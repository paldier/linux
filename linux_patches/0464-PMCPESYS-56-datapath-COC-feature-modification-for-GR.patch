From 8637bafeba20a10b9063c13b4eed24ff27176640 Mon Sep 17 00:00:00 2001
From: thampan <joby.thampan@intel.com>
Date: Wed, 19 Dec 2018 18:26:44 +0800
Subject: [PATCH] PMCPESYS-56: datapath COC feature modification for GRX500 &
 Metering Irq in GSWIP

---
 drivers/net/ethernet/lantiq/Kconfig                |   7 -
 drivers/net/ethernet/lantiq/datapath/Kconfig       |   8 +
 drivers/net/ethernet/lantiq/datapath/datapath.h    |  17 +-
 .../net/ethernet/lantiq/datapath/datapath_api.c    |   4 +-
 .../ethernet/lantiq/datapath/datapath_instance.c   |   3 +
 .../net/ethernet/lantiq/datapath/datapath_misc.c   |  75 +++
 .../net/ethernet/lantiq/datapath/gswip30/Kconfig   |   6 -
 .../net/ethernet/lantiq/datapath/gswip30/Makefile  |   2 +-
 .../lantiq/datapath/gswip30/datapath_coc.c         | 688 ++++-----------------
 .../lantiq/datapath/gswip30/datapath_misc.c        |   3 +
 .../lantiq/datapath/gswip30/datapath_misc.h        |  13 +
 .../lantiq/datapath/gswip30/datapath_proc.c        |   1 +
 .../net/ethernet/lantiq/datapath/gswip31/Kconfig   |   7 -
 .../net/ethernet/lantiq/datapath/gswip31/Makefile  |   2 +-
 .../net/ethernet/lantiq/switch-api/gsw_flow_core.c |   3 +
 .../net/ethernet/lantiq/switch-api/gsw_flow_core.h |  16 +-
 drivers/net/ethernet/lantiq/switch-api/gsw_irq.c   | 595 ++++++++----------
 drivers/net/ethernet/lantiq/switch-api/gsw_reg.h   |   8 +
 include/net/datapath_api.h                         |  17 +-
 include/net/datapath_inst.h                        |   3 +
 include/net/switch_api/gsw_irq.h                   |  22 +-
 21 files changed, 542 insertions(+), 958 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/Kconfig b/drivers/net/ethernet/lantiq/Kconfig
index 06abd1337edc..bf47990fd5f2 100644
--- a/drivers/net/ethernet/lantiq/Kconfig
+++ b/drivers/net/ethernet/lantiq/Kconfig
@@ -39,13 +39,6 @@ config LTQ_ETH_XRX500
         ---help---
         Lantiq Ethernet driver for XRX500 series.
 
-config XRX500_ETH_DRV_COC_SUPPORT
-		bool "CoC support in the ethernet driver"
-        depends on LTQ_ETH_XRX500 && LTQ_DATAPATH_CPUFREQ
-		default n
-		---help---
-		CoC support in the Ethernet driver of XRX500 series
-
 config XRX500_ETH_DRV_THERMAL_SUPPORT
 	bool "ThermaL support in the ethernet driver"
 	depends on LTQ_ETH_XRX500 && THERMAL
diff --git a/drivers/net/ethernet/lantiq/datapath/Kconfig b/drivers/net/ethernet/lantiq/datapath/Kconfig
index 03fc5f3a55ef..99f7162effde 100644
--- a/drivers/net/ethernet/lantiq/datapath/Kconfig
+++ b/drivers/net/ethernet/lantiq/datapath/Kconfig
@@ -135,6 +135,14 @@ config LTQ_DATAPATH_DDR_SIMULATE_GSWIP31
 	depends on LTQ_DATAPATH
 	---help---
 	  test prx300 HAL in GRX350 boards
+
+config LTQ_DATAPATH_CPUFREQ
+	bool "Datapath DFS(COC) support"
+	depends on LTQ_DATAPATH && CPU_FREQ
+	default n
+	---help---
+	  It is to support DFS(COC) in Datapath
+
 source "drivers/net/ethernet/lantiq/datapath/gswip31/Kconfig"
 source "drivers/net/ethernet/lantiq/datapath/gswip30/Kconfig"
 endif
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath.h b/drivers/net/ethernet/lantiq/datapath/datapath.h
index a51a577ca1c6..fe36e9f21503 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath.h
+++ b/drivers/net/ethernet/lantiq/datapath/datapath.h
@@ -333,7 +333,7 @@ enum DP_DBG_FLAG {
 	DP_DBG_ENUM_OR_STRING(DP_DBG_FLAG_MAX, "")\
 }
 
-enum {
+enum QOS_FLAG {
 	NODE_LINK_ADD = 0, /*add a link node */
 	NODE_LINK_GET,     /*get a link node */
 	NODE_LINK_EN_GET,  /*Get link status: enable/disable */
@@ -619,6 +619,14 @@ struct dp_tc_vlan_info {
 	int inst;  /*DP instance */
 };
 
+#ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
+enum CPUFREQ_FLAG {
+	PRE_CHANGE = 0,		/*! Cpufreq transition prechange */
+	POST_CHANGE,		/*! Cpufreq transition postchange */
+	POLICY_NOTIFY,		/*! Cpufreq policy notifier */
+};
+#endif
+
 /*port 0 is reserved*/
 extern int dp_inst_num;
 extern struct inst_property dp_port_prop[DP_MAX_INST];
@@ -671,12 +679,13 @@ void proc_mib_timer_read(struct seq_file *s);
 int mpe_fh_netfiler_install(void);
 int dp_coc_cpufreq_exit(void);
 int dp_coc_cpufreq_init(void);
+int dp_cpufreq_notify_init(int inst);
 int qos_dump_start(void);
 int qos_dump(struct seq_file *s, int pos);
 ssize_t proc_qos_write(struct file *file, const char *buf,
 		       size_t count, loff_t *ppos);
-int update_coc_up_sub_module(enum ltq_cpufreq_state new_state,
-			     enum ltq_cpufreq_state old_state, uint32_t flag);
+int update_coc_up_sub_module(int new_state,
+			     int old_state, uint32_t flag);
 void proc_coc_read(struct seq_file *s);
 ssize_t proc_coc_write(struct file *file, const char *buf, size_t count,
 		       loff_t *ppos);
@@ -741,7 +750,7 @@ void dp_dump_raw_data(char *buf, int len, char *prefix_str);
 int ltq_tso_xmit(struct sk_buff *skb, void *hdr, int len, int flags);
 #endif
 
-int dp_set_meter_rate(enum ltq_cpufreq_state stat, unsigned int rate);
+//int dp_set_meter_rate(enum ltq_cpufreq_state stat, unsigned int rate);
 char *dp_skb_csum_str(struct sk_buff *skb);
 extern struct dentry *dp_proc_node;
 int get_dp_dbg_flag_str_size(void);
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_api.c b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
index 3428cf4e7de3..57f9b11846b3 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_api.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
@@ -1275,8 +1275,8 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 }
 
 #ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
-int update_coc_up_sub_module(enum ltq_cpufreq_state new_state,
-			     enum ltq_cpufreq_state old_state, uint32_t flag)
+int update_coc_up_sub_module(int new_state,
+			     int old_state, uint32_t flag)
 {
 	int i;
 	dp_coc_confirm_stat fn;
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_instance.c b/drivers/net/ethernet/lantiq/datapath/datapath_instance.c
index 923df87aa960..7eb0e925ca38 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_instance.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_instance.c
@@ -137,6 +137,9 @@ int dp_request_inst(struct dp_inst_info *info, u32 flag)
 	DP_DEBUG(DP_DBG_FLAG_INST,
 		 "dp_request_inst ok: inst=%d, dp_inst_num=%d\n",
 		 i, dp_inst_num);
+#ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
+	dp_cpufreq_notify_init(i);
+#endif
 	return 0;
 }
 EXPORT_SYMBOL(dp_request_inst);
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_misc.c b/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
index 620b30180c33..7d39e521c5fe 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
@@ -41,6 +41,15 @@
 #define dp_memcpy(x, y, z)   memcpy(x, y, z)
 #endif
 
+#ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
+#include <linux/cpufreq.h>
+static int dp_coc_inst;
+static int dp_coc_cpufreq_transition_notifier(struct notifier_block *nb,
+					      unsigned long event, void *data);
+static int dp_coc_cpufreq_policy_notifier(struct notifier_block *nb,
+					  unsigned long event, void *data);
+#endif
+
 struct hlist_head dp_subif_list[DP_SUBIF_LIST_HASH_SIZE];
 char *parser_flags_str[] = {
 	"PARSER_FLAGS_NO",
@@ -1410,3 +1419,69 @@ int32_t dp_sync_subifid_priv(struct net_device *dev, char *subif_name,
 	}
 	return 0;
 }
+
+#ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
+static int dp_coc_cpufreq_policy_notifier(struct notifier_block *nb,
+					  unsigned long event, void *data)
+{
+	struct cpufreq_policy *policy = data;
+	DP_DEBUG(DP_DBG_FLAG_COC,"%s; cpu=%d\n",
+		 event ? "CPUFREQ_NOTIFY" : "CPUFREQ_ADJUST",
+		 policy->cpu);
+	if (event != CPUFREQ_ADJUST) {
+		DP_DEBUG(DP_DBG_FLAG_COC, "policy (min, max, cur):%u, %u, %u\n",
+			 policy->min, policy->max, policy->cur);
+		return NOTIFY_DONE;
+	}
+	if (!dp_port_prop[dp_coc_inst].info.dp_handle_cpufreq_event)
+		return NOTIFY_OK;
+	return
+	dp_port_prop[dp_coc_inst].info.dp_handle_cpufreq_event(POLICY_NOTIFY, policy);
+}
+
+/* keep track of frequency transitions */
+static int dp_coc_cpufreq_transition_notifier(struct notifier_block *nb,
+					      unsigned long event, void *data)
+{
+	struct cpufreq_freqs *freq = data;
+	if (event == CPUFREQ_PRECHANGE) {
+		if (!dp_port_prop[dp_coc_inst].info.dp_handle_cpufreq_event)
+			return NOTIFY_STOP_MASK;
+		return dp_port_prop[dp_coc_inst].info.
+					dp_handle_cpufreq_event(PRE_CHANGE, freq);
+	} else if (event == CPUFREQ_POSTCHANGE) {
+		if (!dp_port_prop[dp_coc_inst].info.dp_handle_cpufreq_event)
+			return NOTIFY_STOP_MASK;
+		return dp_port_prop[dp_coc_inst].info.
+					dp_handle_cpufreq_event(POST_CHANGE, freq);
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block dp_coc_cpufreq_transition_notifier_block = {
+	.notifier_call = dp_coc_cpufreq_transition_notifier
+};
+
+static struct notifier_block dp_coc_cpufreq_policy_notifier_block = {
+	.notifier_call = dp_coc_cpufreq_policy_notifier
+};
+
+int dp_cpufreq_notify_init(int inst)
+{
+	
+	dp_coc_inst = inst;
+	if (cpufreq_register_notifier
+	    (&dp_coc_cpufreq_transition_notifier_block,
+	    CPUFREQ_TRANSITION_NOTIFIER)) {
+		PR_ERR("cpufreq_register_notifier failed?\n");
+		return -1;
+	}
+	if (cpufreq_register_notifier
+	    (&dp_coc_cpufreq_policy_notifier_block,
+	    CPUFREQ_POLICY_NOTIFIER)) {
+		PR_ERR("cpufreq_register_notifier failed?\n");
+		return -1;
+	}
+	return 0;
+}
+#endif
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip30/Kconfig b/drivers/net/ethernet/lantiq/datapath/gswip30/Kconfig
index 1a081c65ddb4..eab61ae22d7b 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip30/Kconfig
+++ b/drivers/net/ethernet/lantiq/datapath/gswip30/Kconfig
@@ -16,10 +16,4 @@ config LTQ_DATAPATH_HAL_GSWIP30_MIB
 	---help---
 	  It is to aggregate GSWIP-L/R, TMU and driver's MIB counter
 
-config LTQ_DATAPATH_HAL_GSWIP30_CPUFREQ
-	bool "Datapath DFS(COC) support"
-	depends on LTQ_DATAPATH && LTQ_CPUFREQ && LTQ_ETHSW_API
-	default y
-	---help---
-	  It is to support DFS(COC) in Datapath
 endif
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip30/Makefile b/drivers/net/ethernet/lantiq/datapath/gswip30/Makefile
index 4827ba29537e..d87291f9acf0 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip30/Makefile
+++ b/drivers/net/ethernet/lantiq/datapath/gswip30/Makefile
@@ -4,7 +4,7 @@ ifneq ($(CONFIG_LTQ_DATAPATH_HAL_GSWIP30_MIB),)
 obj-$(CONFIG_LTQ_DATAPATH) += datapath_mib.o
 endif
 
-ifneq ($(CONFIG_LTQ_DATAPATH_HAL_GSWIP30_COC),)
+ifneq ($(CONFIG_LTQ_DATAPATH_CPUFREQ),)
 obj-$(CONFIG_LTQ_DATAPATH) += datapath_coc.o
 endif
 
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_coc.c b/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_coc.c
index 73e3f528bddc..a2fe55210a1a 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_coc.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_coc.c
@@ -11,30 +11,24 @@
 #include <linux/module.h>
 #include <linux/types.h>	/* size_t */
 #include <linux/timer.h>
+#include <linux/cpufreq.h>
 #include <net/datapath_api.h>
 #include <net/datapath_proc_api.h>
 #include "../datapath.h"
+#include "datapath_misc.h"
 
 #define DP_MODULE  LTQ_CPUFREQ_MODULE_DP
 #define DP_ID 0	 /* this ID should represent the Datapath interface No. */
-static struct timer_list dp_coc_timer;
-static u32 polling_period;	/*seconds */
-static int rmon_timer_en;
+#define LTQ_CPUFREQ_PS_D0 0
+#define LTQ_CPUFREQ_PS_D3 3
 static spinlock_t dp_coc_lock;
 
-/* threshold data for D0:D3 */
-struct ltq_cpufreq_threshold rmon_threshold = { 0, 30, 20, 10 }; /*packets */
-
 /* driver is busy and needs highest performance */
 static int dp_coc_init_stat;	/*DP COC is Initialized or not */
 static int dp_coc_ena;		/*DP COC is enabled or not */
-enum ltq_cpufreq_state dp_coc_ps_curr = LTQ_CPUFREQ_PS_UNDEF;/*current state*/
-/*new statue wanted to switch to */
-enum ltq_cpufreq_state dp_coc_ps_new = LTQ_CPUFREQ_PS_UNDEF;
-
-static GSW_RMON_Port_cnt_t rmon_last[PMAC_MAX_NUM];
-static u64 last_rmon_rx;
+int dp_coc_ps_curr = -1;/*current state*/
 
+int inst = 0;
 /*meter */
 #define PCE_OVERHD 20
 static u32 meter_id;
@@ -43,34 +37,20 @@ static u32 meter_ncbs = 0x8000 + (1514 + PCE_OVERHD) * 3 + 200;
 /*1 ~ 2 packet size */
 static u32 meter_nebs = 0x8000 + (1514 + PCE_OVERHD) * 1 + 200;
 /*k bits */
-static u32 meter_nrate[4] = { 0/*D0 */, 700/*D1*/, 600/*D2*/, 500/*D3*/};
-
-static int dp_coc_cpufreq_notifier(struct notifier_block *nb,
-				   unsigned long val, void *data);
-static int dp_coc_stateget(enum ltq_cpufreq_state *state);
-static int dp_coc_fss_ena(int ena);
-static int apply_meter_rate(u32 rate, enum ltq_cpufreq_state new_state);
-static int enable_meter_interrupt(void);
-static int clear_meter_interrupt(void);
-int dp_set_meter_rate(enum ltq_cpufreq_state stat, unsigned int rate)
+static u32 meter_nrate[2] = { 0/*D0 */, 500/*D3*/};
+
+static int apply_meter_rate(u32 rate, unsigned int new_state);
+
+int dp_set_meter_rate(int stat, unsigned int rate)
 {/*set the rate for upscaling to D0 from specified stat */
-	if (stat == LTQ_CPUFREQ_PS_D1)
+	if (stat == LTQ_CPUFREQ_PS_D3)
 		meter_nrate[1] = rate;
-	else if (stat == LTQ_CPUFREQ_PS_D2)
-		meter_nrate[2] = rate;
-	else if (stat == LTQ_CPUFREQ_PS_D3)
-		meter_nrate[3] = rate;
 	else
 		return -1;
-	if (dp_coc_ps_curr == stat)
+	//if (dp_coc_ps_curr == stat)
 		apply_meter_rate(-1, stat);
 	return 0;
 }
-EXPORT_SYMBOL(dp_set_meter_rate);
-
-static struct notifier_block dp_coc_cpufreq_notifier_block = {
-	.notifier_call = dp_coc_cpufreq_notifier
-};
 
 static inline void coc_lock(void)
 {
@@ -86,307 +66,16 @@ static inline void coc_unlock(void)
 	spin_unlock_bh(&dp_coc_lock);
 }
 
-struct ltq_cpufreq_module_info dp_coc_feature_fss = {
-	.name = "Datapath FSS",
-	.pmcuModule = DP_MODULE,
-	.pmcuModuleNr = DP_ID,
-	.powerFeatureStat = 1,
-	.ltq_cpufreq_state_get = dp_coc_stateget,
-	.ltq_cpufreq_pwr_feature_switch = dp_coc_fss_ena,
-};
-
-#if defined(CONFIG_LTQ_DATAPATH_DBG) && CONFIG_LTQ_DATAPATH_DBG
-static char *get_sub_module_str(uint32_t flag)
-{
-	if (flag == DP_COC_REQ_DP)
-		return "DP";
-	else if (flag == DP_COC_REQ_ETHERNET)
-		return "Ethernet";
-	else if (flag == DP_COC_REQ_VRX318)
-		return "VRX318";
-	else
-		return "Unknown";
-}
-#endif
-
-static char *get_coc_stat_string(enum ltq_cpufreq_state stat)
+static char *get_coc_stat_string(int stat)
 {
 	if (stat == LTQ_CPUFREQ_PS_D0)
 		return "D0";
-	else if (stat == LTQ_CPUFREQ_PS_D1)
-		return "D1";
-	else if (stat == LTQ_CPUFREQ_PS_D2)
-		return "D2";
 	else if (stat == LTQ_CPUFREQ_PS_D3)
 		return "D3";
-	else if (stat == LTQ_CPUFREQ_PS_D0D3)
-		return "D0D3-NotCare";
-	else if (stat == LTQ_CPUFREQ_PS_BOOST)
-		return "Boost";
 	else
 		return "Undef";
 }
 
-static void dp_rmon_polling(unsigned long data)
-{
-	GSW_RMON_Port_cnt_t curr;
-	int i;
-	u64 rx = 0;
-
-	for (i = 0; i < PMAC_MAX_NUM; i++) {
-		memset(&curr, 0, sizeof(curr));
-		get_gsw_port_rmon(i, GSWIP_R, &curr);
-
-		coc_lock();
-		/*wrapround handling */
-		if (curr.nRxGoodPkts >= rmon_last[i].nRxGoodPkts)
-			rx += curr.nRxGoodPkts - rmon_last[i].nRxGoodPkts;
-		else
-			rx +=
-			    (u64)0xFFFFFFFF + (u64)curr.nRxGoodPkts -
-			    rmon_last[i].nRxGoodPkts;
-
-		if (curr.nRxDroppedPkts >= rmon_last[i].nRxDroppedPkts)
-			rx +=
-			    curr.nRxDroppedPkts - rmon_last[i].nRxDroppedPkts;
-		else
-			rx +=
-			    (u64)0xFFFFFFFF + (u64)curr.nRxDroppedPkts -
-			    rmon_last[i].nRxDroppedPkts;
-
-		memcpy(&rmon_last[i], &curr, sizeof(curr));
-		coc_unlock();
-	}
-	last_rmon_rx = rx;
-	if (dp_coc_ps_curr != LTQ_CPUFREQ_PS_UNDEF) {
-		if (rx < rmon_threshold.th_d3) {
-			if (dp_coc_new_stat_req
-			    (LTQ_CPUFREQ_PS_D3, DP_COC_REQ_DP) == 0) {
-				coc_lock();
-				rmon_timer_en = 0;
-				coc_unlock();
-				DP_DEBUG(DP_DBG_FLAG_COC,
-					 "Request to D3:rx (%u) < th_d3 %d\n",
-					 (unsigned int)rx,
-					 rmon_threshold.th_d3);
-			} else
-				DP_DEBUG(DP_DBG_FLAG_COC,
-					 "req to D3 fail for dp_coc_new_stat_req\n");
-		} else if (rx < rmon_threshold.th_d2) {
-			if (dp_coc_new_stat_req
-			    (LTQ_CPUFREQ_PS_D2, DP_COC_REQ_DP) == 0) {
-				DP_DEBUG(DP_DBG_FLAG_COC,
-					 "req to D2: rx (%u) < th_d2 %d\n",
-					 (unsigned int)rx,
-					 rmon_threshold.th_d2);
-			} else
-				DP_DEBUG(DP_DBG_FLAG_COC,
-					 "req to D2 fail for dp_coc_new_stat_req\n");
-		} else if (rx < rmon_threshold.th_d1) {
-			if (dp_coc_new_stat_req
-			    (LTQ_CPUFREQ_PS_D1, DP_COC_REQ_DP) == 0) {
-				DP_DEBUG(DP_DBG_FLAG_COC,
-					 "req to D1 since rx (%u) < th_d1 %d\n",
-					 (unsigned int)rx,
-					 rmon_threshold.th_d1);
-			} else
-				DP_DEBUG(DP_DBG_FLAG_COC,
-					 "req to D1 fail: dp_coc_new_stat_req\n");
-		} else
-			DP_DEBUG(DP_DBG_FLAG_COC,
-				 "Stat no change:rx(%u)>=any thresholds %d_%d_%d\n",
-				 (unsigned int)rx, rmon_threshold.th_d3,
-				 rmon_threshold.th_d2, rmon_threshold.th_d1);
-	} else
-		DP_DEBUG(DP_DBG_FLAG_COC,
-			 "DP COC not get its initial power state yet\n");
-
-	coc_lock();
-
-	if (rmon_timer_en)
-		mod_timer(&dp_coc_timer,
-			  jiffies + msecs_to_jiffies(polling_period * 1000));
-	else
-		last_rmon_rx = 0;
-
-	coc_unlock();
-}
-
-static int dp_coc_stateget(enum ltq_cpufreq_state *state)
-{
-	DP_DEBUG(DP_DBG_FLAG_COC, "dp_coc_stateget with %d(%s)\n",
-		 dp_coc_ps_curr, get_coc_stat_string(dp_coc_ps_curr));
-	coc_lock();
-	*state = dp_coc_ps_curr;
-	coc_unlock();
-	return LTQ_CPUFREQ_RETURN_SUCCESS;
-}
-
-static int dp_coc_fss_ena(int ena)
-{
-	DP_DEBUG(DP_DBG_FLAG_COC,
-		 "dp_coc_fss_ena: %d(%s frequency scaling)\n", ena,
-		 ena ? "enable" : "disable");
-	coc_lock();
-	dp_coc_ena = ena;
-	coc_unlock();
-	return LTQ_CPUFREQ_RETURN_SUCCESS;
-}
-
-void update_rmon_last(void)
-{
-	int i;
-
-	for (i = 0; i < PMAC_MAX_NUM; i++)
-		get_gsw_port_rmon(i, GSWIP_R, &rmon_last[i]);
-}
-
-int update_coc_rmon_timer(enum ltq_cpufreq_state new_state, uint32_t flag)
-{
-	if (new_state == LTQ_CPUFREQ_PS_D0) {
-		/*enable rmon timer */
-		if (!rmon_timer_en)
-			update_rmon_last();
-		mod_timer(&dp_coc_timer,
-			  jiffies + msecs_to_jiffies(polling_period * 1000));
-		rmon_timer_en = 1;
-
-		/*disable meter */
-		apply_meter_rate(0, 0);
-	} else if (new_state == LTQ_CPUFREQ_PS_D1 ||
-		   new_state == LTQ_CPUFREQ_PS_D2) {
-		/*enable rmon timer */
-		if (!rmon_timer_en)
-			update_rmon_last();
-		mod_timer(&dp_coc_timer,
-			  jiffies + msecs_to_jiffies(polling_period * 1000));
-		rmon_timer_en = 1;
-
-		/*enable meter, but first disable to fix red color issue
-		 * if last already triggered
-		 */
-		apply_meter_rate(0, 0);
-		apply_meter_rate(-1, new_state);	/*enable again */
-	} else if (new_state == LTQ_CPUFREQ_PS_D3) {
-		/*disable rmon timer */
-		del_timer(&dp_coc_timer);
-		rmon_timer_en = 0;
-		last_rmon_rx = 0;
-
-		/*enable meter */
-		/*enable meter, but first disable to fix red color issue
-		 * if last already triggered
-		 */
-		apply_meter_rate(0, 0);
-		apply_meter_rate(-1, new_state);	/*enable again */
-	}
-
-	return 0;
-}
-
-static int update_coc_cfg(enum ltq_cpufreq_state new_state,
-			  enum ltq_cpufreq_state old_state, uint32_t flag)
-{
-	update_coc_up_sub_module(new_state, old_state, flag);
-	update_coc_rmon_timer(new_state, flag);
-	return 0;
-}
-
-static int dp_coc_prechange(enum ltq_cpufreq_module module,
-			    enum ltq_cpufreq_state new_state,
-			    enum ltq_cpufreq_state old_state, u8 flags)
-{
-	int res = -1;
-
-	/*check whether can be switched or not */
-	if (!dp_coc_init_stat || !dp_coc_ena) {
-		res = 0;
-	} else if ((flags & CPUFREQ_PM_NO_DENY) ||
-		   (dp_coc_ps_curr == LTQ_CPUFREQ_PS_UNDEF) ||
-		   (dp_coc_ps_new == LTQ_CPUFREQ_PS_UNDEF) ||
-		   (dp_coc_ps_new == LTQ_CPUFREQ_PS_D0D3)) { /*accept */
-		res = 0;
-	} else if (dp_coc_ps_new >= new_state) {
-		/* Accept any upscale request */
-		res = 0;
-	}
-
-	DP_DEBUG(DP_DBG_FLAG_COC,
-		 "dp_coc_prechange:%s to switch from %s to %s\n",
-		 res ? "Deny" : "Accept", get_coc_stat_string(old_state),
-		 get_coc_stat_string(new_state));
-
-	return res;
-}
-
-static int dp_coc_postchange(enum ltq_cpufreq_module module,
-			     enum ltq_cpufreq_state new_state,
-			     enum ltq_cpufreq_state old_state, u8 flags)
-{
-	if (!dp_coc_init_stat || !dp_coc_ena)
-		return 0;
-
-	DP_DEBUG(DP_DBG_FLAG_COC, "dp_coc_postchange:switch from %s to %s\n",
-		 get_coc_stat_string(old_state),
-		 get_coc_stat_string(new_state));
-
-	coc_lock();
-	dp_coc_ps_curr = new_state;
-	dp_coc_ps_new = LTQ_CPUFREQ_PS_UNDEF;
-	update_coc_cfg(new_state, old_state, flags);/*don't lock before it */
-	coc_unlock();
-
-	return 0;
-}
-
-/* keep track of frequency transitions */
-static int dp_coc_cpufreq_notifier(struct notifier_block *nb,
-				   unsigned long val, void *data)
-{
-	struct cpufreq_freqs *freq = data;
-	enum ltq_cpufreq_state new_state, old_state;
-
-	new_state = ltq_cpufreq_get_ps_from_khz(freq->new);
-
-	if (new_state == LTQ_CPUFREQ_PS_UNDEF) {
-		DP_DEBUG(DP_DBG_FLAG_COC,
-			 "dp_coc_cpufreq_notifier new_state=UNDEF with val=%u\n",
-			 (unsigned int)val);
-		return NOTIFY_STOP_MASK | (DP_MODULE << 4);
-	}
-
-	old_state = ltq_cpufreq_get_ps_from_khz(freq->old);
-
-	if (old_state == LTQ_CPUFREQ_PS_UNDEF) {
-		DP_DEBUG(DP_DBG_FLAG_COC,
-			 "new_state=%s old_state=UNDEF with val=%u\n",
-			 get_coc_stat_string(new_state), (unsigned int)val);
-		return NOTIFY_STOP_MASK | (DP_MODULE << 4);
-	}
-
-	if (val == CPUFREQ_PRECHANGE) {
-		DP_DEBUG(DP_DBG_FLAG_COC,
-			 "dp_coc_cpufreq_notifier prechange from %s to %s\n",
-			 get_coc_stat_string(old_state),
-			 get_coc_stat_string(new_state));
-
-		if (dp_coc_prechange
-		    (DP_MODULE, new_state, old_state, freq->flags))
-			return NOTIFY_STOP_MASK | (DP_MODULE << 4);
-	} else if (val == CPUFREQ_POSTCHANGE) {
-		DP_DEBUG(DP_DBG_FLAG_COC,
-			 "dp_coc_cpufreq_notifier postchange from %s to %s\n",
-			 get_coc_stat_string(old_state),
-			 get_coc_stat_string(new_state));
-
-		if (dp_coc_postchange
-		    (DP_MODULE, new_state, old_state, freq->flags))
-			return NOTIFY_STOP_MASK | (DP_MODULE << 4);
-	}
-
-	return NOTIFY_OK | (DP_MODULE << 4);
-}
-
 void proc_coc_read(struct seq_file *s)
 {
 	GSW_register_t reg;
@@ -399,22 +88,11 @@ void proc_coc_read(struct seq_file *s)
 	seq_puts(s, "  Basic DP COC Info:\n");
 	seq_printf(s, "    dp_coc_ena=%d @ 0x%p (DP %s)\n", dp_coc_ena,
 		   &dp_coc_ena, dp_coc_ena ? "COC Enabled" : "COC Disabled");
-	seq_printf(s, "    Rmon timer interval: %u sec (Timer %s)\n",
-		   (unsigned int)polling_period,
-		   rmon_timer_en ? "enabled" : "disabled");
-	/*seq_printf(s, "    RMON D0 Threshold: %d\n", rmon_threshold.th_d0); */
-	seq_printf(s, "    RMON D1 Threshold: %d\n", rmon_threshold.th_d1);
-	seq_printf(s, "    RMON D2 Threshold: %d\n", rmon_threshold.th_d2);
-	seq_printf(s, "    RMON D3 Threshold: %d\n", rmon_threshold.th_d3);
 	seq_printf(s, "    dp_coc_init_stat=%d @ %p (%s)\n", dp_coc_init_stat,
 		   &dp_coc_init_stat,
 		   dp_coc_init_stat ? "initialized ok" : "Not initialized");
 	seq_printf(s, "    dp_coc_ps_curr=%d (%s) @ 0x%p\n", dp_coc_ps_curr,
 		   get_coc_stat_string(dp_coc_ps_curr), &dp_coc_ps_curr);
-	seq_printf(s, "    dp_coc_ps_new=%d (%s)@ 0x%p\n", dp_coc_ps_new,
-		   get_coc_stat_string(dp_coc_ps_new), &dp_coc_ps_new);
-	seq_printf(s, "    last_rmon_rx=%llu pkts@ 0x%p (%s)\n", last_rmon_rx,
-		   &last_rmon_rx, rmon_timer_en ? "Valid" : "Not valid");
 
 	seq_puts(s, "    Metering Info:\n");
 	/*PCE_OVERHD */
@@ -434,9 +112,7 @@ void proc_coc_read(struct seq_file *s)
 	seq_printf(s, "    meter nRate=%u\n", meter_cfg.nRate);
 	seq_printf(s, "    meter nPiRate=%u\n", meter_cfg.nPiRate);
 	seq_printf(s, "    meter eMtrType=%u\n", (int)meter_cfg.eMtrType);
-	seq_printf(s, "    D1 nRate=%u\n", meter_nrate[1]);
-	seq_printf(s, "    D2 nRate=%u\n", meter_nrate[2]);
-	seq_printf(s, "    D3 nRate=%u\n", meter_nrate[3]);
+	seq_printf(s, "    D3 nRate=%u\n", meter_nrate[1]);
 
 	memset(&reg, 0, sizeof(reg));
 	reg.nRegAddr = 0x489 + meter_id * 10;
@@ -446,26 +122,7 @@ void proc_coc_read(struct seq_file *s)
 		   reg.nRegAddr, reg.nData, reg.nData,
 		   (reg.nData & 0x100) ? "on" : "off");
 
-	memset(&reg, 0, sizeof(reg));
-	reg.nRegAddr = 0xE11;
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.RegisterGet,
-		     gsw_handle, &reg);
-	seq_printf(s, "    GSW_PCE_TCM_STAT(0x%x)=%u(0x%x)-backpress %s\n",
-		   reg.nRegAddr, reg.nData, reg.nData,
-		   (reg.nData & 1) ? "on" : "off");
-}
-
-int dp_set_rmon_threshold(struct ltq_cpufreq_threshold *threshold,
-			  uint32_t flags)
-{
-	if (!threshold)
-		return -1;
-
-	memcpy((void *)&rmon_threshold, (void *)threshold,
-	       sizeof(rmon_threshold));
-	return 0;
 }
-EXPORT_SYMBOL(dp_set_rmon_threshold);
 
 ssize_t proc_coc_write(struct file *file, const char *buf, size_t count,
 		       loff_t *ppos)
@@ -473,7 +130,6 @@ ssize_t proc_coc_write(struct file *file, const char *buf, size_t count,
 	int len, num;
 	char str[64];
 	char *param_list[3];
-#define MIN_POLL_TIME 1
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
@@ -482,66 +138,7 @@ ssize_t proc_coc_write(struct file *file, const char *buf, size_t count,
 	str[len] = 0;
 
 	num = dp_split_buffer(str, param_list, ARRAY_SIZE(param_list));
-	if (dp_strncmpi(param_list[0], "timer", strlen("timer")) == 0) {
-		polling_period = dp_atoi(param_list[1]);
-
-		if (polling_period < MIN_POLL_TIME)
-			polling_period = MIN_POLL_TIME;
-
-		coc_lock();
-
-		if (rmon_timer_en) {
-			mod_timer(&dp_coc_timer,
-				  jiffies +
-				  msecs_to_jiffies(polling_period * 1000));
-		}
-
-		coc_unlock();
-	} else if (dp_strncmpi(param_list[0],
-			"threshold0", strlen("threshold0")) == 0) {
-		coc_lock();
-		rmon_threshold.th_d0 = dp_atoi(param_list[1]);
-
-		if (!rmon_threshold.th_d0)
-			rmon_threshold.th_d0 = 1;
-
-		coc_unlock();
-	} else if (dp_strncmpi(param_list[0],
-			"threshold1", strlen("threshold1")) == 0) {
-		coc_lock();
-		rmon_threshold.th_d1 = dp_atoi(param_list[1]);
-
-		if (!rmon_threshold.th_d1)
-			rmon_threshold.th_d1 = 1;
-
-		coc_unlock();
-	} else if (dp_strncmpi(param_list[0],
-			"threshold2", strlen("threshold2")) == 0) {
-		coc_lock();
-		rmon_threshold.th_d2 = dp_atoi(param_list[1]);
-
-		if (!rmon_threshold.th_d2)
-			rmon_threshold.th_d2 = 1;
-
-		coc_unlock();
-	} else if (dp_strncmpi(param_list[0],
-			"threshold3", strlen("threshold3")) == 0) {
-		coc_lock();
-		rmon_threshold.th_d3 = dp_atoi(param_list[1]);
-
-		if (!rmon_threshold.th_d3)
-			rmon_threshold.th_d3 = 1;
-
-		coc_unlock();
-	} else if (dp_strncmpi(param_list[0], "D0", 2) == 0) {
-		dp_coc_new_stat_req(LTQ_CPUFREQ_PS_D0, DP_COC_REQ_DP);
-	} else if (dp_strncmpi(param_list[0], "D1", 2) == 0) {
-		dp_coc_new_stat_req(LTQ_CPUFREQ_PS_D1, DP_COC_REQ_DP);
-	} else if (dp_strncmpi(param_list[0], "D2", 2) == 0) {
-		dp_coc_new_stat_req(LTQ_CPUFREQ_PS_D2, DP_COC_REQ_DP);
-	} else if (dp_strncmpi(param_list[0], "D3", 2) == 0) {
-		dp_coc_new_stat_req(LTQ_CPUFREQ_PS_D3, DP_COC_REQ_DP);
-	} else if (dp_strncmpi(param_list[0], "rate", strlen("rate")) == 0) {
+	if (dp_strncmpi(param_list[0], "rate", strlen("rate") + 1) == 0) {
 		/*meter rate */
 		u32 rate = dp_atoi(param_list[1]);
 
@@ -549,56 +146,26 @@ ssize_t proc_coc_write(struct file *file, const char *buf, size_t count,
 			PR_INFO("rate should not be zero\n");
 			return count;
 		}
-		if (dp_strncmpi(param_list[0], "rate1", strlen("rate1")) == 0) {
-			dp_set_meter_rate(LTQ_CPUFREQ_PS_D1, rate);
-
-		} else if (dp_strncmpi(param_list[0],
-				"rate2",
-				strlen("rate2")) == 0) {
-			dp_set_meter_rate(LTQ_CPUFREQ_PS_D2, rate);
-		} else if ((dp_strncmpi(param_list[0],
-				"rate3",
-				strlen("rate3")) == 0) ||
-			   (dp_strncmpi(param_list[0],
-			   "rate",
-			   strlen("rate")) == 0)) { /*back-compatiable */
+		if (dp_strncmpi(param_list[0], "rate3", strlen("rate3") + 1) 
+									== 0) {
 			dp_set_meter_rate(LTQ_CPUFREQ_PS_D3, rate);
+
 		} else {
 			PR_INFO
-			    ("Wrong COC state, it should be D1/D2/D3 only\n");
+			    ("Wrong COC state, it should be D3 only\n");
 		}
-	} else if (dp_strncmpi(param_list[0],
-			"interrupt", strlen("interrupt")) == 0) {/*meter */
-		enable_meter_interrupt();
-		PR_INFO("Enabled meter interurpt\n");
-	} else if (dp_strncmpi(param_list[0],
-			"clear", strlen("clear")) == 0) {	/*meter */
-		clear_meter_interrupt();
-		PR_INFO("Clear meter interurpt src\n");
 	} else {
 		goto help;
 	}
 	return count;
-
  help:
 	PR_INFO("Datapath COC Proc Usage:\n");
-	PR_INFO("  echo timer polling_interval_in_seconds > /proc/dp/coc\n");
-	PR_INFO("  echo <thresholdx> its_threshold_value > /proc/dp/coc\n");
-	PR_INFO("       Note:Valid x of ranage: 1 2 3\n");
-	PR_INFO
-	    ("            For downscale to D<x> if rmon<threshold<x>'s cfg\n");
-	PR_INFO("            threshold1's >= threshold'2 > threshold'3\n");
 	PR_INFO("  echo <ratex> <meter_rate_in_knps> /proc/dp/coc\n");
-	PR_INFO("       Note:Valid x of ranage: 1 2 3\n");
-	PR_INFO
-	  ("            For upscale to D0 from D<x> if rmon>=rate<x>'s cfg\n");
-	PR_INFO("            Rate1's >= Rate2's > D3's threshold\n");
-	PR_INFO
-	  ("  echo interrupt > /proc/dp/coc:enable/disable meter interrupt\n");
-	PR_INFO("  echo clear > /proc/dp/coc  :clear meter interrupt\n");
+	PR_INFO("       Note:Valid x of range: 3\n");
 	return count;
 }
 
+#if defined(DATAPATH_ENABLE_CPU)
 int clear_meter_interrupt(void)
 {
 	GSW_register_t reg;
@@ -652,16 +219,19 @@ int enable_meter_interrupt(void)
 
 	return 0;
 }
+#endif
 
 /* rate      0: disable meter
  * -1: enable meter
  * others: really change rate.
  */
-int apply_meter_rate(u32 rate, enum ltq_cpufreq_state new_state)
+int apply_meter_rate(u32 rate, unsigned int new_state)
 {
 	GSW_QoS_meterCfg_t meter_cfg;
 	struct core_ops *gsw_handle;
 
+	DP_DEBUG(DP_DBG_FLAG_COC,
+		 "rate=%d new state=%d\n", rate, new_state);
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
 	memset(&meter_cfg, 0, sizeof(meter_cfg));
 	meter_cfg.nMeterId = meter_id;
@@ -672,18 +242,10 @@ int apply_meter_rate(u32 rate, enum ltq_cpufreq_state new_state)
 	} else if (rate == -1) {
 		meter_cfg.bEnable = 1;
 		/*set PAE metering */
-		if (new_state == LTQ_CPUFREQ_PS_D1) {
+		if (new_state == LTQ_CPUFREQ_PS_D3) {
 			meter_cfg.nRate = meter_nrate[1];
-		} else if (new_state == LTQ_CPUFREQ_PS_D2) {
-			meter_cfg.nRate = meter_nrate[2];
-		} else if (new_state == LTQ_CPUFREQ_PS_D3) {
-			meter_cfg.nRate = meter_nrate[3];
 		} else {
-			DP_DEBUG(DP_DBG_FLAG_COC,
-				 "Why still try to enable meter with status %s\n",
-				 get_coc_stat_string(dp_coc_ps_curr));
-
-			return -1;
+			meter_cfg.nRate = new_state;
 		}
 	} else {
 		return -1;
@@ -736,7 +298,7 @@ int meter_set_default(void)
 	meter_cfg.nMeterId = meter_id;
 	meter_cfg.nCbs = meter_ncbs;
 	meter_cfg.nEbs = meter_nebs;
-	meter_cfg.nRate = meter_nrate[3];
+	meter_cfg.nRate = meter_nrate[1];
 	meter_cfg.nPiRate = 0xFFFFFF; /* try to set maximum */
 	meter_cfg.eMtrType = GSW_QOS_Meter_trTCM;
 	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_MeterCfgSet,
@@ -784,7 +346,8 @@ int meter_set_default(void)
 		wred_q.nQueueId = i;
 		gsw_core_api((dp_gsw_cb)gsw_handle->gsw_qos_ops
 			     .QoS_WredQueueCfgGet, gsw_handle,
-			     &tmp);
+			     &wred_q);
+
 		wred_q.nYellow_Min = wred_q.nGreen_Min;
 		wred_q.nYellow_Max = wred_q.nGreen_Max;
 		wred_q.nRed_Min = wred_q.nGreen_Min;
@@ -819,118 +382,112 @@ int meter_set_default(void)
 	return 0;
 }
 
-/* For Datapth's sub-module to request power state change, esp for
- *  Ethernet/VRX318 driver to call it if there is state change needed.
- *   The flag can be:
- *     DP_COC_REQ_DP
- *     DP_COC_REQ_ETHERNET
- *     DP_COC_REQ_VRX318
- */
-int dp_coc_new_stat_req(enum ltq_cpufreq_state new_state, uint32_t flag)
+static int dp_coc_prechange(struct cpufreq_freqs *freq)
 {
-	int ret;
-
-	DP_DEBUG(DP_DBG_FLAG_COC,
-		 "SubModular [%s] requesting to switch from %s to %s\n",
-		 get_sub_module_str(flag),
-		 get_coc_stat_string(dp_coc_ps_curr),
-		 get_coc_stat_string(new_state));
+	int res = -1;
 
-	if (unlikely(in_irq())) {
-		PR_ERR
-		    ("Not allowed to cal dp_coc_new_stat_req in_irq mode\n");
-		return -1;
+	/*check whether can be switched or not
+	 * and accept the request 
+	 */
+	if (!dp_coc_init_stat || !dp_coc_ena) {
+		res = 0;
 	}
+	DP_DEBUG(DP_DBG_FLAG_COC,
+	         "dp_coc_prechange:to switch from %d to %d\n",
+		 freq->old, freq->new);
 
-	if (!dp_coc_init_stat) {
-		PR_ERR("COC is not initialized yet in DP\n");
-		return -1;
-	}
+	return res;
+}
 
-	if (!dp_coc_ena) {
-		PR_ERR("COC is not enabled in DP yet\n");
-		return -1;
-	}
+static int dp_coc_postchange(struct cpufreq_freqs *freq)
+{
+	if (!dp_coc_init_stat || !dp_coc_ena)
+		return 0;
 
 	coc_lock();
+	if (dp_coc_ps_curr > freq->new) {/*changing to low freq, enable meter*/
+		DP_DEBUG(DP_DBG_FLAG_COC, "enable meter new_freq=%d\n",
+			 freq->new);
+		apply_meter_rate(-1, freq->new);
+	} else if (dp_coc_ps_curr < freq->new) { /*changing to high freq, disable meter*/
+		DP_DEBUG(DP_DBG_FLAG_COC, "disable meter new_freq=%d\n",
+			 freq->new);
+		apply_meter_rate(0, 0);
+	} 
+	dp_coc_ps_curr = freq->new;
+	coc_unlock();
 
-	if (dp_coc_ps_curr == new_state) {
-		/*Workaround: if no change but this API still is called,
-		 *it means need to update interrupt enable/disable status
-		 */
-		DP_DEBUG(DP_DBG_FLAG_COC, "No change\n");
-		update_coc_cfg(new_state, new_state, flag);
-		coc_unlock();
-		return 0;
-	}
+	return 0;
+}
 
-	dp_coc_ps_new = new_state;
-	coc_unlock();
+static int dp_coc_policy_notify(struct cpufreq_policy *policy)
+{
+	if (dp_coc_ps_curr == -1) {
+		dp_coc_ps_curr = policy->max;
+	} else if (dp_coc_ps_curr <= policy->min) {
+		/*No down scaling allowed, limit the frequency to max */
+		cpufreq_verify_within_limits(policy, policy->max, policy->max);
+	} else {
+		return NOTIFY_OK;
+	}
 
-	DP_DEBUG(DP_DBG_FLAG_COC, "ltq_cpufreq_state_req(%d,%d,%d)\n",
-		 DP_MODULE, DP_ID, new_state);
-	ret = ltq_cpufreq_state_req(DP_MODULE, DP_ID, new_state);
+	return NOTIFY_OK;
+}
 
-	if (ret != LTQ_CPUFREQ_RETURN_SUCCESS) {
-		DP_DEBUG(DP_DBG_FLAG_COC,
-			 "Power stat req to %d(%s) fail via ltq_cpufreq_state_req?\n",
-			 new_state, get_coc_stat_string(new_state));
-		DP_DEBUG(DP_DBG_FLAG_COC, "return value: %d ??\n", ret);
-		return -1;
+int dp_handle_cpufreq_event_30(int event_id, void *cfg)
+{
+	int res = DP_FAILURE;
+
+	if (!cfg)
+		return res;
+
+	switch (event_id) {
+	case PRE_CHANGE:
+		res = dp_coc_prechange((struct cpufreq_freqs *)cfg);
+		break;
+	case POST_CHANGE:
+		res = dp_coc_postchange((struct cpufreq_freqs *)cfg);
+		break;
+	case POLICY_NOTIFY:
+		res = dp_coc_policy_notify((struct cpufreq_policy *)cfg);
+		break;
+	default:
+		PR_ERR("no support for %d\n", event_id);
+		break;
 	}
+	return res;
+}
 
-	return 0;
+void dp_meter_interrupt_cb(void *param)
+{
+	DP_DEBUG(DP_DBG_FLAG_COC, "triggered meter intr\n");
+
+	cpufreq_update_policy(0);
+	return;
 }
-EXPORT_SYMBOL(dp_coc_new_stat_req);
 
 int dp_coc_cpufreq_init(void)
 {
-	struct ltq_cpufreq *dp_coc_cpufreq_p;
-	struct ltq_cpufreq_threshold *th_data;
-
+	GSW_Irq_Op_t irq;
+	struct core_ops *gsw_handle;
 	pr_debug("enter dp_coc_cpufreq_init\n");
+
 	spin_lock_init(&dp_coc_lock);
 	dp_coc_init_stat = 0;
 	dp_coc_ena = 0;
-	dp_coc_cpufreq_p = ltq_cpufreq_get();
-
-	if (!dp_coc_cpufreq_p) {
-		PR_ERR("dp_coc_cpufreq_init failed:ltq_cpufreq_get failed?\n");
-		return -1;
-	}
-
-	if (cpufreq_register_notifier
-	    (&dp_coc_cpufreq_notifier_block, CPUFREQ_TRANSITION_NOTIFIER)) {
-		PR_ERR("cpufreq_register_notifier failed?\n");
-		return -1;
-	}
-
-	ltq_cpufreq_mod_list(&dp_coc_feature_fss.list, LTQ_CPUFREQ_LIST_ADD);
-
-	th_data = ltq_cpufreq_get_threshold(DP_MODULE, DP_ID);
-	if (th_data) {		/*copy threshold to local */
-		rmon_threshold.th_d0 = th_data->th_d0;
-		rmon_threshold.th_d1 = th_data->th_d1;
-		rmon_threshold.th_d2 = th_data->th_d2;
-		rmon_threshold.th_d3 = th_data->th_d3;
-	}
-	/*santity check */
-	if (rmon_threshold.th_d2 < rmon_threshold.th_d3)
-		rmon_threshold.th_d2 = rmon_threshold.th_d3 + 100;
-	if (rmon_threshold.th_d1 < rmon_threshold.th_d2)
-		rmon_threshold.th_d1 = rmon_threshold.th_d2 + 100;
-
-	polling_period = ltq_cpufreq_get_poll_period(DP_MODULE, DP_ID);
-
-	if (!polling_period)
-		polling_period = 2;
-
+        gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
+	cpufreq_update_policy(0);
 	meter_set_default();
-	/*Set to D0 Stage from the beginning */
-	dp_coc_new_stat_req(LTQ_CPUFREQ_PS_D0, 0);
-	init_timer_on_stack(&dp_coc_timer);
-	dp_coc_timer.data = 0;
-	dp_coc_timer.function = dp_rmon_polling;
+	irq.blk = PCE;
+	irq.event = PCE_METER_EVENT;
+	irq.portid = 0; // logical port id
+	irq.call_back = dp_meter_interrupt_cb;// Callback API
+	irq.param = NULL; // Callback  API parameter
+	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_irq_ops.IRQ_Register,
+		     gsw_handle, &irq);
+	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_irq_ops.IRQ_Enable,
+		     gsw_handle, &irq);
+
 	dp_coc_init_stat = 1;
 	dp_coc_ena = 1;
 	pr_debug("Register DP to CPUFREQ successfully.\n");
@@ -940,23 +497,8 @@ int dp_coc_cpufreq_init(void)
 int dp_coc_cpufreq_exit(void)
 {
 	if (dp_coc_init_stat) {
-		int ret;
 
 		coc_lock();
-		ret = del_timer(&dp_coc_timer);
-
-		if (ret)
-			PR_ERR("The timer is still in use...\n");
-
-		dp_coc_new_stat_req(LTQ_CPUFREQ_PS_D0D3, 0);/*dont care mode */
-
-		if (cpufreq_unregister_notifier
-		    (&dp_coc_cpufreq_notifier_block,
-		     CPUFREQ_TRANSITION_NOTIFIER))
-			PR_ERR("CPUFREQ unregistration failed.");
-
-		ltq_cpufreq_mod_list(&dp_coc_feature_fss.list,
-				     LTQ_CPUFREQ_LIST_DEL);
 		dp_coc_init_stat = 0;
 		dp_coc_ena = 0;
 		coc_unlock();
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_misc.c b/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_misc.c
index 39be5a76bc5a..f9ca7a9e358c 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_misc.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_misc.c
@@ -655,6 +655,9 @@ int register_dp_cap_gswip30(int flag)
 	cap.info.dp_get_port_vap_mib = dp_get_port_vap_mib_30;
 	cap.info.dp_clear_netif_mib = dp_clear_netif_mib_30;
 #endif
+#ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
+	cap.info.dp_handle_cpufreq_event = dp_handle_cpufreq_event_30;
+#endif
 	cap.info.cap.tx_hw_chksum = 1;
 	cap.info.cap.rx_hw_chksum = 1;
 	cap.info.cap.hw_tso = 1;
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_misc.h b/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_misc.h
index 4387956b4542..5d913a49f207 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_misc.h
+++ b/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_misc.h
@@ -30,6 +30,16 @@ struct gsw_itf {
 	u16 n;
 };
 
+#ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
+/* threshold data for D0:D3 */
+struct dp_coc_threshold {
+	int	th_d0;
+	int	th_d1;
+	int	th_d2;
+	int	th_d3;
+};
+#endif
+
 #define SET_PMAC_PORTMAP(pmac, port_id) do { \
 	if ((port_id) <= 7) \
 		(pmac)->port_map2 = 1 << (port_id); \
@@ -77,6 +87,9 @@ int lookup_dump30(struct seq_file *s, int pos);
 int lookup_start30(void);
 ssize_t proc_get_qid_via_index30(struct file *file, const char *buf,
 				 size_t count, loff_t *ppos);
+#ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
+int dp_handle_cpufreq_event_30(int event_id, void *cfg);
+#endif
 
 #endif
 
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_proc.c b/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_proc.c
index 61ead6c2daa6..e38b291371bf 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_proc.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_proc.c
@@ -20,6 +20,7 @@
 #include "datapath_misc.h"
 
 #define PROC_PARSER "parser"
+#define PROC_COC "coc"
 #define PROC_RMON_PORTS  "rmon"
 #define PROC_EP "ep"	/*EP/port ID info */
 #define PROC_DPORT "dport"	/*TMU dequeue port info */
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/Kconfig b/drivers/net/ethernet/lantiq/datapath/gswip31/Kconfig
index 440908756018..4695da0b9ee6 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/Kconfig
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/Kconfig
@@ -16,13 +16,6 @@ config LTQ_DATAPATH_HAL_GSWIP31_MIB
 	---help---
 	  It is to aggregate GSWIP-L/R, TMU and driver's MIB counter
 
-config LTQ_DATAPATH_HAL_GSWIP30_CPUFREQ
-	bool "Datapath DFS(COC) support"
-	depends on LTQ_DATAPATH && LTQ_CPUFREQ && LTQ_ETHSW_API
-	default y
-	---help---
-	  It is to support DFS(COC) in Datapath
-
 config LTQ_DATAPATH_DDR_SIMULATE_GSWIP31
 	bool "Datapath Simulation GSWIP3.1 based on GRX500 board"
 	default n
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/Makefile b/drivers/net/ethernet/lantiq/datapath/gswip31/Makefile
index 2ce79f19ed43..3941e417722c 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/Makefile
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/Makefile
@@ -10,7 +10,7 @@ ifneq ($(CONFIG_LTQ_DATAPATH_HAL_GSWIP31_MIB),)
 obj-$(CONFIG_LTQ_DATAPATH) += datapath_mib.o
 endif
 
-ifneq ($(CONFIG_LTQ_DATAPATH_HAL_GSWIP31_COC),)
+ifneq ($(CONFIG_LTQ_DATAPATH_CPUFREQ),)
 obj-$(CONFIG_LTQ_DATAPATH) += datapath_coc.o
 endif
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
index 6f764fec27a0..0ec740d07adf 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
@@ -2897,6 +2897,9 @@ static GSW_return_t legacy_switch_core_init(void *cdev)
 		}
 	}
 
+	/*Initalize GSWIP Irq*/
+	GSW_Irq_init(cdev);
+
 	return GSW_statusOk;
 }
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
index 6fb1bb03780b..087c36e55f66 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
@@ -866,17 +866,19 @@ typedef struct {
 
 /*Switch IRQ related structures*/
 typedef struct gsw_pce_irq gsw_pce_irq;
+
 struct gsw_pce_irq {
 	gsw_pce_irq *pNext;
-	char Port_ier_enabled;
-	unsigned short P_IER_MASK;
-	char Event_ier_enable;
-	unsigned short E_IER_MASK;
-	unsigned short P_ISR_MASK;
-	unsigned short E_ISR_MASK;
+	u32 portId;
+	int pce_ier_mask;
+	int pce_gier_mask;
+	int pce_pier_mask;
+	int pce_isr_mask;
+	int pce_gisr_mask;
+	int pce_pisr_mask;
 	void *call_back;
 	void *param;
-} ;
+};
 
 struct pce_irq_linklist {
 	gsw_pce_irq	*first_ptr;
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_irq.c b/drivers/net/ethernet/lantiq/switch-api/gsw_irq.c
index 8b6b988d8b47..fcb49a85c43c 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_irq.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_irq.c
@@ -9,13 +9,15 @@ this software module.
 
 typedef void (*gsw_call_back)(void *param);
 
-extern ethsw_api_dev_t *ecoredev[LTQ_FLOW_DEV_MAX];
+#define IS_PCE_IER_MATCH(p1, p2) (p1->pce_ier_mask==p2->pce_ier_mask)
+#define IS_PCE_GIER_MATCH(p1, p2) (p1->pce_gier_mask==p2->pce_gier_mask)
+#define IS_PCE_PIER_MATCH(p1, p2) (p1->pce_pier_mask==p2->pce_pier_mask)
+#define INVALID -1
 
 GSW_return_t  GSW_Debug_PrintPceIrqList(void *cdev)
 {
 	gsw_pce_irq *irq;
-	unsigned int i = 0;
-	unsigned int port = 0;
+	u32 i = 0;
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
 
 	if (gswdev == NULL) {
@@ -24,70 +26,61 @@ GSW_return_t  GSW_Debug_PrintPceIrqList(void *cdev)
 	}
 
 	irq = gswdev->PceIrqList->first_ptr;
-	printk("\n");
 
 	while (irq != NULL) {
-		printk("PCE Node %d:\n", i);
-		printk("Irq address          = 0x%x\n", (u32)irq);
-		printk("Next Irq Address     = 0x%x\n\n", (u32)irq->pNext);
-
-		if (irq->Port_ier_enabled)
-			printk("\tPort IER			= ENABLED\n");
-		else
-			printk("\tPort IER			= DISABLED\n");
-
-		for (i = 0; i < 12; i++) {
-			if (irq->P_IER_MASK & (1 << i)) {
-				port = i;
-				break;
-			}
+
+		if (irq->pce_gier_mask == INVALID &&
+		    irq->pce_ier_mask == INVALID &&
+		    irq->pce_pier_mask == INVALID) {
+			goto cont;
 		}
 
-		printk("\tP_IER_MASK			= %u (port no)\n", port);
+		printk("PCE Node                 %d:\n", i);
+		printk("PceIrqList address                 = 0x%p\n", irq);
+		printk("PceIrqList Next Irq Address                 = 0x%p\n\n", irq->pNext);
 
-		if (irq->Event_ier_enable)
-			printk("\tEvent IER			= ENABLED\n");
-		else
-			printk("\tEvent IER			= DISABLED\n");
+		printk("pce_ier_mask                 = %u (port no)\n", irq->portId);
 
-		switch (irq->E_IER_MASK) {
+		switch (irq->pce_gier_mask) {
 		case PCE_MAC_TABLE_CHANGE:
-			printk("\tE_IER_MASK			= PCE_MAC_TABLE_CHANGE\n");
+			printk("pce_gier_mask                 = PCE_MAC_TABLE_CHANGE\n");
 			break;
 
 		case PCE_FLOW_TABLE_RULE_MATCHED:
-			printk("\tE_IER_MASK			= PCE_FLOW_TABLE_RULE_MATCHED\n");
+			printk("pce_gier_mask                 = PCE_FLOW_TABLE_RULE_MATCHED\n");
 			break;
 
 		case PCE_CLASSIFICATION_PHASE_2:
-			printk("\tE_IER_MASK			= PCE_CLASSIFICATION_PHASE_2\n");
+			printk("pce_gier_mask                 = PCE_CLASSIFICATION_PHASE_2\n");
 			break;
 
 		case PCE_CLASSIFICATION_PHASE_1:
-			printk("\tE_IER_MASK			= PCE_CLASSIFICATION_PHASE_1\n");
+			printk("pce_gier_mask                 = PCE_CLASSIFICATION_PHASE_1\n");
 			break;
 
 		case PCE_CLASSIFICATION_PHASE_0:
-			printk("\tE_IER_MASK			= PCE_CLASSIFICATION_PHASE_0\n");
+			printk("pce_gier_mask                 = PCE_CLASSIFICATION_PHASE_0\n");
 			break;
 
 		case PCE_PARSER_READY:
-			printk("\tE_IER_MASK			= PCE_PARSER_READY\n");
+			printk("pce_gier_mask                 = PCE_PARSER_READY\n");
 			break;
 
 		case PCE_IGMP_TABLE_FULL:
-			printk("\tE_IER_MASK			= PCE_IGMP_TABLE_FULL\n");
+			printk("pce_gier_mask                 = PCE_IGMP_TABLE_FULL\n");
 			break;
 
 		case PCE_MAC_TABLE_FULL:
-			printk("\tE_IER_MASK			= PCE_MAC_TABLE_FULL\n");
+			printk("pce_gier_mask                 = PCE_MAC_TABLE_FULL\n");
 			break;
 		}
 
-		printk("\tP_ISR_MASK			= %u\n", irq->P_ISR_MASK);
-		printk("\tE_ISR_MASK			= %u\n", irq->E_ISR_MASK);
-		printk("\tcall_back				= 0x%x\n", (u32)irq->call_back);
+		printk("pce_isr_mask                 = %u\n", irq->pce_isr_mask);
+		printk("pce_gisr_mask                 = %u\n", irq->pce_gisr_mask);
+		printk("pce_pisr_mask                 = %u\n", irq->pce_pisr_mask);
+		printk("call_back                 = 0x%p\n", irq->call_back);
 		printk("\n");
+cont:
 		irq = irq->pNext;
 		i++;
 	}
@@ -95,38 +88,24 @@ GSW_return_t  GSW_Debug_PrintPceIrqList(void *cdev)
 	return GSW_statusOk;
 }
 
-static unsigned int PortIrq_Match(gsw_pce_irq *p1,
-				  gsw_pce_irq *p2)
-{
-	if (p1->P_IER_MASK == p2->P_IER_MASK &&
-	    p1->P_ISR_MASK == p2->P_ISR_MASK)
-		return 1;
-	else
-		return 0;
-}
-
-static unsigned int EventIrq_Match(gsw_pce_irq *p1,
-				   gsw_pce_irq *p2)
-{
-	if (p1->E_IER_MASK == p2->E_IER_MASK &&
-	    p1->E_ISR_MASK == p2->E_ISR_MASK)
-		return 1;
-	else
-		return 0;
-}
-
-static GSW_return_t pce_irq_add(void *cdev, gsw_pce_irq pce_irg,
+static GSW_return_t pce_irq_add(void *cdev, gsw_pce_irq *pce_irq,
 				struct pce_irq_linklist *node)
 {
-	gsw_pce_irq	*register_irq = NULL;
+	gsw_pce_irq *reg_irq = NULL;
 	gsw_pce_irq *irq = NULL;
+
 	irq = node->first_ptr;
 
 	while (irq != NULL) {
-		if (PortIrq_Match(&pce_irg, irq) &&
-		    EventIrq_Match(&pce_irg, irq)) {
-			pr_err("ERROR : Invalid operation , IRQ already registered %s:%s:%d\n",
-			       __FILE__, __func__, __LINE__);
+		if (IS_PCE_IER_MATCH(pce_irq, irq) &&
+		    IS_PCE_GIER_MATCH(pce_irq, irq)) {
+			pr_debug("Event & Port already registered\n");
+			return GSW_statusErr;
+		}
+
+		if (IS_PCE_IER_MATCH(pce_irq, irq) &&
+		    IS_PCE_PIER_MATCH(pce_irq, irq)) {
+			pr_debug("Event & PIER already registered\n");
 			return GSW_statusErr;
 		}
 
@@ -134,46 +113,66 @@ static GSW_return_t pce_irq_add(void *cdev, gsw_pce_irq pce_irg,
 	}
 
 #ifdef __KERNEL__
-	register_irq = (gsw_pce_irq *)kmalloc(sizeof(gsw_pce_irq), GFP_KERNEL);
-	memset(register_irq, 0, sizeof(gsw_pce_irq));
+	reg_irq = (gsw_pce_irq *)kmalloc(sizeof(gsw_pce_irq), GFP_KERNEL);
+	memset(reg_irq, 0, sizeof(gsw_pce_irq));
 #else
-	register_irq = (gsw_pce_irq *)malloc(sizeof(gsw_pce_irq));
-	memset(register_irq, 0, sizeof(gsw_pce_irq));
+	reg_irq = (gsw_pce_irq *)malloc(sizeof(gsw_pce_irq));
+	memset(reg_irq, 0, sizeof(gsw_pce_irq));
 #endif
 
-	register_irq->pNext			=	NULL;
-	register_irq->Port_ier_enabled	=	0;
-	register_irq->P_IER_MASK	=	pce_irg.P_IER_MASK;
-	register_irq->Event_ier_enable	=	0;
-	register_irq->E_IER_MASK	=	pce_irg.E_IER_MASK;
-	register_irq->P_ISR_MASK	=	pce_irg.P_ISR_MASK;
-	register_irq->E_ISR_MASK	=	pce_irg.E_ISR_MASK;
-	register_irq->call_back		=	pce_irg.call_back;
-	register_irq->param			=	pce_irg.param;
+	reg_irq->pNext			=	NULL;
+	reg_irq->portId			= 	pce_irq->portId;
+	reg_irq->pce_ier_mask		=	pce_irq->pce_ier_mask;
+	reg_irq->pce_isr_mask		=	pce_irq->pce_isr_mask;
+	reg_irq->pce_gier_mask		=	pce_irq->pce_gier_mask;
+	reg_irq->pce_gisr_mask		=	pce_irq->pce_gisr_mask;
+	reg_irq->pce_pier_mask		=	pce_irq->pce_pier_mask;
+	reg_irq->pce_pisr_mask		=	pce_irq->pce_pisr_mask;
+	reg_irq->call_back		=	pce_irq->call_back;
+	reg_irq->param			=	pce_irq->param;
 
 	if (node->first_ptr != NULL) {
-		node->last_ptr->pNext = register_irq;
-		node->last_ptr = register_irq;
+		node->last_ptr->pNext = reg_irq;
+		node->last_ptr = reg_irq;
 	} else {
-		node->first_ptr = node->last_ptr = register_irq;
+		node->first_ptr = reg_irq;
+		node->last_ptr = reg_irq;
 	}
 
 	return GSW_statusOk;
 }
 
-static GSW_return_t pce_irq_del(void *cdev, gsw_pce_irq pce_irg,
+static GSW_return_t pce_irq_del(void *cdev, gsw_pce_irq *pce_irq,
 				struct pce_irq_linklist *node)
 {
 	gsw_pce_irq *prv_irq = NULL, *delete_irq = NULL;
-	u32 p_ierq = 0;
+	u32 p_ierq = 0, found = 0;
+
 	delete_irq = node->first_ptr;
 
 	while (delete_irq != NULL) {
-		if (PortIrq_Match(&pce_irg, delete_irq) &&
-		    EventIrq_Match(&pce_irg, delete_irq)) {
+		if (IS_PCE_IER_MATCH(pce_irq, delete_irq) &&
+		    IS_PCE_GIER_MATCH(pce_irq, delete_irq)) {
+
+			gsw_r32(cdev, PCE_IER_0_OFFSET,
+				delete_irq->pce_ier_mask,
+				1, &p_ierq);
+
+			/*Check only Port IER*/
+			if (p_ierq) {
+				pr_err("ERROR : Can not Un-Register IRQ, disable IRQ first %s:%s:%d\n",
+				       __FILE__, __func__, __LINE__);
+				return -1;
+			}
+
+			found = 1;
+		}
+
+		if (IS_PCE_IER_MATCH(pce_irq, delete_irq) &&
+		    IS_PCE_PIER_MATCH(pce_irq, delete_irq)) {
 
 			gsw_r32(cdev, PCE_IER_0_OFFSET,
-				delete_irq->P_IER_MASK,
+				delete_irq->pce_ier_mask,
 				1, &p_ierq);
 
 			/*Check only Port IER*/
@@ -183,6 +182,11 @@ static GSW_return_t pce_irq_del(void *cdev, gsw_pce_irq pce_irg,
 				return -1;
 			}
 
+			found = 1;
+		}
+
+
+		if (found) {
 			if (node->first_ptr == delete_irq &&
 			    node->last_ptr == delete_irq) {
 				node->first_ptr = delete_irq->pNext;
@@ -201,141 +205,92 @@ static GSW_return_t pce_irq_del(void *cdev, gsw_pce_irq pce_irg,
 #else
 			free(delete_irq);
 #endif
-			return GSW_statusOk;
 		}
 
 		prv_irq = delete_irq;
 		delete_irq = delete_irq->pNext;
 	}
 
-	pr_err("ERROR : Invalid operation , IRQ not registered %s:%s:%d\n",
-	       __FILE__, __func__, __LINE__);
-	return GSW_statusErr;
+	return GSW_statusOk;
 }
 
-static GSW_return_t pce_irq_enable(void *cdev, gsw_pce_irq pce_irg,
+static GSW_return_t pce_irq_enable(void *cdev, gsw_pce_irq *pce_irq,
 				   struct pce_irq_linklist *node)
 {
-	u32 p_ierq = 0, e_ierq = 0, irq_registered = 0;
 	gsw_pce_irq *irq = NULL;
+	short pce_pier_offset = 0;
+
+	if (!node)
+		return GSW_statusErr;
 
 	irq = node->first_ptr;
 
 	while (irq != NULL) {
-		p_ierq = 0;
-		e_ierq = 0;
-
-		if (PortIrq_Match(&pce_irg, irq))
-			p_ierq = 1;
 
-		if (EventIrq_Match(&pce_irg, irq))
-			e_ierq = 1;
+		if (IS_PCE_IER_MATCH(pce_irq, irq) &&
+		    IS_PCE_GIER_MATCH(pce_irq, irq)) {
 
-		if (p_ierq && e_ierq &&
-		    pce_irg.P_IER_MASK != PCE_INVALID_PORT_IERQ &&
-		    pce_irg.E_IER_MASK != PCE_INVALID_EVENT_IERQ) {
-			/*If both Port IER and Event IER found
-				in the IRQ register list*/
-			irq->Port_ier_enabled = 1;
 			gsw_w32(cdev, PCE_IER_0_OFFSET,
-				irq->P_IER_MASK, 1, 1);
+				irq->pce_ier_mask, 1, 1);
 
-			irq->Event_ier_enable = 1;
 			gsw_w32(cdev, PCE_IER_1_OFFSET,
-				irq->E_IER_MASK, 1, 1);
-
-			return 1;
-		} else if (pce_irg.P_IER_MASK == PCE_INVALID_PORT_IERQ
-			   && e_ierq) {
-			/*if only Event IER in
-			  the IRQ register list*/
-			irq->Event_ier_enable = 1;
-			gsw_w32(cdev, PCE_IER_1_OFFSET,
-				irq->E_IER_MASK, 1, 1);
-			irq_registered = 1;
-		} else if (pce_irg.E_IER_MASK == PCE_INVALID_EVENT_IERQ
-			   && p_ierq) {
-			/*if only Port IER in
-			  the IRQ register list*/
-			irq->Port_ier_enabled = 1;
+				irq->pce_gier_mask, 1, 1);
+		}
+
+		if (IS_PCE_IER_MATCH(pce_irq, irq) &&
+		    IS_PCE_PIER_MATCH(pce_irq, irq)) {
+
+			pce_pier_offset = PCE_PIER_OFFSET(pce_irq->portId);
+
 			gsw_w32(cdev, PCE_IER_0_OFFSET,
-				irq->P_IER_MASK, 1, 1);
-			irq_registered = 1;
+				irq->pce_ier_mask, 1, 1);
+
+			gsw_w32(cdev, pce_pier_offset,
+				irq->pce_pier_mask, 1, 1);
 		}
 
 		irq = irq->pNext;
 	}
 
-	if (!irq_registered) {
-		pr_err("ERROR : Invalid operation , IRQ not registered %s:%s:%d\n",
-		       __FILE__, __func__, __LINE__);
-		return GSW_statusErr;
-	}
-
 	return GSW_statusOk;
 }
 
-static GSW_return_t pce_irq_disable(void *cdev, gsw_pce_irq pce_irg,
+static GSW_return_t pce_irq_disable(void *cdev, gsw_pce_irq *pce_irq,
 				    struct pce_irq_linklist *node)
 {
-	u32 p_ierq = 0, e_ierq = 0;
 	gsw_pce_irq *irq = NULL;
-	irq = node->first_ptr;
+	short pce_pier_offset = 0;
 
-	if (pce_irg.P_IER_MASK == PCE_INVALID_PORT_IERQ) {
-		p_ierq = 1;
-		irq = NULL;
-	} else {
-		irq = node->first_ptr;
-	}
+	irq = node->first_ptr;
 
 	while (irq != NULL) {
-		if (PortIrq_Match(&pce_irg, irq)) {
-			irq->Port_ier_enabled = 0;
-			gsw_w32(cdev, PCE_IER_0_OFFSET,
-				irq->P_IER_MASK, 1, 0);
-			p_ierq = 1;
+		if (IS_PCE_IER_MATCH(pce_irq, irq) &&
+		    IS_PCE_GIER_MATCH(pce_irq, irq)) {
+			gsw_w32(cdev, PCE_IER_0_OFFSET, irq->pce_ier_mask, 1, 0);
+			gsw_w32(cdev, PCE_IER_1_OFFSET, irq->pce_gier_mask, 1, 0);
 		}
 
 		irq = irq->pNext;
 	}
 
-	if (!p_ierq) {
-		pr_err("ERROR : Invalid operation , PORT not registered %s:%s:%d\n",
-		       __FILE__, __func__, __LINE__);
-		return GSW_statusErr;
-	}
-
-	if (pce_irg.E_IER_MASK == PCE_INVALID_EVENT_IERQ) {
-		e_ierq = 1;
-		irq = NULL;
-	} else {
-		irq = node->first_ptr;
-	}
+	irq = node->first_ptr;
 
 	while (irq != NULL) {
-		if (EventIrq_Match(&pce_irg, irq)) {
-			irq->Event_ier_enable = 0;
-			gsw_w32(cdev, PCE_IER_1_OFFSET,
-				irq->E_IER_MASK, 1, 0);
-			e_ierq = 1;
+		if ((IS_PCE_IER_MATCH(pce_irq, irq)) &&
+		    (IS_PCE_PIER_MATCH(pce_irq, irq))) {
+			pce_pier_offset = PCE_PIER_OFFSET(pce_irq->portId);
+			gsw_w32(cdev, pce_pier_offset, irq->pce_gier_mask, 1, 0);
 		}
 
 		irq = irq->pNext;
 	}
 
-	if (!e_ierq) {
-		pr_err("ERROR : Invalid operation , EVENT not registered %s:%s:%d\n",
-		       __FILE__, __func__, __LINE__);
-		return GSW_statusErr;
-	}
-
 	return GSW_statusOk;
 }
 
 static GSW_return_t pce_irq_config(void *cdev, GSW_Irq_Op_t *irq, IRQ_TYPE IrqType)
 {
-	gsw_pce_irq pce_irg;
+	gsw_pce_irq pce_irq = {0};
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
 
 	if (gswdev == NULL) {
@@ -343,61 +298,70 @@ static GSW_return_t pce_irq_config(void *cdev, GSW_Irq_Op_t *irq, IRQ_TYPE IrqTy
 		return GSW_statusErr;
 	}
 
-	if (irq->portid > gswdev->tpnum &&
-	    irq->portid != PCE_INVALID_PORT_IERQ) {
+	if (irq->portid > gswdev->tpnum) {
 		pr_err("ERROR : PortId %d is not with in GSWIP capabilty %s:%s:%d\n",
 		       irq->portid, __FILE__, __func__, __LINE__);
 		return GSW_statusErr;
-	} else if (irq->portid == PCE_INVALID_PORT_IERQ) {
-		pce_irg.P_IER_MASK 	= PCE_INVALID_PORT_IERQ;
-	} else {
-		pce_irg.P_IER_MASK 	= PCE_IER_0_PORT_MASK_GET(irq->portid);
-		pce_irg.P_ISR_MASK 	= PCE_ISR_0_PORT_MASK_GET(irq->portid);
 	}
 
+	pce_irq.pce_gier_mask = INVALID;
+	pce_irq.pce_ier_mask  = INVALID;
+	pce_irq.pce_pier_mask = INVALID;
+	pce_irq.pce_gisr_mask = INVALID;
+	pce_irq.pce_isr_mask  = INVALID;
+	pce_irq.pce_pisr_mask = INVALID;
+
+	pce_irq.portId 		= irq->portid;
+	pce_irq.pce_ier_mask 	= PCE_IER_0_PORT_MASK_GET(irq->portid);
+	pce_irq.pce_isr_mask 	= PCE_ISR_0_PORT_MASK_GET(irq->portid);
+
+	pce_irq.pce_ier_mask = pce_irq.pce_ier_mask >> 1;
+	pce_irq.pce_isr_mask = pce_irq.pce_isr_mask >> 1;
+
 	switch (irq->event) {
 	case PCE_MAC_TABLE_CHANGE:
-		pce_irg.E_IER_MASK = PCE_IER_1_CHG_SHIFT;
-		pce_irg.E_ISR_MASK = PCE_ISR_1_CHG_SHIFT;
+		pce_irq.pce_gier_mask = PCE_IER_1_CHG_SHIFT;
+		pce_irq.pce_gisr_mask = PCE_ISR_1_CHG_SHIFT;
 		break;
 
 	case PCE_FLOW_TABLE_RULE_MATCHED:
-		pce_irg.E_IER_MASK = PCE_IER_1_FLOWINT_SHIFT;
-		pce_irg.E_ISR_MASK = PCE_ISR_1_FLOWINT_SHIFT;
+		pce_irq.pce_gier_mask = PCE_IER_1_FLOWINT_SHIFT;
+		pce_irq.pce_gisr_mask = PCE_ISR_1_FLOWINT_SHIFT;
 		break;
 
 	case PCE_CLASSIFICATION_PHASE_2:
-		pce_irg.E_IER_MASK = PCE_IER_1_CPH2_SHIFT;
-		pce_irg.E_ISR_MASK = PCE_ISR_1_CPH2_SHIFT;
+		pce_irq.pce_gier_mask = PCE_IER_1_CPH2_SHIFT;
+		pce_irq.pce_gisr_mask = PCE_ISR_1_CPH2_SHIFT;
 		break;
 
 	case PCE_CLASSIFICATION_PHASE_1:
-		pce_irg.E_IER_MASK = PCE_IER_1_CPH1_SHIFT;
-		pce_irg.E_ISR_MASK = PCE_ISR_1_CPH1_SHIFT;
+		pce_irq.pce_gier_mask = PCE_IER_1_CPH1_SHIFT;
+		pce_irq.pce_gisr_mask = PCE_ISR_1_CPH1_SHIFT;
 		break;
 
 	case PCE_CLASSIFICATION_PHASE_0:
-		pce_irg.E_IER_MASK = PCE_IER_1_CPH0_SHIFT;
-		pce_irg.E_ISR_MASK = PCE_ISR_1_CPH0_SHIFT;
+		pce_irq.pce_gier_mask = PCE_IER_1_CPH0_SHIFT;
+		pce_irq.pce_gisr_mask = PCE_ISR_1_CPH0_SHIFT;
 		break;
 
 	case PCE_PARSER_READY:
-		pce_irg.E_IER_MASK = PCE_IER_1_PRDY_SHIFT;
-		pce_irg.E_ISR_MASK = PCE_ISR_1_PRDY_SHIFT;
+		pce_irq.pce_gier_mask = PCE_IER_1_PRDY_SHIFT;
+		pce_irq.pce_gisr_mask = PCE_ISR_1_PRDY_SHIFT;
 		break;
 
 	case PCE_IGMP_TABLE_FULL:
-		pce_irg.E_IER_MASK = PCE_IER_1_IGTF_SHIFT;
-		pce_irg.E_ISR_MASK = PCE_ISR_1_IGTF_SHIFT;
+		pce_irq.pce_gier_mask = PCE_IER_1_IGTF_SHIFT;
+		pce_irq.pce_gisr_mask = PCE_ISR_1_IGTF_SHIFT;
 		break;
 
 	case PCE_MAC_TABLE_FULL:
-		pce_irg.E_IER_MASK = PCE_IER_1_MTF_SHIFT;
-		pce_irg.E_ISR_MASK = PCE_ISR_1_MTF_SHIFT;
+		pce_irq.pce_gier_mask = PCE_IER_1_MTF_SHIFT;
+		pce_irq.pce_gisr_mask = PCE_ISR_1_MTF_SHIFT;
 		break;
 
-	case PCE_INVALID_EVENT_IERQ:
-		pce_irg.E_IER_MASK = PCE_INVALID_EVENT_IERQ;
+	case PCE_METER_EVENT:
+		pce_irq.pce_pier_mask = PCE_PIER_METER_SHIFT;
+		pce_irq.pce_pisr_mask = PCE_PIER_METER_SHIFT;
 		break;
 
 	default:
@@ -406,54 +370,30 @@ static GSW_return_t pce_irq_config(void *cdev, GSW_Irq_Op_t *irq, IRQ_TYPE IrqTy
 		return GSW_statusErr;
 	}
 
-	switch (IrqType)	{
+	switch (IrqType) {
 	case IRQ_REGISTER:
-		if (irq->event == PCE_INVALID_EVENT_IERQ) {
-			pr_err("ERROR : PCE_INVALID_EVENT_IERQ %s:%s:%d\n",
-			       __FILE__, __func__, __LINE__);
-			return GSW_statusErr;
-		}
-
-		if (irq->portid == PCE_INVALID_PORT_IERQ) {
-			pr_err("ERROR : PCE PCE_INVALID_PORT_IERQ %s:%s:%d\n",
-			       __FILE__, __func__, __LINE__);
-			return GSW_statusErr;
-		}
-
 		if (irq->call_back != NULL) {
-			pce_irg.call_back	= irq->call_back;
-			pce_irg.param		= irq->param;
+			pce_irq.call_back	= irq->call_back;
+			pce_irq.param		= irq->param;
 		} else {
 			pr_err("ERROR : callback handle is NULL %s:%s:%d\n",
 			       __FILE__, __func__, __LINE__);
 			return GSW_statusErr;
 		}
 
-		pce_irq_add(cdev, pce_irg, gswdev->PceIrqList);
+		pce_irq_add(cdev, &pce_irq, gswdev->PceIrqList);
 		break;
 
 	case IRQ_UNREGISTER:
-		if (irq->event == PCE_INVALID_EVENT_IERQ) {
-			pr_err("ERROR : PCE_INVALID_EVENT_IERQ %s:%s:%d\n",
-			       __FILE__, __func__, __LINE__);
-			return GSW_statusErr;
-		}
-
-		if (irq->portid == PCE_INVALID_PORT_IERQ) {
-			pr_err("ERROR : PCE PCE_INVALID_PORT_IERQ %s:%s:%d\n",
-			       __FILE__, __func__, __LINE__);
-			return GSW_statusErr;
-		}
-
-		pce_irq_del(cdev, pce_irg, gswdev->PceIrqList);
+		pce_irq_del(cdev, &pce_irq, gswdev->PceIrqList);
 		break;
 
 	case IRQ_ENABLE:
-		pce_irq_enable(cdev, pce_irg, gswdev->PceIrqList);
+		pce_irq_enable(cdev, &pce_irq, gswdev->PceIrqList);
 		break;
 
 	case IRQ_DISABLE:
-		pce_irq_disable(cdev, pce_irg, gswdev->PceIrqList);
+		pce_irq_disable(cdev, &pce_irq, gswdev->PceIrqList);
 		break;
 
 	default:
@@ -501,8 +441,6 @@ static GSW_return_t swcore_irq_config(void *cdev, GSW_Irq_Op_t *irq, IRQ_TYPE Ir
 		break;
 
 	case PCE:
-		printk("Switch Core PCE BLK %s:%s:%d\n"
-		       , __FILE__, __func__, __LINE__);
 		pce_irq_config(cdev, irq, IrqType);
 		break;
 
@@ -523,107 +461,129 @@ static GSW_return_t swcore_irq_config(void *cdev, GSW_Irq_Op_t *irq, IRQ_TYPE Ir
 	return ret;
 }
 
-void GSW_Irq_tasklet(unsigned long prvdata)
+void GSW_Irq_tasklet(unsigned long ops)
 {
 	gsw_pce_irq *pceirq = NULL;
-	gsw_call_back callback;
-	u32 p_isr = 0, e_isr = 0;
-	ethsw_api_dev_t *cdev = (ethsw_api_dev_t *)prvdata;
+	gsw_call_back callback = NULL;
+	u32 p_isr = 0, e_isr = 0, e_pisr = 0;
 	u32 pce_event = 0;
+	short pce_pisr_offset = 0;
+	void *cdev = (void *)ops;
+	ethsw_api_dev_t *gswdev;
+
+	if (!cdev)
+		return;
+
+	gswdev = GSW_PDATA_GET(cdev);
+
+	gsw_r32(cdev, ETHSW_ISR_PCEINT_OFFSET,
+		ETHSW_ISR_PCEINT_SHIFT, ETHSW_ISR_PCEINT_SIZE,
+		&pce_event);
 
-	if (cdev) {
-
-		/*PCE IRQ*/
-		/* Read PCE ETHSW_ISR if anything is set ,
-			disable the global PCEINT IER
-			and Service PCE register IRQ list and Enable back
-			global PCEINT IER */
-		/*Global PCE ISR is read only,Hardware Status*/
-		gsw_r32(cdev, ETHSW_ISR_PCEINT_OFFSET,
-			ETHSW_ISR_PCEINT_SHIFT, ETHSW_ISR_PCEINT_SIZE,
-			&pce_event);
-
-		if (pce_event) {
-			/*Disable PCE Global IER*/
-			gsw_w32(cdev, ETHSW_IER_PCEIE_OFFSET,
-				ETHSW_IER_PCEIE_SHIFT, ETHSW_IER_PCEIE_SIZE, 0);
-
-			/*PCE : Service registered IRQ list*/
-			if (cdev->PceIrqList)
-				pceirq = cdev->PceIrqList->first_ptr;
-
-			while (pceirq != NULL) {
-				callback = NULL;
-
-				if (pceirq->Port_ier_enabled &&
-				    pceirq->Event_ier_enable) {
-					/*Check for Pending Interrupt*/
-					gsw_r32(cdev, PCE_ISR_0_OFFSET,
-						pceirq->P_ISR_MASK,
-						1, &p_isr);
-					gsw_r32(cdev, PCE_ISR_1_OFFSET,
-						pceirq->E_ISR_MASK,
-						1, &e_isr);
-
-					if (p_isr && e_isr) {
-						/*Clear only the Event
-						ISR (lhsc)-> cleared by writting 1.
-						PORT ISR cleared by Hardware (Read Only)*/
-						gsw_w32(cdev, PCE_ISR_1_OFFSET,
-							pceirq->P_ISR_MASK, 1, 1);
-
-						callback = pceirq->call_back;
-
-						/*Call back Service*/
-						if (callback)
-							callback(pceirq->param);
-					}
-				}
+	if (pce_event) {
 
+		/*PCE : Service registered IRQ list*/
+		if (gswdev->PceIrqList)
+			pceirq = gswdev->PceIrqList->first_ptr;
+
+		while (pceirq != NULL) {
+			callback = NULL;
+
+			/* Check for Pending Interrupt */
+			if (pceirq->pce_isr_mask == INVALID) {
 				pceirq = pceirq->pNext;
+				continue;
 			}
 
-			/*Enable PCE Global IER*/
-			gsw_w32(cdev, ETHSW_IER_PCEIE_OFFSET,
-				ETHSW_IER_PCEIE_SHIFT, ETHSW_IER_PCEIE_SIZE, 1);
-		}
+			if (pceirq->pce_gisr_mask != INVALID) {
+				gsw_r32(cdev, PCE_ISR_0_OFFSET,
+					pceirq->pce_isr_mask,
+					1, &p_isr);
+				gsw_r32(cdev, PCE_ISR_1_OFFSET,
+					pceirq->pce_gisr_mask,
+					1, &e_isr);
+			}
 
+			if (pceirq->pce_pisr_mask != INVALID) {
 
-		/*BM : Service registered IRQ list*/
-		/*yet to be done*/
+				pce_pisr_offset = PCE_PISR_OFFSET(pceirq->portId);
 
-		/*SDMA : Service registered IRQ list*/
-		/*yet to be done*/
+				gsw_r32(cdev, PCE_ISR_0_OFFSET,
+					pceirq->pce_isr_mask,
+					1, &p_isr);
+				gsw_r32(cdev, pce_pisr_offset,
+					pceirq->pce_pisr_mask,
+					1, &e_pisr);
+			}
 
-		/*FDMA : Service registered IRQ list*/
-		/*yet to be done*/
+			if (e_isr) {
+				gsw_w32(cdev, PCE_ISR_1_OFFSET,
+					pceirq->pce_isr_mask, 1, 1);
+				callback = pceirq->call_back;
+			}
+
+			if (e_pisr) {
+				gsw_w32(cdev, pce_pisr_offset,
+					pceirq->pce_pisr_mask, 1, 1);
+
+				callback = pceirq->call_back;
+			}
 
-		/*PMAC : Service registered IRQ list*/
-		/*yet to be done*/
+			/*Call back Service*/
+			if (callback)
+				callback(pceirq->param);
 
+			pceirq = pceirq->pNext;
+		}
+
+		/*Enable PCE Global IER*/
+		gsw_w32(cdev, ETHSW_IER_PCEIE_OFFSET,
+			ETHSW_IER_PCEIE_SHIFT, ETHSW_IER_PCEIE_SIZE, 1);
 	}
 }
 
-
 #ifdef __KERNEL__
-static irqreturn_t GSW_ISR(int irq, void *dev_id)
+static irqreturn_t GSW_ISR(int irq, void *cdev)
 {
 	struct core_ops *sw_ops;
-	ethsw_api_dev_t *gswdev;
-	u32 dev;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 dev, maxdev = 0, isr_event;
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0)
+		maxdev = 2;
+	else if (gswdev->gipver == LTQ_GSWIP_3_1)
+		maxdev = 1;
 
-	for (dev = 0; dev < LTQ_FLOW_DEV_MAX; dev++) {
+	for (dev = 0; dev < maxdev; dev++) {
 		sw_ops = NULL;
 		gswdev = NULL;
 		sw_ops = gsw_get_swcore_ops(dev);
+		gsw_r32_raw(sw_ops, ETHSW_ISR_PCEINT_OFFSET, &isr_event);
+
+		if (isr_event == 0)
+			continue;
 
 		if (sw_ops) {
 			gswdev = GSW_PDATA_GET(sw_ops);
 
-			if (gswdev) {
-				printk("\tSwitch IRQ tasklet for device %d\n", dev);
-				tasklet_schedule(&gswdev->gswip_tasklet);
+			if (isr_event & (1 << ETHSW_IER_PCEIE_SHIFT)) {
+				gsw_w32(sw_ops, ETHSW_IER_PCEIE_OFFSET,
+					ETHSW_IER_PCEIE_SHIFT, ETHSW_IER_PCEIE_SIZE, 0);
+			} else if (isr_event & (1 << ETHSW_ISR_BMINT_SHIFT)) {
+				gsw_w32(sw_ops, ETHSW_IER_PCEIE_OFFSET,
+					ETHSW_ISR_BMINT_SHIFT, ETHSW_ISR_BMINT_SIZE, 0);
+			} else if (isr_event & (1 << ETHSW_ISR_MACINT_SHIFT)) {
+				gsw_w32(sw_ops, ETHSW_IER_PCEIE_OFFSET,
+					ETHSW_ISR_MACINT_SHIFT, ETHSW_ISR_MACINT_SIZE, 0);
+			} else if (isr_event & (1 << ETHSW_ISR_SDMAINT_SHIFT)) {
+				gsw_w32(sw_ops, ETHSW_IER_PCEIE_OFFSET,
+					ETHSW_ISR_SDMAINT_SHIFT, ETHSW_ISR_SDMAINT_SIZE, 0);
+			} else if (isr_event & (1 << ETHSW_ISR_FDMAINT_SHIFT)) {
+				gsw_w32(sw_ops, ETHSW_IER_PCEIE_OFFSET,
+					ETHSW_ISR_FDMAINT_SHIFT, ETHSW_ISR_FDMAINT_SIZE, 0);
 			}
+
+			tasklet_schedule(&gswdev->gswip_tasklet);
 		}
 	}
 
@@ -631,10 +591,8 @@ static irqreturn_t GSW_ISR(int irq, void *dev_id)
 }
 #endif
 
-
 GSW_return_t GSW_Irq_init(void *cdev)
 {
-
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
 	u32 ret;
 
@@ -643,42 +601,34 @@ GSW_return_t GSW_Irq_init(void *cdev)
 		return GSW_statusErr;
 	}
 
-	/*GSWIP PCE BLK IRQ Pointer*/
-#ifdef __KERNEL__
-	gswdev->PceIrqList =
-		(struct pce_irq_linklist *)kmalloc(sizeof(struct pce_irq_linklist), GFP_KERNEL);
-#else
-	gswdev->PceIrqList =
-		(struct pce_irq_linklist *)malloc(sizeof(struct pce_irq_linklist));
-#endif
-
-	gswdev->PceIrqList->first_ptr = NULL;
-	gswdev->PceIrqList->last_ptr = NULL;
-
 	/*Enable PCE Global IER*/
 	gsw_w32(cdev, ETHSW_IER_PCEIE_OFFSET,
 		ETHSW_IER_PCEIE_SHIFT, ETHSW_IER_PCEIE_SIZE, 1);
-	/*Enable BM Global IER*/
-	/*yet to be done*/
-	/*Enable SDMA Global IER*/
-	/*yet to be done*/
-	/*Enable FDMA Global IER*/
-	/*yet to be done*/
-	/*Enable PMAC Global IER*/
-	/*yet to be done*/
 
+	/*GSWIP PCE BLK IRQ Pointer*/
 #ifdef __KERNEL__
-
-	ret = request_irq(gswdev->irq_num, GSW_ISR, 0, "gswip", NULL);
+	gswdev->PceIrqList =
+		(struct pce_irq_linklist *)kmalloc(sizeof(struct pce_irq_linklist), GFP_KERNEL);
+	ret = request_irq(gswdev->irq_num, GSW_ISR, 0, "gswip", cdev);
 
 	if (ret) {
 		pr_err("Switch irq request error %s:%s:%d", __FILE__, __func__, __LINE__);
 		return ret;
 	}
 
+	gswdev->PceIrqList->first_ptr = NULL;
+	gswdev->PceIrqList->last_ptr = NULL;
+
 	tasklet_init(&gswdev->gswip_tasklet,
 		     GSW_Irq_tasklet,
-		     (unsigned long)gswdev);
+		     (unsigned long)cdev);
+#else
+	gswdev->PceIrqList =
+		(struct pce_irq_linklist *)malloc(sizeof(struct pce_irq_linklist));
+
+	gswdev->PceIrqList->first_ptr = NULL;
+	gswdev->PceIrqList->last_ptr = NULL;
+
 #endif
 
 	return GSW_statusOk;
@@ -686,7 +636,6 @@ GSW_return_t GSW_Irq_init(void *cdev)
 
 GSW_return_t GSW_Irq_deinit(void *cdev)
 {
-
 	gsw_pce_irq *irq = NULL;
 	gsw_pce_irq *free_irq = NULL;
 	ethsw_api_dev_t *gswdev = (ethsw_api_dev_t *)cdev;
@@ -721,8 +670,6 @@ GSW_return_t GSW_Irq_deinit(void *cdev)
 	return GSW_statusOk;
 }
 
-
-
 GSW_return_t GSW_Irq_register(void *cdev, GSW_Irq_Op_t *irq)
 {
 	return swcore_irq_config(cdev, irq, IRQ_REGISTER);
@@ -742,5 +689,3 @@ GSW_return_t GSW_Irq_disable(void *cdev, GSW_Irq_Op_t *irq)
 {
 	return swcore_irq_config(cdev, irq, IRQ_DISABLE);
 }
-
-
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_reg.h b/drivers/net/ethernet/lantiq/switch-api/gsw_reg.h
index 7bdbdb5570ca..12a3733ba645 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_reg.h
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_reg.h
@@ -4406,5 +4406,13 @@
 #define PCE_ISR_1_SHIFT					0
 #define PCE_ISR_1_SIZE					16
 
+#define PCE_PIER_OFFSET(idx)				(0x488 + (0xA * idx))
+#define PCE_PIER_METER_SHIFT				8
+#define PCE_PIER_METER_SIZE				1
+
+#define PCE_PISR_OFFSET(idx)				(0x489 + (0xA * idx))
+#define PCE_PISR_METER_SHIFT				8
+#define PCE_PISR_METER_SIZE				1
+
 /* --------------------------------------------------- */
 #endif /* _LTQ_GSWITCH_REG_H_ */
diff --git a/include/net/datapath_api.h b/include/net/datapath_api.h
index 0c96c05c52c4..2db8ff8d1931 100644
--- a/include/net/datapath_api.h
+++ b/include/net/datapath_api.h
@@ -30,8 +30,6 @@
 #include <net/switch_api/gsw_flow_ops.h>
 #ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
 #include <linux/cpufreq.h>
-#include <cpufreq/ltq_cpufreq.h>
-
 #endif /*CONFIG_LTQ_DATAPATH_CPUFREQ*/
 
 /*! @mainpage Datapath Manager API
@@ -361,9 +359,9 @@ typedef int32_t(*dp_get_mib_fn_t)(dp_subif_t *subif, dp_drv_mib_t *,
 typedef int32_t(*dp_get_netif_subifid_fn_t)(struct net_device *netif,
 	struct sk_buff *skb, void *subif_data, uint8_t dst_mac[DP_MAX_ETH_ALEN],
 	dp_subif_t *subif, uint32_t flags);	/*!< @brief   get subifid */
-#if defined(CONFIG_LTQ_DATAPATH_CPUFREQ) && defined(CONFIG_LTQ_CPUFREQ)
-typedef int32_t(*dp_coc_confirm_stat)(enum ltq_cpufreq_state new_state,
-	enum ltq_cpufreq_state old_st, uint32_t f); /*!< @brief Confirm state
+#if defined(CONFIG_LTQ_DATAPATH_CPUFREQ)
+typedef int32_t(*dp_coc_confirm_stat)(int new_state,
+	int old_st, uint32_t f); /*!< @brief Confirm state
 						     *   by COC
 						     */
 #endif
@@ -1112,7 +1110,7 @@ int dp_get_port_subitf_via_dev(struct net_device *dev,
  *@param[in] flag flag
  *@return 0 if OK / -1 if error
  */
-int dp_coc_new_stat_req(enum ltq_cpufreq_state new_state, uint32_t flag);
+int dp_coc_new_stat_req(int new_state, uint32_t flag);
 
 /*!
  *@brief  The API is for dp_get_port_subitf_via_dev
@@ -1121,12 +1119,9 @@ int dp_coc_new_stat_req(enum ltq_cpufreq_state new_state, uint32_t flag);
  *@return 0 if OK / -1 if error
  */
 /*! DP's submodule to call it */
-int dp_set_rmon_threshold(struct ltq_cpufreq_threshold *threshold,
-			  uint32_t flags);
+/*int dp_set_rmon_threshold(struct dp_coc_threshold *threshold,
+			  uint32_t flags);*/
 #endif /*! CONFIG_LTQ_DATAPATH_CPUFREQ*/
-
-/*! @brief enum ltq_cpufreq_state */
-enum ltq_cpufreq_state;
 /*! get port flag. for TMU proc file cat /proc/tmu/queue1 and /proc/tmu/eqt */
 u32 get_dp_port_flag(int k);
 
diff --git a/include/net/datapath_inst.h b/include/net/datapath_inst.h
index d2fe7c2311df..4e4ea4b3687c 100644
--- a/include/net/datapath_inst.h
+++ b/include/net/datapath_inst.h
@@ -140,6 +140,9 @@ struct inst_info {
 	int (*dp_tc_vlan_set)(struct core_ops *ops, struct dp_tc_vlan *vlan,
 			      struct dp_tc_vlan_info *info,
 			      int flag);
+#ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
+	int (*dp_handle_cpufreq_event)(int event_id, void *cfg);
+#endif
 };
 
 struct dp_inst {
diff --git a/include/net/switch_api/gsw_irq.h b/include/net/switch_api/gsw_irq.h
index 900f7eb45761..7e3f1cfdbc6f 100644
--- a/include/net/switch_api/gsw_irq.h
+++ b/include/net/switch_api/gsw_irq.h
@@ -5,18 +5,9 @@ For licensing information, see the file 'LICENSE' in the root folder of
 this software module.
 ******************************************************************************/
 
-
 #ifndef _GSW_IRQ_H_
 #define _GSW_IRQ_H_
 
-typedef struct {
-	unsigned int blk;
-	unsigned int event;
-	unsigned int portid;
-	void *call_back;
-	void *param;
-} GSW_Irq_Op_t;
-
 typedef enum {
 	BM 		= 0,
 	SDMA	= 1,
@@ -26,11 +17,6 @@ typedef enum {
 } GSWIP_IRQ_BLK;
 
 typedef enum {
-	PCE_INVALID_EVENT_IERQ		= 0xFE,
-	PCE_INVALID_PORT_IERQ 		= 0xFF
-} GSWIP_PCE_INVALID_IERQ;
-
-typedef enum {
 	PCE_MAC_TABLE_FULL			= 0,
 	PCE_IGMP_TABLE_FULL			= 1,
 	PCE_PARSER_READY 			= 2,
@@ -39,8 +25,16 @@ typedef enum {
 	PCE_CLASSIFICATION_PHASE_2 	= 5,
 	PCE_FLOW_TABLE_RULE_MATCHED = 6,
 	PCE_MAC_TABLE_CHANGE 		= 7,
+	PCE_METER_EVENT = 8,
 } GSWIP_PCE_EVENT;
 
+typedef struct {
+	unsigned int blk;
+	unsigned int event;
+	unsigned int portid;
+	void *call_back;
+	void *param;
+} GSW_Irq_Op_t;
 
 typedef enum {
 	XGMAC_BLK	= 0,
