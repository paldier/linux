From efd35ebe83986400721e49382177dff51720ee16 Mon Sep 17 00:00:00 2001
From: manohara <s.manoharan@intel.com>
Date: Tue, 28 Aug 2018 17:49:27 +0800
Subject: [PATCH] format corrected

---
 .../net/ethernet/lantiq/switch-api/gsw_flow_core.c | 241 ++++----
 .../net/ethernet/lantiq/switch-api/gsw_flow_core.h |   6 +-
 .../net/ethernet/lantiq/switch-api/gsw_flow_pce.c  | 646 +++++++++++----------
 drivers/net/ethernet/lantiq/switch-api/gsw_init.c  |  78 +--
 4 files changed, 497 insertions(+), 474 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
index 99944ab4f99e..4e36d1fd259e 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
@@ -353,6 +353,7 @@ static void reset_multicast_sw_table(void *cdev)
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return;
 	}
+
 	if (IS_VRSN_31(gswdev->gipver)) {
 		gsw_init_hash_table(cdev);
 	}
@@ -382,7 +383,7 @@ static int gsw2x_msw_table_wr(void *cdev, GSW_multicastTable_t *parm)
 	pce_dasa_msb_t	mtbl;
 	ltq_pce_table_t *hpctbl = NULL;
 	gsw_igmp_t *hitbl = NULL;
-	
+
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return GSW_statusErr;
@@ -951,7 +952,7 @@ static int gsw3x_msw_table_wr(void *cdev, GSW_multicastTable_t *parm)
 	pce_dasa_msb_t	mtbl;
 	ltq_pce_table_t *hpctbl = NULL;
 	gsw_igmp_t *hitbl = NULL;
-	
+
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return GSW_statusErr;
@@ -1678,7 +1679,7 @@ static int gsw2x_msw_table_rm(void *cdev, GSW_multicastTable_t *parm)
 	pce_dasa_lsb_t ltbl;
 	pce_dasa_msb_t mtbl;
 	int dlix = 0, dmix = 0, slix = 0, smix = 0;
-	
+
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return GSW_statusErr;
@@ -2614,6 +2615,7 @@ static void get_gsw_hw_cap(void *cdev)
 		printk("\n");
 		printk("Number of logical port           =  %d\n", gswdev->pnum);
 		printk("Number of ports including V port =  %d\n", gswdev->tpnum);
+
 		if (gswdev->gipver == LTQ_GSWIP_3_1) {
 			printk("Number of CTP Port               =  %d\n", gswdev->num_of_ctp);
 			printk("Number of Bridge                 =  %d\n", gswdev->num_of_bridge);
@@ -2621,6 +2623,7 @@ static void get_gsw_hw_cap(void *cdev)
 			printk("Number of P-Mapper               =  %d\n", gswdev->num_of_pmapper);
 
 		}
+
 		printk("Number of queues                 =  %d\n", gswdev->num_of_queues);
 		printk("Number of meter instance         =  %d\n", gswdev->num_of_meters);
 		printk("Number of shapers                =  %d\n", gswdev->num_of_shapers);
@@ -2645,6 +2648,7 @@ static void get_gsw_hw_cap(void *cdev)
 			printk("Extend VLAN Table Size table     =  %d\n", gswdev->num_of_extendvlan);
 			printk("VlanFilter table Size            =  %d\n\n", gswdev->num_of_vlanfilter);
 		}
+
 		printk("\n");
 	}
 
@@ -3124,6 +3128,7 @@ static GSW_return_t switch_core_init(void *cdev)
 			mac_init_fn_ptrs(mac_ops);
 			mac_ops->init(mac_ops);
 		}
+
 		struct adap_ops *ops = gsw_get_adap_ops(0);
 
 		if (ops == NULL) {
@@ -3168,29 +3173,31 @@ void *ethsw_api_core_init(ethsw_core_init_t *ethcinit)
 	ethsw_api_dev_t *PrvData;
 	struct core_ops *ops;
 	void *cdev;
-	u32 ret =0;
-	printk("\n########## Switch Core INIT for device = %d ##########\n",ethcinit->sdev);
+	u32 ret = 0;
+	printk("\n########## Switch Core INIT for device = %d ##########\n", ethcinit->sdev);
 
 #ifdef __KERNEL__
+
 	/* KERNEL_MODE */
 	/** Get Platform Driver Data */
-	if((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
-	ops = platform_get_drvdata(ethcinit->pdev);
+	if ((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
+		ops = platform_get_drvdata(ethcinit->pdev);
 
-	/** Get Switch Core Private Data */
-	PrvData = container_of(ops, ethsw_api_dev_t, ops);
+		/** Get Switch Core Private Data */
+		PrvData = container_of(ops, ethsw_api_dev_t, ops);
 
-	if (PrvData == NULL) {
-		pr_err("%s:%s:%d (Plateform driver data not allocated)\n",
-		       __FILE__, __func__, __LINE__);
-		return PrvData;
-	}
+		if (PrvData == NULL) {
+			pr_err("%s:%s:%d (Plateform driver data not allocated)\n",
+			       __FILE__, __func__, __LINE__);
+			return PrvData;
+		}
 
-	/** Clear Switch Core Private Data */
+		/** Clear Switch Core Private Data */
 	} else {
 		/*External switch*/
 		PrvData = ethcinit->pdev;
 	}
+
 	/** Set Core OPS struct Adress to cdev*/
 	cdev = &PrvData->ops;
 
@@ -3248,7 +3255,8 @@ void *ethsw_api_core_init(ethsw_core_init_t *ethcinit)
 	}
 
 #if defined(CONFIG_LTQ_MULTICAST) && CONFIG_LTQ_MULTICAST
-	if((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
+
+	if ((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
 		/*Reset Multicast software table*/
 		reset_multicast_sw_table(cdev);
 	}
@@ -3263,17 +3271,19 @@ void *ethsw_api_core_init(ethsw_core_init_t *ethcinit)
 	gsw_w32(cdev, PCE_GCTRL_0_MC_VALID_OFFSET,
 		PCE_GCTRL_0_MC_VALID_SHIFT, PCE_GCTRL_0_MC_VALID_SIZE, 0x1);
 #else
-	if((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
+
+	if ((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
 		gsw_pmicro_code_init(cdev);
 		printk("Switch API: PCE MicroCode loaded !!\n");
 	}
+
 #endif
 
-	if((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
-	if (IS_VRSN_31(PrvData->gipver))
-		switch_core_init(cdev);
-	else
-		legacy_switch_core_init(cdev);
+	if ((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
+		if (IS_VRSN_31(PrvData->gipver))
+			switch_core_init(cdev);
+		else
+			legacy_switch_core_init(cdev);
 	}
 
 #ifdef CONFIG_X86_INTEL_CE2700
@@ -7047,14 +7057,14 @@ GSW_return_t GSW_QoS_MeterCfgSet(void *cdev,
 		}
 
 
-		if(IS_VRSN_31(gswdev->gipver)) {
+		if (IS_VRSN_31(gswdev->gipver)) {
 			/*Check whether it is InUSE,if not InUse,return ERROR*/
 			if (!(gswdev->meter_idx[mid].IndexInUse)) {
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
 		}
-		
+
 		gsw_w32(cdev, GSW_INST_SEL_INST_OFFSET,
 			GSW_INST_SEL_INST_SHIFT,
 			GSW_INST_SEL_INST_SIZE, mid);
@@ -8632,6 +8642,7 @@ GSW_return_t GSW_QoS_QueuePortSet(void *cdev,
 	if (IS_VRSN_31(gswdev->gipver)) {
 		GSW_Freeze();
 	}
+
 #ifdef __KERNEL__
 	spin_lock_bh(&gswdev->lock_pce);
 #endif
@@ -8703,6 +8714,7 @@ GSW_return_t GSW_QoS_QueuePortSet(void *cdev,
 	bmtable.tableID = BUF_MGR_Q_MAP_TABLE;
 	bmtable.numValues = 1;
 	ret = gsw_bm_table_write(cdev, &bmtable);
+
 	if (IS_VRSN_31(gswdev->gipver)) {
 		GSW_UnFreeze();
 	}
@@ -11680,10 +11692,10 @@ GSW_return_t GSW_CapGet(void *cdev, GSW_cap_t *parm)
 
 	switch (parm->nCapType) {
 	case GSW_CAP_TYPE_PORT:
+
 		/*Temp work around for the below external switch model*/
-		if(gswdev->gsw_dev == LTQ_FLOW_DEV_EXT_AX3000_F24S)
-		{
-			get_gsw_hw_cap (cdev);
+		if (gswdev->gsw_dev == LTQ_FLOW_DEV_EXT_AX3000_F24S) {
+			get_gsw_hw_cap(cdev);
 		}
 
 		gsw_r32(cdev, ETHSW_CAP_1_PPORTS_OFFSET,
@@ -12109,8 +12121,8 @@ GSW_return_t GSW_CfgSet(void *cdev, GSW_cfg_t *parm)
 GSW_return_t GSW_HW_Init(void *cdev, GSW_HW_Init_t *parm)
 {
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
-	u32 j=0;
-	u32 ret=0;
+	u32 j = 0;
+	u32 ret = 0;
 
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
@@ -12121,109 +12133,110 @@ GSW_return_t GSW_HW_Init(void *cdev, GSW_HW_Init_t *parm)
 	spin_lock_bh(&gswdev->lock_pce);
 #endif
 
-		if(gswdev->gsw_dev == LTQ_FLOW_DEV_EXT_AX3000_F24S)
-		{
-			/* Reset the Switch via Switch IP register*/
-			get_gsw_hw_cap (cdev);
-			/* Software Table Init */
-			ltq_ethsw_port_cfg_init(cdev);
-			//rst_multi_sw_table(cdev);
-			/* HW Init */
-			gsw_pmicro_code_init_f24s(cdev);
-			printk("Switch API: PCE MicroCode loaded for LTQ_FLOW_DEV_EXT_AX3000_F24S\n");
-			/*hardcoded setting for LTQ_FLOW_DEV_EXT_AX3000_F24S*/
-			ret = GSW_statusOk;
+	if (gswdev->gsw_dev == LTQ_FLOW_DEV_EXT_AX3000_F24S) {
+		/* Reset the Switch via Switch IP register*/
+		get_gsw_hw_cap(cdev);
+		/* Software Table Init */
+		ltq_ethsw_port_cfg_init(cdev);
+		//rst_multi_sw_table(cdev);
+		/* HW Init */
+		gsw_pmicro_code_init_f24s(cdev);
+		printk("Switch API: PCE MicroCode loaded for LTQ_FLOW_DEV_EXT_AX3000_F24S\n");
+		/*hardcoded setting for LTQ_FLOW_DEV_EXT_AX3000_F24S*/
+		ret = GSW_statusOk;
 
-		}else {
+	} else {
 
-			/* Reset the Switch via Switch IP register*/
-			j = 1;
-			gsw_w32(cdev, ETHSW_SWRES_R0_OFFSET,
-				ETHSW_SWRES_R0_SHIFT, ETHSW_SWRES_R0_SIZE, j);
+		/* Reset the Switch via Switch IP register*/
+		j = 1;
+		gsw_w32(cdev, ETHSW_SWRES_R0_OFFSET,
+			ETHSW_SWRES_R0_SHIFT, ETHSW_SWRES_R0_SIZE, j);
 
-	do {
+		do {
 //		udelay(100);
-		gsw_r32(cdev, ETHSW_SWRES_R0_OFFSET,
-			ETHSW_SWRES_R0_SHIFT, ETHSW_SWRES_R0_SIZE, &j);
-	} while (j);
+			gsw_r32(cdev, ETHSW_SWRES_R0_OFFSET,
+				ETHSW_SWRES_R0_SHIFT, ETHSW_SWRES_R0_SIZE, &j);
+		} while (j);
 
 #if defined(CONFIG_USE_EMULATOR) && CONFIG_USE_EMULATOR
 
-			if (gswdev->gipver == LTQ_GSWIP_3_0) {
-				/* Set Auto-Polling of connected PHYs - For all ports */
-				gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET
-					       + GSW30_TOP_OFFSET),
-					GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x0);
-			} else {
-				/* Set Auto-Polling of connected PHYs - For all ports */
-				gsw_w32(cdev, (MDC_CFG_0_PEN_0_OFFSET
-					       + GSW_TREG_OFFSET),
-					MDC_CFG_0_PEN_0_SHIFT, 6, 0x0);
-			}
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			/* Set Auto-Polling of connected PHYs - For all ports */
+			gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET
+				       + GSW30_TOP_OFFSET),
+				GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x0);
+		} else {
+			/* Set Auto-Polling of connected PHYs - For all ports */
+			gsw_w32(cdev, (MDC_CFG_0_PEN_0_OFFSET
+				       + GSW_TREG_OFFSET),
+				MDC_CFG_0_PEN_0_SHIFT, 6, 0x0);
+		}
 
 #else
-			if (gswdev->gipver == LTQ_GSWIP_3_0) {
-				if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
 #ifdef __KERNEL__
-					gsw_r_init();
+				gsw_r_init();
 #endif
-					gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
-						GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x1);
-				} else {
-					gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
-						GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x1e);
-				}
+				gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
+					GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x1);
+			} else {
+				gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
+					GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x1e);
 			}
+		}
 
 #endif  /* CONFIG_USE_EMULATOR */
-			/*	platform_device_init(cdev); */
-			gswdev->hwinit = 1;
-			/*	get_gsw_hw_cap (cdev); */
-			/* Software Table Init */
+		/*	platform_device_init(cdev); */
+		gswdev->hwinit = 1;
+		/*	get_gsw_hw_cap (cdev); */
+		/* Software Table Init */
 #if defined(CONFIG_LTQ_VLAN) && CONFIG_LTQ_VLAN
-			reset_vlan_sw_table(cdev);
+		reset_vlan_sw_table(cdev);
 #endif /*CONFIG_LTQ_VLAN */
-			ltq_ethsw_port_cfg_init(cdev);
+		ltq_ethsw_port_cfg_init(cdev);
 #if defined(CONFIG_LTQ_MULTICAST) && CONFIG_LTQ_MULTICAST
-			reset_multicast_sw_table(cdev);
+		reset_multicast_sw_table(cdev);
 #endif /*CONFIG_LTQ_MULTICAST*/
-			pce_table_init(&gswdev->phandler);
-			/* HW Init */
-			gsw_pmicro_code_init(cdev);
+		pce_table_init(&gswdev->phandler);
+		/* HW Init */
+		gsw_pmicro_code_init(cdev);
 
-			if (gswdev->gipver == LTQ_GSWIP_3_0) {
-				if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
-					/*suresh*/
-		//			rt_table_init();
-					gsw_w32(cdev, PCE_TFCR_NUM_NUM_OFFSET, PCE_TFCR_NUM_NUM_SHIFT,
-						PCE_TFCR_NUM_NUM_SIZE, 0x80);
-				}
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+				/*suresh*/
+				//			rt_table_init();
+				gsw_w32(cdev, PCE_TFCR_NUM_NUM_OFFSET, PCE_TFCR_NUM_NUM_SHIFT,
+					PCE_TFCR_NUM_NUM_SIZE, 0x80);
+			}
 
-				/* EEE auto negotiation overides:*/
-				/*  clock disable (ANEG_EEE_0.CLK_STOP_CAPABLE)  */
-				for (j = 0; j < gswdev->pnum - 1; j++) {
-					gsw_w32(cdev,
-						((GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_OFFSET
-						  + (4 * j)) + GSW30_TOP_OFFSET),
-						GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_SHIFT,
-						GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_SIZE, 0x3);
-				}
-			} else {
-				/* Configure the MDIO Clock 97.6 Khz */
-				gsw_w32(cdev, (MDC_CFG_1_FREQ_OFFSET + GSW_TREG_OFFSET),
-					MDC_CFG_1_FREQ_SHIFT,
-					MDC_CFG_1_FREQ_SIZE, 0xFF);
-
-				for (j = 0; j < gswdev->pnum - 1; j++) {
-					gsw_w32(cdev, ((ANEG_EEE_0_CLK_STOP_CAPABLE_OFFSET + j)
-						       + GSW_TREG_OFFSET),
-						ANEG_EEE_0_CLK_STOP_CAPABLE_SHIFT,
-						ANEG_EEE_0_CLK_STOP_CAPABLE_SIZE, 0x3);
-				}
+			/* EEE auto negotiation overides:*/
+			/*  clock disable (ANEG_EEE_0.CLK_STOP_CAPABLE)  */
+			for (j = 0; j < gswdev->pnum - 1; j++) {
+				gsw_w32(cdev,
+					((GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_OFFSET
+					  + (4 * j)) + GSW30_TOP_OFFSET),
+					GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_SHIFT,
+					GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_SIZE, 0x3);
+			}
+		} else {
+			/* Configure the MDIO Clock 97.6 Khz */
+			gsw_w32(cdev, (MDC_CFG_1_FREQ_OFFSET + GSW_TREG_OFFSET),
+				MDC_CFG_1_FREQ_SHIFT,
+				MDC_CFG_1_FREQ_SIZE, 0xFF);
+
+			for (j = 0; j < gswdev->pnum - 1; j++) {
+				gsw_w32(cdev, ((ANEG_EEE_0_CLK_STOP_CAPABLE_OFFSET + j)
+					       + GSW_TREG_OFFSET),
+					ANEG_EEE_0_CLK_STOP_CAPABLE_SHIFT,
+					ANEG_EEE_0_CLK_STOP_CAPABLE_SIZE, 0x3);
 			}
-			ret = GSW_statusOk;
 		}
 
+		ret = GSW_statusOk;
+	}
+
 #ifdef __KERNEL__
 	spin_unlock_bh(&gswdev->lock_pce);
 #endif
@@ -17163,7 +17176,7 @@ GSW_return_t GSW_CPU_PortCfgGet(void *cdev, GSW_CPU_PortCfg_t *parm)
 					goto UNLOCK_AND_RETURN;
 				}
 
-				parm->bFcsTxOps = ops->get_fcsgen(ops);
+				parm->bFcsGenerate = ops->get_fcsgen(ops);
 #endif
 			}
 		}
@@ -17211,7 +17224,6 @@ GSW_return_t GSW_CPU_PortCfgSet(void *cdev, GSW_CPU_PortCfg_t *parm)
 	u32 RST, AS, AST, RXSH;
 	u32 ret;
 
-
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return GSW_statusErr;
@@ -17296,8 +17308,8 @@ GSW_return_t GSW_CPU_PortCfgSet(void *cdev, GSW_CPU_PortCfg_t *parm)
 					ret = GSW_statusErr;
 					goto UNLOCK_AND_RETURN;
 				}
-				
-				ops->set_fcsgen(ops, parm->bFcsTxOps);
+
+				ops->set_fcsgen(ops, 1);
 #endif
 			}
 		}
@@ -25635,7 +25647,7 @@ GSW_return_t GSW_QOS_MeterAlloc(void *cdev, GSW_QoS_meterCfg_t *param)
 		goto UNLOCK_AND_RETURN;
 	}
 
-	if (param->nMeterId >= gswdev->num_of_meters ) {
+	if (param->nMeterId >= gswdev->num_of_meters) {
 		ret = GSW_statusErr;
 		goto UNLOCK_AND_RETURN;
 	}
@@ -26401,6 +26413,7 @@ GSW_return_t GSW_Enable(void *cdev)
 
 	if (IS_VRSN_31(gswdev->gipver)) {
 		struct adap_ops *ops = get_adap_ops(gswdev);
+
 		if (ops == NULL) {
 			pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 			return GSW_statusErr;
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
index 4e64199c67e9..e10ba896f0f4 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
@@ -404,8 +404,8 @@ enum {
 	GOUT_IGMP0,
 	GOUT_IGMP1,
 //	GOUT_IPOFF,	/*39*/
-	GOUT_STAG0=61,
-	GOUT_STAG1=62,
+	GOUT_STAG0 = 61,
+	GOUT_STAG1 = 62,
 	GOUT_NONE	=	63,
 };
 
@@ -519,7 +519,7 @@ typedef enum {
 typedef enum {
 	LTQ_FLOW_DEV_INT	= 0,
 	LTQ_FLOW_DEV_INT_R	= 1,
-	LTQ_FLOW_DEV_EXT_AX3000_F24S = 2,	
+	LTQ_FLOW_DEV_EXT_AX3000_F24S = 2,
 	LTQ_FLOW_DEV_MAX
 } gsw_devtype_t;
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
index 6fc2c2529e08..9a255ab10d0b 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
@@ -549,73 +549,73 @@ const PCE_MICROCODE pce_mc_max_ifx_tag_m = {
 	/*-----------------------------------------------------------------*/
 	/**   value    mask   ns  out_fields   L  type   flags   ipv4_len **/
 	/*-----------------------------------------------------------------*/
-	PCE_MC_M(0x88c3 , 0xFFFF , 1 , GOUT_ITAG0 , 4 , INSTR , GFLAG_ITAG ,	0),
-	PCE_MC_M(0x8100 , 0xFFFF , 4 , GOUT_STAG0 , 2 , INSTR , GFLAG_SVLAN ,  0),
-	PCE_MC_M(0x88A8 , 0xFFFF , 4 , GOUT_STAG0 , 2 , INSTR , GFLAG_SVLAN ,  0),
-	PCE_MC_M(0x9100 , 0xFFFF , 4 , GOUT_STAG0 , 2 , INSTR , GFLAG_SVLAN ,  0),
-	PCE_MC_M(0x8100 , 0xFFFF , 5 , GOUT_VTAG0 , 2 , INSTR , GFLAG_VLAN ,	0),
-	PCE_MC_M(0x88A8 , 0xFFFF , 6 , GOUT_VTAG0 , 2 , INSTR , GFLAG_VLAN ,	0),
-	PCE_MC_M(0x9100 , 0xFFFF , 4 , GOUT_VTAG0 , 2 , INSTR , GFLAG_VLAN ,	0),
-	PCE_MC_M(0x8864 , 0xFFFF , 20 , GOUT_ETHTYP , 1 , INSTR , GFLAG_NO ,	0),
-	PCE_MC_M(0x0800 , 0xFFFF , 24 , GOUT_ETHTYP , 1 , INSTR , GFLAG_NO ,	0),
-	PCE_MC_M(0x86DD , 0xFFFF , 25 , GOUT_ETHTYP , 1 , INSTR , GFLAG_NO ,	0),
-	PCE_MC_M(0x8863 , 0xFFFF , 19 , GOUT_ETHTYP , 1 , INSTR , GFLAG_NO ,	0),
-	PCE_MC_M(0x0000 , 0xF800 , 13 , GOUT_NONE , 0 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 44 , GOUT_ETHTYP , 1 , INSTR , GFLAG_NO ,	0),
-	PCE_MC_M(0x0600 , 0x0600 , 44 , GOUT_ETHTYP , 1 , INSTR , GFLAG_NO ,	0),
-	PCE_MC_M(0x0000 , 0x0000 , 15 , GOUT_NONE , 1 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0xAAAA , 0xFFFF , 17 , GOUT_NONE , 1 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0300 , 0xFF00 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_SNAP ,	0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_DIP7 , 3 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 21 , GOUT_DIP7 , 3 , INSTR , GFLAG_PPPOE ,  0),
-	PCE_MC_M(0x0021 , 0xFFFF , 24 , GOUT_NONE , 1 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0057 , 0xFFFF , 25 , GOUT_NONE , 1 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 44 , GOUT_NONE , 0 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x4000 , 0xF000 , 27 , GOUT_IP0 , 4 , INSTR , GFLAG_IPV4 , 1),
-	PCE_MC_M(0x6000 , 0xF000 , 30 , GOUT_IP0 , 3 , INSTR , GFLAG_IPV6 ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 44 , GOUT_NONE , 0 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 28 , GOUT_IP3 , 2 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 29 , GOUT_SIP0 , 4 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 44 , GOUT_NONE , 0 , LENACCU , GFLAG_NO ,	0),
-	PCE_MC_M(0x1100 , 0xFF00 , 43 , GOUT_PROT , 1 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0600 , 0xFF00 , 43 , GOUT_PROT , 1 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0xFF00 , 41 , GOUT_IP3 , 17 , INSTR , GFLAG_HOP ,  0),
-	PCE_MC_M(0x2B00 , 0xFF00 , 41 , GOUT_IP3 , 17 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x3C00 , 0xFF00 , 41 , GOUT_IP3 , 17 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 43 , GOUT_PROT , 1 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0xFF00 , 41 , GOUT_NONE , 0 , IPV6 , GFLAG_HOP ,  0),
-	PCE_MC_M(0x2B00 , 0xFF00 , 41 , GOUT_NONE , 0 , IPV6 , GFLAG_NO ,  0),
-	PCE_MC_M(0x3C00 , 0xFF00 , 41 , GOUT_NONE , 0 , IPV6 , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0x00FC , 44 , GOUT_PROT , 0 , IPV6 , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 44 , GOUT_NONE , 0 , IPV6 , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0x00F8 , 36 , GOUT_NONE , 0 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 44 , GOUT_NONE , 0 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 44 , GOUT_SIP0 , 16 , INSTR , GFLAG_NO ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 45 , GOUT_APP0 , 3 , INSTR , GFLAG_IGMP , 0),
-	PCE_MC_M(0x1000 , 0x1000 , 46 , GOUT_NONE , 0 , INSTR , GFLAG_NN2 , 0),
-	PCE_MC_M(0x2000 , 0x2000 , 47 , GOUT_NONE , 0 , INSTR , GFLAG_NN1 , 0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_IGMP1 , 1 , INSTR , GFLAG_NO , 0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END ,  0),
-	PCE_MC_M(0x0000 , 0x0000 , 48 , GOUT_NONE , 0 , INSTR , GFLAG_END , 0),
+	PCE_MC_M(0x88c3, 0xFFFF, 1, GOUT_ITAG0, 4, INSTR, GFLAG_ITAG,	0),
+	PCE_MC_M(0x8100, 0xFFFF, 4, GOUT_STAG0, 2, INSTR, GFLAG_SVLAN,  0),
+	PCE_MC_M(0x88A8, 0xFFFF, 4, GOUT_STAG0, 2, INSTR, GFLAG_SVLAN,  0),
+	PCE_MC_M(0x9100, 0xFFFF, 4, GOUT_STAG0, 2, INSTR, GFLAG_SVLAN,  0),
+	PCE_MC_M(0x8100, 0xFFFF, 5, GOUT_VTAG0, 2, INSTR, GFLAG_VLAN,	0),
+	PCE_MC_M(0x88A8, 0xFFFF, 6, GOUT_VTAG0, 2, INSTR, GFLAG_VLAN,	0),
+	PCE_MC_M(0x9100, 0xFFFF, 4, GOUT_VTAG0, 2, INSTR, GFLAG_VLAN,	0),
+	PCE_MC_M(0x8864, 0xFFFF, 20, GOUT_ETHTYP, 1, INSTR, GFLAG_NO,	0),
+	PCE_MC_M(0x0800, 0xFFFF, 24, GOUT_ETHTYP, 1, INSTR, GFLAG_NO,	0),
+	PCE_MC_M(0x86DD, 0xFFFF, 25, GOUT_ETHTYP, 1, INSTR, GFLAG_NO,	0),
+	PCE_MC_M(0x8863, 0xFFFF, 19, GOUT_ETHTYP, 1, INSTR, GFLAG_NO,	0),
+	PCE_MC_M(0x0000, 0xF800, 13, GOUT_NONE, 0, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 44, GOUT_ETHTYP, 1, INSTR, GFLAG_NO,	0),
+	PCE_MC_M(0x0600, 0x0600, 44, GOUT_ETHTYP, 1, INSTR, GFLAG_NO,	0),
+	PCE_MC_M(0x0000, 0x0000, 15, GOUT_NONE, 1, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0xAAAA, 0xFFFF, 17, GOUT_NONE, 1, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0300, 0xFF00, 48, GOUT_NONE, 0, INSTR, GFLAG_SNAP,	0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_DIP7, 3, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 21, GOUT_DIP7, 3, INSTR, GFLAG_PPPOE,  0),
+	PCE_MC_M(0x0021, 0xFFFF, 24, GOUT_NONE, 1, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0057, 0xFFFF, 25, GOUT_NONE, 1, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 44, GOUT_NONE, 0, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x4000, 0xF000, 27, GOUT_IP0, 4, INSTR, GFLAG_IPV4, 1),
+	PCE_MC_M(0x6000, 0xF000, 30, GOUT_IP0, 3, INSTR, GFLAG_IPV6,  0),
+	PCE_MC_M(0x0000, 0x0000, 44, GOUT_NONE, 0, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 28, GOUT_IP3, 2, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 29, GOUT_SIP0, 4, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 44, GOUT_NONE, 0, LENACCU, GFLAG_NO,	0),
+	PCE_MC_M(0x1100, 0xFF00, 43, GOUT_PROT, 1, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0600, 0xFF00, 43, GOUT_PROT, 1, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0xFF00, 41, GOUT_IP3, 17, INSTR, GFLAG_HOP,  0),
+	PCE_MC_M(0x2B00, 0xFF00, 41, GOUT_IP3, 17, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x3C00, 0xFF00, 41, GOUT_IP3, 17, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 43, GOUT_PROT, 1, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0xFF00, 41, GOUT_NONE, 0, IPV6, GFLAG_HOP,  0),
+	PCE_MC_M(0x2B00, 0xFF00, 41, GOUT_NONE, 0, IPV6, GFLAG_NO,  0),
+	PCE_MC_M(0x3C00, 0xFF00, 41, GOUT_NONE, 0, IPV6, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x00FC, 44, GOUT_PROT, 0, IPV6, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 44, GOUT_NONE, 0, IPV6, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x00F8, 36, GOUT_NONE, 0, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 44, GOUT_NONE, 0, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 44, GOUT_SIP0, 16, INSTR, GFLAG_NO,  0),
+	PCE_MC_M(0x0000, 0x0000, 45, GOUT_APP0, 3, INSTR, GFLAG_IGMP, 0),
+	PCE_MC_M(0x1000, 0x1000, 46, GOUT_NONE, 0, INSTR, GFLAG_NN2, 0),
+	PCE_MC_M(0x2000, 0x2000, 47, GOUT_NONE, 0, INSTR, GFLAG_NN1, 0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_IGMP1, 1, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END,  0),
+	PCE_MC_M(0x0000, 0x0000, 48, GOUT_NONE, 0, INSTR, GFLAG_END, 0),
 };
 
 /* find a matched entry if already written or empty entry and fill */
@@ -1509,58 +1509,62 @@ int gsw_pmicro_code_init_f24s(void *cdev)
 	pctbl_prog_t tbl_entry;
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
 
-		printk("PCE f24s micro-code init\n");
-		/* Disable all physical port  */
+	printk("PCE f24s micro-code init\n");
+	/* Disable all physical port  */
 
-		for (j = 0; j < gswdev->pnum; j++) {
-		printk("gswdev->pnum =%d j= %d\n",gswdev->pnum,j);			
-			gsw_w32(cdev, (SDMA_PCTRL_PEN_OFFSET + (j * 0x6)),
-				SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE, 0);
-		}	
-	
-		gsw_w32(cdev, PCE_GCTRL_0_MC_VALID_OFFSET,
+	for (j = 0; j < gswdev->pnum; j++) {
+		printk("gswdev->pnum =%d j= %d\n", gswdev->pnum, j);
+		gsw_w32(cdev, (SDMA_PCTRL_PEN_OFFSET + (j * 0x6)),
+			SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE, 0);
+	}
+
+	gsw_w32(cdev, PCE_GCTRL_0_MC_VALID_OFFSET,
 		PCE_GCTRL_0_MC_VALID_SHIFT, PCE_GCTRL_0_MC_VALID_SIZE, 0x0);
-	
-		/* Download the microcode  */
-		for (i = 0; i < 64 /* PCE_MICRO_TABLE_SIZE */; i++) {
-				memset(&tbl_entry, 0, sizeof(tbl_entry));
-				tbl_entry.val[3] = pce_mc_max_ifx_tag_m[i].val_3;
-				tbl_entry.val[2] = pce_mc_max_ifx_tag_m[i].val_2;
-				tbl_entry.val[1] = pce_mc_max_ifx_tag_m[i].val_1;
-				tbl_entry.val[0] = pce_mc_max_ifx_tag_m[i].val_0;
-				tbl_entry.pcindex = i;
-				tbl_entry.table = PCE_PARS_INDEX;
-				gsw_pce_table_write(cdev, &tbl_entry);
-			}
 
-		gsw_w32(cdev, PCE_GCTRL_0_MC_VALID_OFFSET,
-			PCE_GCTRL_0_MC_VALID_SHIFT, PCE_GCTRL_0_MC_VALID_SIZE, 0x1);
-	
-		for (j = 0; j < gswdev->pnum; j++) {
-			gsw_w32(cdev, (SDMA_PCTRL_PEN_OFFSET + (j * 0x6)),
-				SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE, 1);
-		}
-		/* Enable RMON Counter for all ports */
-		for (j = 0; j < gswdev->pnum; j++) {
-			gsw_w32(cdev, (BM_PCFG_CNTEN_OFFSET + (j * 0x2)),
-				BM_PCFG_CNTEN_SHIFT, BM_PCFG_CNTEN_SIZE, 1);
-		}
-		gsw_w32(cdev, BM_QUEUE_GCTRL_GL_MOD_OFFSET,
-			BM_QUEUE_GCTRL_GL_MOD_SHIFT,
-			BM_QUEUE_GCTRL_GL_MOD_SIZE, 0);
+	/* Download the microcode  */
+	for (i = 0; i < 64 /* PCE_MICRO_TABLE_SIZE */; i++) {
+		memset(&tbl_entry, 0, sizeof(tbl_entry));
+		tbl_entry.val[3] = pce_mc_max_ifx_tag_m[i].val_3;
+		tbl_entry.val[2] = pce_mc_max_ifx_tag_m[i].val_2;
+		tbl_entry.val[1] = pce_mc_max_ifx_tag_m[i].val_1;
+		tbl_entry.val[0] = pce_mc_max_ifx_tag_m[i].val_0;
+		tbl_entry.pcindex = i;
+		tbl_entry.table = PCE_PARS_INDEX;
+		gsw_pce_table_write(cdev, &tbl_entry);
+	}
+
+	gsw_w32(cdev, PCE_GCTRL_0_MC_VALID_OFFSET,
+		PCE_GCTRL_0_MC_VALID_SHIFT, PCE_GCTRL_0_MC_VALID_SIZE, 0x1);
+
+	for (j = 0; j < gswdev->pnum; j++) {
+		gsw_w32(cdev, (SDMA_PCTRL_PEN_OFFSET + (j * 0x6)),
+			SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE, 1);
+	}
+
+	/* Enable RMON Counter for all ports */
+	for (j = 0; j < gswdev->pnum; j++) {
+		gsw_w32(cdev, (BM_PCFG_CNTEN_OFFSET + (j * 0x2)),
+			BM_PCFG_CNTEN_SHIFT, BM_PCFG_CNTEN_SIZE, 1);
+	}
+
+	gsw_w32(cdev, BM_QUEUE_GCTRL_GL_MOD_OFFSET,
+		BM_QUEUE_GCTRL_GL_MOD_SHIFT,
+		BM_QUEUE_GCTRL_GL_MOD_SIZE, 0);
 
 #if 0
-		printk("PARSER CODE DUMP\n\n");
-		for (i = 0; i < 64 /* PCE_MICRO_TABLE_SIZE */; i++) {
-			memset(&tbl_entry, 0, sizeof(tbl_entry));
-			tbl_entry.pcindex = i;
-			tbl_entry.table = PCE_PARS_INDEX;
-			tbl_entry.val[3] = pce_mc_max_ifx_tag_m[i].val_3;
-			tbl_entry.val[2] = pce_mc_max_ifx_tag_m[i].val_2;
-			gsw_pce_table_read(cdev, &tbl_entry);
-			printk("0x%04x , 0x%04x , 0x%04x , 0x%04x\n",tbl_entry.val[0],tbl_entry.val[1],tbl_entry.val[2],tbl_entry.val[3]);
-		}
-		printk("\n\nPARSER CODE DUMP Complete\n\n");
+	printk("PARSER CODE DUMP\n\n");
+
+	for (i = 0; i < 64 /* PCE_MICRO_TABLE_SIZE */; i++) {
+		memset(&tbl_entry, 0, sizeof(tbl_entry));
+		tbl_entry.pcindex = i;
+		tbl_entry.table = PCE_PARS_INDEX;
+		tbl_entry.val[3] = pce_mc_max_ifx_tag_m[i].val_3;
+		tbl_entry.val[2] = pce_mc_max_ifx_tag_m[i].val_2;
+		gsw_pce_table_read(cdev, &tbl_entry);
+		printk("0x%04x , 0x%04x , 0x%04x , 0x%04x\n", tbl_entry.val[0], tbl_entry.val[1], tbl_entry.val[2], tbl_entry.val[3]);
+	}
+
+	printk("\n\nPARSER CODE DUMP Complete\n\n");
 #endif
 
 	return 0;
@@ -1680,7 +1684,7 @@ int gsw_pmicro_code_init(void *cdev)
 	}
 
 	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
-		(gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
 	    (gswdev->gipver == LTQ_GSWIP_3_0) ||
 	    (IS_VRSN_31(gswdev->gipver)))
 		Gl_Mod_Size = BM_QUEUE_GCTRL_GL_MOD_SIZE2;
@@ -1783,13 +1787,14 @@ int pce_pattern_delete(void *cdev, ltq_pce_table_t *pthandle, u32 index)
 	/* Parer flags field */
 	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->parse1_msb_idx,
 			      pce_tm_flags_tbl_delete)
+
 	if (IS_VRSN_30_31(gswdev->gipver)) {
 		/* Payload1 field */
 		IFX_PCE_TM_IDX_DELETE(0xFF, ptable->payload1_idx,
-			      		pce_tm_payload_tbl_delete)
+				      pce_tm_payload_tbl_delete)
 		/* payload2 field */
 		IFX_PCE_TM_IDX_DELETE(0xFF, ptable->payload2_idx,
-			      		pce_tm_payload_tbl_delete)
+				      pce_tm_payload_tbl_delete)
 	}
 
 	/* DIP MSB */
@@ -2002,7 +2007,7 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 		parm->pattern.nDSCP = (ptbl.key[6] >> 8) & 0x3F;
 		parm->pattern.bDSCP_Enable = 1;
 	}
-	
+
 	/* Applicable for 3.0 or less*/
 	if (gswdev->gipver <= LTQ_GSWIP_3_0) {
 		if (ptbl.val[0] & 0x1) { //If port-map action set.
@@ -2018,7 +2023,7 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 				}
 			} else if (ptbl.val[1] != 0x0) { //If port-map IDs set.
 				parm->action.nForwardPortMap[0] = ptbl.val[1];
-	
+
 				if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
 					//If port-map type is 'tflow'.
 					parm->action.ePortMapAction =
@@ -2060,208 +2065,209 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 		/* Processing path type action value */
 		if (ptbl.val[8] & 0x1)
 			parm->action.eProcessPath_Action = (ptbl.val[8] >> 1) & 0x3;
-		
-		}
 
+	}
 
-		/* L3 Routing type action value */
-		if (gswdev->gipver == LTQ_GSWIP_3_0) {
-			if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
-				parm->action.bRtCtrlEna_Action = ptbl.val[9] & 0x1;
-				parm->action.bRtAccelEna_Action = (ptbl.val[9] >> 1) & 0x1;
-				parm->action.bRtInnerIPasKey_Action = (ptbl.val[9] >> 2) & 0x1;
 
-				if ((ptbl.val[9] >> 3) & 0x1)
-					parm->action.bRtSrcIpMaskCmp_Action = 0;
-				else
-					parm->action.bRtSrcIpMaskCmp_Action = 1;
+	/* L3 Routing type action value */
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+			parm->action.bRtCtrlEna_Action = ptbl.val[9] & 0x1;
+			parm->action.bRtAccelEna_Action = (ptbl.val[9] >> 1) & 0x1;
+			parm->action.bRtInnerIPasKey_Action = (ptbl.val[9] >> 2) & 0x1;
 
-				if ((ptbl.val[9] >> 4) & 0x1)
-					parm->action.bRtDstIpMaskCmp_Action = 0;
-				else
-					parm->action.bRtDstIpMaskCmp_Action = 1;
+			if ((ptbl.val[9] >> 3) & 0x1)
+				parm->action.bRtSrcIpMaskCmp_Action = 0;
+			else
+				parm->action.bRtSrcIpMaskCmp_Action = 1;
 
-				if ((ptbl.val[9] >> 5) & 0x1)
-					parm->action.bRtSrcPortMaskCmp_Action = 0;
-				else
-					parm->action.bRtSrcPortMaskCmp_Action = 1;
+			if ((ptbl.val[9] >> 4) & 0x1)
+				parm->action.bRtDstIpMaskCmp_Action = 0;
+			else
+				parm->action.bRtDstIpMaskCmp_Action = 1;
 
-				if ((ptbl.val[9] >> 6) & 0x1)
-					parm->action.bRtDstPortMaskCmp_Action = 0;
-				else
-					parm->action.bRtDstPortMaskCmp_Action = 1;
+			if ((ptbl.val[9] >> 5) & 0x1)
+				parm->action.bRtSrcPortMaskCmp_Action = 0;
+			else
+				parm->action.bRtSrcPortMaskCmp_Action = 1;
 
-				if (((ptbl.val[9] >> 8) & 0xFF) != 0xFF) {
-					parm->action.bRoutExtId_Action = 1;
-					parm->action.nRoutExtId = (ptbl.val[9] >> 8) & 0xFF;
-				}
-			}
+			if ((ptbl.val[9] >> 6) & 0x1)
+				parm->action.bRtDstPortMaskCmp_Action = 0;
+			else
+				parm->action.bRtDstPortMaskCmp_Action = 1;
 
-			/* Flow ID action value */
-			if ((ptbl.val[4] >> 4) & 0x1) {
-				parm->action.bFlowID_Action = 1;
-				parm->action.nFlowID = ptbl.val[1];
+			if (((ptbl.val[9] >> 8) & 0xFF) != 0xFF) {
+				parm->action.bRoutExtId_Action = 1;
+				parm->action.nRoutExtId = (ptbl.val[9] >> 8) & 0xFF;
 			}
 		}
 
-		/* Trunk port, port link selection action value */
-		parm->action.bPortLinkSelection = (ptbl.val[5] >> 1) & 0x1;
-		parm->action.bPortTrunkAction = (ptbl.val[5] >> 0) & 0x1;
-
-		/* Cross VLAN action value */
-		if ((ptbl.val[0] >> 4) & 0x1) {
-			if ((ptbl.val[3] >> 15) & 0x1)
-				parm->action.eVLAN_CrossAction =
-					GSW_PCE_ACTION_CROSS_VLAN_CROSS;
-			else
-				parm->action.eVLAN_CrossAction =
-					GSW_PCE_ACTION_CROSS_VLAN_REGULAR;
+		/* Flow ID action value */
+		if ((ptbl.val[4] >> 4) & 0x1) {
+			parm->action.bFlowID_Action = 1;
+			parm->action.nFlowID = ptbl.val[1];
 		}
+	}
 
-		/* Applicable for 3.0*/
-		if (gswdev->gipver == LTQ_GSWIP_3_0) {
-			parm->action.bPortBitMapMuxControl = (ptbl.val[6] >> 0) & 0x1;
+	/* Trunk port, port link selection action value */
+	parm->action.bPortLinkSelection = (ptbl.val[5] >> 1) & 0x1;
+	parm->action.bPortTrunkAction = (ptbl.val[5] >> 0) & 0x1;
 
-			if (parm->action.bPortBitMapMuxControl)
-				parm->action.nForwardPortMap[0] = ptbl.val[1];
+	/* Cross VLAN action value */
+	if ((ptbl.val[0] >> 4) & 0x1) {
+		if ((ptbl.val[3] >> 15) & 0x1)
+			parm->action.eVLAN_CrossAction =
+				GSW_PCE_ACTION_CROSS_VLAN_CROSS;
+		else
+			parm->action.eVLAN_CrossAction =
+				GSW_PCE_ACTION_CROSS_VLAN_REGULAR;
+	}
 
-			if (((ptbl.val[5] >> 2) & 0x1) 	&& ((ptbl.val[0] >> 1) & 0x1))
-				parm->action.bCVLAN_Ignore_Control = 1;
+	/* Applicable for 3.0*/
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		parm->action.bPortBitMapMuxControl = (ptbl.val[6] >> 0) & 0x1;
 
-			if ((ptbl.val[0] >> 1) & 0x1) {
-				parm->action.eSVLAN_Action = 1;
-				parm->action.nSVLAN_Id = (ptbl.val[6] >> 4) & 0xFFF;
-				//parm->action.nFId = ((ptbl.val[2] >> 8) & 0xFF);
-			}
+		if (parm->action.bPortBitMapMuxControl)
+			parm->action.nForwardPortMap[0] = ptbl.val[1];
 
-			if ((ptbl.val[0] >> 1) & 0x1) { //Govind - 3.0 same flag for both eVLAN_Action n eSVLAN_Action?
-				parm->action.eVLAN_Action = 1;
-				parm->action.nVLAN_Id = (ptbl.val[5] >> 4) & 0xFFF;
-				parm->action.nFId = ((ptbl.val[2] >> 8) & 0xFF);
-			}
+		if (((ptbl.val[5] >> 2) & 0x1) 	&& ((ptbl.val[0] >> 1) & 0x1))
+			parm->action.bCVLAN_Ignore_Control = 1;
+
+		if ((ptbl.val[0] >> 1) & 0x1) {
+			parm->action.eSVLAN_Action = 1;
+			parm->action.nSVLAN_Id = (ptbl.val[6] >> 4) & 0xFFF;
+			//parm->action.nFId = ((ptbl.val[2] >> 8) & 0xFF);
 		}
 
-		//Extended VLAN tagging action.
-		if (IS_VRSN_31(gswdev->gipver)) {
-			if ((ptbl.val[6] >> 3) & 0x1) {
-				parm->action.bExtendedVlanEnable = 1; //Enable extended VLAN tagging.
-				parm->action.nExtendedVlanBlockId = (ptbl.val[6] >> 4) & 0x3FF;
-			}
+		if ((ptbl.val[0] >> 1) & 0x1) { //Govind - 3.0 same flag for both eVLAN_Action n eSVLAN_Action?
+			parm->action.eVLAN_Action = 1;
+			parm->action.nVLAN_Id = (ptbl.val[5] >> 4) & 0xFFF;
+			parm->action.nFId = ((ptbl.val[2] >> 8) & 0xFF);
 		}
+	}
 
-		/* Applicable for 3.0*/
-		if (IS_VRSN_NOT_31(gswdev->gipver)) {
-			if ((ptbl.val[0] >> 12) & 0x1) {
-				parm->action.bRMON_Action = 1;
-				parm->action.nRMON_Id = (((ptbl.val[4] >> 8) & 0x1F) - 1);
-			}
+	//Extended VLAN tagging action.
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if ((ptbl.val[6] >> 3) & 0x1) {
+			parm->action.bExtendedVlanEnable = 1; //Enable extended VLAN tagging.
+			parm->action.nExtendedVlanBlockId = (ptbl.val[6] >> 4) & 0x3FF;
+		}
+	}
 
-			if ((ptbl.val[0] >> 11) & 0x1) {
-				parm->action.eMeterAction = (ptbl.val[3] >> 6) & 0x3;
-				parm->action.nMeterId = ptbl.val[3] & 0x1F;
-			}
+	/* Applicable for 3.0*/
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if ((ptbl.val[0] >> 12) & 0x1) {
+			parm->action.bRMON_Action = 1;
+			parm->action.nRMON_Id = (((ptbl.val[4] >> 8) & 0x1F) - 1);
+		}
 
-			if (!((ptbl.val[3] >> 13) & 0x1))
-				parm->action.bRemarkClass = 1;
+		if ((ptbl.val[0] >> 11) & 0x1) {
+			parm->action.eMeterAction = (ptbl.val[3] >> 6) & 0x3;
+			parm->action.nMeterId = ptbl.val[3] & 0x1F;
+		}
 
-			if (!((ptbl.val[3] >> 12) & 0x1))
-				parm->action.bRemarkDSCP = 1;
+		if (!((ptbl.val[3] >> 13) & 0x1))
+			parm->action.bRemarkClass = 1;
 
-			if (!((ptbl.val[6] >> 2) & 0x1))
-				parm->action.bRemarkSTAG_DEI = 1;
+		if (!((ptbl.val[3] >> 12) & 0x1))
+			parm->action.bRemarkDSCP = 1;
 
-			if (!((ptbl.val[6] >> 1) & 0x1))
-				parm->action.bRemarkSTAG_PCP = 1;
+		if (!((ptbl.val[6] >> 2) & 0x1))
+			parm->action.bRemarkSTAG_DEI = 1;
 
-			if (!((ptbl.val[3] >> 14) & 0x1))
-				parm->action.bRemarkPCP = 1;
+		if (!((ptbl.val[6] >> 1) & 0x1))
+			parm->action.bRemarkSTAG_PCP = 1;
 
-			if ((ptbl.val[0] >> 3) & 0x1)
-				parm->action.bRemarkAction = 1;
+		if (!((ptbl.val[3] >> 14) & 0x1))
+			parm->action.bRemarkPCP = 1;
 
-			if ((ptbl.val[0] >> 6) & 0x1) {
-				if ((ptbl.val[4] >> 14) & 0x1)
-					parm->action.eCritFrameAction =
-						GSW_PCE_ACTION_CRITICAL_FRAME_CRITICAL;
-				else
-					parm->action.eCritFrameAction =
-						GSW_PCE_ACTION_CRITICAL_FRAME_REGULAR;
-			}
+		if ((ptbl.val[0] >> 3) & 0x1)
+			parm->action.bRemarkAction = 1;
+
+		if ((ptbl.val[0] >> 6) & 0x1) {
+			if ((ptbl.val[4] >> 14) & 0x1)
+				parm->action.eCritFrameAction =
+					GSW_PCE_ACTION_CRITICAL_FRAME_CRITICAL;
+			else
+				parm->action.eCritFrameAction =
+					GSW_PCE_ACTION_CRITICAL_FRAME_REGULAR;
 		}
+	}
 
-		/* RMON counter action value */
-		if (IS_VRSN_31(gswdev->gipver)) {
-			if ((ptbl.val[4] >> 4) & 0x1) {
-				parm->action.bRMON_Action = parm->action.bFlowID_Action = 1;
-				parm->action.nRMON_Id = parm->action.nFlowID =
-								ptbl.val[1] & 0xFF;
-			}
+	/* RMON counter action value */
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if ((ptbl.val[4] >> 4) & 0x1) {
+			parm->action.bRMON_Action = parm->action.bFlowID_Action = 1;
+			parm->action.nRMON_Id = parm->action.nFlowID =
+							ptbl.val[1] & 0xFF;
+		}
 
-			/* Metering and counter action value */
-			if ((ptbl.val[0] >> 11) & 0x1) {
-				if ((ptbl.val[3] >> 7) & 0x1) {
-					parm->action.eMeterAction = GSW_PCE_ACTION_METER_1;
-					parm->action.nMeterId = ptbl.val[3] & 0x7F;
-				} else {
-					parm->action.eMeterAction = GSW_PCE_ACTION_METER_REGULAR;
-				}
+		/* Metering and counter action value */
+		if ((ptbl.val[0] >> 11) & 0x1) {
+			if ((ptbl.val[3] >> 7) & 0x1) {
+				parm->action.eMeterAction = GSW_PCE_ACTION_METER_1;
+				parm->action.nMeterId = ptbl.val[3] & 0x7F;
+			} else {
+				parm->action.eMeterAction = GSW_PCE_ACTION_METER_REGULAR;
 			}
+		}
 
-			/* FID action control */
-			if ((ptbl.val[5] >> 3) & 0x1) {
-				parm->action.bFidEnable = 1;
-				parm->action.nFId = (ptbl.val[2] >> 8) & 0x3F;
-			}
+		/* FID action control */
+		if ((ptbl.val[5] >> 3) & 0x1) {
+			parm->action.bFidEnable = 1;
+			parm->action.nFId = (ptbl.val[2] >> 8) & 0x3F;
 		}
+	}
 
-		/* Applicable for 3.1*/
-		if (IS_VRSN_31(gswdev->gipver)) {
-			if (ptbl.val[0] & 0x1) { //If port-map action set.
-				if (!(ptbl.val[10]) && !(ptbl.val[11]) && !(ptbl.val[12]) &&
-				    !(ptbl.val[13]) && !(ptbl.val[14]) && !(ptbl.val[15]) &&
-				    !(ptbl.val[16]) && !(ptbl.val[17])) {
-					//If port-map IDs not set.
-					if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
-						//If port-map type is 'tflow'.
-						parm->action.ePortMapAction =
-							GSW_PCE_ACTION_PORTMAP_DISCARD;
-					} else if (((ptbl.val[4] >> 2) & 0x3) == 0x0) {
-						//If port-map type is 'default'.
-						parm->action.ePortMapAction =
-							GSW_PCE_ACTION_PORTMAP_REGULAR;
-					}
-				} else if (((ptbl.val[10]) || (ptbl.val[11]) || (ptbl.val[12])) ||
-					   ((ptbl.val[13]) || (ptbl.val[14]) || (ptbl.val[15])) ||
-					   ((ptbl.val[16]) || (ptbl.val[17]))) {
-					/* It is 'traffic-flow' portmap type */
-					for (i = 0; i <= 7; i++)
-						parm->action.nForwardPortMap[i] = ptbl.val[i + 10];
-
-					if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
-						//If port-map type is 'tflow'.
-						parm->action.ePortMapAction =
-							GSW_PCE_ACTION_PORTMAP_ALTERNATIVE;
-					} else if (((ptbl.val[4] >> 2) & 0x3) == 0x1) {
-						//If port-map type is 'MC router'.
-						parm->action.ePortMapAction =
-							GSW_PCE_ACTION_PORTMAP_CPU;
-					}
+	/* Applicable for 3.1*/
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if (ptbl.val[0] & 0x1) { //If port-map action set.
+			if (!(ptbl.val[10]) && !(ptbl.val[11]) && !(ptbl.val[12]) &&
+			    !(ptbl.val[13]) && !(ptbl.val[14]) && !(ptbl.val[15]) &&
+			    !(ptbl.val[16]) && !(ptbl.val[17])) {
+				//If port-map IDs not set.
+				if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
+					//If port-map type is 'tflow'.
+					parm->action.ePortMapAction =
+						GSW_PCE_ACTION_PORTMAP_DISCARD;
+				} else if (((ptbl.val[4] >> 2) & 0x3) == 0x0) {
+					//If port-map type is 'default'.
+					parm->action.ePortMapAction =
+						GSW_PCE_ACTION_PORTMAP_REGULAR;
+				}
+			} else if (((ptbl.val[10]) || (ptbl.val[11]) || (ptbl.val[12])) ||
+				   ((ptbl.val[13]) || (ptbl.val[14]) || (ptbl.val[15])) ||
+				   ((ptbl.val[16]) || (ptbl.val[17]))) {
+				/* It is 'traffic-flow' portmap type */
+				for (i = 0; i <= 7; i++)
+					parm->action.nForwardPortMap[i] = ptbl.val[i + 10];
+
+				if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
+					//If port-map type is 'tflow'.
+					parm->action.ePortMapAction =
+						GSW_PCE_ACTION_PORTMAP_ALTERNATIVE;
+				} else if (((ptbl.val[4] >> 2) & 0x3) == 0x1) {
+					//If port-map type is 'MC router'.
+					parm->action.ePortMapAction =
+						GSW_PCE_ACTION_PORTMAP_CPU;
 				}
 			}
 		}
+	}
 
-		/* Color action */
-		if (IS_VRSN_31(gswdev->gipver)) {
-			if ((ptbl.val[0] >> 6) & 0x1) {
-				if ((ptbl.val[2] & 0x7) < 4) {
-					parm->action.eColorFrameAction =
-						GSW_PCE_ACTION_COLOR_FRAME_NO_CHANGE;
-				} else {
-					parm->action.eColorFrameAction = (ptbl.val[2] & 0x7) - 2;
-				}
+	/* Color action */
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if ((ptbl.val[0] >> 6) & 0x1) {
+			if ((ptbl.val[2] & 0x7) < 4) {
+				parm->action.eColorFrameAction =
+					GSW_PCE_ACTION_COLOR_FRAME_NO_CHANGE;
+			} else {
+				parm->action.eColorFrameAction = (ptbl.val[2] & 0x7) - 2;
 			}
 		}
-		if (IS_VRSN_30_31(gswdev->gipver)) {
+	}
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
 
 		/* TS action control */
 		if ((ptbl.val[0] >> 7) & 0x1) {
@@ -2295,33 +2301,33 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 		} else
 			parm->action.eIrqAction = GSW_PCE_ACTION_IRQ_DISABLE;
 
-		}
+	}
 
 
-		/* MAC learning action control */
-		if ((ptbl.val[0] >> 9) & 0x1) {
-			if (((ptbl.val[4]) & 0x3) == 0)
-				parm->action.eLearningAction = GSW_PCE_ACTION_LEARNING_REGULAR;
-			else if (((ptbl.val[4]) & 0x3) == 1)
-				parm->action.eLearningAction = GSW_PCE_ACTION_LEARNING_DISABLE;
-			else
-				parm->action.eLearningAction = (ptbl.val[4]) & 0x3;
-		}
+	/* MAC learning action control */
+	if ((ptbl.val[0] >> 9) & 0x1) {
+		if (((ptbl.val[4]) & 0x3) == 0)
+			parm->action.eLearningAction = GSW_PCE_ACTION_LEARNING_REGULAR;
+		else if (((ptbl.val[4]) & 0x3) == 1)
+			parm->action.eLearningAction = GSW_PCE_ACTION_LEARNING_DISABLE;
+		else
+			parm->action.eLearningAction = (ptbl.val[4]) & 0x3;
+	}
 
-		/* IGMP snooping action control */
-		if ((ptbl.val[0] >> 10) & 0x1)
-			parm->action.eSnoopingTypeAction = ((ptbl.val[4] >> 5) & 0x7) + 1;
+	/* IGMP snooping action control */
+	if ((ptbl.val[0] >> 10) & 0x1)
+		parm->action.eSnoopingTypeAction = ((ptbl.val[4] >> 5) & 0x7) + 1;
 
-		/* Traffic class action control */
-		if ((ptbl.val[0] >> 2) & 1) {
-			if ((ptbl.val[0] >> 14) & 1) {
-				parm->action.eTrafficClassAction =
-					GSW_PCE_ACTION_TRAFFIC_CLASS_ALTERNATIVE;
-				parm->action.nTrafficClassAlternate = (ptbl.val[3] >> 8) & 0xF;
-			} else
-				parm->action.eTrafficClassAction =
-					GSW_PCE_ACTION_TRAFFIC_CLASS_REGULAR;
-		}
+	/* Traffic class action control */
+	if ((ptbl.val[0] >> 2) & 1) {
+		if ((ptbl.val[0] >> 14) & 1) {
+			parm->action.eTrafficClassAction =
+				GSW_PCE_ACTION_TRAFFIC_CLASS_ALTERNATIVE;
+			parm->action.nTrafficClassAlternate = (ptbl.val[3] >> 8) & 0xF;
+		} else
+			parm->action.eTrafficClassAction =
+				GSW_PCE_ACTION_TRAFFIC_CLASS_REGULAR;
+	}
 
 	/* Inner CoS & DEI field value for 3.0 */
 	if (IS_VRSN_NOT_31(gswdev->gipver)) {
@@ -2469,16 +2475,16 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 			parm->pattern.nParserFlagMSB = flags_tbl.parser_flag_data;
 			parm->pattern.nParserFlagMSB_Mask = flags_tbl.mask_value;
 		}
-		
+
 		/* Payload1 field table */
 		if (ptable->payload1_idx != 0xFF) { //Is table enabled?
 			payload_tbl_t payload_tbl;
 			memset(&payload_tbl, 0, sizeof(payload_tbl_t));
-		
+
 			if (0 != pce_tm_payload_tbl_read(&pthandle->pce_sub_tbl,
 							 ptable->payload1_idx, &payload_tbl))
 				GSW_RETURN_PCE;
-		
+
 			/* Destination Application used */
 			parm->pattern.bPayload1_SrcEnable = 1;
 			/* Destination Application field */
@@ -2488,16 +2494,16 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 			/* Payload	mask/range */
 			parm->pattern.nPayload1_Mask = payload_tbl.mask_range;
 		}
-		
+
 		/* Payload2 field table */
 		if (ptable->payload2_idx != 0xFF) { //Is table enabled?
 			payload_tbl_t payload_tbl;
 			memset(&payload_tbl, 0, sizeof(payload_tbl_t));
-		
+
 			if (0 != pce_tm_payload_tbl_read(&pthandle->pce_sub_tbl,
 							 ptable->payload2_idx, &payload_tbl))
 				GSW_RETURN_PCE;
-		
+
 			/* Destination Application used */
 			parm->pattern.bPayload2_SrcEnable = 1;
 			/* Destination Application field */
@@ -3026,18 +3032,18 @@ int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 	}
 
 	if (IS_VRSN_30_31(gswdev->gipver)) {
-	/* OAM and Extraction flags field table */
-	if (((ptbl.val[8] >> 3) & 0x1) || ((ptbl.val[7] >> 8) & 0x1)) {
-		/*OAM flag*/
-		if ((ptbl.val[8] >> 3) & 0x1) {
-			parm->action.bOamEnable = 1;
-			/*OAM and extraction packet control*/
-			parm->action.nRecordId = ((ptbl.val[8] >> 4) & 0xFFF);
-		}
+		/* OAM and Extraction flags field table */
+		if (((ptbl.val[8] >> 3) & 0x1) || ((ptbl.val[7] >> 8) & 0x1)) {
+			/*OAM flag*/
+			if ((ptbl.val[8] >> 3) & 0x1) {
+				parm->action.bOamEnable = 1;
+				/*OAM and extraction packet control*/
+				parm->action.nRecordId = ((ptbl.val[8] >> 4) & 0xFFF);
+			}
 
-		/*Extraction flag*/
-		if ((ptbl.val[7] >> 8) & 0x1) {
-			parm->action.bExtractEnable = 1;
+			/*Extraction flag*/
+			if ((ptbl.val[7] >> 8) & 0x1) {
+				parm->action.bExtractEnable = 1;
 			}
 		}
 	}
@@ -3985,7 +3991,7 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 								    parm->pattern.nSLAN_Vid, 0, 0);
 			}
 		}
-		
+
 		ptable->svlan_idx = tindex;
 		ptbl.key[8] &= ~(0xFF << 8);
 		ptbl.key[8] |= (ptable->svlan_idx << 8);
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_init.c b/drivers/net/ethernet/lantiq/switch-api/gsw_init.c
index 86db7a8d2c5b..ecb17c8a0f83 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_init.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_init.c
@@ -415,13 +415,12 @@ void gsw_r32_raw(void *cdev, short offset, u32 *value)
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return;
 	}
-	
+
 	if (pethdev->gsw_base != 0) {
 		*value = gsw1_r32((volatile void *)pethdev->gsw_base + (offset * 4));
-	}
-	else {
+	} else {
 		/*external switch*/
-		gsw_ext_r32(cdev,offset,0,16,value);
+		gsw_ext_r32(cdev, offset, 0, 16, value);
 	}
 
 }
@@ -439,14 +438,14 @@ void gsw_w32_raw(void *cdev, short offset, u32 value)
 		gsw1_w32(value, (volatile void *)(pethdev->gsw_base + (offset * 4)));
 	} else {
 		/*external switch*/
-		gsw_ext_w32(cdev,offset,0,16,value);
+		gsw_ext_w32(cdev, offset, 0, 16, value);
 	}
 }
 
 
 int GSW_SMDIO_DataRead(void *cdev, GSW_MDIO_data_t *pPar)
 {
-	int ret=0;
+	int ret = 0;
 	ethsw_api_dev_t *pethdev = GSW_PDATA_GET(cdev);
 
 #ifdef CONFIG_X86_INTEL_CE2700
@@ -456,8 +455,8 @@ int GSW_SMDIO_DataRead(void *cdev, GSW_MDIO_data_t *pPar)
 	pPar->nData = data & 0xFFFF;
 #else
 	struct core_ops *gsw_ops;
-	gsw_ops=gsw_get_swcore_ops(pethdev->parent_devid);
-	gsw_ops->gsw_common_ops.MDIO_DataRead(gsw_ops,pPar);
+	gsw_ops = gsw_get_swcore_ops(pethdev->parent_devid);
+	gsw_ops->gsw_common_ops.MDIO_DataRead(gsw_ops, pPar);
 
 #endif
 	return ret;
@@ -465,16 +464,16 @@ int GSW_SMDIO_DataRead(void *cdev, GSW_MDIO_data_t *pPar)
 
 int GSW_SMDIO_DataWrite(void *cdev, GSW_MDIO_data_t *pPar)
 {
-	int ret=0;
+	int ret = 0;
 	ethsw_api_dev_t *pethdev = GSW_PDATA_GET(cdev);
 
 #ifdef CONFIG_X86_INTEL_CE2700
 	ret = DWC_ETH_QOS_mdio_write_direct(MDIO_BUS_NUMBER_0, C45_ENABLED,
-					     MDIO_ADDR_LANTIQ, MMD_DISABLED, pPar->nAddressReg & 0x1F, pPar->nData & 0xFFFF);
+					    MDIO_ADDR_LANTIQ, MMD_DISABLED, pPar->nAddressReg & 0x1F, pPar->nData & 0xFFFF);
 #else
 	struct core_ops *gsw_ops;
-	gsw_ops=gsw_get_swcore_ops(pethdev->parent_devid);
-	gsw_ops->gsw_common_ops.MDIO_DataWrite(gsw_ops,pPar);
+	gsw_ops = gsw_get_swcore_ops(pethdev->parent_devid);
+	gsw_ops->gsw_common_ops.MDIO_DataWrite(gsw_ops, pPar);
 #endif
 
 	return ret;
@@ -510,7 +509,7 @@ void gsw_ext_r32(void *cdev, short offset, short shift, short size, u32 *value)
 	mask = (1 << size) - 1;
 	rvalue = (rvalue >> shift);
 	*value = (rvalue & mask);
-	
+
 }
 
 /** read and update the GSWIP register */
@@ -614,15 +613,15 @@ void gsw_r32(void *cdev, short offset, short shift, short size, u32 *value)
 	} else {
 
 #ifdef __KERNEL__
-	/*external switch*/
-		if(pethdev->ext_devid) {
-			gsw_ext_r32(cdev,offset,shift,size,value);
-		}
-		else
+
+		/*external switch*/
+		if (pethdev->ext_devid) {
+			gsw_ext_r32(cdev, offset, shift, size, value);
+		} else
 #endif
 			pr_err("%s:%s:%d,(ERROR)\n", __FILE__, __func__, __LINE__);
 	}
-	
+
 }
 
 /** read and update the GSWIP register */
@@ -658,9 +657,10 @@ void gsw_w32(void *cdev, short offset, short shift, short size, u32 value)
 	} else {
 
 #ifdef __KERNEL__
+
 		/*external switch*/
-		if(pethdev->ext_devid)
-			gsw_ext_w32(cdev,offset,shift,size,value);
+		if (pethdev->ext_devid)
+			gsw_ext_w32(cdev, offset, shift, size, value);
 		else
 #endif
 			pr_err("%s:%s:%d,(ERROR)\n", __FILE__, __func__, __LINE__);
@@ -998,7 +998,7 @@ int ltq_gsw_api_register(struct platform_device *pdev)
 	}
 
 	if (device_id == 1) {
-		ethsw_api_dev_t *PrvData,*ExtPrvData;
+		ethsw_api_dev_t *PrvData, *ExtPrvData;
 		struct core_ops *ops;
 
 		/* Init FLOW Switch Core Layer */
@@ -1024,9 +1024,9 @@ int ltq_gsw_api_register(struct platform_device *pdev)
 		/** Get Switch Core Private Data */
 		PrvData = container_of(ops, ethsw_api_dev_t, ops);
 
-		if(PrvData->ext_devid == LTQ_FLOW_DEV_EXT_AX3000_F24S) {
+		if (PrvData->ext_devid == LTQ_FLOW_DEV_EXT_AX3000_F24S) {
 			ethsw_core_init_t ext_core_init;
-			
+
 			/** Clear core_init */
 			memset(&ext_core_init, 0, sizeof(ethsw_core_init_t));
 
@@ -1037,21 +1037,23 @@ int ltq_gsw_api_register(struct platform_device *pdev)
 			gsw1_w32(0x800,	(volatile void *)0xb6080120);
 			gsw1_w32(0x7c,	(volatile void *)0xbc003c1c);
 			gsw1_w32(0x1806,	(volatile void *)0xba003d10);
-			gsw1_w32(0x100800,  (volatile void *)0xb6080120);
-			gsw1_w32(0x80000000,  (volatile void *)0xb6000010);
-			gsw1_w32(0x0,  (volatile void *)0xb6000010);
-			gsw1_w32(0xff,  (volatile void *)0xb6D00034);
-			gsw1_w32(0xff,  (volatile void *)0xb6D00044);
-			gsw1_w32(0x00008800,  (volatile void *)0xb6D002B8);
+			gsw1_w32(0x100800, (volatile void *)0xb6080120);
+			gsw1_w32(0x80000000, (volatile void *)0xb6000010);
+			gsw1_w32(0x0, (volatile void *)0xb6000010);
+			gsw1_w32(0xff, (volatile void *)0xb6D00034);
+			gsw1_w32(0xff, (volatile void *)0xb6D00044);
+			gsw1_w32(0x00008800, (volatile void *)0xb6D002B8);
 #endif
 			ExtPrvData = (void *)kmalloc(sizeof(ethsw_api_dev_t), GFP_KERNEL);
-			if (ExtPrvData== NULL) {
+
+			if (ExtPrvData == NULL) {
 				pr_err("%s:%s:%d (Exterenal switch:LTQ_FLOW_DEV_EXT_AX3000_F24S Init Failed)\n",
-			       __FILE__, __func__, __LINE__);
+				       __FILE__, __func__, __LINE__);
 				return -1;
 			}
+
 			memset(ExtPrvData, 0, sizeof(ethsw_api_dev_t));
-			
+
 			/*init external switch private data*/
 			ExtPrvData->cport = GSW_2X_SOC_CPU_PORT;
 			ExtPrvData->gsw_dev = LTQ_FLOW_DEV_EXT_AX3000_F24S;
@@ -1060,22 +1062,23 @@ int ltq_gsw_api_register(struct platform_device *pdev)
 			ExtPrvData->ext_phyid = PrvData->ext_phyid;
 			ExtPrvData->gswex_base = PrvData->gswex_base;
 			ExtPrvData->gswex_sgmiibase = PrvData->gswex_sgmiibase;
-			
+
 			/* Init External Switch Core Layer */
 			ext_core_init.sdev = LTQ_FLOW_DEV_EXT_AX3000_F24S;
 			ext_core_init.gsw_base_addr = NULL;
 			ext_core_init.pdev = (void *)ExtPrvData;
 			pEDevExt = ethsw_api_core_init(&ext_core_init);
+
 			if (pEDevExt == NULL) {
 				pr_err("%s:%s:%d (Init Failed)\n",
 				       __FILE__, __func__, __LINE__);
 				return -1;
 			}
-			
+
 		}
 
 	}
-	
+
 
 	if (device_id == 0) {
 		ioct_cmd_start_node = gsw_create_ioctl_cmd_linklist(&pEDev0->ops);
@@ -1097,13 +1100,14 @@ int ltq_gsw_api_register(struct platform_device *pdev)
 	/* add Internal switch */
 	if ((device_id == 1) && pioctlctl && pEDev1) {
 		ioctl_wrapper_dev_add(pioctlctl, &pEDev1->ops, LTQ_FLOW_DEV_INT_R);
-		
+
 		/* Init wrapper , if external switch attached to GSWIP-R*/
 		if ((pEDev1->ext_devid == LTQ_FLOW_DEV_EXT_AX3000_F24S) && pioctlctl && pEDevExt) {
 			ioctl_wrapper_dev_add(pioctlctl, &pEDevExt->ops, LTQ_FLOW_DEV_EXT_AX3000_F24S);
 		}
 
 	}
+
 	return 0;
 }
 #endif /* CONFIG_SOC_GRX500 */
