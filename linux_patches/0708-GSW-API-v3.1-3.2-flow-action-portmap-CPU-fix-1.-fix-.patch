From 99a47416f59ef037bda16ce00d2fad5daa67305b Mon Sep 17 00:00:00 2001
From: Xu Liang <liang.xu@intel.com>
Date: Tue, 23 Jul 2019 17:04:19 +0800
Subject: [PATCH] GSW API: v3.1/3.2 flow action portmap CPU fix 1. fix wrong
 capability of HW Multicast table 2. add CPU port for GSWIP3.1
 GSW_PCE_ACTION_PORTMAP_CPU

---
 .../net/ethernet/lantiq/switch-api/gsw_flow_core.c |  2 +-
 .../net/ethernet/lantiq/switch-api/gsw_flow_pce.c  | 41 ++++++++++++++--------
 2 files changed, 28 insertions(+), 15 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
index 764172eff983..48175dd3dc6d 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
@@ -2559,7 +2559,7 @@ static void get_gsw_hw_cap(void *cdev)
 		gsw_r32(cdev, ETHSW_CAP_16_MCASTHW_OFFSET,
 			ETHSW_CAP_16_MCASTHW_SHIFT,
 			ETHSW_CAP_16_MCASTHW_SIZE, &reg_val);
-		gswdev->mcsthw_snoop = reg_val;
+		gswdev->mcsthw_snoop = reg_val ? MCAST_HWSNOOP_DIS : MCAST_HWSNOOP_EN;
 
 		gsw_r32(cdev, ETHSW_CAP_17_BRG_OFFSET,
 			ETHSW_CAP_17_BRG_SHIFT,
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
index 083c843af551..a57f4bc666f4 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
@@ -4183,23 +4183,36 @@ int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
 
 			case GSW_PCE_ACTION_PORTMAP_CPU:
 			case GSW_PCE_ACTION_PORTMAP_ALTERNATIVE:
-				if (gswdev->gipver <= LTQ_GSWIP_3_0) {
-					/* CPU port-map */ //Govind - Need to test for 3.0 with MC router.
+				if (IS_VRSN_BELOW_31(gswdev->gipver)) {
 					ptbl.val[1] = (paction->nForwardPortMap[0] & 0xFFFF);
-				}
 
-				if (IS_VRSN_31(gswdev->gipver)) {
-					for (i = 0; i <= 7; i++)
-						ptbl.val[i + 10] = (paction->nForwardPortMap[i]);
-				}
+					if (paction->ePortMapAction == GSW_PCE_ACTION_PORTMAP_CPU) {
+						/* Applicable for 2.1/2.2/3.0
+						   or multicast hardware enabled */
+						/* set to 'MC router' portmap MUX control */
+						ptbl.val[4] &= ~(0x3 << 2);
+						ptbl.val[4] |= (0x1 << 2);
+					}
+				} else {
+					u16 map = 0;
 
-				//If CPU type set to 'MC router' portmap MUX control.
-				if ((paction->ePortMapAction == GSW_PCE_ACTION_PORTMAP_CPU) &&
-					((IS_VRSN_BELOW_31(gswdev->gipver)) ||
-					(gswdev->mcsthw_snoop == MCAST_HWSNOOP_EN))) {
-					/*Applicable for 3.0 and when multicast hardware enabled */
-					ptbl.val[4] &= ~(0x3 << 2);
-					ptbl.val[4] |= (0x1 << 2); /* set to 'MC router' portmap MUX control */
+					for (i = 0; i < 8; i++) {
+						ptbl.val[i + 10] = paction->nForwardPortMap[i];
+						map |= paction->nForwardPortMap[i];
+					}
+
+					if (paction->ePortMapAction == GSW_PCE_ACTION_PORTMAP_CPU) {
+						if (gswdev->mcsthw_snoop == MCAST_HWSNOOP_EN) {
+							/* Applicable for 2.1/2.2/3.0
+							   or multicast hardware enabled */
+							/* set to 'MC router' portmap MUX control */
+							ptbl.val[4] &= ~(0x3 << 2);
+							ptbl.val[4] |= (0x1 << 2);
+						} else if (map == 0) {
+							map = 1 << (gswdev->cport % 16);
+							ptbl.val[10 + gswdev->cport / 16] = map;
+						}
+					}
 				}
 
 				break;
