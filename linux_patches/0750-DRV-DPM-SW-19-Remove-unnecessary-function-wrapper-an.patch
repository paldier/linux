From c2aecfddddcfda755c9242df71fb90694c9cb4e8 Mon Sep 17 00:00:00 2001
From: Gu Chao <gux.chao@intel.com>
Date: Fri, 16 Aug 2019 17:32:32 +0800
Subject: [PATCH] DRV_DPM_SW-19: Remove unnecessary function wrapper and
 typecast

---
 drivers/net/datapath/dpm/datapath.h                |   2 -
 drivers/net/datapath/dpm/gswip30/datapath_coc.c    |  90 +++-----
 drivers/net/datapath/dpm/gswip30/datapath_gswip.c  |  30 +--
 drivers/net/datapath/dpm/gswip30/datapath_mib.c    |  43 ++--
 drivers/net/datapath/dpm/gswip30/datapath_misc.h   |   8 -
 drivers/net/datapath/dpm/gswip30/datapath_proc.c   |  22 +-
 drivers/net/datapath/dpm/gswip31/datapath_gswip.c  | 222 +++++++------------
 drivers/net/datapath/dpm/gswip31/datapath_misc.c   |  92 ++++----
 drivers/net/datapath/dpm/gswip31/datapath_misc.h   |   7 -
 drivers/net/datapath/dpm/gswip31/datapath_proc.c   |  16 +-
 .../net/datapath/dpm/gswip31/datapath_switchdev.c  | 132 +++++------
 drivers/net/datapath/dpm/gswip32/datapath_gswip.c  | 246 ++++++++-------------
 drivers/net/datapath/dpm/gswip32/datapath_misc.c   |  88 ++++----
 drivers/net/datapath/dpm/gswip32/datapath_misc.h   |   5 -
 drivers/net/datapath/dpm/gswip32/datapath_proc.c   |  16 +-
 .../net/datapath/dpm/gswip32/datapath_switchdev.c  | 133 +++++------
 16 files changed, 440 insertions(+), 712 deletions(-)

diff --git a/drivers/net/datapath/dpm/datapath.h b/drivers/net/datapath/dpm/datapath.h
index b8fa9c2e1bcd..64aab089b0ee 100644
--- a/drivers/net/datapath/dpm/datapath.h
+++ b/drivers/net/datapath/dpm/datapath.h
@@ -149,7 +149,6 @@
 
 #define PARSER_FLAG_SIZE   40
 #define PARSER_OFFSET_SIZE 8
-#define DP_PMAC_OPS(gsw, cmd) ((dp_gsw_cb)(gsw)->gsw_pmac_ops.cmd)
 
 #define PKT_PASER_FLAG_OFFSET   0
 #define PKT_PASER_OFFSET_OFFSET (PARSER_FLAG_SIZE)
@@ -881,7 +880,6 @@ int get_dp_port_status_str_size(void);
 
 int dp_request_inst(struct dp_inst_info *info, u32 flag);
 int register_dp_cap(u32 flag);
-typedef GSW_return_t(*dp_gsw_cb)(void *, void *);
 int bp_pmapper_dev_get(int inst, struct net_device *dev);
 extern int dp_init_ok;
 void set_chksum(struct pmac_tx_hdr *pmac, u32 tcp_type,
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_coc.c b/drivers/net/datapath/dpm/gswip30/datapath_coc.c
index b3566e3e8038..9648fbf4f743 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_coc.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_coc.c
@@ -142,13 +142,11 @@ void proc_coc_read_30(struct seq_file *s)
 	/*PCE_OVERHD */
 	memset(&reg, 0, sizeof(reg));
 	reg.nRegAddr = 0x46C;	/*PCE_OVERHD */
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.RegisterGet,
-		     gsw_handle, &reg);
+	gsw_handle->gsw_common_ops.RegisterGet(gsw_handle, &reg);
 	seq_printf(s, "    PCE_OVERHD=%d\n", reg.nData);
 
 	meter_cfg.nMeterId = meter_id;
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_MeterCfgGet,
-		     gsw_handle, &meter_cfg);
+	gsw_handle->gsw_qos_ops.QoS_MeterCfgGet(gsw_handle, &meter_cfg);
 	seq_printf(s, "    meter id=%u (%s)\n", meter_id,
 		   meter_cfg.bEnable ? "Enabled" : "Disabled");
 	seq_printf(s, "    meter nCbs=%u\n", meter_cfg.nCbs);
@@ -162,8 +160,7 @@ void proc_coc_read_30(struct seq_file *s)
 
 	memset(&reg, 0, sizeof(reg));
 	reg.nRegAddr = 0x489 + meter_id * 10;
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.RegisterGet,
-		     gsw_handle, &reg);
+	gsw_handle->gsw_common_ops.RegisterGet(gsw_handle, &reg);
 	seq_printf(s, "    PCE_PISR(0x%x)=%u(0x%x)-interrupt %s\n",
 		   reg.nRegAddr, reg.nData, reg.nData,
 		   (reg.nData & 0x100) ? "on" : "off");
@@ -294,8 +291,7 @@ int clear_meter_interrupt(void)
 	memset(&reg, 0, sizeof(reg));
 	reg.nRegAddr = 0x489 + meter_id * 10;
 	reg.nData = -1;
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.RegisterSet,
-		     gsw_handle, &reg);
+	gsw_handle->gsw_common_ops.RegisterSet(gsw_handle, &reg);
 	return 0;
 }
 
@@ -310,31 +306,25 @@ int enable_meter_interrupt(void)
 	 */
 	memset(&reg, 0, sizeof(reg));
 	reg.nRegAddr = 0x14;	/*ETHSW_IER */
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.RegisterGet,
-		     gsw_handle, &reg);
+	gsw_handle->gsw_common_ops.RegisterGet(gsw_handle, &reg);
 	reg.nRegAddr |= 1 << 1; /*Enable PCEIE */
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.RegisterSet,
-		     gsw_handle, &reg);
+	gsw_handle->gsw_common_ops.RegisterSet(gsw_handle, &reg);
 
 	/*#Enable PCE Port Interrupt
 	 *  switch_cli GSW_REGISTER_SET nRegAddr=0x465 nData=0x1 dev=1
 	 */
 	memset(&reg, 0, sizeof(reg));
 	reg.nRegAddr = 0x465;	/*PCE_IER_0 */
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.RegisterGet,
-		     gsw_handle, &reg);
+	gsw_handle->gsw_common_ops.RegisterGet(gsw_handle, &reg);
 	reg.nRegAddr |= 1 << 0; /*Enable PCE Port 0 */
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.RegisterSet,
-		     gsw_handle, &reg);
+	gsw_handle->gsw_common_ops.RegisterSet(gsw_handle, &reg);
 
 	memset(&reg, 0, sizeof(reg));
 	reg.nRegAddr = 0x488;	/*PCE_PIER */
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.RegisterGet,
-		     gsw_handle, &reg);
+	gsw_handle->gsw_common_ops.RegisterGet(gsw_handle, &reg);
 	/*Enable Metering Based Backpressure Status Change Interrupt Enable */
 	reg.nRegAddr |= 1 << 8;
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.RegisterSet,
-		     gsw_handle, &reg);
+	gsw_handle->gsw_common_ops.RegisterSet(gsw_handle, &reg);
 
 	return 0;
 }
@@ -352,8 +342,7 @@ int apply_meter_rate(u32 rate, unsigned int new_state)
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
 	memset(&meter_cfg, 0, sizeof(meter_cfg));
 	meter_cfg.nMeterId = meter_id;
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_MeterCfgGet,
-		     gsw_handle, &meter_cfg);
+	gsw_handle->gsw_qos_ops.QoS_MeterCfgGet(gsw_handle, &meter_cfg);
 	if (rate == 0) {		/*only need to disable the meter */
 		meter_cfg.bEnable = 0;
 	} else if (rate == -1) {
@@ -371,8 +360,7 @@ int apply_meter_rate(u32 rate, unsigned int new_state)
 		return -1;
 	}
 
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_MeterCfgSet,
-		     gsw_handle, &meter_cfg);
+	gsw_handle->gsw_qos_ops.QoS_MeterCfgSet(gsw_handle, &meter_cfg);
 
 	return 0;
 }
@@ -387,8 +375,10 @@ int meter_set_default(void)
 	GSW_QoS_meterPort_t meter_port;
 	GSW_register_t reg;
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	/*#currently directly change global setting, later should use
 	 * GSW_QOS_WRED_PORT_CFG_SET instead
 	 * switch_cli dev=1 GSW_REGISTER_SET nRegAddr=0x4a nData=0x518
@@ -397,16 +387,12 @@ int meter_set_default(void)
 
 	for (i = 0; i < PMAC_MAX_NUM; i++) {/*cp green setting to yellow/red*/
 		wred_p.nPortId = i;
-		gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_WredPortCfgGet,
-			gsw_handle, &wred_p);
+		gsw_qos->QoS_WredPortCfgGet(gsw_handle, &wred_p);
 		wred_p.nYellow_Min = wred_p.nGreen_Min;
 		wred_p.nYellow_Max = wred_p.nGreen_Max;
 		wred_p.nRed_Min = wred_p.nGreen_Min;
 		wred_p.nRed_Max = wred_p.nGreen_Max;
-		gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_WredPortCfgSet,
-			gsw_handle, &wred_p);
+		gsw_qos->QoS_WredPortCfgSet(gsw_handle, &wred_p);
 	}
 
 	/*#Enable Meter 0, configure the rate
@@ -421,8 +407,7 @@ int meter_set_default(void)
 	meter_cfg.nRate = meter_nrate[3];
 	meter_cfg.nPiRate = 0xFFFFFF; /* try to set maximum */
 	meter_cfg.eMtrType = GSW_QOS_Meter_trTCM;
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_MeterCfgSet,
-		     gsw_handle, &meter_cfg);
+	gsw_qos->QoS_MeterCfgSet(gsw_handle, &meter_cfg);
 
 	/*#Assign Port0 ingress to Meter 0
 	 * switch_cli GSW_QOS_METER_PORT_ASSIGN nMeterId=0 eDir=1
@@ -434,9 +419,7 @@ int meter_set_default(void)
 		meter_port.nMeterId = meter_id;
 		meter_port.eDir = 1;
 		meter_port.nPortIngressId = i;
-		gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_MeterPortAssign,
-			gsw_handle, &meter_port);
+		gsw_qos->QoS_MeterPortAssign(gsw_handle, &meter_port);
 	}
 
 	/*#Enable Port 0 Meter Based Flow control (Bit 2 MFCEN)
@@ -444,11 +427,9 @@ int meter_set_default(void)
 	 */
 	memset(&reg, 0, sizeof(reg));
 	reg.nRegAddr = 0xBC0;
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.RegisterGet,
-		     gsw_handle, &reg);
+	gsw_handle->gsw_common_ops.RegisterGet(gsw_handle, &reg);
 	reg.nData |= 1 << 2;
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.RegisterSet,
-		     gsw_handle, &reg);
+	gsw_handle->gsw_common_ops.RegisterSet(gsw_handle, &reg);
 
 	/*#Configure Red and Yellow watermark for each queue
 	 *  (Yellow and Red shall not be 0 in CoC case in order to avoid
@@ -465,17 +446,13 @@ int meter_set_default(void)
 	memset(&wred_q, 0, sizeof(wred_q));
 	for (i = 0; i < 32; i++) {	/*copy green setting to yellow/red */
 		wred_q.nQueueId = i;
-		gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_WredQueueCfgGet,
-			gsw_handle, &wred_q);
+		gsw_qos->QoS_WredQueueCfgGet(gsw_handle, &wred_q);
 
 		wred_q.nYellow_Min = wred_q.nGreen_Min;
 		wred_q.nYellow_Max = wred_q.nGreen_Max;
 		wred_q.nRed_Min = wred_q.nGreen_Min;
 		wred_q.nRed_Max = wred_q.nGreen_Max;
-		gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_WredQueueCfgSet,
-			gsw_handle, &wred_q);
+		gsw_qos->QoS_WredQueueCfgSet(gsw_handle, &wred_q);
 	}
 
 	/*Configure Red and Yellow watermark for each queue (Yellow and Red
@@ -484,21 +461,18 @@ int meter_set_default(void)
 	 * nYellow_Min=255 nYellow_Max=255  nGreen_Min=255 nGreen_Max=255 dev=1
 	 */
 	memset(&wred_cfg, 0, sizeof(wred_cfg));
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_WredCfgGet,
-		     gsw_handle, &wred_cfg);
+	gsw_qos->QoS_WredCfgGet(gsw_handle, &wred_cfg);
 	wred_cfg.nYellow_Min = wred_cfg.nGreen_Min;
 	wred_cfg.nYellow_Max = wred_cfg.nGreen_Max;
 	wred_cfg.nRed_Min = wred_cfg.nGreen_Min;
 	wred_cfg.nRed_Max = wred_cfg.nGreen_Max;
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_WredCfgSet,
-		     gsw_handle, &wred_cfg);
+	gsw_qos->QoS_WredCfgSet(gsw_handle, &wred_cfg);
 
 	/*#Configure OVERHEAD */
 	memset(&reg, 0, sizeof(reg));
 	reg.nRegAddr = 0x46C;	/*PCE_OVERHD */
 	reg.nData = PCE_OVERHD;
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.RegisterSet,
-		     gsw_handle, &reg);
+	gsw_handle->gsw_common_ops.RegisterSet(gsw_handle, &reg);
 
 	return 0;
 }
@@ -515,8 +489,7 @@ static void dp_rmon_polling(unsigned long data)
 	for (i = 0; i < PMAC_MAX_NUM; i++) {
 		memset(&curr, 0, sizeof(curr));
 		curr.nPortId = i;
-		gsw_core_api((dp_gsw_cb)gsw_handle->gsw_rmon_ops.RMON_Port_Get,
-			     gsw_handle, &curr);
+		gsw_handle->gsw_rmon_ops.RMON_Port_Get(gsw_handle, &curr);
 
 		coc_lock();
 		/*wrapround handling */
@@ -589,13 +562,14 @@ void update_rmon_last(void)
 {
 	int i;
 	struct core_ops *gsw_handle;
+	struct rmon_ops *gsw_rmon;
 
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
+	gsw_rmon = &gsw_handle->gsw_rmon_ops;
 	memset(rmon_last, 0, sizeof(rmon_last));
 	for (i = 0; i < PMAC_MAX_NUM; i++) {
 		rmon_last[i].nPortId = i;
-		gsw_core_api((dp_gsw_cb)gsw_handle->gsw_rmon_ops.RMON_Port_Get,
-			     gsw_handle, &rmon_last[i]);
+		gsw_rmon->RMON_Port_Get(gsw_handle, &rmon_last[i]);
 	}
 }
 
@@ -791,10 +765,8 @@ int dp_coc_cpufreq_init(void)
 	irq.portid = 0; // logical port id
 	irq.call_back = dp_meter_interrupt_cb;// Callback API
 	irq.param = NULL; // Callback  API parameter
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_irq_ops.IRQ_Register,
-		     gsw_handle, &irq);
-	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_irq_ops.IRQ_Enable,
-		     gsw_handle, &irq);
+	gsw_handle->gsw_irq_ops.IRQ_Register(gsw_handle, &irq);
+	gsw_handle->gsw_irq_ops.IRQ_Enable(gsw_handle, &irq);
 
 	INIT_WORK(&coc_work_q, (work_func_t)coc_work_task);/*initialize work Q*/
 	init_timer_on_stack(&dp_coc_timer);
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_gswip.c b/drivers/net/datapath/dpm/gswip30/datapath_gswip.c
index 74ed0b53a0c7..9853c9df97a2 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_gswip.c
@@ -64,9 +64,7 @@ int dp_pmac_set_30(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 				igcfg.nTxDmaChanId =
 					pmac_cfg->ig_pmac.tx_dma_chan;
 			}
-			gsw_core_api(
-				(dp_gsw_cb)gswr_r->gsw_pmac_ops.Pmac_Ig_CfgGet,
-				gswr_r, &igcfg);
+			gswr_r->gsw_pmac_ops.Pmac_Ig_CfgGet(gswr_r, &igcfg);
 
 			/*update igcfg and write back to gsw */
 			if (pmac_cfg->ig_pmac_flags & IG_PMAC_F_ERR_DISC)
@@ -165,9 +163,7 @@ int dp_pmac_set_30(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 
 			DP_DEBUG(DP_DBG_FLAG_DBG, "\n");
 
-			gsw_core_api(
-				(dp_gsw_cb)gswr_r->gsw_pmac_ops.Pmac_Ig_CfgSet,
-				gswr_r, &igcfg);
+			gswr_r->gsw_pmac_ops.Pmac_Ig_CfgSet(gswr_r, &igcfg);
 		}
 
 		kfree(dqport.deq_info);
@@ -185,10 +181,8 @@ int dp_pmac_set_30(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 			egcfg.nTrafficClass = i;
 			egcfg.nFlowIDMsb = j;
 			memset(&pmac_glb, 0, sizeof(pmac_glb));
-			gsw_core_api(DP_PMAC_OPS(gswr_r, Pmac_Gbl_CfgGet),
-				     gswr_r, &pmac_glb);
-			gsw_core_api(DP_PMAC_OPS(gswr_r, Pmac_Eg_CfgGet),
-				     gswr_r, &egcfg);
+			gswr_r->gsw_pmac_ops.Pmac_Gbl_CfgGet(gswr_r, &pmac_glb);
+			gswr_r->gsw_pmac_ops.Pmac_Eg_CfgGet(gswr_r, &egcfg);
 			egcfg.bProcFlagsSelect = pmac_glb.bProcFlagsEgCfgEna;
 			DP_DEBUG(DP_DBG_FLAG_DBG, "bProcFlagsSelect=%u\n",
 				 egcfg.bProcFlagsSelect);
@@ -287,9 +281,7 @@ int dp_pmac_set_30(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 					 egcfg.bMpe2Flag);
 			}
 #endif
-			gsw_core_api(
-				(dp_gsw_cb)gswr_r->gsw_pmac_ops.Pmac_Eg_CfgSet,
-				gswr_r, &egcfg);
+			gswr_r->gsw_pmac_ops.Pmac_Eg_CfgSet(gswr_r, &egcfg);
 
 			;
 		}
@@ -311,8 +303,7 @@ int dp_set_gsw_parser_30(u8 flag, u8 cpu, u8 mpe1,
 	GSW_CPU_PortCfg_t param = {0};
 	struct core_ops *gsw_handle = dp_port_prop[0].ops[1]; /*pae*/
 
-	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.CPU_PortCfgGet,
-			 gsw_handle, &param)) {
+	if (gsw_handle->gsw_common_ops.CPU_PortCfgGet(gsw_handle, &param)) {
 		PR_ERR("Failed GSW_CPU_PORT_CFG_GET\n");
 		return -1;
 	}
@@ -334,8 +325,7 @@ int dp_set_gsw_parser_30(u8 flag, u8 cpu, u8 mpe1,
 	if (flag & F_MPE1_MPE2)
 		param.eMPE1MPE2ParserCfg = mpe3;
 
-	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.CPU_PortCfgSet,
-			 gsw_handle, &param)) {
+	if (gsw_handle->gsw_common_ops.CPU_PortCfgSet(gsw_handle, &param)) {
 		PR_ERR("Failed GSW_CPU_PORT_CFG_SET\n");
 		return -1;
 	}
@@ -352,8 +342,7 @@ int dp_get_gsw_parser_30(u8 *cpu, u8 *mpe1, u8 *mpe2,
 	GSW_CPU_PortCfg_t param = {0};
 	struct core_ops *gsw_handle = dp_port_prop[0].ops[1]; /*pae*/
 
-	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.CPU_PortCfgGet,
-			 gsw_handle, &param)) {
+	if (gsw_handle->gsw_common_ops.CPU_PortCfgGet(gsw_handle, &param)) {
 		PR_ERR("Failed GSW_CPU_PORT_CFG_GET\n");
 		return -1;
 	}
@@ -396,8 +385,7 @@ int gsw_mib_reset_30(int dev, u32 flag)
 	else
 		gsw_handle = dp_port_prop[0].ops[1];
 	rmon_clear.eRmonType = GSW_RMON_ALL_TYPE;
-	ret = gsw_core_api((dp_gsw_cb)gsw_handle->gsw_rmon_ops.RMON_Clear,
-			   gsw_handle, &rmon_clear);
+	ret = gsw_handle->gsw_rmon_ops.RMON_Clear(gsw_handle, &rmon_clear);
 
 	if (ret != GSW_statusOk) {
 		PR_ERR("R:GSW_RMON_CLEAR failed for GSW_RMON_ALL_TYPE\n");
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_mib.c b/drivers/net/datapath/dpm/gswip30/datapath_mib.c
index 80e6fac5ae55..8a6626f1edc9 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_mib.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_mib.c
@@ -451,9 +451,7 @@ static int get_gsw_port_rmon(u32 ep, char *gsw_drv_name,
 		return -1;
 	memset(mib, 0, sizeof(*mib));
 	mib->nPortId = ep;
-	ret = gsw_core_api(
-		(dp_gsw_cb)dp_port_prop[0].ops[index]->gsw_rmon_ops.RMON_Port_Get,
-		dp_port_prop[0].ops[index], mib);
+	ret = dp_port_prop[0].ops[index]->gsw_rmon_ops.RMON_Port_Get(dp_port_prop[0].ops[index], mib);
 	if (ret) {
 		PR_ERR("GSW_RMON_PORT_GET failed(%d) from %s for port %d\n",
 		       ret, gsw_drv_name, ep);
@@ -474,9 +472,7 @@ static int get_gsw_redirect_rmon(u32 ep, int index,
 	}
 
 	memset(mib, 0, sizeof(*mib));
-	ret = gsw_core_api(
-		(dp_gsw_cb)dp_port_prop[0].ops[index]->gsw_rmon_ops.RMON_Redirect_Get,
-		dp_port_prop[0].ops[index], mib);
+	ret = dp_port_prop[0].ops[index]->gsw_rmon_ops.RMON_Redirect_Get(dp_port_prop[0].ops[index], mib);
 	if (ret) {
 		PR_ERR("GSW_RMON_REDIRECT_GET failed from %s\n",
 		       gsw_drv_name);
@@ -497,9 +493,7 @@ static int get_gsw_itf_rmon(u32 index, int index,
 	}
 	memset(mib, 0, sizeof(*mib));
 	mib->nIfId = index;
-	ret = gsw_core_api(
-		(dp_gsw_cb)dp_port_prop[0].ops[index]->gsw_rmon_ops.RMON_If_Get,
-		dp_port_prop[0].ops[index], mib);
+	ret = dp_port_prop[0].ops[index]->gsw_rmon_ops.RMON_If_Get(dp_port_prop[0].ops[index], mib);
 	if (ret) {
 		PR_ERR
 		    ("GSW_RMON_PORT_GET GSW_RMON_IF_GET from %s: index %d\n",
@@ -535,17 +529,16 @@ int gsw_eth_wan_redirect_status(void)
 	int i;
 	GSW_return_t ret;
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	#define MAX_CLASS_NUM 16
 
 	gsw_handle = dp_port_prop[inst].ops[1];
-
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	memset(&q_cfg, 0, sizeof(q_cfg));
 	q_cfg.nPortId = WAN_EP;
 	for (i = 0; i <= MAX_CLASS_NUM; i++) {
 		q_cfg.nTrafficClassId = i;
-		ret = gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_QueuePortGet,
-			gsw_handle, &q_cfg);
+		ret = gsw_qos->QoS_QueuePortGet(gsw_handle, &q_cfg);
 		if (ret) {
 			PR_ERR("%s failed(%d) from %s for port %d\n",
 			       "GSW_QOS_QUEUE_PORT_GET",
@@ -1593,8 +1586,7 @@ int clear_gsw_itf_mib(dp_subif_t *subif, u32 flag)
 			       rmon.nRmonId);
 			return -1;
 		}
-		gsw_core_api((dp_gsw_cb)gsw_handle->gsw_rmon_ops.RMON_Clear,
-			     gsw_handle, &rmon);
+		gsw_handle->gsw_rmon_ops.RMON_Clear(gsw_handle, &rmon);
 	}
 	return 0;
 }
@@ -1696,14 +1688,12 @@ int dp_clear_netif_mib_30(dp_subif_t *subif, void *priv, u32 flag)
 		/*reset GSWIP-R rmon counters */
 		rmon.eRmonType = GSW_RMON_PORT_TYPE;
 		rmon.nRmonId = port_id;
-		gsw_core_api((dp_gsw_cb)gsw_r->gsw_rmon_ops.RMON_Clear,
-			     gsw_r, &rmon);
+		gsw_r->gsw_rmon_ops.RMON_Clear(gsw_r, &rmon);
 
 		/*reset GSWIP-R redirect counters */
 		rmon.eRmonType = GSW_RMON_REDIRECT_TYPE;
 		rmon.nRmonId = 0;
-		gsw_core_api((dp_gsw_cb)gsw_r->gsw_rmon_ops.RMON_Clear,
-			     gsw_r, &rmon);
+		gsw_r->gsw_rmon_ops.RMON_Clear(gsw_r, &rmon);
 
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_MIB_TMU_MPE_MIB)
 		tmu_hal_clear_csum_ol_m_local =
@@ -1716,15 +1706,12 @@ int dp_clear_netif_mib_30(dp_subif_t *subif, void *priv, u32 flag)
 		/*reset GSWIP-L/R rmon counters */
 		rmon.eRmonType = GSW_RMON_PORT_TYPE;
 		rmon.nRmonId = port_id;
-		gsw_core_api((dp_gsw_cb)gsw_l->gsw_rmon_ops.RMON_Clear,
-			     gsw_r, &rmon);
-		gsw_core_api((dp_gsw_cb)gsw_r->gsw_rmon_ops.RMON_Clear,
-			     gsw_r, &rmon);
+		gsw_l->gsw_rmon_ops.RMON_Clear(gsw_r, &rmon);
+		gsw_r->gsw_rmon_ops.RMON_Clear(gsw_r, &rmon);
 	} else {		/*port 7 ~ 14 */
 		rmon.eRmonType = GSW_RMON_PORT_TYPE;
 		rmon.nRmonId = port_id;
-		gsw_core_api((dp_gsw_cb)gsw_r->gsw_rmon_ops.RMON_Clear,
-			     gsw_r, &rmon);
+		gsw_r->gsw_rmon_ops.RMON_Clear(gsw_r, &rmon);
 	}
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_MIB_TMU_MPE_MIB)
 	tmu_hal_clear_qos_m_local = tmu_hal_clear_qos_mib_hook_fn;
@@ -2090,8 +2077,7 @@ int set_gsw_itf(u8 ep, u8 ena, int start)
 
 	/*get this ports itf base */
 	port_cfg.nPortId = ep;
-	if (gsw_core_api((dp_gsw_cb)gsw_r->gsw_common_ops.PortCfgGet,
-			 gsw_r, &port_cfg)) {
+	if (gsw_r->gsw_common_ops.PortCfgGet(gsw_r, &port_cfg)) {
 		DP_DEBUG(DP_DBG_FLAG_MIB,
 			 "Why gsw_core_api return failure: GSW_PORT_CFG_GET for port_id=%d\n",
 			 port_cfg.nPortId);
@@ -2099,8 +2085,7 @@ int set_gsw_itf(u8 ep, u8 ena, int start)
 	}
 	port_cfg.nIfCountStartIdx = start;
 	port_cfg.bIfCounters = ena ? 1 : 0;
-	if (gsw_core_api((dp_gsw_cb)gsw_r->gsw_common_ops.PortCfgSet,
-			 gsw_r, &port_cfg)) {
+	if (gsw_r->gsw_common_ops.PortCfgSet(gsw_r, &port_cfg)) {
 		DP_DEBUG(DP_DBG_FLAG_MIB,
 			 "Why gsw_core_api return failure: GSW_PORT_CFG_SET for port_id=%d\n",
 			 port_cfg.nPortId);
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_misc.h b/drivers/net/datapath/dpm/gswip30/datapath_misc.h
index 92b63fa0e19f..40016a2c6534 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_misc.h
+++ b/drivers/net/datapath/dpm/gswip30/datapath_misc.h
@@ -62,14 +62,6 @@ int32_t dp_rx_30(struct sk_buff *skb, u32 flags);
 int32_t dp_xmit_30(struct net_device *rx_if, dp_subif_t *rx_subif,
 		   struct sk_buff *skb, int32_t len, uint32_t flags);
 
-static inline GSW_return_t gsw_core_api(dp_gsw_cb func,
-					void *ops, void *param)
-{
-	if (!func)
-		return DP_FAILURE;
-	return func(ops, param);
-}
-
 static inline char *parser_flag_str(u8 f)
 {
 	if (f == DP_PARSER_F_DISABLE)
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_proc.c b/drivers/net/datapath/dpm/gswip30/datapath_proc.c
index e2256aee7b49..5b7ee2899fa8 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_proc.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_proc.c
@@ -157,11 +157,13 @@ static ssize_t proc_parser_write(struct file *file, const char *buf,
 	static GSW_PCE_rule_t pce;
 	int inst = 0;
 	struct core_ops *gsw_handle;
+	struct tflow_ops *gsw_tflow;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 	memset(&pce, 0, sizeof(pce));
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
+	gsw_tflow = &gsw_handle->gsw_tflow_ops;
 	len = (sizeof(str) > count) ? count : sizeof(str) - 1;
 	len -= copy_from_user(str, buf, len);
 	str[len] = 0;
@@ -306,9 +308,7 @@ static ssize_t proc_parser_write(struct file *file, const char *buf,
 		pce.action.bRMON_Action = 1;
 		pce.action.nRMON_Id = 0;	/*RMON_UDP_CNTR; */
 
-		if (gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_tflow_ops.TFLOW_PceRuleWrite,
-			gsw_handle, &pce)) {
+		if (gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, &pce)) {
 			PR_ERR("PCE rule add fail for GSW_PCE_RULE_WRITE\n");
 			return count;
 		}
@@ -321,9 +321,7 @@ static ssize_t proc_parser_write(struct file *file, const char *buf,
 		memset(&pce, 0, sizeof(pce));
 		pce.pattern.nIndex = pce_rule_id;
 		pce.pattern.bEnable = 0;
-		if (gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_tflow_ops.TFLOW_PceRuleWrite,
-			gsw_handle, &pce)) {
+		if (gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, &pce)) {
 			PR_ERR("PCE rule add fail for GSW_PCE_RULE_WRITE\n");
 			return count;
 		}
@@ -693,9 +691,8 @@ static int proc_gsw_port_rmon_dump(struct seq_file *s, int pos)
 		rmon = &gsw_handle->gsw_rmon_ops;
 		for (i = 0; i < ARRAY_SIZE(gsw_r_rmon_mib); i++) {
 			gsw_r_rmon_mib[i].nPortId = i;
-			ret = gsw_core_api((dp_gsw_cb)rmon->RMON_Port_Get,
-					   gsw_handle, &gsw_r_rmon_mib[i]);
-
+			ret = rmon->RMON_Port_Get(gsw_handle,
+						  &gsw_r_rmon_mib[i]);
 			if (ret != GSW_statusOk) {
 				PR_ERR("RMON_PORT_GET fail for Port %d\n", i);
 				return -1;
@@ -704,8 +701,7 @@ static int proc_gsw_port_rmon_dump(struct seq_file *s, int pos)
 
 		/*read pmac rmon redirect mib */
 		memset(&gswr_rmon_redirect, 0, sizeof(gswr_rmon_redirect));
-		ret = gsw_core_api((dp_gsw_cb)rmon->RMON_Redirect_Get,
-				   gsw_handle, &gswr_rmon_redirect);
+		ret = rmon->RMON_Redirect_Get(gsw_handle, &gswr_rmon_redirect);
 
 		if (ret != GSW_statusOk) {
 			PR_ERR("GSW_RMON_REDIRECT_GET fail for Port %d\n", i);
@@ -717,8 +713,8 @@ static int proc_gsw_port_rmon_dump(struct seq_file *s, int pos)
 		rmon = &gsw_handle->gsw_rmon_ops;
 		for (i = 0; i < ARRAY_SIZE(gsw_l_rmon_mib); i++) {
 			gsw_l_rmon_mib[i].nPortId = i;
-			ret = gsw_core_api((dp_gsw_cb)rmon->RMON_Port_Get,
-					   gsw_handle, &gsw_l_rmon_mib[i]);
+			ret = rmon->RMON_Port_Get(gsw_handle,
+						  &gsw_l_rmon_mib[i]);
 			if (ret != GSW_statusOk) {
 				PR_ERR("RMON_PORT_GET fail for Port %d\n", i);
 				return -1;
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
index 8d5958a0aac9..9ca3e5b41d1e 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
@@ -14,10 +14,6 @@
 #include "../datapath.h"
 #include "datapath_misc.h"
 
-#define GSW_CORE_API(_handle, a, b) ({ \
-	typeof(_handle) (handle) = (_handle); \
-	gsw_core_api((dp_gsw_cb)(handle)->a, (handle), (b)); })
-
 #define BP_CFG(bp_cfg, _index, bflag, id) ({ \
 	typeof(_index) (index) = (_index); \
 	(bp_cfg)->bEgressSubMeteringEnable[(index)] = bflag; \
@@ -132,9 +128,7 @@ int dp_pmac_set_31(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 				igcfg.nTxDmaChanId =
 					pmac_cfg->ig_pmac.tx_dma_chan;
 			}
-			gsw_core_api(
-				(dp_gsw_cb)gswr_r->gsw_pmac_ops.Pmac_Ig_CfgGet,
-				gswr_r, &igcfg);
+			gswr_r->gsw_pmac_ops.Pmac_Ig_CfgGet(gswr_r, &igcfg);
 
 			/*update igcfg and write back to gsw */
 			if (pmac_cfg->ig_pmac_flags & IG_PMAC_F_ERR_DISC)
@@ -234,9 +228,7 @@ int dp_pmac_set_31(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 
 			DP_DEBUG(DP_DBG_FLAG_DBG, "\n");
 
-			gsw_core_api(
-				(dp_gsw_cb)gswr_r->gsw_pmac_ops.Pmac_Ig_CfgSet,
-				gswr_r, &igcfg);
+			gswr_r->gsw_pmac_ops.Pmac_Ig_CfgSet(gswr_r, &igcfg);
 		}
 
 			kfree(dqport.deq_info);
@@ -258,9 +250,7 @@ int dp_pmac_set_31(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 			egcfg.bProcFlagsSelect = 1;
 			DP_DEBUG(DP_DBG_FLAG_DBG, "bProcFlagsSelect=%u\n",
 				 egcfg.bProcFlagsSelect);
-			gsw_core_api(
-				(dp_gsw_cb)gswr_r->gsw_pmac_ops.Pmac_Eg_CfgGet,
-				gswr_r, &egcfg);
+			gswr_r->gsw_pmac_ops.Pmac_Eg_CfgGet(gswr_r, &egcfg);
 
 			/*update egcfg and write back to gsw */
 			if (pmac_cfg->eg_pmac_flags & EG_PMAC_F_FCS)
@@ -390,9 +380,7 @@ int dp_pmac_set_31(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 					 egcfg.bMpe2Flag);
 			}
 #endif
-			gsw_core_api(
-				(dp_gsw_cb)gswr_r->gsw_pmac_ops.Pmac_Eg_CfgSet,
-				gswr_r, &egcfg);
+			gswr_r->gsw_pmac_ops.Pmac_Eg_CfgSet(gswr_r, &egcfg);
 		}
 	}
 
@@ -412,9 +400,7 @@ int dp_set_gsw_parser_31(u8 flag, u8 cpu, u8 mpe1,
 	GSW_CPU_PortCfg_t param = {0};
 	struct core_ops *gsw_handle = dp_port_prop[0].ops[0];/*gswip o */
 
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_common_ops.CPU_PortCfgGet,
-		gsw_handle, &param)) {
+	if (gsw_handle->gsw_common_ops.CPU_PortCfgGet(gsw_handle, &param)) {
 		PR_ERR("Failed GSW_CPU_PORT_CFG_GET\n");
 		return -1;
 	}
@@ -436,9 +422,7 @@ int dp_set_gsw_parser_31(u8 flag, u8 cpu, u8 mpe1,
 	if (flag & F_MPE1_MPE2)
 		param.eMPE1MPE2ParserCfg = mpe3;
 
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_common_ops.CPU_PortCfgSet,
-		gsw_handle, &param)) {
+	if (gsw_handle->gsw_common_ops.CPU_PortCfgSet(gsw_handle, &param)) {
 		PR_ERR("Failed GSW_CPU_PORT_CFG_SET\n");
 		return -1;
 	}
@@ -455,9 +439,7 @@ int dp_get_gsw_parser_31(u8 *cpu, u8 *mpe1, u8 *mpe2,
 	GSW_CPU_PortCfg_t param = {0};
 	struct core_ops *gsw_handle = dp_port_prop[0].ops[0]; /*gswip 0*/
 
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_common_ops.CPU_PortCfgGet,
-		gsw_handle, &param)) {
+	if (gsw_handle->gsw_common_ops.CPU_PortCfgGet(gsw_handle, &param)) {
 		PR_ERR("Failed GSW_CPU_PORT_CFG_GET\n");
 		return -1;
 	}
@@ -496,8 +478,7 @@ int gsw_mib_reset_31(int dev, u32 flag)
 
 	gsw_handle = dp_port_prop[0].ops[0];
 	rmon_clear.eRmonType = GSW_RMON_ALL_TYPE;
-	ret = gsw_core_api((dp_gsw_cb)gsw_handle->gsw_rmon_ops.RMON_Clear,
-			   gsw_handle, &rmon_clear);
+	ret = gsw_handle->gsw_rmon_ops.RMON_Clear(gsw_handle, &rmon_clear);
 
 	if (ret != GSW_statusOk) {
 		PR_ERR("R:GSW_RMON_CLEAR failed for GSW_RMON_ALL_TYPE\n");
@@ -529,10 +510,7 @@ struct gsw_itf *ctp_port_assign(int inst, u8 ep, int bp_default,
 		ctp_assign.eMode = itf_assign[ep].mode;
 		ctp_assign.nFirstCtpPortId = itf_assign[ep].start;
 		ctp_assign.nNumberOfCtpPort = itf_assign[ep].n;
-		if (gsw_core_api(
-			(dp_gsw_cb)gsw_ctp->CTP_PortAssignmentFree,
-			gsw_handle,
-			&ctp_assign) != 0) {
+		if (gsw_ctp->CTP_PortAssignmentFree(gsw_handle, &ctp_assign)) {
 			PR_ERR("Failed to allc CTP for ep=%d blk=%d mode=%d\n",
 			       ep, assign->num, assign->emode);
 			return NULL;
@@ -556,10 +534,7 @@ struct gsw_itf *ctp_port_assign(int inst, u8 ep, int bp_default,
 	ctp_assign.nBridgePortId = bp_default;
 	ctp_assign.nFirstCtpPortId = 0;
 	ctp_assign.nNumberOfCtpPort = num;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_ctp->CTP_PortAssignmentAlloc,
-		gsw_handle,
-		&ctp_assign) != 0) {
+	if (gsw_ctp->CTP_PortAssignmentAlloc(gsw_handle, &ctp_assign)) {
 		PR_ERR("Failed CTP Assignment for ep=%d blk size=%d mode=%s\n",
 		       ep, num, ctp_mode_string(assign->emode));
 		return NULL;
@@ -609,14 +584,14 @@ int alloc_bridge_port(int inst, int port_id, int subif_ix,
 	GSW_BRIDGE_portAlloc_t bp = {0};
 	GSW_BRIDGE_portConfig_t bp_cfg = {0};
 	struct core_ops *gsw_handle;
+	struct brdgport_ops *gsw_bp;
 	GSW_return_t ret;
 
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	/*allocate a free bridge port */
 	memset(&bp, 0, sizeof(bp));
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_Alloc,
-		gsw_handle, &bp);
+	ret = gsw_bp->BridgePort_Alloc(gsw_handle, &bp);
 	if ((ret != GSW_statusOk) ||
 	    (bp.nBridgePortId < 0)) {
 		PR_ERR("Failed to get a bridge port\n");
@@ -643,15 +618,11 @@ int alloc_bridge_port(int inst, int port_id, int subif_ix,
 	bp_cfg.nBridgeId = fid;
 
 	SET_BP_MAP(bp_cfg.nBridgePortMap, bp_member); /*CPU*/
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigSet,
-		gsw_handle, &bp_cfg);
+	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Failed to set bridge id(%d) and port map for bp= %d\n",
 		       fid, bp_cfg.nBridgePortId);
-		gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_Free,
-			gsw_handle, &bp);
+		gsw_bp->BridgePort_Free(gsw_handle, &bp);
 		return -1;
 	}
 
@@ -660,27 +631,19 @@ int alloc_bridge_port(int inst, int port_id, int subif_ix,
 	 */
 	bp_cfg.nBridgePortId = bp_member;
 	bp_cfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
-		gsw_handle, &bp_cfg);
+	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Failed to get bridge port's member for bridgeport=%d\n",
 		       bp_cfg.nBridgePortId);
-		gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_Free,
-			gsw_handle, &bp);
+		gsw_bp->BridgePort_Free(gsw_handle, &bp);
 		return -1;
 	}
 	SET_BP_MAP(bp_cfg.nBridgePortMap, bp.nBridgePortId);
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigSet,
-		gsw_handle, &bp_cfg);
+	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Failed to set bridge port's member for bridgeport=%d\n",
 		       bp_cfg.nBridgePortId);
-		gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_Free,
-			gsw_handle, &bp);
+		gsw_bp->BridgePort_Free(gsw_handle, &bp);
 		return -1;
 	}
 
@@ -713,9 +676,7 @@ int free_bridge_port(int inst, int bp)
 	/*read out this delting bridge port's member*/
 	tmp->nBridgePortId = bp;
 	tmp->eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
-		gsw_handle, tmp);
+	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, tmp);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_GET: %d\n", bp);
 		goto EXIT;
@@ -730,17 +691,13 @@ int free_bridge_port(int inst, int bp)
 			tmp2->eMask =
 				GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 			tmp2->nBridgePortId = i * 16 + j;
-			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
-				gsw_handle, tmp2);
+			ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, tmp2);
 			if (ret != GSW_statusOk) {
 				PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_GET\n");
 				goto EXIT;
 			}
 			UNSET_BP_MAP(tmp2->nBridgePortMap, bp);
-			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
-				gsw_handle, tmp2);
+			ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, tmp2);
 			if (ret != GSW_statusOk) {
 				PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_SET\n");
 				goto EXIT;
@@ -752,9 +709,8 @@ int free_bridge_port(int inst, int bp)
 	memset(tmp, 0, sizeof(tmp));
 	tmp->nBridgePortId = bp;
 	tmp->eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_bp->BridgePort_Free,
-		gsw_handle, tmp);
+	ret = gsw_bp->BridgePort_Free(gsw_handle,
+				      (GSW_BRIDGE_portAlloc_t *)tmp);
 	if (ret != GSW_statusOk)
 		PR_ERR("Failed to GSW_BRIDGE_PORT_FREE:%d\n", bp);
 FREE_EXIT:
@@ -777,9 +733,7 @@ int dp_gswip_mac_entry_add(int bport, int fid, int inst, u8 *addr)
 	SET_BP_MAP(tmp.nPortMap, bport);
 	tmp.nSubIfId = 0;
 	memcpy(tmp.nMAC, addr, GSW_MAC_ADDR_LEN);
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_swmac_ops.MAC_TableEntryAdd,
-		gsw_handle, &tmp);
+	ret = gsw_handle->gsw_swmac_ops.MAC_TableEntryAdd(gsw_handle, &tmp);
 	if (ret != GSW_statusOk) {
 		PR_ERR("fail in setting MAC table static add entry\r\n");
 		return -1;
@@ -793,24 +747,22 @@ int dp_gswip_mac_entry_del(int bport, int fid, int inst, u8 *addr)
 	GSW_MAC_tableQuery_t mac_query;
 	GSW_return_t ret;
 	struct core_ops *gsw_handle;
+	struct swmac_ops *gsw_swmac;
 
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
+	gsw_swmac = &gsw_handle->gsw_swmac_ops;
 	memset(&tmp, 0, sizeof(tmp));
 	memset(&mac_query, 0, sizeof(mac_query));
 	mac_query.nFId = fid;
 	memcpy(mac_query.nMAC, addr, GSW_MAC_ADDR_LEN);
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_swmac_ops.MAC_TableEntryQuery,
-		gsw_handle, &tmp);
+	ret = gsw_swmac->MAC_TableEntryQuery(gsw_handle, &mac_query);
 	if (ret != GSW_statusOk) {
 		PR_ERR("fail in getting MAC query entry\r\n");
 		return -1;
 	}
 	tmp.nFId = fid;
 	memcpy(tmp.nMAC, addr, GSW_MAC_ADDR_LEN);
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_swmac_ops.MAC_TableEntryRemove,
-		gsw_handle, &tmp);
+	ret = gsw_swmac->MAC_TableEntryRemove(gsw_handle, &tmp);
 	if (ret != GSW_statusOk) {
 		PR_ERR("fail in setting MAC static entry remove\r\n");
 		return -1;
@@ -827,16 +779,14 @@ int cpu_vlan_mod_dis(int inst)
 	ops = dp_port_prop[inst].ops[GSWIP_L];
 
 	cfg.nPortId = 0;
-	ret = gsw_core_api((dp_gsw_cb)ops->gsw_qos_ops.QoS_PortRemarkingCfgGet,
-			   ops, &cfg);
+	ret = ops->gsw_qos_ops.QoS_PortRemarkingCfgGet(ops, &cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("QoS_PortRemarkingCfgGet failed\n");
 		return -1;
 	}
 
 	cfg.bPCP_EgressRemarkingEnable = LTQ_FALSE;
-	ret = gsw_core_api((dp_gsw_cb)ops->gsw_qos_ops.QoS_PortRemarkingCfgSet,
-			   ops, &cfg);
+	ret = ops->gsw_qos_ops.QoS_PortRemarkingCfgSet(ops, &cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("QoS_PortRemarkingCfgSet failed\n");
 		return -1;
@@ -850,13 +800,14 @@ int dp_set_gsw_pmapper_31(int inst, int bport, int lport,
 {
 	GSW_BRIDGE_portConfig_t bp_cfg = {0};
 	struct core_ops *gsw_handle;
+	struct brdgport_ops *gsw_bp;
 	GSW_return_t ret;
 	int i, index;
 	int ctp;
 	struct pmac_port_info *port_info = get_dp_port_info(inst, lport);
 
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
-
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	DP_DEBUG(DP_DBG_FLAG_DBG,
 		 "set pmapper bport %d inst %d lport %d\n",
 		 bport, inst, lport);
@@ -901,9 +852,7 @@ int dp_set_gsw_pmapper_31(int inst, int bport, int lport,
 		 "call switch api mode %d enable %d eMask 0x%x\n",
 		 bp_cfg.ePmapperMappingMode, bp_cfg.bPmapperEnable,
 		 bp_cfg.eMask);
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigSet,
-		gsw_handle, &bp_cfg);
+	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("fail in setting pmapper\r\n");
 		return -1;
@@ -916,6 +865,7 @@ int dp_get_gsw_pmapper_31(int inst, int bport, int lport,
 {
 	GSW_BRIDGE_portConfig_t bp_cfg = {0};
 	struct core_ops *gsw_handle;
+	struct brdgport_ops *gsw_bp;
 	GSW_return_t ret;
 	int i, index;
 	struct hal_priv *priv;
@@ -924,7 +874,7 @@ int dp_get_gsw_pmapper_31(int inst, int bport, int lport,
 
 	priv = (struct hal_priv *)dp_port_prop[inst].priv_hal;
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
-
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	DP_DEBUG(DP_DBG_FLAG_DBG,
 		 "get bport %d inst %d lport %d\n",
 		 bport, inst, lport);
@@ -932,9 +882,7 @@ int dp_get_gsw_pmapper_31(int inst, int bport, int lport,
 	bp_cfg.nDestLogicalPortId = lport;
 	bp_cfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_CTP_MAPPING;
 
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
-		gsw_handle, &bp_cfg);
+	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("fail in getting pmapper\r\n");
 		return -1;
@@ -980,6 +928,7 @@ int dp_get_gsw_pmapper_31(int inst, int bport, int lport,
 int dp_meter_alloc_31(int inst, int *meterid, int flag)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_meterCfg_t meter_cfg = {0};
 	GSW_return_t ret;
 
@@ -996,10 +945,10 @@ int dp_meter_alloc_31(int inst, int *meterid, int flag)
 		PR_ERR("gsw_handle NULL\n");
 		return -1;
 	}
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	if (flag == DP_F_DEREGISTER && *meterid >= 0) {
 		meter_cfg.nMeterId = *meterid;
-		ret = GSW_CORE_API(gsw_handle, gsw_qos_ops.QOS_MeterAlloc,
-				   &meter_cfg);
+		ret = gsw_qos->QOS_MeterAlloc(gsw_handle, &meter_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("Meter dealloc failed: %d\n", ret);
 			return -1;
@@ -1007,8 +956,7 @@ int dp_meter_alloc_31(int inst, int *meterid, int flag)
 		return 0;
 	}
 	memset(&meter_cfg, 0, sizeof(meter_cfg));
-	ret = GSW_CORE_API(gsw_handle, gsw_qos_ops.QOS_MeterAlloc,
-			   &meter_cfg);
+	ret = gsw_qos->QOS_MeterAlloc(gsw_handle, &meter_cfg);
 	if ((ret != GSW_statusOk) || (meter_cfg.nMeterId < 0)) {
 		PR_ERR("Failed to get a meter alloc\n");
 		*meterid = -1;
@@ -1022,6 +970,8 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 			   int flag, struct dp_meter_subif *mtr_subif)
 {
 	struct core_ops *gsw_handle;
+	struct ctp_ops *gsw_ctp;
+	struct brdgport_ops *gsw_bp;
 	GSW_BRIDGE_portConfig_t bp_cfg;
 	GSW_CTP_portConfig_t ctp_cfg;
 	GSW_return_t ret;
@@ -1036,6 +986,8 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 	gsw_handle = dp_port_prop[mtr_subif->inst].ops[GSWIP_L];
 	if (!gsw_handle)
 		return -1;
+	gsw_ctp = &gsw_handle->gsw_ctp_ops;
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	if (flag & DP_METER_ATTACH_CTP) {/* CTP port Flag */
 		if (mtr_subif->subif.flag_pmapper) {
 			PR_ERR("can't use CTP,pmapper is enable\n");
@@ -1047,8 +999,7 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 		ctp_cfg.nSubIfIdGroup  = GET_VAP(mtr_subif->subif.subif,
 						 port_info->vap_offset,
 						 port_info->vap_mask);
-		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigGet,
-				   &ctp_cfg);
+		ret = gsw_ctp->CTP_PortConfigGet(gsw_handle, &ctp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("PortConfigGet API failed :%d\n", ret);
 			return -1;
@@ -1070,8 +1021,7 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 		} else {
 			return -1;
 		}
-		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigSet,
-				   &ctp_cfg);
+		ret = gsw_ctp->CTP_PortConfigSet(gsw_handle, &ctp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("PortConfigSet API failed :%d\n", ret);
 			return -1;
@@ -1083,9 +1033,7 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 			return -1;
 		}
 		bp_cfg.nBridgePortId = mtr_subif->subif.bport;
-		ret = GSW_CORE_API(gsw_handle,
-				   gsw_brdgport_ops.BridgePort_ConfigGet,
-				   &bp_cfg);
+		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &bp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("BridgePort_ConfigGet API failed :%d\n", ret);
 			return -1;
@@ -1101,9 +1049,7 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 			PR_ERR(" invalid color mark dir\n");
 			return -1;
 		}
-		ret = GSW_CORE_API(gsw_handle,
-				   gsw_brdgport_ops.BridgePort_ConfigSet,
-				   &bp_cfg);
+		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &bp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("BridgePort_ConfigSet API failed :%d\n", ret);
 			return -1;
@@ -1116,6 +1062,11 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		    int flag, struct dp_meter_subif *mtr_subif)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
+	struct tflow_ops *gsw_tflow;
+	struct ctp_ops *gsw_ctp;
+	struct brdgport_ops *gsw_bp;
+	struct brdg_ops *gsw_brdg;
 	GSW_QoS_meterCfg_t meter_cfg;
 	GSW_BRIDGE_portConfig_t *bp_cfg = NULL;
 	GSW_PCE_rule_t *pce_rule = NULL;
@@ -1131,7 +1082,11 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	gsw_handle = dp_port_prop[mtr_subif->inst].ops[GSWIP_L];
 	if (!gsw_handle)
 		return -1;
-
+	gsw_qos = &gsw_handle->gsw_qos_ops;
+	gsw_tflow = &gsw_handle->gsw_tflow_ops;
+	gsw_ctp = &gsw_handle->gsw_ctp_ops;
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
+	gsw_brdg = &gsw_handle->gsw_brdg_ops;
 	if (flag & DP_COL_MARKING)
 		return dp_set_col_mark(dev, meter, flag, mtr_subif);
 	memset(&meter_cfg, 0, sizeof(GSW_QoS_meterCfg_t));
@@ -1150,8 +1105,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	}
 	meter_cfg.nMeterId = meter->meter_id;
 	meter_cfg.nColourBlindMode = meter->col_mode;
-	ret = GSW_CORE_API(gsw_handle, gsw_qos_ops.QoS_MeterCfgSet,
-			   &meter_cfg);
+	ret = gsw_qos->QoS_MeterCfgSet(gsw_handle, &meter_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("MeterCfgSet API failed:%d\n", ret);
 		return -1;
@@ -1170,8 +1124,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		/* action setting */
 		pce_rule->action.eMeterAction = GSW_PCE_ACTION_METER_1;
 		pce_rule->action.nMeterId =  meter->meter_id;
-		ret = GSW_CORE_API(gsw_handle, gsw_tflow_ops.TFLOW_PceRuleWrite,
-				   pce_rule);
+		ret = gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, pce_rule);
 		if (ret != GSW_statusOk) {
 			PR_ERR("PceRule Write API failed :%d\n", ret);
 			goto err;
@@ -1202,8 +1155,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		ctp_cfg->nSubIfIdGroup  = GET_VAP(mtr_subif->subif.subif,
 						 port_info->vap_offset,
 						 port_info->vap_mask);
-		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigGet,
-				   ctp_cfg);
+		ret = gsw_ctp->CTP_PortConfigGet(gsw_handle, ctp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("PortConfigGet API failed :%d\n", ret);
 			bret = -1;
@@ -1221,8 +1173,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			PR_ERR(" invalid meter dir\n");
 			return -1;
 		}
-		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigSet,
-				   ctp_cfg);
+		ret = gsw_ctp->CTP_PortConfigSet(gsw_handle, ctp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("PortConfigSet API failed :%d\n", ret);
 			bret = -1;
@@ -1242,9 +1193,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			goto err;
 		}
 		bp_cfg->nBridgePortId = mtr_subif->subif.bport;
-		ret = GSW_CORE_API(gsw_handle,
-				   gsw_brdgport_ops.BridgePort_ConfigGet,
-				   bp_cfg);
+		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, bp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("BridgePort_ConfigGet API failed :%d\n", ret);
 			bret = -1;
@@ -1278,9 +1227,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			PR_ERR(" invalid meter dir\n");
 			return -1;
 		}
-		ret = GSW_CORE_API(gsw_handle,
-				   gsw_brdgport_ops.BridgePort_ConfigSet,
-				   bp_cfg);
+		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, bp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("BridgePort_ConfigSet API failed :%d\n", ret);
 			bret = -1;
@@ -1294,9 +1241,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			goto err;
 		}
 		br_cfg->nBridgeId = mtr_subif->fid;
-		ret = GSW_CORE_API(gsw_handle,
-				   gsw_brdg_ops.Bridge_ConfigGet,
-				   br_cfg);
+		ret = gsw_brdg->Bridge_ConfigGet(gsw_handle, br_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("Bridge_ConfigGet API failed :%d\n", ret);
 			bret = -1;
@@ -1320,8 +1265,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			bret = -1;
 			goto err;
 		}
-		ret = GSW_CORE_API(gsw_handle, gsw_brdg_ops.Bridge_ConfigSet,
-				   br_cfg);
+		ret = gsw_brdg->Bridge_ConfigSet(gsw_handle, br_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("Bridge_ConfigSet API failed :%d\n", ret);
 			bret = -1;
@@ -1340,6 +1284,10 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		    int flag, struct dp_meter_subif *mtr_subif)
 {
 	struct core_ops *gsw_handle;
+	struct tflow_ops *gsw_tflow;
+	struct ctp_ops *gsw_ctp;
+	struct brdgport_ops *gsw_bp;
+	struct brdg_ops *gsw_brdg;
 	GSW_BRIDGE_portConfig_t *bp_cfg = NULL;
 	GSW_PCE_rule_t *pce_rule = NULL;
 	GSW_CTP_portConfig_t *ctp_cfg = NULL;
@@ -1354,7 +1302,10 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	gsw_handle = dp_port_prop[mtr_subif->inst].ops[GSWIP_L];
 	if (!gsw_handle)
 		return -1;
-
+	gsw_tflow = &gsw_handle->gsw_tflow_ops;
+	gsw_ctp = &gsw_handle->gsw_ctp_ops;
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
+	gsw_brdg = &gsw_handle->gsw_brdg_ops;
 	if (meter->dir & DP_METER_ATTACH_PCE) {
 		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_ATOMIC);
 		if (!pce_rule) {
@@ -1365,8 +1316,7 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		/* pattern setting */
 		pce_rule->pattern.nIndex = meter->dp_pce.pce_idx;
 		pce_rule->pattern.bEnable = 0;
-		ret = GSW_CORE_API(gsw_handle, gsw_tflow_ops.TFLOW_PceRuleWrite,
-				   pce_rule);
+		ret = gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, pce_rule);
 		if (ret != GSW_statusOk) {
 			PR_ERR("PceRule Write API failed :%d\n", ret);
 			bret = -1;
@@ -1402,8 +1352,7 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			ctp_cfg->nEgressTrafficMeterId =  meter->meter_id;
 		else if (meter->dir == DP_DIR_INGRESS)
 			ctp_cfg->nIngressTrafficMeterId =  meter->meter_id;
-		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigGet,
-				   ctp_cfg);
+		ret = gsw_ctp->CTP_PortConfigGet(gsw_handle, ctp_cfg);
 		if (ret != GSW_statusOk) {
 			bret = -1;
 			goto err;
@@ -1415,8 +1364,7 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			ctp_cfg->eMask = GSW_CTP_PORT_CONFIG_INGRESS_METER;
 			ctp_cfg->bIngressMeteringEnable = 0;
 		}
-		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigSet,
-				   ctp_cfg);
+		ret = gsw_ctp->CTP_PortConfigSet(gsw_handle, ctp_cfg);
 		if (ret != GSW_statusOk) {
 			bret = -1;
 			goto err;
@@ -1435,9 +1383,7 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			goto err;
 		}
 		bp_cfg->nBridgePortId = mtr_subif->subif.bport;
-		ret = GSW_CORE_API(gsw_handle,
-				   gsw_brdgport_ops.BridgePort_ConfigGet,
-				   bp_cfg);
+		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, bp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("BridgePort_ConfigGet API failed\n");
 			bret = -1;
@@ -1467,9 +1413,7 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 				GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_METER;
 			bp_cfg->bIngressMeteringEnable = 0;
 		}
-		ret = GSW_CORE_API(gsw_handle,
-				   gsw_brdgport_ops.BridgePort_ConfigSet,
-				   bp_cfg);
+		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, bp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("BridgePort_ConfigSet API failed\n");
 			bret = -1;
@@ -1484,8 +1428,7 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			goto err;
 		}
 		br_cfg->nBridgeId = mtr_subif->fid;
-		ret = GSW_CORE_API(gsw_handle, gsw_brdg_ops.Bridge_ConfigGet,
-				   br_cfg);
+		ret = gsw_brdg->Bridge_ConfigGet(gsw_handle, br_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("Bridge_ConfigGet API failed :%d\n", ret);
 			bret = -1;
@@ -1509,8 +1452,7 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			bret = -1;
 			goto err;
 		}
-		ret = GSW_CORE_API(gsw_handle, gsw_brdg_ops.Bridge_ConfigSet,
-				   br_cfg);
+		ret = gsw_brdg->Bridge_ConfigSet(gsw_handle, br_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("Bridge_ConfigSet API failed :%d\n", ret);
 			bret = -1;
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_misc.c b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
index d686a3a2dbc5..9153364c6d50 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
@@ -504,9 +504,11 @@ int alloc_q_to_port(struct ppv4_q_sch_port *info, u32 flag)
 static int dp_gswip_remark_8P0D_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorRemarkingEntry_t color_remark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_remark.eMode = mode;
 	color_remark.nVal[0] = 0;
 	color_remark.nVal[1] = 2;
@@ -524,9 +526,7 @@ static int dp_gswip_remark_8P0D_set(int mode, int inst)
 	color_remark.nVal[13] = 11;
 	color_remark.nVal[14] = 13;
 	color_remark.nVal[15] = 15;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorReMarkingTableSet,
-		gsw_handle, &color_remark)) {
+	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
 		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -536,9 +536,11 @@ static int dp_gswip_remark_8P0D_set(int mode, int inst)
 static int dp_gswip_remark_7P1D_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorRemarkingEntry_t color_remark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_remark.eMode = mode;
 	color_remark.nVal[0] = 0;
 	color_remark.nVal[1] = 2;
@@ -556,9 +558,7 @@ static int dp_gswip_remark_7P1D_set(int mode, int inst)
 	color_remark.nVal[13] = 9;
 	color_remark.nVal[14] = 13;
 	color_remark.nVal[15] = 15;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorReMarkingTableSet,
-		gsw_handle, &color_remark)) {
+	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
 		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -568,9 +568,11 @@ static int dp_gswip_remark_7P1D_set(int mode, int inst)
 static int dp_gswip_remark_6P2D_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorRemarkingEntry_t color_remark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_remark.eMode = mode;
 	color_remark.nVal[0] = 0;
 	color_remark.nVal[1] = 2;
@@ -588,9 +590,7 @@ static int dp_gswip_remark_6P2D_set(int mode, int inst)
 	color_remark.nVal[13] = 9;
 	color_remark.nVal[14] = 13;
 	color_remark.nVal[15] = 15;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorReMarkingTableSet,
-		gsw_handle, &color_remark)) {
+	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
 		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -600,9 +600,11 @@ static int dp_gswip_remark_6P2D_set(int mode, int inst)
 static int dp_gswip_remark_5P3D_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorRemarkingEntry_t color_remark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_remark.eMode = mode;
 	color_remark.nVal[0] = 2;
 	color_remark.nVal[1] = 2;
@@ -620,9 +622,7 @@ static int dp_gswip_remark_5P3D_set(int mode, int inst)
 	color_remark.nVal[13] = 9;
 	color_remark.nVal[14] = 13;
 	color_remark.nVal[15] = 15;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorReMarkingTableSet,
-		gsw_handle, &color_remark)) {
+	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
 		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -632,9 +632,11 @@ static int dp_gswip_remark_5P3D_set(int mode, int inst)
 static int dp_gswip_remark_dscp_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorRemarkingEntry_t color_remark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_remark.eMode = mode;
 	color_remark.nVal[0] = 10;
 	color_remark.nVal[1] = 18;
@@ -652,9 +654,7 @@ static int dp_gswip_remark_dscp_set(int mode, int inst)
 	color_remark.nVal[13] = 36;
 	color_remark.nVal[14] = 36;
 	color_remark.nVal[15] = 36;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorReMarkingTableSet,
-		gsw_handle, &color_remark)) {
+	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
 		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -664,9 +664,11 @@ static int dp_gswip_remark_dscp_set(int mode, int inst)
 static int dp_gswip_color_dscp_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorMarkingEntry_t color_mark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_mark.eMode = mode;
 	color_mark.nPriority[0] = PRIO0;
 	color_mark.nPriority[1] = PRIO0;
@@ -796,9 +798,7 @@ static int dp_gswip_color_dscp_set(int mode, int inst)
 	color_mark.nColor[61] = GSW_DROP_PRECEDENCE_YELLOW;
 	color_mark.nColor[62] = GSW_DROP_PRECEDENCE_YELLOW;
 	color_mark.nColor[63] = GSW_DROP_PRECEDENCE_YELLOW;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorMarkingTableSet,
-		gsw_handle, &color_mark)) {
+	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
 		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -808,9 +808,11 @@ static int dp_gswip_color_dscp_set(int mode, int inst)
 static int dp_gswip_color_5P3D_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorMarkingEntry_t color_mark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_mark.eMode = mode;
 	color_mark.nPriority[0] = PRIO0;
 	color_mark.nPriority[1] = PRIO0;
@@ -844,9 +846,7 @@ static int dp_gswip_color_5P3D_set(int mode, int inst)
 	color_mark.nColor[13] = GSW_DROP_PRECEDENCE_YELLOW;
 	color_mark.nColor[14] = GSW_DROP_PRECEDENCE_GREEN;
 	color_mark.nColor[15] = GSW_DROP_PRECEDENCE_YELLOW;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorMarkingTableSet,
-		gsw_handle, &color_mark)) {
+	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
 		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -856,9 +856,11 @@ static int dp_gswip_color_5P3D_set(int mode, int inst)
 static int dp_gswip_color_6P2D_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorMarkingEntry_t color_mark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_mark.eMode = mode;
 	color_mark.nPriority[0] = PRIO0;
 	color_mark.nPriority[1] = PRIO0;
@@ -892,9 +894,7 @@ static int dp_gswip_color_6P2D_set(int mode, int inst)
 	color_mark.nColor[13] = GSW_DROP_PRECEDENCE_YELLOW;
 	color_mark.nColor[14] = GSW_DROP_PRECEDENCE_GREEN;
 	color_mark.nColor[15] = GSW_DROP_PRECEDENCE_YELLOW;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorMarkingTableSet,
-		gsw_handle, &color_mark)) {
+	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
 		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -904,9 +904,11 @@ static int dp_gswip_color_6P2D_set(int mode, int inst)
 static int dp_gswip_color_7P1D_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorMarkingEntry_t color_mark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_mark.eMode = mode;
 	color_mark.nPriority[0] = PRIO0;
 	color_mark.nPriority[1] = PRIO0;
@@ -940,9 +942,7 @@ static int dp_gswip_color_7P1D_set(int mode, int inst)
 	color_mark.nColor[13] = GSW_DROP_PRECEDENCE_YELLOW;
 	color_mark.nColor[14] = GSW_DROP_PRECEDENCE_GREEN;
 	color_mark.nColor[15] = GSW_DROP_PRECEDENCE_YELLOW;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorMarkingTableSet,
-		gsw_handle, &color_mark)) {
+	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
 		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -952,9 +952,11 @@ static int dp_gswip_color_7P1D_set(int mode, int inst)
 static int dp_gswip_color_8P0D_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorMarkingEntry_t color_mark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_mark.eMode = mode;
 	color_mark.nPriority[0] = PRIO0;
 	color_mark.nPriority[1] = PRIO0;
@@ -988,9 +990,7 @@ static int dp_gswip_color_8P0D_set(int mode, int inst)
 	color_mark.nColor[13] = GSW_DROP_PRECEDENCE_YELLOW;
 	color_mark.nColor[14] = GSW_DROP_PRECEDENCE_GREEN;
 	color_mark.nColor[15] = GSW_DROP_PRECEDENCE_YELLOW;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorMarkingTableSet,
-		gsw_handle, &color_mark)) {
+	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
 		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -1211,16 +1211,14 @@ static int dp_platform_set(int inst, u32 flag)
 #endif
 		/*disable egress VLAN modification for CPU port*/
 		port_remark.nPortId = 0;
-		if (gsw_core_api(
-			(dp_gsw_cb)gsw_qos->QoS_PortRemarkingCfgGet,
-			gsw_handle, &port_remark)) {
+		if (gsw_qos->QoS_PortRemarkingCfgGet(gsw_handle,
+						     &port_remark)) {
 			PR_ERR("GSW_QOS_PORT_REMARKING_CFG_GET failed\n");
 			return -1;
 		}
 		port_remark.bPCP_EgressRemarkingEnable = 0;
-		if (gsw_core_api(
-			(dp_gsw_cb)gsw_qos->QoS_PortRemarkingCfgGet,
-			gsw_handle, &port_remark)) {
+		if (gsw_qos->QoS_PortRemarkingCfgGet(gsw_handle,
+						     &port_remark)) {
 			PR_ERR("GSW_QOS_PORT_REMARKING_CFG_GET failed\n");
 			return -1;
 		}
@@ -1261,15 +1259,16 @@ static int dp_platform_set(int inst, u32 flag)
 static int pon_config(int inst, int ep, struct dp_port_data *data, u32 flags)
 {
 	struct core_ops *gsw_handle;
+	struct common_ops *gsw_com;
 	GSW_return_t ret;
 	struct mac_ops *mac_ops;
 	GSW_CPU_PortCfg_t cpu_port_cfg;
 
 	mac_ops = dp_port_prop[inst].mac_ops[ep];
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
+	gsw_com = &gsw_handle->gsw_common_ops;
 	memset((void *)&cpu_port_cfg, 0x00, sizeof(cpu_port_cfg));
-	ret = gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.CPU_PortCfgGet,
-			   gsw_handle, &cpu_port_cfg);
+	ret = gsw_com->CPU_PortCfgGet(gsw_handle, &cpu_port_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("fail in getting CPU port config\r\n");
 		return -1;
@@ -1278,8 +1277,7 @@ static int pon_config(int inst, int ep, struct dp_port_data *data, u32 flags)
 	cpu_port_cfg.nPortId = ep;
 	cpu_port_cfg.bSpecialTagIngress = 1;
 	cpu_port_cfg.bSpecialTagEgress = 1;
-	ret = gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.CPU_PortCfgSet,
-			   gsw_handle, &cpu_port_cfg);
+	ret = gsw_com->CPU_PortCfgSet(gsw_handle, &cpu_port_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Fail in configuring CPU port\n");
 		return -1;
@@ -1428,8 +1426,7 @@ static int set_ctp_bp(int inst, int ctp, int portid, int bp,
 	tmp.nSubIfIdGroup = ctp;
 	tmp.eMask = GSW_CTP_PORT_CONFIG_MASK_BRIDGE_PORT_ID;
 	tmp.nBridgePortId = bp;
-	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_ctp_ops.CTP_PortConfigSet,
-			 gsw_handle, &tmp) != 0) {
+	if (gsw_handle->gsw_ctp_ops.CTP_PortConfigSet(gsw_handle, &tmp)) {
 		PR_ERR("Failed to CTP(%d)'s bridge port=%d for ep=%d\n",
 		       ctp, bp, portid);
 		return -1;
@@ -1452,8 +1449,7 @@ static int reset_ctp_bp(int inst, int ctp, int portid, int bp)
 	tmp.nLogicalPortId = portid;
 	tmp.nSubIfIdGroup = ctp;
 	tmp.nBridgePortId = bp;
-	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_ctp_ops.CTP_PortConfigReset,
-			 gsw_handle, &tmp) != 0) {
+	if (gsw_handle->gsw_ctp_ops.CTP_PortConfigReset(gsw_handle, &tmp)) {
 		PR_ERR("Failed to reset CTP(%d)'s bridge port=%d for ep=%d\n",
 		       ctp, bp, portid);
 		return -1;
@@ -1985,6 +1981,7 @@ static int dp_ctp_tc_map_set_31(struct dp_tc_cfg *tc, int flag,
 				struct dp_meter_subif *mtr_subif)
 {
 	struct core_ops *gsw_handle;
+	struct ctp_ops *gsw_ctp;
 	GSW_CTP_portConfig_t ctp_tc_cfg;
 
 	memset(&ctp_tc_cfg, 0, sizeof(ctp_tc_cfg));
@@ -1999,10 +1996,10 @@ static int dp_ctp_tc_map_set_31(struct dp_tc_cfg *tc, int flag,
 		return -1;
 	}
 	gsw_handle = dp_port_prop[mtr_subif->inst].ops[GSWIP_L];
+	gsw_ctp = &gsw_handle->gsw_ctp_ops;
 	ctp_tc_cfg.nLogicalPortId = mtr_subif->subif.port_id;
 	ctp_tc_cfg.nSubIfIdGroup = mtr_subif->subif.subif;
-	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_ctp_ops.CTP_PortConfigGet,
-			 gsw_handle, &ctp_tc_cfg) != 0) {
+	if (gsw_ctp->CTP_PortConfigGet(gsw_handle, &ctp_tc_cfg)) {
 		PR_ERR("Failed to get CTP info for ep=%d subif=%d\n",
 		       mtr_subif->subif.port_id, mtr_subif->subif.subif);
 		return -1;
@@ -2014,8 +2011,7 @@ static int dp_ctp_tc_map_set_31(struct dp_tc_cfg *tc, int flag,
 	else
 		ctp_tc_cfg.bForcedTrafficClass = 0;
 
-	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_ctp_ops.CTP_PortConfigSet,
-			 gsw_handle, &ctp_tc_cfg) != 0) {
+	if (gsw_ctp->CTP_PortConfigSet(gsw_handle, &ctp_tc_cfg)) {
 		PR_ERR("CTP tc set fail for ep=%d subif=%d tc=%d force=%d\n",
 		       mtr_subif->subif.port_id, mtr_subif->subif.subif,
 		       tc->tc, tc->force);
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_misc.h b/drivers/net/datapath/dpm/gswip31/datapath_misc.h
index 9d24d2560121..27e824ab886b 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_misc.h
+++ b/drivers/net/datapath/dpm/gswip31/datapath_misc.h
@@ -181,13 +181,6 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 void set_chksum(struct pmac_tx_hdr *pmac, u32 tcp_type, u32 ip_offset,
 		int ip_off_hw_adjust, u32 tcp_h_offset);
 
-static inline GSW_return_t gsw_core_api(dp_gsw_cb func, void *ops, void *param)
-{
-	if (!func)
-		return DP_FAILURE;
-	return func(ops, param);
-}
-
 static inline char *parser_flag_str(u8 f)
 {
 	if (f == DP_PARSER_F_DISABLE)
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_proc.c b/drivers/net/datapath/dpm/gswip31/datapath_proc.c
index 2480e0f6ae3e..2a967ecf7864 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_proc.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_proc.c
@@ -55,11 +55,13 @@ ssize_t proc_parser_write(struct file *file, const char *buf,
 	static GSW_PCE_rule_t pce;
 	int inst = 0;
 	struct core_ops *gsw_handle;
+	struct tflow_ops *gsw_tflow;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 	memset(&pce, 0, sizeof(pce));
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
+	gsw_tflow = &gsw_handle->gsw_tflow_ops;
 	len = (sizeof(str) > count) ? count : sizeof(str) - 1;
 	len -= copy_from_user(str, buf, len);
 	str[len] = 0;
@@ -204,9 +206,7 @@ ssize_t proc_parser_write(struct file *file, const char *buf,
 		pce.action.bRMON_Action = 1;
 		pce.action.nRMON_Id = 0;	/*RMON_UDP_CNTR; */
 
-		if (gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_tflow_ops.TFLOW_PceRuleWrite,
-			gsw_handle, &pce)) {
+		if (gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, &pce)) {
 			PR_ERR("PCE rule add fail: GSW_PCE_RULE_WRITE\n");
 			return count;
 		}
@@ -217,9 +217,7 @@ ssize_t proc_parser_write(struct file *file, const char *buf,
 		pce_rule_id = dp_atoi(param_list[1]);
 		pce.pattern.nIndex = pce_rule_id;
 		pce.pattern.bEnable = 0;
-		if (gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_tflow_ops.TFLOW_PceRuleWrite,
-			gsw_handle, &pce)) {
+		if (gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, &pce)) {
 			PR_ERR("PCE rule add fail:GSW_PCE_RULE_WRITE\n");
 			return count;
 		}
@@ -242,17 +240,17 @@ char *get_bp_member_string(int inst, u16 bp, char *buf)
 	GSW_BRIDGE_portConfig_t bp_cfg;
 	int i, ret;
 	struct core_ops *gsw_handle;
+	struct brdgport_ops *gsw_bp;
 
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	if (!buf)
 		return NULL;
 	buf[0] = 0;
 	bp_cfg.nBridgePortId = bp;
 	bp_cfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP |
 		GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID;
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
-		gsw_handle, &bp_cfg);
+	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Failed to get bridge port's member for bridgeport=%d\n",
 		       bp_cfg.nBridgePortId);
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_switchdev.c b/drivers/net/datapath/dpm/gswip31/datapath_switchdev.c
index 5228decad4d8..83443843f26c 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_switchdev.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_switchdev.c
@@ -22,8 +22,7 @@ int dp_swdev_alloc_bridge_id(int inst)
 
 	gsw_handle = dp_port_prop[inst].ops[0];
 	memset(&br, 0, sizeof(br));
-	ret = gsw_core_api((dp_gsw_cb)gsw_handle->gsw_brdg_ops.Bridge_Alloc,
-			   gsw_handle, &br);
+	ret = gsw_handle->gsw_brdg_ops.Bridge_Alloc(gsw_handle, &br);
 	if ((ret != GSW_statusOk) ||
 	    (br.nBridgeId < 0)) {
 		PR_ERR("Failed to get a FID\n");
@@ -50,9 +49,7 @@ int dp_swdev_bridge_port_cfg_set(struct br_info *br_item,
 	DP_DEBUG(DP_DBG_FLAG_SWDEV, "Set current BP=%d inst:%d\n",
 		 brportcfg.nBridgePortId, inst);
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
-		gsw_handle, &brportcfg);
+	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("fail in getting bridge port config\r\n");
 		return -1;
@@ -66,46 +63,35 @@ int dp_swdev_bridge_port_cfg_set(struct br_info *br_item,
 	brportcfg.nBridgeId = br_item->fid;
 	brportcfg.nBridgePortId = bport;
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
-		GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
-		gsw_handle, &brportcfg);
+			  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
+	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Fail in allocating/configuring bridge port\n");
 		return -1;
 	}
 	/* To set other member portmap with current bridge port map */
 	list_for_each_entry(bport_list, &br_item->bp_list, list) {
-		if (bport_list->portid != bport) {
-			memset(&brportcfg, 0,
-			       sizeof(GSW_BRIDGE_portConfig_t));
-			brportcfg.nBridgePortId = bport_list->portid;
-			DP_DEBUG(DP_DBG_FLAG_SWDEV,
-				 "Set other BP=%d inst:%d\n",
-				 brportcfg.nBridgePortId, inst);
-			brportcfg.eMask =
-				GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
-				gsw_handle, &brportcfg);
-			if (ret != GSW_statusOk) {
-				PR_ERR
-					("fail in getting br port config\r\n");
-				return -1;
-			}
-			SET_BP_MAP(brportcfg.nBridgePortMap, bport);
-			brportcfg.nBridgeId = br_item->fid;
-			brportcfg.nBridgePortId = bport_list->portid;
-			brportcfg.eMask =
-				GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
-				GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
-				gsw_handle, &brportcfg);
-			if (ret != GSW_statusOk) {
-				PR_ERR("Fail alloc/cfg bridge port\n");
-				return -1;
-			}
+		if (bport_list->portid == bport)
+			continue;
+		memset(&brportcfg, 0, sizeof(GSW_BRIDGE_portConfig_t));
+		brportcfg.nBridgePortId = bport_list->portid;
+		DP_DEBUG(DP_DBG_FLAG_SWDEV, "Set other BP=%d inst:%d\n",
+			 brportcfg.nBridgePortId, inst);
+		brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
+		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &brportcfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("fail in getting br port config\r\n");
+			return -1;
+		}
+		SET_BP_MAP(brportcfg.nBridgePortMap, bport);
+		brportcfg.nBridgeId = br_item->fid;
+		brportcfg.nBridgePortId = bport_list->portid;
+		brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
+				  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
+		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &brportcfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("Fail alloc/cfg bridge port\n");
+			return -1;
 		}
 	}
 	return 0;
@@ -129,9 +115,7 @@ int dp_swdev_bridge_port_cfg_reset(struct br_info *br_item,
 		 brportcfg.nBridgePortId, inst);
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	/*Reset other members from current bport map*/
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
-		gsw_handle, &brportcfg);
+	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
 		/* Note: here may fail if this device is not removed from
 		 * linux bridge via brctl delif but user try to un-regiser
@@ -167,9 +151,7 @@ int dp_swdev_bridge_port_cfg_reset(struct br_info *br_item,
 	brportcfg.nBridgePortId = bport;
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
 			  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
-		gsw_handle, &brportcfg);
+	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Fail in configuring GSW_BRIDGE_portConfig_t in %s\r\n",
 		       __func__);
@@ -177,35 +159,28 @@ int dp_swdev_bridge_port_cfg_reset(struct br_info *br_item,
 	}
 	/*Reset current bp from all other bridge port's port map*/
 	list_for_each_entry(bport_list, &br_item->bp_list, list) {
-		if (bport_list->portid != bport) {
-			memset(&brportcfg, 0,
-			       sizeof(GSW_BRIDGE_portConfig_t));
-			brportcfg.nBridgePortId = bport_list->portid;
-			DP_DEBUG(DP_DBG_FLAG_SWDEV,
-				 "reset current BP from other BP=%d inst:%d\n",
-				 brportcfg.nBridgePortId, inst);
-			brportcfg.eMask =
-				 GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP |
-				 GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID;
-			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
-				gsw_handle, &brportcfg);
-			if (ret != GSW_statusOk) {
-				PR_ERR("failed getting br port cfg\r\n");
-				return -1;
-			}
-			UNSET_BP_MAP(brportcfg.nBridgePortMap, bport);
-			brportcfg.nBridgePortId = bport_list->portid;
-			brportcfg.eMask =
-				 GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
-				 GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
-				gsw_handle, &brportcfg);
-			if (ret != GSW_statusOk) {
-				PR_ERR("Fail alloc/cfg br port\n");
-				return -1;
-			}
+		if (bport_list->portid == bport)
+			continue;
+		memset(&brportcfg, 0, sizeof(GSW_BRIDGE_portConfig_t));
+		brportcfg.nBridgePortId = bport_list->portid;
+		DP_DEBUG(DP_DBG_FLAG_SWDEV,
+			 "reset current BP from other BP=%d inst:%d\n",
+			 brportcfg.nBridgePortId, inst);
+		brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP |
+				  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID;
+		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &brportcfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("failed getting br port cfg\r\n");
+			return -1;
+		}
+		UNSET_BP_MAP(brportcfg.nBridgePortMap, bport);
+		brportcfg.nBridgePortId = bport_list->portid;
+		brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
+				  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
+		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &brportcfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("Fail alloc/cfg br port\n");
+			return -1;
 		}
 	}
 	DP_DEBUG(DP_DBG_FLAG_SWDEV, "%s success\n", __func__);
@@ -233,13 +208,11 @@ int dp_swdev_bridge_cfg_set(int inst, u16 fid)
 	brcfg.eForwardBroadcast = GSW_BRIDGE_FORWARD_FLOOD;
 	brcfg.eForwardUnknownMulticastNonIp = GSW_BRIDGE_FORWARD_FLOOD;
 	brcfg.eForwardUnknownUnicast = GSW_BRIDGE_FORWARD_FLOOD;
-	ret = gsw_core_api((dp_gsw_cb)gsw_handle->gsw_brdg_ops.Bridge_ConfigSet,
-			   gsw_handle, &brcfg);
+	ret = gsw_handle->gsw_brdg_ops.Bridge_ConfigSet(gsw_handle, &brcfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Failed to set bridge id(%d)\n", brcfg.nBridgeId);
 		br.nBridgeId = fid;
-		gsw_core_api((dp_gsw_cb)gsw_handle->gsw_brdg_ops.Bridge_Free,
-			     gsw_handle, &br);
+		gsw_handle->gsw_brdg_ops.Bridge_Free(gsw_handle, &br);
 		return -1;
 	}
 	DP_DEBUG(DP_DBG_FLAG_SWDEV, "FID(%d) cfg success for inst %d\n",
@@ -256,8 +229,7 @@ int dp_swdev_free_brcfg(int inst, u16 fid)
 	gsw_handle = dp_port_prop[inst].ops[0];
 	memset(&br, 0, sizeof(br));
 	br.nBridgeId = fid;
-	ret = gsw_core_api((dp_gsw_cb)gsw_handle->gsw_brdg_ops.Bridge_Free,
-			   gsw_handle, &br);
+	ret = gsw_handle->gsw_brdg_ops.Bridge_Free(gsw_handle, &br);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Failed to free bridge id(%d)\n", br.nBridgeId);
 		return -1;
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_gswip.c b/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
index 784860def527..f0d43161d3ae 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
@@ -14,10 +14,6 @@
 #include "../datapath.h"
 #include "datapath_misc.h"
 
-#define GSW_CORE_API(_handle, a, b) ({ \
-	typeof(_handle) (handle) = (_handle); \
-	gsw_core_api((dp_gsw_cb)(handle)->a, (handle), (b)); })
-
 #define BP_CFG(bp_cfg, _index, bflag, id) ({ \
 	typeof(_index) (index) = (_index); \
 	(bp_cfg)->bEgressSubMeteringEnable[(index)] = bflag; \
@@ -132,9 +128,7 @@ int dp_pmac_set_32(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 				igcfg.nTxDmaChanId =
 					pmac_cfg->ig_pmac.tx_dma_chan;
 			}
-			gsw_core_api(
-				(dp_gsw_cb)gswr_r->gsw_pmac_ops.Pmac_Ig_CfgGet,
-				gswr_r, &igcfg);
+			gswr_r->gsw_pmac_ops.Pmac_Ig_CfgGet(gswr_r, &igcfg);
 
 			/*update igcfg and write back to gsw */
 			if (pmac_cfg->ig_pmac_flags & IG_PMAC_F_ERR_DISC)
@@ -234,9 +228,7 @@ int dp_pmac_set_32(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 
 			DP_DEBUG(DP_DBG_FLAG_DBG, "\n");
 
-			gsw_core_api(
-				(dp_gsw_cb)gswr_r->gsw_pmac_ops.Pmac_Ig_CfgSet,
-				gswr_r, &igcfg);
+			gswr_r->gsw_pmac_ops.Pmac_Ig_CfgSet(gswr_r, &igcfg);
 		}
 
 			kfree(dqport.deq_info);
@@ -257,9 +249,7 @@ int dp_pmac_set_32(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 			egcfg.nBslTrafficClass = i;
 
 			memset(&pmac_glb, 0, sizeof(pmac_glb));
-			gsw_core_api(
-				(dp_gsw_cb)gswr_r->gsw_pmac_ops.Pmac_Gbl_CfgGet,
-				gswr_r, &pmac_glb);
+			gswr_r->gsw_pmac_ops.Pmac_Gbl_CfgGet(gswr_r, &pmac_glb);
 			egcfg.bProcFlagsSelect = pmac_glb.bProcFlagsEgCfgEna;
 			DP_DEBUG(DP_DBG_FLAG_DBG, "bProcFlagsSelect=%u\n",
 				 egcfg.bProcFlagsSelect);
@@ -392,9 +382,7 @@ int dp_pmac_set_32(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 					 egcfg.bMpe2Flag);
 			}
 #endif
-			gsw_core_api(
-				(dp_gsw_cb)gswr_r->gsw_pmac_ops.Pmac_Eg_CfgSet,
-				gswr_r, &egcfg);
+			gswr_r->gsw_pmac_ops.Pmac_Eg_CfgSet(gswr_r, &egcfg);
 			;
 		}
 	}
@@ -415,8 +403,7 @@ int dp_set_gsw_parser_32(u8 flag, u8 cpu, u8 mpe1,
 	GSW_CPU_PortCfg_t param = {0};
 	struct core_ops *gsw_handle = dp_port_prop[0].ops[0];/*gswip o */
 
-	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.CPU_PortCfgGet,
-			 gsw_handle, &param)) {
+	if (gsw_handle->gsw_common_ops.CPU_PortCfgGet(gsw_handle, &param)) {
 		PR_ERR("Failed GSW_CPU_PORT_CFG_GET\n");
 		return -1;
 	}
@@ -438,8 +425,7 @@ int dp_set_gsw_parser_32(u8 flag, u8 cpu, u8 mpe1,
 	if (flag & F_MPE1_MPE2)
 		param.eMPE1MPE2ParserCfg = mpe3;
 
-	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.CPU_PortCfgSet,
-			 gsw_handle, &param)) {
+	if (gsw_handle->gsw_common_ops.CPU_PortCfgSet(gsw_handle, &param)) {
 		PR_ERR("Failed GSW_CPU_PORT_CFG_SET\n");
 		return -1;
 	}
@@ -456,8 +442,7 @@ int dp_get_gsw_parser_32(u8 *cpu, u8 *mpe1, u8 *mpe2,
 	GSW_CPU_PortCfg_t param = {0};
 	struct core_ops *gsw_handle = dp_port_prop[0].ops[0]; /*gswip 0*/
 
-	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.CPU_PortCfgGet,
-			 gsw_handle, &param)) {
+	if (gsw_handle->gsw_common_ops.CPU_PortCfgGet(gsw_handle, &param)) {
 		PR_ERR("Failed GSW_CPU_PORT_CFG_GET\n");
 		return -1;
 	}
@@ -496,8 +481,7 @@ int gsw_mib_reset_32(int dev, u32 flag)
 
 	gsw_handle = dp_port_prop[0].ops[0];
 	rmon_clear.eRmonType = GSW_RMON_ALL_TYPE;
-	ret = gsw_core_api((dp_gsw_cb)gsw_handle->gsw_rmon_ops.RMON_Clear,
-			   gsw_handle, &rmon_clear);
+	ret = gsw_handle->gsw_rmon_ops.RMON_Clear(gsw_handle, &rmon_clear);
 
 	if (ret != GSW_statusOk) {
 		PR_ERR("R:GSW_RMON_CLEAR failed for GSW_RMON_ALL_TYPE\n");
@@ -529,9 +513,7 @@ struct gsw_itf *ctp_port_assign_32(int inst, u8 ep, int bp_default,
 		ctp_assign.eMode = itf_assign[ep].mode;
 		ctp_assign.nFirstCtpPortId = itf_assign[ep].start;
 		ctp_assign.nNumberOfCtpPort = itf_assign[ep].n;
-		if (gsw_core_api(
-			(dp_gsw_cb)gsw_ctp->CTP_PortAssignmentFree,
-			gsw_handle, &ctp_assign) != 0) {
+		if (gsw_ctp->CTP_PortAssignmentFree(gsw_handle, &ctp_assign)) {
 			PR_ERR("Failed to allc CTP for ep=%d blk=%d mode=%d\n",
 			       ep, assign->num, assign->emode);
 			return NULL;
@@ -555,10 +537,7 @@ struct gsw_itf *ctp_port_assign_32(int inst, u8 ep, int bp_default,
 	ctp_assign.nBridgePortId = bp_default;
 	ctp_assign.nFirstCtpPortId = 0;
 	ctp_assign.nNumberOfCtpPort = num;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_ctp->CTP_PortAssignmentAlloc,
-		gsw_handle,
-		&ctp_assign) != 0) {
+	if (gsw_ctp->CTP_PortAssignmentAlloc(gsw_handle, &ctp_assign)) {
 		PR_ERR("Failed CTP Assignment for ep=%d blk size=%d mode=%s\n",
 		       ep, num, ctp_mode_string(assign->emode));
 		return NULL;
@@ -609,16 +588,15 @@ int alloc_bridge_port_32(int inst, int port_id, int subif_ix,
 	GSW_BRIDGE_portAlloc_t bp = {0};
 	GSW_BRIDGE_portConfig_t bp_cfg = {0};
 	struct core_ops *gsw_handle;
+	struct brdgport_ops *gsw_bp;
 	GSW_return_t ret;
 
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	/*allocate a free bridge port */
 	memset(&bp, 0, sizeof(bp));
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_Alloc,
-		gsw_handle, &bp);
-	if ((ret != GSW_statusOk) ||
-	    (bp.nBridgePortId < 0)) {
+	ret = gsw_bp->BridgePort_Alloc(gsw_handle, &bp);
+	if ((ret != GSW_statusOk) || (bp.nBridgePortId < 0)) {
 		PR_ERR("Failed to get a bridge port\n");
 		return -1;
 	}
@@ -643,15 +621,11 @@ int alloc_bridge_port_32(int inst, int port_id, int subif_ix,
 	bp_cfg.nBridgeId = fid;
 
 	SET_BP_MAP(bp_cfg.nBridgePortMap, bp_member); /*CPU*/
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigSet,
-		gsw_handle, &bp_cfg);
+	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Failed to set bridge id(%d) and port map for bp= %d\n",
 		       fid, bp_cfg.nBridgePortId);
-		gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_Free,
-			gsw_handle, &bp);
+		gsw_bp->BridgePort_Free(gsw_handle, &bp);
 		return -1;
 	}
 
@@ -660,27 +634,19 @@ int alloc_bridge_port_32(int inst, int port_id, int subif_ix,
 	 */
 	bp_cfg.nBridgePortId = bp_member;
 	bp_cfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
-		gsw_handle, &bp_cfg);
+	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Failed to get bridge port's member for bridgeport=%d\n",
 		       bp_cfg.nBridgePortId);
-		gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_Free,
-			gsw_handle, &bp);
+		gsw_bp->BridgePort_Free(gsw_handle, &bp);
 		return -1;
 	}
 	SET_BP_MAP(bp_cfg.nBridgePortMap, bp.nBridgePortId);
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigSet,
-		gsw_handle, &bp_cfg);
+	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Failed to set bridge port's member for bridgeport=%d\n",
 		       bp_cfg.nBridgePortId);
-		gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_Free,
-			gsw_handle, &bp);
+		gsw_bp->BridgePort_Free(gsw_handle, &bp);
 		return -1;
 	}
 
@@ -713,9 +679,7 @@ int free_bridge_port_32(int inst, int bp)
 	/*read out this delting bridge port's member*/
 	tmp->nBridgePortId = bp;
 	tmp->eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
-		gsw_handle, tmp);
+	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, tmp);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_GET: %d\n", bp);
 		goto EXIT;
@@ -730,17 +694,13 @@ int free_bridge_port_32(int inst, int bp)
 			tmp2->eMask =
 				GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 			tmp2->nBridgePortId = i * 16 + j;
-			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
-				gsw_handle, tmp2);
+			ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, tmp2);
 			if (ret != GSW_statusOk) {
 				PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_GET\n");
 				goto EXIT;
 			}
 			UNSET_BP_MAP(tmp2->nBridgePortMap, bp);
-			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
-				gsw_handle, tmp2);
+			ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, tmp2);
 			if (ret != GSW_statusOk) {
 				PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_SET\n");
 				goto EXIT;
@@ -752,9 +712,8 @@ int free_bridge_port_32(int inst, int bp)
 	memset(tmp, 0, sizeof(*tmp));
 	tmp->nBridgePortId = bp;
 	tmp->eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_bp->BridgePort_Free,
-		gsw_handle, tmp);
+	ret = gsw_bp->BridgePort_Free(gsw_handle,
+				      (GSW_BRIDGE_portAlloc_t *)tmp);
 	if (ret != GSW_statusOk)
 		PR_ERR("Failed to GSW_BRIDGE_PORT_FREE:%d\n", bp);
 FREE_EXIT:
@@ -777,9 +736,7 @@ int dp_gswip_mac_entry_add_32(int bport, int fid, int inst, u8 *addr)
 	SET_BP_MAP(tmp.nPortMap, bport);
 	tmp.nSubIfId = 0;
 	memcpy(tmp.nMAC, addr, GSW_MAC_ADDR_LEN);
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_swmac_ops.MAC_TableEntryAdd,
-		gsw_handle, &tmp);
+	ret = gsw_handle->gsw_swmac_ops.MAC_TableEntryAdd(gsw_handle, &tmp);
 	if (ret != GSW_statusOk) {
 		PR_ERR("fail in setting MAC table static add entry\r\n");
 		return -1;
@@ -793,24 +750,22 @@ int dp_gswip_mac_entry_del_32(int bport, int fid, int inst, u8 *addr)
 	GSW_MAC_tableQuery_t mac_query;
 	GSW_return_t ret;
 	struct core_ops *gsw_handle;
+	struct swmac_ops *gsw_swmac;
 
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
+	gsw_swmac = &gsw_handle->gsw_swmac_ops;
 	memset(&tmp, 0, sizeof(tmp));
 	memset(&mac_query, 0, sizeof(mac_query));
 	mac_query.nFId = fid;
 	memcpy(mac_query.nMAC, addr, GSW_MAC_ADDR_LEN);
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_swmac_ops.MAC_TableEntryQuery,
-		gsw_handle, &tmp);
+	ret = gsw_swmac->MAC_TableEntryQuery(gsw_handle, &mac_query);
 	if (ret != GSW_statusOk) {
 		PR_ERR("fail in getting MAC query entry\r\n");
 		return -1;
 	}
 	tmp.nFId = fid;
 	memcpy(tmp.nMAC, addr, GSW_MAC_ADDR_LEN);
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_swmac_ops.MAC_TableEntryRemove,
-		gsw_handle, &tmp);
+	ret = gsw_swmac->MAC_TableEntryRemove(gsw_handle, &tmp);
 	if (ret != GSW_statusOk) {
 		PR_ERR("fail in setting MAC static entry remove\r\n");
 		return -1;
@@ -827,18 +782,14 @@ int cpu_vlan_mod_dis_32(int inst)
 	ops = dp_port_prop[inst].ops[GSWIP_L];
 
 	cfg.nPortId = 0;
-	ret = gsw_core_api(
-		(dp_gsw_cb)ops->gsw_qos_ops.QoS_PortRemarkingCfgGet,
-		ops, &cfg);
+	ret = ops->gsw_qos_ops.QoS_PortRemarkingCfgGet(ops, &cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("QoS_PortRemarkingCfgGet failed\n");
 		return -1;
 	}
 
 	cfg.bPCP_EgressRemarkingEnable = LTQ_FALSE;
-	ret = gsw_core_api(
-		(dp_gsw_cb)ops->gsw_qos_ops.QoS_PortRemarkingCfgSet,
-		ops, &cfg);
+	ret = ops->gsw_qos_ops.QoS_PortRemarkingCfgSet(ops, &cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("QoS_PortRemarkingCfgSet failed\n");
 		return -1;
@@ -852,13 +803,14 @@ int dp_set_gsw_pmapper_32(int inst, int bport, int lport,
 {
 	GSW_BRIDGE_portConfig_t bp_cfg = {0};
 	struct core_ops *gsw_handle;
+	struct brdgport_ops *gsw_bp;
 	GSW_return_t ret;
 	int i, index;
 	int ctp;
 	struct pmac_port_info *port_info = get_dp_port_info(inst, lport);
 
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
-
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	DP_DEBUG(DP_DBG_FLAG_DBG,
 		 "set pmapper bport %d inst %d lport %d\n",
 		 bport, inst, lport);
@@ -903,9 +855,7 @@ int dp_set_gsw_pmapper_32(int inst, int bport, int lport,
 		 "call switch api mode %d enable %d eMask 0x%x\n",
 		 bp_cfg.ePmapperMappingMode, bp_cfg.bPmapperEnable,
 		 bp_cfg.eMask);
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigSet,
-		gsw_handle, &bp_cfg);
+	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("fail in setting pmapper\r\n");
 		return -1;
@@ -918,6 +868,7 @@ int dp_get_gsw_pmapper_32(int inst, int bport, int lport,
 {
 	GSW_BRIDGE_portConfig_t bp_cfg = {0};
 	struct core_ops *gsw_handle;
+	struct brdgport_ops *gsw_bp;
 	GSW_return_t ret;
 	int i, index;
 	struct hal_priv *priv;
@@ -926,7 +877,7 @@ int dp_get_gsw_pmapper_32(int inst, int bport, int lport,
 
 	priv = (struct hal_priv *)dp_port_prop[inst].priv_hal;
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
-
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	DP_DEBUG(DP_DBG_FLAG_DBG,
 		 "get bport %d inst %d lport %d\n",
 		 bport, inst, lport);
@@ -934,9 +885,7 @@ int dp_get_gsw_pmapper_32(int inst, int bport, int lport,
 	bp_cfg.nDestLogicalPortId = lport;
 	bp_cfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_CTP_MAPPING;
 
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
-		gsw_handle, &bp_cfg);
+	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("fail in getting pmapper\r\n");
 		return -1;
@@ -982,6 +931,7 @@ int dp_get_gsw_pmapper_32(int inst, int bport, int lport,
 int dp_meter_alloc_32(int inst, int *meterid, int flag)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_meterCfg_t meter_cfg = {0};
 	GSW_return_t ret;
 
@@ -998,10 +948,10 @@ int dp_meter_alloc_32(int inst, int *meterid, int flag)
 		PR_ERR("gsw_handle NULL\n");
 		return -1;
 	}
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	if (flag == DP_F_DEREGISTER && *meterid >= 0) {
 		meter_cfg.nMeterId = *meterid;
-		ret = GSW_CORE_API(gsw_handle, gsw_qos_ops.QOS_MeterAlloc,
-				   &meter_cfg);
+		ret = gsw_qos->QOS_MeterAlloc(gsw_handle, &meter_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("Meter dealloc failed: %d\n", ret);
 			return -1;
@@ -1009,8 +959,7 @@ int dp_meter_alloc_32(int inst, int *meterid, int flag)
 		return 0;
 	}
 	memset(&meter_cfg, 0, sizeof(meter_cfg));
-	ret = GSW_CORE_API(gsw_handle, gsw_qos_ops.QOS_MeterAlloc,
-			   &meter_cfg);
+	ret = gsw_qos->QOS_MeterAlloc(gsw_handle, &meter_cfg);
 	if ((ret != GSW_statusOk) || (meter_cfg.nMeterId < 0)) {
 		PR_ERR("Failed to get a meter alloc\n");
 		*meterid = -1;
@@ -1024,6 +973,8 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 			   int flag, struct dp_meter_subif *mtr_subif)
 {
 	struct core_ops *gsw_handle;
+	struct ctp_ops *gsw_ctp;
+	struct brdgport_ops *gsw_bp;
 	GSW_BRIDGE_portConfig_t bp_cfg;
 	GSW_CTP_portConfig_t ctp_cfg;
 	GSW_return_t ret;
@@ -1038,6 +989,8 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 	gsw_handle = dp_port_prop[mtr_subif->inst].ops[GSWIP_L];
 	if (!gsw_handle)
 		return -1;
+	gsw_ctp = &gsw_handle->gsw_ctp_ops;
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	if (flag & DP_METER_ATTACH_CTP) {/* CTP port Flag */
 		if (mtr_subif->subif.flag_pmapper) {
 			PR_ERR("can't use CTP,pmapper is enable\n");
@@ -1049,8 +1002,7 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 		ctp_cfg.nSubIfIdGroup  = GET_VAP(mtr_subif->subif.subif,
 						 port_info->vap_offset,
 						 port_info->vap_mask);
-		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigGet,
-				   &ctp_cfg);
+		ret = gsw_ctp->CTP_PortConfigGet(gsw_handle, &ctp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("PortConfigGet API failed :%d\n", ret);
 			return -1;
@@ -1072,8 +1024,7 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 		} else {
 			return -1;
 		}
-		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigSet,
-				   &ctp_cfg);
+		ret = gsw_ctp->CTP_PortConfigSet(gsw_handle, &ctp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("PortConfigSet API failed :%d\n", ret);
 			return -1;
@@ -1085,9 +1036,7 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 			return -1;
 		}
 		bp_cfg.nBridgePortId = mtr_subif->subif.bport;
-		ret = GSW_CORE_API(gsw_handle,
-				   gsw_brdgport_ops.BridgePort_ConfigGet,
-				   &bp_cfg);
+		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &bp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("BridgePort_ConfigGet API failed :%d\n", ret);
 			return -1;
@@ -1103,9 +1052,7 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 			PR_ERR(" invalid color mark dir\n");
 			return -1;
 		}
-		ret = GSW_CORE_API(gsw_handle,
-				   gsw_brdgport_ops.BridgePort_ConfigSet,
-				   &bp_cfg);
+		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &bp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("BridgePort_ConfigSet API failed :%d\n", ret);
 			return -1;
@@ -1118,6 +1065,11 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		    int flag, struct dp_meter_subif *mtr_subif)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
+	struct tflow_ops *gsw_tflow;
+	struct ctp_ops *gsw_ctp;
+	struct brdgport_ops *gsw_bp;
+	struct brdg_ops *gsw_brdg;
 	GSW_QoS_meterCfg_t meter_cfg;
 	GSW_BRIDGE_portConfig_t *bp_cfg = NULL;
 	GSW_PCE_rule_t *pce_rule = NULL;
@@ -1133,7 +1085,11 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	gsw_handle = dp_port_prop[mtr_subif->inst].ops[GSWIP_L];
 	if (!gsw_handle)
 		return -1;
-
+	gsw_qos = &gsw_handle->gsw_qos_ops;
+	gsw_tflow = &gsw_handle->gsw_tflow_ops;
+	gsw_ctp = &gsw_handle->gsw_ctp_ops;
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
+	gsw_brdg = &gsw_handle->gsw_brdg_ops;
 	if (flag & DP_COL_MARKING)
 		return dp_set_col_mark(dev, meter, flag, mtr_subif);
 	memset(&meter_cfg, 0, sizeof(GSW_QoS_meterCfg_t));
@@ -1152,8 +1108,7 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	}
 	meter_cfg.nMeterId = meter->meter_id;
 	meter_cfg.nColourBlindMode = meter->col_mode;
-	ret = GSW_CORE_API(gsw_handle, gsw_qos_ops.QoS_MeterCfgSet,
-			   &meter_cfg);
+	ret = gsw_qos->QoS_MeterCfgSet(gsw_handle, &meter_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("MeterCfgSet API failed:%d\n", ret);
 		return -1;
@@ -1172,8 +1127,7 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		/* action setting */
 		pce_rule->action.eMeterAction = GSW_PCE_ACTION_METER_1;
 		pce_rule->action.nMeterId =  meter->meter_id;
-		ret = GSW_CORE_API(gsw_handle, gsw_tflow_ops.TFLOW_PceRuleWrite,
-				   pce_rule);
+		ret = gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, pce_rule);
 		if (ret != GSW_statusOk) {
 			PR_ERR("PceRule Write API failed :%d\n", ret);
 			goto err;
@@ -1193,9 +1147,8 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			bret = -1;
 			goto err;
 		}
-		port_info =
-		get_dp_port_info(mtr_subif->subif.inst,
-				 mtr_subif->subif.port_id);
+		port_info = get_dp_port_info(mtr_subif->subif.inst,
+					     mtr_subif->subif.port_id);
 		if (!port_info) {
 			PR_ERR(" port_info is NULL\n");
 			bret = -1;
@@ -1205,8 +1158,7 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		ctp_cfg->nSubIfIdGroup  = GET_VAP(mtr_subif->subif.subif,
 						 port_info->vap_offset,
 						 port_info->vap_mask);
-		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigGet,
-				   ctp_cfg);
+		ret = gsw_ctp->CTP_PortConfigGet(gsw_handle, ctp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("PortConfigGet API failed :%d\n", ret);
 			bret = -1;
@@ -1224,8 +1176,7 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			PR_ERR(" invalid meter dir\n");
 			return -1;
 		}
-		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigSet,
-				   ctp_cfg);
+		ret = gsw_ctp->CTP_PortConfigSet(gsw_handle, ctp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("PortConfigSet API failed :%d\n", ret);
 			bret = -1;
@@ -1245,9 +1196,7 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			goto err;
 		}
 		bp_cfg->nBridgePortId = mtr_subif->subif.bport;
-		ret = GSW_CORE_API(gsw_handle,
-				   gsw_brdgport_ops.BridgePort_ConfigGet,
-				   bp_cfg);
+		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, bp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("BridgePort_ConfigGet API failed :%d\n", ret);
 			bret = -1;
@@ -1281,9 +1230,7 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			PR_ERR(" invalid meter dir\n");
 			return -1;
 		}
-		ret = GSW_CORE_API(gsw_handle,
-				   gsw_brdgport_ops.BridgePort_ConfigSet,
-				   bp_cfg);
+		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, bp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("BridgePort_ConfigSet API failed :%d\n", ret);
 			bret = -1;
@@ -1297,9 +1244,7 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			goto err;
 		}
 		br_cfg->nBridgeId = mtr_subif->fid;
-		ret = GSW_CORE_API(gsw_handle,
-				   gsw_brdg_ops.Bridge_ConfigGet,
-				   br_cfg);
+		ret = gsw_brdg->Bridge_ConfigGet(gsw_handle, br_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("Bridge_ConfigGet API failed :%d\n", ret);
 			bret = -1;
@@ -1323,8 +1268,7 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			bret = -1;
 			goto err;
 		}
-		ret = GSW_CORE_API(gsw_handle, gsw_brdg_ops.Bridge_ConfigSet,
-				   br_cfg);
+		ret = gsw_brdg->Bridge_ConfigSet(gsw_handle, br_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("Bridge_ConfigSet API failed :%d\n", ret);
 			bret = -1;
@@ -1343,6 +1287,10 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		    int flag, struct dp_meter_subif *mtr_subif)
 {
 	struct core_ops *gsw_handle;
+	struct tflow_ops *gsw_tflow;
+	struct ctp_ops *gsw_ctp;
+	struct brdgport_ops *gsw_bp;
+	struct brdg_ops *gsw_brdg;
 	GSW_BRIDGE_portConfig_t *bp_cfg = NULL;
 	GSW_PCE_rule_t *pce_rule = NULL;
 	GSW_CTP_portConfig_t *ctp_cfg = NULL;
@@ -1357,7 +1305,10 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	gsw_handle = dp_port_prop[mtr_subif->inst].ops[GSWIP_L];
 	if (!gsw_handle)
 		return -1;
-
+	gsw_tflow = &gsw_handle->gsw_tflow_ops;
+	gsw_ctp = &gsw_handle->gsw_ctp_ops;
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
+	gsw_brdg = &gsw_handle->gsw_brdg_ops;
 	if (meter->dir & DP_METER_ATTACH_PCE) {
 		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_ATOMIC);
 		if (!pce_rule) {
@@ -1368,8 +1319,7 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		/* pattern setting */
 		pce_rule->pattern.nIndex = meter->dp_pce.pce_idx;
 		pce_rule->pattern.bEnable = 0;
-		ret = GSW_CORE_API(gsw_handle, gsw_tflow_ops.TFLOW_PceRuleWrite,
-				   pce_rule);
+		ret = gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, pce_rule);
 		if (ret != GSW_statusOk) {
 			PR_ERR("PceRule Write API failed :%d\n", ret);
 			bret = -1;
@@ -1405,8 +1355,7 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			ctp_cfg->nEgressTrafficMeterId =  meter->meter_id;
 		else if (meter->dir == DP_DIR_INGRESS)
 			ctp_cfg->nIngressTrafficMeterId =  meter->meter_id;
-		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigGet,
-				   ctp_cfg);
+		ret = gsw_ctp->CTP_PortConfigGet(gsw_handle, ctp_cfg);
 		if (ret != GSW_statusOk) {
 			bret = -1;
 			goto err;
@@ -1418,8 +1367,7 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			ctp_cfg->eMask = GSW_CTP_PORT_CONFIG_INGRESS_METER;
 			ctp_cfg->bIngressMeteringEnable = 0;
 		}
-		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigSet,
-				   ctp_cfg);
+		ret = gsw_ctp->CTP_PortConfigSet(gsw_handle, ctp_cfg);
 		if (ret != GSW_statusOk) {
 			bret = -1;
 			goto err;
@@ -1438,9 +1386,7 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			goto err;
 		}
 		bp_cfg->nBridgePortId = mtr_subif->subif.bport;
-		ret = GSW_CORE_API(gsw_handle,
-				   gsw_brdgport_ops.BridgePort_ConfigGet,
-				   bp_cfg);
+		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, bp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("BridgePort_ConfigGet API failed\n");
 			bret = -1;
@@ -1470,9 +1416,7 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 				GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_METER;
 			bp_cfg->bIngressMeteringEnable = 0;
 		}
-		ret = GSW_CORE_API(gsw_handle,
-				   gsw_brdgport_ops.BridgePort_ConfigSet,
-				   bp_cfg);
+		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, bp_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("BridgePort_ConfigSet API failed\n");
 			bret = -1;
@@ -1487,8 +1431,7 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			goto err;
 		}
 		br_cfg->nBridgeId = mtr_subif->fid;
-		ret = GSW_CORE_API(gsw_handle, gsw_brdg_ops.Bridge_ConfigGet,
-				   br_cfg);
+		ret = gsw_brdg->Bridge_ConfigGet(gsw_handle, br_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("Bridge_ConfigGet API failed :%d\n", ret);
 			bret = -1;
@@ -1512,8 +1455,7 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			bret = -1;
 			goto err;
 		}
-		ret = GSW_CORE_API(gsw_handle, gsw_brdg_ops.Bridge_ConfigSet,
-				   br_cfg);
+		ret = gsw_brdg->Bridge_ConfigSet(gsw_handle, br_cfg);
 		if (ret != GSW_statusOk) {
 			PR_ERR("Bridge_ConfigSet API failed :%d\n", ret);
 			bret = -1;
@@ -1557,9 +1499,8 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 		gpid_base = get_dp_port_info(inst, ep)->gpid_base;
 		gpid_num = get_dp_port_info(inst, ep)->gpid_num;
 
-		if (gsw_core_api(
-			(dp_gsw_cb)gsw_gpid->LpidToGpid_AssignmentSet,
-			gsw_handle, &lp_gp_assign) != 0) {
+		if (gsw_gpid->LpidToGpid_AssignmentSet(gsw_handle,
+						       &lp_gp_assign)) {
 			PR_ERR("Fail to assign Lpid->Gpid table %d in GSWIP\n",
 			       ep);
 			return DP_FAILURE;
@@ -1568,9 +1509,8 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 		gp_lp_assign.nLogicalPortId = ep;
 		gp_lp_assign.nGlobalPortId = gpid_base;
 
-		if (gsw_core_api(
-			(dp_gsw_cb)gsw_gpid->GpidToLpid_AssignmentSet,
-			gsw_handle, &gp_lp_assign) != 0) {
+		if (gsw_gpid->GpidToLpid_AssignmentSet(gsw_handle,
+						       &gp_lp_assign)) {
 			PR_ERR("Fail to assign GPID->LPID table %d in GSWIP\n",
 			       ep);
 			return DP_FAILURE;
@@ -1602,9 +1542,7 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 	lp_gp_assign.nFirstGlobalPortId = gpid_base;
 	lp_gp_assign.nNumberOfGlobalPort = gpid_num;
 
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_gpid->LpidToGpid_AssignmentSet,
-		gsw_handle, &lp_gp_assign) != 0) {
+	if (gsw_gpid->LpidToGpid_AssignmentSet(gsw_handle, &lp_gp_assign)) {
 #if 0
 		PR_ERR("Fail to assign Lpid->Gpid table %d in GSWIP\n",
 		       ep);
@@ -1617,9 +1555,7 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 	gp_lp_assign.nLogicalPortId = ep;
 	gp_lp_assign.nGlobalPortId = gpid_base;
 
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_gpid->GpidToLpid_AssignmentSet,
-		gsw_handle, &gp_lp_assign) != 0) {
+	if (gsw_gpid->GpidToLpid_AssignmentSet(gsw_handle, &gp_lp_assign)) {
 		PR_ERR("Fail to assign Gpid->Lpid table %d in GSWIP\n",
 		       ep);
 #if 0
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_misc.c b/drivers/net/datapath/dpm/gswip32/datapath_misc.c
index 4930874c32cb..f24a17a20c34 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_misc.c
@@ -512,9 +512,11 @@ int alloc_q_to_port_32(struct ppv4_q_sch_port *info, u32 flag)
 static int dp_gswip_remark_8P0D_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorRemarkingEntry_t color_remark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_remark.eMode = mode;
 	color_remark.nVal[0] = 0;
 	color_remark.nVal[1] = 2;
@@ -532,9 +534,7 @@ static int dp_gswip_remark_8P0D_set(int mode, int inst)
 	color_remark.nVal[13] = 11;
 	color_remark.nVal[14] = 13;
 	color_remark.nVal[15] = 15;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorReMarkingTableSet,
-		gsw_handle, &color_remark)) {
+	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
 		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -544,9 +544,11 @@ static int dp_gswip_remark_8P0D_set(int mode, int inst)
 static int dp_gswip_remark_7P1D_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorRemarkingEntry_t color_remark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_remark.eMode = mode;
 	color_remark.nVal[0] = 0;
 	color_remark.nVal[1] = 2;
@@ -564,9 +566,7 @@ static int dp_gswip_remark_7P1D_set(int mode, int inst)
 	color_remark.nVal[13] = 9;
 	color_remark.nVal[14] = 13;
 	color_remark.nVal[15] = 15;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorReMarkingTableSet,
-		gsw_handle, &color_remark)) {
+	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
 		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -576,9 +576,11 @@ static int dp_gswip_remark_7P1D_set(int mode, int inst)
 static int dp_gswip_remark_6P2D_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorRemarkingEntry_t color_remark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_remark.eMode = mode;
 	color_remark.nVal[0] = 0;
 	color_remark.nVal[1] = 2;
@@ -596,9 +598,7 @@ static int dp_gswip_remark_6P2D_set(int mode, int inst)
 	color_remark.nVal[13] = 9;
 	color_remark.nVal[14] = 13;
 	color_remark.nVal[15] = 15;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorReMarkingTableSet,
-		gsw_handle, &color_remark)) {
+	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
 		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -608,9 +608,11 @@ static int dp_gswip_remark_6P2D_set(int mode, int inst)
 static int dp_gswip_remark_5P3D_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorRemarkingEntry_t color_remark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_remark.eMode = mode;
 	color_remark.nVal[0] = 2;
 	color_remark.nVal[1] = 2;
@@ -628,9 +630,7 @@ static int dp_gswip_remark_5P3D_set(int mode, int inst)
 	color_remark.nVal[13] = 9;
 	color_remark.nVal[14] = 13;
 	color_remark.nVal[15] = 15;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorReMarkingTableSet,
-		gsw_handle, &color_remark)) {
+	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
 		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -640,9 +640,11 @@ static int dp_gswip_remark_5P3D_set(int mode, int inst)
 static int dp_gswip_remark_dscp_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorRemarkingEntry_t color_remark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_remark.eMode = mode;
 	color_remark.nVal[0] = 10;
 	color_remark.nVal[1] = 18;
@@ -660,9 +662,7 @@ static int dp_gswip_remark_dscp_set(int mode, int inst)
 	color_remark.nVal[13] = 36;
 	color_remark.nVal[14] = 36;
 	color_remark.nVal[15] = 36;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorReMarkingTableSet,
-		gsw_handle, &color_remark)) {
+	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
 		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -672,9 +672,11 @@ static int dp_gswip_remark_dscp_set(int mode, int inst)
 static int dp_gswip_color_dscp_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorMarkingEntry_t color_mark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_mark.eMode = mode;
 	color_mark.nPriority[0] = PRIO0;
 	color_mark.nPriority[1] = PRIO0;
@@ -804,9 +806,7 @@ static int dp_gswip_color_dscp_set(int mode, int inst)
 	color_mark.nColor[61] = GSW_DROP_PRECEDENCE_YELLOW;
 	color_mark.nColor[62] = GSW_DROP_PRECEDENCE_YELLOW;
 	color_mark.nColor[63] = GSW_DROP_PRECEDENCE_YELLOW;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorMarkingTableSet,
-		gsw_handle, &color_mark)) {
+	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
 		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -816,9 +816,11 @@ static int dp_gswip_color_dscp_set(int mode, int inst)
 static int dp_gswip_color_5P3D_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorMarkingEntry_t color_mark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_mark.eMode = mode;
 	color_mark.nPriority[0] = PRIO0;
 	color_mark.nPriority[1] = PRIO0;
@@ -852,9 +854,7 @@ static int dp_gswip_color_5P3D_set(int mode, int inst)
 	color_mark.nColor[13] = GSW_DROP_PRECEDENCE_YELLOW;
 	color_mark.nColor[14] = GSW_DROP_PRECEDENCE_GREEN;
 	color_mark.nColor[15] = GSW_DROP_PRECEDENCE_YELLOW;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorMarkingTableSet,
-		gsw_handle, &color_mark)) {
+	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
 		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -864,9 +864,11 @@ static int dp_gswip_color_5P3D_set(int mode, int inst)
 static int dp_gswip_color_6P2D_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorMarkingEntry_t color_mark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_mark.eMode = mode;
 	color_mark.nPriority[0] = PRIO0;
 	color_mark.nPriority[1] = PRIO0;
@@ -900,9 +902,7 @@ static int dp_gswip_color_6P2D_set(int mode, int inst)
 	color_mark.nColor[13] = GSW_DROP_PRECEDENCE_YELLOW;
 	color_mark.nColor[14] = GSW_DROP_PRECEDENCE_GREEN;
 	color_mark.nColor[15] = GSW_DROP_PRECEDENCE_YELLOW;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorMarkingTableSet,
-		gsw_handle, &color_mark)) {
+	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
 		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -912,9 +912,11 @@ static int dp_gswip_color_6P2D_set(int mode, int inst)
 static int dp_gswip_color_7P1D_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorMarkingEntry_t color_mark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_mark.eMode = mode;
 	color_mark.nPriority[0] = PRIO0;
 	color_mark.nPriority[1] = PRIO0;
@@ -948,9 +950,7 @@ static int dp_gswip_color_7P1D_set(int mode, int inst)
 	color_mark.nColor[13] = GSW_DROP_PRECEDENCE_YELLOW;
 	color_mark.nColor[14] = GSW_DROP_PRECEDENCE_GREEN;
 	color_mark.nColor[15] = GSW_DROP_PRECEDENCE_YELLOW;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorMarkingTableSet,
-		gsw_handle, &color_mark)) {
+	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
 		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -960,9 +960,11 @@ static int dp_gswip_color_7P1D_set(int mode, int inst)
 static int dp_gswip_color_8P0D_set(int mode, int inst)
 {
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	GSW_QoS_colorMarkingEntry_t color_mark = {0};
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_qos = &gsw_handle->gsw_qos_ops;
 	color_mark.eMode = mode;
 	color_mark.nPriority[0] = PRIO0;
 	color_mark.nPriority[1] = PRIO0;
@@ -996,9 +998,7 @@ static int dp_gswip_color_8P0D_set(int mode, int inst)
 	color_mark.nColor[13] = GSW_DROP_PRECEDENCE_YELLOW;
 	color_mark.nColor[14] = GSW_DROP_PRECEDENCE_GREEN;
 	color_mark.nColor[15] = GSW_DROP_PRECEDENCE_YELLOW;
-	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_qos_ops.QOS_ColorMarkingTableSet,
-		gsw_handle, &color_mark)) {
+	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
 		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
@@ -1314,14 +1314,12 @@ static int dp_platform_set(int inst, u32 flag)
 #endif
 		/*disable egress VLAN modification for CPU port*/
 		port_remark.nPortId = 0;
-		if (gsw_core_api((dp_gsw_cb)qos->QoS_PortRemarkingCfgGet,
-				 gsw_handle, &port_remark)) {
+		if (qos->QoS_PortRemarkingCfgGet(gsw_handle, &port_remark)) {
 			PR_ERR("GSW_QOS_PORT_REMARKING_CFG_GET failed\n");
 			return -1;
 		}
 		port_remark.bPCP_EgressRemarkingEnable = 0;
-		if (gsw_core_api((dp_gsw_cb)qos->QoS_PortRemarkingCfgGet,
-				 gsw_handle, &port_remark)) {
+		if (qos->QoS_PortRemarkingCfgGet(gsw_handle, &port_remark)) {
 			PR_ERR("GSW_QOS_PORT_REMARKING_CFG_GET failed\n");
 			return -1;
 		}
@@ -1369,15 +1367,16 @@ static int dp_platform_set(int inst, u32 flag)
 static int pon_config(int inst, int ep, struct dp_port_data *data, u32 flags)
 {
 	struct core_ops *gsw_handle;
+	struct common_ops *gsw_com;
 	GSW_return_t ret;
 	struct mac_ops *mac_ops;
 	GSW_CPU_PortCfg_t cpu_port_cfg;
 
 	mac_ops = dp_port_prop[inst].mac_ops[ep];
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
+	gsw_com = &gsw_handle->gsw_common_ops;
 	memset((void *)&cpu_port_cfg, 0x00, sizeof(cpu_port_cfg));
-	ret = gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.CPU_PortCfgGet,
-			   gsw_handle, &cpu_port_cfg);
+	ret = gsw_com->CPU_PortCfgGet(gsw_handle, &cpu_port_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("fail in getting CPU port config\r\n");
 		return -1;
@@ -1386,8 +1385,7 @@ static int pon_config(int inst, int ep, struct dp_port_data *data, u32 flags)
 	cpu_port_cfg.nPortId = ep;
 	cpu_port_cfg.bSpecialTagIngress = 1;
 	cpu_port_cfg.bSpecialTagEgress = 1;
-	ret = gsw_core_api((dp_gsw_cb)gsw_handle->gsw_common_ops.CPU_PortCfgSet,
-			   gsw_handle, &cpu_port_cfg);
+	ret = gsw_com->CPU_PortCfgSet(gsw_handle, &cpu_port_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Fail in configuring CPU port\n");
 		return -1;
@@ -1536,8 +1534,7 @@ static int set_ctp_bp(int inst, int ctp, int portid, int bp)
 	tmp.nSubIfIdGroup = ctp;
 	tmp.eMask = GSW_CTP_PORT_CONFIG_MASK_BRIDGE_PORT_ID;
 	tmp.nBridgePortId = bp;
-	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_ctp_ops.CTP_PortConfigSet,
-			 gsw_handle, &tmp) != 0) {
+	if (gsw_handle->gsw_ctp_ops.CTP_PortConfigSet(gsw_handle, &tmp)) {
 		PR_ERR("Failed to CTP(%d)'s bridge port=%d for ep=%d\n",
 		       ctp, bp, portid);
 		return -1;
@@ -1556,8 +1553,7 @@ static int reset_ctp_bp(int inst, int ctp, int portid, int bp)
 	tmp.nLogicalPortId = portid;
 	tmp.nSubIfIdGroup = ctp;
 	tmp.nBridgePortId = bp;
-	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_ctp_ops.CTP_PortConfigReset,
-			 gsw_handle, &tmp) != 0) {
+	if (gsw_handle->gsw_ctp_ops.CTP_PortConfigReset(gsw_handle, &tmp)) {
 		PR_ERR("Failed to reset CTP(%d)'s bridge port=%d for ep=%d\n",
 		       ctp, bp, portid);
 		return -1;
@@ -2027,6 +2023,7 @@ static int dp_ctp_tc_map_set_32(struct dp_tc_cfg *tc, int flag,
 				struct dp_meter_subif *mtr_subif)
 {
 	struct core_ops *gsw_handle;
+	struct ctp_ops *gsw_ctp;
 	GSW_CTP_portConfig_t ctp_tc_cfg;
 
 	memset(&ctp_tc_cfg, 0, sizeof(ctp_tc_cfg));
@@ -2041,10 +2038,10 @@ static int dp_ctp_tc_map_set_32(struct dp_tc_cfg *tc, int flag,
 		return -1;
 	}
 	gsw_handle = dp_port_prop[mtr_subif->inst].ops[GSWIP_L];
+	gsw_ctp = &gsw_handle->gsw_ctp_ops;
 	ctp_tc_cfg.nLogicalPortId = mtr_subif->subif.port_id;
 	ctp_tc_cfg.nSubIfIdGroup = mtr_subif->subif.subif;
-	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_ctp_ops.CTP_PortConfigGet,
-			 gsw_handle, &ctp_tc_cfg) != 0) {
+	if (gsw_ctp->CTP_PortConfigGet(gsw_handle, &ctp_tc_cfg)) {
 		PR_ERR("Failed to get CTP info for ep=%d subif=%d\n",
 		       mtr_subif->subif.port_id, mtr_subif->subif.subif);
 		return -1;
@@ -2056,8 +2053,7 @@ static int dp_ctp_tc_map_set_32(struct dp_tc_cfg *tc, int flag,
 	else
 		ctp_tc_cfg.bForcedTrafficClass = 0;
 
-	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_ctp_ops.CTP_PortConfigSet,
-			 gsw_handle, &ctp_tc_cfg) != 0) {
+	if (gsw_ctp->CTP_PortConfigSet(gsw_handle, &ctp_tc_cfg)) {
 		PR_ERR("CTP tc set fail for ep=%d subif=%d tc=%d force=%d\n",
 		       mtr_subif->subif.port_id, mtr_subif->subif.subif,
 		       tc->tc, tc->force);
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_misc.h b/drivers/net/datapath/dpm/gswip32/datapath_misc.h
index 9126ba8f440c..5f3520065082 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_misc.h
+++ b/drivers/net/datapath/dpm/gswip32/datapath_misc.h
@@ -212,11 +212,6 @@ void set_chksum(struct pmac_tx_hdr *pmac, u32 tcp_type,
 
 int dp_lan_wan_bridging(int port_id, struct sk_buff *skb);
 
-static inline GSW_return_t gsw_core_api(dp_gsw_cb func, void *ops, void *param)
-{
-	return func(ops, param);
-}
-
 static inline char *parser_flag_str(u8 f)
 {
 	if (f == DP_PARSER_F_DISABLE)
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_proc.c b/drivers/net/datapath/dpm/gswip32/datapath_proc.c
index 9bcb1da217cb..8240cd145596 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_proc.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_proc.c
@@ -55,11 +55,13 @@ ssize_t proc_parser_write(struct file *file, const char *buf,
 	static GSW_PCE_rule_t pce;
 	int inst = 0;
 	struct core_ops *gsw_handle;
+	struct tflow_ops *gsw_tflow;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 	memset(&pce, 0, sizeof(pce));
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
+	gsw_tflow = &gsw_handle->gsw_tflow_ops;
 	len = (sizeof(str) > count) ? count : sizeof(str) - 1;
 	len -= copy_from_user(str, buf, len);
 	str[len] = 0;
@@ -204,9 +206,7 @@ ssize_t proc_parser_write(struct file *file, const char *buf,
 		pce.action.bRMON_Action = 1;
 		pce.action.nRMON_Id = 0;	/*RMON_UDP_CNTR; */
 
-		if (gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_tflow_ops.TFLOW_PceRuleWrite,
-			gsw_handle, &pce)) {
+		if (gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, &pce)) {
 			PR_ERR("PCE rule add fail: GSW_PCE_RULE_WRITE\n");
 			return count;
 		}
@@ -217,9 +217,7 @@ ssize_t proc_parser_write(struct file *file, const char *buf,
 		pce_rule_id = dp_atoi(param_list[1]);
 		pce.pattern.nIndex = pce_rule_id;
 		pce.pattern.bEnable = 0;
-		if (gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_tflow_ops.TFLOW_PceRuleWrite,
-			gsw_handle, &pce)) {
+		if (gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, &pce)) {
 			PR_ERR("PCE rule add fail:GSW_PCE_RULE_WRITE\n");
 			return count;
 		}
@@ -242,17 +240,17 @@ char *get_bp_member_string_32(int inst, u16 bp, char *buf)
 	GSW_BRIDGE_portConfig_t bp_cfg;
 	int i, ret;
 	struct core_ops *gsw_handle;
+	struct brdgport_ops *gsw_bp;
 
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	if (!buf)
 		return NULL;
 	buf[0] = 0;
 	bp_cfg.nBridgePortId = bp;
 	bp_cfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP |
 		GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID;
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
-		gsw_handle, &bp_cfg);
+	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Failed to get bridge port's member for bridgeport=%d\n",
 		       bp_cfg.nBridgePortId);
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_switchdev.c b/drivers/net/datapath/dpm/gswip32/datapath_switchdev.c
index a119baed4b30..4a0e8c1ee3c0 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_switchdev.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_switchdev.c
@@ -22,8 +22,7 @@ int dp_swdev_alloc_bridge_id_32(int inst)
 
 	gsw_handle = dp_port_prop[inst].ops[0];
 	memset(&br, 0, sizeof(br));
-	ret = gsw_core_api((dp_gsw_cb)gsw_handle->gsw_brdg_ops.Bridge_Alloc,
-			   gsw_handle, &br);
+	ret = gsw_handle->gsw_brdg_ops.Bridge_Alloc(gsw_handle, &br);
 	if ((ret != GSW_statusOk) ||
 	    (br.nBridgeId < 0)) {
 		PR_ERR("Failed to get a FID\n");
@@ -50,9 +49,7 @@ int dp_swdev_bridge_port_cfg_set_32(struct br_info *br_item,
 	DP_DEBUG(DP_DBG_FLAG_SWDEV, "Set current BP=%d inst:%d\n",
 		 brportcfg.nBridgePortId, inst);
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
-		gsw_handle, &brportcfg);
+	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("fail in getting bridge port config\r\n");
 		return -1;
@@ -66,46 +63,35 @@ int dp_swdev_bridge_port_cfg_set_32(struct br_info *br_item,
 	brportcfg.nBridgeId = br_item->fid;
 	brportcfg.nBridgePortId = bport;
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
-		GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
-		gsw_handle, &brportcfg);
+			  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
+	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Fail in allocating/configuring bridge port\n");
 		return -1;
 	}
 	/* To set other member portmap with current bridge port map */
 	list_for_each_entry(bport_list, &br_item->bp_list, list) {
-		if (bport_list->portid != bport) {
-			memset(&brportcfg, 0,
-			       sizeof(GSW_BRIDGE_portConfig_t));
-			brportcfg.nBridgePortId = bport_list->portid;
-			DP_DEBUG(DP_DBG_FLAG_SWDEV,
-				 "Set other BP=%d inst:%d\n",
-				 brportcfg.nBridgePortId, inst);
-			brportcfg.eMask =
-				GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
-				gsw_handle, &brportcfg);
-			if (ret != GSW_statusOk) {
-				PR_ERR
-					("fail in getting br port config\r\n");
-				return -1;
-			}
-			SET_BP_MAP(brportcfg.nBridgePortMap, bport);
-			brportcfg.nBridgeId = br_item->fid;
-			brportcfg.nBridgePortId = bport_list->portid;
-			brportcfg.eMask =
-				GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
-				GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
-				gsw_handle, &brportcfg);
-			if (ret != GSW_statusOk) {
-				PR_ERR("Fail alloc/cfg bridge port\n");
-				return -1;
-			}
+		if (bport_list->portid == bport)
+			continue;
+		memset(&brportcfg, 0, sizeof(GSW_BRIDGE_portConfig_t));
+		brportcfg.nBridgePortId = bport_list->portid;
+		DP_DEBUG(DP_DBG_FLAG_SWDEV, "Set other BP=%d inst:%d\n",
+			 brportcfg.nBridgePortId, inst);
+		brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
+		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &brportcfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("fail in getting br port config\r\n");
+			return -1;
+		}
+		SET_BP_MAP(brportcfg.nBridgePortMap, bport);
+		brportcfg.nBridgeId = br_item->fid;
+		brportcfg.nBridgePortId = bport_list->portid;
+		brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
+				  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
+		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &brportcfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("Fail alloc/cfg bridge port\n");
+			return -1;
 		}
 	}
 	return 0;
@@ -129,9 +115,7 @@ int dp_swdev_bridge_port_cfg_reset_32(struct br_info *br_item,
 		 brportcfg.nBridgePortId, inst);
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	/*Reset other members from current bport map*/
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
-		gsw_handle, &brportcfg);
+	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
 		/* Note: here may fail if this device is not removed from
 		 * linux bridge via brctl delif but user try to un-regiser
@@ -167,9 +151,7 @@ int dp_swdev_bridge_port_cfg_reset_32(struct br_info *br_item,
 	brportcfg.nBridgePortId = bport;
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
 			  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
-		gsw_handle, &brportcfg);
+	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Fail in configuring GSW_BRIDGE_portConfig_t in %s\r\n",
 		       __func__);
@@ -177,35 +159,28 @@ int dp_swdev_bridge_port_cfg_reset_32(struct br_info *br_item,
 	}
 	/*Reset current bp from all other bridge port's port map*/
 	list_for_each_entry(bport_list, &br_item->bp_list, list) {
-		if (bport_list->portid != bport) {
-			memset(&brportcfg, 0,
-			       sizeof(GSW_BRIDGE_portConfig_t));
-			brportcfg.nBridgePortId = bport_list->portid;
-			DP_DEBUG(DP_DBG_FLAG_SWDEV,
-				 "reset current BP from other BP=%d inst:%d\n",
-				 brportcfg.nBridgePortId, inst);
-			brportcfg.eMask =
-				 GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP |
-				 GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID;
-			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
-				gsw_handle, &brportcfg);
-			if (ret != GSW_statusOk) {
-				PR_ERR("failed getting br port cfg\r\n");
-				return -1;
-			}
-			UNSET_BP_MAP(brportcfg.nBridgePortMap, bport);
-			brportcfg.nBridgePortId = bport_list->portid;
-			brportcfg.eMask =
-				 GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
-				 GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
-			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
-				gsw_handle, &brportcfg);
-			if (ret != GSW_statusOk) {
-				PR_ERR("Fail alloc/cfg br port\n");
-				return -1;
-			}
+		if (bport_list->portid == bport)
+			continue;
+		memset(&brportcfg, 0, sizeof(GSW_BRIDGE_portConfig_t));
+		brportcfg.nBridgePortId = bport_list->portid;
+		DP_DEBUG(DP_DBG_FLAG_SWDEV,
+			 "reset current BP from other BP=%d inst:%d\n",
+			 brportcfg.nBridgePortId, inst);
+		brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP |
+				  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID;
+		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &brportcfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("failed getting br port cfg\r\n");
+			return -1;
+		}
+		UNSET_BP_MAP(brportcfg.nBridgePortMap, bport);
+		brportcfg.nBridgePortId = bport_list->portid;
+		brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
+				  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
+		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &brportcfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("Fail alloc/cfg br port\n");
+			return -1;
 		}
 	}
 	DP_DEBUG(DP_DBG_FLAG_SWDEV, "%s success\n", __func__);
@@ -233,14 +208,11 @@ int dp_swdev_bridge_cfg_set_32(int inst, u16 fid)
 	brcfg.eForwardBroadcast = GSW_BRIDGE_FORWARD_FLOOD;
 	brcfg.eForwardUnknownMulticastNonIp = GSW_BRIDGE_FORWARD_FLOOD;
 	brcfg.eForwardUnknownUnicast = GSW_BRIDGE_FORWARD_FLOOD;
-	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdg_ops.Bridge_ConfigSet,
-		gsw_handle, &brcfg);
+	ret = gsw_handle->gsw_brdg_ops.Bridge_ConfigSet(gsw_handle, &brcfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Failed to set bridge id(%d)\n", brcfg.nBridgeId);
 		br.nBridgeId = fid;
-		gsw_core_api((dp_gsw_cb)gsw_handle->gsw_brdg_ops.Bridge_Free,
-			     gsw_handle, &br);
+		gsw_handle->gsw_brdg_ops.Bridge_Free(gsw_handle, &br);
 		return -1;
 	}
 	DP_DEBUG(DP_DBG_FLAG_SWDEV, "FID(%d) cfg success for inst %d\n",
@@ -257,8 +229,7 @@ int dp_swdev_free_brcfg_32(int inst, u16 fid)
 	gsw_handle = dp_port_prop[inst].ops[0];
 	memset(&br, 0, sizeof(br));
 	br.nBridgeId = fid;
-	ret = gsw_core_api((dp_gsw_cb)gsw_handle->gsw_brdg_ops.Bridge_Free,
-			   gsw_handle, &br);
+	ret = gsw_handle->gsw_brdg_ops.Bridge_Free(gsw_handle, &br);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Failed to free bridge id(%d)\n", br.nBridgeId);
 		return -1;
