From ade3893d9f9007a7fc4caf1bd7adf3360736fa04 Mon Sep 17 00:00:00 2001
From: Hauke Mehrtens <hauke.mehrtens@intel.com>
Date: Mon, 27 May 2019 18:55:52 +0200
Subject: [PATCH] PONRTSYS-4307: Request PTP clock in PTP driver

The PTP driver should request the PTP clock otherwise it could be
deactivated when we do not set clk_ignore_unused anymore.

The driver also sets the frequency of the clock and this frequency can
be specified in device tree, this allows it to set it to 312.5MHz in
the low power mode.
---
 .../net/ethernet/lantiq/switch-api/mac/mac_drv.c   | 42 ++++++++++++++++++++--
 1 file changed, 39 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c b/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c
index d7056477e4f2..f5a52906774d 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c
@@ -136,6 +136,7 @@ static int mac_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	int linksts = 0, duplex = 0, speed = 0;
 	char *load, *ls, *dp;
+	int ret;
 
 	gswdev->mac_dev[pdev->id] = pdev;
 
@@ -173,15 +174,21 @@ static int mac_probe(struct platform_device *pdev)
 		pdata->haps = 0;
 	}
 
-	pdata->ker_ptp_clk = devm_clk_get(dev, "ptp_clk");
+	ret = of_property_read_u32(dev->of_node, "clock-frequency",
+				   &pdata->ptp_clk);
+	if (ret < 0) {
+		pdata->ptp_clk = 500000000;
+		dev_info(dev, "using default %u Hz PTP clock frequency\n",
+			 pdata->ptp_clk);
+	}
 
+	pdata->ker_ptp_clk = devm_clk_get(dev, "ptp_clk");
 	if (IS_ERR(pdata->ker_ptp_clk)) {
 		dev_err(dev, "Failed to get MAC %d ptp clock!\n",
 			pdata->mac_idx);
-		return -EINVAL;
+		return PTR_ERR(pdata->ker_ptp_clk);
 	}
 
-	pdata->ptp_clk = (u32)clk_get_rate(pdata->ker_ptp_clk);
 	pdata->dev = dev;
 
 	/* Init function fointers */
@@ -193,6 +200,25 @@ static int mac_probe(struct platform_device *pdev)
 		return 0;
 	}
 
+	ret = clk_round_rate(pdata->ker_ptp_clk, pdata->ptp_clk);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set MAC %d ptp clock to %i Hz\n",
+			pdata->mac_idx, pdata->ptp_clk);
+		return ret;
+	}
+	if (ret != pdata->ptp_clk) {
+		dev_err(dev, "Expected PTP clock rate unsupported, will use %i Hz instead\n",
+			ret);
+		pdata->ptp_clk = ret;
+	}
+
+	ret = clk_prepare_enable(pdata->ker_ptp_clk);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable MAC %i ptp clock\n",
+			pdata->mac_idx);
+		return ret;
+	}
+
 	/* Request IRQ for MAC */
 	mac_irq_init(pdata);
 
@@ -235,6 +261,15 @@ static int mac_probe(struct platform_device *pdev)
 	return 0;
 }
 
+static int mac_remove(struct platform_device *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(platform_get_drvdata(pdev));
+
+	clk_disable_unprepare(pdata->ker_ptp_clk);
+
+	return 0;
+}
+
 static const struct of_device_id gsw_mac_match[] = {
 	{ .compatible = "intel,gsw_mac" },
 	{},
@@ -243,6 +278,7 @@ MODULE_DEVICE_TABLE(of, gsw_mac_match);
 
 static struct platform_driver gsw_mac_driver = {
 	.probe = mac_probe,
+	.remove = mac_remove,
 	.driver = {
 		.name = MAC_DEV_NAME,
 		.owner = THIS_MODULE,
