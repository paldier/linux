From 29698a515887c6a4c5c7e190c3c704b56966629d Mon Sep 17 00:00:00 2001
From: Yuval Mintz <yuvalm@mellanox.com>
Date: Thu, 14 Dec 2017 15:54:30 +0200
Subject: [PATCH] net: sched: Move to new offload indication in RED

Let RED utilize the new internal flag, TCQ_F_OFFLOADED,
to mark a given qdisc as offloaded instead of using a dedicated
indication.

Also, change internal logic into looking at said flag when possible.

Fixes: 602f3baf2218 ("net_sch: red: Add offload ability to RED qdisc")
Signed-off-by: Yuval Mintz <yuvalm@mellanox.com>
Acked-by: Jiri Pirko <jiri@mellanox.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
---
 net/sched/sch_red.c | 36 +++++++++++++++++-------------------
 1 file changed, 17 insertions(+), 19 deletions(-)

diff --git a/net/sched/sch_red.c b/net/sched/sch_red.c
index 5cb7abee4c81..52bba02eb0e4 100644
--- a/net/sched/sch_red.c
+++ b/net/sched/sch_red.c
@@ -157,7 +157,8 @@ static int red_offload(struct Qdisc *sch, bool enable)
 		.parent = sch->parent,
 	};
 	struct tc_to_netdev tc = {.type = TC_SETUP_QDISC_RED,
-				  { .sch_red = &opt }};
+				  { .sch_red = &opt } };
+	int err;
 
 	if (!dev->netdev_ops->ndo_setup_tc)
 		return -EOPNOTSUPP;
@@ -172,7 +173,14 @@ static int red_offload(struct Qdisc *sch, bool enable)
 		opt.command = TC_RED_DESTROY;
 	}
 
-	return dev->netdev_ops->ndo_setup_tc(dev, sch->handle, 0, &tc);
+	err = dev->netdev_ops->ndo_setup_tc(dev, sch->handle, 0, &tc);
+
+	if (!err && enable)
+		sch->flags |= TCQ_F_OFFLOADED;
+	else
+		sch->flags &= ~TCQ_F_OFFLOADED;
+
+	return err;
 }
 
 static void red_destroy(struct Qdisc *sch)
@@ -272,7 +280,7 @@ static int red_init(struct Qdisc *sch, struct nlattr *opt)
 	return red_change(sch, opt);
 }
 
-static int red_dump_offload(struct Qdisc *sch, struct tc_red_qopt *opt)
+static int red_dump_offload_stats(struct Qdisc *sch, struct tc_red_qopt *opt)
 {
 	struct net_device *dev = qdisc_dev(sch);
 	struct tc_red_qopt_offload hw_stats = {
@@ -285,22 +293,12 @@ static int red_dump_offload(struct Qdisc *sch, struct tc_red_qopt *opt)
 		},
 	};
 	struct tc_to_netdev tc = {.type = TC_SETUP_QDISC_RED,
-				  { .sch_red = &hw_stats }};
-
-	int err;
+				  { .sch_red = &hw_stats } };
 
-	opt->flags &= ~TC_RED_OFFLOADED;
-	if (!dev->netdev_ops->ndo_setup_tc)
-		return 0;
-
-	err = dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_RED, 0, &tc);
-	if (err == -EOPNOTSUPP)
+	if (!(sch->flags & TCQ_F_OFFLOADED))
 		return 0;
 
-	if (!err)
-		opt->flags |= TC_RED_OFFLOADED;
-
-	return err;
+	return dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_RED, 0, &tc);
 }
 
 static int red_dump(struct Qdisc *sch, struct sk_buff *skb)
@@ -319,7 +317,7 @@ static int red_dump(struct Qdisc *sch, struct sk_buff *skb)
 	int err;
 
 	sch->qstats.backlog = q->qdisc->qstats.backlog;
-	err = red_dump_offload(sch, &opt);
+	err = red_dump_offload_stats(sch, &opt);
 	if (err)
 		goto nla_put_failure;
 
@@ -347,7 +345,7 @@ static int red_dump_stats(struct Qdisc *sch, struct gnet_dump *d)
 		.marked	= q->stats.prob_mark + q->stats.forced_mark,
 	};
 
-	if (dev->netdev_ops->ndo_setup_tc) {
+	if (sch->flags & TCQ_F_OFFLOADED) {
 		struct red_stats hw_stats = {0};
 		struct tc_red_qopt_offload hw_stats_request = {
 			.command = TC_RED_XSTATS,
@@ -358,7 +356,7 @@ static int red_dump_stats(struct Qdisc *sch, struct gnet_dump *d)
 			},
 		};
 		struct tc_to_netdev tc = {.type = TC_SETUP_QDISC_RED,
-				  { .sch_red = &hw_stats_request }};
+				  { .sch_red = &hw_stats_request } };
 
 		if (!dev->netdev_ops->ndo_setup_tc(dev,
 						   TC_SETUP_QDISC_RED, 0,
