From a3e22b1ba02f4748d8fa80815ad382c4240ffe68 Mon Sep 17 00:00:00 2001
From: INgo Rah <ingo.rah@intel.com>
Date: Mon, 17 Dec 2018 15:06:18 +0100
Subject: [PATCH] Removes several debug prints and lowers the print level for
 debug printouts

- Remove some ppv4 qos prints
- Remove vmb prints
- Remove and change gswip prints
---
 arch/mips/include/asm/ltq_itc.h                    |  2 +-
 arch/mips/lantiq/lantiq-itc.c                      |  4 --
 arch/mips/lantiq/lantiq-vmb.c                      | 74 ----------------------
 drivers/net/ethernet/lantiq/cqm/cqm_dev.c          | 13 +---
 drivers/net/ethernet/lantiq/cqm/prx300/cqm.c       |  2 -
 .../net/ethernet/lantiq/datapath/datapath_api.c    |  2 +-
 .../lantiq/datapath/gswip31/datapath_misc.c        |  2 -
 .../net/ethernet/lantiq/ppv4/qos/pp_qos_linux.c    |  3 +-
 drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c | 11 ++--
 .../net/ethernet/lantiq/switch-api/gsw_defconf.c   | 73 ---------------------
 .../net/ethernet/lantiq/switch-api/gsw_flow_core.c | 40 ++----------
 .../net/ethernet/lantiq/switch-api/gsw_flow_pce.c  |  7 +-
 .../net/ethernet/lantiq/switch-api/gsw_gphy_fw.c   |  5 +-
 drivers/net/ethernet/lantiq/switch-api/gsw_init.c  |  4 --
 .../ethernet/lantiq/switch-api/mac/xgmac_common.h  |  2 +-
 .../ethernet/lantiq/switch-api/mac/xgmac_mac_api.c |  8 +--
 16 files changed, 22 insertions(+), 230 deletions(-)

diff --git a/arch/mips/include/asm/ltq_itc.h b/arch/mips/include/asm/ltq_itc.h
index bd3c3a824ab5..52631727a807 100644
--- a/arch/mips/include/asm/ltq_itc.h
+++ b/arch/mips/include/asm/ltq_itc.h
@@ -27,7 +27,7 @@
 #define ITC_AddrMask		0x3f	/* 128K ITC address space */
 #define ITC_EntryGrain		0	/* 128 bytes between Entries (Cells)*/
 
-#define DEBUG_ITC
+#undef DEBUG_ITC
 
 int32_t itc_init(void);
 void itc_sem_wait(uint8_t semId);
diff --git a/arch/mips/lantiq/lantiq-itc.c b/arch/mips/lantiq/lantiq-itc.c
index 2c85aa9d8549..a6817121c94b 100644
--- a/arch/mips/lantiq/lantiq-itc.c
+++ b/arch/mips/lantiq/lantiq-itc.c
@@ -46,7 +46,6 @@ int32_t itc_init(void)
 			ehb; \
 			"
 		);
-	pr_info("\nInitial ITC_Address_Map0 %08x\n", read_c0_dtaglo());
 
 	if (read_c0_dtaglo() & ITC_En) {
 		pr_info("ITC Memory is already initialised for Core %d at address %x !!!",
@@ -183,9 +182,6 @@ int32_t itc_init(void)
 		ITC_Cell_Sem_off = ITC_Cell_Sem_off + (128 * (0x1 << ITC_EntryGrain));
 	}
 
-	pr_info("\n ITC Init done on Core %d on CPU %d !!!\n",
-		(smp_processor_id() / 2), smp_processor_id());
-
 	return 0;
 }
 early_initcall(itc_init);
diff --git a/arch/mips/lantiq/lantiq-vmb.c b/arch/mips/lantiq/lantiq-vmb.c
index c9d3082e5b74..66e0c17a75f7 100644
--- a/arch/mips/lantiq/lantiq-vmb.c
+++ b/arch/mips/lantiq/lantiq-vmb.c
@@ -81,15 +81,11 @@ static irqreturn_t fw_vmb_ipi1_hdlr(int irq, void *ptr)
 	struct VMB_vpe_t *vpet_t;
 	struct FW_vmb_msg_t *fw_t;
 
-	pr_info("[%s]:[%d] CPU = %d irq = %d\n", __func__, __LINE__,
-		smp_processor_id(), (irq - MIPS_GIC_IRQ_BASE));
-
 	/* This handler is from FW_VMB_IPI1 so called from CPU1 */
 	cpu = 1;
 	cid = which_core(cpu);
 	vid = vpe_in_core(cpu);
 
-	pr_info("[%s]:[%d] cid = %d, vid = %d\n", __func__, __LINE__, cid, vid);
 	vpet_t = &core_t[cid].vpe_t[vid];
 	fw_t = (struct FW_vmb_msg_t *)VMB_get_msg_addr(cpu, 1);
 
@@ -108,7 +104,6 @@ static irqreturn_t fw_vmb_ipi1_hdlr(int irq, void *ptr)
 		vmb_cpu_free(cpu);
 		vmb_tc_free(cpu, -1);
 
-		pr_info("[%s]:[%d], cpu = %d\n", __func__, __LINE__, cpu);
 		if (vpet_t->vmb_callback_fn && vpet_t->vmb_callback_fn != NULL)
 			vpet_t->vmb_callback_fn(vpet_t->fw_vmb.status);
 
@@ -122,16 +117,8 @@ static irqreturn_t fw_vmb_ipi1_hdlr(int irq, void *ptr)
 		vmb_tc_free(cpu, -1);
 
 		vpet_t->bl_status = IBL_ACTIVE;
-		pr_info("[%s]:[%d], cpu = %d\n", __func__, __LINE__, cpu);
 	}
 
-	/* Clear DDR section */
-	if (vpet_t->fw_vmb.status == (uint32_t)FW_VMB_ACK)
-		pr_info("[%s]:[%d]\n", __func__, __LINE__);
-
-	pr_info("[%s]:[%d]\n", __func__, __LINE__);
-	pr_info("  vmb_wq = %p\n",  &vpet_t->v_wq.vmb_wq);
-
 	/* Set the wakeup_vpe and wakeup the waitqueue */
 	vpet_t->v_wq.wakeup_vpe = 1;
 	wake_up_interruptible(&vpet_t->v_wq.vmb_wq);
@@ -169,7 +156,6 @@ static irqreturn_t fw_vmb_ipi2_hdlr(int irq, void *ptr)
 		vmb_cpu_free(cpu);
 		vmb_tc_free(cpu, -1);
 
-		pr_info("[%s]:[%d], cpu = %d\n", __func__, __LINE__, cpu);
 		if (vpet_t->vmb_callback_fn && vpet_t->vmb_callback_fn != NULL)
 			vpet_t->vmb_callback_fn(vpet_t->fw_vmb.status);
 
@@ -182,7 +168,6 @@ static irqreturn_t fw_vmb_ipi2_hdlr(int irq, void *ptr)
 		vmb_cpu_free(cpu);
 		vmb_tc_free(cpu, -1);
 		vpet_t->bl_status = IBL_ACTIVE;
-		pr_info("[%s]:[%d], cpu = %d\n", __func__, __LINE__, cpu);
 	}
 
 	/* Set the wakeup_vpe and wakeup the waitqueue */
@@ -199,16 +184,11 @@ static irqreturn_t fw_vmb_ipi3_hdlr(int irq, void *ptr)
 	struct VMB_vpe_t *vpet_t;
 	struct FW_vmb_msg_t *fw_t;
 
-	pr_info("[%s]:[%d] CPU = %d irq = %d\n", __func__,
-		__LINE__, smp_processor_id(), (irq - MIPS_GIC_IRQ_BASE));
-
 	/* This handler is from FW_VMB_IPI3 so called from CPU3 */
 	cpu = 3;
 	cid = which_core(cpu);
 	vid = vpe_in_core(cpu);
 
-	pr_info("[%s]:[%d] cid = %d, vid = %d\n",
-		__func__, __LINE__, cid, vid);
 	vpet_t = &core_t[cid].vpe_t[vid];
 	fw_t = (struct FW_vmb_msg_t *)VMB_get_msg_addr(cpu, 1);
 
@@ -227,7 +207,6 @@ static irqreturn_t fw_vmb_ipi3_hdlr(int irq, void *ptr)
 		vmb_cpu_free(cpu);
 		vmb_tc_free(cpu, -1);
 
-		pr_info("[%s]:[%d], cpu = %d\n", __func__, __LINE__, cpu);
 		if (vpet_t->vmb_callback_fn && vpet_t->vmb_callback_fn != NULL)
 			vpet_t->vmb_callback_fn(vpet_t->fw_vmb.status);
 
@@ -241,15 +220,8 @@ static irqreturn_t fw_vmb_ipi3_hdlr(int irq, void *ptr)
 		vmb_tc_free(cpu, -1);
 
 		vpet_t->bl_status = IBL_ACTIVE;
-		pr_info("[%s]:[%d], cpu = %d\n", __func__, __LINE__, cpu);
 	}
 
-	if (vpet_t->fw_vmb.status == (uint32_t)FW_VMB_ACK)
-		pr_info("[%s]:[%d]\n", __func__, __LINE__);
-
-	pr_info("[%s]:[%d]\n", __func__, __LINE__);
-	pr_info("  vmb_wq = %p\n",  &vpet_t->v_wq.vmb_wq);
-
 	/* Set the wakeup_vpe and wakeup the waitqueue */
 	vpet_t->v_wq.wakeup_vpe = 1;
 	wake_up_interruptible(&vpet_t->v_wq.vmb_wq);
@@ -305,7 +277,6 @@ static int linux_cpu_ipi_update(unsigned long cpu)
 
 static int __init vmb_cpu_active(unsigned int hcpu)
 {
-	pr_info("[%s]:[%d], cpu = %ld\n", __func__, __LINE__, (long)hcpu);
 	if (hcpu != 0)
 		linux_cpu_ipi_update((unsigned long)hcpu);
 
@@ -329,8 +300,6 @@ static void vmb_check_IBL_fw_msg(void)
 
 			spin_lock(&vpet[j].vpe_lock);
 			cpu = get_cpu_id(i, j);
-			pr_info("[%s]:[%d] vpet[j].bl_status = %d, cpu = %d\n",
-				__func__, __LINE__, vpet[j].bl_status, cpu);
 			fw_msg_t = (struct FW_vmb_msg_t *)VMB_get_msg_addr(cpu, 1);
 			memcpy(&vpet[j].fw_vmb, fw_msg_t,
 			       sizeof(struct FW_vmb_msg_t));
@@ -367,9 +336,6 @@ static int update_DB_from_DT(struct VMB_vpe_t *vt)
 	strlcpy(vt->name, name, sizeof(vt->name));
 	vt->cpu_status |= CPU_BOOTUP_DT;
 
-	pr_info("[%s]:[%d], cpuid = %d name = %s\n",
-		__func__, __LINE__, vt->cpu_id, vt->name);
-
 	/* for CPU 0, no need to get IRQ for VMB */
 	if (vt->cpu_id == 0)
 		return 0;
@@ -581,9 +547,6 @@ static int __init vmb_init(void)
 {
 	memset(core_t, 0, sizeof(struct VMB_core_t));
 
-	pr_info("MAXCORE = %d, MAXCPU = %d, MAXTCS = %d MAX_VPE = %d\n",
-		MAX_CORE, MAX_CPU, MAX_TC, MAX_VPE);
-
 	/*
 	 * CPU notifier for Linux SMP bootup indication notify (CPU_STARTING)
 	 * from start_secondary
@@ -631,18 +594,12 @@ static void gic_trigger(int8_t cpu)
 {
 	switch (cpu) {
 	case 1:
-		pr_info("[%s]:[%d] VMB_CPU_IPI1 - %d CPU = %d\n",
-			__func__, __LINE__, g_cpu_vmb_irq[1], cpu);
 		gic_send_ipi_simple(g_cpu_vmb_irq[1], 0);
 		break;
 	case 2:
-		pr_info("[%s]:[%d] VMB_CPU_IPI2 - %d CPU = %d\n",
-			__func__, __LINE__, g_cpu_vmb_irq[2], cpu);
 		gic_send_ipi_simple(g_cpu_vmb_irq[2], 0);
 		break;
 	case 3:
-		pr_info("[%s]:[%d] VMB_CPU_IPI3 - %d CPU = %d\n",
-			__func__, __LINE__, g_cpu_vmb_irq[3], cpu);
 		gic_send_ipi_simple(g_cpu_vmb_irq[3], 0);
 		break;
 	default:
@@ -796,9 +753,6 @@ int8_t vmb_cpu_force_stop(int8_t cpu)
 		goto fin_fstop;
 	}
 
-	pr_info("[%s]:[%d] OUTSIDE wakeup_vpe = %d vpet->fw_vmb.status = %d\n",
-		__func__, __LINE__, vpet->v_wq.wakeup_vpe, vpet->fw_vmb.status);
-
 	vpet->v_wq.wakeup_vpe = 0;
 
 	if (vpet->fw_vmb.status == (uint32_t)IBL_IN_WAIT) {
@@ -947,9 +901,6 @@ int8_t vmb_cpu_start(int8_t cpu, struct CPU_launch_t cpu_launch,
 
 	memset(vmb_fw_msg_t, 0, sizeof(struct VMB_fw_msg_t));
 
-	pr_info("[%s]:[%d] vmb_fw_msg_t = %p cpu = %d !\n",
-		__func__, __LINE__, vmb_fw_msg_t, cpu);
-
 	vmb_fw_msg_t->msg_id = VMB_CPU_START;
 	memcpy(&vmb_fw_msg_t->cpu_launch, &cpu_launch,
 	       sizeof(vmb_fw_msg_t->cpu_launch));
@@ -961,10 +912,6 @@ int8_t vmb_cpu_start(int8_t cpu, struct CPU_launch_t cpu_launch,
 		}
 	}
 
-	pr_info("[%s]:[%d]  start_address = %u cpu = %d !!!!\n",
-		__func__, __LINE__,
-		(unsigned int)(vmb_fw_msg_t->cpu_launch.start_addr), cpu);
-
 	/* update the allocated yield resource bitmap */
 	vmb_fw_msg_t->cpu_launch.yield_res = (uint32_t)yieldres_t;
 
@@ -977,9 +924,6 @@ int8_t vmb_cpu_start(int8_t cpu, struct CPU_launch_t cpu_launch,
 	gic_trigger(cpu);
 	mips_ihb();
 
-	pr_info("[%s]:[%d] WAITING FOR RESPONSE vpet->v_wq.wakeup_vpe = %d !\n",
-		__func__, __LINE__, vpet->v_wq.wakeup_vpe);
-
 	/* Wait for timeout */
 	ret1 = wait_event_interruptible_timeout(vpet->v_wq.vmb_wq,
 					(vpet->v_wq.wakeup_vpe == 1),
@@ -996,14 +940,11 @@ int8_t vmb_cpu_start(int8_t cpu, struct CPU_launch_t cpu_launch,
 		ret = -VMB_ETIMEOUT;
 		goto fin;
 	}
-	pr_info("[%s]:[%d] OUTSIDE wakeup_vpe = %d vpet->fw_vmb.status = %d\n",
-		__func__, __LINE__, vpet->v_wq.wakeup_vpe, vpet->fw_vmb.status);
 	memset(vmb_fw_msg_t, 0, sizeof(struct VMB_fw_msg_t));
 	vpet->v_wq.wakeup_vpe = 0;
 
 	if (vpet->fw_vmb.status == (uint32_t)FW_VMB_ACK) {
 		ret = VMB_SUCCESS;
-		pr_err("[%s]:[%d] ret = %d\n", __func__, __LINE__, ret);
 	} else {
 		ret = -VMB_ENACK;
 		pr_err("[%s]:[%d] -ENACK recieved from FW ..\n",
@@ -1042,8 +983,6 @@ int8_t vmb_tc_alloc(uint8_t cpu)
 				tct[i].tc_status |= TC_ACTIVE;
 				ret = i;
 				tct[i].vpe_id = v_id;
-				pr_info("[%s]:[%d] CPU tct tc_status = %x\n",
-					__func__, __LINE__, tct[i].tc_status);
 				goto fin_talloc;
 			} else {
 				ret = -VMB_EBUSY;
@@ -1161,9 +1100,6 @@ int8_t vmb_tc_start(uint8_t cpu, struct TC_launch_t tc_launch[],
 	gic_trigger(cpu);
 	mips_ihb();
 
-	pr_info("[%s]:[%d] OUTSIDE wakeup_vpe = %d vpet->fw_vmb.status = %d\n",
-		__func__, __LINE__, vpet->v_wq.wakeup_vpe, vpet->fw_vmb.status);
-
 	/* Wait for timeout */
 	ret1 = wait_event_interruptible_timeout(vpet->v_wq.vmb_wq,
 					(vpet->v_wq.wakeup_vpe == 1),
@@ -1179,15 +1115,11 @@ int8_t vmb_tc_start(uint8_t cpu, struct TC_launch_t tc_launch[],
 		goto fin_tcstart;
 	}
 
-	pr_info("[%s]:[%d] OUTSIDE wakeup_vpe = %d vpet->fw_vmb.status = %d\n",
-		__func__, __LINE__, vpet->v_wq.wakeup_vpe, vpet->fw_vmb.status);
-
 	memset(vmb_fw_msg_t, 0, sizeof(struct VMB_fw_msg_t));
 	vpet->v_wq.wakeup_vpe = 0;
 
 	if (vpet->fw_vmb.status == (uint32_t)FW_VMB_ACK) {
 		ret = VMB_SUCCESS;
-		pr_err("[%s]:[%d] ret = %d\n", __func__, __LINE__, ret);
 	} else {
 		ret = -VMB_ENACK;
 		pr_err("[%s]:[%d] -ENACK recieved from FW. Resetting\n",
@@ -1240,14 +1172,11 @@ int8_t vmb_tc_stop(uint8_t cpu, uint8_t tc_num)
 		goto fin_tcstop;
 	}
 
-	pr_info("[%s]:[%d] OUTSIDE wakeup_vpe = %d vpet->fw_vmb.status = %d\n",
-		__func__, __LINE__, vpet->v_wq.wakeup_vpe, vpet->fw_vmb.status);
 	memset(vmb_fw_msg_t, 0, sizeof(struct VMB_fw_msg_t));
 	vpet->v_wq.wakeup_vpe = 0;
 
 	if (vpet->fw_vmb.status == (uint32_t)FW_VMB_ACK) {
 		ret = VMB_SUCCESS;
-		pr_err("[%s]:[%d]  ret = %d\n", __func__, __LINE__, ret);
 	} else {
 		ret = -VMB_ENACK;
 		pr_err("[%s]:[%d] -ENACK recieved from FW. Resetting\n",
@@ -1542,9 +1471,6 @@ int32_t fw_vmb_get_irq(uint8_t cpu)
 	if (cpu < MAX_CPU)
 		ret = g_fw_vmb_hwirq[cpu];
 
-	pr_info("[%s]:[%d] CPU = %d  IRQ = %d !!!\n",
-		__func__, __LINE__, cpu, ret);
-
 	return ret;
 }
 EXPORT_SYMBOL(fw_vmb_get_irq);
diff --git a/drivers/net/ethernet/lantiq/cqm/cqm_dev.c b/drivers/net/ethernet/lantiq/cqm/cqm_dev.c
index 082cb300be7a..95478f225c19 100644
--- a/drivers/net/ethernet/lantiq/cqm/cqm_dev.c
+++ b/drivers/net/ethernet/lantiq/cqm/cqm_dev.c
@@ -28,8 +28,6 @@ struct device_node *parse_dts(int j, void **pdata, struct resource **res,
 	unsigned int pool_size = 0;
 	u8 count = 0;
 
-	pr_info("[%s] .. [%d]\n", __func__, __LINE__);
-
 	node = of_find_node_by_name(NULL, dev_node_name[j].node_name);
 	if (!node) {
 		pr_err("Unable to get node %s for %s\n",
@@ -54,11 +52,11 @@ struct device_node *parse_dts(int j, void **pdata, struct resource **res,
 	memcpy(*res, resource, (sizeof(struct resource) * idx));
 	cqm_pdata->num_resources = idx;
 	*num_res = idx;
-	pr_info("num_res %d\n", *num_res);
+	pr_debug("num_res %d\n", *num_res);
 
 	for (idx = 0; idx < MAX_NUM_INTR; idx++) {
 		intr[idx] = irq_of_parse_and_map(node, idx);
-		pr_info("intr %d\n", intr[idx]);
+		pr_debug("intr %d\n", intr[idx]);
 		if (!intr[idx])
 			break;
 	}
@@ -136,7 +134,6 @@ int add_cqm_dev(int i)
 		       __func__, __LINE__, dev_node_name[i].dev_name);
 		return CBM_FAILURE;
 	}
-	pr_info("parse dts done\n");
 #if 1
 
 	pdev = platform_device_alloc(dev_node_name[i].dev_name, 1);
@@ -153,7 +150,6 @@ int add_cqm_dev(int i)
 		platform_set_drvdata(pdev, pdata);
 	/* Add resources to platform device */
 	if ((num_res > 0) && res) {
-		pr_info("adding resources\n");
 		ret = platform_device_add_resources(pdev, res, num_res);
 		if (ret) {
 			pr_info("%s: Failed to add resources for %s.\n",
@@ -162,7 +158,6 @@ int add_cqm_dev(int i)
 		}
 	}
 
-	pr_info("resources added\n");
 	/* Add platform device */
 	ret = platform_device_add(pdev);
 	if (ret) {
@@ -172,7 +167,6 @@ int add_cqm_dev(int i)
 	}
 #endif
 
-	pr_info(" Successfully Registered Platform device %s.\n", pdev->name);
 	return ret;
 
 err_free_pdata:
@@ -197,10 +191,8 @@ static int cqm_platdev_parse_dts(void)
 	int i, dev_add = 0;
 
 	for (i = 0; i < CQM_NUM_DEV_SUPP; i++) {
-		pr_info("dev %s\n", dev_node_name[i].dev_name);
 		if (!add_cqm_dev(i)) {
 			dev_add++;
-			pr_info("device added\n");
 		}
 	}
 	if (!dev_add)
@@ -210,7 +202,6 @@ static int cqm_platdev_parse_dts(void)
 
 static __init int cqm_platdev_init(void)
 {
-	pr_info("%s is called\n", __func__);
 	cqm_platdev_parse_dts();
 	return 0;
 }
diff --git a/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c b/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
index 980f4a60785a..74b6410fae17 100644
--- a/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
+++ b/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
@@ -69,8 +69,6 @@ static int get_buff_resv_bytes(int cbm_inst, int size)
 {
 	int bsl_thr_val = 0x2800;
 
-	dev_info(cqm_ctrl->dev, "BSL thres %d size %d\n", BSL_THRES, size);
-
 	if (size < cqm_ctrl->num_pools)
 		bsl_thr_val = cqm_ctrl->prx300_pool_size[size] - BSL_THRES;
 	else
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_api.c b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
index 17fd834b6b30..79c9ebae8edb 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_api.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
@@ -2786,7 +2786,7 @@ int dp_basic_proc(void)
 		PR_INFO("NMI_MASK\n");
 #endif
 	dp_init_ok = 1;
-	PR_INFO("datapath init done\n");
+
 	return res;
 }
 
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
index 656077d51744..48cd27bc9c9c 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
@@ -1085,8 +1085,6 @@ int dp_platform_queue_set(int inst, u32 flag)
 			return -1;
 		}
 		priv->ppv4_drop_q = q.qid;
-	} else {
-		PR_INFO("drop queue: %d\n", priv->ppv4_drop_q);
 	}
 	/*Map all lookup entry to drop queue at the beginning*/
 	cbm_queue_map_set(dp_port_prop[inst].cbm_inst, priv->ppv4_drop_q,
diff --git a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_linux.c b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_linux.c
index 09953f974a05..f6ed20c54c7f 100644
--- a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_linux.c
+++ b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_linux.c
@@ -539,7 +539,7 @@ static int __init pp_qos_mod_init(void)
 	qos_dbg_module_init();
 	rc = platform_driver_register(&pp_qos_driver);
 	PPV4_QOS_MANUAL_ADD(rc);
-	pr_info("pp_qos_driver init, status %d\n", rc);
+
 	return rc;
 }
 
@@ -549,7 +549,6 @@ static void __exit pp_qos_mod_exit(void)
 	platform_driver_unregister(&pp_qos_driver);
 
 	qos_dbg_module_clean();
-	pr_info("pp_qos_driver exit\n");
 }
 
 //device_initcall(pp_qos_mod_init);
diff --git a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c
index e6bc3aa4e69e..b9d43f82e266 100644
--- a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c
+++ b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c
@@ -2204,13 +2204,14 @@ struct pp_qos_dev *create_qos_dev_desc(struct qos_dev_init_info *initinfo)
 		if (rc)
 			goto err;
 		qos_devs[id] = qdev;
-		QOS_LOG_INFO("Initialized qos instance\nmax_port:\t\t%u\n",
+		
+		QOS_LOG_DEBUG("Initialized qos instance\nmax_port:\t\t%u\n",
 				qdev->max_port);
-		QOS_LOG_INFO("fw_logger_start:\t0x%08X\n",
+		QOS_LOG_DEBUG("fw_logger_start:\t0x%08X\n",
 				qdev->hwconf.fw_logger_start);
-		QOS_LOG_INFO("fw_stat:\t\t0x%08X\n",
+		QOS_LOG_DEBUG("fw_stat:\t\t0x%08X\n",
 				qdev->hwconf.fw_stat);
-		QOS_LOG_INFO("cmdbuf:\t\t0x%08X\ncmdbuf size:\t\t%zu\n",
+		QOS_LOG_DEBUG("cmdbuf:\t\t0x%08X\ncmdbuf size:\t\t%zu\n",
 				(unsigned int)(uintptr_t)qdev->fwcom.cmdbuf,
 				qdev->fwcom.cmdbuf_sz);
 	} else {
@@ -2247,8 +2248,6 @@ void qos_module_init(void)
 
 	for (i = 0 ; i < MAX_QOS_INSTANCES; ++i)
 		qos_devs[i] = NULL;
-
-	QOS_LOG_INFO("qos_module_init completed\n");
 }
 
 int pp_qos_get_quanta(struct pp_qos_dev *qdev, unsigned int *quanta)
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c b/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c
index d0624d4988b8..5716e62471ca 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c
@@ -132,10 +132,6 @@ int gsw_get_def_pce_qmap(struct core_ops *ops)
 		return -EIO;
 	}
 
-	printk("\nGSWIP Default PCE-Q-MAP\n");
-	printk("%15s %15s %15s %15s %15s %15s\n",
-	       "EgLpid", "Ext", "Traf_Cls", "Q_Map_Mode", "Qid", "Redir_Lpid");
-
 	for (j = 0; j < num_of_elem; j++) {
 		for (i = gsw_pce_path[j].tc_from;
 		     i <= gsw_pce_path[j].tc_to; i++) {
@@ -143,11 +139,6 @@ int gsw_get_def_pce_qmap(struct core_ops *ops)
 			q_map.nTrafficClassId = i;
 			q_map.nPortId = gsw_pce_path[j].eg_lpid;
 			ops->gsw_qos_ops.QoS_QueuePortGet(ops, &q_map);
-			printk("%15d %15d %15d %15d %15d %15d ",
-			       q_map.nPortId, q_map.bExtrationEnable,
-			       q_map.nTrafficClassId, q_map.eQMapMode,
-			       q_map.nQueueId, q_map.nRedirectPortId);
-			printk("\n");
 
 		}
 	}
@@ -206,21 +197,12 @@ int gsw_get_def_bypass_qmap(struct core_ops *ops)
 		return -EIO;
 	}
 
-	printk("\nGSWIP Default PCE Bypass Q-MAP\n");
-	printk("%15s %15s %15s %15s %15s %15s\n",
-	       "EgMpid", "Ext", "Traf_Cls", "Q_Map_Mode", "Qid", "Redir_Lpid");
-
 	for (j = 0; j < num_of_elem; j++) {
 		memset(&q_map, 0, sizeof(GSW_QoS_queuePort_t));
 		q_map.nPortId = gsw_bypass_path[j].eg_pid;
 		q_map.bRedirectionBypass = 1;
 		q_map.bExtrationEnable = gsw_bypass_path[j].ext;
 		ops->gsw_qos_ops.QoS_QueuePortGet(ops, &q_map);
-		printk("%15d %15d %15d %15d %15d %15d ",
-		       q_map.nPortId, q_map.bExtrationEnable,
-		       q_map.nTrafficClassId, q_map.eQMapMode,
-		       q_map.nQueueId, q_map.nRedirectPortId);
-		printk("\n");
 	}
 
 	return 0;
@@ -362,8 +344,6 @@ static int pmac_ig_cfg(struct core_ops *ops, u8 pmacid, u8 dpu)
 		ops->gsw_pmac_ops.Pmac_Ig_CfgSet(ops, &ig_cfg);
 	}
 
-	pr_debug("PMAC_IG_CFG_SET for PMAC %d %s\n", pmacid,
-		(dpu == NON_DPU) ? "Non-DPU" : "DPU");
 	return 0;
 }
 
@@ -379,11 +359,6 @@ int pmac_get_ig_cfg(struct core_ops *ops, u8 pmacid)
 		return -EIO;
 	}
 
-	printk("\nGSWIP PMAC IG CFG\n");
-	printk("%10s %10s %10s %10s %10s %10s %10s %10s %10s\n",
-	       "PmacId", "TxDmaChId", "ErrPktDisc", "ClassEn",
-	       "ClassDef", "eSubId", "bSpIdDef", "bPmacPr", "DefPmacHdr");
-
 	for (i = PMAC0_TX_DMACHID_START; i <= PMAC0_TX_DMACHID_END; i++) {
 		memset((void *)&ig_cfg, 0x00, sizeof(ig_cfg));
 
@@ -391,16 +366,6 @@ int pmac_get_ig_cfg(struct core_ops *ops, u8 pmacid)
 		ig_cfg.nTxDmaChanId	= i;
 
 		ops->gsw_pmac_ops.Pmac_Ig_CfgGet(ops, &ig_cfg);
-		printk("%10d %10d %10d %10d %10d %10d %10d %10d %10x:%x:%x:%x:%x:%x:%x:%x",
-		       ig_cfg.nPmacId, ig_cfg.nTxDmaChanId,
-		       ig_cfg.bErrPktsDisc, ig_cfg.bClassEna,
-		       ig_cfg.bClassDefault, ig_cfg.eSubId,
-		       ig_cfg.bSpIdDefault, ig_cfg.bPmacPresent,
-		       ig_cfg.defPmacHdr[0], ig_cfg.defPmacHdr[1],
-		       ig_cfg.defPmacHdr[2], ig_cfg.defPmacHdr[3],
-		       ig_cfg.defPmacHdr[4], ig_cfg.defPmacHdr[5],
-		       ig_cfg.defPmacHdr[6], ig_cfg.defPmacHdr[7]);
-		printk("\n");
 	}
 
 	return 0;
@@ -495,9 +460,6 @@ static int pmac_eg_cfg(struct core_ops *ops, u8 pmacid, u8 dpu)
 		}
 	}
 
-	pr_debug("PMAC_EG_CFG_SET for PMAC %d %s\n", pmacid,
-		(dpu == NON_DPU) ? "Non-DPU" : "DPU");
-
 	return 0;
 }
 
@@ -513,14 +475,6 @@ int pmac_get_eg_cfg(struct core_ops *ops, u8 pmacid, u8 dst_port)
 		return -EIO;
 	}
 
-	printk("\nGSWIP PMAC EG CFG\n");
-
-	printk("\n\nDestination portId = %d\n\n", dst_port);
-	printk("%10s %10s %10s %10s %10s %10s %10s %10s %10s %10s %10s %10s\n",
-	       "PmacId", "RxDmaChId", "BslTrafCls", "BslSegDis",
-	       "PmacEna", "RedirEna", "DestPortId", "TrafCls", "Mpe1",
-	       "Mpe2", "FlowId", "FcsEn");
-
 	for (k = 0; k <= 3; k++) {
 		for (i = 0; i <= 3; i++) {
 			for (j = 0; j <= 3; j++) {
@@ -539,20 +493,6 @@ int pmac_get_eg_cfg(struct core_ops *ops, u8 pmacid, u8 dst_port)
 
 				ops->gsw_pmac_ops.Pmac_Eg_CfgGet(ops,
 								 &eg_cfg);
-				printk("%10d %10d %10d %10d %10d %10d %10d %10d %10d %10d %10d %10d",
-				       eg_cfg.nPmacId,
-				       eg_cfg.nRxDmaChanId,
-				       eg_cfg.nBslTrafficClass,
-				       eg_cfg.bBslSegmentDisable,
-				       eg_cfg.bPmacEna,
-				       eg_cfg.bRedirEnable,
-				       eg_cfg.nDestPortId,
-				       eg_cfg.nTrafficClass,
-				       eg_cfg.bMpe1Flag,
-				       eg_cfg.bMpe2Flag,
-				       eg_cfg.nFlowIDMsb,
-				       eg_cfg.bFcsEna);
-				printk("\n");
 			}
 		}
 	}
@@ -580,8 +520,6 @@ static int pmac_glbl_cfg(struct core_ops *ops, u8 pmacid)
 
 	ops->gsw_pmac_ops.Pmac_Gbl_CfgSet(ops, &glbl_cfg);
 
-	pr_debug("PMAC_GLBL_CFG_SET for PMAC %d\n", pmacid);
-
 	return 0;
 }
 
@@ -684,21 +622,12 @@ int pmac_get_bp_cfg(struct core_ops *ops, u8 pmacid)
 	}
 
 	/* Do the GSWIP PMAC BM table configuration */
-	printk("\nGSWIP PMAC BP CFG\n");
-	printk("%10s %10s %10s %10s\n",
-	       "PmacId", "TxDmaChId", "TxQMask", "RxPortMask");
-
 	for (m = PMAC0_TX_DMACHID_START; m <= PMAC0_TX_DMACHID_END; m++) {
 		memset((void *)&bm_cfg, 0x00, sizeof(bm_cfg));
 		bm_cfg.nPmacId		= pmacid;
 		bm_cfg.nTxDmaChanId	= m;
 
 		ops->gsw_pmac_ops.Pmac_Bm_CfgGet(ops, &bm_cfg);
-
-		printk("%10d %10d %10x %10x",
-		       bm_cfg.nPmacId, bm_cfg.nTxDmaChanId,
-		       bm_cfg.txQMask, bm_cfg.rxPortMask);
-		printk("\n");
 	}
 
 	return 0;
@@ -721,7 +650,6 @@ int gsw_pmac_init_nondpu(void)
 	pmac_eg_cfg(ops, 1, NON_DPU);
 	pmac_bp_cfg(ops, NON_DPU);
 
-	pr_debug("\n\t GSW PMAC Init Done!!!\n");
 	return 0;
 }
 
@@ -742,7 +670,6 @@ int gsw_pmac_init_dpu(void)
 	pmac_eg_cfg(ops, 1, NON_DPU);
 	pmac_bp_cfg(ops, DPU);
 
-	pr_debug("\n\t GSW PMAC Init Done!!!\n");
 	return 0;
 }
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
index 0ec740d07adf..fc996818ed24 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
@@ -212,7 +212,7 @@ struct mac_ops *get_mac_ops(ethsw_api_dev_t *gswdev, int idx)
 	u32 max_mac = gsw_get_mac_subifcnt(dev_id);
 
 	if (idx < 2 || idx > max_mac + 1) {
-		printk("Invalid MAC Idx %d, Only MAC idx > 2 is Allowed\n", idx);
+		pr_info("Invalid MAC Idx %d, Only MAC idx > 2 is Allowed\n", idx);
 		return NULL;
 	}
 
@@ -1661,7 +1661,7 @@ static int gsw3x_msw_table_rm(void *cdev, GSW_multicastTable_t *parm)
 	}
 
 	if (MATCH == 0)
-		pr_err("The GIP/SIP not found\n");
+		pr_info("The GIP/SIP not found\n");
 
 	return GSW_statusOk;
 }
@@ -3271,11 +3271,9 @@ void *ethsw_api_core_init(ethsw_core_init_t *ethcinit)
 		PCE_GCTRL_0_MC_VALID_SHIFT, PCE_GCTRL_0_MC_VALID_SIZE, 0x1);
 #else
 
-	if ((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
+	if ((ethcinit->sdev == LTQ_FLOW_DEV_INT) ||
+	    (ethcinit->sdev == LTQ_FLOW_DEV_INT_R))
 		gsw_pmicro_code_init(cdev);
-		pr_debug("Switch API: PCE MicroCode loaded !!\n");
-	}
-
 #endif
 
 	if ((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
@@ -12133,7 +12131,6 @@ GSW_return_t GSW_HW_Init(void *cdev, GSW_HW_Init_t *parm)
 		//rst_multi_sw_table(cdev);
 		/* HW Init */
 		gsw_pmicro_code_init_f24s(cdev);
-		printk("Switch API: PCE MicroCode loaded for LTQ_FLOW_DEV_EXT_AX3000_F24S\n");
 		/*hardcoded setting for LTQ_FLOW_DEV_EXT_AX3000_F24S*/
 		ret = GSW_statusOk;
 
@@ -21850,8 +21847,6 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 #endif
 
 	if (param->nBridgePortId >= gswdev->num_of_bridge_port) {
-		pr_err("nBridgePortId %d is out of range [num_of_bridge_port supported =%d]\n",
-		       param->nBridgePortId, (gswdev->num_of_bridge_port - 1));
 		ret = GSW_statusErr;
 		goto UNLOCK_AND_RETURN;
 	}
@@ -21907,7 +21902,6 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 	/*Both ingress/egress states must be same
 	 if not equal return error*/
 	if (IngressStpState != EgressStpState) {
-		pr_err("IngressStpState != EgressStpState");
 		ret = GSW_statusErr;
 		goto UNLOCK_AND_RETURN;
 	}
@@ -21961,7 +21955,6 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 					gswdev->brdgeconfig_idx[param->nBridgeId].IndexInUsageCnt++;
 				}
 			} else {
-				pr_err("gswdev->brdgeconfig_idx[param->nBridgeId].IndexInUse not in use\n");
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
@@ -21997,7 +21990,6 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 			FirstIdx = param->nIngressExtendedVlanBlockId;
 
 			if (FirstIdx >= gswdev->num_of_extendvlan) {
-				pr_err("in FirstIdx %d >= gswdev->num_of_egvlan %d\n", FirstIdx, gswdev->num_of_extendvlan);
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
@@ -22006,7 +21998,6 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 			  Since it will be marked as InUse during allocation.
 			*/
 			if (!gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUse) {
-				pr_err("!gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUse\n");
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
@@ -22016,7 +22007,6 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 			*/
 			if (gswdev->extendvlan_idx.vlan_idx[FirstIdx].VlanBlockId
 			    != param->nIngressExtendedVlanBlockId) {
-				pr_err("VlanBlockId != param->nIngressExtendedVlanBlockId\n");
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
@@ -22045,8 +22035,8 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 			/*Set Last Index of the Block*/
 			tbl_prog_brdgeport_ingress.val[2] &= ~(0x3FF);
 			tbl_prog_brdgeport_ingress.val[2] |= ((LastIdx - 1) & 0x3FF);
-			pr_err("\nBridge port ExVlan FirstIdx = %d\n", FirstIdx);
-			pr_err("Bridge port ExVlan LastIdx  = %d\n", LastIdx - 1);
+			pr_debug("Bridge port ExVlan FirstIdx = %d\n", FirstIdx);
+			pr_debug("Bridge port ExVlan LastIdx  = %d\n", LastIdx - 1);
 
 			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
 				/*Usage count will be incremented only once during vlan blk assignment
@@ -22099,7 +22089,6 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 			FirstIdx = param->nEgressExtendedVlanBlockId;
 
 			if (FirstIdx >= gswdev->num_of_extendvlan) {
-				pr_err("FirstIdx >= gswdev->num_of_egvlan\n");
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
@@ -22108,7 +22097,6 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 			  Since it will be marked as InUse during allocation.
 			*/
 			if (!gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUse) {
-				pr_err("!gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUse\n");
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
@@ -22118,7 +22106,6 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 			*/
 			if (gswdev->extendvlan_idx.vlan_idx[FirstIdx].VlanBlockId
 			    != param->nEgressExtendedVlanBlockId) {
-				pr_err("VlanBlockId!= param->nEgressExtendedVlanBlockId\n");
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
@@ -22791,7 +22778,6 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 			*/
 			if (gswdev->vlanfilter_idx.filter_idx[FirstIdx].FilterBlockId
 			    != param->nIngressVlanFilterBlockId) {
-				pr_err("FilterBlockId != param->nIngressVlanFilterBlockId\n");
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
@@ -22906,7 +22892,6 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 			FirstIdx = param->nEgressVlanFilter1BlockId;
 
 			if (FirstIdx > gswdev->num_of_vlanfilter) {
-				pr_err("FirstIdx > gswdev->num_of_vlanfilter\n");
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
@@ -22915,7 +22900,6 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 			  Since it will be marked as InUse during allocation.
 			*/
 			if (!gswdev->vlanfilter_idx.filter_idx[FirstIdx].IndexInUse) {
-				pr_err("!gswdev->vlanfilter_idx.filter_idx[FirstIdx].IndexInUse\n");
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
@@ -22925,7 +22909,6 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 			*/
 			if (gswdev->vlanfilter_idx.filter_idx[FirstIdx].FilterBlockId
 			    != param->nEgressVlanFilter1BlockId) {
-				pr_err("FilterBlockId != param->nEgressVlanFilter1BlockId\n");
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
@@ -23040,7 +23023,6 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 			FirstIdx = param->nEgressVlanFilter2BlockId;
 
 			if (FirstIdx > gswdev->num_of_vlanfilter) {
-				pr_err("FirstIdx > gswdev->num_of_vlanfilter\n");
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
@@ -23049,7 +23031,6 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 			  Since it will be marked as InUse during allocation.
 			*/
 			if (!gswdev->vlanfilter_idx.filter_idx[FirstIdx].IndexInUse) {
-				pr_err("!gswdev->vlanfilter_idx.filter_idx[FirstIdx].IndexInUse\n");
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
@@ -23059,7 +23040,6 @@ GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
 			*/
 			if (gswdev->vlanfilter_idx.filter_idx[FirstIdx].FilterBlockId
 			    != param->nEgressVlanFilter2BlockId) {
-				pr_err("FilterBlockId != param->nEgressVlanFilter2BlockId\n");
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
@@ -23891,7 +23871,6 @@ GSW_return_t GSW_CtpPortConfigSet(void *cdev, GSW_CTP_portConfig_t *param)
 
 	/*Checking based on number of logical port*/
 	if (param->nLogicalPortId >= gswdev->tpnum) {
-		pr_err("nLogicalPortId %d  >=  gswdev->pnum %d\n", param->nLogicalPortId, gswdev->pnum);
 		ret = GSW_statusErr;
 		goto UNLOCK_AND_RETURN;
 	}
@@ -23968,9 +23947,6 @@ GSW_return_t GSW_CtpPortConfigSet(void *cdev, GSW_CTP_portConfig_t *param)
 
 	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_BRIDGE_PORT_ID) {
 		if (param->nBridgePortId >= gswdev->num_of_bridge_port) {
-			pr_err("nBridgePortId (%i) >= num_of_bridge_port (%i)\n",
-			       param->nBridgePortId,
-			       gswdev->num_of_bridge_port);
 			ret = GSW_statusErr;
 			goto UNLOCK_AND_RETURN;
 		}
@@ -24061,7 +24037,6 @@ GSW_return_t GSW_CtpPortConfigSet(void *cdev, GSW_CTP_portConfig_t *param)
 			FirstIdx = param->nIngressExtendedVlanBlockId;
 
 			if (FirstIdx > gswdev->num_of_extendvlan) {
-				pr_err("FirstIdx %d > gswdev->num_of_extendvlan %d\n", FirstIdx, gswdev->num_of_egvlan);
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
@@ -24070,7 +24045,6 @@ GSW_return_t GSW_CtpPortConfigSet(void *cdev, GSW_CTP_portConfig_t *param)
 			  Since it will be marked as InUse during allocation.
 			*/
 			if (!gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUse) {
-				pr_err("Not in use gswdev->extendvlan_idx.vlan_idx[%d].IndexInUse\n", FirstIdx);
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
@@ -24080,8 +24054,6 @@ GSW_return_t GSW_CtpPortConfigSet(void *cdev, GSW_CTP_portConfig_t *param)
 			*/
 			if (gswdev->extendvlan_idx.vlan_idx[FirstIdx].VlanBlockId
 			    != param->nIngressExtendedVlanBlockId) {
-				pr_err("gswdev->extendvlan_idx.vlan_idx[FirstIdx].VlanBlockId != param->nIngressExtendedVlanBlockId\n");
-				pr_err("param->nIngressExtendedVlanBlockId = %d\n", param->nIngressExtendedVlanBlockId);
 				ret = GSW_statusErr;
 				goto UNLOCK_AND_RETURN;
 			}
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
index bbf3379be721..f11f1bf2619b 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
@@ -1510,9 +1510,7 @@ int gsw_pmicro_code_init_f24s(void *cdev)
 		return GSW_statusErr;
 	}
 
-	printk("PCE f24s micro-code init\n");
 	/* Disable all physical port  */
-
 	for (j = 0; j < gswdev->pnum; j++) {
 		printk("gswdev->pnum =%d j= %d\n", gswdev->pnum, j);
 		gsw_w32(cdev, (SDMA_PCTRL_PEN_OFFSET + (j * 0x6)),
@@ -1592,8 +1590,6 @@ int gsw_pmicro_code_init(void *cdev)
 	else
 		no_ports = gswdev->pnum;
 
-	pr_debug("Enter PCE micro-code init\n");
-
 	/* Disable all physical port  */
 	for (j = 0; j < no_ports; j++) {
 		gsw_w32(cdev, (FDMA_PCTRL_EN_OFFSET + (j * 0x6)),
@@ -1695,7 +1691,6 @@ int gsw_pmicro_code_init(void *cdev)
 	gsw_w32(cdev, BM_QUEUE_GCTRL_GL_MOD_OFFSET, BM_QUEUE_GCTRL_GL_MOD_SHIFT,
 		Gl_Mod_Size, 0);
 
-	pr_debug("Exit PCE micro-code init\n");
 	return GSW_statusOk;
 }
 
@@ -1722,7 +1717,7 @@ int pce_action_delete(void *cdev, ltq_pce_table_t *pthandle, u32 index)
 	if (ptbl.valid == 1) {
 		if (((ptbl.val[0] >> 1) & 0x1)  && (gswdev->gipver == LTQ_GSWIP_3_0)) {
 			u32 index = (ptbl.val[2] & 0x3F);
-			pr_err("\n VLAN action delete at % index in %s", index, __func__);
+			pr_debug("\n VLAN action delete at % index in %s", index, __func__);
 
 			if (pthandle->pce_sub_tbl.vlan_act_tbl_cnt[index] > 0)
 				pthandle->pce_sub_tbl.vlan_act_tbl_cnt[index]--;
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_gphy_fw.c b/drivers/net/ethernet/lantiq/switch-api/gsw_gphy_fw.c
index 8937438a5811..d667bb2ed91b 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_gphy_fw.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_gphy_fw.c
@@ -1135,7 +1135,8 @@ static int gphy_rmon_poll_thread(void *arg)
 	int port_tx_prev[NUM_OF_PORTS] = {0, 0, 0, 0, 0, 0};
 	GSW_RMON_Port_cnt_t param;
 	GSW_portLinkCfg_t param_link;
-	printk(KERN_INFO "start %p ..\n", current);
+
+	pr_debug("start %p ..\n", current);
 	allow_signal(SIGKILL);
 
 	while (!kthread_should_stop()) {
@@ -1216,7 +1217,7 @@ int AR10_F2_GPHY_LED_init(void)
 				   "gphy_rmon_poll_thread");
 
 	if (!IS_ERR(gphy_rmon_poll_thread_id)) {
-		printk(KERN_EMERG "GPHY RMON poll thread created..\n");
+		pr_debug("GPHY RMON poll thread created..\n");
 		wake_up_process(gphy_rmon_poll_thread_id);
 	}
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_init.c b/drivers/net/ethernet/lantiq/switch-api/gsw_init.c
index 2cd469571239..40050e3d27e7 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_init.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_init.c
@@ -963,13 +963,9 @@ int ltq_gsw_api_register(struct platform_device *pdev)
 
 	if (device_id == 1) {
 		addr_gswr = devm_ioremap_resource(&pdev->dev, memres);
-		pr_debug("addr_gswr = 0x%p\n", addr_gswr);
 
 		if (IS_ERR(addr_gswr))
 			return PTR_ERR(addr_gswr);
-
-		pr_err("%s:%s:%d (Register r base:0x%p)\n",
-		       __FILE__, __func__, __LINE__, addr_gswr);
 	}
 
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h
index f12371fc43e4..67c6a0ebce57 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h
@@ -196,7 +196,7 @@ FILE *get_fp(void);
 #define mac_dbg printf
 #endif
 #else
-#define mac_printf printk
+#define mac_printf pr_debug
 #define mac_dbg pr_debug
 #endif
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mac_api.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mac_api.c
index ecae66d1f3e4..96abd77a03d9 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mac_api.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mac_api.c
@@ -98,8 +98,6 @@ int xgmac_disable_tx_flow_ctl(void *pdev)
 	reg_val = XGMAC_RGRD(pdata, MAC_TX_FCR);
 
 	if (MAC_GET_VAL(reg_val, MAC_TX_FCR, TFE) != 0) {
-		mac_dbg("XGMAC %d: Disable TX Flow Control\n",
-			pdata->mac_idx);
 		MAC_SET_VAL(reg_val, MAC_TX_FCR, TFE, 0);
 		XGMAC_RGWR(pdata, MAC_TX_FCR, reg_val);
 	}
@@ -491,12 +489,8 @@ int xgmac_set_mac_address(void *pdev, u8 *mac_addr)
 	/* Since 16 bits only need to check, not checking the previous value */
 	XGMAC_RGWR(pdata, MAC_MACA0HR, mac_addr_hi);
 
-	if (XGMAC_RGRD(pdata, MAC_MACA0LR) != mac_addr_lo) {
-		mac_dbg("XGMAC %d: Setting mac_addr as %08x%04x\n",
-			pdata->mac_idx,  mac_addr_lo,
-			(mac_addr_hi & 0x0000FFFF));
+	if (XGMAC_RGRD(pdata, MAC_MACA0LR) != mac_addr_lo)
 		XGMAC_RGWR(pdata, MAC_MACA0LR, mac_addr_lo);
-	}
 
 	return 0;
 }
