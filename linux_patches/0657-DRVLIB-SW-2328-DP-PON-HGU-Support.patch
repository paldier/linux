From 6f8173cf6918521e7a58b6c1436a3a728a11a3e9 Mon Sep 17 00:00:00 2001
From: thampan <joby.thampan@intel.com>
Date: Fri, 24 May 2019 12:01:33 +0800
Subject: [PATCH] DRVLIB_SW-2328: DP PON HGU Support

---
 drivers/net/datapath/dpm/gswip31/datapath_gswip.c  |  9 +++----
 drivers/net/datapath/dpm/gswip31/datapath_misc.c   | 29 ++++++++++++++++++++--
 drivers/net/datapath/dpm/gswip31/datapath_tx.c     |  5 ++++
 .../net/ethernet/lantiq/switch-api/gsw_defconf.c   | 14 ++++++++---
 include/net/datapath_api.h                         |  2 ++
 5 files changed, 48 insertions(+), 11 deletions(-)

diff --git a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
index 445603d4fdf4..822fbc1050f3 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
@@ -64,6 +64,7 @@ static struct ctp_assign ctp_assign_info[] = {
 		GSW_LOGICAL_PORT_OTHER, 1, 8, 0xF, CQE_LU_MODE2, 1},
 	{DP_F_FAST_ETH_LAN, GSW_LOGICAL_PORT_OTHER, 1, 8, 0xF, CQE_LU_MODE2, 1},
 #endif
+	{DP_F_VUNI, GSW_LOGICAL_PORT_8BIT_WLAN, 2, 8, 0xF, CQE_LU_MODE2, 1},
 	{DP_F_FAST_WLAN, GSW_LOGICAL_PORT_8BIT_WLAN, 16, 8, 0xF, CQE_LU_MODE2, 1},
 	{DP_F_FAST_WLAN_EXT, GSW_LOGICAL_PORT_9BIT_WLAN, 8, 9, 0x7,
 		CQE_LU_MODE2, 1}
@@ -326,13 +327,11 @@ int dp_pmac_set_31(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 			egcfg.nTrafficClass = i;
 			egcfg.nFlowIDMsb = j;
 			egcfg.nBslTrafficClass = i;
-
-			memset(&pmac_glb, 0, sizeof(pmac_glb));
-			gsw_core_api((dp_gsw_cb)gswr_r->gsw_pmac_ops
-				     .Pmac_Gbl_CfgGet, gswr_r, &pmac_glb);
-			egcfg.bProcFlagsSelect = pmac_glb.bProcFlagsEgCfgEna;
+			egcfg.bProcFlagsSelect = 1;
 			DP_DEBUG(DP_DBG_FLAG_DBG, "bProcFlagsSelect=%u\n",
 				 egcfg.bProcFlagsSelect);
+			gsw_core_api((dp_gsw_cb)gswr_r->gsw_pmac_ops
+				     .Pmac_Eg_CfgGet, gswr_r, &egcfg);
 
 			/*update egcfg and write back to gsw */
 			if (pmac_cfg->eg_pmac_flags & EG_PMAC_F_FCS)
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_misc.c b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
index 9c3a855675fa..9b388094be70 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
@@ -197,6 +197,15 @@ static void init_dma_pmac_template(int portid, u32 flags)
 		dp_info->dma1_mask_template[TEMPL_OTHERS].field.enc = 0;
 		dp_info->dma1_mask_template[TEMPL_OTHERS].field.dec = 0;
 		dp_info->dma1_mask_template[TEMPL_OTHERS].field.mpe2 = 0;
+	} else if (flags & DP_F_VUNI) {
+		dp_info->pmac_template[TEMPL_NORMAL].igp_msb = portid;
+		SET_PMAC_IGP_EGP(&dp_info->pmac_template[TEMPL_NORMAL], portid);
+		dp_info->dma0_template[TEMPL_NORMAL].field.redir = 0;
+		dp_info->dma0_mask_template[TEMPL_NORMAL].field.redir = 0;
+		dp_info->dma1_template[TEMPL_NORMAL].field.ep = portid;
+		dp_info->dma1_template[TEMPL_NORMAL].field.ip = portid;
+		dp_info->dma1_mask_template[TEMPL_NORMAL].field.mpe2 = 0;
+		dp_info->dma1_template[TEMPL_NORMAL].field.mpe2 = 1;
 	} else if (flags & DP_F_FAST_WLAN) {
 		/* WLAN block must put after DSL/DIRECTLINK block
 		 * since all ACA device in GRX500 is using WLAN flag wrongly
@@ -1542,6 +1551,7 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 	struct dp_subif_info *sif;
 	struct hal_priv *priv = HAL(inst);
 	int q_flag = 0;
+	int qid;
 
 	if (!data || !data->subif_data) {
 		PR_ERR("data NULL or subif_data NULL\n");
@@ -1771,6 +1781,21 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 	sif->cqm_deq_port = q_port.cqe_deq;
 	sif->cqm_port_idx = deq_port_idx;
 
+	qid = q_port.qid;
+	if (data->subif_data->flag_ops & DP_SUBIF_VANI) {
+		lookup_f &= ~CBM_QUEUE_MAP_F_MPE2_DONTCARE;
+		lookup_f |= CBM_QUEUE_MAP_F_SUBIF_DONTCARE;
+		lookup.mpe2 = 0;
+		/* Map to CPU Q */
+		qid = get_dp_port_info(inst, 0)->subif_info[0].qid;
+	} else if (port_info->alloc_flags & DP_F_VUNI) {
+		/* Map to GSWIP */
+		lookup_f &= ~CBM_QUEUE_MAP_F_MPE2_DONTCARE;
+		lookup_f &= ~CBM_QUEUE_MAP_F_MPE1_DONTCARE;
+		lookup_f |= CBM_QUEUE_MAP_F_SUBIF_DONTCARE;
+		lookup.mpe2 = 1;
+		lookup.mpe1 = 0;
+	}
 	/* Map this port's lookup to its 1st queue only */
 	//lookup.mode = get_dp_port_info(inst, portid)->cqe_lu_mode; /*no need */
 	lookup.ep = portid;
@@ -1782,13 +1807,13 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 	    (port_info->cqe_lu_mode == CQE_LU_MODE0))
 		lookup_f |= CBM_QUEUE_MAP_F_SUBIF_DONTCARE;
 	cbm_queue_map_set(dp_port_prop[inst].cbm_inst,
-			  q_port.qid,
+			  qid,
 			  &lookup,
 			  lookup_f);
 	DP_DEBUG(DP_DBG_FLAG_QOS,
 		 "%s %s=%d %s=%d %s=%d %s=%d %s=0x%x %s=0x%x(%d)\n",
 		 "cbm_queue_map_set",
-		 "qid", q_port.qid,
+		 "qid", qid,
 		 "for dp_port", lookup.ep,
 		 "num_subif", port_info->num_subif,
 		 "lu_mode", port_info->cqe_lu_mode,
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_tx.c b/drivers/net/datapath/dpm/gswip31/datapath_tx.c
index 2d8ddde95a6c..86819e6323cd 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_tx.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_tx.c
@@ -343,6 +343,11 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 							dp_info);
 			DP_CB(inst, set_pmac_subif)(&pmac, rx_subif->subif);
 		}
+	}  else if (dp_info->alloc_flags & DP_F_VUNI) {
+		DP_CB(inst, get_dma_pmac_templ)(TEMPL_NORMAL, &pmac,
+						desc_0, desc_1,
+						dp_info);
+		DP_CB(inst, set_pmac_subif)(&pmac, rx_subif->subif);
 	} else { /*normal directpath: always w/ pmac */
 		if (unlikely(tx_chksum_flag)) {
 			DP_CB(inst, get_dma_pmac_templ)(TEMPL_CHECKSUM,
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c b/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c
index 929b0b8798a8..10e4ae186bff 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c
@@ -13,7 +13,7 @@
 #define PMAC0_TX_DMACHID_START	0
 #define PMAC0_TX_DMACHID_END	16
 #define PMAC1_TX_DMACHID_START	0
-#define PMAC1_TX_DMACHID_END	0
+#define PMAC1_TX_DMACHID_END	1 /* Using a reserved DMA2 TX for PON-HGU */
 
 #define PMAC0_DST_PRT_START	0
 #define PMAC0_DST_PRT_END	11
@@ -234,8 +234,8 @@ int gsw_misc_config(struct core_ops *ops)
 	/* Ignore Undersized frames and forward to CPU for the MAC ports
 	 * MAC logical ports start from 2
 	 */
-	for (i = 0; i < gswdev->pnum; i++) {
-		reg.nRegAddr = ((SDMA_PRIO_USIGN_OFFSET + (2 * 6)) + (i * 6));
+	for (i = 0; i < gswdev->tpnum; i++) {
+		reg.nRegAddr = (SDMA_PRIO_USIGN_OFFSET + (i * 6));
 		ops->gsw_common_ops.RegisterGet(ops, &reg);
 
 		reg.nData |= (1 << SDMA_PRIO_USIGN_SHIFT);
@@ -337,9 +337,15 @@ static int pmac_ig_cfg(struct core_ops *ops, u8 pmacid, u8 dpu)
 				ig_cfg.bSpIdDefault	= 1;
 			}
 
-			/* The packets has PMAC header for 0, 8 & 16 */
+			/* The packet has PMAC header for 0, 8 & 16 */
 			if ((i % 8) == 0)
 				ig_cfg.bPmacPresent  = 1;
+
+			/* For PON HGU using a reserved DMA2 TX Channel,
+			 * so from CPU packet is entering with PMAC Header through PMAC 1
+			 */
+			if (pmacid == 1)
+				ig_cfg.bPmacPresent  = 1;
 		} else if (dpu == DPU) {
 			/* The packets has PMAC header for all channels */
 			ig_cfg.bPmacPresent  	= 1;
diff --git a/include/net/datapath_api.h b/include/net/datapath_api.h
index 160e1af6f10a..bc5170afd140 100644
--- a/include/net/datapath_api.h
+++ b/include/net/datapath_api.h
@@ -196,6 +196,7 @@ enum DP_F_FLAG {
 	DP_F_DOCSIS   = BIT(15), /*!< For DOCSIS device support */
 	DP_F_CPU      = BIT(16), /*!< For CPU */
 
+	DP_F_VUNI     = BIT(21), /*!< For vUNI device */
 	DP_F_SHARE_RES = BIT(22), /*!< Wave600 multiple radio share same ACA */
 	DP_F_ACA       = BIT(23), /*!< peripheral PCI device via ACA*/
 	DP_F_NON_ACA_PORT = BIT(24), /*!< ACA device but without ACA PORT */
@@ -733,6 +734,7 @@ enum DP_SUBIF_DATA_FLAG {
 				       *  by last call of dp_register_subif_ext
 				       */
 	DP_SUBIF_LCT = BIT(2), /*!< Register as LCT port */
+	DP_SUBIF_VANI = BIT(3), /*!< Register as vANI Subif */
 };
 
 /*! @brief dp_subif_id struct for get_netif_subif */
