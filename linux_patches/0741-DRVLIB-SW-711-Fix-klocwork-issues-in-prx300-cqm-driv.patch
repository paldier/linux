From a269e07c1252388ce441e0f327d20d843f07f2ec Mon Sep 17 00:00:00 2001
From: kavitha3 <k.subramanian@intel.com>
Date: Fri, 26 Jul 2019 11:47:39 +0800
Subject: [PATCH] DRVLIB_SW-711: Fix klocwork issues in prx300 cqm driver

---
 drivers/net/ethernet/lantiq/cqm/cqm_dev.c    | 13 +++++++++----
 drivers/net/ethernet/lantiq/cqm/prx300/cqm.c |  5 ++++-
 2 files changed, 13 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/cqm/cqm_dev.c b/drivers/net/ethernet/lantiq/cqm/cqm_dev.c
index 0bbf9af61766..e9a5ae6fdb84 100644
--- a/drivers/net/ethernet/lantiq/cqm/cqm_dev.c
+++ b/drivers/net/ethernet/lantiq/cqm/cqm_dev.c
@@ -47,8 +47,10 @@ struct device_node *parse_dts(int j, void **pdata, struct resource **res,
 	}
 	*res = kmalloc_array(idx, sizeof(struct resource),
 					 GFP_KERNEL);
-	if (!*res)
+	if (!*res) {
 		pr_info("error allocating memory\n");
+		goto err_free_pdata;
+	}
 	memcpy(*res, resource, (sizeof(struct resource) * idx));
 	cqm_pdata->num_resources = idx;
 	*num_res = idx;
@@ -63,6 +65,8 @@ struct device_node *parse_dts(int j, void **pdata, struct resource **res,
 	cqm_pdata->num_intrs = idx;
 	cqm_pdata->intrs = kmalloc_array(idx, sizeof(unsigned int),
 						   GFP_KERNEL);
+	if (!cqm_pdata->intrs)
+		goto err_free_pdata;
 	memcpy(cqm_pdata->intrs, intr, (sizeof(unsigned int) * idx));
 	cqm_pdata->rcu_reset = of_reset_control_get(node, "cqm");
 	if (IS_ERR(cqm_pdata->rcu_reset))
@@ -85,7 +89,7 @@ struct device_node *parse_dts(int j, void **pdata, struct resource **res,
 
 	if (cqm_pdata->num_pools != pool_size) {
 		pr_err("buff num and buff size mismatch\n");
-		return NULL;
+		goto err_free_pdata;
 	}
 
 	pool_size = 0;
@@ -101,7 +105,7 @@ struct device_node *parse_dts(int j, void **pdata, struct resource **res,
 
 	if (cqm_pdata->num_pools_a1 != pool_size) {
 		pr_err("buff num and buff size mismatch\n");
-		return NULL;
+		goto err_free_pdata;
 	}
 
 	for_each_available_child_of_node(node, cpu_deq_port) {
@@ -129,7 +133,7 @@ struct device_node *parse_dts(int j, void **pdata, struct resource **res,
 	gsw_node = of_find_node_by_name(NULL, "gsw_core");
 	if (!gsw_node) {
 		pr_err("Unable to get node gsw_core\n");
-		return NULL;
+		goto err_free_pdata;
 	}
 	cqm_pdata->gsw_mode = 0;
 	of_property_read_u32(gsw_node, "gsw_mode", &cqm_pdata->gsw_mode);
@@ -137,6 +141,7 @@ struct device_node *parse_dts(int j, void **pdata, struct resource **res,
 
 err_free_pdata:
 	kfree(pdata);
+	kfree(res);
 	return NULL;
 }
 
diff --git a/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c b/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
index c20e2009c847..6470bfa62152 100644
--- a/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
+++ b/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
@@ -4147,7 +4147,10 @@ bool fsqm_check(uint16_t len)
 	head = fsq.head;
 	tail = fsq.tail;
 	dev_info(cqm_ctrl->dev, "start with head: 0x%x tail: 0x%x", head, tail);
-	touched[head] = true;
+	if (head < FSQM_FRM_NUM)
+		touched[head] = true;
+	else
+		return false;
 
 	for (cnt = 0; cnt < (len - 1); cnt++) {
 		next =  cbm_r32(FSQM_LLT_RAM(fsqm, head));
