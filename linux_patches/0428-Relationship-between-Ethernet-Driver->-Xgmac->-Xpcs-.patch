From d603b21ceb1b9feed9001999a835ca17f8cb65b2 Mon Sep 17 00:00:00 2001
From: thampan <joby.thampan@intel.com>
Date: Mon, 17 Dec 2018 11:24:06 +0800
Subject: [PATCH] Relationship between Ethernet Driver -> Xgmac -> Xpcs added

---
 drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c | 58 ++++++++++++++++++------
 drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.h |  1 +
 drivers/net/ethernet/lantiq/xpcs/xpcs.c          | 27 +++--------
 drivers/net/ethernet/lantiq/xpcs/xpcs.h          |  4 +-
 4 files changed, 55 insertions(+), 35 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
index 7cbb276f572d..e80d0dfc819f 100644
--- a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
+++ b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
@@ -260,11 +260,22 @@ int serdes_ethtool_get_link_ksettings(struct net_device *dev,
 				   struct ethtool_link_ksettings *cmd)
 {
 	struct ltq_eth_priv *priv = netdev_priv(dev);
+	struct platform_device *pdev;
+	int ret = 0;
 
-	/* Speed Get in Ethtool */
-	xpcs_ethtool_ksettings_get(priv->xgmac_id, cmd);
-
-	return 0;
+	if (!priv->xpcs_node)
+		return -1;
+	
+	pdev = of_find_device_by_node(priv->xpcs_node);
+	if (pdev) {
+		/* Speed Get in Ethtool */
+		xpcs_ethtool_ksettings_get(&pdev->dev, cmd);
+	} else {		
+		pr_err("Cannot get Xpcs pdev for %s\n",dev->name);
+		ret = -1;
+	}
+	
+	return ret;
 }
 
 int serdes_ethtool_set_link_ksettings(struct net_device *dev,
@@ -272,9 +283,20 @@ int serdes_ethtool_set_link_ksettings(struct net_device *dev,
 {
 	struct ltq_eth_priv *priv = netdev_priv(dev);
 	int ret = 0;
+	struct platform_device *pdev;
+
+	if (!priv->xpcs_node)
+		return -1;
 
 	/* Speed Set in Ethtool */
-	ret = xpcs_ethtool_ksettings_set(priv->xgmac_id, cmd);
+	pdev = of_find_device_by_node(priv->xpcs_node);
+	if (pdev) {
+		/* Speed Get in Ethtool */
+		ret = xpcs_ethtool_ksettings_set(&pdev->dev, cmd);
+	} else {
+		pr_err("Cannot get Xpcs pdev for %s\n",dev->name);
+		ret = -1;
+	}
 
 	return ret;
 }
@@ -1424,7 +1446,7 @@ static int xrx500_of_iface(struct xrx500_hw *hw, struct device_node *iface,
 {
 	struct ltq_eth_priv *priv;
 	struct dp_dev_data dev_data = {0};
-	struct device_node *port;
+	struct device_node *port, *mac_np;
 	const __be32 *wan;
 	u32 dp_dev_port_param, dp_port_id_param, xgmac_id_param;
 	u32 lct_en_param = 0, extra_subif_param = 0;
@@ -1476,14 +1498,24 @@ static int xrx500_of_iface(struct xrx500_hw *hw, struct device_node *iface,
 		return ret;
 	}
 
-	ret = of_property_read_u32(iface, "intel,xgmac-id",
-				   &xgmac_id_param);
-	if (ret < 0) {
-		pr_debug("Property intel,xgmac-id not exist for if %s\n",
-			 name);
-		priv->xgmac_id = -1;
-	} else {
+	priv->xgmac_id = -1;
+
+	mac_np = of_parse_phandle(iface, "mac", 0);	
+	if (mac_np) {
+		ret = of_property_read_u32(mac_np, "mac_idx", &xgmac_id_param);
+		if (ret < 0) {
+			pr_info("ERROR : Property mac_idx not read from DT for if %s\n",
+				name);
+			return ret;
+		}
+
 		priv->xgmac_id = xgmac_id_param;
+		
+		priv->xpcs_node = of_parse_phandle(mac_np, "xpcs", 0);
+		if (!priv->xpcs_node) {
+			pr_info("Cannot get xpcs node\n");
+			return -EINVAL;			
+		}
 	}
 
 	ret = of_property_read_u32(iface, "intel,lct-en",
diff --git a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.h b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.h
index 60646e649cc9..52117b690b33 100644
--- a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.h
+++ b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.h
@@ -66,6 +66,7 @@ struct ltq_eth_priv {
 	s32 f_dp;   /* status for register to datapath*/
 	u32 dp_port_id;
 	int xgmac_id;
+	struct device_node *xpcs_node;
 	struct xrx500_port port[NUM_ETH_INF];
 	int num_port;
 	struct xrx500_hw				*hw;
diff --git a/drivers/net/ethernet/lantiq/xpcs/xpcs.c b/drivers/net/ethernet/lantiq/xpcs/xpcs.c
index 2719ef0bec6c..c008f8707510 100644
--- a/drivers/net/ethernet/lantiq/xpcs/xpcs.c
+++ b/drivers/net/ethernet/lantiq/xpcs/xpcs.c
@@ -47,8 +47,6 @@ static int xpcs_teng_kr_mode(struct xpcs_prv_data *pdata);
 static int xpcs_2p5g_xaui_mode(struct xpcs_prv_data *pdata);
 static int xpcs_synphy_reset_sts(struct xpcs_prv_data *pdata);
 
-struct xpcs_prv_data *priv_data[MAX_XPCS] = {0};
-
 struct xpcs_mode_cfg mode_cfg[MAX_XPCS_MODE] = {
 	{
 		.id = TENG_KR_MODE,
@@ -896,6 +894,7 @@ static int xpcs_parse_dts(struct platform_device *pdev,
 {
 	struct device *dev = &pdev->dev;
 	u32 prop = 0;
+	struct device_node *mac_np;
 
 	(*pdata) = devm_kzalloc(dev, sizeof(pdata), GFP_KERNEL);
 
@@ -911,7 +910,6 @@ static int xpcs_parse_dts(struct platform_device *pdev,
 	/* Retrieve the xpcs mode */
 	if (!device_property_read_u32(dev, XPCS_MODE_NAME, &prop)) {
 		(*pdata)->mode = prop;
-
 		if ((*pdata)->mode >= MAX_XPCS_MODE) {
 			dev_err(dev, "Xpcs mode: %u is invalid\n",
 				(*pdata)->mode);
@@ -936,13 +934,6 @@ static int xpcs_parse_dts(struct platform_device *pdev,
 		return -EINVAL;
 	}
 
-	if (!device_property_read_u32(dev, XPCS_MAC_IDX, &prop)) {
-		(*pdata)->mac_idx = prop;
-	} else {
-		dev_err(dev, "Xpcs conn: cannot get property\n");
-		return -EINVAL;
-	}
-
 	if (!device_property_read_u32(dev, POWER_SAVE_MODE, &prop)) {
 		(*pdata)->power_save = prop;
 	} else {
@@ -975,13 +966,13 @@ static int xpcs_reset(struct device *dev)
 	return 0;
 }
 
-void xpcs_ethtool_ksettings_get(u32 idx,
+void xpcs_ethtool_ksettings_get(struct device *dev,
 				struct ethtool_link_ksettings *cmd)
 {
-	struct xpcs_prv_data *pdata = priv_data[idx];
+	struct xpcs_prv_data *pdata = dev_get_drvdata(dev);
 
 	if (!pdata) {
-		pr_err("XPCS %d is not initialized\n",idx);
+		pr_err("XPCS %s is not initialized\n",pdata->name);
 		return;
 	}
 
@@ -994,15 +985,15 @@ void xpcs_ethtool_ksettings_get(u32 idx,
 }
 EXPORT_SYMBOL(xpcs_ethtool_ksettings_get);
 
-int xpcs_ethtool_ksettings_set(u32 idx,
+int xpcs_ethtool_ksettings_set(struct device *dev,
 			       const struct ethtool_link_ksettings *cmd)
 {
 	u32 speed = cmd->base.speed;
 	u32 mode;
-	struct xpcs_prv_data *pdata = priv_data[idx];
+	struct xpcs_prv_data *pdata = dev_get_drvdata(dev);
 
 	if (!pdata) {
-		pr_err("XPCS %d is not initialized\n",idx);
+		pr_err("XPCS %s is not initialized\n",pdata->name);
 		return -1;
 	}
 	
@@ -1078,8 +1069,6 @@ static int xpcs_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	int ret = XPCS_SUCCESS;
 	struct xpcs_prv_data *pdata;
-	int i = 0;
-	struct reset_control *xpcs_rst;
 
 	if (dev->of_node) {
 		if (xpcs_parse_dts(pdev, &pdata) != XPCS_SUCCESS) {
@@ -1096,8 +1085,6 @@ static int xpcs_probe(struct platform_device *pdev)
 		}
 	}
 
-	priv_data[pdata->mac_idx] = pdata;
-
 	pdata->id = pdev->id;
 	pdata->dev = dev;
 
diff --git a/drivers/net/ethernet/lantiq/xpcs/xpcs.h b/drivers/net/ethernet/lantiq/xpcs/xpcs.h
index c8a22b5f0190..56e9bd0166f1 100644
--- a/drivers/net/ethernet/lantiq/xpcs/xpcs.h
+++ b/drivers/net/ethernet/lantiq/xpcs/xpcs.h
@@ -768,9 +768,9 @@ static inline void XPCS_RGWR(struct xpcs_prv_data *pdata, u32 reg, u32 val)
 	} while (0)
 
 int xpcs_sysfs_init(struct xpcs_prv_data *priv);
-void xpcs_ethtool_ksettings_get(u32 idx,
+void xpcs_ethtool_ksettings_get(struct device *dev,
 				struct ethtool_link_ksettings *cmd);
-int xpcs_ethtool_ksettings_set(u32 idx,
+int xpcs_ethtool_ksettings_set(struct device *dev,
 			       const struct ethtool_link_ksettings *cmd);
 int xpcs_reinit(struct device *dev, u32 mode);
 
