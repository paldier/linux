From aa15156f06339028ca90700c60031a74fb6c7e2d Mon Sep 17 00:00:00 2001
From: arathinx <ayyappanx.rathinam@intel.com>
Date: Wed, 7 Aug 2019 13:15:18 +0800
Subject: [PATCH] DRVLIB_SW-2685: Solution to replace LTQ_ETH_MAX_DATA_LEN in
 ethernet driver

---
 drivers/net/datapath/dpm/datapath_api.c          | 13 +++++++++++++
 drivers/net/ethernet/lantiq/cqm/cbm_wrapper.c    |  9 +++++++++
 drivers/net/ethernet/lantiq/cqm/cqm_common.h     |  1 +
 drivers/net/ethernet/lantiq/cqm/prx300/cqm.c     |  9 +++++++++
 drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c | 15 ++++++---------
 include/net/datapath_api.h                       |  1 +
 include/net/lantiq_cbm_api.h                     |  1 +
 7 files changed, 40 insertions(+), 9 deletions(-)

diff --git a/drivers/net/datapath/dpm/datapath_api.c b/drivers/net/datapath/dpm/datapath_api.c
index 52817b5340a2..804affbee1e9 100644
--- a/drivers/net/datapath/dpm/datapath_api.c
+++ b/drivers/net/datapath/dpm/datapath_api.c
@@ -2344,6 +2344,19 @@ int dp_basic_proc(void)
 	}
 }
 
+/*!
+*@brief get network device's MTU
+*@param[in] dev: network device pointer
+*@param[out] mtu_size: return the MTU value in the specified memory if valid.
+*@Returns DP_SUCCESS on succeed and DP_FAILURE on failure
+*/
+/* This API will be enhanced later based on netdevice */
+int dp_get_mtu_size(struct net_device *dev, u32 *mtu_size)
+{
+	return cbm_get_mtu_size(mtu_size);
+}
+EXPORT_SYMBOL(dp_get_mtu_size);
+
 MODULE_LICENSE("GPL");
 
 static int __init dp_dbg_lvl_set(char *str)
diff --git a/drivers/net/ethernet/lantiq/cqm/cbm_wrapper.c b/drivers/net/ethernet/lantiq/cqm/cbm_wrapper.c
index fb0032d00d7f..8a66f451d2bb 100644
--- a/drivers/net/ethernet/lantiq/cqm/cbm_wrapper.c
+++ b/drivers/net/ethernet/lantiq/cqm/cbm_wrapper.c
@@ -25,6 +25,15 @@ s32 cbm_enable_backpressure(s32 port_id, bool flag)
 }
 EXPORT_SYMBOL(cbm_enable_backpressure);
 
+s32 cbm_get_mtu_size(u32 *mtu_size)
+{
+	if (g_cbm_ops->cbm_get_mtu_size)
+		return g_cbm_ops->cbm_get_mtu_size(mtu_size);
+	else
+		return CBM_FAILURE;
+}
+EXPORT_SYMBOL(cbm_get_mtu_size);
+
 s32 cbm_queue_map_get(int cbm_inst, s32 queue_id, s32 *num_entries,
 		      cbm_queue_map_entry_t **entries, u32 flags)
 {
diff --git a/drivers/net/ethernet/lantiq/cqm/cqm_common.h b/drivers/net/ethernet/lantiq/cqm/cqm_common.h
index 579d0a464843..498251abe869 100644
--- a/drivers/net/ethernet/lantiq/cqm/cqm_common.h
+++ b/drivers/net/ethernet/lantiq/cqm/cqm_common.h
@@ -212,6 +212,7 @@ struct cbm_ops {
 	void (*cbm_setup_DMA_p2p)(void);
 	int (*cbm_turn_on_DMA_p2p)(void);
 	s32 (*cbm_enable_backpressure)(s32 port_id, bool flag);
+	s32 (*cbm_get_mtu_size)(u32 *mtu_size);
 };
 
 static inline void set_val(void __iomem *reg, u32 val, u32 mask, u32 offset)
diff --git a/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c b/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
index 9b808e6b3b7d..c20e2009c847 100644
--- a/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
+++ b/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
@@ -3960,6 +3960,14 @@ static void cqm_rst(struct cqm_data *lpp)
 	cqm_rst_deassert(lpp);
 }
 
+static int cqm_get_mtu_size(u32 *mtu_size)
+{
+	/* Always last pool */
+	*mtu_size = (cqm_ctrl->prx300_pool_size[cqm_ctrl->num_pools - 1] -
+		     BSL_THRES);
+	return CBM_SUCCESS;
+}
+
 static const struct cbm_ops cqm_ops = {
 	.cbm_igp_delay_set = cqm_igp_delay_set,
 	.cbm_igp_delay_get = cqm_igp_delay_get,
@@ -3990,6 +3998,7 @@ static const struct cbm_ops cqm_ops = {
 	.set_lookup_qid_via_index = set_lookup_qid_via_index_prx300,
 	.get_lookup_qid_via_index = get_lookup_qid_via_idx_prx300,
 	.cbm_enable_backpressure = enable_backpressure,
+	.cbm_get_mtu_size = cqm_get_mtu_size,
 };
 
 static const struct of_device_id cqm_prx300_match[] = {
diff --git a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
index c41f4bef522d..bdf0157dbd97 100644
--- a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
+++ b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
@@ -887,10 +887,13 @@ static int ltq_eth_init(struct net_device *dev)
 		 priv->dp_subif.subif, dev->name);
 
 	/* get the minimum MTU and call the change mtu */
-	if( !(dev->mtu > LTQ_ETH_MIN_MTU && dev->mtu < g_soc_data.mtu_limit))
+	dp_get_mtu_size(dev, &g_soc_data.mtu_limit);
+
+	if (!(dev->mtu > LTQ_ETH_MIN_MTU && dev->mtu < g_soc_data.mtu_limit))
 		dev->mtu = g_soc_data.mtu_limit;
 
-	ltq_change_mtu(dev, dev->mtu);
+	if (g_eth_switch_mode != 0)
+		ltq_change_mtu(dev, dev->mtu);
 
 	return 0;
 }
@@ -2209,7 +2212,6 @@ static int ltq_eth_drv_init(struct platform_device *pdev)
 	struct device_node *node = pdev->dev.of_node;
 	struct device_node *mdio_np, *iface_np;
 	struct mii_bus *bus;
-	u32 mtu_limit = 0;
 
 	memset(g_ltq_eth_module, 0, sizeof(g_ltq_eth_module));
 
@@ -2241,12 +2243,7 @@ static int ltq_eth_drv_init(struct platform_device *pdev)
 		ret = 0;
 	}
 
-	of_property_read_u32(node, "lantiq,prx300-mtu-a1",
-			     &mtu_limit);
-	if (!ltq_get_soc_rev() && mtu_limit)
-		g_soc_data.mtu_limit = mtu_limit;
-	else
-		g_soc_data.mtu_limit = LTQ_ETH_MAX_DATA_LEN;
+	g_soc_data.mtu_limit = LTQ_ETH_MAX_DATA_LEN;
 
 	/* bring up the mdio bus */
 	mdio_np = of_find_compatible_node(node, NULL,
diff --git a/include/net/datapath_api.h b/include/net/datapath_api.h
index 666edb8a4650..6dbb4f9c94a7 100644
--- a/include/net/datapath_api.h
+++ b/include/net/datapath_api.h
@@ -1810,5 +1810,6 @@ void dp_register_ops(int inst, enum DP_OPS_TYPE type, void *ops);
  *@return ops pointer if registered, or NULL if not registered
  */
 void *dp_get_ops(int inst, enum DP_OPS_TYPE type);
+int dp_get_mtu_size(struct net_device *dev, u32 *mtu_size);
 
 #endif /*DATAPATH_API_H */
diff --git a/include/net/lantiq_cbm_api.h b/include/net/lantiq_cbm_api.h
index b4c9068dc5de..259f24de53b2 100644
--- a/include/net/lantiq_cbm_api.h
+++ b/include/net/lantiq_cbm_api.h
@@ -1642,6 +1642,7 @@ void reset_deq_counter(uint32_t index);
 int32_t cbm_get_egress_port_info(uint32_t cbm_port, uint32_t *tx_ch,
 				 uint32_t *flags);
 int cbm_buff_resv_bytes_get(int cbm_inst, int size);
+s32 cbm_get_mtu_size(u32 *mtu_size);
 /*
  * cbm_eqm_ctrl_t
  * cbm_dqm_ctrl_t
