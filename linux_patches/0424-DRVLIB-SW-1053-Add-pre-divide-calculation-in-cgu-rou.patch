From 2f555c83171f84e430f1c05cbf5a0e7a720511df Mon Sep 17 00:00:00 2001
From: Peter Harliman Liem <peter.harliman.liem@intel.com>
Date: Wed, 9 Jan 2019 09:46:05 +0800
Subject: [PATCH] DRVLIB_SW-1053 - Add pre-divide calculation in cgu round_rate

We need to consider pre-divide (2.5x) in round_rate. Otherwise
round_rate may fail to retrieve dividers value, and eventually
block clk_set_rate() function.
E.g. in gphy low-power-mode, the freq is set to 25MHz
(divider val 50 before pre-divide). Without pre-divide routine,
set_clk_rate() will fail due to cgu unable to get correct dividers.
---
 drivers/clk/intel/clk-cgu.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/drivers/clk/intel/clk-cgu.c b/drivers/clk/intel/clk-cgu.c
index e6d14dcde51c..8d3e3e54b97d 100644
--- a/drivers/clk/intel/clk-cgu.c
+++ b/drivers/clk/intel/clk-cgu.c
@@ -540,11 +540,18 @@ static long
 intel_clk_ddiv_round_rate(struct clk_hw *hw, unsigned long rate,
 			  unsigned long *prate)
 {
+	struct intel_clk_ddiv *ddiv = to_intel_clk_ddiv(hw);
 	u32 div, ddiv1, ddiv2;
 	u64 rate64 = rate;
 
 	div = DIV_ROUND_CLOSEST_ULL((u64)*prate, rate);
 
+	/* if predivide bit is enabled, modify div by factor of 2.5 */
+	if (intel_get_clk_val(ddiv->map, ddiv->reg, ddiv->shift2, 1)) {
+		div = div * 2;
+		div = DIV_ROUND_CLOSEST_ULL((u64)div, 5);
+	}
+
 	if (div <= 0)
 		return *prate;
 
@@ -557,6 +564,12 @@ intel_clk_ddiv_round_rate(struct clk_hw *hw, unsigned long rate,
 	do_div(rate64, ddiv1);
 	do_div(rate64, ddiv2);
 
+	/* if predivide bit is enabled, modify rounded rate by factor of 2.5 */
+	if (intel_get_clk_val(ddiv->map, ddiv->reg, ddiv->shift2, 1)) {
+		rate64 = rate64 * 2;
+		rate64 = DIV_ROUND_CLOSEST_ULL(rate64, 5);
+	}
+
 	return (unsigned long)rate64;
 }
 
