From 853a6d7c1fb35c7575d932b8d0b924a72a4fd76f Mon Sep 17 00:00:00 2001
From: Peter Harliman Liem <peter.harliman.liem@intel.com>
Date: Thu, 22 Feb 2018 14:28:19 +0800
Subject: [PATCH] Fix address conversion in qspi driver

Existing address format in ltq_spinand & qspi driver is
inconsistent as it somehow uses different endianness, depending
on quad or single mode. Eventually this causes qspi driver
issue if we use single mode.

This change is to make the endianness consistent, hence removing
dependency on quad or single mode. Qspi driver is also modified
to fix bugs that was hidden before and uncovered now.
---
 drivers/mtd/ltq-spinand/ltq_spinand.c | 71 ++++++++++-------------------------
 drivers/spi/spi-cadence-qspi-apb.c    | 39 +++++++------------
 2 files changed, 32 insertions(+), 78 deletions(-)

diff --git a/drivers/mtd/ltq-spinand/ltq_spinand.c b/drivers/mtd/ltq-spinand/ltq_spinand.c
index 8d31432c1bd8..1f36b91ba2bc 100644
--- a/drivers/mtd/ltq-spinand/ltq_spinand.c
+++ b/drivers/mtd/ltq-spinand/ltq_spinand.c
@@ -293,7 +293,6 @@ static int spi_nand_manufacture_init(struct mtd_info *mtd, struct nand_chip *chi
  */
 struct nand_flash_dev * spinand_flash_detect(struct mtd_info *mtd, struct nand_chip *chip)
 {
-	int retval=0;
 	u8 id_data[8];
 	int i;
 	struct nand_flash_dev *type = NULL;
@@ -737,25 +736,15 @@ static int spinand_write_enable(struct spi_device *spi)
  */
 static int spinand_read_page_to_cache(struct spi_device *spi, int page_id)
 {
-	struct mtd_info *mtd = (struct mtd_info *)dev_get_drvdata((const struct device *)&(spi->dev));
-	struct nand_chip *chip = mtd_to_nand(mtd);
-	struct spinand_info *info = (struct spinand_info *)chip->priv;
 	struct spinand_cmd cmd = {0};
 	u16 row;
 
 	row = page_id;
 	cmd.cmd = CMD_READ;
 	cmd.n_addr = 3;
-	if (info->spi->mode & SPI_RX_QUAD) {
-		cmd.addr[2] = (u8) ((page_id & 0xff0000) >> 16);
-		cmd.addr[1] = (u8)((page_id & 0xff00) >> 8);
-		cmd.addr[0] = (u8)(page_id & 0x00ff);
-	} else {
-		cmd.addr[0] = (u8) ((page_id & 0xff0000) >> 16);
-		cmd.addr[1] = (u8)((page_id & 0xff00) >> 8);
-		cmd.addr[2] = (u8)(page_id & 0x00ff);
-	}
-
+	cmd.addr[0] = (u8)(page_id >> 16);
+	cmd.addr[1] = (u8)(page_id >> 8);
+	cmd.addr[2] = (u8)(page_id);
 
 	return spinand_cmd(spi, &cmd);
 }
@@ -797,24 +786,20 @@ static int spinand_read_from_cache(struct spi_device *spi, int page_id,
 	else
 		cmd.cmd = CMD_READ_RDM;
 	cmd.n_addr = 3;
+
+	/* General format is:
+	 * 4-bit mode/plane-select + 12-bit addr + 8-bit dummy.
+	 * Gigadevice, however, requires the dummy to be placed at the
+	 * the first byte instead.
+	 */
 	if (chip->options & GIGADEVICE_DUMMY_TYPE) {
-		if (info->spi->mode & SPI_RX_QUAD) {
-			cmd.addr[2] = 0;
-			cmd.addr[1] = (u8)(column >> 8);
-			cmd.addr[0] = (u8)column;
-		} else {
-			cmd.addr[0] = 0;
-			cmd.addr[1] = (u8)(column >> 8);
-			cmd.addr[2] = (u8)column;
-		}
-	} else if (info->spi->mode & SPI_RX_QUAD) {
-		cmd.addr[0] = 0;
+		cmd.addr[0] = 0xff;
 		cmd.addr[1] = (u8)(column >> 8);
 		cmd.addr[2] = (u8)column;
 	} else {
-		cmd.addr[0] = (u8)((column & 0xff00) >> 8);
-		cmd.addr[1] = (u8)(column & 0x00ff);
-		cmd.addr[2] = (u8)(0xff);
+		cmd.addr[0] = (u8)(column >> 8);
+		cmd.addr[1] = (u8)(column);
+		cmd.addr[2] = 0xff;
 	}
 
 	cmd.n_dummy = 0;
@@ -981,23 +966,14 @@ static int spinand_program_data_to_cache(struct spi_device *spi,
  */
 static int spinand_program_execute(struct spi_device *spi, int page_id)
 {
-	struct mtd_info *mtd = (struct mtd_info *)dev_get_drvdata((const struct device *)&(spi->dev));
-	struct nand_chip *chip = mtd_to_nand(mtd);
-	struct spinand_info *info = (struct spinand_info *)chip->priv;
 	struct spinand_cmd cmd = {0};
 
 	/* NOTE: this is changed so you can write above 128 MB */
 	cmd.cmd = CMD_PROG_PAGE_EXC;
 	cmd.n_addr = 3;
-	if (info->spi->mode & SPI_TX_QUAD) {
-		cmd.addr[2] = (u8)((page_id & 0xff0000) >> 16);
-		cmd.addr[1] = (u8)((page_id & 0xff00) >> 8);
-		cmd.addr[0] = (u8)(page_id & 0x00ff);
-	} else {
-		cmd.addr[0] = (u8)((page_id & 0xff0000) >> 16);
-		cmd.addr[1] = (u8)((page_id & 0xff00) >> 8);
-		cmd.addr[2] = (u8)(page_id & 0x00ff);
-	}
+	cmd.addr[0] = (u8)(page_id >> 16);
+	cmd.addr[1] = (u8)(page_id >> 8);
+	cmd.addr[2] = (u8)(page_id);
 
 	return spinand_cmd(spi, &cmd);
 }
@@ -1089,24 +1065,15 @@ static int spinand_program_page(struct spi_device *spi,
  */
 static int spinand_erase_block_erase(struct spi_device *spi, u32 block_id)
 {
-	struct mtd_info *mtd = (struct mtd_info *)dev_get_drvdata((const struct device *)&(spi->dev));
-	struct nand_chip *chip = mtd_to_nand(mtd);
-	struct spinand_info *info = (struct spinand_info *)chip->priv;
 	struct spinand_cmd cmd = {0};
 	u16 row;
 
 	row = block_id;
 	cmd.cmd = CMD_ERASE_BLK;
 	cmd.n_addr = 3;
-	if (info->spi->mode & SPI_TX_QUAD) {
-		cmd.addr[2] = (u8)((block_id & 0xff0000) >> 16);
-		cmd.addr[1] = (u8)((block_id & 0xff00) >> 8);
-		cmd.addr[0] = (u8)(block_id & 0x00ff);
-	} else {
-		cmd.addr[0] = (u8)((block_id & 0xff0000) >> 16);
-		cmd.addr[1] = (u8)((block_id & 0xff00) >> 8);
-		cmd.addr[2] = (u8)(block_id & 0x00ff);
-	}
+	cmd.addr[0] = (u8)(block_id >> 16);
+	cmd.addr[1] = (u8)(block_id >> 8);
+	cmd.addr[2] = (u8)(block_id);
 
 	return spinand_cmd(spi, &cmd);
 }
diff --git a/drivers/spi/spi-cadence-qspi-apb.c b/drivers/spi/spi-cadence-qspi-apb.c
index db344ac29653..a49c9fb1e0e1 100644
--- a/drivers/spi/spi-cadence-qspi-apb.c
+++ b/drivers/spi/spi-cadence-qspi-apb.c
@@ -66,6 +66,10 @@ void SwapBytes(void *pv, unsigned int n)
 		p[hi] = tmp;
 	}
 }
+
+/**
+ * Convert address buffer into word format (MSB first).
+ */
 static unsigned int cadence_qspi_apb_cmd2addr(const unsigned char *addr_buf,
 	unsigned int addr_width)
 {
@@ -75,6 +79,12 @@ static unsigned int cadence_qspi_apb_cmd2addr(const unsigned char *addr_buf,
 	debug_print("[%s] addr_buf[0]=0x%x addr_buf[1]=0x%x addr_buf[2]=0x%x "
 		"addr_buf[3]=0x%x addr_width %d\n", __func__,
 		addr_buf[0], addr_buf[1], addr_buf[2], addr_buf[3], addr_width);
+
+	if (addr_width > 4) {
+		pr_err("Invalid address width %u\n", addr_width);
+		return 0;
+	}
+
 	for (i = 0; i < addr_width; i++) {
 		addr = addr << 8;
 		addr |= addr_buf[i];
@@ -82,17 +92,6 @@ static unsigned int cadence_qspi_apb_cmd2addr(const unsigned char *addr_buf,
 
 	return addr;
 }
-static uint32_t qspi_create_address(const u8 *address, unsigned int cmdlen)
-{
-	uint32_t addr_value = 0;
-
-	addr_value = address[2] << 16 | address[1] << 8 |
-						address[0];
-	if (cmdlen > 3)
-		addr_value |= (address[3] << 24);
-
-	return addr_value;
-}
 
 void disable_qspi_direct_access(void *reg_base)
 {
@@ -381,8 +380,7 @@ static int cadence_qspi_apb_command_read(void *reg_base,
 		reg |= ((addrlen - 1) & CQSPI_REG_CMDCTRL_ADD_BYTES_MASK)
 			<< CQSPI_REG_CMDCTRL_ADD_BYTES_LSB;
 		/* Get address */
-		addr_value = qspi_create_address(&addrbuf[0],
-			addrlen >= 5 ? 4 : 3);
+		addr_value = cadence_qspi_apb_cmd2addr(&addrbuf[0], addrlen);
 		CQSPI_WRITEL(addr_value, reg_base + CQSPI_REG_CMDADDRESS);
 		debug_print("[%s] CQSPI_REG_CMDADDRESS=0x%x\n", __func__, addr_value);
 	}
@@ -478,8 +476,6 @@ static int cadence_qspi_apb_command_write(void *reg_base,
 			debug_print("[%s] CQSPI_REG_CMDWRITEDATAUPPER=0x%x\n", __func__, data);
 		}
 	}
-	if (addrlen > 3)
-		addrlen = 3;
 	if (addrlen) {
 		/* Command with address */
 		reg |= (0x1 << CQSPI_REG_CMDCTRL_ADDR_EN_LSB);
@@ -487,12 +483,7 @@ static int cadence_qspi_apb_command_write(void *reg_base,
 		reg |= ((addrlen - 1) & CQSPI_REG_CMDCTRL_ADD_BYTES_MASK)
 			<< CQSPI_REG_CMDCTRL_ADD_BYTES_LSB;
 		/* Get address */
-		if ((flash_type == QSPI_FLASH_TYPE_NOR) && (txbuf[0] != MACRONIX_WRSR_CMD))
-			addr_value = cadence_qspi_apb_cmd2addr(&txbuf[1],
-				addrlen >= 5 ? 4 : 3);
-		else
-			addr_value = qspi_create_address(&addrbuf[0],
-				addrlen >= 5 ? 4 : 3);
+		addr_value = cadence_qspi_apb_cmd2addr(&addrbuf[0], addrlen);
 		CQSPI_WRITEL(addr_value, reg_base + CQSPI_REG_CMDADDRESS);
 		debug_print("[%s] CQSPI_REG_CMDADDRESS=0x%x\n", __func__, addr_value);
 	}
@@ -539,11 +530,7 @@ static int cadence_qspi_apb_indirect_read_setup(void *reg_base,
 	CQSPI_WRITEL(ahb_phy_addr, reg_base + CQSPI_REG_INDIRECTTRIGGER);
 	if (addrlen) {
 		/* Get address */
-		if (flash_type == QSPI_FLASH_TYPE_NOR) {
-			addr_value = cadence_qspi_apb_cmd2addr(&addrbuf[0], addr_bytes);
-		} else {
-			addr_value = qspi_create_address(&addrbuf[0], addr_bytes);
-		}
+		addr_value = cadence_qspi_apb_cmd2addr(&addrbuf[0], addr_bytes);
 		CQSPI_WRITEL(addr_value,
 			reg_base + CQSPI_REG_INDIRECTRDSTARTADDR);
 		debug_print("[%s]CQSPI_REG_INDIRECTRDSTARTADDR=0x%x\n", __func__, addr_value);
