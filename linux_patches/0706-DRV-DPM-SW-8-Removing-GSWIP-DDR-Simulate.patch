From 07be55d25fde9fa4cf61fd2cc359b491ffea8a5a Mon Sep 17 00:00:00 2001
From: thampan <joby.thampan@intel.com>
Date: Sun, 21 Jul 2019 22:10:39 +0800
Subject: [PATCH] DRV_DPM_SW-8: Removing GSWIP DDR Simulate

---
 drivers/net/datapath/dpm/Kconfig                   |   7 -
 drivers/net/datapath/dpm/datapath_api.c            |   2 +-
 drivers/net/datapath/dpm/datapath_soc.c            |  14 +-
 drivers/net/datapath/dpm/gswip31/Kconfig           |   9 -
 drivers/net/datapath/dpm/gswip31/Makefile          |   6 +-
 drivers/net/datapath/dpm/gswip31/datapath_gswip.c  |  70 --
 .../datapath/dpm/gswip31/datapath_gswip_simulate.c | 983 ---------------------
 .../datapath/dpm/gswip31/datapath_gswip_simulate.h |  39 -
 drivers/net/datapath/dpm/gswip31/datapath_misc.c   |   7 -
 drivers/net/datapath/dpm/gswip31/datapath_misc.h   |  14 -
 drivers/net/datapath/dpm/gswip32/Kconfig           |   2 +-
 drivers/net/datapath/dpm/gswip32/datapath_gswip.c  |  69 --
 .../datapath/dpm/gswip32/datapath_gswip_simulate.c | 983 ---------------------
 .../datapath/dpm/gswip32/datapath_gswip_simulate.h |  39 -
 drivers/net/datapath/dpm/gswip32/datapath_misc.c   |   7 -
 drivers/net/datapath/dpm/gswip32/datapath_misc.h   |  15 -
 include/net/datapath_api.h                         |   5 +-
 17 files changed, 9 insertions(+), 2262 deletions(-)

diff --git a/drivers/net/datapath/dpm/Kconfig b/drivers/net/datapath/dpm/Kconfig
index 1f555104b496..e7d2409e90bb 100644
--- a/drivers/net/datapath/dpm/Kconfig
+++ b/drivers/net/datapath/dpm/Kconfig
@@ -120,13 +120,6 @@ config INTEL_DATAPATH_PTP1588_SW_WORKAROUND
         ---help---
           PTP1588 Software Workaround
 
-config INTEL_DATAPATH_DDR_SIMULATE_GSWIP31
-	bool "Force PRX300 SOC"
-	default n
-	depends on INTEL_DATAPATH
-	---help---
-	  test prx300 HAL in GRX350 boards
-
 config INTEL_DATAPATH_CPUFREQ
 	bool "Datapath DFS(COC) support"
 	depends on INTEL_DATAPATH && CPU_FREQ
diff --git a/drivers/net/datapath/dpm/datapath_api.c b/drivers/net/datapath/dpm/datapath_api.c
index fc5ba6a48b38..02553f231a4a 100644
--- a/drivers/net/datapath/dpm/datapath_api.c
+++ b/drivers/net/datapath/dpm/datapath_api.c
@@ -187,7 +187,7 @@ int parser_enabled(int ep, struct dma_rx_desc_1 *desc_1)
 	}
 #endif
 
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_SIMULATE_GSWIP32) || \
+#if IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP32) || \
 	IS_ENABLED(CONFIG_X86_INTEL_LGM)
 #else
 	if (!ep)
diff --git a/drivers/net/datapath/dpm/datapath_soc.c b/drivers/net/datapath/dpm/datapath_soc.c
index 25fef9a26913..cc7b2bbf5a14 100644
--- a/drivers/net/datapath/dpm/datapath_soc.c
+++ b/drivers/net/datapath/dpm/datapath_soc.c
@@ -18,35 +18,29 @@
 #include "datapath_instance.h"
 #include "datapath_swdev_api.h"
 
-#if IS_ENABLED(CONFIG_PRX300_CQM)
-#define INTEL_DATAPATH_SOC_PRX300
-#endif
-
 int request_dp(u32 flag)
 {
 	struct dp_inst_info info;
 	int i = 0;
 	u32 mac_ifcnt = gsw_get_mac_subifcnt(0);
 
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_SIMULATE_GSWIP32) || \
-	IS_ENABLED(CONFIG_LGM_CQM)
+#if IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP32)
 	info.type = GSWIP32_TYPE;
 	info.ver = GSWIP32_VER;
 	info.ops[0] = gsw_get_swcore_ops(0);
 	info.ops[1] = gsw_get_swcore_ops(0);
 	info.mac_ops[0] = NULL;
 	info.mac_ops[1] = NULL;
-	for(i = 0; i < mac_ifcnt; i++)
+	for (i = 0; i < mac_ifcnt; i++)
 		info.mac_ops[i + 2] = gsw_get_mac_ops(0, i + 2);
-#elif IS_ENABLED(CONFIG_PRX300_CQM) || \
-	IS_ENABLED(CONFIG_INTEL_DATAPATH_DDR_SIMULATE_GSWIP31) /*testing only */
+#elif IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP31)
 	info.type = GSWIP31_TYPE;
 	info.ver = GSWIP31_VER;
 	info.ops[0] = gsw_get_swcore_ops(0);
 	info.ops[1] = gsw_get_swcore_ops(0);
 	info.mac_ops[0] = NULL;
 	info.mac_ops[1] = NULL;
-	for(i = 0; i < mac_ifcnt; i++)
+	for (i = 0; i < mac_ifcnt; i++)
 		info.mac_ops[i + 2] = gsw_get_mac_ops(0, i + 2);
 #else
 	info.type = GSWIP30_TYPE;
diff --git a/drivers/net/datapath/dpm/gswip31/Kconfig b/drivers/net/datapath/dpm/gswip31/Kconfig
index 5efb5e9abb73..207b5f63ac4c 100644
--- a/drivers/net/datapath/dpm/gswip31/Kconfig
+++ b/drivers/net/datapath/dpm/gswip31/Kconfig
@@ -16,15 +16,6 @@ config INTEL_DATAPATH_HAL_GSWIP31_MIB
 	---help---
 	  It is to aggregate GSWIP-L/R, TMU and driver's MIB counter
 
-config INTEL_DATAPATH_DDR_SIMULATE_GSWIP31
-	bool "Datapath Simulation GSWIP3.1 based on GRX500 board"
-	default n
-	depends on INTEL_DATAPATH_DBG
-	---help---
-		Datapath Debug Tool for GSWIP DDR simulation
-		Only for debugging purpose
-		By default it should be disabled.
-
 config INTEL_DATAPATH_DUMMY_QOS
 	bool "datapath dummy QOS based on slim QOS driver or real QOS API with PRX300_test API"
 	depends on LTQ_PPV4_QOS_SLIM || (LTQ_PPV4_QOS || LTQ_PPV4)
diff --git a/drivers/net/datapath/dpm/gswip31/Makefile b/drivers/net/datapath/dpm/gswip31/Makefile
index 7f9984bf35c9..858a18b9a737 100644
--- a/drivers/net/datapath/dpm/gswip31/Makefile
+++ b/drivers/net/datapath/dpm/gswip31/Makefile
@@ -1,11 +1,7 @@
-ifneq ($(CONFIG_INTEL_DATAPATH_DDR_SIMULATE_GSWIP31),)
-obj-$(CONFIG_INTEL_DATAPATH) += datapath_gswip_simulate.o
-endif
-
 obj-$(CONFIG_INTEL_DATAPATH) += datapath_misc.o datapath_gswip.o datapath_proc.o
 obj-$(CONFIG_INTEL_DATAPATH) += datapath_ppv4.o
 obj-$(CONFIG_INTEL_DATAPATH) += datapath_lookup_proc.o datapath_ppv4_api.o
-obj-$(CONFIG_INTEL_DATAPATH) += datapath_rx.o datapath_tx.o 
+obj-$(CONFIG_INTEL_DATAPATH) += datapath_rx.o datapath_tx.o
 
 ifneq ($(CONFIG_INTEL_DATAPATH_HAL_GSWIP31_MIB),)
 obj-$(CONFIG_INTEL_DATAPATH) += datapath_mib.o
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
index 47f148369148..8dc69d185c21 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
@@ -13,9 +13,6 @@
 #include <net/datapath_api.h>
 #include "../datapath.h"
 #include "datapath_misc.h"
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_DDR_SIMULATE_GSWIP31)
-#include "datapath_gswip_simulate.h"
-#endif
 
 #define GSW_CORE_API(_handle, a, b) ({ \
 	typeof(_handle) (handle) = (_handle); \
@@ -96,72 +93,6 @@ static char *ctp_mode_string(GSW_LogicalPortMode_t type)
 	return "Undef";
 }
 
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_DDR_SIMULATE_GSWIP31)
-GSW_return_t gsw_core_api_ddr_simu31(dp_gsw_cb func, void *ops, void *param)
-{
-	if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_brdgport_ops.BridgePort_Alloc) {
-		return BridgePortAlloc(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_brdgport_ops.BridgePort_ConfigGet) {
-		return BridgePortConfigGet(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_brdgport_ops.BridgePort_ConfigSet) {
-		return BridgePortConfigSet(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_brdgport_ops.BridgePort_Free) {
-		return BridgePortFree(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_brdg_ops.Bridge_Alloc) {
-		return BridgeAlloc(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_brdg_ops.Bridge_ConfigSet) {
-		return BridgeConfigSet(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_brdg_ops.Bridge_ConfigGet) {
-		return BridgeConfigGet(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_brdg_ops.Bridge_Free) {
-		return BridgeFree(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_ctp_ops.CTP_PortAssignmentAlloc) {
-		return CTP_PortAssignmentAlloc
-			(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_ctp_ops.CTP_PortAssignmentFree) {
-		return CTP_PortAssignmentFree
-			(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_ctp_ops.CTP_PortAssignmentSet) {
-		return CTP_PortAssignmentSet
-			(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_ctp_ops.CTP_PortAssignmentGet) {
-		return CTP_PortAssignmentGet
-			(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_ctp_ops.CTP_PortConfigSet) {
-		return CtpPortConfigSet(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_ctp_ops.CTP_PortConfigGet) {
-		return CtpPortConfigGet(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-		   gsw_swmac_ops.MAC_TableEntryAdd) {
-		return MacTableAdd(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-		   gsw_swmac_ops.MAC_TableEntryRead) {
-		return MacTableRead(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-		   gsw_swmac_ops.MAC_TableEntryRemove) {
-		return MacTableRemove(param);
-	}  else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-		    gsw_swmac_ops.MAC_TableEntryQuery) {
-		return MacTableQuery(param);
-	}
-	return GSW_SIMUTE_DDR_NOT_MATCH;
-}
-#endif
-
 /*This API is only for GSWIP-R PMAC modification, not for GSWIP-L */
 int dp_pmac_set_31(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 {
@@ -466,7 +397,6 @@ int dp_pmac_set_31(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 #endif
 			gsw_core_api((dp_gsw_cb)gswr_r->gsw_pmac_ops
 				     .Pmac_Eg_CfgSet, gswr_r, &egcfg);
-			;
 		}
 	}
 
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_gswip_simulate.c b/drivers/net/datapath/dpm/gswip31/datapath_gswip_simulate.c
deleted file mode 100644
index 2195b295426a..000000000000
--- a/drivers/net/datapath/dpm/gswip31/datapath_gswip_simulate.c
+++ /dev/null
@@ -1,983 +0,0 @@
-/*
- * Copyright (C) Intel Corporation
- * Author: Shao Guohua <guohua.shao@intel.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- */
-
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/etherdevice.h>
-#include <net/datapath_api.h>
-#include "../datapath.h"
-#include "datapath_misc.h"
-
-#define MAX_CPT_PORT 288
-u8 ctp_assign_f[MAX_CPT_PORT] = {0};
-GSW_CTP_portAssignment_t ctp_assign[MAX_CPT_PORT] = {0};
-
-#define MAX_PMAPPER 2336
-u8 pmapper_f[MAX_PMAPPER] = {0};
-
-u32  Pmapper_Alloc(int size)
-{
-	u32 i, j;
-
-	for (i = 1; i < MAX_PMAPPER; i++) {
-		if (pmapper_f[i])
-			continue;
-		for (j = 0; j < size; j++)
-			if (pmapper_f[i + j])
-				continue;
-
-		for (j = 0; j < size; j++)
-			pmapper_f[i] = 1;
-		return i;
-	}
-	return -1;
-}
-
-int Pmapper_Free(u32 offset, int size)
-{
-	int i;
-
-	for (i = 0; i < size; i++)
-		pmapper_f[i + offset] = 0;
-	return -1;
-}
-
-int CTP_PortAssignmentAlloc(GSW_CTP_portAssignment_t *param)
-{
-	int i, j;
-
-	for (i = 1; i < MAX_CPT_PORT; i++) {
-		if (ctp_assign_f[i])
-			continue;
-		for (j = 0; j < param->nNumberOfCtpPort; j++)
-			if (ctp_assign_f[i + j])
-				continue;
-		param->nFirstCtpPortId = i;
-		for (j = 0; j < param->nNumberOfCtpPort; j++) {
-			ctp_assign_f[i + j] = 1;
-			ctp_assign[i + j].eMode = param->eMode;
-			ctp_assign[i + j].nBridgePortId =
-				param->nBridgePortId;
-			ctp_assign[i + j].nFirstCtpPortId =
-				param->nFirstCtpPortId;
-			ctp_assign[i + j].nLogicalPortId =
-				param->nLogicalPortId;
-			ctp_assign[i + j].nNumberOfCtpPort =
-				param->nNumberOfCtpPort;
-		}
-		return 0;
-	}
-	return -1;
-}
-
-int CTP_PortAssignmentFree(GSW_CTP_portAssignment_t *param)
-{
-	int i;
-
-	for (i = 0; i < param->nNumberOfCtpPort; i++)
-		ctp_assign_f[i + param->nNumberOfCtpPort] = 0;
-	return 0;
-}
-
-int CTP_PortAssignmentSet(GSW_CTP_portAssignment_t *param)
-{
-	u32 idx = param->nFirstCtpPortId;
-	int i;
-
-	for (i = 0; i < param->nNumberOfCtpPort; i++) {
-		ctp_assign[idx + i].eMode = param->eMode;
-		ctp_assign[idx + i].nBridgePortId = param->nBridgePortId;
-		ctp_assign[idx + i].nFirstCtpPortId = param->nFirstCtpPortId;
-		ctp_assign[idx + i].nLogicalPortId = param->nLogicalPortId;
-		ctp_assign[idx + i].nNumberOfCtpPort = param->nNumberOfCtpPort;
-	}
-	return 0;
-}
-
-int CTP_PortAssignmentGet(GSW_CTP_portAssignment_t *param)
-{
-	int i;
-
-	for (i = 0; i < MAX_CPT_PORT; i++) {
-		if (!ctp_assign_f[i])
-			continue;
-		if (ctp_assign[i].nLogicalPortId != param->nLogicalPortId)
-			continue;
-
-		param->eMode = ctp_assign[i].eMode;
-		param->nBridgePortId = ctp_assign[i].nBridgePortId;
-		param->nFirstCtpPortId = ctp_assign[i].nFirstCtpPortId;
-		param->nNumberOfCtpPort = ctp_assign[i].nNumberOfCtpPort;
-		return 0;
-	}
-	return -1;
-}
-
-GSW_CTP_portConfig_t ctp_port_cfg[MAX_CPT_PORT] = {0};
-int CtpPortConfigSet(GSW_CTP_portConfig_t *param)
-{
-	GSW_CTP_portAssignment_t ctp_get;
-	int ret;
-	u32 ctp_port;
-
-	ctp_get.nLogicalPortId = param->nLogicalPortId;
-	ret = CTP_PortAssignmentGet(&ctp_get);
-	if (ret) {
-		PR_ERR("CTP_PortAssignmentGet fail for bp=%d\n",
-		       ctp_get.nLogicalPortId);
-		return GSW_statusErr;
-	}
-	ctp_port = ctp_get.nFirstCtpPortId  + param->nSubIfIdGroup;
-	if ((ctp_port >= MAX_CPT_PORT) ||
-	    (ctp_port < ctp_get.nFirstCtpPortId)) {
-		PR_ERR("CtpPortConfigSet wrong ctp_port %d (%d ~ %d)\n",
-		       ctp_port, ctp_get.nFirstCtpPortId, MAX_CPT_PORT);
-		return GSW_statusErr;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_BRIDGE_PORT_ID)
-		ctp_port_cfg[ctp_port].nBridgePortId = param->nBridgePortId;
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE_TRAFFIC_CLASS) {
-		ctp_port_cfg[ctp_port].nDefaultTrafficClass =
-			param->nDefaultTrafficClass;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN) {
-		ctp_port_cfg[ctp_port].bIngressExtendedVlanEnable =
-			param->bIngressExtendedVlanEnable;
-		ctp_port_cfg[ctp_port].nIngressExtendedVlanBlockId =
-			param->nIngressExtendedVlanBlockId;
-	}
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN_IGMP) {
-		ctp_port_cfg[ctp_port].bIngressExtendedVlanIgmpEnable = param->
-			bIngressExtendedVlanIgmpEnable;
-		ctp_port_cfg[ctp_port].nIngressExtendedVlanBlockIdIgmp = param->
-			nIngressExtendedVlanBlockIdIgmp;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN) {
-		ctp_port_cfg[ctp_port].bEgressExtendedVlanEnable = param->
-			bEgressExtendedVlanEnable;
-		ctp_port_cfg[ctp_port].nEgressExtendedVlanBlockId = param->
-			nEgressExtendedVlanBlockId;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN_IGMP) {
-		ctp_port_cfg[ctp_port].bEgressExtendedVlanIgmpEnable = param->
-			bEgressExtendedVlanIgmpEnable;
-		ctp_port_cfg[ctp_port].nEgressExtendedVlanBlockIdIgmp = param->
-			nEgressExtendedVlanBlockIdIgmp;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INRESS_NTO1_VLAN)
-		ctp_port_cfg[ctp_port].bIngressNto1VlanEnable = param->
-			bIngressNto1VlanEnable;
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_NTO1_VLAN)
-		ctp_port_cfg[ctp_port].eMask = param->eMask;
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_INGRESS_METER) {
-		ctp_port_cfg[ctp_port].bIngressMeteringEnable = param->
-			bIngressMeteringEnable;
-		ctp_port_cfg[ctp_port].nIngressTrafficMeterId = param->
-			nIngressTrafficMeterId;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_METER) {
-		ctp_port_cfg[ctp_port].bEgressMeteringEnable =
-			param->bEgressMeteringEnable;
-		ctp_port_cfg[ctp_port].nEgressTrafficMeterId =
-			param->nEgressTrafficMeterId;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_BRIDGING_BYPASS) {
-		ctp_port_cfg[ctp_port].bBridgingBypass =
-			param->bBridgingBypass;
-		ctp_port_cfg[ctp_port].nDestLogicalPortId =
-			param->nDestLogicalPortId;
-		ctp_port_cfg[ctp_port].ePmapperMappingMode =
-			param->ePmapperMappingMode;
-		ctp_port_cfg[ctp_port].nDestSubIfIdGroup =
-			param->nDestSubIfIdGroup;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_INGRESS_MARKING) {
-		ctp_port_cfg[ctp_port].eIngressMarkingMode =
-			param->eIngressMarkingMode;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_MARKING) {
-		ctp_port_cfg[ctp_port].eEgressMarkingMode =
-			param->eEgressMarkingMode;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_REMARKING) {
-		ctp_port_cfg[ctp_port].eEgressRemarkingMode =
-			param->eEgressRemarkingMode;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_MARKING_OVERRIDE) {
-		ctp_port_cfg[ctp_port].bEgressMarkingOverrideEnable = param->
-			bEgressMarkingOverrideEnable;
-		ctp_port_cfg[ctp_port].eEgressMarkingModeOverride = param->
-			eEgressMarkingModeOverride;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_FLOW_ENTRY) {
-		ctp_port_cfg[ctp_port].nFirstFlowEntryIndex =
-			param->nFirstFlowEntryIndex;
-		ctp_port_cfg[ctp_port].nNumberOfFlowEntries =
-			param->nNumberOfFlowEntries;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_LOOPBACK_AND_MIRROR) {
-		ctp_port_cfg[ctp_port].bIngressLoopbackEnable = param->
-			bIngressLoopbackEnable;
-		ctp_port_cfg[ctp_port].bEgressLoopbackEnable =
-			param->bEgressLoopbackEnable;
-		ctp_port_cfg[ctp_port].bIngressMirrorEnable =
-			param->bIngressMirrorEnable;
-		ctp_port_cfg[ctp_port].bEgressMirrorEnable =
-			param->bEgressMirrorEnable;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_LOOPBACK_AND_MIRROR) {
-		ctp_port_cfg[ctp_port].bIngressDaSaSwapEnable = param->
-			bIngressDaSaSwapEnable;
-		ctp_port_cfg[ctp_port].bEgressDaSaSwapEnable =
-			param->bEgressDaSaSwapEnable;
-	}
-
-	return 0;
-}
-
-int CtpPortConfigGet(GSW_CTP_portConfig_t *param)
-{
-	GSW_CTP_portAssignment_t ctp_get;
-	int ret;
-	u32 ctp_port;
-
-	ctp_get.nLogicalPortId = param->nLogicalPortId;
-	ret = CTP_PortAssignmentGet(&ctp_get);
-	if (ret) {
-		PR_ERR("CtpPortConfigGet returns ERROR\n");
-		return GSW_statusErr;
-	}
-	ctp_port = ctp_get.nFirstCtpPortId  + param->nSubIfIdGroup;
-	if ((ctp_port >= MAX_CPT_PORT) ||
-	    (ctp_port < ctp_get.nFirstCtpPortId)) {
-		PR_ERR("CtpPortConfigGet wrong ctp_port %d (%d ~ %d)\n",
-		       ctp_port, ctp_get.nFirstCtpPortId, MAX_CPT_PORT);
-		return GSW_statusErr;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_BRIDGE_PORT_ID)
-		param->nBridgePortId = ctp_port_cfg[ctp_port].nBridgePortId;
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE_TRAFFIC_CLASS) {
-		param->nDefaultTrafficClass =
-			ctp_port_cfg[ctp_port].nDefaultTrafficClass;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN) {
-		param->bIngressExtendedVlanEnable = ctp_port_cfg[ctp_port].
-			bIngressExtendedVlanEnable;
-		param->nIngressExtendedVlanBlockId = ctp_port_cfg[ctp_port].
-			nIngressExtendedVlanBlockId;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN_IGMP) {
-		param->bIngressExtendedVlanIgmpEnable = ctp_port_cfg[ctp_port].
-			bIngressExtendedVlanIgmpEnable;
-		param->nIngressExtendedVlanBlockIdIgmp = ctp_port_cfg[ctp_port].
-			nIngressExtendedVlanBlockIdIgmp;
-		/*param->nIngressExtendedVlanBlockSizeIgmp =
-		 *ctp_port_cfg[ctp_port].nIngressExtendedVlanBlockSizeIgmp;
-		 */
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN) {
-		param->bEgressExtendedVlanEnable = ctp_port_cfg[ctp_port].
-			bEgressExtendedVlanEnable;
-		param->nEgressExtendedVlanBlockId = ctp_port_cfg[ctp_port].
-			nEgressExtendedVlanBlockId;
-		/*param->nEgressExtendedVlanBlockSize = ctp_port_cfg[ctp_port].
-		 *nEgressExtendedVlanBlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN_IGMP) {
-		param->bEgressExtendedVlanIgmpEnable = ctp_port_cfg[ctp_port].
-			bEgressExtendedVlanIgmpEnable;
-		param->nEgressExtendedVlanBlockIdIgmp = ctp_port_cfg[ctp_port].
-			nEgressExtendedVlanBlockIdIgmp;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INRESS_NTO1_VLAN)
-		param->bIngressNto1VlanEnable = ctp_port_cfg[ctp_port].
-			bIngressNto1VlanEnable;
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_NTO1_VLAN)
-		param->eMask = ctp_port_cfg[ctp_port].eMask;
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_INGRESS_METER) {
-		param->bIngressMeteringEnable = ctp_port_cfg[ctp_port].
-			bIngressMeteringEnable;
-		param->nIngressTrafficMeterId = ctp_port_cfg[ctp_port].
-			nIngressTrafficMeterId;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_METER) {
-		param->bEgressMeteringEnable =
-			ctp_port_cfg[ctp_port].bEgressMeteringEnable;
-		param->nEgressTrafficMeterId =
-			ctp_port_cfg[ctp_port].nEgressTrafficMeterId;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_BRIDGING_BYPASS) {
-		param->bBridgingBypass =
-			ctp_port_cfg[ctp_port].bBridgingBypass;
-		param->nDestLogicalPortId =
-			ctp_port_cfg[ctp_port].nDestLogicalPortId;
-		param->ePmapperMappingMode =
-			ctp_port_cfg[ctp_port].ePmapperMappingMode;
-		param->nDestSubIfIdGroup =
-			ctp_port_cfg[ctp_port].nDestSubIfIdGroup;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_INGRESS_MARKING) {
-		param->eIngressMarkingMode =
-			ctp_port_cfg[ctp_port].eIngressMarkingMode;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_MARKING) {
-		param->eEgressMarkingMode =
-			ctp_port_cfg[ctp_port].eEgressMarkingMode;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_REMARKING) {
-		param->eEgressRemarkingMode =
-			ctp_port_cfg[ctp_port].eEgressRemarkingMode;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_MARKING_OVERRIDE) {
-		param->bEgressMarkingOverrideEnable = ctp_port_cfg[ctp_port].
-			bEgressMarkingOverrideEnable;
-		param->eEgressMarkingModeOverride = ctp_port_cfg[ctp_port].
-			eEgressMarkingModeOverride;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_FLOW_ENTRY) {
-		param->nFirstFlowEntryIndex =
-			ctp_port_cfg[ctp_port].nFirstFlowEntryIndex;
-		param->nNumberOfFlowEntries =
-			ctp_port_cfg[ctp_port].nNumberOfFlowEntries;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_LOOPBACK_AND_MIRROR) {
-		param->bIngressLoopbackEnable = ctp_port_cfg[ctp_port].
-			bIngressLoopbackEnable;
-		param->bEgressLoopbackEnable = ctp_port_cfg[ctp_port].
-			bEgressLoopbackEnable;
-		param->bIngressMirrorEnable = ctp_port_cfg[ctp_port].
-			bIngressMirrorEnable;
-		param->bEgressMirrorEnable = ctp_port_cfg[ctp_port].
-			bEgressMirrorEnable;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_LOOPBACK_AND_MIRROR) {
-		param->bIngressDaSaSwapEnable = ctp_port_cfg[ctp_port].
-			bIngressDaSaSwapEnable;
-		param->bEgressDaSaSwapEnable = ctp_port_cfg[ctp_port].
-			bEgressDaSaSwapEnable;
-	}
-	return 0;
-}
-
-#define MAX_BRIDGE_PORT 120
-u8 bridge_port_f[MAX_BRIDGE_PORT];
-GSW_BRIDGE_portConfig_t bridge_port[MAX_BRIDGE_PORT];
-
-#define MAX_BRIDGE	64
-u8 bridge_f[MAX_BRIDGE_PORT];
-GSW_BRIDGE_config_t bridge[MAX_BRIDGE];
-
-int BridgePortAlloc(GSW_BRIDGE_portConfig_t *param)
-{
-	int i;
-
-	for (i = 1; i < MAX_BRIDGE_PORT; i++) {
-		if (bridge_port_f[i])
-			continue;
-		bridge_port_f[i] = 1;
-		param->nBridgePortId = i;
-		return 0;
-	}
-
-	return -1;
-}
-
-int BridgePortFree(GSW_BRIDGE_portConfig_t *param)
-{
-	bridge_port_f[param->nBridgePortId] = 0;
-	return 0;
-}
-
-int BridgeAlloc(GSW_BRIDGE_alloc_t *param)
-{
-	int i;
-
-	for (i = 1; i < MAX_BRIDGE_PORT; i++) {
-		if (bridge_f[i])
-			continue;
-		bridge_f[i] = 1;
-		param->nBridgeId = i;
-		return 0;
-	}
-
-	return -1;
-}
-
-int BridgeFree(GSW_BRIDGE_alloc_t *param)
-{
-	bridge_f[param->nBridgeId] = 0;
-	return 0;
-}
-
-int BridgePortConfigSet(GSW_BRIDGE_portConfig_t *param)
-{
-	int i = param->nBridgePortId;
-	//int k;
-	bridge_port[i].nBridgePortId = param->nBridgePortId;
-
-	/*If Bridge Port ID is invalid ,find a free Bridge
-	 *port configuration table
-	 *index and allocate
-	 *New Bridge Port configuration table index
-	 */
-	if (param->nBridgePortId >= MAX_BRIDGE_PORT) {
-		PR_ERR("wrong bridge port %d\n", param->nBridgePortId);
-		return GSW_statusErr;
-	}
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID)
-		bridge_port[i].nBridgeId = param->nBridgeId;
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_VLAN) {
-		bridge_port[i].bIngressExtendedVlanEnable = param->
-			bIngressExtendedVlanEnable;
-		if (param->bIngressExtendedVlanEnable)
-			bridge_port[i].nIngressExtendedVlanBlockId = param->
-				nIngressExtendedVlanBlockId;
-		/*bridge_port[i].nIngressExtendedVlanBlockSize = param->
-		 *nIngressExtendedVlanBlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN) {
-		bridge_port[i].bEgressExtendedVlanEnable = param->
-			bEgressExtendedVlanEnable;
-		bridge_port[i].nEgressExtendedVlanBlockId = param->
-			nEgressExtendedVlanBlockId;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_MARKING)
-		bridge_port[i].eIngressMarkingMode = param->eIngressMarkingMode;
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_REMARKING) {
-		bridge_port[i].eEgressRemarkingMode = param->
-			eEgressRemarkingMode;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_METER) {
-		bridge_port[i].bIngressMeteringEnable = param->
-			bIngressMeteringEnable;
-		bridge_port[i].nIngressTrafficMeterId = param->
-			nIngressTrafficMeterId;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_SUB_METER) {
-		memcpy(bridge_port[i].bEgressSubMeteringEnable, param->
-		       bEgressSubMeteringEnable,
-		       sizeof(bridge_port[i].bEgressSubMeteringEnable));
-		memcpy(bridge_port[i].nEgressTrafficSubMeterId, param->
-		       nEgressTrafficSubMeterId,
-		       sizeof(bridge_port[i].nEgressTrafficSubMeterId));
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_CTP_MAPPING) {
-#define PMAPPER_BLOCK_SIZE 36
-		bridge_port[i].bPmapperEnable = param->bPmapperEnable;
-		bridge_port[i].nDestLogicalPortId = param->nDestLogicalPortId;
-		bridge_port[i].ePmapperMappingMode = param->ePmapperMappingMode;
-		if (bridge_port[i].bPmapperEnable) {
-			if (!bridge_port[i].sPmapper.nPmapperId) {
-				bridge_port[i].sPmapper.nPmapperId =
-					Pmapper_Alloc(PMAPPER_BLOCK_SIZE);
-				param->sPmapper.nPmapperId =
-					bridge_port[i].sPmapper.nPmapperId;
-			}
-		} else if (bridge_port[i].sPmapper.nPmapperId)
-			Pmapper_Free(bridge_port[i].sPmapper.nPmapperId,
-				     PMAPPER_BLOCK_SIZE);
-	}
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP)
-		memcpy(bridge_port[i].nBridgePortMap, param->nBridgePortMap,
-		       sizeof(bridge_port[i].nBridgePortMap));
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_DEST_IP_LOOKUP) {
-		bridge_port[i].bMcDestIpLookupDisable = param->
-			bMcDestIpLookupDisable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_SRC_IP_LOOKUP) {
-		bridge_port[i].bMcSrcIpLookupEnable = param->
-			bMcSrcIpLookupEnable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_DEST_MAC_LOOKUP) {
-		bridge_port[i].bDestMacLookupDisable = param->
-			bDestMacLookupDisable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_SRC_MAC_LEARNING) {
-		bridge_port[i].bSrcMacLearningDisable = param->
-			bSrcMacLearningDisable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MAC_SPOOFING) {
-		bridge_port[i].bMacSpoofingDetectEnable = param->
-			bMacSpoofingDetectEnable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_PORT_LOCK)
-		bridge_port[i].bPortLockEnable = param->bPortLockEnable;
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_VLAN_FILTER) {
-		bridge_port[i].bBypassEgressVlanFilter1 = param->
-			bBypassEgressVlanFilter1;
-		bridge_port[i].bIngressVlanFilterEnable = param->
-			bIngressVlanFilterEnable;
-		bridge_port[i].nIngressVlanFilterBlockId = param->
-			nIngressVlanFilterBlockId;
-		/*bridge_port[i].nIngressVlanFilterBlockSize = param->
-		 *nIngressVlanFilterBlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN_FILTER1) {
-		bridge_port[i].bEgressVlanFilter1Enable = param->
-			bEgressVlanFilter1Enable;
-		bridge_port[i].nEgressVlanFilter1BlockId = param->
-			nEgressVlanFilter1BlockId;
-		/*bridge_port[i].nEgressVlanFilter1BlockSize = param->
-		 *nEgressVlanFilter1BlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN_FILTER2) {
-		bridge_port[i].bEgressVlanFilter2Enable = param->
-			bEgressVlanFilter2Enable;
-		bridge_port[i].nEgressVlanFilter2BlockId = param->
-			nEgressVlanFilter2BlockId;
-		/*bridge_port[i].nEgressVlanFilter2BlockSize = param->
-		 *nEgressVlanFilter2BlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MAC_LEARNING_LIMIT) {
-		bridge_port[i].bMacLearningLimitEnable = param->
-			bMacLearningLimitEnable;
-		bridge_port[i].nMacLearningLimit = param->nMacLearningLimit;
-	}
-	return 0;
-}
-
-int BridgePortConfigGet(GSW_BRIDGE_portConfig_t *param)
-{
-	int i = param->nBridgePortId;
-	//int k;
-
-	if (param->nBridgePortId >= MAX_BRIDGE_PORT) {
-		PR_ERR("wrong bridge port %d\n", param->nBridgePortId);
-		return GSW_statusErr;
-	}
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID)
-		param->nBridgeId = bridge_port[i].nBridgeId;
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_VLAN) {
-		param->bIngressExtendedVlanEnable = bridge_port[i].
-			bIngressExtendedVlanEnable;
-
-		param->nIngressExtendedVlanBlockId = bridge_port[i].
-			nIngressExtendedVlanBlockId;
-		/*param->nIngressExtendedVlanBlockSize = bridge_port[i].
-		 *nIngressExtendedVlanBlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN) {
-		param->bEgressExtendedVlanEnable = bridge_port[i].
-			bEgressExtendedVlanEnable;
-		param->nEgressExtendedVlanBlockId = bridge_port[i].
-			nEgressExtendedVlanBlockId;
-		/*param->nEgressExtendedVlanBlockSize = bridge_port[i].
-		 *nEgressExtendedVlanBlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_MARKING)
-		param->eIngressMarkingMode = bridge_port[i].eIngressMarkingMode;
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_REMARKING) {
-		param->eEgressRemarkingMode = bridge_port[i].
-			eEgressRemarkingMode;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_METER) {
-		param->bIngressMeteringEnable = bridge_port[i].
-			bIngressMeteringEnable;
-		param->nIngressTrafficMeterId = bridge_port[i].
-			nIngressTrafficMeterId;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_SUB_METER) {
-		memcpy(param->bEgressSubMeteringEnable, bridge_port[i].
-		       bEgressSubMeteringEnable,
-		       sizeof(bridge_port[i].bEgressSubMeteringEnable));
-		memcpy(param->nEgressTrafficSubMeterId, bridge_port[i].
-		       nEgressTrafficSubMeterId,
-		       sizeof(bridge_port[i].nEgressTrafficSubMeterId));
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_CTP_MAPPING) {
-#define PMAPPER_BLOCK_SIZE 36
-		param->bPmapperEnable = bridge_port[i].bPmapperEnable;
-		param->nDestLogicalPortId = bridge_port[i].nDestLogicalPortId;
-		param->ePmapperMappingMode = bridge_port[i].ePmapperMappingMode;
-		memcpy(&param->sPmapper, &bridge_port[i].sPmapper,
-		       sizeof(param->sPmapper));
-	}
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP) {
-		memcpy(param->nBridgePortMap, bridge_port[i].nBridgePortMap,
-		       sizeof(bridge_port[i].nBridgePortMap));
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_DEST_IP_LOOKUP) {
-		param->bMcDestIpLookupDisable = bridge_port[i].
-			bMcDestIpLookupDisable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_SRC_IP_LOOKUP) {
-		param->bMcSrcIpLookupEnable = bridge_port[i].
-			bMcSrcIpLookupEnable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_DEST_MAC_LOOKUP) {
-		param->bDestMacLookupDisable = bridge_port[i].
-			bDestMacLookupDisable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_SRC_MAC_LEARNING) {
-		param->bSrcMacLearningDisable = bridge_port[i].
-			bSrcMacLearningDisable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MAC_SPOOFING) {
-		param->bMacSpoofingDetectEnable = bridge_port[i].
-			bMacSpoofingDetectEnable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_PORT_LOCK)
-		param->bPortLockEnable = bridge_port[i].bPortLockEnable;
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_VLAN_FILTER) {
-		param->bBypassEgressVlanFilter1 = bridge_port[i].
-			bBypassEgressVlanFilter1;
-		param->bIngressVlanFilterEnable = bridge_port[i].
-			bIngressVlanFilterEnable;
-		param->nIngressVlanFilterBlockId = bridge_port[i].
-			nIngressVlanFilterBlockId;
-		/*param->nIngressVlanFilterBlockSize = bridge_port[i].
-		 *nIngressVlanFilterBlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN_FILTER1) {
-		param->bEgressVlanFilter1Enable = bridge_port[i].
-			bEgressVlanFilter1Enable;
-		param->nEgressVlanFilter1BlockId = bridge_port[i].
-			nEgressVlanFilter1BlockId;
-		/*param->nEgressVlanFilter1BlockSize = bridge_port[i].
-		 *nEgressVlanFilter1BlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN_FILTER2) {
-		param->bEgressVlanFilter2Enable = bridge_port[i].
-			bEgressVlanFilter2Enable;
-		param->nEgressVlanFilter2BlockId = bridge_port[i].
-			nEgressVlanFilter2BlockId;
-		/*param->nEgressVlanFilter2BlockSize = bridge_port[i].
-		 *nEgressVlanFilter2BlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MAC_LEARNING_LIMIT) {
-		param->bMacLearningLimitEnable = bridge_port[i].
-			bMacLearningLimitEnable;
-		param->nMacLearningLimit = bridge_port[i].nMacLearningLimit;
-	}
-	return 0;
-}
-
-int BridgeConfigSet(GSW_BRIDGE_config_t *param)
-{
-	int i = param->nBridgeId;
-
-	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_MAC_LEARNING_LIMIT) {
-		bridge[i].bMacLearningLimitEnable = param->
-			bMacLearningLimitEnable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_SUB_METER) {
-		memcpy(bridge[i].bSubMeteringEnable, param->bSubMeteringEnable,
-		       sizeof(bridge[i].bSubMeteringEnable));
-		memcpy(bridge[i].nTrafficSubMeterId, param->nTrafficSubMeterId,
-		       sizeof(bridge[i].nTrafficSubMeterId));
-	}
-
-	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_FORWARDING_MODE) {
-		bridge[i].eForwardBroadcast = param->eForwardBroadcast;
-		bridge[i].eForwardUnknownUnicast = param->
-			eForwardUnknownUnicast;
-		bridge[i].eForwardUnknownMulticastNonIp = param->
-			eForwardUnknownMulticastNonIp;
-	}
-	return 0;
-}
-
-int BridgeConfigGet(GSW_BRIDGE_config_t *param)
-{
-	int i = param->nBridgeId;
-
-	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_MAC_LEARNING_LIMIT) {
-		param->bMacLearningLimitEnable = bridge[i].
-			bMacLearningLimitEnable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_SUB_METER) {
-		memcpy(param->bSubMeteringEnable, bridge[i].bSubMeteringEnable,
-		       sizeof(bridge[i].bSubMeteringEnable));
-		memcpy(param->nTrafficSubMeterId, bridge[i].nTrafficSubMeterId,
-		       sizeof(bridge[i].nTrafficSubMeterId));
-	}
-
-	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_FORWARDING_MODE) {
-		param->eForwardBroadcast = bridge[i].eForwardBroadcast;
-		param->eForwardUnknownUnicast = bridge[i].
-			eForwardUnknownUnicast;
-		param->eForwardUnknownMulticastNonIp = bridge[i].
-			eForwardUnknownMulticastNonIp;
-	}
-	return 0;
-}
-
-#define MAX_EXTENDVLAN  512
-u8 extvlan_f[MAX_EXTENDVLAN] = {0};
-GSW_EXTENDEDVLAN_alloc_t extvlan_alloc[MAX_EXTENDVLAN] = {0};
-GSW_EXTENDEDVLAN_config_t extvlan[MAX_EXTENDVLAN] = {0};
-GSW_return_t ExtendedVlanAlloc(GSW_EXTENDEDVLAN_alloc_t *param)
-{
-	int i, j;
-
-	for (i = 1; i < MAX_EXTENDVLAN; i++) {
-		if (extvlan_f[i])
-			continue;
-		for (j = 0; j < param->nNumberOfEntries; j++)
-			if (extvlan_f[i + j])
-				continue;
-		param->nExtendedVlanBlockId = i;
-		for (j = 0; j < param->nNumberOfEntries; j++) {
-			extvlan_f[i + j] = 1;
-			extvlan_alloc[i + j].nExtendedVlanBlockId = i;
-			extvlan_alloc[i + j].nNumberOfEntries =  param->
-				nNumberOfEntries;
-		}
-		return 0;
-	}
-	return -1;
-}
-
-int ExtendedVlanFree(GSW_EXTENDEDVLAN_alloc_t *param)
-{
-	int i;
-
-	for (i = 0; i < extvlan_alloc[param->nExtendedVlanBlockId].
-	     nNumberOfEntries ; i++)
-		extvlan_f[i + param->nExtendedVlanBlockId] = 0;
-	return 0;
-}
-
-GSW_return_t ExtendedVlanSet(GSW_EXTENDEDVLAN_config_t *param)
-{ /*Note: not support pmapper here */
-	u32 idx = param->nExtendedVlanBlockId + param->nEntryIndex;
-
-	if (idx >= MAX_EXTENDVLAN) {
-		PR_ERR("ERROR : idx %d >= %d\n", idx, MAX_EXTENDVLAN);
-		return -1;
-	}
-
-	memcpy(&extvlan[idx].sFilter, &param->sFilter,
-	       sizeof(extvlan[idx].sFilter));
-	memcpy(&extvlan[idx].sTreatment, &param->sTreatment,
-	       sizeof(extvlan[idx].sTreatment));
-
-	return 0;
-}
-
-GSW_return_t ExtendedVlanGet(GSW_EXTENDEDVLAN_config_t *param)
-{ /*Note: not support pmapper here */
-	u32 idx = param->nExtendedVlanBlockId + param->nEntryIndex;
-
-	if (idx >= MAX_EXTENDVLAN) {
-		PR_ERR("ERROR: idx %d >= %d\n", idx, MAX_EXTENDVLAN);
-		return -1;
-	}
-	memcpy(&param->sFilter, &extvlan[idx].sFilter,
-	       sizeof(extvlan[idx].sFilter));
-	memcpy(&param->sTreatment, &extvlan[idx].sTreatment,
-	       sizeof(extvlan[idx].sTreatment));
-
-	return 0;
-}
-
-//TODO Yet to test below simulation code completely
-//#define MAC_MAX_ENTRY 4096
-#define MAC_MAX_ENTRY 10
-u8 mac_f[MAC_MAX_ENTRY];
-GSW_MAC_tableAdd_t MacAdd[MAC_MAX_ENTRY];
-
-int MacTableAdd(GSW_MAC_tableAdd_t *param)
-{
-	int i;
-
-	for (i = 0; i < MAC_MAX_ENTRY; i++) {
-		if (mac_f[i]) {
-			continue;
-		} else {
-			PR_ERR("MAC add i(%d) value\n", i);
-			mac_f[i] = 1;
-			break;
-		}
-	}
-
-	if (param->nPortId >= MAX_BRIDGE_PORT) {
-		PR_ERR("wrong bridge port for MAC add%d\n", param->nPortId);
-		return GSW_statusErr;
-	}
-
-	if (param->nPortMap) {
-		memcpy(MacAdd[i].nPortMap, param->nPortMap,
-		       sizeof(param->nPortMap));
-	}
-	MacAdd[i].nFId = param->nFId;
-	MacAdd[i].bStaticEntry = param->bStaticEntry;
-	MacAdd[i].nPortId = param->nPortId;
-	MacAdd[i].nSubIfId = param->nSubIfId;
-	memcpy(MacAdd[i].nMAC, param->nMAC, sizeof(param->nMAC));
-	PR_ERR("MAC add for entry:%d %02x:%02x:%02x:%02x:%02x:%02x\n", i,
-	       MacAdd[i].nMAC[0], MacAdd[i].nMAC[1], MacAdd[i].nMAC[2],
-	       MacAdd[i].nMAC[3], MacAdd[i].nMAC[4], MacAdd[i].nMAC[5]);
-	return 0;
-}
-
-int MacTableRemove(GSW_MAC_tableRemove_t *param)
-{
-	int i;
-
-	for (i = 0; i < MAC_MAX_ENTRY; i++) {
-		if (!mac_f[i])
-			continue;
-		if (MacAdd[i].nFId != param->nFId)
-			continue;
-		if (memcmp(MacAdd[i].nMAC, param->nMAC, sizeof(param->nMAC))) {
-			memset(&MacAdd[i], 0, sizeof(MacAdd[i]));
-			PR_ERR("MAC remove for entry:%d\n", i);
-		}
-		mac_f[i] = 0;
-		return 0;
-	}
-	return -1;
-}
-
-int MacTableQuery(GSW_MAC_tableQuery_t *param)
-{
-	int i;
-
-	for (i = 0; i < MAC_MAX_ENTRY; i++) {
-		if (!mac_f[i])
-			continue;
-		if (MacAdd[i].nFId != param->nFId)
-			continue;
-		if (memcmp(MacAdd[i].nMAC, param->nMAC, sizeof(param->nMAC))) {
-			param->nFId = MacAdd[i].nFId;
-			param->bFound = 1;
-			param->nPortId = MacAdd[i].nPortId;
-			param->nSubIfId = MacAdd[i].nSubIfId;
-			param->bStaticEntry = MacAdd[i].bStaticEntry;
-			memcpy(param->nPortMap,
-			       MacAdd[i].nPortMap,
-			       sizeof(MacAdd[i].nPortMap));
-			memcpy(param->nMAC, MacAdd[i].nMAC,
-			       sizeof(MacAdd[i].nMAC));
-
-		PR_ERR("%d    %d    %d	%02x:%02x:%02x:%02x:%02x:%02x\n",
-		       param->nFId, param->nPortId,
-		       param->bStaticEntry,
-		       param->nMAC[0], param->nMAC[1], param->nMAC[2],
-		       param->nMAC[3], param->nMAC[4], param->nMAC[5]);
-			return 0;
-		} else if (MacAdd[i].nPortId == param->nPortId) {
-			param->nFId = MacAdd[i].nFId;
-			param->bFound = 1;
-			param->nPortId = MacAdd[i].nPortId;
-			param->nSubIfId = MacAdd[i].nSubIfId;
-			memcpy(param->nPortMap,
-			       MacAdd[i].nPortMap,
-			       sizeof(MacAdd[i].nPortMap));
-			memcpy(param->nMAC, MacAdd[i].nMAC,
-			       sizeof(MacAdd[i].nMAC));
-			return 0;
-		}
-	}
-	PR_ERR("MAC Tbl query not match\n");
-	return -1;
-}
-
-int MacTableRead(GSW_MAC_tableRead_t *param)
-{
-	int i;
-
-	PR_ERR("MAC Tbl read\n");
-	for (i = 0; i < MAC_MAX_ENTRY; i++) {
-		if (!mac_f[i])
-			return -1;
-		param->nFId = MacAdd[i].nFId;
-		param->nPortId = MacAdd[i].nPortId;
-		param->nSubIfId = MacAdd[i].nSubIfId;
-		param->bStaticEntry = MacAdd[i].bStaticEntry;
-		memcpy(param->nPortMap,
-		       MacAdd[i].nPortMap,
-		       sizeof(MacAdd[i].nPortMap));
-		memcpy(param->nMAC, MacAdd[i].nMAC,
-		       sizeof(MacAdd[i].nMAC));
-	}
-	return 0;
-}
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_gswip_simulate.h b/drivers/net/datapath/dpm/gswip31/datapath_gswip_simulate.h
deleted file mode 100644
index a69fabc46301..000000000000
--- a/drivers/net/datapath/dpm/gswip31/datapath_gswip_simulate.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) Intel Corporation
- * Author: Shao Guohua <guohua.shao@intel.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- */
-
-#ifndef DATAPATH_GSWIP_SIMULATE_H_
-#define DATAPATH_GSWIP_SIMULATE_H_
-
-u32  Pmapper_Alloc(int size);
-int Pmapper_Free(u32 offset, int size);
-int CTP_PortAssignmentAlloc(GSW_CTP_portAssignment_t *param);
-int CTP_PortAssignmentFree(GSW_CTP_portAssignment_t *param);
-int CTP_PortAssignmentSet(GSW_CTP_portAssignment_t *param);
-int CTP_PortAssignmentGet(GSW_CTP_portAssignment_t *param);
-int CtpPortConfigSet(GSW_CTP_portConfig_t *param);
-int CtpPortConfigGet(GSW_CTP_portConfig_t *param);
-int BridgePortAlloc(GSW_BRIDGE_portConfig_t *param);
-int BridgePortFree(GSW_BRIDGE_portConfig_t *param);
-int BridgeAlloc(GSW_BRIDGE_alloc_t *param);
-int BridgeFree(GSW_BRIDGE_alloc_t *param);
-int BridgePortConfigSet(GSW_BRIDGE_portConfig_t *param);
-int BridgePortConfigGet(GSW_BRIDGE_portConfig_t *param);
-int BridgeConfigSet(GSW_BRIDGE_config_t *param);
-int BridgeConfigGet(GSW_BRIDGE_config_t *param);
-int MacTableAdd(GSW_MAC_tableAdd_t *param);
-int MacTableRemove(GSW_MAC_tableRemove_t *param);
-int MacTableQuery(GSW_MAC_tableQuery_t *param);
-int MacTableRead(GSW_MAC_tableAdd_t *param);
-
-GSW_return_t ExtendedVlanAlloc(GSW_EXTENDEDVLAN_alloc_t *param);
-int ExtendedVlanFree(GSW_EXTENDEDVLAN_alloc_t *param);
-GSW_return_t ExtendedVlanSet(GSW_EXTENDEDVLAN_config_t *param);
-GSW_return_t ExtendedVlanGet(GSW_EXTENDEDVLAN_config_t *param);
-#endif
-
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_misc.c b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
index 861e33343786..d4513d66aa77 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
@@ -1126,14 +1126,7 @@ int dp_platform_queue_set(int inst, u32 flag)
 	/*Alloc queue/scheduler/port per CPU port */
 	cpu_data.dp_inst = inst;
 	cpu_data.cbm_inst = dp_port_prop[inst].cbm_inst;
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_DDR_SIMULATE_GSWIP31)
-	cpu_data.dq_tx_push_info[0].deq_port = 0;
-	cpu_data.dq_tx_push_info[1].deq_port = -1;
-	cpu_data.dq_tx_push_info[2].deq_port = -1;
-	cpu_data.dq_tx_push_info[3].deq_port = -1;
-#else
 	ret = cbm_cpu_port_get(&cpu_data, 0);
-#endif
 	if (ret == -1) {
 		PR_ERR("%s fail for CPU Port. Why ???\n",
 		       "cbm_cpu_port_get");
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_misc.h b/drivers/net/datapath/dpm/gswip31/datapath_misc.h
index 61a71379c556..d828dbce306f 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_misc.h
+++ b/drivers/net/datapath/dpm/gswip31/datapath_misc.h
@@ -179,22 +179,8 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 void set_chksum(struct pmac_tx_hdr *pmac, u32 tcp_type, u32 ip_offset,
 		int ip_off_hw_adjust, u32 tcp_h_offset);
 
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_DDR_SIMULATE_GSWIP31)
-GSW_return_t gsw_core_api_ddr_simu31(dp_gsw_cb func, void *ops, void *param);
-#define GSW_SIMUTE_DDR_NOT_MATCH  0x1234
-#endif
-
 static inline GSW_return_t gsw_core_api(dp_gsw_cb func, void *ops, void *param)
 {
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_DDR_SIMULATE_GSWIP31)
-	{
-		GSW_return_t res;
-
-		res = gsw_core_api_ddr_simu31(func, ops, param);
-		if (res != GSW_SIMUTE_DDR_NOT_MATCH)
-			return res;
-	}
-#endif /*CONFIG_INTEL_DATAPATH_DDR_SIMULATE_GSWIP31*/
 	if (!func)
 		return DP_FAILURE;
 	return func(ops, param);
diff --git a/drivers/net/datapath/dpm/gswip32/Kconfig b/drivers/net/datapath/dpm/gswip32/Kconfig
index e89c6b36fea7..e348f8dc6aab 100644
--- a/drivers/net/datapath/dpm/gswip32/Kconfig
+++ b/drivers/net/datapath/dpm/gswip32/Kconfig
@@ -1,7 +1,7 @@
 menuconfig INTEL_DATAPATH_HAL_GSWIP32
 	bool "Datapath HAL_GSWIP32"
 	default y
-	depends on INTEL_DATAPATH && (X86_INTEL_LGM || INTEL_DATAPATH_SIMULATE_GSWIP32)
+	depends on INTEL_DATAPATH && X86_INTEL_LGM
 	---help---
 	  Datapath Lib is to provide common rx/tx wrapper Lib without taking
 	  care of much HW knowledge and also provide common interface for legacy
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_gswip.c b/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
index d28f50f40cd7..344b91229d17 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
@@ -13,9 +13,6 @@
 #include <net/datapath_api.h>
 #include "../datapath.h"
 #include "datapath_misc.h"
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_DDR_SIMULATE_GSWIP32)
-#include "datapath_gswip_simulate.h"
-#endif
 
 #define GSW_CORE_API(_handle, a, b) ({ \
 	typeof(_handle) (handle) = (_handle); \
@@ -95,72 +92,6 @@ static char *ctp_mode_string(GSW_LogicalPortMode_t type)
 	return "Undef";
 }
 
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_DDR_SIMULATE_GSWIP32)
-GSW_return_t gsw_core_api_ddr_simu32(dp_gsw_cb func, void *ops, void *param)
-{
-	if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_brdgport_ops.BridgePort_Alloc) {
-		return BridgePortAlloc(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_brdgport_ops.BridgePort_ConfigGet) {
-		return BridgePortConfigGet(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_brdgport_ops.BridgePort_ConfigSet) {
-		return BridgePortConfigSet(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_brdgport_ops.BridgePort_Free) {
-		return BridgePortFree(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_brdg_ops.Bridge_Alloc) {
-		return BridgeAlloc(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_brdg_ops.Bridge_ConfigSet) {
-		return BridgeConfigSet(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_brdg_ops.Bridge_ConfigGet) {
-		return BridgeConfigGet(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_brdg_ops.Bridge_Free) {
-		return BridgeFree(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_ctp_ops.CTP_PortAssignmentAlloc) {
-		return CTP_PortAssignmentAlloc
-			(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_ctp_ops.CTP_PortAssignmentFree) {
-		return CTP_PortAssignmentFree
-			(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_ctp_ops.CTP_PortAssignmentSet) {
-		return CTP_PortAssignmentSet
-			(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_ctp_ops.CTP_PortAssignmentGet) {
-		return CTP_PortAssignmentGet
-			(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_ctp_ops.CTP_PortConfigSet) {
-		return CtpPortConfigSet(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-	    gsw_ctp_ops.CTP_PortConfigGet) {
-		return CtpPortConfigGet(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-		   gsw_swmac_ops.MAC_TableEntryAdd) {
-		return MacTableAdd(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-		   gsw_swmac_ops.MAC_TableEntryRead) {
-		return MacTableRead(param);
-	} else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-		   gsw_swmac_ops.MAC_TableEntryRemove) {
-		return MacTableRemove(param);
-	}  else if (func == (dp_gsw_cb)dp_port_prop[0].ops[0]->
-		    gsw_swmac_ops.MAC_TableEntryQuery) {
-		return MacTableQuery(param);
-	}
-	return GSW_SIMUTE_DDR_NOT_MATCH;
-}
-#endif
-
 /*This API is only for GSWIP-R PMAC modification, not for GSWIP-L */
 int dp_pmac_set_32(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 {
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_gswip_simulate.c b/drivers/net/datapath/dpm/gswip32/datapath_gswip_simulate.c
deleted file mode 100644
index 2195b295426a..000000000000
--- a/drivers/net/datapath/dpm/gswip32/datapath_gswip_simulate.c
+++ /dev/null
@@ -1,983 +0,0 @@
-/*
- * Copyright (C) Intel Corporation
- * Author: Shao Guohua <guohua.shao@intel.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- */
-
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/etherdevice.h>
-#include <net/datapath_api.h>
-#include "../datapath.h"
-#include "datapath_misc.h"
-
-#define MAX_CPT_PORT 288
-u8 ctp_assign_f[MAX_CPT_PORT] = {0};
-GSW_CTP_portAssignment_t ctp_assign[MAX_CPT_PORT] = {0};
-
-#define MAX_PMAPPER 2336
-u8 pmapper_f[MAX_PMAPPER] = {0};
-
-u32  Pmapper_Alloc(int size)
-{
-	u32 i, j;
-
-	for (i = 1; i < MAX_PMAPPER; i++) {
-		if (pmapper_f[i])
-			continue;
-		for (j = 0; j < size; j++)
-			if (pmapper_f[i + j])
-				continue;
-
-		for (j = 0; j < size; j++)
-			pmapper_f[i] = 1;
-		return i;
-	}
-	return -1;
-}
-
-int Pmapper_Free(u32 offset, int size)
-{
-	int i;
-
-	for (i = 0; i < size; i++)
-		pmapper_f[i + offset] = 0;
-	return -1;
-}
-
-int CTP_PortAssignmentAlloc(GSW_CTP_portAssignment_t *param)
-{
-	int i, j;
-
-	for (i = 1; i < MAX_CPT_PORT; i++) {
-		if (ctp_assign_f[i])
-			continue;
-		for (j = 0; j < param->nNumberOfCtpPort; j++)
-			if (ctp_assign_f[i + j])
-				continue;
-		param->nFirstCtpPortId = i;
-		for (j = 0; j < param->nNumberOfCtpPort; j++) {
-			ctp_assign_f[i + j] = 1;
-			ctp_assign[i + j].eMode = param->eMode;
-			ctp_assign[i + j].nBridgePortId =
-				param->nBridgePortId;
-			ctp_assign[i + j].nFirstCtpPortId =
-				param->nFirstCtpPortId;
-			ctp_assign[i + j].nLogicalPortId =
-				param->nLogicalPortId;
-			ctp_assign[i + j].nNumberOfCtpPort =
-				param->nNumberOfCtpPort;
-		}
-		return 0;
-	}
-	return -1;
-}
-
-int CTP_PortAssignmentFree(GSW_CTP_portAssignment_t *param)
-{
-	int i;
-
-	for (i = 0; i < param->nNumberOfCtpPort; i++)
-		ctp_assign_f[i + param->nNumberOfCtpPort] = 0;
-	return 0;
-}
-
-int CTP_PortAssignmentSet(GSW_CTP_portAssignment_t *param)
-{
-	u32 idx = param->nFirstCtpPortId;
-	int i;
-
-	for (i = 0; i < param->nNumberOfCtpPort; i++) {
-		ctp_assign[idx + i].eMode = param->eMode;
-		ctp_assign[idx + i].nBridgePortId = param->nBridgePortId;
-		ctp_assign[idx + i].nFirstCtpPortId = param->nFirstCtpPortId;
-		ctp_assign[idx + i].nLogicalPortId = param->nLogicalPortId;
-		ctp_assign[idx + i].nNumberOfCtpPort = param->nNumberOfCtpPort;
-	}
-	return 0;
-}
-
-int CTP_PortAssignmentGet(GSW_CTP_portAssignment_t *param)
-{
-	int i;
-
-	for (i = 0; i < MAX_CPT_PORT; i++) {
-		if (!ctp_assign_f[i])
-			continue;
-		if (ctp_assign[i].nLogicalPortId != param->nLogicalPortId)
-			continue;
-
-		param->eMode = ctp_assign[i].eMode;
-		param->nBridgePortId = ctp_assign[i].nBridgePortId;
-		param->nFirstCtpPortId = ctp_assign[i].nFirstCtpPortId;
-		param->nNumberOfCtpPort = ctp_assign[i].nNumberOfCtpPort;
-		return 0;
-	}
-	return -1;
-}
-
-GSW_CTP_portConfig_t ctp_port_cfg[MAX_CPT_PORT] = {0};
-int CtpPortConfigSet(GSW_CTP_portConfig_t *param)
-{
-	GSW_CTP_portAssignment_t ctp_get;
-	int ret;
-	u32 ctp_port;
-
-	ctp_get.nLogicalPortId = param->nLogicalPortId;
-	ret = CTP_PortAssignmentGet(&ctp_get);
-	if (ret) {
-		PR_ERR("CTP_PortAssignmentGet fail for bp=%d\n",
-		       ctp_get.nLogicalPortId);
-		return GSW_statusErr;
-	}
-	ctp_port = ctp_get.nFirstCtpPortId  + param->nSubIfIdGroup;
-	if ((ctp_port >= MAX_CPT_PORT) ||
-	    (ctp_port < ctp_get.nFirstCtpPortId)) {
-		PR_ERR("CtpPortConfigSet wrong ctp_port %d (%d ~ %d)\n",
-		       ctp_port, ctp_get.nFirstCtpPortId, MAX_CPT_PORT);
-		return GSW_statusErr;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_BRIDGE_PORT_ID)
-		ctp_port_cfg[ctp_port].nBridgePortId = param->nBridgePortId;
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE_TRAFFIC_CLASS) {
-		ctp_port_cfg[ctp_port].nDefaultTrafficClass =
-			param->nDefaultTrafficClass;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN) {
-		ctp_port_cfg[ctp_port].bIngressExtendedVlanEnable =
-			param->bIngressExtendedVlanEnable;
-		ctp_port_cfg[ctp_port].nIngressExtendedVlanBlockId =
-			param->nIngressExtendedVlanBlockId;
-	}
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN_IGMP) {
-		ctp_port_cfg[ctp_port].bIngressExtendedVlanIgmpEnable = param->
-			bIngressExtendedVlanIgmpEnable;
-		ctp_port_cfg[ctp_port].nIngressExtendedVlanBlockIdIgmp = param->
-			nIngressExtendedVlanBlockIdIgmp;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN) {
-		ctp_port_cfg[ctp_port].bEgressExtendedVlanEnable = param->
-			bEgressExtendedVlanEnable;
-		ctp_port_cfg[ctp_port].nEgressExtendedVlanBlockId = param->
-			nEgressExtendedVlanBlockId;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN_IGMP) {
-		ctp_port_cfg[ctp_port].bEgressExtendedVlanIgmpEnable = param->
-			bEgressExtendedVlanIgmpEnable;
-		ctp_port_cfg[ctp_port].nEgressExtendedVlanBlockIdIgmp = param->
-			nEgressExtendedVlanBlockIdIgmp;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INRESS_NTO1_VLAN)
-		ctp_port_cfg[ctp_port].bIngressNto1VlanEnable = param->
-			bIngressNto1VlanEnable;
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_NTO1_VLAN)
-		ctp_port_cfg[ctp_port].eMask = param->eMask;
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_INGRESS_METER) {
-		ctp_port_cfg[ctp_port].bIngressMeteringEnable = param->
-			bIngressMeteringEnable;
-		ctp_port_cfg[ctp_port].nIngressTrafficMeterId = param->
-			nIngressTrafficMeterId;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_METER) {
-		ctp_port_cfg[ctp_port].bEgressMeteringEnable =
-			param->bEgressMeteringEnable;
-		ctp_port_cfg[ctp_port].nEgressTrafficMeterId =
-			param->nEgressTrafficMeterId;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_BRIDGING_BYPASS) {
-		ctp_port_cfg[ctp_port].bBridgingBypass =
-			param->bBridgingBypass;
-		ctp_port_cfg[ctp_port].nDestLogicalPortId =
-			param->nDestLogicalPortId;
-		ctp_port_cfg[ctp_port].ePmapperMappingMode =
-			param->ePmapperMappingMode;
-		ctp_port_cfg[ctp_port].nDestSubIfIdGroup =
-			param->nDestSubIfIdGroup;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_INGRESS_MARKING) {
-		ctp_port_cfg[ctp_port].eIngressMarkingMode =
-			param->eIngressMarkingMode;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_MARKING) {
-		ctp_port_cfg[ctp_port].eEgressMarkingMode =
-			param->eEgressMarkingMode;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_REMARKING) {
-		ctp_port_cfg[ctp_port].eEgressRemarkingMode =
-			param->eEgressRemarkingMode;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_MARKING_OVERRIDE) {
-		ctp_port_cfg[ctp_port].bEgressMarkingOverrideEnable = param->
-			bEgressMarkingOverrideEnable;
-		ctp_port_cfg[ctp_port].eEgressMarkingModeOverride = param->
-			eEgressMarkingModeOverride;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_FLOW_ENTRY) {
-		ctp_port_cfg[ctp_port].nFirstFlowEntryIndex =
-			param->nFirstFlowEntryIndex;
-		ctp_port_cfg[ctp_port].nNumberOfFlowEntries =
-			param->nNumberOfFlowEntries;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_LOOPBACK_AND_MIRROR) {
-		ctp_port_cfg[ctp_port].bIngressLoopbackEnable = param->
-			bIngressLoopbackEnable;
-		ctp_port_cfg[ctp_port].bEgressLoopbackEnable =
-			param->bEgressLoopbackEnable;
-		ctp_port_cfg[ctp_port].bIngressMirrorEnable =
-			param->bIngressMirrorEnable;
-		ctp_port_cfg[ctp_port].bEgressMirrorEnable =
-			param->bEgressMirrorEnable;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_LOOPBACK_AND_MIRROR) {
-		ctp_port_cfg[ctp_port].bIngressDaSaSwapEnable = param->
-			bIngressDaSaSwapEnable;
-		ctp_port_cfg[ctp_port].bEgressDaSaSwapEnable =
-			param->bEgressDaSaSwapEnable;
-	}
-
-	return 0;
-}
-
-int CtpPortConfigGet(GSW_CTP_portConfig_t *param)
-{
-	GSW_CTP_portAssignment_t ctp_get;
-	int ret;
-	u32 ctp_port;
-
-	ctp_get.nLogicalPortId = param->nLogicalPortId;
-	ret = CTP_PortAssignmentGet(&ctp_get);
-	if (ret) {
-		PR_ERR("CtpPortConfigGet returns ERROR\n");
-		return GSW_statusErr;
-	}
-	ctp_port = ctp_get.nFirstCtpPortId  + param->nSubIfIdGroup;
-	if ((ctp_port >= MAX_CPT_PORT) ||
-	    (ctp_port < ctp_get.nFirstCtpPortId)) {
-		PR_ERR("CtpPortConfigGet wrong ctp_port %d (%d ~ %d)\n",
-		       ctp_port, ctp_get.nFirstCtpPortId, MAX_CPT_PORT);
-		return GSW_statusErr;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_BRIDGE_PORT_ID)
-		param->nBridgePortId = ctp_port_cfg[ctp_port].nBridgePortId;
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE_TRAFFIC_CLASS) {
-		param->nDefaultTrafficClass =
-			ctp_port_cfg[ctp_port].nDefaultTrafficClass;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN) {
-		param->bIngressExtendedVlanEnable = ctp_port_cfg[ctp_port].
-			bIngressExtendedVlanEnable;
-		param->nIngressExtendedVlanBlockId = ctp_port_cfg[ctp_port].
-			nIngressExtendedVlanBlockId;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN_IGMP) {
-		param->bIngressExtendedVlanIgmpEnable = ctp_port_cfg[ctp_port].
-			bIngressExtendedVlanIgmpEnable;
-		param->nIngressExtendedVlanBlockIdIgmp = ctp_port_cfg[ctp_port].
-			nIngressExtendedVlanBlockIdIgmp;
-		/*param->nIngressExtendedVlanBlockSizeIgmp =
-		 *ctp_port_cfg[ctp_port].nIngressExtendedVlanBlockSizeIgmp;
-		 */
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN) {
-		param->bEgressExtendedVlanEnable = ctp_port_cfg[ctp_port].
-			bEgressExtendedVlanEnable;
-		param->nEgressExtendedVlanBlockId = ctp_port_cfg[ctp_port].
-			nEgressExtendedVlanBlockId;
-		/*param->nEgressExtendedVlanBlockSize = ctp_port_cfg[ctp_port].
-		 *nEgressExtendedVlanBlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN_IGMP) {
-		param->bEgressExtendedVlanIgmpEnable = ctp_port_cfg[ctp_port].
-			bEgressExtendedVlanIgmpEnable;
-		param->nEgressExtendedVlanBlockIdIgmp = ctp_port_cfg[ctp_port].
-			nEgressExtendedVlanBlockIdIgmp;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INRESS_NTO1_VLAN)
-		param->bIngressNto1VlanEnable = ctp_port_cfg[ctp_port].
-			bIngressNto1VlanEnable;
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_NTO1_VLAN)
-		param->eMask = ctp_port_cfg[ctp_port].eMask;
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_INGRESS_METER) {
-		param->bIngressMeteringEnable = ctp_port_cfg[ctp_port].
-			bIngressMeteringEnable;
-		param->nIngressTrafficMeterId = ctp_port_cfg[ctp_port].
-			nIngressTrafficMeterId;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_METER) {
-		param->bEgressMeteringEnable =
-			ctp_port_cfg[ctp_port].bEgressMeteringEnable;
-		param->nEgressTrafficMeterId =
-			ctp_port_cfg[ctp_port].nEgressTrafficMeterId;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_BRIDGING_BYPASS) {
-		param->bBridgingBypass =
-			ctp_port_cfg[ctp_port].bBridgingBypass;
-		param->nDestLogicalPortId =
-			ctp_port_cfg[ctp_port].nDestLogicalPortId;
-		param->ePmapperMappingMode =
-			ctp_port_cfg[ctp_port].ePmapperMappingMode;
-		param->nDestSubIfIdGroup =
-			ctp_port_cfg[ctp_port].nDestSubIfIdGroup;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_INGRESS_MARKING) {
-		param->eIngressMarkingMode =
-			ctp_port_cfg[ctp_port].eIngressMarkingMode;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_MARKING) {
-		param->eEgressMarkingMode =
-			ctp_port_cfg[ctp_port].eEgressMarkingMode;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_REMARKING) {
-		param->eEgressRemarkingMode =
-			ctp_port_cfg[ctp_port].eEgressRemarkingMode;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_MARKING_OVERRIDE) {
-		param->bEgressMarkingOverrideEnable = ctp_port_cfg[ctp_port].
-			bEgressMarkingOverrideEnable;
-		param->eEgressMarkingModeOverride = ctp_port_cfg[ctp_port].
-			eEgressMarkingModeOverride;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_FLOW_ENTRY) {
-		param->nFirstFlowEntryIndex =
-			ctp_port_cfg[ctp_port].nFirstFlowEntryIndex;
-		param->nNumberOfFlowEntries =
-			ctp_port_cfg[ctp_port].nNumberOfFlowEntries;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_LOOPBACK_AND_MIRROR) {
-		param->bIngressLoopbackEnable = ctp_port_cfg[ctp_port].
-			bIngressLoopbackEnable;
-		param->bEgressLoopbackEnable = ctp_port_cfg[ctp_port].
-			bEgressLoopbackEnable;
-		param->bIngressMirrorEnable = ctp_port_cfg[ctp_port].
-			bIngressMirrorEnable;
-		param->bEgressMirrorEnable = ctp_port_cfg[ctp_port].
-			bEgressMirrorEnable;
-	}
-
-	if (param->eMask & GSW_CTP_PORT_CONFIG_LOOPBACK_AND_MIRROR) {
-		param->bIngressDaSaSwapEnable = ctp_port_cfg[ctp_port].
-			bIngressDaSaSwapEnable;
-		param->bEgressDaSaSwapEnable = ctp_port_cfg[ctp_port].
-			bEgressDaSaSwapEnable;
-	}
-	return 0;
-}
-
-#define MAX_BRIDGE_PORT 120
-u8 bridge_port_f[MAX_BRIDGE_PORT];
-GSW_BRIDGE_portConfig_t bridge_port[MAX_BRIDGE_PORT];
-
-#define MAX_BRIDGE	64
-u8 bridge_f[MAX_BRIDGE_PORT];
-GSW_BRIDGE_config_t bridge[MAX_BRIDGE];
-
-int BridgePortAlloc(GSW_BRIDGE_portConfig_t *param)
-{
-	int i;
-
-	for (i = 1; i < MAX_BRIDGE_PORT; i++) {
-		if (bridge_port_f[i])
-			continue;
-		bridge_port_f[i] = 1;
-		param->nBridgePortId = i;
-		return 0;
-	}
-
-	return -1;
-}
-
-int BridgePortFree(GSW_BRIDGE_portConfig_t *param)
-{
-	bridge_port_f[param->nBridgePortId] = 0;
-	return 0;
-}
-
-int BridgeAlloc(GSW_BRIDGE_alloc_t *param)
-{
-	int i;
-
-	for (i = 1; i < MAX_BRIDGE_PORT; i++) {
-		if (bridge_f[i])
-			continue;
-		bridge_f[i] = 1;
-		param->nBridgeId = i;
-		return 0;
-	}
-
-	return -1;
-}
-
-int BridgeFree(GSW_BRIDGE_alloc_t *param)
-{
-	bridge_f[param->nBridgeId] = 0;
-	return 0;
-}
-
-int BridgePortConfigSet(GSW_BRIDGE_portConfig_t *param)
-{
-	int i = param->nBridgePortId;
-	//int k;
-	bridge_port[i].nBridgePortId = param->nBridgePortId;
-
-	/*If Bridge Port ID is invalid ,find a free Bridge
-	 *port configuration table
-	 *index and allocate
-	 *New Bridge Port configuration table index
-	 */
-	if (param->nBridgePortId >= MAX_BRIDGE_PORT) {
-		PR_ERR("wrong bridge port %d\n", param->nBridgePortId);
-		return GSW_statusErr;
-	}
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID)
-		bridge_port[i].nBridgeId = param->nBridgeId;
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_VLAN) {
-		bridge_port[i].bIngressExtendedVlanEnable = param->
-			bIngressExtendedVlanEnable;
-		if (param->bIngressExtendedVlanEnable)
-			bridge_port[i].nIngressExtendedVlanBlockId = param->
-				nIngressExtendedVlanBlockId;
-		/*bridge_port[i].nIngressExtendedVlanBlockSize = param->
-		 *nIngressExtendedVlanBlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN) {
-		bridge_port[i].bEgressExtendedVlanEnable = param->
-			bEgressExtendedVlanEnable;
-		bridge_port[i].nEgressExtendedVlanBlockId = param->
-			nEgressExtendedVlanBlockId;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_MARKING)
-		bridge_port[i].eIngressMarkingMode = param->eIngressMarkingMode;
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_REMARKING) {
-		bridge_port[i].eEgressRemarkingMode = param->
-			eEgressRemarkingMode;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_METER) {
-		bridge_port[i].bIngressMeteringEnable = param->
-			bIngressMeteringEnable;
-		bridge_port[i].nIngressTrafficMeterId = param->
-			nIngressTrafficMeterId;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_SUB_METER) {
-		memcpy(bridge_port[i].bEgressSubMeteringEnable, param->
-		       bEgressSubMeteringEnable,
-		       sizeof(bridge_port[i].bEgressSubMeteringEnable));
-		memcpy(bridge_port[i].nEgressTrafficSubMeterId, param->
-		       nEgressTrafficSubMeterId,
-		       sizeof(bridge_port[i].nEgressTrafficSubMeterId));
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_CTP_MAPPING) {
-#define PMAPPER_BLOCK_SIZE 36
-		bridge_port[i].bPmapperEnable = param->bPmapperEnable;
-		bridge_port[i].nDestLogicalPortId = param->nDestLogicalPortId;
-		bridge_port[i].ePmapperMappingMode = param->ePmapperMappingMode;
-		if (bridge_port[i].bPmapperEnable) {
-			if (!bridge_port[i].sPmapper.nPmapperId) {
-				bridge_port[i].sPmapper.nPmapperId =
-					Pmapper_Alloc(PMAPPER_BLOCK_SIZE);
-				param->sPmapper.nPmapperId =
-					bridge_port[i].sPmapper.nPmapperId;
-			}
-		} else if (bridge_port[i].sPmapper.nPmapperId)
-			Pmapper_Free(bridge_port[i].sPmapper.nPmapperId,
-				     PMAPPER_BLOCK_SIZE);
-	}
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP)
-		memcpy(bridge_port[i].nBridgePortMap, param->nBridgePortMap,
-		       sizeof(bridge_port[i].nBridgePortMap));
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_DEST_IP_LOOKUP) {
-		bridge_port[i].bMcDestIpLookupDisable = param->
-			bMcDestIpLookupDisable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_SRC_IP_LOOKUP) {
-		bridge_port[i].bMcSrcIpLookupEnable = param->
-			bMcSrcIpLookupEnable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_DEST_MAC_LOOKUP) {
-		bridge_port[i].bDestMacLookupDisable = param->
-			bDestMacLookupDisable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_SRC_MAC_LEARNING) {
-		bridge_port[i].bSrcMacLearningDisable = param->
-			bSrcMacLearningDisable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MAC_SPOOFING) {
-		bridge_port[i].bMacSpoofingDetectEnable = param->
-			bMacSpoofingDetectEnable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_PORT_LOCK)
-		bridge_port[i].bPortLockEnable = param->bPortLockEnable;
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_VLAN_FILTER) {
-		bridge_port[i].bBypassEgressVlanFilter1 = param->
-			bBypassEgressVlanFilter1;
-		bridge_port[i].bIngressVlanFilterEnable = param->
-			bIngressVlanFilterEnable;
-		bridge_port[i].nIngressVlanFilterBlockId = param->
-			nIngressVlanFilterBlockId;
-		/*bridge_port[i].nIngressVlanFilterBlockSize = param->
-		 *nIngressVlanFilterBlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN_FILTER1) {
-		bridge_port[i].bEgressVlanFilter1Enable = param->
-			bEgressVlanFilter1Enable;
-		bridge_port[i].nEgressVlanFilter1BlockId = param->
-			nEgressVlanFilter1BlockId;
-		/*bridge_port[i].nEgressVlanFilter1BlockSize = param->
-		 *nEgressVlanFilter1BlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN_FILTER2) {
-		bridge_port[i].bEgressVlanFilter2Enable = param->
-			bEgressVlanFilter2Enable;
-		bridge_port[i].nEgressVlanFilter2BlockId = param->
-			nEgressVlanFilter2BlockId;
-		/*bridge_port[i].nEgressVlanFilter2BlockSize = param->
-		 *nEgressVlanFilter2BlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MAC_LEARNING_LIMIT) {
-		bridge_port[i].bMacLearningLimitEnable = param->
-			bMacLearningLimitEnable;
-		bridge_port[i].nMacLearningLimit = param->nMacLearningLimit;
-	}
-	return 0;
-}
-
-int BridgePortConfigGet(GSW_BRIDGE_portConfig_t *param)
-{
-	int i = param->nBridgePortId;
-	//int k;
-
-	if (param->nBridgePortId >= MAX_BRIDGE_PORT) {
-		PR_ERR("wrong bridge port %d\n", param->nBridgePortId);
-		return GSW_statusErr;
-	}
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID)
-		param->nBridgeId = bridge_port[i].nBridgeId;
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_VLAN) {
-		param->bIngressExtendedVlanEnable = bridge_port[i].
-			bIngressExtendedVlanEnable;
-
-		param->nIngressExtendedVlanBlockId = bridge_port[i].
-			nIngressExtendedVlanBlockId;
-		/*param->nIngressExtendedVlanBlockSize = bridge_port[i].
-		 *nIngressExtendedVlanBlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN) {
-		param->bEgressExtendedVlanEnable = bridge_port[i].
-			bEgressExtendedVlanEnable;
-		param->nEgressExtendedVlanBlockId = bridge_port[i].
-			nEgressExtendedVlanBlockId;
-		/*param->nEgressExtendedVlanBlockSize = bridge_port[i].
-		 *nEgressExtendedVlanBlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_MARKING)
-		param->eIngressMarkingMode = bridge_port[i].eIngressMarkingMode;
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_REMARKING) {
-		param->eEgressRemarkingMode = bridge_port[i].
-			eEgressRemarkingMode;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_METER) {
-		param->bIngressMeteringEnable = bridge_port[i].
-			bIngressMeteringEnable;
-		param->nIngressTrafficMeterId = bridge_port[i].
-			nIngressTrafficMeterId;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_SUB_METER) {
-		memcpy(param->bEgressSubMeteringEnable, bridge_port[i].
-		       bEgressSubMeteringEnable,
-		       sizeof(bridge_port[i].bEgressSubMeteringEnable));
-		memcpy(param->nEgressTrafficSubMeterId, bridge_port[i].
-		       nEgressTrafficSubMeterId,
-		       sizeof(bridge_port[i].nEgressTrafficSubMeterId));
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_CTP_MAPPING) {
-#define PMAPPER_BLOCK_SIZE 36
-		param->bPmapperEnable = bridge_port[i].bPmapperEnable;
-		param->nDestLogicalPortId = bridge_port[i].nDestLogicalPortId;
-		param->ePmapperMappingMode = bridge_port[i].ePmapperMappingMode;
-		memcpy(&param->sPmapper, &bridge_port[i].sPmapper,
-		       sizeof(param->sPmapper));
-	}
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP) {
-		memcpy(param->nBridgePortMap, bridge_port[i].nBridgePortMap,
-		       sizeof(bridge_port[i].nBridgePortMap));
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_DEST_IP_LOOKUP) {
-		param->bMcDestIpLookupDisable = bridge_port[i].
-			bMcDestIpLookupDisable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_SRC_IP_LOOKUP) {
-		param->bMcSrcIpLookupEnable = bridge_port[i].
-			bMcSrcIpLookupEnable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_DEST_MAC_LOOKUP) {
-		param->bDestMacLookupDisable = bridge_port[i].
-			bDestMacLookupDisable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_SRC_MAC_LEARNING) {
-		param->bSrcMacLearningDisable = bridge_port[i].
-			bSrcMacLearningDisable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MAC_SPOOFING) {
-		param->bMacSpoofingDetectEnable = bridge_port[i].
-			bMacSpoofingDetectEnable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_PORT_LOCK)
-		param->bPortLockEnable = bridge_port[i].bPortLockEnable;
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_VLAN_FILTER) {
-		param->bBypassEgressVlanFilter1 = bridge_port[i].
-			bBypassEgressVlanFilter1;
-		param->bIngressVlanFilterEnable = bridge_port[i].
-			bIngressVlanFilterEnable;
-		param->nIngressVlanFilterBlockId = bridge_port[i].
-			nIngressVlanFilterBlockId;
-		/*param->nIngressVlanFilterBlockSize = bridge_port[i].
-		 *nIngressVlanFilterBlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN_FILTER1) {
-		param->bEgressVlanFilter1Enable = bridge_port[i].
-			bEgressVlanFilter1Enable;
-		param->nEgressVlanFilter1BlockId = bridge_port[i].
-			nEgressVlanFilter1BlockId;
-		/*param->nEgressVlanFilter1BlockSize = bridge_port[i].
-		 *nEgressVlanFilter1BlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN_FILTER2) {
-		param->bEgressVlanFilter2Enable = bridge_port[i].
-			bEgressVlanFilter2Enable;
-		param->nEgressVlanFilter2BlockId = bridge_port[i].
-			nEgressVlanFilter2BlockId;
-		/*param->nEgressVlanFilter2BlockSize = bridge_port[i].
-		 *nEgressVlanFilter2BlockSize;
-		 */
-	}
-
-	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MAC_LEARNING_LIMIT) {
-		param->bMacLearningLimitEnable = bridge_port[i].
-			bMacLearningLimitEnable;
-		param->nMacLearningLimit = bridge_port[i].nMacLearningLimit;
-	}
-	return 0;
-}
-
-int BridgeConfigSet(GSW_BRIDGE_config_t *param)
-{
-	int i = param->nBridgeId;
-
-	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_MAC_LEARNING_LIMIT) {
-		bridge[i].bMacLearningLimitEnable = param->
-			bMacLearningLimitEnable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_SUB_METER) {
-		memcpy(bridge[i].bSubMeteringEnable, param->bSubMeteringEnable,
-		       sizeof(bridge[i].bSubMeteringEnable));
-		memcpy(bridge[i].nTrafficSubMeterId, param->nTrafficSubMeterId,
-		       sizeof(bridge[i].nTrafficSubMeterId));
-	}
-
-	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_FORWARDING_MODE) {
-		bridge[i].eForwardBroadcast = param->eForwardBroadcast;
-		bridge[i].eForwardUnknownUnicast = param->
-			eForwardUnknownUnicast;
-		bridge[i].eForwardUnknownMulticastNonIp = param->
-			eForwardUnknownMulticastNonIp;
-	}
-	return 0;
-}
-
-int BridgeConfigGet(GSW_BRIDGE_config_t *param)
-{
-	int i = param->nBridgeId;
-
-	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_MAC_LEARNING_LIMIT) {
-		param->bMacLearningLimitEnable = bridge[i].
-			bMacLearningLimitEnable;
-	}
-
-	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_SUB_METER) {
-		memcpy(param->bSubMeteringEnable, bridge[i].bSubMeteringEnable,
-		       sizeof(bridge[i].bSubMeteringEnable));
-		memcpy(param->nTrafficSubMeterId, bridge[i].nTrafficSubMeterId,
-		       sizeof(bridge[i].nTrafficSubMeterId));
-	}
-
-	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_FORWARDING_MODE) {
-		param->eForwardBroadcast = bridge[i].eForwardBroadcast;
-		param->eForwardUnknownUnicast = bridge[i].
-			eForwardUnknownUnicast;
-		param->eForwardUnknownMulticastNonIp = bridge[i].
-			eForwardUnknownMulticastNonIp;
-	}
-	return 0;
-}
-
-#define MAX_EXTENDVLAN  512
-u8 extvlan_f[MAX_EXTENDVLAN] = {0};
-GSW_EXTENDEDVLAN_alloc_t extvlan_alloc[MAX_EXTENDVLAN] = {0};
-GSW_EXTENDEDVLAN_config_t extvlan[MAX_EXTENDVLAN] = {0};
-GSW_return_t ExtendedVlanAlloc(GSW_EXTENDEDVLAN_alloc_t *param)
-{
-	int i, j;
-
-	for (i = 1; i < MAX_EXTENDVLAN; i++) {
-		if (extvlan_f[i])
-			continue;
-		for (j = 0; j < param->nNumberOfEntries; j++)
-			if (extvlan_f[i + j])
-				continue;
-		param->nExtendedVlanBlockId = i;
-		for (j = 0; j < param->nNumberOfEntries; j++) {
-			extvlan_f[i + j] = 1;
-			extvlan_alloc[i + j].nExtendedVlanBlockId = i;
-			extvlan_alloc[i + j].nNumberOfEntries =  param->
-				nNumberOfEntries;
-		}
-		return 0;
-	}
-	return -1;
-}
-
-int ExtendedVlanFree(GSW_EXTENDEDVLAN_alloc_t *param)
-{
-	int i;
-
-	for (i = 0; i < extvlan_alloc[param->nExtendedVlanBlockId].
-	     nNumberOfEntries ; i++)
-		extvlan_f[i + param->nExtendedVlanBlockId] = 0;
-	return 0;
-}
-
-GSW_return_t ExtendedVlanSet(GSW_EXTENDEDVLAN_config_t *param)
-{ /*Note: not support pmapper here */
-	u32 idx = param->nExtendedVlanBlockId + param->nEntryIndex;
-
-	if (idx >= MAX_EXTENDVLAN) {
-		PR_ERR("ERROR : idx %d >= %d\n", idx, MAX_EXTENDVLAN);
-		return -1;
-	}
-
-	memcpy(&extvlan[idx].sFilter, &param->sFilter,
-	       sizeof(extvlan[idx].sFilter));
-	memcpy(&extvlan[idx].sTreatment, &param->sTreatment,
-	       sizeof(extvlan[idx].sTreatment));
-
-	return 0;
-}
-
-GSW_return_t ExtendedVlanGet(GSW_EXTENDEDVLAN_config_t *param)
-{ /*Note: not support pmapper here */
-	u32 idx = param->nExtendedVlanBlockId + param->nEntryIndex;
-
-	if (idx >= MAX_EXTENDVLAN) {
-		PR_ERR("ERROR: idx %d >= %d\n", idx, MAX_EXTENDVLAN);
-		return -1;
-	}
-	memcpy(&param->sFilter, &extvlan[idx].sFilter,
-	       sizeof(extvlan[idx].sFilter));
-	memcpy(&param->sTreatment, &extvlan[idx].sTreatment,
-	       sizeof(extvlan[idx].sTreatment));
-
-	return 0;
-}
-
-//TODO Yet to test below simulation code completely
-//#define MAC_MAX_ENTRY 4096
-#define MAC_MAX_ENTRY 10
-u8 mac_f[MAC_MAX_ENTRY];
-GSW_MAC_tableAdd_t MacAdd[MAC_MAX_ENTRY];
-
-int MacTableAdd(GSW_MAC_tableAdd_t *param)
-{
-	int i;
-
-	for (i = 0; i < MAC_MAX_ENTRY; i++) {
-		if (mac_f[i]) {
-			continue;
-		} else {
-			PR_ERR("MAC add i(%d) value\n", i);
-			mac_f[i] = 1;
-			break;
-		}
-	}
-
-	if (param->nPortId >= MAX_BRIDGE_PORT) {
-		PR_ERR("wrong bridge port for MAC add%d\n", param->nPortId);
-		return GSW_statusErr;
-	}
-
-	if (param->nPortMap) {
-		memcpy(MacAdd[i].nPortMap, param->nPortMap,
-		       sizeof(param->nPortMap));
-	}
-	MacAdd[i].nFId = param->nFId;
-	MacAdd[i].bStaticEntry = param->bStaticEntry;
-	MacAdd[i].nPortId = param->nPortId;
-	MacAdd[i].nSubIfId = param->nSubIfId;
-	memcpy(MacAdd[i].nMAC, param->nMAC, sizeof(param->nMAC));
-	PR_ERR("MAC add for entry:%d %02x:%02x:%02x:%02x:%02x:%02x\n", i,
-	       MacAdd[i].nMAC[0], MacAdd[i].nMAC[1], MacAdd[i].nMAC[2],
-	       MacAdd[i].nMAC[3], MacAdd[i].nMAC[4], MacAdd[i].nMAC[5]);
-	return 0;
-}
-
-int MacTableRemove(GSW_MAC_tableRemove_t *param)
-{
-	int i;
-
-	for (i = 0; i < MAC_MAX_ENTRY; i++) {
-		if (!mac_f[i])
-			continue;
-		if (MacAdd[i].nFId != param->nFId)
-			continue;
-		if (memcmp(MacAdd[i].nMAC, param->nMAC, sizeof(param->nMAC))) {
-			memset(&MacAdd[i], 0, sizeof(MacAdd[i]));
-			PR_ERR("MAC remove for entry:%d\n", i);
-		}
-		mac_f[i] = 0;
-		return 0;
-	}
-	return -1;
-}
-
-int MacTableQuery(GSW_MAC_tableQuery_t *param)
-{
-	int i;
-
-	for (i = 0; i < MAC_MAX_ENTRY; i++) {
-		if (!mac_f[i])
-			continue;
-		if (MacAdd[i].nFId != param->nFId)
-			continue;
-		if (memcmp(MacAdd[i].nMAC, param->nMAC, sizeof(param->nMAC))) {
-			param->nFId = MacAdd[i].nFId;
-			param->bFound = 1;
-			param->nPortId = MacAdd[i].nPortId;
-			param->nSubIfId = MacAdd[i].nSubIfId;
-			param->bStaticEntry = MacAdd[i].bStaticEntry;
-			memcpy(param->nPortMap,
-			       MacAdd[i].nPortMap,
-			       sizeof(MacAdd[i].nPortMap));
-			memcpy(param->nMAC, MacAdd[i].nMAC,
-			       sizeof(MacAdd[i].nMAC));
-
-		PR_ERR("%d    %d    %d	%02x:%02x:%02x:%02x:%02x:%02x\n",
-		       param->nFId, param->nPortId,
-		       param->bStaticEntry,
-		       param->nMAC[0], param->nMAC[1], param->nMAC[2],
-		       param->nMAC[3], param->nMAC[4], param->nMAC[5]);
-			return 0;
-		} else if (MacAdd[i].nPortId == param->nPortId) {
-			param->nFId = MacAdd[i].nFId;
-			param->bFound = 1;
-			param->nPortId = MacAdd[i].nPortId;
-			param->nSubIfId = MacAdd[i].nSubIfId;
-			memcpy(param->nPortMap,
-			       MacAdd[i].nPortMap,
-			       sizeof(MacAdd[i].nPortMap));
-			memcpy(param->nMAC, MacAdd[i].nMAC,
-			       sizeof(MacAdd[i].nMAC));
-			return 0;
-		}
-	}
-	PR_ERR("MAC Tbl query not match\n");
-	return -1;
-}
-
-int MacTableRead(GSW_MAC_tableRead_t *param)
-{
-	int i;
-
-	PR_ERR("MAC Tbl read\n");
-	for (i = 0; i < MAC_MAX_ENTRY; i++) {
-		if (!mac_f[i])
-			return -1;
-		param->nFId = MacAdd[i].nFId;
-		param->nPortId = MacAdd[i].nPortId;
-		param->nSubIfId = MacAdd[i].nSubIfId;
-		param->bStaticEntry = MacAdd[i].bStaticEntry;
-		memcpy(param->nPortMap,
-		       MacAdd[i].nPortMap,
-		       sizeof(MacAdd[i].nPortMap));
-		memcpy(param->nMAC, MacAdd[i].nMAC,
-		       sizeof(MacAdd[i].nMAC));
-	}
-	return 0;
-}
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_gswip_simulate.h b/drivers/net/datapath/dpm/gswip32/datapath_gswip_simulate.h
deleted file mode 100644
index a69fabc46301..000000000000
--- a/drivers/net/datapath/dpm/gswip32/datapath_gswip_simulate.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) Intel Corporation
- * Author: Shao Guohua <guohua.shao@intel.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- */
-
-#ifndef DATAPATH_GSWIP_SIMULATE_H_
-#define DATAPATH_GSWIP_SIMULATE_H_
-
-u32  Pmapper_Alloc(int size);
-int Pmapper_Free(u32 offset, int size);
-int CTP_PortAssignmentAlloc(GSW_CTP_portAssignment_t *param);
-int CTP_PortAssignmentFree(GSW_CTP_portAssignment_t *param);
-int CTP_PortAssignmentSet(GSW_CTP_portAssignment_t *param);
-int CTP_PortAssignmentGet(GSW_CTP_portAssignment_t *param);
-int CtpPortConfigSet(GSW_CTP_portConfig_t *param);
-int CtpPortConfigGet(GSW_CTP_portConfig_t *param);
-int BridgePortAlloc(GSW_BRIDGE_portConfig_t *param);
-int BridgePortFree(GSW_BRIDGE_portConfig_t *param);
-int BridgeAlloc(GSW_BRIDGE_alloc_t *param);
-int BridgeFree(GSW_BRIDGE_alloc_t *param);
-int BridgePortConfigSet(GSW_BRIDGE_portConfig_t *param);
-int BridgePortConfigGet(GSW_BRIDGE_portConfig_t *param);
-int BridgeConfigSet(GSW_BRIDGE_config_t *param);
-int BridgeConfigGet(GSW_BRIDGE_config_t *param);
-int MacTableAdd(GSW_MAC_tableAdd_t *param);
-int MacTableRemove(GSW_MAC_tableRemove_t *param);
-int MacTableQuery(GSW_MAC_tableQuery_t *param);
-int MacTableRead(GSW_MAC_tableAdd_t *param);
-
-GSW_return_t ExtendedVlanAlloc(GSW_EXTENDEDVLAN_alloc_t *param);
-int ExtendedVlanFree(GSW_EXTENDEDVLAN_alloc_t *param);
-GSW_return_t ExtendedVlanSet(GSW_EXTENDEDVLAN_config_t *param);
-GSW_return_t ExtendedVlanGet(GSW_EXTENDEDVLAN_config_t *param);
-#endif
-
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_misc.c b/drivers/net/datapath/dpm/gswip32/datapath_misc.c
index 25dd3d7f99ef..42425c157645 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_misc.c
@@ -1118,14 +1118,7 @@ int dp_platform_queue_set_32(int inst, u32 flag)
 	/*Alloc queue/scheduler/port per CPU port */
 	cpu.dp_inst = inst;
 	cpu.cbm_inst = dp_port_prop[inst].cbm_inst;
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_DDR_SIMULATE_GSWIP32)
-	cpu.dq_tx_push_info[0].deq_port = 0;
-	cpu.dq_tx_push_info[1].deq_port = -1;
-	cpu.dq_tx_push_info[2].deq_port = -1;
-	cpu.dq_tx_push_info[3].deq_port = -1;
-#else
 	ret = cbm_cpu_port_get(&cpu, 0);
-#endif
 	if (ret == -1) {
 		PR_ERR("%s fail for CPU Port. Why ???\n",
 		       "cbm_cpu_port_get");
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_misc.h b/drivers/net/datapath/dpm/gswip32/datapath_misc.h
index fbe045272329..f4f141862b7a 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_misc.h
+++ b/drivers/net/datapath/dpm/gswip32/datapath_misc.h
@@ -210,23 +210,8 @@ void set_chksum(struct pmac_tx_hdr *pmac, u32 tcp_type,
 
 int dp_lan_wan_bridging(int port_id, struct sk_buff *skb);
 
-
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_DDR_SIMULATE_GSWIP32)
-GSW_return_t gsw_core_api_ddr_simu32(dp_gsw_cb func, void *ops, void *param);
-#define GSW_SIMUTE_DDR_NOT_MATCH  0x1234
-#endif
-
 static inline GSW_return_t gsw_core_api(dp_gsw_cb func, void *ops, void *param)
 {
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_DDR_SIMULATE_GSWIP32)
-	{
-		GSW_return_t res;
-
-		res = gsw_core_api_ddr_simu32(func, ops, param);
-		if (res != GSW_SIMUTE_DDR_NOT_MATCH)
-			return res;
-	}
-#endif /*CONFIG_INTEL_DATAPATH_DDR_SIMULATE_GSWIP32*/
 	return func(ops, param);
 }
 
diff --git a/include/net/datapath_api.h b/include/net/datapath_api.h
index bb644b051307..b586b60b95e4 100644
--- a/include/net/datapath_api.h
+++ b/include/net/datapath_api.h
@@ -15,13 +15,12 @@
 #include <linux/atmdev.h>
 
 #ifndef DATAPATH_HAL_LAYER
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_SIMULATE_GSWIP32) || \
+#if IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP32) || \
 	IS_ENABLED(CONFIG_SOC_LGM) || \
 	IS_ENABLED(CONFIG_X86_INTEL_LGM)
 #include <net/datapath_api_gswip32.h>
 #include <net/datapath_api_ppv4.h>
-#elif IS_ENABLED(CONFIG_PRX300_CQM) || \
-	IS_ENABLED(CONFIG_INTEL_DATAPATH_DDR_SIMULATE_GSWIP31) /*testing only */
+#elif IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP31)
 #include <net/datapath_api_gswip31.h>
 #elif IS_ENABLED(CONFIG_GRX500_CBM) /*GRX500 GSWIP30*/
 #include <net/datapath_api_gswip30.h>
