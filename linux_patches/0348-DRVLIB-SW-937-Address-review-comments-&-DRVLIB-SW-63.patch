From 30a51221dea97e8ac61034cb7c203147bc1cec95 Mon Sep 17 00:00:00 2001
From: Rekha Eswaran <rekha.eswaran@intel.com>
Date: Tue, 23 Oct 2018 14:01:23 +0800
Subject: [PATCH] DRVLIB_SW-937: Address review comments & DRVLIB_SW-634: DP
 print clean up

---
 drivers/net/ethernet/lantiq/datapath/datapath.h    |  4 +-
 .../net/ethernet/lantiq/datapath/datapath_api.c    | 31 +++-------------
 .../lantiq/datapath/datapath_logical_dev.c         |  2 +-
 .../net/ethernet/lantiq/datapath/datapath_misc.c   | 35 +++++++++++-------
 .../net/ethernet/lantiq/datapath/datapath_swdev.c  | 43 ++++++++++------------
 .../lantiq/datapath/gswip31/datapath_ext_vlan.c    | 18 ++++-----
 .../lantiq/datapath/gswip31/datapath_mib.c         |  6 +--
 .../lantiq/datapath/gswip31/datapath_misc.c        |  8 ++--
 .../lantiq/datapath/gswip31/datapath_ppv4.c        | 17 ++++-----
 .../lantiq/datapath/gswip31/datapath_ppv4_api.c    | 16 ++++----
 .../lantiq/datapath/gswip31/datapath_proc.c        |  1 -
 include/net/datapath_api.h                         |  2 +-
 12 files changed, 79 insertions(+), 104 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/datapath/datapath.h b/drivers/net/ethernet/lantiq/datapath/datapath.h
index 6e4578291a6d..8d86383bb671 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath.h
+++ b/drivers/net/ethernet/lantiq/datapath/datapath.h
@@ -53,7 +53,7 @@
 
 #ifdef LOGF_KLOG_INFO
 #undef PR_INFO
-#define PR_INFO LOGF_KLOG_ERROR
+#define PR_INFO LOGF_KLOG_INFO
 #else
 #undef PR_INFO
 #define PR_INFO printk
@@ -122,9 +122,11 @@
 #define DP_SPIN_LOCK 
 #endif
 #ifdef DP_SPIN_LOCK
+#define DP_DEFINE_LOCK(lock) DEFINE_SPINLOCK(lock)
 #define DP_LIB_LOCK    spin_lock_bh
 #define DP_LIB_UNLOCK  spin_unlock_bh
 #else
+#define DP_DEFINE_LOCK(lock) DEFINE_MUTEX(lock)
 #define DP_LIB_LOCK    mutex_lock
 #define DP_LIB_UNLOCK  mutex_unlock
 #endif
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_api.c b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
index aba5fa92bca3..4f55da820622 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_api.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
@@ -90,11 +90,7 @@ char *dp_port_status_str[] = {
 
 static int try_walkaround;
 static int dp_init_ok;
-#ifdef DP_SPIN_LOCK
-static DEFINE_SPINLOCK(dp_lock); /*datapath spinlock*/
-#else
-static DEFINE_MUTEX(dp_lock);
-#endif
+DP_DEFINE_LOCK(dp_lock);
 unsigned int dp_dbg_err = 1; /*print error */
 static int32_t dp_rx_one_skb(struct sk_buff *skb, uint32_t flags);
 /*port 0 is reserved and never assigned to any one */
@@ -1061,8 +1057,8 @@ int32_t dp_get_netif_subifid(struct net_device *netif, struct sk_buff *skb,
 		return res;
 	}
 	memcpy(subif, &dp_subif->subif, sizeof(dp_subif->subif));
-	rcu_read_unlock_bh();
 	subifid_fn_t = dp_subif->subif_fn;
+	rcu_read_unlock_bh();
 	if (subifid_fn_t) {
 		/*subif->subif will be set by callback api itself */
 		res =
@@ -1070,6 +1066,8 @@ int32_t dp_get_netif_subifid(struct net_device *netif, struct sk_buff *skb,
 				 flags);
 		if (res != 0)
 			PR_ERR("get_netif_subifid callback function failed\n");
+	} else {
+		res = DP_SUCCESS;
 	}
 	return res;
 }
@@ -1205,7 +1203,6 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 						       dp_port_info[inst][k].
 							  subif_info[i].bp,
 						       bport);
-						//DP_LIB_UNLOCK(&dp_lock);
 						goto EXIT;
 					}
 					num++;
@@ -1248,22 +1245,6 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 	subif->port_id = port_id;
 	subif->bport = bport;
 	subif->alloc_flag = dp_port_info[inst][port_id].alloc_flags;
-	#if 0
-	subifid_fn_t = dp_port_info[inst][port_id].cb.get_subifid_fn;
-
-	if (subifid_fn_t && !(flags & DP_F_SUBIF_LOGICAL)) {
-		/*subif->subif will be set by callback api itself */
-		res =
-		    subifid_fn_t(netif, skb, subif_data, dst_mac, subif,
-				 flags);
-		if (res != 0)
-			DP_DEBUG(DP_DBG_FLAG_DBG,
-				 "get_netif_subifid callback failed\n");
-		else if (!subif->subif_num)/*back-compatible */
-			subif->subif_num = 1;
-		goto EXIT;
-	}
-	#endif
 	subif->subif_num = num;
 	for (i = 0; i < num; i++) {
 		subif->subif_list[i] = subifs[i];
@@ -2597,14 +2578,12 @@ int dp_set_min_frame_len(s32 dp_port,
 			 s32 min_frame_len,
 			 uint32_t flags)
 {
-	PR_INFO("Dummy dp_set_min_frame_len, need to implement later\n");
 	return DP_SUCCESS;
 }
 EXPORT_SYMBOL(dp_set_min_frame_len);
 
 int dp_rx_enable(struct net_device *netif, char *ifname, uint32_t flags)
 {
-	PR_INFO("Dummy dp_rx_enable, need to implement later\n");
 	return DP_SUCCESS;
 }
 EXPORT_SYMBOL(dp_rx_enable);
@@ -2635,7 +2614,7 @@ int dp_vlan_set(struct dp_tc_vlan *vlan, int flags)
 	}
 	if (vlan->mcast_flag == DP_MULTICAST_SESSION) 
 		info.dev_type |= 0x02;
-	PR_INFO("dev_type:0x%x\n", info.dev_type);
+	DP_DEBUG(DP_DBG_FLAG_PAE, "dev_type:0x%x\n", info.dev_type);
 	if (DP_CB(subif.inst, dp_tc_vlan_set))
 		return DP_CB(subif.inst, dp_tc_vlan_set)
 			    (dp_port_prop[subif.inst].ops[0],
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_logical_dev.c b/drivers/net/ethernet/lantiq/datapath/datapath_logical_dev.c
index 5ad6a5078b91..f3a63cea61a7 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_logical_dev.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_logical_dev.c
@@ -130,7 +130,7 @@ int add_logic_dev(int inst, int port_id, struct net_device *dev,
 	struct pmac_port_info *port_info;
 
 	if (!dev) {
-		DP_DEBUG(DP_DBG_FLAG_LOGIC, "dev NULL\n");
+		PR_ERR("dev NULL\n");
 		return -1;
 	}
 	base_dev = get_base_dev(dev, -1);
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_misc.c b/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
index 8d585d6155bd..08ca58800228 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
@@ -1074,21 +1074,24 @@ int get_vlan_info(struct net_device *dev, struct vlan_info *vinfo)
 	if (is_vlan_dev(dev)) {
 		num++;
 		vlan = vlan_dev_priv(dev);
-		PR_INFO("vlan proto:%x VID:%d real devname:%s\n",
-			vlan->vlan_proto, vlan->vlan_id,
-			vlan->real_dev ? vlan->real_dev->name : "NULL");
+
+		DP_DEBUG(DP_DBG_FLAG_DBG,
+			 "vlan proto:%x VID:%d real devname:%s\n",
+			 vlan->vlan_proto, vlan->vlan_id,
+			 vlan->real_dev ? vlan->real_dev->name : "NULL");
 		netdev_for_each_lower_dev(dev, lower_dev, iter) {
 			if (is_vlan_dev(lower_dev)) {
 				num++;
 				vinfo->in_proto = vlan->vlan_proto;
 				vinfo->in_vid = vlan->vlan_id;
 				vlan = vlan_dev_priv(lower_dev);
-				PR_INFO("%s:%x VID:%d %s:%s\n",
-					"Outer vlan proto",
-					vlan->vlan_proto, vlan->vlan_id,
-					"real devname",
-					vlan->real_dev ?
-					vlan->real_dev->name : "NULL");
+				DP_DEBUG(DP_DBG_FLAG_DBG,
+					 "%s:%x VID:%d %s:%s\n",
+					 "Outer vlan proto",
+					 vlan->vlan_proto, vlan->vlan_id,
+					 "real devname",
+					 vlan->real_dev ?
+					 vlan->real_dev->name : "NULL");
 				vinfo->out_proto = vlan->vlan_proto;
 				vinfo->out_vid = vlan->vlan_id;
 				vinfo->cnt = num;
@@ -1334,15 +1337,19 @@ int32_t dp_sync_subifid(struct net_device *dev, char *subif_name,
 			dp_subif_t *subif_id, struct dp_subif_data *data,
 			u32 flags)
 {
-/*Note: passing subif_name as subif_data to dp_get_netif_subifid_priv api */
-	void *subif_data;
+/*Note: passing subif_name as subif_data to dp_get_netif_subifid_priv api
+ *subif data can be any valid value other than subif_name also
+ *This is workaround for DSL case. Later they need to provide valid subif_name
+ */
+	void *subif_data = NULL;
 
-	subif_data = (void *)subif_name;
+	if (flags & DP_F_FAST_DSL)
+		subif_data = (void *)subif_name;
 	/*check flag for register / deregister to update/del */
 	if (flags & DP_F_DEREGISTER) {
 		if (data->ctp_dev)
 			dp_del_subif(data->ctp_dev, subif_data, subif_id,
-				     subif_name, flags);
+				     NULL, flags);
 
 		if (dp_get_netif_subifid_priv(dev, NULL, subif_data, NULL,
 					      subif_id, 0))
@@ -1363,7 +1370,7 @@ int32_t dp_sync_subifid(struct net_device *dev, char *subif_name,
 						      subif_id,	0))
 				return DP_FAILURE;
 			dp_update_subif(data->ctp_dev, subif_data, subif_id,
-					subif_name, flags);
+					NULL, flags);
 		}
 	}
 	return 0;
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_swdev.c b/drivers/net/ethernet/lantiq/datapath/datapath_swdev.c
index 87c7503ebeed..91bc7fdab5fd 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_swdev.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_swdev.c
@@ -42,12 +42,7 @@ static int dp_swdev_del_bport_from_list(struct br_info *br_item,
 struct hlist_head
 	g_bridge_id_entry_hash_table[DP_MAX_INST][BR_ID_ENTRY_HASH_TABLE_SIZE];
 
-#ifdef DP_SPIN_LOCK
-static DEFINE_SPINLOCK(dp_swdev_lock); /*datapath spinlock*/
-#else
-static DEFINE_MUTEX(dp_swdev_lock);
-#endif
-
+DP_DEFINE_LOCK(dp_swdev_lock);
 static inline void swdev_lock(void)
 {
 	DP_LIB_LOCK(&dp_swdev_lock);
@@ -694,11 +689,12 @@ static int dp_swdev_port_attr_set(struct net_device *dev,
 					lower_dev->name);
 			}
 		}
-		PR_INFO("flag=%d attr=%d stat=%d dev=%s orig/up_dev=%s/%s:%s\n",
-			attr->flags, attr->id, attr->u.stp_state,
-			dev->name,
-			attr->orig_dev ? attr->orig_dev->name : "NULL"
-			br_dev ? br_dev->name : "Null", buf);
+		DP_DEBUG(DP_DBG_FLAG_SWDEV,
+			 "flag=%d attr=%d stat=%d dev=%s ori/up_dev=%s/%s:%s\n",
+			 attr->flags, attr->id, attr->u.stp_state,
+			 dev->name,
+			 attr->orig_dev ? attr->orig_dev->name : "NULL"
+			 br_dev ? br_dev->name : "Null", buf);
 		return 0;
 	}
 #endif
@@ -804,12 +800,11 @@ static int dp_swdev_port_obj_add(struct net_device *dev,
 	{
 		struct net_device *br_dev = netdev_master_upper_dev_get(dev);
 
-		PR_INFO
-		("obj_add: obj-id=%d flag=%d dev=%s orig_dev=%s up-dev=%s\n",
-		 obj->id, obj->flags,
-		 dev->name,
-		 obj->orig_dev ? obj->orig_dev->name : "NULL",
-		 br_dev ? br_dev->name : "Null");
+		DP_DEBUG(DP_DBG_FLAG_SWDEV,
+			 "obj_add: obj-id=%d flag=%d dev=%s origdev=%s %s=%s\n",
+			 obj->id, obj->flags, dev->name,
+			 obj->orig_dev ? obj->orig_dev->name : "NULL", "up-dev",
+			 br_dev ? br_dev->name : "Null");
 		return 0;
 	}
 	return err; //TODO
@@ -852,12 +847,11 @@ static int dp_swdev_port_obj_del(struct net_device *dev,
 	{
 		struct net_device *br_dev = netdev_master_upper_dev_get(dev);
 
-		PR_INFO
-		("obj_del: obj-id=%d flag=%d dev=%s orig_dev=%s up-dev=%s\n",
-		 obj->id, obj->flags,
-		 dev->name,
-		 obj->orig_dev ? obj->orig_dev->name : "NULL",
-		 br_dev ? br_dev->name : "Null");
+		DP_DEBUG(DP_DBG_FLAG_SWDEV,
+			 "obj_del: obj-id=%d flag=%d dev=%s origdev=%s %s=%s\n",
+			 obj->id, obj->flags, dev->name,
+			 obj->orig_dev ? obj->orig_dev->name : "NULL", "up-dev",
+			 br_dev ? br_dev->name : "Null");
 		return 0;
 	}
 #endif
@@ -943,7 +937,8 @@ static int dp_ndo_bridge_setlink(struct net_device *dev,
 	if (!br_spec)
 		return -EINVAL;
 	nla_for_each_nested(attr, br_spec, rem) {
-		PR_INFO("nla_type(attr)=%d\n", nla_type(attr));
+		DP_DEBUG(DP_DBG_FLAG_SWDEV, "nla_type(attr)=%d\n",
+			 nla_type(attr));
 		if (nla_type(attr) != IFLA_BRIDGE_MODE)
 			continue;
 		if (nla_len(attr) < sizeof(mode))
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_ext_vlan.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_ext_vlan.c
index de27324018ce..14758eefb780 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_ext_vlan.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_ext_vlan.c
@@ -245,16 +245,14 @@ static int update_ctp(struct core_ops *ops, struct ext_vlan_info *vlan)
 		ctp.bIngressExtendedVlanEnable = LTQ_FALSE;
 		ret = ops->gsw_ctp_ops.CTP_PortConfigSet(ops, &ctp);
 		if (ret != GSW_statusOk) {
-			PR_INFO("Fail:Ingress VLan operate disable in ctp\n");
+			PR_ERR("Fail:Ingress VLan operate disable in ctp\n");
 			return -EIO;
 		}
-		PR_INFO("ingress VLan operation disabled in ctp\n");
+		PR_ERR("ingress VLan operation disabled in ctp\n");
 		alloc.nExtendedVlanBlockId = block;
 		ret = ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 		if (ret != GSW_statusOk) {
-			PR_INFO("VLAN Free fail\n");
 			return -EIO;
-			PR_INFO("VLAN Free Success\n");
 		}
 	}
 	memset(&alloc, 0, sizeof(GSW_EXTENDEDVLAN_alloc_t));
@@ -264,7 +262,7 @@ static int update_ctp(struct core_ops *ops, struct ext_vlan_info *vlan)
 	alloc.nNumberOfEntries += vlan->n_vlan1_drop * 2;
 	alloc.nNumberOfEntries += vlan->n_vlan2_drop;
 	if (alloc.nNumberOfEntries == 0) {
-		PR_INFO("nNumberOfEntries == 0 , returning to caller\n");
+		PR_ERR("nNumberOfEntries == 0 , returning to caller\n");
 		return 0;
 	}
 
@@ -312,10 +310,8 @@ static int update_ctp(struct core_ops *ops, struct ext_vlan_info *vlan)
 	ret = ops->gsw_ctp_ops.CTP_PortConfigSet(ops, &ctp);
 
 	if (ret != GSW_statusOk) {
-		PR_INFO("Enable ingress vlan in ctp fail\n");
 		return -EIO;
 	}
-	PR_INFO("Enable ingress vlan in ctp success\n");
 	return 0;
 UPDATE_ERROR:
 	ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
@@ -381,7 +377,7 @@ static int bp_add_vlan1(struct core_ops *ops, struct vlan1 *vlan,
 		ret = ops->gsw_extvlan_ops.ExtendedVlan_Set(ops, vcfg);
 
 		if (ret != GSW_statusOk) {
-			PR_INFO("Fail updating Extended VLAN entry (%u, %u).\n",
+			PR_ERR("Fail updating Extended VLAN entry (%u, %u).\n",
 				alloc.nExtendedVlanBlockId, i);
 			ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 			return -EIO;
@@ -394,7 +390,7 @@ static int bp_add_vlan1(struct core_ops *ops, struct vlan1 *vlan,
 	ret = ops->gsw_brdgport_ops.BridgePort_ConfigSet(ops, bpcfg);
 
 	if (ret != GSW_statusOk) {
-		PR_INFO("Failed in attaching Extended VLAN to Bridge Port.\n");
+		PR_ERR("Failed in attaching Extended VLAN to Bridge Port.\n");
 		ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 		return -EIO;
 	} else {
@@ -470,7 +466,7 @@ static int bp_add_vlan2(struct core_ops *ops, struct vlan2 *vlan,
 		ret = ops->gsw_extvlan_ops.ExtendedVlan_Set(ops, vcfg);
 
 		if (ret != GSW_statusOk) {
-			PR_INFO("Fail updating Extended VLAN entry (%u, %u).\n",
+			PR_ERR("Fail updating Extended VLAN entry (%u, %u).\n",
 				alloc.nExtendedVlanBlockId, i);
 			ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 			return -EIO;
@@ -483,7 +479,7 @@ static int bp_add_vlan2(struct core_ops *ops, struct vlan2 *vlan,
 	ret = ops->gsw_brdgport_ops.BridgePort_ConfigSet(ops, bpcfg);
 
 	if (ret != GSW_statusOk) {
-		PR_INFO("Failed in attaching Extended VLAN to Bridge Port.\n");
+		PR_ERR("Failed in attaching Extended VLAN to Bridge Port.\n");
 		ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 		return -EIO;
 	} else {
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_mib.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_mib.c
index b09697b493b9..b0622c6eca3f 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_mib.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_mib.c
@@ -255,8 +255,8 @@ ssize_t proc_mib_timer_write(struct file *file, const char *buf, size_t count,
 #ifndef THREAD_MODE
 	mod_timer(&exp_timer, jiffies + poll_interval);
 #endif
-	PR_INFO("new poll_interval=%u sec\n",
-		(unsigned int)poll_interval / HZ);
+	DP_DEBUG(DP_DBG_FLAG_MIB, "new poll_interval=%u sec\n",
+		 (unsigned int)poll_interval / HZ);
 	return count;
 }
 
@@ -372,7 +372,7 @@ int dp_mib_init(u32 flag)
 	exp_timer.data = 0;
 	exp_timer.function = mib_wraparound_timer_poll;
 	add_timer(&exp_timer);
-	PR_INFO("dp_mib_init done\n");
+	DP_DEBUG(DP_DBG_FLAG_MIB, "dp_mib_init done\n");
 #endif
 	return 0;
 }
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
index f6936253b7ba..6947a0239c52 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
@@ -1104,7 +1104,7 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 			 *      we need find way to get cqm_dequeue_port
 			 *      and qos_port later
 			 */
-			PR_INFO("need set cqm_dequeue_port/qos_port... ?\n");
+			PR_ERR("need set cqm_dequeue_port/qos_port... ?\n");
 			dp_q_tbl[inst][q_port.qid].cqm_dequeue_port =
 				q_port.cqe_deq;
 			dp_deq_port_tbl[inst][q_port.cqe_deq].qos_port = -1;
@@ -1121,9 +1121,9 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 		q_port.port_node =
 			dp_deq_port_tbl[inst][q_port.cqe_deq].qos_port;
 
-		PR_INFO("need to further set q_port.q_node/port_node\n");
-		PR_INFO("via special internal QOS HAL API to get it\n");
-		PR_INFO("since it is created by caller itself\n");
+		PR_ERR("need to further set q_port.q_node/port_node\n");
+		PR_ERR("via special internal QOS HAL API to get it\n");
+		PR_ERR("since it is created by caller itself\n");
 
 	} else { /*auto sharing queue: if go to here, it means sharing queue
 		  *is ready and it is created by previous dp_register_subif_ext
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_ppv4.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_ppv4.c
index e83ddcd398fb..14690cc8938b 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_ppv4.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_ppv4.c
@@ -381,7 +381,7 @@ void init_qos_fn(void)
 	qos_dev_init = pp_qos_dev_init;
 #else
 	/*all NULL function pointer */
-	PR_INFO("call QOS function pointer set to NULL\n");
+	DP_DEBUG(DP_DBG_FLAG_QOS, "call QOS function pointer set to NULL\n");
 #endif /*CONFIG_LTQ_DATAPATH_DUMMY_QOS*/
 }
 
@@ -688,7 +688,7 @@ int init_ppv4_qos(int inst, int flag)
 		return DP_FAILURE;
 	}
 	if (!(flag & DP_PLATFORM_INIT)) {
-		PR_INFO("need to implement de-initialization for qos later\n");
+		/*need to implement de-initialization for qos later*/
 		priv->qdev = NULL;
 		return DP_SUCCESS;
 	}
@@ -698,7 +698,6 @@ int init_ppv4_qos(int inst, int flag)
 		       dp_port_prop[inst].qos_inst);
 		return DP_FAILURE;
 	}
-	PR_INFO("qos_dev_open qdev=%p\n", priv->qdev);
 	t = kzalloc(sizeof(*t), GFP_ATOMIC);
 	if (!t) {
 		PR_ERR("kzalloc fail: %d bytes\n", sizeof(*t));
@@ -716,7 +715,6 @@ int init_ppv4_qos(int inst, int flag)
 		       dp_port_prop[inst].qos_inst);
 		goto EXIT;
 	}
-	PR_INFO("qos_dev_init done\n");
 	if (cbm_cpu_port_get(&cpu_data, 0)) {
 		PR_ERR("cbm_cpu_port_get for CPU port?\n");
 		goto EXIT;
@@ -733,10 +731,11 @@ int init_ppv4_qos(int inst, int flag)
 	dp_deq_port_tbl[inst][idx].tx_ring_addr = flush_port->tx_ring_addr;
 	dp_deq_port_tbl[inst][idx].tx_ring_size = flush_port->tx_ring_size;
 	dp_deq_port_tbl[inst][idx].dp_port = 0;/* dummy one */
-	PR_INFO("DP Flush port[%d]: ring addr=0x%x size=%d pkt_credit=%d\n",
-		priv->cqm_drop_p, dp_deq_port_tbl[inst][idx].tx_ring_addr,
-		dp_deq_port_tbl[inst][idx].tx_ring_size,
-		dp_deq_port_tbl[inst][idx].tx_pkt_credit);
+	DP_DEBUG(DP_DBG_FLAG_QOS,
+		 "DP Flush port[%d]: ring addr=0x%x size=%d pkt_credit=%d\n",
+		 priv->cqm_drop_p, dp_deq_port_tbl[inst][idx].tx_ring_addr,
+		 dp_deq_port_tbl[inst][idx].tx_ring_size,
+		 dp_deq_port_tbl[inst][idx].tx_pkt_credit);
 #ifdef CONFIG_LTQ_DATAPATH_QOS_HAL
 	DP_DEBUG(DP_DBG_FLAG_DBG, "priv=%p deq_port_stat=%p q_dev=%p\n",
 		 priv, priv ? priv->deq_port_stat : NULL,
@@ -906,7 +905,7 @@ int ppv4_alloc_ring_31(int size, void **phy, void **virt)
 	if (!*virt)
 		return DP_FAILURE;
 
-	*phy = virt_to_phys(virt);
+	*phy = virt_to_phys(*virt);
 
 	return DP_SUCCESS;
 }
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_ppv4_api.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_ppv4_api.c
index d3e3033efb58..9e00e5466981 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_ppv4_api.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_ppv4_api.c
@@ -1344,9 +1344,6 @@ static int dp_alloc_qos_port(struct dp_node_alloc *node, int flag)
 		PR_ERR("failed to qos_port_allocate:%d\n", cqm_deq_port);
 		goto EXIT;
 	}
-	/* PR_INFO("qos_port_alloc succeed: %d/%d\n",
-	 *	   cqm_deq_port, qos_port);
-	 */
 	/* Configure QOS dequeue port */
 	qos_port_conf_set_default(&port_cfg);
 	port_cfg.ring_address =
@@ -2660,7 +2657,7 @@ int dp_node_unlink_31(struct dp_node_link *info, int flag)
 		/* Need to check ACTIVE Flag */
 		if (!(priv->qos_queue_stat[info->node_id.q_id].flag &
 		    PP_NODE_ACTIVE)) {
-			PR_INFO("Wrong Queue[%d] Stat(%d):Expect ACTIVE\n",
+			PR_ERR("Wrong Queue[%d] Stat(%d):Expect ACTIVE\n",
 				info->node_id.q_id,
 				priv->qos_queue_stat[info->node_id.q_id].flag);
 		}
@@ -2669,7 +2666,7 @@ int dp_node_unlink_31(struct dp_node_link *info, int flag)
 	} else if (info->node_type == DP_NODE_SCH) {
 		if (!(priv->qos_sch_stat[info->node_id.sch_id].c_flag &
 								PP_NODE_ACTIVE))
-			PR_INFO("Wrong Sched FLAG Expect ACTIVE\n");
+			PR_ERR("Wrong Sched FLAG Expect ACTIVE\n");
 		if (qos_sched_conf_get(priv->qdev, info->node_id.sch_id,
 				       &sched_cfg))
 			return DP_FAILURE;
@@ -2730,8 +2727,8 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 	}
 
 	if ((!info->dp_port) && (info->dp_port != DP_PORT(info).dp_port)) {
-		PR_INFO("Fix wrong dp_port from %d to %d\n",
-			info->dp_port, DP_PORT(info).dp_port);
+		PR_ERR("Fix wrong dp_port from %d to %d\n",
+		       info->dp_port, DP_PORT(info).dp_port);
 		info->dp_port = DP_PORT(info).dp_port;
 	}
 	t = kzalloc(sizeof(*t), GFP_KERNEL);
@@ -4396,7 +4393,7 @@ int dp_node_reserve(int inst, int ep, struct dp_port_data *data, int flags)
 		res = DP_FAILURE;
 		goto FREE_EXIT;
 	}
-	PR_INFO("queue size =%d for ep=%d\n", len, ep);
+	DP_DEBUG(DP_DBG_FLAG_QOS, "queue size =%d for ep=%d\n", len, ep);
 	resv_q = priv->resv[ep].resv_q;
 	for (i = 0; i < data->num_resv_q; i++) {
 		if (qos_queue_allocate(priv->qdev, &id)) {
@@ -4442,7 +4439,8 @@ int dp_node_reserve(int inst, int ep, struct dp_port_data *data, int flags)
 
 		len = sizeof(struct resv_sch) * data->num_resv_sched;
 		priv->resv[ep].resv_sched = kzalloc(len, GFP_ATOMIC);
-		PR_INFO("sched size =%d for ep=%d\n", len, ep);
+		DP_DEBUG(DP_DBG_FLAG_QOS, "sched size =%d for ep=%d\n",
+			 len, ep);
 		if (!priv->resv[ep].resv_sched) {
 			res = DP_FAILURE;
 			goto FREE_EXIT;
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_proc.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_proc.c
index 57c48ef2e85e..7fe934e48ee0 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_proc.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_proc.c
@@ -2454,7 +2454,6 @@ int dp_sub_proc_install_31(void)
 
 	for (i = 0; i < ARRAY_SIZE(dp_proc_entries); i++)
 		dp_proc_entry_create(dp_proc_node, &dp_proc_entries[i]);
-	PR_INFO("dp_sub_proc_install ok\n");
 	return 0;
 }
 
diff --git a/include/net/datapath_api.h b/include/net/datapath_api.h
index 247abc883d8a..795bbdaadfa9 100644
--- a/include/net/datapath_api.h
+++ b/include/net/datapath_api.h
@@ -647,7 +647,7 @@ struct dp_subif_cache {
 	struct hlist_node hlist;
 	dp_subif_t subif;
 	struct net_device *dev;
-	char name[16];
+	char name[IFNAMSIZ];
 	dp_get_netif_subifid_fn_t subif_fn;  /*!< Get Sub Interface Id
 					      * of netif/netdevice
 					      */
