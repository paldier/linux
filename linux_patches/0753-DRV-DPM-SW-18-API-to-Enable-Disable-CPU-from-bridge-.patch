From 2877d8831863929392615a4e72550170dda7a38a Mon Sep 17 00:00:00 2001
From: thampan <joby.thampan@intel.com>
Date: Fri, 16 Aug 2019 14:44:49 +0800
Subject: [PATCH] DRV_DPM_SW-18: API to Enable/Disable CPU from bridge member
 list

---
 drivers/net/datapath/dpm/datapath.h               |  1 +
 drivers/net/datapath/dpm/datapath_api.c           | 35 +++++++++++++++++++++++
 drivers/net/datapath/dpm/gswip31/datapath_gswip.c | 31 ++++++++++++++++++++
 drivers/net/datapath/dpm/gswip31/datapath_misc.c  |  1 +
 drivers/net/datapath/dpm/gswip31/datapath_misc.h  |  1 +
 drivers/net/datapath/dpm/gswip32/datapath_gswip.c | 32 +++++++++++++++++++++
 drivers/net/datapath/dpm/gswip32/datapath_misc.c  |  1 +
 drivers/net/datapath/dpm/gswip32/datapath_misc.h  |  1 +
 include/net/datapath_api.h                        | 18 ++++++++++++
 include/net/datapath_inst.h                       |  2 ++
 10 files changed, 123 insertions(+)

diff --git a/drivers/net/datapath/dpm/datapath.h b/drivers/net/datapath/dpm/datapath.h
index 64aab089b0ee..dcebcae636de 100644
--- a/drivers/net/datapath/dpm/datapath.h
+++ b/drivers/net/datapath/dpm/datapath.h
@@ -454,6 +454,7 @@ struct dp_subif_info {
 	u8  pkt_only_en;
 	u8  seg_en;
 	u16 gpid;
+	bool cpu_port_en;
 };
 
 struct vlan_info {
diff --git a/drivers/net/datapath/dpm/datapath_api.c b/drivers/net/datapath/dpm/datapath_api.c
index 1e458638f42e..98a68dc1bf4d 100644
--- a/drivers/net/datapath/dpm/datapath_api.c
+++ b/drivers/net/datapath/dpm/datapath_api.c
@@ -2204,6 +2204,41 @@ int dp_vlan_set(struct dp_tc_vlan *vlan, int flags)
 }
 EXPORT_SYMBOL(dp_vlan_set);
 
+int dp_set_bp_attr(struct dp_bp_attr *conf, uint32_t flag)
+{
+	struct pmac_port_info *port_info;
+	dp_subif_t subif = {0};
+	int ret = DP_SUCCESS;
+
+	if (!conf) {
+		DP_DEBUG(DP_DBG_FLAG_DBG, "conf passed is (%s)\n",
+			 conf ? conf->dev->name : "NULL");
+		return DP_FAILURE;
+	}
+
+	DP_LIB_LOCK(&dp_lock);
+
+	if (dp_get_netif_subifid_priv(conf->dev, NULL, NULL, NULL, &subif, 0)) {
+		DP_LIB_UNLOCK(&dp_lock);
+		return DP_FAILURE;
+	}
+
+	port_info = get_dp_port_info(conf->inst, subif.port_id);
+	port_info->subif_info->cpu_port_en = conf->en;
+
+	DP_LIB_UNLOCK(&dp_lock);
+
+	/* Null check is needed since some platforms dont have this API */
+	if (!dp_port_prop[subif.inst].info.dp_set_bp_attr)
+		return DP_FAILURE;
+
+	ret = dp_port_prop[subif.inst].info.dp_set_bp_attr(conf, subif.bport,
+			flag);
+
+	return ret;
+}
+EXPORT_SYMBOL(dp_set_bp_attr);
+
 /*Return the table entry index based on dev:
  *success: >=0
  *fail: DP_FAILURE
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
index 9ca3e5b41d1e..9cb71e1f0091 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
@@ -1466,3 +1466,34 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	kfree(pce_rule);
 	return bret;
 }
+
+int dp_set_bp_attr_31(struct dp_bp_attr *conf, int bport, uint32_t flag)
+{
+	GSW_return_t ret;
+	GSW_BRIDGE_portConfig_t brportcfg;
+	struct core_ops *ops = dp_port_prop[conf->inst].ops[0];
+
+	memset(&brportcfg, 0, sizeof(GSW_BRIDGE_portConfig_t));
+
+	brportcfg.nBridgePortId = bport;
+	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
+
+	ret = ops->gsw_brdgport_ops.BridgePort_ConfigGet(ops, &brportcfg);
+	if (ret != GSW_statusOk) {
+		PR_ERR("fail in getting bridge port config\r\n");
+		return DP_FAILURE;
+	}
+
+	if (conf->en)
+		SET_BP_MAP(brportcfg.nBridgePortMap, CPU_PORT);
+	else
+		UNSET_BP_MAP(brportcfg.nBridgePortMap, CPU_PORT);
+
+	ret = ops->gsw_brdgport_ops.BridgePort_ConfigSet(ops, &brportcfg);
+	if (ret != GSW_statusOk) {
+		PR_ERR("Fail in allocating/configuring bridge port\n");
+		return DP_FAILURE;
+	}
+
+	return DP_SUCCESS;
+}
\ No newline at end of file
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_misc.c b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
index 9153364c6d50..0703b7d0ef54 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
@@ -2132,6 +2132,7 @@ int register_dp_cap_gswip31(int flag)
 	cap.info.dp_meter_alloc = dp_meter_alloc_31;
 	cap.info.dp_meter_add = dp_meter_add_31;
 	cap.info.dp_meter_del = dp_meter_del_31;
+	cap.info.dp_set_bp_attr = dp_set_bp_attr_31;
 	cap.info.dp_rx = dp_rx_31;
 	cap.info.dp_tx = dp_xmit_31;
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP31_MIB)
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_misc.h b/drivers/net/datapath/dpm/gswip31/datapath_misc.h
index 27e824ab886b..fc44fb382aba 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_misc.h
+++ b/drivers/net/datapath/dpm/gswip31/datapath_misc.h
@@ -180,6 +180,7 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 		   struct sk_buff *skb, int32_t len, uint32_t flags);
 void set_chksum(struct pmac_tx_hdr *pmac, u32 tcp_type, u32 ip_offset,
 		int ip_off_hw_adjust, u32 tcp_h_offset);
+int dp_set_bp_attr_31(struct dp_bp_attr *conf, int bport, uint32_t flag);
 
 static inline char *parser_flag_str(u8 f)
 {
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_gswip.c b/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
index f0d43161d3ae..bd9b0c9ce0c7 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
@@ -1602,3 +1602,35 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 	}
 	return DP_SUCCESS;
 }
+
+int dp_set_bp_attr_32(struct dp_bp_attr *conf, int bport, uint32_t flag)
+{
+	GSW_return_t ret;
+	GSW_BRIDGE_portConfig_t brportcfg;
+	struct core_ops *ops = dp_port_prop[conf->inst].ops[0];
+
+	memset(&brportcfg, 0, sizeof(GSW_BRIDGE_portConfig_t));
+
+	brportcfg.nBridgePortId = bport;
+	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
+
+	ret = ops->gsw_brdgport_ops.BridgePort_ConfigGet(ops, &brportcfg);
+	if (ret != GSW_statusOk) {
+		PR_ERR("fail in getting bridge port config\r\n");
+		return DP_FAILURE;
+	}
+
+	if (conf->en)
+		SET_BP_MAP(brportcfg.nBridgePortMap, CPU_PORT);
+	else
+		UNSET_BP_MAP(brportcfg.nBridgePortMap, CPU_PORT);
+
+	ret = ops->gsw_brdgport_ops.BridgePort_ConfigSet(ops, &brportcfg);
+	if (ret != GSW_statusOk) {
+		PR_ERR("Fail in allocating/configuring bridge port\n");
+		return DP_FAILURE;
+	}
+
+	return DP_SUCCESS;
+}
+
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_misc.c b/drivers/net/datapath/dpm/gswip32/datapath_misc.c
index f24a17a20c34..3cb838b633aa 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_misc.c
@@ -2184,6 +2184,7 @@ int register_dp_cap_gswip32(int flag)
 	cap.info.dp_meter_alloc = dp_meter_alloc_32;
 	cap.info.dp_meter_add = dp_meter_add_32;
 	cap.info.dp_meter_del = dp_meter_del_32;
+	cap.info.dp_set_bp_attr = dp_set_bp_attr_32;
 	cap.info.dp_rx = dp_rx_32;
 	cap.info.dp_tx = dp_xmit_32;
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP31_MIB)
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_misc.h b/drivers/net/datapath/dpm/gswip32/datapath_misc.h
index 5f3520065082..2ff7b84efec5 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_misc.h
+++ b/drivers/net/datapath/dpm/gswip32/datapath_misc.h
@@ -209,6 +209,7 @@ int32_t dp_xmit_32(struct net_device *rx_if, dp_subif_t *rx_subif,
 void set_chksum(struct pmac_tx_hdr *pmac, u32 tcp_type,
 		u32 ip_offset, int ip_off_hw_adjust,
 		u32 tcp_h_offset);
+int dp_set_bp_attr_32(struct dp_bp_attr *conf, int bport, uint32_t flag);
 
 int dp_lan_wan_bridging(int port_id, struct sk_buff *skb);
 
diff --git a/include/net/datapath_api.h b/include/net/datapath_api.h
index 3b85b957a148..3b5e02901197 100644
--- a/include/net/datapath_api.h
+++ b/include/net/datapath_api.h
@@ -1838,4 +1838,22 @@ static inline void dp_dma_parse_id(u32 dma_id, u8 *cid, u8 *pid, u16 *chid)
 	if (chid)
 		*chid = dma_id & 0xffff;
 }
+
+/*!
+ *@brief struct dp_bp_attr enable/disable CPU port in the BP member list
+ */
+struct dp_bp_attr {
+	int inst; /*!< [in] DP instance ID */
+	struct net_device *dev; /*!< [in] Network device pointer */
+	bool en; /*!< [in] DP enable/disable CPU port in the BP member list.*/
+};
+
+/*!
+ *@brief dp_set_bp_attr API
+ *@param[in/out] conf: bp attribute
+ *@param[in] flag: reserved for future
+ *@return DP_SUCCESS on succeed and DP_FAILURE on failure
+ */
+int dp_set_bp_attr(struct dp_bp_attr *conf, uint32_t flag);
+
 #endif /*DATAPATH_API_H */
diff --git a/include/net/datapath_inst.h b/include/net/datapath_inst.h
index d490b08bf5b0..3cb79fad889e 100644
--- a/include/net/datapath_inst.h
+++ b/include/net/datapath_inst.h
@@ -128,6 +128,8 @@ struct inst_info {
 			    struct dp_meter_cfg *meter, int flag,
 			    struct dp_meter_subif *mtr_subif);
 
+	int (*dp_set_bp_attr)(struct dp_bp_attr *bp_attr, int bport, u32 flags);
+
 	int32_t (*dp_rx)(struct sk_buff *skb, uint32_t flags);
 	int32_t (*dp_tx)(struct net_device *rx_if, dp_subif_t *rx_subif,
 			 struct sk_buff *skb, int32_t len, uint32_t flags);
