From c5373581922f889e3c97323f8f26148b3d3e2f03 Mon Sep 17 00:00:00 2001
From: Li Yin <yin1.li@intel.com>
Date: Thu, 9 May 2019 10:11:27 +0800
Subject: [PATCH] datapath: add TX helper library

---
 drivers/net/datapath/dpm/Makefile       |   2 +-
 drivers/net/datapath/dpm/datapath_api.c |   3 +
 drivers/net/datapath/dpm/datapath_tx.c  | 150 ++++++++++++++++++++++++++++++++
 drivers/net/datapath/dpm/datapath_tx.h  |  18 ++++
 include/net/datapath_api_tx.h           |  96 ++++++++++++++++++++
 5 files changed, 268 insertions(+), 1 deletion(-)

diff --git a/drivers/net/datapath/dpm/Makefile b/drivers/net/datapath/dpm/Makefile
index fa6fd06caa7e..9ade1af5f09c 100644
--- a/drivers/net/datapath/dpm/Makefile
+++ b/drivers/net/datapath/dpm/Makefile
@@ -1,4 +1,4 @@
-obj-$(CONFIG_INTEL_DATAPATH) = datapath_api.o datapath_proc_api.o datapath_proc.o  datapath_misc.o datapath_notifier.o datapath_logical_dev.o datapath_instance.o datapath_platform_dev.o datapath_soc.o datapath_qos.o datapath_proc_qos.o
+obj-$(CONFIG_INTEL_DATAPATH) = datapath_api.o datapath_proc_api.o datapath_proc.o  datapath_misc.o datapath_notifier.o datapath_logical_dev.o datapath_instance.o datapath_platform_dev.o datapath_soc.o datapath_qos.o datapath_proc_qos.o datapath_tx.o
 
 ifneq ($(CONFIG_INTEL_DATAPATH_HAL_GSWIP32),)
 obj-$(CONFIG_INTEL_DATAPATH) += gswip32/
diff --git a/drivers/net/datapath/dpm/datapath_api.c b/drivers/net/datapath/dpm/datapath_api.c
index 88896283f0d2..1e49e2603d3f 100644
--- a/drivers/net/datapath/dpm/datapath_api.c
+++ b/drivers/net/datapath/dpm/datapath_api.c
@@ -24,6 +24,7 @@
 #include <net/ip.h>
 #include <net/datapath_api.h>
 #include "datapath.h"
+#include "datapath_tx.h"
 #include "datapath_instance.h"
 #include "datapath_swdev_api.h"
 
@@ -2258,6 +2259,8 @@ int dp_basic_proc(void)
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_SWITCHDEV)
 	dp_switchdev_init();
 #endif
+	if (dp_tx_init(0))
+		return -ENOMEM;
 	return 0;
 }
 
diff --git a/drivers/net/datapath/dpm/datapath_tx.c b/drivers/net/datapath/dpm/datapath_tx.c
new file mode 100644
index 000000000000..50705294fb3c
--- /dev/null
+++ b/drivers/net/datapath/dpm/datapath_tx.c
@@ -0,0 +1,150 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+#include "datapath.h"
+#include "datapath_tx.h"
+
+struct tx_entry {
+	tx_fn cb;
+	void *priv;
+};
+
+/**
+ * struct tx_stored - entries been set
+ * @process: external process
+ * @preprocess: internal preprocess
+ * @preprocess_always_enabled: process even when hook is not registered
+ */
+struct tx_stored {
+	struct tx_entry process;
+	struct tx_entry preprocess;
+	bool preprocess_always_enabled;
+};
+
+/**
+ * struct tx_hook_list - datapath TX call chain
+ * @fn: callback function, sorted by priority
+ * @cnt: number of callback function
+ */
+struct tx_hook_list {
+	struct rcu_head rcu_head;
+	struct tx_entry chain[DP_TX_CNT * 2];
+	u8 cnt;
+};
+
+/**
+ * struct dp_tx_context - datapath TX runtime
+ * @lock: Lock to pretect concurrent update
+ * @en: TX list for reader
+ * @stored: TX lists for updater
+ */
+struct dp_tx_context {
+	spinlock_t lock;
+	struct tx_hook_list __rcu *en;
+	struct tx_stored stored[DP_TX_CNT];
+};
+
+static struct dp_tx_context *dp_tx_ctx;
+
+int dp_tx_update_list(void)
+{
+	struct dp_tx_context *ctx = dp_tx_ctx;
+	struct tx_hook_list *new_data;
+	struct tx_hook_list *old_data;
+	u8 cnt = 0;
+	u8 i;
+
+	/* update list for fast read */
+	new_data = kmalloc(sizeof(struct tx_hook_list), GFP_ATOMIC);
+	if (!new_data)
+		return -ENOMEM;
+	/* add spin lock to protect modules update TX list concurrently */
+	spin_lock(&ctx->lock);
+	for (i = 0; i < DP_TX_CNT; i++) {
+		const struct tx_stored *s = &ctx->stored[i];
+		bool en = s->preprocess_always_enabled || s->process.cb;
+
+		if (s->preprocess.cb && en) {
+			memcpy(&new_data->chain[cnt++], &s->preprocess,
+			       sizeof(struct tx_entry));
+		}
+		if (s->process.cb) {
+			memcpy(&new_data->chain[cnt++], &s->process,
+			       sizeof(struct tx_entry));
+		}
+	}
+	new_data->cnt = cnt;
+	old_data = rcu_access_pointer(ctx->en);
+	rcu_assign_pointer(ctx->en, new_data);
+	spin_unlock(&ctx->lock);
+
+	if (old_data)
+		kfree_rcu(old_data, rcu_head);
+	return 0;
+}
+
+void dp_tx_register_process(enum DP_TX_PRIORITY priority, tx_fn fn, void *priv)
+{
+	struct tx_stored *s;
+
+	if (!dp_tx_ctx)
+		return;
+	s = &dp_tx_ctx->stored[priority];
+	s->process.cb = fn;
+	s->process.priv = priv;
+}
+
+void dp_tx_register_preprocess(enum DP_TX_PRIORITY priority, tx_fn fn,
+			       void *priv, bool always_enabled)
+{
+	struct tx_stored *s;
+
+	if (!dp_tx_ctx)
+		return;
+	s = &dp_tx_ctx->stored[priority];
+	s->preprocess.cb = fn;
+	s->preprocess.priv = priv;
+	s->preprocess_always_enabled = always_enabled;
+}
+
+int dp_tx_start(struct sk_buff *skb, struct dp_tx_common *cmn)
+{
+	int ret = DP_XMIT_ERR_NOT_INIT;
+	struct tx_hook_list *list;
+	u8 cnt;
+	u8 i;
+
+	/* dp_tx_start() could be called in either normal context or softirq */
+	rcu_read_lock();
+	list = rcu_dereference(dp_tx_ctx->en);
+	cnt = list->cnt;
+	for (i = 0; i < cnt; i++) {
+		const struct tx_entry *entry = &list->chain[i];
+
+		ret = entry->cb(skb, cmn, entry->priv);
+		if (ret != DP_TX_FN_CONTINUE)
+			break;
+	}
+	rcu_read_unlock();
+	return ret;
+}
+
+int dp_tx_init(int inst)
+{
+	if (inst)
+		return 0;
+	dp_tx_ctx = kzalloc(sizeof(struct dp_tx_context), GFP_ATOMIC);
+	if (!dp_tx_ctx)
+		return -ENOMEM;
+	spin_lock_init(&dp_tx_ctx->lock);
+	return 0;
+}
+
+int dp_register_tx(enum DP_TX_PRIORITY priority, tx_fn fn, void *priv)
+{
+	if (!dp_tx_ctx)
+		return -ENOMEM;
+	dp_tx_register_process(priority, fn, priv);
+	return dp_tx_update_list();
+}
+EXPORT_SYMBOL(dp_register_tx);
diff --git a/drivers/net/datapath/dpm/datapath_tx.h b/drivers/net/datapath/dpm/datapath_tx.h
new file mode 100644
index 000000000000..83b93d57ef6a
--- /dev/null
+++ b/drivers/net/datapath/dpm/datapath_tx.h
@@ -0,0 +1,18 @@
+#ifndef DATAPATH_TX_H_7PAJCKO6
+#define DATAPATH_TX_H_7PAJCKO6
+
+#include <net/datapath_api_tx.h>
+
+int dp_tx_init(int inst);
+
+void dp_tx_register_process(enum DP_TX_PRIORITY priority, tx_fn fn,
+			    void *priv);
+
+void dp_tx_register_preprocess(enum DP_TX_PRIORITY priority, tx_fn fn,
+			       void *priv, bool always_enabled);
+
+int dp_tx_update_list(void);
+
+int dp_tx_start(struct sk_buff *skb, struct dp_tx_common *cmn);
+
+#endif /* end of include guard: DATAPATH_TX_H_7PAJCKO6 */
diff --git a/include/net/datapath_api_tx.h b/include/net/datapath_api_tx.h
new file mode 100644
index 000000000000..f87fb0883c8a
--- /dev/null
+++ b/include/net/datapath_api_tx.h
@@ -0,0 +1,96 @@
+#ifndef DATAPATH_API_TX_H_34JWW7RR
+#define DATAPATH_API_TX_H_34JWW7RR
+
+/*! @{ */
+/*!
+ * @file datapath_api_tx.h
+ *
+ * @brief &nbsp; Datapath TX path API
+ */
+ /*! @} */
+
+#ifndef DP_TX_FN_CONTINUE
+#define DP_TX_FN_CONTINUE 1 /*!< @brief return this value in callback
+			       function to continue execution */
+#endif /* !DP_TX_FN_CONTINUE */
+
+/**
+ * enum DP_TX_PRIORITY - define TX chain priority from high to low
+ */
+/*! @brief define TX chain priority from high to low */
+enum DP_TX_PRIORITY {
+	DP_TX_PP, /*!< packet processor */
+	DP_TX_TSO, /*!< traffic offload engine */
+	DP_TX_VPNA, /*!< VPN adapter */
+	DP_TX_CQM,  /*!< CQM CPU port */
+	DP_TX_CNT,
+};
+
+/**
+ * enum DP_TX_FLAGS - define TX path common flags
+ */
+/*! @brief define TX path common flags */
+enum DP_TX_FLAGS {
+	DP_TX_FLAG_INSERT_PMAC = BIT(0), /*!< insert PMAC header*/
+	DP_TX_FLAG_STREAM_PORT = BIT(1), /*!< is stream port*/
+	DP_TX_FLAG_SKIP_NEXT = BIT(2), /*!< skip next TX call*/
+};
+
+/**
+ * struct dp_tx_common - datapath TX callback parameters
+ * @flags: bitmap of DP_TX_FLAGS
+ * @private: private value from dp_register_txpath()
+ */
+/*! @brief datapath TX callback parameters */
+struct dp_tx_common {
+	u8 *pmac; /*!< PMAC */
+	u32 flags; /*!< bitmap of enum DP_TX_FLAGS */
+	u8 len; /*!< length of PMAC */
+	u8 dpid; /*!< datapath port ID */
+	u8 vap; /*!< datapath port subif vap */
+	u8 gpid; /*!< GPID */
+	struct dev_mib *mib; /*!< per vap MIB */
+};
+
+/**
+ * tx_fn() - callback prototype for TX path
+ * @param[in,out] skb: skb to process
+ * @param[in,out] cmn: common data which is persist across the call chain
+ * @param[in,out] p: private parameter passed in from dp_register_tx()
+ *
+ * @Return 0 - skb consumed, stop further process;
+ *         DP_TX_FN_CONTINUE skb - not consumed, continue for further process;
+ *         others - skb not consumed with error code, stop further process
+ */
+typedef int (*tx_fn)(struct sk_buff *skb, struct dp_tx_common *cmn, void *p);
+
+/**
+ * dp_register_tx() - register datapath tx path function
+ * @priority: TX priority
+ * @tx_fn: callback function
+ * @p: parameters
+ */
+int dp_register_tx(enum DP_TX_PRIORITY priority, tx_fn fn, void *p);
+
+/**
+ * dp_tx_skip_next_call() - set to skip next TX call
+ */
+static inline void dp_tx_skip_next_call(struct dp_tx_common *cmn)
+{
+	cmn->flags |= DP_TX_FLAG_SKIP_NEXT;
+}
+
+/**
+ * dp_tx_call_skipped() - check if current call should be skipped
+ */
+static inline bool dp_tx_call_skipped(struct dp_tx_common *cmn)
+{
+	if (unlikely(cmn->flags & DP_TX_FLAG_SKIP_NEXT)) {
+		cmn->flags &= ~DP_TX_FLAG_SKIP_NEXT;
+		return true;
+	} else {
+		return false;
+	}
+}
+
+#endif /* end of include guard: DATAPATH_API_TX_H_34JWW7RR */
