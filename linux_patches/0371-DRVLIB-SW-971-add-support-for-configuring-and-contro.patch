From 80aafe85033b5f82f23aeb53122a62e3b03db9e0 Mon Sep 17 00:00:00 2001
From: arathinx <ayyappanx.rathinam@intel.com>
Date: Mon, 26 Nov 2018 15:39:48 +0800
Subject: [PATCH] DRVLIB_SW-971: add support for configuring and control EEE
 feature on Ethernet interfaces of GRX500

---
 drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c | 63 ++++++++++++++++++++++++
 1 file changed, 63 insertions(+)

diff --git a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
index 83e21aa991c2..c26db75c5d8a 100644
--- a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
+++ b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
@@ -191,6 +191,66 @@ static int nway_reset(struct net_device *dev)
 	return 0;
 }
 
+static int  ethtool_eee_get(struct net_device *dev,
+			    struct ethtool_eee *eee_data)
+{
+	struct core_ops *ops = gsw_get_swcore_ops(0);
+	GSW_portLinkCfg_t	port_link_cfg = {0};
+	int retval = EOPNOTSUPP;
+
+	port_link_cfg.nPortId = dev->dev_id;
+	retval = ops->gsw_common_ops.PortLinkCfgGet(ops, &port_link_cfg);
+
+	if (retval != 0) {
+		pr_err("%s: gsw PortLinkCfgGet failed\n", __func__);
+		return retval;
+	}
+
+	if (port_link_cfg.bLPI) {
+		phy_ethtool_get_eee(dev->phydev, eee_data);
+		eee_data->eee_active = port_link_cfg.bLPI;
+		eee_data->eee_enabled = port_link_cfg.bLPI;
+		eee_data->tx_lpi_enabled = port_link_cfg.bLPI;
+	}
+
+	return retval;
+}
+
+static int  ethtool_eee_set(struct net_device *dev,
+			    struct ethtool_eee *eee_data)
+{
+	struct core_ops *ops = gsw_get_swcore_ops(0);
+	GSW_portLinkCfg_t	port_link_cfg = {0};
+	int retval = EOPNOTSUPP;
+
+	port_link_cfg.nPortId = dev->dev_id;
+	retval = ops->gsw_common_ops.PortLinkCfgGet(ops, &port_link_cfg);
+
+	if (retval != 0) {
+		pr_err("%s: gsw PortLinkCfgGet failed\n", __func__);
+		return retval;
+	}
+
+	/* xmac */
+	port_link_cfg.bLPI ^= 1;
+	retval =  ops->gsw_common_ops.PortLinkCfgSet(ops, &port_link_cfg);
+
+	if (retval != 0) {
+		pr_err("%s: gsw PortLinkCfgset failed\n", __func__);
+		return retval;
+	}
+
+	/* phy */
+	if (!eee_data->eee_active) {
+		if (phy_init_eee(dev->phydev, 0)) {
+			pr_err("%s: phy_init_eee failed\n", __func__);
+			return retval;
+		}
+	}
+
+	return retval;
+}
+
 /* Structure of the ether tool operation  */
 static const struct ethtool_ops ethtool_ops = {
 	.get_drvinfo		= get_drvinfo,
@@ -200,6 +260,8 @@ static const struct ethtool_ops ethtool_ops = {
 	.get_link		= ethtool_op_get_link,
 	.get_link_ksettings	= phy_ethtool_get_link_ksettings,
 	.set_link_ksettings	= phy_ethtool_set_link_ksettings,
+	.get_eee		= ethtool_eee_get,
+	.set_eee		= ethtool_eee_set,
 };
 
 /* open the network device interface*/
@@ -1251,6 +1313,7 @@ static int xrx500_of_iface(struct xrx500_hw *hw, struct device_node *iface,
 	hw->devs[hw->num_devs]->netdev_ops = &ltq_eth_drv_ops;
 	hw->devs[hw->num_devs]->watchdog_timeo = LTQ_TX_TIMEOUT;
 	hw->devs[hw->num_devs]->needed_headroom = sizeof(ltq_pmac_header_t);
+	hw->devs[hw->num_devs]->dev_id = dp_port_id_param;
 	SET_NETDEV_DEV(hw->devs[hw->num_devs], &pdev->dev);
 
 	/* setup our private data */
