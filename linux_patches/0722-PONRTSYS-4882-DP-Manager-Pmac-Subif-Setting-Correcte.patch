From 5a53d15ea4e3e118ac283ed4e4afc6c7687b24c2 Mon Sep 17 00:00:00 2001
From: thampan <joby.thampan@intel.com>
Date: Thu, 1 Aug 2019 11:33:32 +0800
Subject: [PATCH] PONRTSYS-4882: DP Manager Pmac Subif Setting Corrected

  - Datapath Library Pmac subif setting is done in all cases where Pmac Header is sent out
  - Egress traffic to P2, P3 and P4 GSWIP looks for Subif inside Pmac Header
  - ACA Checksum work around is removed for DSL and WiFi in DP HAL layer for GSWIP 3.1
  - DirectLink related code is removed for DP HAL layer of GSWIP 3.1
---
 drivers/net/datapath/dpm/gswip31/datapath_misc.c | 55 ------------------------
 drivers/net/datapath/dpm/gswip31/datapath_tx.c   | 53 +++++------------------
 2 files changed, 10 insertions(+), 98 deletions(-)

diff --git a/drivers/net/datapath/dpm/gswip31/datapath_misc.c b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
index 926f9bacf6d7..5b5be341f47b 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
@@ -104,61 +104,6 @@ static void init_dma_pmac_template(int portid, u32 flags)
 		dp_info->dma0_template[TEMPL_INSERT].field.redir = 0;
 		dp_info->dma0_mask_template[TEMPL_INSERT].field.redir = 0;
 
-	} else if (flags & DP_F_DIRECTLINK) { /*always with pmac*/
-		/*normal dirctpath without checksum support
-		 *but with pmac to Switch for accelerate
-		 */
-		dp_info->pmac_template[TEMPL_NORMAL].igp_msb = portid;
-		dp_info->pmac_template[TEMPL_NORMAL].class_en = 1;
-		SET_PMAC_IGP_EGP(&dp_info->pmac_template[TEMPL_NORMAL], portid);
-
-		dp_info->dma1_template[TEMPL_CHECKSUM].field.enc = 1;
-		dp_info->dma1_template[TEMPL_CHECKSUM].field.dec = 1;
-		dp_info->dma1_template[TEMPL_CHECKSUM].field.mpe2 = 0;
-		dp_info->dma1_mask_template[TEMPL_CHECKSUM].field.enc = 0;
-		dp_info->dma1_mask_template[TEMPL_CHECKSUM].field.dec = 0;
-		dp_info->dma1_mask_template[TEMPL_CHECKSUM].field.mpe2 = 0;
-		/*dirctpath with checksum support */
-		dp_info->pmac_template[TEMPL_CHECKSUM].igp_msb = portid;
-		dp_info->dma0_template[TEMPL_CHECKSUM].field.redir = 1;
-		dp_info->dma0_mask_template[TEMPL_CHECKSUM].field.redir = 0;
-		dp_info->pmac_template[TEMPL_CHECKSUM].tcp_chksum = 1;
-		dp_info->pmac_template[TEMPL_CHECKSUM].class_en = 1;
-		SET_PMAC_IGP_EGP(&dp_info->pmac_template[TEMPL_CHECKSUM],
-				 portid);
-		dp_info->dma1_template[TEMPL_CHECKSUM].field.enc = 1;
-		dp_info->dma1_template[TEMPL_CHECKSUM].field.dec = 1;
-		dp_info->dma1_template[TEMPL_CHECKSUM].field.mpe2 = 1;
-		dp_info->dma1_mask_template[TEMPL_CHECKSUM].field.enc = 0;
-		dp_info->dma1_mask_template[TEMPL_CHECKSUM].field.dec = 0;
-		dp_info->dma1_mask_template[TEMPL_CHECKSUM].field.mpe2 = 0;
-
-		/*dirctpath without checksum support but send packet to MPE
-		 * DL FW
-		 */
-		dp_info->pmac_template[TEMPL_OTHERS].igp_msb = portid;
-		dp_info->dma0_template[TEMPL_OTHERS].field.redir = 1;
-		dp_info->dma0_mask_template[TEMPL_OTHERS].field.redir = 0;
-		dp_info->pmac_template[TEMPL_OTHERS].class_en = 1;
-		SET_PMAC_IGP_EGP(&dp_info->pmac_template[TEMPL_OTHERS], portid);
-#if defined(CONFIG_ACCL_11AC_CS2) || defined(CONFIG_ACCL_11AC_CS2_MODULE)
-			/* CPU traffic to PAE via cbm to apply PCE rule */
-		dp_info->dma1_template[TEMPL_OTHERS].field.enc = 1;
-		dp_info->dma1_template[TEMPL_OTHERS].field.dec = 1;
-		dp_info->dma1_template[TEMPL_OTHERS].field.mpe2 = 0;
-		dp_info->dma1_mask_template[TEMPL_OTHERS].field.enc = 0;
-		dp_info->dma1_mask_template[TEMPL_OTHERS].field.dec = 0;
-		dp_info->dma1_mask_template[TEMPL_OTHERS].field.mpe2 = 0;
-#else
-		/* No need since already set to zero by default
-		 *dp_info->dma1_template[TEMPL_OTHERS].field.enc = 0;
-		 *dp_info->dma1_template[TEMPL_OTHERS].field.dec = 0;
-		 *dp_info->dma1_template[TEMPL_OTHERS].field.mpe2 = 0;
-		 *dp_info->dma1_mask_template[TEMPL_OTHERS].field.enc = 0;
-		 *dp_info->dma1_mask_template[TEMPL_OTHERS].field.dec = 0;
-		 *dp_info->dma1_mask_template[TEMPL_OTHERS].field.mpe2 = 0;
-		 */
-#endif
 	} else if (flags & DP_F_FAST_DSL) { /*sometimes with pmac*/
 		/* For normal single DSL upstream, there is no pmac at all*/
 		dp_info->dma1_template[TEMPL_NORMAL].field.dec = 1;
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_tx.c b/drivers/net/datapath/dpm/gswip31/datapath_tx.c
index fcd0dab02c5a..33d6a3708507 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_tx.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_tx.c
@@ -206,7 +206,7 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 	/*As new SWAS 3.7 required, MPE1/Color/FlowID is set by applications */
 	desc_0->all &= dma_tx_desc_mask0.all;
 	desc_1->all &= dma_tx_desc_mask1.all;
-	/*desc_2->all = 0;*/ /*remove since later it will be set properly */
+
 	if (desc_3->field.dic) {
 		desc_3->all = 0; /*keep DIC bit to support test tool*/
 		desc_3->field.dic = 1;
@@ -229,11 +229,12 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 							dp_info);
 			set_chksum(&pmac, tcp_type, ip_offset,
 				   ip_offset_hw_adjust, tcp_h_offset);
-			DP_CB(inst, set_pmac_subif)(&pmac, rx_subif->subif);
 		} else if (flags & DP_TX_INSERT) {
 			DP_CB(inst, get_dma_pmac_templ)(TEMPL_INSERT, &pmac,
 							desc_0, desc_1,
 							dp_info);
+
+			/* Set the GSWIP Logical Port ID to insert */
 			SET_PMAC_IGP_EGP(&pmac, ep);
 
 			/* if DP_TX_INSERT_POINT Ins Point 1, else Ins Point 0
@@ -248,7 +249,6 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 			DP_CB(inst, get_dma_pmac_templ)(TEMPL_NORMAL, &pmac,
 							desc_0, desc_1,
 							dp_info);
-			DP_CB(inst, set_pmac_subif)(&pmac, rx_subif->subif);
 		}
 
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_PTP1588)
@@ -275,6 +275,7 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 			pmac.record_id_msb = rec_id;
 		}
 #endif
+
 	} else if (dp_info->alloc_flags & DP_F_FAST_DSL) { /*some with pmac*/
 		if (unlikely(flags & DP_TX_CAL_CHKSUM)) { /* w/ pmac*/
 			DP_CB(inst, get_dma_pmac_templ)(TEMPL_CHECKSUM, &pmac,
@@ -282,22 +283,12 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 							dp_info);
 			set_chksum(&pmac, tcp_type, ip_offset,
 				   ip_offset_hw_adjust, tcp_h_offset);
-			DP_CB(inst, set_pmac_subif)(&pmac, rx_subif->subif);
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_ACA_CSUM_WORKAROUND)
-			if (aca_portid > 0)
-				desc_1->field.ep = aca_portid;
-#endif
 		} else if (flags & DP_TX_DSL_FCS) {/* after checksum check */
 			/* w/ pmac for FCS purpose*/
 			DP_CB(inst, get_dma_pmac_templ)(TEMPL_OTHERS, &pmac,
 							desc_0, desc_1,
 							dp_info);
-			DP_CB(inst, set_pmac_subif)(&pmac, rx_subif->subif);
 			insert_pmac_f = 1;
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_ACA_CSUM_WORKAROUND)
-			if (aca_portid > 0)
-				desc_1->field.ep = aca_portid;
-#endif
 		} else { /*no pmac */
 			DP_CB(inst, get_dma_pmac_templ)(TEMPL_NORMAL, NULL,
 							desc_0, desc_1,
@@ -311,43 +302,15 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 							dp_info);
 			set_chksum(&pmac, tcp_type, ip_offset,
 				   ip_offset_hw_adjust, tcp_h_offset);
-			DP_CB(inst, set_pmac_subif)(&pmac, rx_subif->subif);
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_ACA_CSUM_WORKAROUND)
-			if (aca_portid > 0)
-				desc_1->field.ep = aca_portid;
-#endif
 		} else { /*no pmac*/
 			DP_CB(inst, get_dma_pmac_templ)(TEMPL_NORMAL, NULL,
 							desc_0, desc_1,
 							dp_info);
 		}
-	} else if (dp_info->alloc_flags & DP_F_DIRECTLINK) { /*always w/ pmac*/
-		if (unlikely(flags & DP_TX_CAL_CHKSUM)) { /* w/ pmac*/
-			DP_CB(inst, get_dma_pmac_templ)(TEMPL_CHECKSUM, &pmac,
-							desc_0, desc_1,
-							dp_info);
-			set_chksum(&pmac, tcp_type, ip_offset,
-				   ip_offset_hw_adjust, tcp_h_offset);
-			DP_CB(inst, set_pmac_subif)(&pmac, rx_subif->subif);
-		} else if (flags & DP_TX_TO_DL_MPEFW) { /*w/ pmac*/
-			/*copy from checksum's pmac template setting,
-			 *but need to reset tcp_chksum in TCP header
-			 */
-			DP_CB(inst, get_dma_pmac_templ)(TEMPL_OTHERS, &pmac,
-							desc_0, desc_1,
-							dp_info);
-			DP_CB(inst, set_pmac_subif)(&pmac, rx_subif->subif);
-		} else { /*do like normal directpath with pmac */
-			DP_CB(inst, get_dma_pmac_templ)(TEMPL_NORMAL, &pmac,
-							desc_0, desc_1,
-							dp_info);
-			DP_CB(inst, set_pmac_subif)(&pmac, rx_subif->subif);
-		}
 	}  else if (dp_info->alloc_flags & DP_F_VUNI) {
 		DP_CB(inst, get_dma_pmac_templ)(TEMPL_NORMAL, &pmac,
 						desc_0, desc_1,
 						dp_info);
-		DP_CB(inst, set_pmac_subif)(&pmac, rx_subif->subif);
 	} else { /*normal directpath: always w/ pmac */
 		if (unlikely(tx_chksum_flag)) {
 			DP_CB(inst, get_dma_pmac_templ)(TEMPL_CHECKSUM,
@@ -357,16 +320,20 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 							dp_info);
 			set_chksum(&pmac, tcp_type, ip_offset,
 				   ip_offset_hw_adjust, tcp_h_offset);
-			DP_CB(inst, set_pmac_subif)(&pmac, rx_subif->subif);
 		} else { /*w/ pmac */
 			DP_CB(inst, get_dma_pmac_templ)(TEMPL_NORMAL, &pmac,
 							desc_0, desc_1,
 							dp_info);
-			DP_CB(inst, set_pmac_subif)(&pmac, rx_subif->subif);
 		}
 	}
 	desc_3->field.data_len = skb->len;
 
+	/* Subifid is taken from PMAC header for
+	 * Egress Port 2/3/4
+	 */
+	if (insert_pmac_f)
+		DP_CB(inst, set_pmac_subif)(&pmac, rx_subif->subif);
+
 	if (unlikely(dp_dbg_flag)) {
 		if (insert_pmac_f)
 			dp_xmit_dbg("After", skb, ep, len, flags, &pmac,
