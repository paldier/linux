From 340d5f31b5d29f160c3830fc61fa65af4940ca10 Mon Sep 17 00:00:00 2001
From: Hua Ma <hua.ma@linux.intel.com>
Date: Thu, 21 Jun 2018 17:37:52 +0800
Subject: [PATCH] Add support for lantiq ppa layer

---
 drivers/net/ethernet/lantiq/ppa/Kconfig           |   70 +
 drivers/net/ethernet/lantiq/ppa/Makefile          |    3 +
 drivers/net/ethernet/lantiq/ppa/ppa_drv_wrapper.c | 1285 ++++++++++++
 drivers/net/ethernet/lantiq/ppa/ppa_hal_wrapper.c | 2174 ++++++++++++++++++++
 drivers/net/ethernet/lantiq/ppa/ppa_hook.c        | 1135 ++++++++++
 include/net/ppa/ltq_mpe_hal.h                     |   65 +
 include/net/ppa/ltq_tmu_hal_api.h                 |   70 +
 include/net/ppa/ppa_api.h                         | 1127 ++++++++++
 include/net/ppa/ppa_api_common.h                  |   68 +
 include/net/ppa/ppa_api_directpath.h              |  438 ++++
 include/net/ppa/ppa_api_netif.h                   |  242 +++
 include/net/ppa/ppa_datapath.h                    |  295 +++
 include/net/ppa/ppa_drv_wrapper.h                 |  151 ++
 include/net/ppa/ppa_hal_wrapper.h                 |   97 +
 include/net/ppa/ppa_hook.h                        |  750 +++++++
 include/net/ppa/ppa_ppe_hal.h                     |  367 ++++
 include/net/ppa/ppa_stack_al.h                    | 2281 +++++++++++++++++++++
 include/net/ppa/qos_hal_api.h                     |   59 +
 include/net/ppa/qos_mgr_tc_hook.h                 |   30 +
 19 files changed, 10707 insertions(+)

diff --git a/drivers/net/ethernet/lantiq/ppa/Kconfig b/drivers/net/ethernet/lantiq/ppa/Kconfig
new file mode 100644
index 000000000000..336592ec2ee5
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/ppa/Kconfig
@@ -0,0 +1,70 @@
+
+menu "PPA"
+
+config PPA
+        bool "Protocol Processing Accelerator"
+        depends on LANTIQ
+        default n
+        ---help---
+        Protocol Acceleration Engine
+
+if PPA 
+
+config PPA_HAL_SELECTOR
+       bool "PPA HAL selector"
+       depends on PPA && SOC_GRX500 
+       default n
+       ---help---	
+       PPA hal selection logic enable
+
+config PPA_QOS
+       bool "PPA Quality of Service"
+       depends on PPA 
+       default y
+       ---help---	
+       PPA QoS enable
+
+config PPA_API_DIRECTPATH
+        bool "Direct Path Support for PPA API"
+        depends on PPA
+        default y
+        ---help---
+        Direct Path Support (e.g. WLAN) for PPA API
+
+config PPA_API_DIRECTCONNECT
+        bool "Direct connect Support for SOC"
+        depends on PPA && SOC_GRX500
+        default n
+        ---help---
+        Direct connect Support (e.g. WLAN) for PPA
+
+config PPA_API_SW_FASTPATH
+       bool "PPA software acceleration"
+       depends on PPA
+       default y
+       ---help---       
+       PPA software acceleration enable
+
+config PPA_TCP_LITEPATH
+       bool "TCP litepath"
+       depends on PPA_API_SW_FASTPATH
+       default y
+       ---help---       
+       PPA local TCP session Acceleration
+
+config PPA_TMU_MIB_SUPPORT
+        tristate "PPA TMU HAL - kernel APIs"
+        depends on PPA && SOC_GRX500
+        default y
+        help
+            TMU HAL MIB APIs support
+
+config PPA_BR_SESS_LEARNING
+        bool "Bridge session learning"
+        depends on PPA
+        default n
+        help
+            Bridge session learning support for PPA
+
+endif # PPA
+endmenu
diff --git a/drivers/net/ethernet/lantiq/ppa/Makefile b/drivers/net/ethernet/lantiq/ppa/Makefile
new file mode 100644
index 000000000000..dd3bd7c84324
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/ppa/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_PPA) += ppa_hook.o 
+obj-$(CONFIG_PPA) += ppa_drv_wrapper.o 
+obj-$(CONFIG_PPA_HAL_SELECTOR) += ppa_hal_wrapper.o
diff --git a/drivers/net/ethernet/lantiq/ppa/ppa_drv_wrapper.c b/drivers/net/ethernet/lantiq/ppa/ppa_drv_wrapper.c
new file mode 100644
index 000000000000..eb31a5cdb863
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/ppa/ppa_drv_wrapper.c
@@ -0,0 +1,1285 @@
+/******************************************************************************
+ **
+ ** FILE NAME    : ppe_drv_wrapper.c
+ ** PROJECT      : PPA
+ ** MODULES      : PPA Wrapper for PPE Driver API
+ **
+ ** DATE         : 14 Mar 2011
+ ** AUTHOR       : Shao Guohua
+ ** DESCRIPTION  : PPA Wrapper for PPE Driver API
+ ** COPYRIGHT    : Copyright (c) 2017 Intel Corporation
+ ** Copyright (c) 2011 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+ ** HISTORY
+ ** $Date        $Author                $Comment
+ ** 14 MAR 2011  Shao Guohua            Initiate Version
+ ** 10 DEC 2012  Manamohan Shetty       Added the support for RTP,MIB mode and CAPWAP
+ **                                     Features
+ ** 05 JUL 2017  Kamal Eradath          Merged ppe_drv_wrapper.c and ppa_datapath_wrapper.c
+ *******************************************************************************/
+
+/*
+ * ####################################
+ *              Head File
+ * ####################################
+ */
+
+/*
+ *  Common Head File
+ */
+/*#include <linux/autoconf.h>*/
+#include <linux/version.h>
+#include <generated/autoconf.h>
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/netdevice.h>
+#include <linux/atmdev.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+
+/*
+ *  Chip Specific Head File
+ */
+#include <net/ppa/ppa_api.h>
+#include <net/ppa/ppa_ppe_hal.h>
+#include <net/ppa/ppa_datapath.h>
+#include <net/ppa/ppa_drv_wrapper.h>
+
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+#include <net/datapath_api.h>
+#include <net/ppa/ltq_mpe_hal.h>
+#endif
+
+int g_ppa_proc_dir_flag = 0;
+struct proc_dir_entry *g_ppa_proc_dir = NULL;
+
+/*Hook API for PPE Driver's Datapath layer: these hook will be set in PPE datapath driver*/
+
+int32_t (*ppa_sw_add_session_hook)(PPA_BUF *skb, void *pitem) = NULL;
+EXPORT_SYMBOL(ppa_sw_add_session_hook);
+
+int32_t (*ppa_sw_update_session_hook)(PPA_BUF *skb, void *pitem, void *txifinfo) = NULL;
+EXPORT_SYMBOL(ppa_sw_update_session_hook);
+
+void (*ppa_sw_del_session_hook)(void *pitem) = NULL;
+EXPORT_SYMBOL(ppa_sw_del_session_hook);
+
+int32_t (*ppa_sw_fastpath_enable_hook)(uint32_t f_enable, uint32_t flags) = NULL;
+EXPORT_SYMBOL(ppa_sw_fastpath_enable_hook);
+
+int32_t (*ppa_get_sw_fastpath_status_hook)(uint32_t *f_enable, uint32_t flags) = NULL;
+EXPORT_SYMBOL(ppa_get_sw_fastpath_status_hook);
+
+int32_t (*ppa_sw_session_enable_hook)(void *pitem, uint32_t f_enable, uint32_t flags) = NULL;
+EXPORT_SYMBOL(ppa_sw_session_enable_hook);
+
+int32_t (*ppa_get_sw_session_status_hook)(void *pitem, uint32_t *f_enable, uint32_t flags) = NULL;
+EXPORT_SYMBOL(ppa_get_sw_session_status_hook);
+
+int32_t (*ppa_sw_fastpath_send_hook)(PPA_SKBUF *skb) = NULL;
+EXPORT_SYMBOL(ppa_sw_fastpath_send_hook);
+
+#if defined(CONFIG_PPA_TCP_LITEPATH) && CONFIG_PPA_TCP_LITEPATH
+int32_t (*ppa_sw_litepath_tcp_send_hook)(PPA_SKBUF *skb) = NULL;
+EXPORT_SYMBOL(ppa_sw_litepath_tcp_send_hook);
+
+int32_t (*ppa_tcp_litepath_enable_hook)(uint32_t f_enable, uint32_t flags) = NULL;
+EXPORT_SYMBOL(ppa_tcp_litepath_enable_hook);
+
+int32_t (*ppa_get_tcp_litepath_status_hook)(uint32_t *f_enable, uint32_t flags) = NULL;
+EXPORT_SYMBOL(ppa_get_tcp_litepath_status_hook);
+#endif
+
+/*Hook API for PPE Driver's HAL layer: these hook will be set in PPE HAL driver */
+int32_t (*ppa_drv_hal_generic_hook)(PPA_GENERIC_HOOK_CMD cmd, void *buffer, uint32_t flag) = NULL;
+EXPORT_SYMBOL(ppa_drv_hal_generic_hook);
+
+/*Hook API for PPE Driver's Datapath layer: these hook will be set in PPE datapath driver*/
+/* First part is for direct path */
+struct ppe_directpath_data *ppa_drv_g_ppe_directpath_data = NULL;
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+int32_t (*ppa_drv_directpath_send_hook)(PPA_SUBIF *, PPA_SKBUF *, int32_t, uint32_t) = NULL;
+#else
+int32_t (*ppa_drv_directpath_send_hook)(uint32_t, PPA_SKBUF *, int32_t, uint32_t) = NULL;
+#endif
+int32_t (*ppa_drv_directpath_rx_stop_hook)(uint32_t, uint32_t) = NULL;
+int32_t (*ppa_drv_directpath_rx_start_hook)(uint32_t, uint32_t) = NULL;
+
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+int32_t (*ppa_drv_directpath_register_hook)(PPA_SUBIF *, PPA_NETIF *, PPA_DIRECTPATH_CB*, int32_t*, uint32_t) = NULL;
+
+int32_t (*mpe_hal_feature_start_fn)(
+		enum MPE_Feature_Type mpeFeature,
+		uint32_t port_id,
+		uint32_t * featureCfgBase,
+		uint32_t flags) = NULL;
+EXPORT_SYMBOL(mpe_hal_feature_start_fn);
+
+#ifdef CONFIG_LTQ_DATAPATH_DUMMY_MPE_MIB
+int32_t (*mpe_hal_get_netif_mib_hook_fn) (struct net_device *dev,
+		dp_subif_t *subif_id, struct mpe_hal_if_stats *mpe_mib,
+		uint32_t flag) = NULL;
+EXPORT_SYMBOL(mpe_hal_get_netif_mib_hook_fn);
+
+int32_t (*mpe_hal_clear_if_mib_hook_fn) (struct net_device *dev,
+		dp_subif_t *subif_id, uint32_t flag) = NULL;
+EXPORT_SYMBOL(mpe_hal_clear_if_mib_hook_fn);
+#endif
+
+#if defined(CONFIG_PPA_TMU_MIB_SUPPORT)
+int32_t (*tmu_hal_get_csum_ol_mib_hook_fn)(
+		struct tmu_hal_qos_stats *csum_mib,
+		uint32_t flag) = NULL;
+EXPORT_SYMBOL(tmu_hal_get_csum_ol_mib_hook_fn);
+int32_t (*tmu_hal_clear_csum_ol_mib_hook_fn)(
+		uint32_t flag) = NULL;
+EXPORT_SYMBOL(tmu_hal_clear_csum_ol_mib_hook_fn);
+int32_t(*tmu_hal_get_qos_mib_hook_fn)(
+		struct net_device *netdev,
+		dp_subif_t *subif_id,
+		int32_t queueid,
+		struct tmu_hal_qos_stats *qos_mib,
+		uint32_t flag) = NULL;
+EXPORT_SYMBOL(tmu_hal_get_qos_mib_hook_fn);
+int32_t (*tmu_hal_clear_qos_mib_hook_fn)(
+		struct net_device *netdev,
+		dp_subif_t *subif_id,
+		int32_t queueid,
+		uint32_t flag) = NULL;
+EXPORT_SYMBOL(tmu_hal_clear_qos_mib_hook_fn);
+#endif
+int32_t (*tmu_hal_set_checksum_queue_map_hook_fn)(
+			uint32_t pmac_port) = NULL;
+EXPORT_SYMBOL(tmu_hal_set_checksum_queue_map_hook_fn);
+#endif
+int32_t (*qos_hal_get_csum_ol_mib_hook_fn)(
+		struct qos_hal_qos_stats *csum_mib,
+		uint32_t flag) = NULL;
+EXPORT_SYMBOL(qos_hal_get_csum_ol_mib_hook_fn);
+
+int32_t (*qos_hal_clear_csum_ol_mib_hook_fn)(
+		uint32_t flag) = NULL;
+EXPORT_SYMBOL(qos_hal_clear_csum_ol_mib_hook_fn);
+
+int32_t(*qos_hal_get_qos_mib_hook_fn)(
+		struct net_device *netdev,
+		dp_subif_t *subif_id,
+		int32_t queueid,
+		struct qos_hal_qos_stats *qos_mib,
+		uint32_t flag) = NULL;
+EXPORT_SYMBOL(qos_hal_get_qos_mib_hook_fn);
+
+int32_t (*qos_hal_clear_qos_mib_hook_fn)(
+		struct net_device *netdev,
+		dp_subif_t *subif_id,
+		int32_t queueid,
+		uint32_t flag) = NULL;
+EXPORT_SYMBOL(qos_hal_clear_qos_mib_hook_fn);
+
+/*    others:: these hook will be set in PPE datapath driver  */
+int (*ppa_drv_get_dslwan_qid_with_vcc_hook)(struct atm_vcc *vcc) = NULL;
+int (*ppa_drv_get_netif_qid_with_pkt_hook)(PPA_SKBUF *skb, void *arg, int is_atm_vcc) = NULL;
+int (*ppa_drv_get_atm_qid_with_pkt_hook)(PPA_SKBUF *skb, void *arg, int is_atm_vcc) = NULL;
+int (*ppa_drv_ppe_clk_change_hook)(unsigned int arg, unsigned int flags) = NULL;
+int (*ppa_drv_ppe_pwm_change_hook)(unsigned int arg, unsigned int flags) = NULL;
+int32_t (*ppa_drv_datapath_generic_hook)(PPA_GENERIC_HOOK_CMD cmd, void *buffer, uint32_t flag) = NULL;
+/*below hook will be exposed from datapath driver and called by its hal driver.*/
+int32_t (*ppa_drv_datapath_mac_entry_setting)(uint8_t  *mac, uint32_t fid, uint32_t portid, uint32_t agetime, uint32_t st_entry , uint32_t action) = NULL;
+
+/* Hook API for datapath A1 to get MPoA type */
+int32_t (*ppa_drv_hal_get_mpoa_type_hook)(uint32_t dslwan_qid, uint32_t *mpoa_type) = NULL;
+
+
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+int ppa_drv_directpath_send(PPA_SUBIF *subif, PPA_SKBUF *skb, int32_t len, uint32_t flags)
+{
+	if (!ppa_drv_directpath_send_hook)
+		return PPA_EINVAL;
+	return ppa_drv_directpath_send_hook(subif, skb, len, flags);
+}
+#else
+int ppa_drv_directpath_send(uint32_t if_id, PPA_SKBUF *skb, int32_t len, uint32_t flags)
+{
+	if (!ppa_drv_directpath_send_hook)
+		return PPA_EINVAL;
+	return ppa_drv_directpath_send_hook(if_id, skb, len, flags);
+}
+#endif
+
+int ppa_drv_directpath_rx_stop(uint32_t if_id, uint32_t flags)
+{
+	if (!ppa_drv_directpath_rx_stop_hook)
+		return PPA_EINVAL;
+	return ppa_drv_directpath_rx_stop_hook(if_id, flags);
+}
+
+int ppa_drv_directpath_rx_start(uint32_t if_id, uint32_t flags)
+{
+	if (!ppa_drv_directpath_rx_start_hook)
+		return PPA_EINVAL;
+	return ppa_drv_directpath_rx_start_hook(if_id, flags);
+}
+
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+int ppa_drv_directpath_register(PPA_SUBIF *subif, PPA_NETIF *netif, PPA_DIRECTPATH_CB *pDirectpathCb, int32_t *index, uint32_t flags)
+{
+	if (!ppa_drv_directpath_register_hook)
+		return PPA_EINVAL;
+	return ppa_drv_directpath_register_hook(subif, netif, pDirectpathCb, index, flags);
+}
+
+#if defined(CONFIG_PPA_TMU_MIB_SUPPORT)
+int32_t ppa_drv_get_csum_ol_mib(
+		struct tmu_hal_qos_stats *csum_mib,
+		uint32_t flag)
+{
+	if (!tmu_hal_get_csum_ol_mib_hook_fn)
+		return PPA_EINVAL;
+	return tmu_hal_get_csum_ol_mib_hook_fn (csum_mib, flag);
+
+}
+EXPORT_SYMBOL(ppa_drv_get_csum_ol_mib);
+
+int32_t ppa_drv_clear_csum_ol_mib(
+		uint32_t flag)
+{
+	if (!tmu_hal_clear_csum_ol_mib_hook_fn)
+		return PPA_EINVAL;
+	return tmu_hal_clear_csum_ol_mib_hook_fn (flag);
+
+}
+EXPORT_SYMBOL(ppa_drv_clear_csum_ol_mib);
+
+int32_t ppa_drv_get_tmu_qos_mib (
+		struct net_device *netdev,
+		dp_subif_t *subif_id,
+		int32_t queueid,
+		struct tmu_hal_qos_stats *qos_mib,
+		uint32_t flag)
+{
+	if (!tmu_hal_get_qos_mib_hook_fn)
+		return PPA_EINVAL;
+	return tmu_hal_get_qos_mib_hook_fn (netdev, subif_id, queueid, qos_mib, flag);
+
+}
+EXPORT_SYMBOL(ppa_drv_get_tmu_qos_mib);
+int32_t ppa_drv_reset_tmu_qos_mib (
+		struct net_device *netdev,
+		dp_subif_t *subif_id,
+		int32_t queueid,
+		uint32_t flag)
+{
+	if (!tmu_hal_clear_qos_mib_hook_fn)
+		return PPA_EINVAL;
+	return tmu_hal_clear_qos_mib_hook_fn (netdev, subif_id, queueid, flag);
+}
+EXPORT_SYMBOL(ppa_drv_reset_tmu_qos_mib);
+#endif
+#endif
+
+int ppa_drv_get_dslwan_qid_with_vcc(struct atm_vcc *vcc)
+{
+	if (!ppa_drv_get_dslwan_qid_with_vcc_hook) return 0;
+	else return ppa_drv_get_dslwan_qid_with_vcc_hook(vcc);
+}
+
+int ppa_drv_get_netif_qid_with_pkt(PPA_SKBUF *skb, void *arg, int is_atm_vcc)
+{
+	if (!ppa_drv_get_netif_qid_with_pkt_hook) return 0;
+	else return ppa_drv_get_netif_qid_with_pkt_hook(skb, arg, is_atm_vcc);
+
+}
+
+int ppa_drv_ppe_clk_change(unsigned int arg, unsigned int flags)
+{
+	if (!ppa_drv_ppe_clk_change_hook)
+		return PPA_FAILURE;
+	else return ppa_drv_ppe_clk_change_hook(arg, flags);
+}
+
+int ppa_drv_ppe_pwm_change(unsigned int arg, unsigned int flags)
+{
+	if (!ppa_drv_ppe_pwm_change_hook)
+		return PPA_FAILURE;
+	else return ppa_drv_ppe_pwm_change_hook(arg, flags);
+}
+
+uint32_t ppa_drv_dp_sb_addr_to_fpi_addr_convert(PPA_FPI_ADDR*a, uint32_t flag)
+{
+	if (!ppa_drv_datapath_generic_hook)
+		return PPA_FAILURE;
+	return ppa_drv_datapath_generic_hook(PPA_GENERIC_DATAPATH_ADDR_TO_FPI_ADDR, (void *)a, flag);
+
+}
+
+int32_t ppa_hook_set_lan_seperate_flag(uint32_t flag)
+{
+	if (!ppa_drv_datapath_generic_hook)
+		return PPA_FAILURE;
+	return ppa_drv_datapath_generic_hook(PPA_GENERIC_DATAPATH_SET_LAN_SEPARATE_FLAG, NULL, flag);
+}
+int32_t ppa_hook_get_lan_seperate_flag(uint32_t flag)
+{
+	if (!ppa_drv_datapath_generic_hook)
+		return PPA_FAILURE;
+	return ppa_drv_datapath_generic_hook(PPA_GENERIC_DATAPATH_GET_LAN_SEPARATE_FLAG, NULL, flag);
+}
+uint32_t ppa_hook_set_wan_seperate_flag(uint32_t flag)
+{
+	if (!ppa_drv_datapath_generic_hook)
+		return PPA_FAILURE;
+	return ppa_drv_datapath_generic_hook(PPA_GENERIC_DATAPATH_SET_WAN_SEPARATE_FLAG, NULL, flag);
+}
+uint32_t ppa_hook_get_wan_seperate_flag(uint32_t flag)
+{
+	if (!ppa_drv_datapath_generic_hook)
+		return PPA_FAILURE;
+	return ppa_drv_datapath_generic_hook(PPA_GENERIC_DATAPATH_GET_WAN_SEPARATE_FLAG, NULL, flag);
+}
+
+/*for PPE driver's datapath APIs*/
+EXPORT_SYMBOL(ppa_drv_g_ppe_directpath_data);
+EXPORT_SYMBOL(ppa_drv_directpath_send_hook);
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+EXPORT_SYMBOL(ppa_drv_directpath_register);
+EXPORT_SYMBOL(ppa_drv_directpath_register_hook);
+#endif
+EXPORT_SYMBOL(ppa_drv_directpath_rx_stop_hook);
+EXPORT_SYMBOL(ppa_drv_directpath_rx_start_hook);
+EXPORT_SYMBOL(ppa_drv_directpath_send);
+EXPORT_SYMBOL(ppa_drv_directpath_rx_stop);
+EXPORT_SYMBOL(ppa_drv_directpath_rx_start);
+
+EXPORT_SYMBOL(ppa_drv_get_dslwan_qid_with_vcc_hook);
+EXPORT_SYMBOL(ppa_drv_get_netif_qid_with_pkt_hook);
+EXPORT_SYMBOL(ppa_drv_get_atm_qid_with_pkt_hook);
+EXPORT_SYMBOL(ppa_drv_hal_get_mpoa_type_hook);
+EXPORT_SYMBOL(ppa_drv_ppe_clk_change_hook);
+EXPORT_SYMBOL(ppa_drv_ppe_pwm_change_hook);
+EXPORT_SYMBOL(ppa_drv_get_dslwan_qid_with_vcc);
+EXPORT_SYMBOL(ppa_drv_get_netif_qid_with_pkt);
+EXPORT_SYMBOL(ppa_drv_ppe_clk_change);
+EXPORT_SYMBOL(ppa_drv_ppe_pwm_change);
+EXPORT_SYMBOL(ppa_drv_datapath_generic_hook);
+EXPORT_SYMBOL(ppa_drv_datapath_mac_entry_setting);
+EXPORT_SYMBOL(ppa_drv_dp_sb_addr_to_fpi_addr_convert);
+EXPORT_SYMBOL(ppa_hook_get_lan_seperate_flag);
+EXPORT_SYMBOL(ppa_hook_set_lan_seperate_flag);
+EXPORT_SYMBOL(ppa_hook_get_wan_seperate_flag);
+EXPORT_SYMBOL(ppa_hook_set_wan_seperate_flag);
+
+
+/*Below wrapper is for PPE driver datapath..---- Not sure whether need to add synchronization or not ---end*/
+
+EXPORT_SYMBOL(g_ppa_proc_dir_flag);
+EXPORT_SYMBOL(g_ppa_proc_dir);
+
+
+
+#ifndef CONFIG_PPA_HAL_SELECTOR
+/*all below wrapper is for PPE driver's hal API */
+
+uint32_t ppa_drv_hal_init(uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_INIT, (void *)NULL, flag);
+}
+
+uint32_t ppa_drv_hal_exit(uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_EXIT, (void *)NULL, flag);
+}
+
+uint32_t ppa_drv_get_ppe_hal_id(PPA_VERSION *v, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_HAL_VERSION, (void *)v, flag);
+}
+
+uint32_t ppa_drv_get_firmware_id(PPA_VERSION *v, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_PPE_FW_VERSION, (void *)v, flag);
+}
+
+
+uint32_t ppa_drv_get_number_of_phys_port(PPE_COUNT_CFG *count, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_PHYS_PORT_NUM, (void *)count, flag);
+}
+
+uint32_t ppa_drv_get_phys_port_info(PPE_IFINFO *info, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_PHYS_PORT_INFO, (void *)info, flag);
+}
+
+uint32_t ppa_drv_get_max_entries(PPA_MAX_ENTRY_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_MAX_ENTRIES, (void *)entry, flag);
+}
+
+
+uint32_t ppa_drv_set_mixed_wan_vlan_id(PPE_WAN_VID_RANGE *vid, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_MIX_WAN_VLAN_ID, (void *)vid, flag);
+}
+
+uint32_t ppa_drv_get_mixed_wan_vlan_id(PPE_WAN_VID_RANGE *vid, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_MIX_WAN_VLAN_ID, (void *)vid, flag);
+}
+
+uint32_t ppa_drv_set_route_cfg(PPE_ROUTING_CFG *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_ROUT_CFG, (void *)cfg, flag);
+}
+
+
+uint32_t ppa_drv_set_bridging_cfg(PPE_BRDG_CFG *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_BRDG_CFG, (void *)cfg, flag);
+}
+
+
+uint32_t ppa_drv_set_fast_mode(PPE_FAST_MODE_CFG *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_FAST_MODE_CFG, (void *)cfg, flag);
+}
+
+/*only needed for ppe hal*/
+#if defined(L2TP_CONFIG) && L2TP_CONFIG
+uint32_t ppa_drv_add_l2tptunnel_entry(PPA_L2TP_INFO *entry , uint32_t flag)
+{
+
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_ADD_L2TP_TUNNEL_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_del_l2tptunnel_entry(PPA_L2TP_INFO *entry , uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_DEL_L2TP_TUNNEL_ENTRY, (void *)entry, flag);
+}
+#endif
+
+uint32_t ppa_drv_set_default_dest_list(PPE_DEST_LIST *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_DEST_LIST, (void *)cfg, flag);
+}
+
+uint32_t ppa_drv_get_acc_mode(PPE_ACC_ENABLE *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_ACC_ENABLE, (void *)cfg, flag);
+}
+
+uint32_t ppa_drv_set_acc_mode(PPE_ACC_ENABLE *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_ACC_ENABLE, (void *)cfg, flag);
+}
+
+#if defined(MIB_MODE_ENABLE) && MIB_MODE_ENABLE
+
+uint32_t ppa_drv_set_mib_mode(PPE_MIB_MODE_ENABLE *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_MIB_MODE_ENABLE, (void *)cfg, flag);
+}
+
+uint32_t ppa_drv_get_mib_mode(PPE_MIB_MODE_ENABLE *cfg)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return
+		ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_MIB_MODE_ENABLE, (void *)cfg, 0);
+}
+
+
+#endif
+
+uint32_t ppa_drv_set_bridge_if_vlan_config(PPE_BRDG_VLAN_CFG *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_BRDG_VLAN_CFG, (void *)cfg, flag);
+}
+
+uint32_t ppa_drv_get_bridge_if_vlan_config(PPE_BRDG_VLAN_CFG *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_BRDG_VLAN_CFG, (void *)cfg, flag);
+}
+
+
+uint32_t ppa_drv_add_vlan_map(PPE_BRDG_VLAN_FILTER_MAP *fitler, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_ADD_BRDG_VLAN_FITLER, (void *)fitler, flag);
+}
+
+uint32_t ppa_drv_del_vlan_map(PPE_BRDG_VLAN_FILTER_MAP *fitler, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_DEL_BRDG_VLAN_FITLER, (void *)fitler, flag);
+}
+
+
+uint32_t ppa_drv_get_vlan_map(PPE_BRDG_VLAN_FILTER_MAP *fitler, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_BRDG_VLAN_FITLER, (void *)fitler, flag);
+}
+
+
+uint32_t ppa_drv_del_all_vlan_map(uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_DEL_BRDG_VLAN_ALL_FITLER_MAP, (void *)NULL, flag);
+}
+
+uint32_t ppa_drv_is_ipv6_enabled(uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_IPV6_FLAG, (void *)NULL, flag);
+}
+
+
+uint32_t ppa_drv_add_routing_entry(PPE_ROUTING_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_ADD_ROUTE_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_del_routing_entry(PPE_ROUTING_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_DEL_ROUTE_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_update_routing_entry(PPE_ROUTING_INFO *entry , uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_UPDATE_ROUTE_ENTRY, (void *)entry, flag);
+}
+
+#if defined(CAP_WAP_CONFIG) && CAP_WAP_CONFIG
+uint32_t ppa_drv_add_capwap_entry(PPA_CMD_CAPWAP_INFO *entry , uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_ADD_CAPWAP_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_delete_capwap_entry(PPA_CMD_CAPWAP_INFO *entry , uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_DEL_CAPWAP_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_get_capwap_mib(PPA_CMD_CAPWAP_INFO *entry , uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_CAPWAP_MIB, (void *)entry, flag);
+}
+
+
+#endif
+
+uint32_t ppa_drv_add_wan_mc_entry(PPE_MC_INFO *entry , uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_ADD_MC_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_del_wan_mc_entry(PPE_MC_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_DEL_MC_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_update_wan_mc_entry(PPE_MC_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_UPDATE_MC_ENTRY, (void *)entry, flag);
+}
+
+#if defined(RTP_SAMPLING_ENABLE) && RTP_SAMPLING_ENABLE
+uint32_t ppa_drv_set_wan_mc_rtp(PPE_MC_INFO *entry)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_MC_RTP, (void *)entry, 0);
+}
+
+uint32_t ppa_drv_get_mc_rtp_sampling_cnt(PPE_MC_INFO *entry)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_MC_RTP_SAMPLING_CNT, (void *)entry, 0);
+}
+
+
+#endif
+
+uint32_t ppa_drv_add_bridging_entry(PPE_BR_MAC_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_ADD_BR_MAC_BRIDGING_ENTRY, (void *)entry, flag);
+}
+
+
+uint32_t ppa_drv_del_bridging_entry(PPE_BR_MAC_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_DEL_BR_MAC_BRIDGING_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_add_tunnel_entry(PPE_TUNNEL_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	if (entry->tunnel_type == TUNNEL_TYPE_6RD){
+		return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_ADD_6RD_TUNNEL_ENTRY, (void *)entry, flag);
+	}else if (entry->tunnel_type == TUNNEL_TYPE_DSLITE){
+#if defined(PPA_DSLITE) && PPA_DSLITE
+		/*disable upsteam acce*/
+		return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_ADD_DSLITE_TUNNEL_ENTRY, (void *)entry, flag);
+#endif
+	}
+
+	return PPA_FAILURE;
+}
+
+uint32_t ppa_drv_del_tunnel_entry(PPE_TUNNEL_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	if (entry->tunnel_type == TUNNEL_TYPE_6RD){
+		return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_DEL_6RD_TUNNEL_ENTRY, (void *)entry, flag);
+	}else if (entry->tunnel_type == TUNNEL_TYPE_DSLITE){
+		return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_DEL_DSLITE_TUNNEL_ENTRY, (void *)entry, flag);
+	}
+
+	return PPA_FAILURE;
+}
+
+
+uint32_t ppa_drv_add_pppoe_entry(PPE_PPPOE_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_ADD_PPPOE_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_del_pppoe_entry(PPE_PPPOE_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_DEL_PPPOE_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_get_pppoe_entry(PPE_PPPOE_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_PPPOE_ENTRY, (void *)entry, flag);
+}
+
+
+uint32_t ppa_drv_add_mtu_entry(PPE_MTU_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_ADD_MTU_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_del_mtu_entry(PPE_MTU_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_DEL_MTU_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_get_mtu_entry(PPE_MTU_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_MTU_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_get_routing_entry_bytes(PPE_ROUTING_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_ROUTE_ACC_BYTES, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_get_mc_entry_bytes(PPE_MC_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_MC_ACC_BYTES, (void *)entry, flag);
+}
+
+
+uint32_t ppa_drv_add_mac_entry(PPE_ROUTE_MAC_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_ADD_MAC_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_del_mac_entry(PPE_ROUTE_MAC_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_DEL_MAC_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_get_mac_entry(PPE_ROUTE_MAC_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_MAC_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_add_outer_vlan_entry(PPE_OUT_VLAN_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_ADD_OUT_VLAN_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_del_outer_vlan_entry(PPE_OUT_VLAN_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_DEL_OUT_VLAN_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_get_outer_vlan_entry(PPE_OUT_VLAN_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_OUT_VLAN_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_add_ipv6_entry(PPE_IPV6_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_ADD_IPV6_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_del_ipv6_entry(PPE_IPV6_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_DEL_IPV6_ENTRY, (void *)entry, flag);
+}
+
+
+uint32_t ppa_drv_get_itf_mib(PPE_ITF_MIB_INFO *mib, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_ITF_MIB, (void *)mib, flag);
+}
+
+uint32_t ppa_drv_get_dsl_mib(PPA_DSL_QUEUE_MIB *mib, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_DSL_MIB, (void *)mib, flag);
+}
+
+
+uint32_t ppa_drv_get_ports_mib(PPA_PORT_MIB *mib, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_PORT_MIB, (void *)mib, flag);
+}
+
+#if defined(PPA_MFE) && PPA_MFE
+uint32_t ppa_drv_multifield_control(PPE_ENABLE_CFG *enable, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_MFE_CONTROL, (void *)enable, flag);
+}
+
+
+uint32_t ppa_drv_get_multifield_status(PPE_ENABLE_CFG *enable, uint32_t flag)  /*hook*/
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_MFE_STATUS, (void *)enable, flag);
+}
+
+uint32_t ppa_drv_get_multifield_max_flow(PPE_COUNT_CFG *count, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_MFE_STATUS, (void *)count, flag);
+}
+
+uint32_t ppa_drv_get_multifield_max_entry(PPE_COUNT_CFG *count, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_MFE_GET_FLOW_MAX_ENTRY, (void *)count, flag);
+}
+
+uint32_t ppa_drv_add_multifield_entry(PPE_MULTIFILED_FLOW *flow, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_MFE_ADD_FLOW, (void *)flow, flag);
+}
+
+uint32_t ppa_drv_get_multifield_entry(PPE_MULTIFILED_FLOW *flow, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_MFE_GET_FLOW, (void *)flow, flag);
+}
+
+uint32_t ppa_drv_del_multifield_entry(PPE_MULTIFILED_FLOW *flow, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_MFE_DEL_FLOW, (void *)flow, flag);
+}
+
+uint32_t ppa_drv_del_multifield_entry_via_index(PPE_MULTIFILED_FLOW *flow, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_MFE_DEL_FLOW_VIA_ENTRY, (void *)flow, flag);
+}
+#endif /*end of PPA_MFE*/
+
+uint32_t ppa_drv_test_and_clear_hit_stat(PPE_ROUTING_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_TEST_CLEAR_ROUTE_HIT_STAT, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_test_and_clear_mc_hit_stat(PPE_MC_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_TEST_CLEAR_MC_HIT_STAT, (void *)entry, flag);
+}
+
+
+uint32_t ppa_drv_test_and_clear_bridging_hit_stat(PPE_BR_MAC_INFO *entry, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_TEST_CLEAR_BR_HIT_STAT, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_get_max_vfilter_entries(PPE_VFILTER_COUNT_CFG *count, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_MAX_VFILTER_ENTRY_NUM, (void *)count, flag);
+}
+
+uint32_t ppa_drv_get_qos_qnum(PPE_QOS_COUNT_CFG *count, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_QOS_QUEUE_NUM, (void *)count, flag);
+}
+
+uint32_t ppa_drv_get_qos_status(PPA_QOS_STATUS *status, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_QOS_STATUS, (void *)status, flag);
+}
+
+
+uint32_t ppa_drv_get_qos_mib(PPE_QOS_MIB_INFO *mib, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_QOS_MIB, (void *)mib, flag);
+}
+
+uint32_t ppa_drv_set_ctrl_qos_rate(PPE_QOS_ENABLE_CFG *enable_cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_QOS_RATE_SHAPING_CTRL, (void *)enable_cfg, flag);
+}
+uint32_t ppa_drv_get_ctrl_qos_rate(PPE_QOS_ENABLE_CFG *enable_cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_QOS_RATE_SHAPING_CTRL, (void *)enable_cfg, flag);
+}
+
+uint32_t ppa_drv_set_qos_rate(PPE_QOS_RATE_SHAPING_CFG *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_QOS_RATE_SHAPING_CFG, (void *)cfg, flag);
+}
+
+uint32_t ppa_drv_get_qos_rate(PPE_QOS_RATE_SHAPING_CFG *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_QOS_RATE_SHAPING_CFG, (void *)cfg, flag);
+}
+
+uint32_t ppa_drv_reset_qos_rate(PPE_QOS_RATE_SHAPING_CFG *cfg , uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_RESET_QOS_RATE_SHAPING_CFG, (void *)cfg, flag);
+}
+
+uint32_t ppa_drv_init_qos_rate(uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_INIT_QOS_RATE_SHAPING, (void *)NULL, flag);
+}
+
+uint32_t ppa_drv_set_ctrl_qos_wfq(PPE_QOS_ENABLE_CFG *enable_cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_QOS_WFQ_CTRL, (void *)enable_cfg, flag);
+}
+
+uint32_t ppa_drv_get_ctrl_qos_wfq(PPE_QOS_ENABLE_CFG *enable_cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_QOS_WFQ_CTRL, (void *)enable_cfg, flag);
+}
+
+uint32_t ppa_drv_set_qos_wfq(PPE_QOS_WFQ_CFG *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_QOS_WFQ_CFG, (void *)cfg, flag);
+}
+uint32_t ppa_drv_get_qos_wfq(PPE_QOS_WFQ_CFG *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_QOS_WFQ_CFG, (void *)cfg, flag);
+}
+
+uint32_t ppa_drv_reset_qos_wfq(PPE_QOS_WFQ_CFG *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_RESET_QOS_WFQ_CFG, (void *)cfg, flag);
+}
+uint32_t ppa_drv_init_qos_wfq(uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_INIT_QOS_WFQ, (void *)NULL, flag);
+}
+
+uint32_t ppa_set_wan_itf(PPE_WANITF_CFG *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_WANITF, (void *)cfg, flag);
+}
+
+uint32_t ppa_get_session_hash(PPE_SESSION_HASH *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_SESSION_HASH, (void *)cfg, flag);
+}
+
+uint32_t ppa_drv_set_value(PPA_CMD_VARIABLE_VALUE_INFO *v, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_VALUE, (void *)v, flag);
+}
+uint32_t ppa_drv_get_value(PPA_CMD_VARIABLE_VALUE_INFO *v, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_VALUE, (void *)v, flag);
+}
+
+EXPORT_SYMBOL(ppa_drv_get_ppe_hal_id);
+EXPORT_SYMBOL(ppa_drv_get_max_entries);
+EXPORT_SYMBOL(ppa_drv_update_routing_entry);
+EXPORT_SYMBOL(ppa_drv_get_ports_mib);
+EXPORT_SYMBOL(ppa_drv_get_max_vfilter_entries);
+EXPORT_SYMBOL(ppa_drv_add_mac_entry);
+EXPORT_SYMBOL(ppa_drv_get_dsl_mib);
+EXPORT_SYMBOL(ppa_drv_get_mtu_entry);
+EXPORT_SYMBOL(ppa_drv_del_mtu_entry);
+EXPORT_SYMBOL(ppa_drv_add_mtu_entry);
+EXPORT_SYMBOL(ppa_drv_del_bridging_entry);
+EXPORT_SYMBOL(ppa_drv_add_ipv6_entry);
+EXPORT_SYMBOL(ppa_drv_del_ipv6_entry);
+EXPORT_SYMBOL(ppa_drv_set_qos_rate);
+EXPORT_SYMBOL(ppa_drv_del_vlan_map);
+EXPORT_SYMBOL(ppa_drv_set_acc_mode);
+#if defined(MIB_MODE_ENABLE) && MIB_MODE_ENABLE
+EXPORT_SYMBOL(ppa_drv_set_mib_mode);
+EXPORT_SYMBOL(ppa_drv_get_mib_mode);
+#endif
+#if defined(CAP_WAP_CONFIG) && CAP_WAP_CONFIG
+EXPORT_SYMBOL(ppa_drv_add_capwap_entry);
+EXPORT_SYMBOL(ppa_drv_delete_capwap_entry);
+EXPORT_SYMBOL(ppa_drv_get_capwap_mib);
+#endif
+EXPORT_SYMBOL(ppa_drv_del_pppoe_entry);
+EXPORT_SYMBOL(ppa_drv_get_acc_mode);
+EXPORT_SYMBOL(ppa_drv_get_pppoe_entry);
+EXPORT_SYMBOL(ppa_drv_del_mac_entry);
+EXPORT_SYMBOL(ppa_drv_set_route_cfg);
+EXPORT_SYMBOL(ppa_drv_set_bridge_if_vlan_config);
+EXPORT_SYMBOL(ppa_drv_get_mixed_wan_vlan_id);
+EXPORT_SYMBOL(ppa_drv_set_fast_mode);
+#if defined(L2TP_CONFIG) && L2TP_CONFIG
+EXPORT_SYMBOL(ppa_drv_add_l2tptunnel_entry);
+EXPORT_SYMBOL(ppa_drv_del_l2tptunnel_entry);
+#endif
+EXPORT_SYMBOL(ppa_drv_add_vlan_map);
+EXPORT_SYMBOL(ppa_drv_get_firmware_id);
+EXPORT_SYMBOL(ppa_drv_del_all_vlan_map);
+EXPORT_SYMBOL(ppa_drv_test_and_clear_hit_stat);
+EXPORT_SYMBOL(ppa_drv_test_and_clear_mc_hit_stat);
+EXPORT_SYMBOL(ppa_drv_get_phys_port_info);
+EXPORT_SYMBOL(ppa_drv_get_ctrl_qos_wfq);
+EXPORT_SYMBOL(ppa_drv_del_wan_mc_entry);
+EXPORT_SYMBOL(ppa_drv_hal_init);
+EXPORT_SYMBOL(ppa_drv_add_wan_mc_entry);
+EXPORT_SYMBOL(ppa_drv_add_pppoe_entry);
+EXPORT_SYMBOL(ppa_drv_add_tunnel_entry);
+EXPORT_SYMBOL(ppa_drv_del_tunnel_entry);
+EXPORT_SYMBOL(ppa_drv_hal_exit);
+EXPORT_SYMBOL(ppa_drv_get_itf_mib);
+EXPORT_SYMBOL(ppa_drv_get_routing_entry_bytes);
+EXPORT_SYMBOL(ppa_drv_get_mc_entry_bytes);
+EXPORT_SYMBOL(ppa_drv_set_bridging_cfg);
+EXPORT_SYMBOL(ppa_drv_get_bridge_if_vlan_config);
+EXPORT_SYMBOL(ppa_drv_get_ctrl_qos_rate);
+EXPORT_SYMBOL(ppa_drv_del_routing_entry);
+EXPORT_SYMBOL(ppa_drv_set_qos_wfq);
+EXPORT_SYMBOL(ppa_drv_set_mixed_wan_vlan_id);
+EXPORT_SYMBOL(ppa_drv_get_qos_mib);
+EXPORT_SYMBOL(ppa_drv_update_wan_mc_entry);
+#if defined(RTP_SAMPLING_ENABLE) && RTP_SAMPLING_ENABLE
+EXPORT_SYMBOL(ppa_drv_set_wan_mc_rtp);
+EXPORT_SYMBOL(ppa_drv_get_mc_rtp_sampling_cnt);
+#endif
+EXPORT_SYMBOL(ppa_drv_get_qos_rate);
+EXPORT_SYMBOL(ppa_drv_reset_qos_rate);
+EXPORT_SYMBOL(ppa_drv_set_ctrl_qos_rate);
+EXPORT_SYMBOL(ppa_drv_get_qos_status);
+EXPORT_SYMBOL(ppa_drv_get_qos_qnum);
+EXPORT_SYMBOL(ppa_drv_add_bridging_entry);
+EXPORT_SYMBOL(ppa_drv_test_and_clear_bridging_hit_stat);
+EXPORT_SYMBOL(ppa_drv_get_number_of_phys_port);
+EXPORT_SYMBOL(ppa_drv_init_qos_rate);
+EXPORT_SYMBOL(ppa_drv_init_qos_wfq);
+EXPORT_SYMBOL(ppa_drv_set_default_dest_list);
+EXPORT_SYMBOL(ppa_drv_get_vlan_map);
+EXPORT_SYMBOL(ppa_drv_add_routing_entry);
+EXPORT_SYMBOL(ppa_drv_del_outer_vlan_entry);
+EXPORT_SYMBOL(ppa_drv_add_outer_vlan_entry);
+EXPORT_SYMBOL(ppa_drv_get_outer_vlan_entry);
+EXPORT_SYMBOL(ppa_drv_reset_qos_wfq);
+EXPORT_SYMBOL(ppa_drv_get_qos_wfq);
+EXPORT_SYMBOL(ppa_drv_set_ctrl_qos_wfq);
+EXPORT_SYMBOL(ppa_set_wan_itf);
+#if defined(PPA_MFE) && PPA_MFE
+EXPORT_SYMBOL(ppa_drv_multifield_control);
+EXPORT_SYMBOL(ppa_drv_get_multifield_status);
+EXPORT_SYMBOL(ppa_drv_get_multifield_max_flow);
+EXPORT_SYMBOL(ppa_drv_get_multifield_max_entry);
+EXPORT_SYMBOL(ppa_drv_add_multifield_entry);
+EXPORT_SYMBOL(ppa_drv_get_multifield_entry);
+EXPORT_SYMBOL(ppa_drv_del_multifield_entry);
+EXPORT_SYMBOL(ppa_drv_del_multifield_entry_via_index);
+#endif
+EXPORT_SYMBOL(ppa_get_session_hash);
+EXPORT_SYMBOL(ppa_drv_set_value);
+EXPORT_SYMBOL(ppa_drv_get_value);
+
+#if defined(MBR_CONFIG) && MBR_CONFIG
+
+uint32_t ppa_drv_set_qos_shaper(PPE_QOS_RATE_SHAPING_CFG *cfg, uint32_t flag)
+{
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	/*return ifx_ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_QOS_RATE_SHAPING_CFG, (void *)cfg, flag);*/
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_SET_QOS_SHAPER_CFG, (void *)cfg, flag);
+}
+
+uint32_t ppa_drv_get_qos_shaper(PPE_QOS_RATE_SHAPING_CFG *cfg, uint32_t flag)
+{
+
+	if (!ppa_drv_hal_generic_hook)
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_generic_hook(PPA_GENERIC_HAL_GET_QOS_SHAPER_CFG, (void *)cfg, flag);
+}
+
+EXPORT_SYMBOL(ppa_drv_set_qos_shaper);
+EXPORT_SYMBOL(ppa_drv_get_qos_shaper);
+#endif /*end of MBR_CONFIG*/
+#endif /* ifndef CONFIG_PPA_HAL_SELECTOR*/
diff --git a/drivers/net/ethernet/lantiq/ppa/ppa_hal_wrapper.c b/drivers/net/ethernet/lantiq/ppa/ppa_hal_wrapper.c
new file mode 100644
index 000000000000..c74e3aeba0e3
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/ppa/ppa_hal_wrapper.c
@@ -0,0 +1,2174 @@
+/******************************************************************************
+ **
+ ** FILE NAME    : ppa_hal_wrapper.c
+ ** PROJECT      : PPA
+ ** MODULES      : PPA Wrapper for HAL Selector
+ **
+ ** DATE         : 18 Feb 2014
+ ** AUTHOR       : Kamal Eradath
+ ** DESCRIPTION  : PPA Wrapper for HAL Selector layer
+ ** COPYRIGHT    : Copyright (c) 2017 Intel Corporation
+ ** Copyright (c) 2014 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+ ** HISTORY
+ ** $Date        $Author                $Comment
+ ** 18 FEB 2014  Kamal Eradath          Initiate Version
+ *******************************************************************************/
+
+/*
+ * ####################################
+ *              Head File
+ * ####################################
+ */
+
+/*
+ *  Common Head File
+ */
+#include <linux/version.h>
+#include <generated/autoconf.h>
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/netdevice.h>
+#include <linux/atmdev.h>
+#include <net/sock.h>
+/*
+ *  Chip Specific Head File
+ */
+#include <net/ppa/ppa_api.h>
+/*TBD: KAMAL the below file is not really ppe specific.. so need to revisit*/
+#include <net/ppa/ppa_ppe_hal.h>
+#include <net/ppa/ppa_hal_wrapper.h>
+
+#if defined(CONFIG_PPA_HAL_SELECTOR) && CONFIG_PPA_HAL_SELECTOR
+
+/*Hooks used by to register multiple HAL layers */
+/*int32_t (*ppa_drv_hal_hook[PPA_MAX_HAL])(PPA_GENERIC_HOOK_CMD cmd, void *buffer, uint32_t flag, uint32_t hal_id)  =  { NULL };*/
+ppa_generic_hook_t	    ppa_drv_hal_hook[MAX_HAL]  =  {NULL};
+
+static PPA_HLIST_HEAD	    g_hsel_caps_list[MAX_CAPS];
+static PPE_LOCK		    g_hsel_caps_lock;
+
+ppa_tunnel_entry	    *g_tunnel_table[MAX_TUNNEL_ENTRIES]  =  {NULL};
+uint32_t		    g_tunnel_counter[MAX_TUNNEL_ENTRIES];
+PPE_LOCK		    g_tunnel_table_lock;
+
+static uint8_t g_num_registred_hals = 0;
+
+uint8_t ppa_drv_get_num_registred_hals(void)
+{
+	return g_num_registred_hals;
+}
+
+/*****************************************************************************************/
+/* HAL registration functions*/
+/*****************************************************************************************/
+uint32_t ppa_drv_generic_hal_register(uint32_t hal_id, ppa_generic_hook_t generic_hook)
+{
+	if (generic_hook) {
+		if (hal_id  ==  PPE_HAL) {/*ppe hal*/
+			ppa_drv_hal_generic_hook  =  generic_hook;
+		}
+		ppa_drv_hal_hook[hal_id]  =  generic_hook;
+		g_num_registred_hals++;
+		return PPA_SUCCESS;
+	}
+	return PPA_FAILURE;
+}
+
+void ppa_drv_generic_hal_deregister(uint32_t hal_id)
+{
+	if (hal_id  ==  PPE_HAL) {/*ppe hal*/
+		ppa_drv_hal_generic_hook  =  NULL;
+	}
+	ppa_drv_hal_hook[hal_id]  =  NULL;
+	g_num_registred_hals--;
+}
+
+int32_t ppa_select_hals_from_caplist(uint8_t start, uint8_t num_entries, PPA_HSEL_CAP_NODE *caps_list)
+{
+	PPA_HSEL_CAP_NODE *t_node = NULL;
+	PPA_HLIST_NODE *tmp;
+
+	uint32_t i;
+
+	for (i  =  start; i < (start+num_entries); i++) {
+		t_node = NULL;
+		ppa_hlist_for_each_entry_safe(t_node, tmp, &g_hsel_caps_list[caps_list[i].cap], cap_list) {
+			if ((caps_list[i].wt  ==  0) ||  (t_node->wt > caps_list[i].wt)) {
+				caps_list[i].hal_id  =  t_node->hal_id;
+				caps_list[i].wt  =  t_node->wt;
+				break;
+			}
+		}
+		if (t_node  ==  NULL) {
+			return PPA_FAILURE;
+		}
+	}
+	return PPA_SUCCESS;
+}
+
+int32_t ppa_group_hals_in_capslist(uint8_t start, uint8_t num_entries, PPA_HSEL_CAP_NODE *caps_list)
+{
+	uint32_t j = 1;
+	if ((start+j) < num_entries) {
+		while (caps_list[start].hal_id  ==  caps_list[start+j].hal_id) {
+			j++;
+		}
+	}
+	return j;
+}
+
+static void ppa_insert_hsel_cap_node(PPA_HSEL_CAP_NODE *cap_node)
+{
+	PPA_HSEL_CAP_NODE *t_node = NULL, *t1_node = NULL;
+	PPA_HLIST_NODE *tmp;
+
+	/* check whether it is first entry in the list*/
+	if (ppa_hlist_empty(&g_hsel_caps_list[cap_node->cap])) {
+		ppa_hlist_add_head(&cap_node->cap_list, &g_hsel_caps_list[cap_node->cap]);
+	} else {
+		/* not the first entry so find the location based on wt*/
+		ppa_hlist_for_each_entry_safe(t_node, tmp,  &g_hsel_caps_list[cap_node->cap], cap_list) {
+			if (t_node->wt > cap_node->wt) {
+				ppa_hlist_add_before(&cap_node->cap_list, &t_node->cap_list);
+				return;
+			}
+			t1_node = t_node;
+		}
+		/* reached the end of the list*/
+		if (likely(t1_node)) {
+			ppa_hlist_add_after(&cap_node->cap_list, &t1_node->cap_list);
+		}
+	}
+}
+
+uint32_t ppa_drv_register_cap(PPA_API_CAPS cap, uint8_t wt, PPA_HAL_ID hal_id)
+{
+	PPA_HSEL_CAP_NODE *cap_node;
+
+	/* allocate the node*/
+	cap_node  =  (PPA_HSEL_CAP_NODE*) kmalloc (sizeof(PPA_HSEL_CAP_NODE), GFP_KERNEL);
+	if (!cap_node) {
+		return PPA_FAILURE;
+	}
+	memset(cap_node, 0, sizeof(PPA_HSEL_CAP_NODE));
+	PPA_INIT_HLIST_NODE(&cap_node->cap_list);
+	cap_node->wt  =  wt;
+	cap_node->cap  =  cap;
+	cap_node->hal_id  =  hal_id;
+
+	/* find the location to insert in the list and insert it. based on the ascending order of weight*/
+	ppa_insert_hsel_cap_node(cap_node);
+
+	return PPA_SUCCESS;
+}
+
+
+uint32_t ppa_drv_deregister_cap(PPA_API_CAPS cap, PPA_HAL_ID hal_id)
+{
+	PPA_HSEL_CAP_NODE *t_node = NULL;
+	PPA_HLIST_NODE *tmp;
+
+	ppa_hlist_for_each_entry_safe(t_node, tmp, &g_hsel_caps_list[cap], cap_list) {
+		if (t_node->hal_id  ==  hal_id) {
+			ppa_hlist_del(&t_node->cap_list);
+			kfree(t_node);
+			return PPA_SUCCESS;
+		}
+	}
+	return PPA_FAILURE;
+}
+
+/*****************************************************************************************/
+/* wrappers for various hal API*/
+/*****************************************************************************************/
+
+uint32_t ppa_hsel_hal_init(uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_INIT, (void *)NULL, flag);
+}
+
+uint32_t ppa_hsel_hal_exit(uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_EXIT, (void *)NULL, flag);
+}
+
+uint32_t ppa_hsel_get_hal_id(PPA_VERSION *v, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_HAL_VERSION, (void *)v, flag);
+}
+
+uint32_t ppa_hsel_get_firmware_id(PPA_VERSION *v, uint32_t flag, uint32_t hal_id)
+{
+
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_PPE_FW_VERSION, (void *)v, flag);
+}
+
+uint32_t ppa_hsel_get_number_of_phys_port(PPE_COUNT_CFG *count, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_PHYS_PORT_NUM, (void *)count, flag);
+}
+
+uint32_t ppa_hsel_get_phys_port_info(PPE_IFINFO *info, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_PHYS_PORT_INFO, (void *)info, flag);
+}
+
+uint32_t ppa_hsel_get_max_entries(PPA_MAX_ENTRY_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_MAX_ENTRIES, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_set_route_cfg(PPE_ROUTING_CFG *cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_ROUT_CFG, (void *)cfg, flag);
+}
+
+
+uint32_t ppa_hsel_set_bridging_cfg(PPE_BRDG_CFG *cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_BRDG_CFG, (void *)cfg, flag);
+}
+
+
+uint32_t ppa_hsel_set_fast_mode(PPE_FAST_MODE_CFG *cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_FAST_MODE_CFG, (void *)cfg, flag);
+}
+
+uint32_t ppa_hsel_set_default_dest_list(PPE_DEST_LIST *cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_DEST_LIST, (void *)cfg, flag);
+}
+
+uint32_t ppa_hsel_get_acc_mode(PPE_ACC_ENABLE *cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_ACC_ENABLE, (void *)cfg, flag);
+}
+
+uint32_t ppa_hsel_set_acc_mode(PPE_ACC_ENABLE *cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_ACC_ENABLE, (void *)cfg, flag);
+}
+
+uint32_t ppa_hsel_is_ipv6_enabled(uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_IPV6_FLAG, (void *)NULL, flag);
+}
+
+
+uint32_t ppa_hsel_init_qos_cfg(uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_QOS_INIT_CFG, (void *)NULL, flag);
+}
+uint32_t ppa_hsel_uninit_qos_cfg(uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_QOS_UNINIT_CFG, (void *)NULL, flag);
+}
+uint32_t ppa_hsel_add_qos_queue_entry(QOS_Q_ADD_CFG *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_QOS_ADDQUE_CFG, (void *)entry, flag);
+}
+uint32_t ppa_hsel_modify_qos_queue_entry(QOS_Q_MOD_CFG *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_QOS_MODQUE_CFG, (void *)entry, flag);
+}
+uint32_t ppa_hsel_delete_qos_queue_entry(QOS_Q_DEL_CFG *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_QOS_DELQUE_CFG, (void *)entry, flag);
+}
+uint32_t ppa_hsel_set_qos_rate_entry(QOS_RATE_SHAPING_CFG *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_QOS_RATE_SHAPING_CFG, (void *)entry, flag);
+}
+uint32_t ppa_hsel_reset_qos_rate_entry(QOS_RATE_SHAPING_CFG *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_RESET_QOS_RATE_SHAPING_CFG, (void *)entry, flag);
+}
+uint32_t ppa_hsel_set_qos_shaper_entry(QOS_RATE_SHAPING_CFG *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_QOS_SHAPER_CFG, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_mod_subif_port_cfg(QOS_MOD_SUBIF_PORT_CFG *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_MOD_SUBIF_PORT_CFG, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_add_complement(PPE_ROUTING_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_COMPLEMENT_ENTRY, (void *)entry, flag);
+}
+EXPORT_SYMBOL(ppa_hsel_add_complement);
+
+uint32_t ppa_hsel_del_complement(PPE_ROUTING_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_COMPLEMENT_ENTRY, (void *)entry, flag);
+}
+EXPORT_SYMBOL(ppa_hsel_del_complement);
+
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+uint32_t ppa_hsel_add_class_rule(PPA_CLASS_RULE *rule, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_CLASS_RULE, (void*) rule, flag);
+}
+
+uint32_t ppa_hsel_mod_class_rule(PPA_CLASS_RULE *rule, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_MOD_CLASS_RULE, (void*) rule, flag);
+}
+
+uint32_t ppa_hsel_del_class_rule(PPA_CLASS_RULE *rule, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_CLASS_RULE, (void*) rule, flag);
+}
+
+uint32_t ppa_hsel_get_class_rule(PPA_CLASS_RULE *rule, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_CLASS_RULE, (void*) rule, flag);
+}
+#endif
+
+
+uint32_t ppa_hsel_add_routing_entry(PPE_ROUTING_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_ROUTE_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_del_routing_entry(PPE_ROUTING_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_ROUTE_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_update_routing_entry(PPE_ROUTING_INFO *entry , uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_UPDATE_ROUTE_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_add_wan_mc_entry(PPE_MC_INFO *entry , uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_MC_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_del_wan_mc_entry(PPE_MC_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_MC_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_update_wan_mc_entry(PPE_MC_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_UPDATE_MC_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_add_bridging_entry(PPE_BR_MAC_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_BR_MAC_BRIDGING_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_del_bridging_entry(PPE_BR_MAC_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_BR_MAC_BRIDGING_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_test_and_clear_bridging_hit_stat(PPE_BR_MAC_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_TEST_CLEAR_BR_HIT_STAT, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_add_tunnel_entry(PPE_TUNNEL_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	if (entry->tunnel_type  ==  TUNNEL_TYPE_6RD) {
+		/*Extract details from the netif and store in the tunnel table*/
+		return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_6RD_TUNNEL_ENTRY, (void *)entry, flag);
+	}else if (entry->tunnel_type  ==  TUNNEL_TYPE_DSLITE) {
+#if defined(PPA_DSLITE) && PPA_DSLITE
+		/*disable upsteam acce*/
+		return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_DSLITE_TUNNEL_ENTRY, (void *)entry, flag);
+#endif
+	}
+	return PPA_FAILURE;
+}
+
+/*****************************************************************************************/
+/* debug enable for all the registered hals*/
+/*****************************************************************************************/
+uint32_t ppa_drv_set_hal_dbg(PPA_CMD_GENERAL_ENABLE_INFO *cfg, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	for (; hal_id < MAX_HAL; hal_id++) {
+		if (ppa_drv_hal_hook[hal_id] != NULL) {
+			ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_DEBUG, (void *)cfg, flag);
+		}
+	}
+
+	return PPA_SUCCESS;
+}
+
+
+uint32_t ppa_hsel_del_tunnel_entry(PPE_TUNNEL_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	if (entry->tunnel_type  ==  TUNNEL_TYPE_6RD) {
+		return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_6RD_TUNNEL_ENTRY, (void *)entry, flag);
+	}else if (entry->tunnel_type  ==  TUNNEL_TYPE_DSLITE) {
+		return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_DSLITE_TUNNEL_ENTRY, (void *)entry, flag);
+	}
+	return PPA_FAILURE;
+}
+
+#if defined(CONFIG_LTQ_TOE_DRIVER) && CONFIG_LTQ_TOE_DRIVER
+uint32_t ppa_hsel_del_lro_entry(PPA_LRO_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_LRO_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_add_lro_entry(PPA_LRO_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_LRO_ENTRY, (void *)entry, flag);
+}
+
+#endif /* defined(CONFIG_LTQ_TOE_DRIVER) && CONFIG_LTQ_TOE_DRIVER*/
+
+
+#if defined(CONFIG_PPA_MPE_IP97)
+uint32_t ppa_hsel_get_ipsec_tunnel_mib(IPSEC_TUNNEL_MIB_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_IPSEC_TUNNEL_MIB, (void *)entry, flag);
+}
+
+#endif
+
+
+uint32_t ppa_hsel_get_routing_entry_bytes(PPE_ROUTING_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_ROUTE_ACC_BYTES, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_get_mc_entry_bytes(PPE_MC_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_MC_ACC_BYTES, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_add_outer_vlan_entry(PPE_OUT_VLAN_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_OUT_VLAN_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_del_outer_vlan_entry(PPE_OUT_VLAN_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_OUT_VLAN_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_get_outer_vlan_entry(PPE_OUT_VLAN_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_OUT_VLAN_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_get_itf_mib(PPE_ITF_MIB_INFO *mib, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_ITF_MIB, (void *)mib, flag);
+}
+
+uint32_t ppa_hsel_get_generic_itf_mib( PPA_ITF_MIB_INFO *mib, uint32_t flag, uint32_t hal_id)
+{
+        if( !ppa_drv_hal_hook[hal_id] ) return PPA_FAILURE;
+
+        return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_NEW_ITF_MIB,(void *)mib, flag );
+}
+
+
+uint32_t ppa_hsel_get_dsl_mib(PPA_DSL_QUEUE_MIB *mib, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_DSL_MIB, (void *)mib, flag);
+}
+
+uint32_t ppa_hsel_get_ports_mib(PPA_PORT_MIB *mib, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_PORT_MIB, (void *)mib, flag);
+}
+
+uint32_t ppa_hsel_test_and_clear_hit_stat(PPE_ROUTING_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_TEST_CLEAR_ROUTE_HIT_STAT, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_test_and_clear_mc_hit_stat(PPE_MC_INFO *entry, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_TEST_CLEAR_MC_HIT_STAT, (void *)entry, flag);
+}
+
+uint32_t ppa_hsel_get_qos_qnum(PPE_QOS_COUNT_CFG *count, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_QOS_QUEUE_NUM, (void *)count, flag);
+}
+
+uint32_t ppa_hsel_get_qos_status(PPA_QOS_STATUS *status, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_QOS_STATUS, (void *)status, flag);
+}
+
+
+uint32_t ppa_hsel_get_qos_mib(PPE_QOS_MIB_INFO *mib, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_QOS_MIB, (void *)mib, flag);
+}
+
+uint32_t ppa_hsel_set_ctrl_qos_rate(PPE_QOS_ENABLE_CFG *enable_cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_QOS_RATE_SHAPING_CTRL, (void *)enable_cfg, flag);
+}
+uint32_t ppa_hsel_get_ctrl_qos_rate(PPE_QOS_ENABLE_CFG *enable_cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_QOS_RATE_SHAPING_CTRL, (void *)enable_cfg, flag);
+}
+
+uint32_t ppa_hsel_set_qos_rate(PPE_QOS_RATE_SHAPING_CFG *cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_QOS_RATE_SHAPING_CFG, (void *)cfg, flag);
+}
+
+uint32_t ppa_hsel_get_qos_rate(PPE_QOS_RATE_SHAPING_CFG *cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_QOS_RATE_SHAPING_CFG, (void *)cfg, flag);
+}
+
+uint32_t ppa_hsel_reset_qos_rate(PPE_QOS_RATE_SHAPING_CFG *cfg , uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_RESET_QOS_RATE_SHAPING_CFG, (void *)cfg, flag);
+}
+
+uint32_t ppa_hsel_init_qos_rate(uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_INIT_QOS_RATE_SHAPING, (void *)NULL, flag);
+}
+
+uint32_t ppa_hsel_set_ctrl_qos_wfq(PPE_QOS_ENABLE_CFG *enable_cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_QOS_WFQ_CTRL, (void *)enable_cfg, flag);
+}
+
+uint32_t ppa_hsel_get_ctrl_qos_wfq(PPE_QOS_ENABLE_CFG *enable_cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_QOS_WFQ_CTRL, (void *)enable_cfg, flag);
+}
+
+uint32_t ppa_hsel_set_qos_wfq(PPE_QOS_WFQ_CFG *cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_QOS_WFQ_CFG, (void *)cfg, flag);
+}
+
+uint32_t ppa_hsel_get_qos_wfq(PPE_QOS_WFQ_CFG *cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_QOS_WFQ_CFG, (void *)cfg, flag);
+}
+
+uint32_t ppa_hsel_reset_qos_wfq(PPE_QOS_WFQ_CFG *cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_RESET_QOS_WFQ_CFG, (void *)cfg, flag);
+}
+
+uint32_t ppa_hsel_init_qos_wfq(uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_INIT_QOS_WFQ, (void *)NULL, flag);
+}
+/*****************************************************************************************/
+/* HAL layer APIs*/
+/*****************************************************************************************/
+
+/*****************************************************************************************/
+/*  Initialize all registred HAL layers							 */
+/*****************************************************************************************/
+uint32_t ppa_drv_hal_init(uint32_t flag)
+{
+	int i = 0;
+
+	/* Initialize the capability list head*/
+	for (i = 0; i < MAX_CAPS; i++) {
+		PPA_INIT_HLIST_HEAD(&g_hsel_caps_list[i]);
+	}
+	/* Initialize all the registred HAL layers*/
+	for (i = 0; i < MAX_HAL; i++) {
+		if (ppa_drv_hal_hook[i] && (ppa_hsel_hal_init(flag, i) !=  PPA_SUCCESS))
+			return PPA_FAILURE;
+	}
+
+	for (i = 0; i<MAX_TUNNEL_ENTRIES; i++) {
+		g_tunnel_table[i]  =  NULL;
+		g_tunnel_counter[i]  =  0;
+	}
+
+	ppe_lock_init(&g_hsel_caps_lock);
+	ppe_lock_init(&g_tunnel_table_lock);
+
+	return PPA_SUCCESS;
+}
+
+/*****************************************************************************************/
+/*  Un-Initialize all registred HAL layers						 */
+/*****************************************************************************************/
+uint32_t ppa_drv_hal_exit(uint32_t flag)
+{
+	int i = 0;
+
+	for (i = 0; i<MAX_TUNNEL_ENTRIES; i++) {
+		kfree(g_tunnel_table[i]);
+	}
+
+	for (i = 0; i < MAX_HAL; i++) {
+		if (ppa_drv_hal_hook[i] && (ppa_hsel_hal_exit(flag, i) !=  PPA_SUCCESS))
+			return PPA_FAILURE;
+	}
+
+	return PPA_SUCCESS;
+}
+
+/*****************************************************************************************/
+/*  return the id of all registred HAL layers						 */
+/*****************************************************************************************/
+uint32_t ppa_drv_get_hal_id(PPA_VERSION *v, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	/* TODO: need clean handling to select hal*/
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+	if (ppa_drv_hal_hook[hal_id]  ==  NULL) {
+		if (v->index  ==  0)
+			hal_id  =  PAE_HAL;
+		else
+			hal_id  =  MPE_HAL;
+	}
+#endif
+
+	return ppa_hsel_get_hal_id(v, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/*  return the firmware id of all registred HAL layers					 */
+/*****************************************************************************************/
+uint32_t ppa_drv_get_firmware_id(PPA_VERSION *v, uint32_t flag)
+{
+#ifndef CONFIG_PPA_PUMA7
+	/* TODO: need clean handling to select hal*/
+	uint32_t hal_id = PPE_HAL;
+	if (ppa_drv_hal_hook[hal_id]  ==  NULL) {
+		if (v->index  ==  0)
+			hal_id  =  PAE_HAL;
+		else
+			hal_id  =  MPE_HAL;
+	}
+	return ppa_hsel_get_firmware_id(v, flag, hal_id);
+#endif
+	return PPA_FAILURE;
+}
+
+/*****************************************************************************************/
+/* This function returns the number of physical port at the system level*/
+/* Since PAE has the physical ports in the iRX500 system connected to it, we need to query only PAE*/
+/* in case of legacy platforms we need to call PPE HAL*/
+/*****************************************************************************************/
+uint32_t ppa_drv_get_number_of_phys_port(PPE_COUNT_CFG *count, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	/* TODO: need clean handling to select hal*/
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+	if (ppa_drv_hal_hook[hal_id]  ==  NULL) {
+		hal_id  =  PAE_HAL;
+	}
+#endif
+	return ppa_hsel_get_number_of_phys_port(count, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* Re-write the hal layer implementation in case of GRX500*/
+/* Since PAE has the physical ports in the system connected to it, we need to query only PAE*/
+/*****************************************************************************************/
+uint32_t ppa_drv_get_phys_port_info(PPE_IFINFO *info, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	/* TODO: need clean handling to select hal*/
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+	if (ppa_drv_hal_hook[hal_id]  ==  NULL) {
+		hal_id  =  PAE_HAL;
+	}
+#endif
+	return ppa_hsel_get_phys_port_info(info, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* The paramters returned by this function is too tightly coupled to PPE implementation*/
+/* some of those parameters are not valid for GRX500*/
+/* some new parametrs are added to the original datastructure to support GRX500 routing*/
+/* new parameters are protucted under macro "CONFIG_PPA_HAL_SELECTOR"*/
+/*****************************************************************************************/
+uint32_t ppa_drv_get_max_entries(PPA_MAX_ENTRY_INFO *entry, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	/* TODO: need clean handling to select hal*/
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+
+	/* Check whether PPE HAl*/
+	if (ppa_drv_hal_hook[hal_id]  ==  NULL) {
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+		entry->ppe_hal_disabled  =  1;
+#endif
+		hal_id  =  PAE_HAL;
+	}
+#endif
+
+	if ((ppa_drv_hal_hook[hal_id] != NULL) && (ppa_hsel_get_max_entries(entry, flag, hal_id) !=  PPA_SUCCESS))
+		return PPA_FAILURE;
+
+	return PPA_SUCCESS;
+}
+
+/*****************************************************************************************/
+/* Initial routing configuration*/
+/* this will include some changes in the parameters based on PAE and MPE initialization parameters*/
+/*******************re-visit**********************************/
+uint32_t ppa_drv_set_route_cfg(PPE_ROUTING_CFG *cfg, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	for (; hal_id < MAX_HAL; hal_id++) {
+		if ((ppa_drv_hal_hook[hal_id] != NULL) && (ppa_hsel_set_route_cfg(cfg, flag, hal_id)!=  PPA_SUCCESS))
+			return PPA_FAILURE;
+	}
+
+	return PPA_SUCCESS;
+
+}
+
+
+/*****************************************************************************************/
+/* Initial bridging configuration*/
+/* Bridge intital configuration*/
+/* Only PAE will do the bridging in case of GRX500*/
+/* In legacy platforms bridge acceleration is not supported*/
+/*****************************************************************************************/
+uint32_t ppa_drv_set_bridging_cfg(PPE_BRDG_CFG *cfg, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	/* TODO: need clean handling to select hal*/
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+
+	if (ppa_drv_hal_hook[hal_id]  ==  NULL) {
+		hal_id  =  PAE_HAL;
+	}
+#endif
+
+	return ppa_hsel_set_bridging_cfg(cfg,flag,hal_id);
+}
+
+/*****************************************************************************************/
+/* sets the default dest list for each port*/
+/*******************re-visit**********************************/
+uint32_t ppa_drv_set_default_dest_list(PPE_DEST_LIST *cfg, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	/* TODO: need clean handling to select hal*/
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+
+	if (ppa_drv_hal_hook[hal_id]  ==  NULL) {
+		return PPA_SUCCESS;
+	}
+#endif
+
+	return ppa_hsel_set_default_dest_list(cfg, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* enable or disable acceleration*/
+/* This is achived in PAE by writing a flow rule to send all the packets to CPU port*/
+/*****************************************************************************************/
+uint32_t ppa_drv_get_acc_mode(PPE_ACC_ENABLE *cfg, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	/* TODO: need clean handling to select hal*/
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+
+	if (ppa_drv_hal_hook[hal_id]  ==  NULL) {
+		hal_id  =  PAE_HAL;
+	}
+#endif
+
+	return ppa_hsel_get_acc_mode(cfg, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* enable or disable acceleration*/
+/* This is achived in PAE by writing a flow rule to send all the packets to CPU port*/
+/*****************************************************************************************/
+uint32_t ppa_drv_set_acc_mode(PPE_ACC_ENABLE *cfg, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	/* TODO: need clean handling to select hal*/
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+
+	if (ppa_drv_hal_hook[hal_id]  ==  NULL) {
+		hal_id  =  PAE_HAL;
+	}
+#endif
+
+	return ppa_hsel_set_acc_mode(cfg, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* Add bridge session entry */
+/* Supported only by PAE in GRX500 so no need to run the HAL selection Algorithm */
+/*****************************************************************************************/
+uint32_t ppa_drv_add_bridging_entry(PPE_BR_MAC_INFO *entry, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	/* TODO: need clean handling to select hal*/
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+
+	if (ppa_drv_hal_hook[hal_id]  ==  NULL) {
+		hal_id  =  PAE_HAL;
+	}
+#endif
+
+	return ppa_hsel_add_bridging_entry(entry, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* Delete bridge session entry */
+/* Supported only by PAE in GRX500 so no need to run the HAL selection Algorithm */
+/*****************************************************************************************/
+uint32_t ppa_drv_del_bridging_entry(PPE_BR_MAC_INFO *entry, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	/* TODO: need clean handling to select hal*/
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+
+	if (ppa_drv_hal_hook[hal_id]  ==  NULL) {
+		hal_id  =  PAE_HAL;
+	}
+#endif
+	return ppa_hsel_del_bridging_entry(entry, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* Multi bridge support*/
+/* Adding a port under a bridge */
+/* Supported only by PAE in GRX500 so no need to run the HAL selection Algorithm */
+/*****************************************************************************************/
+uint32_t ppa_drv_add_br_port(PPA_BR_PORT_INFO *entry, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	/* TODO: need clean handling to select hal*/
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PAE_HAL;
+#endif
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_BR_PORT, (void *)entry, flag);
+}
+
+/*****************************************************************************************/
+/* Multi bridge support*/
+/* deleting a port under a bridge */
+/* Supported only by PAE in GRX500 so no need to run the HAL selection Algorithm */
+/*****************************************************************************************/
+uint32_t ppa_drv_del_br_port(PPA_BR_PORT_INFO *entry, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	/* TODO: need clean handling to select hal*/
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PAE_HAL;
+#endif
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_BR_PORT, (void *)entry, flag);
+}
+
+
+/*****************************************************************************************/
+/* Bridge entry timeout */
+/* Supported only by PAE in GRX500 so no need to run the HAL selection Algorithm */
+/*****************************************************************************************/
+uint32_t ppa_drv_test_and_clear_bridging_hit_stat(PPE_BR_MAC_INFO *entry, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	/* TODO: need clean handling to select hal*/
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+	if (ppa_drv_hal_hook[hal_id]  ==  NULL) {
+		hal_id  =  PAE_HAL;
+	}
+#endif
+
+	return ppa_hsel_test_and_clear_bridging_hit_stat(entry, flag, hal_id);
+}
+
+uint32_t ppa_drv_add_routing_entry(PPE_ROUTING_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	return ppa_hsel_add_routing_entry(entry, flag, hal_id);
+}
+
+uint32_t ppa_drv_del_routing_entry(PPE_ROUTING_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	return ppa_hsel_del_routing_entry(entry, flag, hal_id);
+}
+
+uint32_t ppa_drv_update_routing_entry(PPE_ROUTING_INFO *entry , uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	return ppa_hsel_update_routing_entry(entry, flag, hal_id);
+}
+
+uint32_t ppa_drv_get_routing_entry_bytes(PPE_ROUTING_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	return ppa_hsel_get_routing_entry_bytes(entry, flag, hal_id);
+}
+
+uint32_t ppa_drv_add_wan_mc_entry(PPE_MC_INFO *entry , uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	return ppa_hsel_add_wan_mc_entry(entry, flag, hal_id);
+}
+
+uint32_t ppa_drv_del_wan_mc_entry(PPE_MC_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	return ppa_hsel_del_wan_mc_entry(entry, flag, hal_id);
+}
+
+uint32_t ppa_drv_update_wan_mc_entry(PPE_MC_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	return ppa_hsel_update_wan_mc_entry(entry, flag, hal_id);
+}
+
+uint32_t ppa_drv_get_mc_entry_bytes(PPE_MC_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	return ppa_hsel_get_mc_entry_bytes(entry, flag, hal_id);
+}
+
+
+uint32_t ppa_drv_test_and_clear_hit_stat(PPE_ROUTING_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	return ppa_hsel_test_and_clear_hit_stat(entry,flag,hal_id);
+}
+
+uint32_t ppa_drv_test_and_clear_mc_hit_stat(PPE_MC_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	return ppa_hsel_test_and_clear_mc_hit_stat(entry,flag,hal_id);
+}
+
+uint32_t ppa_drv_add_pppoe_entry(PPE_PPPOE_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_PPPOE_ENTRY, (void *)entry, flag);
+
+}
+
+uint32_t ppa_drv_del_pppoe_entry(PPE_PPPOE_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_PPPOE_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_get_pppoe_entry(PPE_PPPOE_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_PPPOE_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_add_ipv6_entry(PPE_IPV6_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_IPV6_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_del_ipv6_entry(PPE_IPV6_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_IPV6_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_add_outer_vlan_entry(PPE_OUT_VLAN_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	return ppa_hsel_add_outer_vlan_entry(entry,flag,hal_id);
+}
+
+uint32_t ppa_drv_del_outer_vlan_entry(PPE_OUT_VLAN_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	return ppa_hsel_del_outer_vlan_entry(entry,flag,hal_id);
+}
+
+uint32_t ppa_drv_get_outer_vlan_entry(PPE_OUT_VLAN_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	return ppa_hsel_get_outer_vlan_entry(entry,flag,hal_id);
+}
+
+uint32_t ppa_drv_add_mac_entry(PPE_ROUTE_MAC_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_MAC_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_del_mac_entry(PPE_ROUTE_MAC_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_MAC_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_get_mac_entry(PPE_ROUTE_MAC_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_MAC_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_set_fast_mode(PPE_FAST_MODE_CFG *cfg, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (ppa_drv_hal_hook[hal_id]  ==  NULL) {
+		return PPA_SUCCESS;
+	}
+
+	return ppa_hsel_set_fast_mode(cfg, flag, hal_id);
+}
+
+/*only needed for ppe hal*/
+#if defined(L2TP_CONFIG) && L2TP_CONFIG
+uint32_t ppa_drv_add_l2tptunnel_entry(PPA_L2TP_INFO *entry , uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_L2TP_TUNNEL_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_del_l2tptunnel_entry(PPA_L2TP_INFO *entry , uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_L2TP_TUNNEL_ENTRY, (void *)entry, flag);
+}
+
+#endif
+
+/*only neded for ppe hal*/
+#if defined(CAP_WAP_CONFIG) && CAP_WAP_CONFIG
+uint32_t ppa_drv_add_capwap_entry(PPA_CMD_CAPWAP_INFO *entry , uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_CAPWAP_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_delete_capwap_entry(PPA_CMD_CAPWAP_INFO *entry , uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_CAPWAP_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_get_capwap_mib(PPA_CMD_CAPWAP_INFO *entry,uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_CAPWAP_MIB, (void *)entry, flag);
+}
+#endif
+
+/*only neded for ppe hal*/
+#if defined(PPA_MFE) && PPA_MFE
+uint32_t ppa_drv_multifield_control(PPE_ENABLE_CFG *cfg, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_MFE_CONTROL, (void *)enable, flag);
+}
+
+uint32_t ppa_drv_get_multifield_status(PPE_ENABLE_CFG *cfg, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_MFE_STATUS, (void *)enable, flag);
+}
+
+uint32_t ppa_drv_get_multifield_max_entry(PPE_COUNT_CFG *count, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_MFE_STATUS, (void *)count, flag);
+}
+
+uint32_t ppa_drv_add_multifield_entry(PPE_MULTIFILED_FLOW *flow, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_MFE_GET_FLOW_MAX_ENTRY, (void *)count, flag);
+}
+
+uint32_t ppa_drv_get_multifield_entry(PPE_MULTIFILED_FLOW *flow, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_MFE_ADD_FLOW, (void *)flow, flag);
+}
+uint32_t ppa_drv_del_multifield_entry(PPE_MULTIFILED_FLOW *flow, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_MFE_DEL_FLOW, (void *)flow, flag);
+}
+uint32_t ppa_drv_del_multifield_entry_via_index(PPE_MULTIFILED_FLOW *flow, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_MFE_DEL_FLOW_VIA_ENTRY, (void *)flow, flag);
+}
+#endif /*end of PPA_MFE*/
+
+/*only neded for ppe hal*/
+#if defined(MIB_MODE_ENABLE) && MIB_MODE_ENABLE
+uint32_t ppa_drv_set_mib_mode(PPE_MIB_MODE_ENABLE *cfg, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_MIB_MODE_ENABLE, (void *)cfg, flag);
+}
+
+uint32_t ppa_drv_get_mib_mode(PPE_MIB_MODE_ENABLE *cfg)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_MIB_MODE_ENABLE, (void *)cfg, 0);
+}
+#endif
+
+#if defined(RTP_SAMPLING_ENABLE) && RTP_SAMPLING_ENABLE
+uint32_t ppa_hsel_set_wan_mc_rtp(PPE_MC_INFO *entry, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_MC_RTP, (void *)entry, 0);
+}
+
+uint32_t ppa_drv_set_wan_mc_rtp(PPE_MC_INFO *entry)
+{
+	uint32_t hal_id = PPE_HAL;
+	return ppa_hsel_set_wan_mc_rtp(entry, hal_id);
+}
+
+uint32_t ppa_hsel_get_mc_rtp_sampling_cnt(PPE_MC_INFO *entry, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_MC_RTP_SAMPLING_CNT, (void *)entry, 0);
+}
+
+uint32_t ppa_drv_get_mc_rtp_sampling_cnt(PPE_MC_INFO *entry)
+{
+	uint32_t hal_id = PPE_HAL;
+	return ppa_hsel_get_mc_rtp_sampling_cnt(entry, hal_id);
+}
+#endif
+
+/*only neded for ppe hal*/
+uint32_t ppa_drv_set_bridge_if_vlan_config(PPE_BRDG_VLAN_CFG *cfg, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_BRDG_VLAN_CFG, (void *)cfg, flag);
+}
+uint32_t ppa_drv_get_bridge_if_vlan_config(PPE_BRDG_VLAN_CFG *cfg, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_BRDG_VLAN_CFG, (void *)cfg, flag);
+}
+uint32_t ppa_drv_add_vlan_map(PPE_BRDG_VLAN_FILTER_MAP *filter, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_BRDG_VLAN_FITLER, (void *)filter, flag);
+}
+
+uint32_t ppa_drv_del_vlan_map(PPE_BRDG_VLAN_FILTER_MAP *filter, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_BRDG_VLAN_FITLER, (void *)filter, flag);
+}
+uint32_t ppa_drv_get_vlan_map(PPE_BRDG_VLAN_FILTER_MAP *filter, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_BRDG_VLAN_FITLER, (void *)filter, flag);
+}
+
+uint32_t ppa_drv_del_all_vlan_map(uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_BRDG_VLAN_ALL_FITLER_MAP, (void *)NULL, flag);
+}
+
+
+
+uint32_t ppa_drv_get_max_vfilter_entries(PPE_VFILTER_COUNT_CFG *count, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_MAX_VFILTER_ENTRY_NUM, (void *)count, flag);
+}
+
+
+uint32_t ppa_drv_set_mixed_wan_vlan_id(PPE_WAN_VID_RANGE *vlan_id, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_MIX_WAN_VLAN_ID, (void *)vlan_id, flag);
+}
+
+
+uint32_t ppa_set_wan_itf(PPE_WANITF_CFG *cfg, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_WANITF, (void *)cfg, flag);
+}
+
+uint32_t ppa_get_session_hash(PPE_SESSION_HASH *cfg, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (ppa_drv_hal_hook[hal_id]) {
+		return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_SESSION_HASH, (void *)cfg, flag);
+	} else {
+		/* in case of PAE the hash information will be same as the hash stored in session_list_item.hash_index*/
+		/* hash table id '2' indicates that this is PAE hash table*/
+		cfg->flag  =  PAE_HAL;
+		return PPA_SUCCESS;
+	}
+
+	return PPA_FAILURE;
+}
+
+
+/*****************************************************************************************/
+/* HAL selector needs to iterate through all the HALs registered for capability "SESS_IPV6,"*/
+/*****************************************************************************************/
+uint32_t ppa_drv_is_ipv6_enabled(uint32_t flag)
+{
+	PPA_HSEL_CAP_NODE *t_node = NULL;
+	PPA_HLIST_NODE *tmp;
+
+	/* for each HAL registred for capability IPV6_ROUTING*/
+	/* if any of the HAL is having it enabled return success*/
+	ppa_hlist_for_each_entry_safe(t_node, tmp,  &g_hsel_caps_list[SESS_IPV6], cap_list) {
+		if (ppa_hsel_is_ipv6_enabled(flag, t_node->hal_id)  ==  PPA_SUCCESS) {
+			return 1;
+		}
+	}
+
+	return PPA_FAILURE;
+}
+
+/*****************************************************************************************/
+/* Add a tunnel entry in the tunnel table*/
+/* in case of GRX500 tunnel information is maintained at the PPA level*/
+/*****************************************************************************************/
+uint32_t ppa_drv_add_tunnel_entry(PPE_TUNNEL_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id  = PPE_HAL;
+
+	if (ppa_drv_hal_hook[PPE_HAL] !=  NULL) {
+		return ppa_hsel_add_tunnel_entry(entry, flag, hal_id);
+	} else {
+		/*******************re-visit**********************************/
+		/* PPA maintains the tunnel table*/
+		/* when the session is getting added this function is getting called if it needs a tunnel*/
+		/* search in the tunnel table to find whether this tunnel is already added*/
+		/* if yes return the tunnel id*/
+		/* if no add the new tunnel entry in the tunnel table*/
+	}
+	return PPA_FAILURE;
+}
+
+/*****************************************************************************************/
+/* Delete a tunnel entry in the tunnel table*/
+/* in case of GRX500 tunnel information is maintained at the PPA level*/
+/*****************************************************************************************/
+uint32_t ppa_drv_del_tunnel_entry(PPE_TUNNEL_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (ppa_drv_hal_hook[PPE_HAL] !=  NULL) {
+		return ppa_hsel_del_tunnel_entry(entry, flag, hal_id);
+	} else {
+		/*******************re-visit**********************************/
+	}
+	return PPA_FAILURE;
+}
+
+/*****************************************************************************************/
+/* interface mib can be read from PAE in case of GRX500*/
+/*****************************************************************************************/
+uint32_t ppa_drv_get_itf_mib(PPE_ITF_MIB_INFO *mib, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+	if (ppa_drv_hal_hook[hal_id]  ==  NULL) {
+		hal_id  =  PAE_HAL;
+	}
+
+	return ppa_hsel_get_itf_mib(mib, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* Generic interface mib read from different acceleration engines */
+/*****************************************************************************************/
+uint32_t ppa_drv_get_generic_itf_mib( PPA_ITF_MIB_INFO *mib, uint32_t flag,uint32_t hal_id)
+{
+	if( ppa_drv_hal_hook[hal_id] == NULL) {
+		hal_id = PAE_HAL;
+	}
+
+	return ppa_hsel_get_generic_itf_mib(mib, flag, hal_id);
+}
+
+
+
+/*****************************************************************************************/
+// DSL interface mib can be read from DSL HAL
+/*****************************************************************************************/
+uint32_t ppa_drv_get_dsl_mib(PPA_DSL_QUEUE_MIB *mib, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+	if (ppa_drv_hal_hook[hal_id]  ==  NULL) {
+		hal_id  =  DSL_HAL;
+	}
+
+	return ppa_hsel_get_dsl_mib(mib, flag, hal_id);
+}
+
+
+/*****************************************************************************************/
+/* Port based MIB can be read from PAE HAL*/
+/*****************************************************************************************/
+uint32_t ppa_drv_get_ports_mib(PPA_PORT_MIB *mib, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+	if (ppa_drv_hal_hook[hal_id]  ==  NULL) {
+		hal_id  =  PAE_HAL;
+		mib->flags  =  PAE_HAL;
+	}
+
+	return ppa_hsel_get_ports_mib(mib, flag,hal_id);
+}
+
+
+
+/*****************************************************************************************/
+/* QOS get number of queues per port*/
+/*****************************************************************************************/
+uint32_t ppa_drv_get_qos_qnum(PPE_QOS_COUNT_CFG *count, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = TMU_HAL;
+#endif
+	return ppa_hsel_get_qos_qnum(count, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* QOS global qos status get*/
+/*****************************************************************************************/
+uint32_t ppa_drv_get_qos_status(PPA_QOS_STATUS *status, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = TMU_HAL;
+#endif
+
+	return ppa_hsel_get_qos_status(status, flag, hal_id);
+}
+
+
+/*****************************************************************************************/
+/* QOS queue level MIB get*/
+/*****************************************************************************************/
+uint32_t ppa_drv_get_qos_mib(PPE_QOS_MIB_INFO *mib, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = TMU_HAL;
+#endif
+
+	return ppa_hsel_get_qos_mib(mib, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* QOS set qos rate shaping enable/disable*/
+/*****************************************************************************************/
+uint32_t ppa_drv_set_ctrl_qos_rate(PPE_QOS_ENABLE_CFG *enable_cfg, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+#endif
+
+	return ppa_hsel_set_ctrl_qos_rate(enable_cfg, flag, hal_id);
+}
+/*****************************************************************************************/
+/* QOS get rateshaping status*/
+/*****************************************************************************************/
+uint32_t ppa_drv_get_ctrl_qos_rate(PPE_QOS_ENABLE_CFG *enable_cfg, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+#endif
+
+	return ppa_hsel_get_ctrl_qos_rate(enable_cfg, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* QOS set rate of a queue*/
+/*****************************************************************************************/
+uint32_t ppa_drv_set_qos_rate(PPE_QOS_RATE_SHAPING_CFG *cfg, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+#endif
+	/*uint32_t hal_id = PPE_HAL;*/
+
+	return ppa_hsel_set_qos_rate(cfg, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* QOS get rate of a queue*/
+/*****************************************************************************************/
+uint32_t ppa_drv_get_qos_rate(PPE_QOS_RATE_SHAPING_CFG *cfg, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+#endif
+
+	return ppa_hsel_get_qos_rate(cfg, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* QOS reset teh rate od a queue to default*/
+/*****************************************************************************************/
+uint32_t ppa_drv_reset_qos_rate(PPE_QOS_RATE_SHAPING_CFG *cfg , uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+#endif
+
+	return ppa_hsel_reset_qos_rate(cfg, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* QOS initialize qos rateshaping*/
+/*****************************************************************************************/
+uint32_t ppa_drv_init_qos_rate(uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+#endif
+
+	return ppa_hsel_init_qos_rate(flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* QOS set enable/disable wfq*/
+/*****************************************************************************************/
+uint32_t ppa_drv_set_ctrl_qos_wfq(PPE_QOS_ENABLE_CFG *enable_cfg, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+#endif
+
+	return ppa_hsel_set_ctrl_qos_wfq(enable_cfg, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* QOS get wfq status*/
+/*****************************************************************************************/
+uint32_t ppa_drv_get_ctrl_qos_wfq(PPE_QOS_ENABLE_CFG *enable_cfg, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+#endif
+
+	return ppa_hsel_get_ctrl_qos_wfq(enable_cfg, flag, hal_id);
+}
+
+
+/*****************************************************************************************/
+/* QOS set queue weight*/
+/*****************************************************************************************/
+uint32_t ppa_drv_set_qos_wfq(PPE_QOS_WFQ_CFG *cfg, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+#endif
+
+	return ppa_hsel_set_qos_wfq(cfg, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* QOS get queue weight*/
+/*****************************************************************************************/
+uint32_t ppa_drv_get_qos_wfq(PPE_QOS_WFQ_CFG *cfg, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+#endif
+
+	return ppa_hsel_get_qos_wfq(cfg, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* QOS reset queue weight*/
+/*****************************************************************************************/
+uint32_t ppa_drv_reset_qos_wfq(PPE_QOS_WFQ_CFG *cfg, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+#endif
+
+	return ppa_hsel_reset_qos_wfq(cfg, flag, hal_id);
+}
+
+/*****************************************************************************************/
+/* QOS initialize wfq*/
+/*****************************************************************************************/
+uint32_t ppa_drv_init_qos_wfq(uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+#endif
+
+	return ppa_hsel_init_qos_wfq(flag, hal_id);
+}
+
+#if defined(MBR_CONFIG) && MBR_CONFIG
+uint32_t ppa_hsel_set_qos_shaper(PPE_QOS_RATE_SHAPING_CFG *cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_QOS_RATE_SHAPING_CTRL, (void *)cfg, flag);
+}
+
+uint32_t ppa_hsel_get_qos_shaper(PPE_QOS_RATE_SHAPING_CFG *cfg, uint32_t flag, uint32_t hal_id)
+{
+	if (!ppa_drv_hal_hook[hal_id])
+		return PPA_FAILURE;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_QOS_RATE_SHAPING_CFG, (void *)cfg, flag);
+}
+
+
+uint32_t ppa_drv_set_qos_shaper(PPE_QOS_RATE_SHAPING_CFG *cfg, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+#endif
+
+	return ppa_hsel_set_qos_shaper(cfg, flag, hal_id);
+}
+
+uint32_t ppa_drv_get_qos_shaper(PPE_QOS_RATE_SHAPING_CFG *cfg, uint32_t flag)
+{
+#ifdef CONFIG_PPA_PUMA7
+	uint32_t hal_id = PUMA_HAL;
+#else
+	uint32_t hal_id = PPE_HAL;
+#endif
+
+	return ppa_hsel_get_qos_shaper(cfg, flag, hal_id);
+
+}
+
+EXPORT_SYMBOL(ppa_drv_set_qos_shaper);
+EXPORT_SYMBOL(ppa_drv_get_qos_shaper);
+#endif /*end of MBR_CONFIG*/
+/*****************************************************************************************/
+uint32_t ppa_drv_get_mixed_wan_vlan_id(PPE_WAN_VID_RANGE *vlan_id, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_MIX_WAN_VLAN_ID, (void *)vlan_id, flag);
+
+}
+
+/*****************************************************************************************/
+/* need more information on the below functions relevence*/
+/*****************************************************************************************/
+uint32_t ppa_drv_set_value(PPA_CMD_VARIABLE_VALUE_INFO *v, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) {
+		return PPA_SUCCESS;
+	}
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_SET_VALUE, (void *)v, flag);
+}
+
+uint32_t ppa_drv_get_value(PPA_CMD_VARIABLE_VALUE_INFO *v, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) {
+		return PPA_SUCCESS;
+	}
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_VALUE, (void *)v, flag);
+}
+
+uint32_t ppa_drv_add_mtu_entry(PPE_MTU_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_ADD_MTU_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_del_mtu_entry(PPE_MTU_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_DEL_MTU_ENTRY, (void *)entry, flag);
+}
+
+uint32_t ppa_drv_get_mtu_entry(PPE_MTU_INFO *entry, uint32_t flag)
+{
+	uint32_t hal_id = PPE_HAL;
+
+	if (!ppa_drv_hal_hook[hal_id]) return PPA_SUCCESS;
+
+	return ppa_drv_hal_hook[hal_id](PPA_GENERIC_HAL_GET_MTU_ENTRY, (void *)entry, flag);
+}
+
+EXPORT_SYMBOL(ppa_drv_hal_hook);
+EXPORT_SYMBOL(g_tunnel_table);
+EXPORT_SYMBOL(g_tunnel_counter);
+EXPORT_SYMBOL(g_tunnel_table_lock);
+
+EXPORT_SYMBOL(ppa_drv_get_num_registred_hals);
+EXPORT_SYMBOL(ppa_drv_generic_hal_register);
+EXPORT_SYMBOL(ppa_drv_generic_hal_deregister);
+EXPORT_SYMBOL(ppa_drv_register_cap);
+EXPORT_SYMBOL(ppa_drv_deregister_cap);
+EXPORT_SYMBOL(ppa_select_hals_from_caplist);
+EXPORT_SYMBOL(ppa_group_hals_in_capslist);
+
+EXPORT_SYMBOL(ppa_set_wan_itf);
+EXPORT_SYMBOL(ppa_drv_hal_init);
+EXPORT_SYMBOL(ppa_drv_hal_exit);
+EXPORT_SYMBOL(ppa_drv_get_hal_id);
+EXPORT_SYMBOL(ppa_drv_get_max_entries);
+EXPORT_SYMBOL(ppa_drv_set_route_cfg);
+EXPORT_SYMBOL(ppa_drv_get_ports_mib);
+EXPORT_SYMBOL(ppa_hsel_get_generic_itf_mib);
+EXPORT_SYMBOL(ppa_drv_get_generic_itf_mib);
+EXPORT_SYMBOL(ppa_drv_get_dsl_mib);
+EXPORT_SYMBOL(ppa_drv_get_itf_mib);
+EXPORT_SYMBOL(ppa_drv_set_acc_mode);
+EXPORT_SYMBOL(ppa_drv_get_acc_mode);
+EXPORT_SYMBOL(ppa_drv_get_firmware_id);
+EXPORT_SYMBOL(ppa_drv_get_phys_port_info);
+EXPORT_SYMBOL(ppa_drv_get_number_of_phys_port);
+EXPORT_SYMBOL(ppa_drv_set_fast_mode);
+EXPORT_SYMBOL(ppa_drv_is_ipv6_enabled);
+EXPORT_SYMBOL(ppa_drv_set_default_dest_list);
+
+EXPORT_SYMBOL(ppa_drv_add_routing_entry);
+EXPORT_SYMBOL(ppa_drv_del_routing_entry);
+EXPORT_SYMBOL(ppa_drv_update_routing_entry);
+EXPORT_SYMBOL(ppa_drv_get_routing_entry_bytes);
+EXPORT_SYMBOL(ppa_drv_add_wan_mc_entry);
+EXPORT_SYMBOL(ppa_drv_del_wan_mc_entry);
+EXPORT_SYMBOL(ppa_drv_update_wan_mc_entry);
+EXPORT_SYMBOL(ppa_drv_get_mc_entry_bytes);
+EXPORT_SYMBOL(ppa_drv_set_bridging_cfg);
+EXPORT_SYMBOL(ppa_drv_add_bridging_entry);
+EXPORT_SYMBOL(ppa_drv_del_bridging_entry);
+EXPORT_SYMBOL(ppa_drv_add_br_port);
+EXPORT_SYMBOL(ppa_drv_del_br_port);
+EXPORT_SYMBOL(ppa_drv_test_and_clear_bridging_hit_stat);
+EXPORT_SYMBOL(ppa_drv_del_outer_vlan_entry);
+EXPORT_SYMBOL(ppa_drv_add_outer_vlan_entry);
+EXPORT_SYMBOL(ppa_drv_get_outer_vlan_entry);
+
+EXPORT_SYMBOL(ppa_drv_add_pppoe_entry);
+EXPORT_SYMBOL(ppa_drv_del_pppoe_entry);
+EXPORT_SYMBOL(ppa_drv_get_pppoe_entry);
+EXPORT_SYMBOL(ppa_drv_add_ipv6_entry);
+EXPORT_SYMBOL(ppa_drv_del_ipv6_entry);
+EXPORT_SYMBOL(ppa_drv_add_tunnel_entry);
+EXPORT_SYMBOL(ppa_drv_del_tunnel_entry);
+
+EXPORT_SYMBOL(ppa_drv_set_qos_rate);
+EXPORT_SYMBOL(ppa_drv_get_ctrl_qos_wfq);
+EXPORT_SYMBOL(ppa_drv_get_ctrl_qos_rate);
+EXPORT_SYMBOL(ppa_drv_set_qos_wfq);
+EXPORT_SYMBOL(ppa_drv_get_qos_mib);
+EXPORT_SYMBOL(ppa_drv_get_qos_rate);
+EXPORT_SYMBOL(ppa_drv_reset_qos_rate);
+EXPORT_SYMBOL(ppa_drv_set_ctrl_qos_rate);
+EXPORT_SYMBOL(ppa_drv_get_qos_status);
+EXPORT_SYMBOL(ppa_drv_get_qos_qnum);
+EXPORT_SYMBOL(ppa_drv_init_qos_rate);
+EXPORT_SYMBOL(ppa_drv_init_qos_wfq);
+EXPORT_SYMBOL(ppa_drv_reset_qos_wfq);
+EXPORT_SYMBOL(ppa_drv_get_qos_wfq);
+EXPORT_SYMBOL(ppa_drv_set_ctrl_qos_wfq);
+
+EXPORT_SYMBOL(ppa_get_session_hash);
+EXPORT_SYMBOL(ppa_drv_set_value);
+EXPORT_SYMBOL(ppa_drv_get_value);
+EXPORT_SYMBOL(ppa_drv_get_mixed_wan_vlan_id);
+EXPORT_SYMBOL(ppa_drv_set_mixed_wan_vlan_id);
+EXPORT_SYMBOL(ppa_drv_get_max_vfilter_entries);
+EXPORT_SYMBOL(ppa_drv_add_mac_entry);
+EXPORT_SYMBOL(ppa_drv_del_mac_entry);
+EXPORT_SYMBOL(ppa_drv_get_mac_entry);
+EXPORT_SYMBOL(ppa_drv_test_and_clear_hit_stat);
+EXPORT_SYMBOL(ppa_drv_test_and_clear_mc_hit_stat);
+EXPORT_SYMBOL(ppa_drv_get_vlan_map);
+EXPORT_SYMBOL(ppa_drv_del_vlan_map);
+EXPORT_SYMBOL(ppa_drv_add_vlan_map);
+EXPORT_SYMBOL(ppa_drv_del_all_vlan_map);
+#if defined(PPA_MFE) && PPA_MFE
+EXPORT_SYMBOL(ppa_drv_multifield_control);
+EXPORT_SYMBOL(ppa_drv_get_multifield_status);
+EXPORT_SYMBOL(ppa_drv_get_multifield_max_flow);
+EXPORT_SYMBOL(ppa_drv_get_multifield_max_entry);
+EXPORT_SYMBOL(ppa_drv_add_multifield_entry);
+EXPORT_SYMBOL(ppa_drv_get_multifield_entry);
+EXPORT_SYMBOL(ppa_drv_del_multifield_entry);
+EXPORT_SYMBOL(ppa_drv_del_multifield_entry_via_index);
+#endif
+#if defined(MIB_MODE_ENABLE) && MIB_MODE_ENABLE
+EXPORT_SYMBOL(ppa_drv_set_mib_mode);
+EXPORT_SYMBOL(ppa_drv_get_mib_mode);
+#endif
+#if defined(RTP_SAMPLING_ENABLE) && RTP_SAMPLING_ENABLE
+EXPORT_SYMBOL(ppa_drv_set_wan_mc_rtp);
+EXPORT_SYMBOL(ppa_drv_get_mc_rtp_sampling_cnt);
+EXPORT_SYMBOL(ppa_hsel_set_wan_mc_rtp);
+EXPORT_SYMBOL(ppa_hsel_get_mc_rtp_sampling_cnt);
+#endif
+EXPORT_SYMBOL(ppa_drv_get_bridge_if_vlan_config);
+EXPORT_SYMBOL(ppa_drv_set_bridge_if_vlan_config);
+
+EXPORT_SYMBOL(ppa_drv_get_mtu_entry);
+EXPORT_SYMBOL(ppa_drv_del_mtu_entry);
+EXPORT_SYMBOL(ppa_drv_add_mtu_entry);
+
+#if defined(L2TP_CONFIG) && L2TP_CONFIG
+EXPORT_SYMBOL(ppa_drv_add_l2tptunnel_entry);
+EXPORT_SYMBOL(ppa_drv_del_l2tptunnel_entry);
+#endif
+
+#if defined(CAP_WAP_CONFIG) && CAP_WAP_CONFIG
+EXPORT_SYMBOL(ppa_drv_add_capwap_entry);
+EXPORT_SYMBOL(ppa_drv_delete_capwap_entry);
+EXPORT_SYMBOL(ppa_drv_get_capwap_mib);
+#endif
+
+EXPORT_SYMBOL(ppa_drv_set_hal_dbg);
+EXPORT_SYMBOL(ppa_hsel_add_routing_entry);
+EXPORT_SYMBOL(ppa_hsel_del_routing_entry);
+EXPORT_SYMBOL(ppa_hsel_update_routing_entry);
+EXPORT_SYMBOL(ppa_hsel_add_wan_mc_entry);
+EXPORT_SYMBOL(ppa_hsel_del_wan_mc_entry);
+EXPORT_SYMBOL(ppa_hsel_update_wan_mc_entry);
+
+EXPORT_SYMBOL(ppa_hsel_add_tunnel_entry);
+EXPORT_SYMBOL(ppa_hsel_del_tunnel_entry);
+
+#if defined(CONFIG_LTQ_TOE_DRIVER) && CONFIG_LTQ_TOE_DRIVER
+EXPORT_SYMBOL(ppa_hsel_add_lro_entry);
+EXPORT_SYMBOL(ppa_hsel_del_lro_entry);
+#endif /* defined(CONFIG_LTQ_TOE_DRIVER) && CONFIG_LTQ_TOE_DRIVER*/
+
+EXPORT_SYMBOL(ppa_hsel_get_routing_entry_bytes);
+#if defined(CONFIG_PPA_MPE_IP97)
+EXPORT_SYMBOL(ppa_hsel_get_ipsec_tunnel_mib);
+#endif
+EXPORT_SYMBOL(ppa_hsel_get_mc_entry_bytes);
+EXPORT_SYMBOL(ppa_hsel_test_and_clear_hit_stat);
+EXPORT_SYMBOL(ppa_hsel_test_and_clear_mc_hit_stat);
+
+EXPORT_SYMBOL(ppa_hsel_add_outer_vlan_entry);
+EXPORT_SYMBOL(ppa_hsel_del_outer_vlan_entry);
+EXPORT_SYMBOL(ppa_hsel_get_outer_vlan_entry);
+
+EXPORT_SYMBOL(ppa_hsel_init_qos_cfg);
+EXPORT_SYMBOL(ppa_hsel_uninit_qos_cfg);
+EXPORT_SYMBOL(ppa_hsel_add_qos_queue_entry);
+EXPORT_SYMBOL(ppa_hsel_modify_qos_queue_entry);
+EXPORT_SYMBOL(ppa_hsel_delete_qos_queue_entry);
+EXPORT_SYMBOL(ppa_hsel_set_qos_rate_entry);
+EXPORT_SYMBOL(ppa_hsel_reset_qos_rate_entry);
+EXPORT_SYMBOL(ppa_hsel_set_qos_shaper_entry);
+EXPORT_SYMBOL(ppa_hsel_mod_subif_port_cfg);
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+EXPORT_SYMBOL(ppa_hsel_add_class_rule);
+EXPORT_SYMBOL(ppa_hsel_mod_class_rule);
+EXPORT_SYMBOL(ppa_hsel_del_class_rule);
+EXPORT_SYMBOL(ppa_hsel_get_class_rule);
+#endif
+#endif /*defined(CONFIG_PPA_HAL_SELECTOR) && CONFIG_PPA_HAL_SELECTOR*/
diff --git a/drivers/net/ethernet/lantiq/ppa/ppa_hook.c b/drivers/net/ethernet/lantiq/ppa/ppa_hook.c
new file mode 100644
index 000000000000..538f0ddc37da
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/ppa/ppa_hook.c
@@ -0,0 +1,1135 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2017-2018 Intel Corporation
+ * Copyright (C) 2010-2016 Lantiq Beteiligungs-GmbH & Co. KG
+ * Author  : Xu Liang
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ *******************************************************************************/
+
+/*
+ * ####################################
+ * Version No.
+ * ####################################
+ */
+#define VER_FAMILY 0x60 /* bit 0: res*/
+/* 1: Danube*/
+/* 2: Twinpass*/
+/* 3: Amazon-SE*/
+/* 4: res*/
+/* 5: AR9*/
+/* 6: GR9*/
+#define VER_DRTYPE 0x08 /* bit 0: Normal Data Path driver*/
+/* 1: Indirect-Fast Path driver*/
+/* 2: HAL driver*/
+/* 3: Hook driver*/
+/* 4: Stack/System Adaption Layer driver*/
+/* 5: PPA API driver*/
+#define VER_INTERFACE 0x00 /* bit 0: MII 0*/
+/* 1: MII 1*/
+/* 2: ATM WAN*/
+/* 3: PTM WAN*/
+#define VER_ACCMODE 0x03 /* bit 0: Routing*/
+/* 1: Bridging*/
+#define VER_MAJOR 0
+#define VER_MID 0
+#define VER_MINOR 2
+
+/*
+ * ####################################
+ * Head File
+ * ####################################
+ */
+
+/*
+ * Common Head File
+ */
+#include <linux/version.h>
+#include <generated/autoconf.h>
+#include <asm/atomic.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/netdevice.h>
+#include <linux/atmdev.h>
+#include <net/sock.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <net/protocol.h>
+#include <net/xfrm.h>
+#include <linux/once.h>
+#include <linux/jhash.h>
+#include <linux/skbuff.h>
+#include <net/netns/hash.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_ipv6.h>
+#include <linux/netfilter_bridge.h>
+#include <linux/netfilter/nfnetlink.h>
+#include <linux/netfilter/nfnetlink_conntrack.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_core.h>
+#include <net/netfilter/nf_conntrack_ecache.h>
+#include <net/netfilter/nf_conntrack_tuple.h>
+#include <net/netfilter/nf_conntrack_acct.h>
+/*
+ * Chip Specific Head File
+ */
+#include <net/ppa/ppa_api.h>
+#include <net/ppa/ppa_stack_al.h>
+#include <net/ppa/ppa_api_directpath.h>
+
+/*
+ * ####################################
+ * Export PPA hook functions
+ * ####################################
+ */
+
+/**********************************************************************************************
+ * PPA unicast routing hook function:ppa_hook_session_add_fn
+ * It it used to check unicast routing session and if necessary, add it to PPE FW to acceleration this session.
+ * This hook will be invoked when a packet is handled before NAT and after NAT
+ * input parameter PPA_BUF *: IP packet
+ * input parameter PPA_SESSION *: routing session in network stack
+ * input parameter uint32_t: this flag mainly to indicate the hook is invoked before NAT or after NAT
+ * return: PPA_SESSION_ADDED: this session is added into PPE FW, ie, it is accelerated by PPE
+ * PPA_SESSION_EXISTS: already added into PPE FW
+ * PPA_SESSION_NOT_ADDED: not added int PPE FW for some reasons.
+ * ...
+ **********************************************************************************************/
+int32_t (*ppa_hook_session_add_fn)(PPA_BUF *, PPA_SESSION *, uint32_t) = NULL;
+int32_t (*ppa_hook_session_bradd_fn)(PPA_BUF *, PPA_SESSION *, uint32_t) = NULL;
+
+#if defined(CONFIG_PPA_MPE_IP97)
+int32_t (*ppa_hook_session_ipsec_add_fn)(PPA_XFRM_STATE *, sa_direction) = NULL;
+int32_t (*ppa_hook_session_ipsec_del_fn)(PPA_XFRM_STATE *) = NULL;
+#endif
+
+/**********************************************************************************************
+ * PPA unicast routing hook function:ppa_hook_session_add_fn
+ * It it used to delete a unicast routing session when it is timeout, reset or purposely.
+ * input parameter PPA_SESSION *: the session pointer
+ * input parameter uint32_t: for future purpose
+ * return: PPA_SUCCESS: this session is deleted sucessfully from PPE FW
+ * ...
+ **********************************************************************************************/
+int32_t (*ppa_hook_session_del_fn)(PPA_SESSION *, uint32_t) = NULL;
+
+/**********************************************************************************************
+ * PPA session priority hook function:ppa_hook_session_prio_fn
+ * It is used to get session priority of a ppa session.
+ * input parameter PPA_SESSION *: the session pointer
+ * input parameter uint32_t: for future purpose
+ * return: session priority
+ * ...
+ **********************************************************************************************/
+int32_t (*ppa_hook_session_prio_fn)(PPA_SESSION *, uint32_t) = NULL;
+
+/**********************************************************************************************
+ * PPA unicast routing hook function:ppa_hook_get_ct_stats_fn
+ * It it used to read the statistics counters of specified session
+ * input parameter PPA_SESSION *: the session pointer
+ * input parameter PPA_CT_COUNTER *: the session stats counter structure pointer
+ * return: PPA_SUCCESS: the session statistics read sucessfully
+ **********************************************************************************************/
+
+int32_t (*ppa_hook_get_ct_stats_fn)(PPA_SESSION *, PPA_CT_COUNTER*) = NULL;
+/**********************************************************************************************
+ * PPA unicast hook function:ppa_hook_inactivity_status_fn
+ * It it used to check whether a unicast session is timeout or not.
+ * Normally it is called by network stack which want to delete a session without any traffic for sometime.
+ * input parameter PPA_U_SESSION *: the unicast session pointer
+ * return: PPA_HIT: the session still hit and should keep it
+ * PPA_TIMEOUT: timeout already
+ **********************************************************************************************/
+int32_t (*ppa_hook_inactivity_status_fn)(PPA_U_SESSION *) = NULL;
+
+/**********************************************************************************************
+ * PPA unicast hook function:ppa_hook_set_inactivity_fn
+ * It it used to set one unicast session timeout value
+ * Normally it is called to prolong one sessions duration.
+ * input parameter PPA_U_SESSION *: the unicast session pointer
+ * input parameter int32_t: the timeout value
+ * return: PPA_SUCCESS: update timeout sucessfully
+ * PPA_FAILURE: fail to update timeout value
+
+ **********************************************************************************************/
+int32_t (*ppa_hook_set_inactivity_fn)(PPA_U_SESSION*, int32_t) = NULL;
+
+/**********************************************************************************************
+ * PPA briding learning hook function:ppa_hook_bridge_entry_add_fn
+ * It it used to add a bridging mac addresss into PPE FW.
+ * This hook will be invoked when bridging learned a mac address or purposely to filter one mac address.
+ * input parameter uint8_t*: the mac address
+ * input parameter PPA_NETIF *: the interface which learned the mac address
+ * input parameter PPA_NETIF *: bridge interface
+ * input parameter uint32_t: PPA_F_STATIC_ENTRY means static mode,
+ * PPA_F_DROP_PACKET means drop the packet, otherwise accelerate the packet.
+ * return: PPA_SESSION_ADDED: this session is added into PPE FW, ie, it is accelerated by PPE
+ * PPA_SESSION_EXISTS: already added into PPE FW
+ * PPA_SESSION_NOT_ADDED: not added int PPE FW for some reasons.
+ **********************************************************************************************/
+int32_t (*ppa_hook_bridge_entry_add_fn)(uint8_t *, PPA_NETIF *, PPA_NETIF *, uint32_t) = NULL;
+
+/**********************************************************************************************
+ * PPA briding learning hook function:ppa_hook_bridge_entry_delete_fn
+ * It it used to delete a bridging mac addresss from PPE FW.
+ * Normally this hook will be invoked when mac address timeout.
+ * input parameter uint8_t*: the mac address
+ * input parameter PPA_NETIF *: bridge interface
+ * input parameter uint32_t: flag for future purpose
+ * return: PPA_SESSION_ADDED: this session is added into PPE FW, ie, it is accelerated by PPE
+ * return: PPA_SUCCESS: set timeout value sucessfully.
+ * PPA_FAILURE: failed to update
+ **********************************************************************************************/
+int32_t (*ppa_hook_bridge_entry_delete_fn)(uint8_t *, PPA_NETIF *, uint32_t) = NULL;
+
+/**********************************************************************************************
+ * PPA bridge hook function:ppa_hook_bridge_entry_hit_time_fn
+ * It it used to get last hit time
+ * input parameter uint8_t *: the mac address
+ * input parameter PPA_NETIF *: bridge interface
+ * input parameter uint32_t *: the last hit time
+ * return: PPA_HIT: sucessfully get the last hit time
+ * PPA_SESSION_NOT_ADDED: the mac address not in PPE FW yet
+ **********************************************************************************************/
+int32_t (*ppa_hook_bridge_entry_hit_time_fn)(uint8_t *, PPA_NETIF *, uint32_t *) = NULL;
+
+#if defined(PPA_IF_MIB) && PPA_IF_MIB
+/**********************************************************************************************
+ * PPA mibs hook function:ppa_hook_get_accel_stats_fn
+ * It it used to port acclerated mib status, like accelerated rx/tx packet number and so on
+ * input parameter PPA_IFNAME *: specify which port's acceleration mibs want to get
+ * output parameter PPA_ACCEL_STATS *
+ * input parameter uint32_t: for future purpose
+ * return: PPA_SUCCESS: get sucessfully
+ * PPA_FAILURE: fail to get
+ **********************************************************************************************/
+int32_t (*ppa_hook_get_netif_accel_stats_fn)(PPA_IFNAME *, PPA_NETIF_ACCEL_STATS *, uint32_t) = NULL;
+#endif
+
+#if defined(CONFIG_PPA_API_DIRECTCONNECT) && CONFIG_PPA_API_DIRECTCONNECT
+/**********************************************************************************************
+ * PPA interface hook function:ppa_check_if_netif_fastpath_fn
+ * It it used to check if network interface like, WAVE500, ACA is a fastpath interface
+ * input parameter PPA_NETIF *: pointer to stack network interface structure
+ * input parameter char *: interface name
+ * input parameter uint32_t: for future purpose
+ * return: 1: if ACA or WLAN fastpath interface
+ * 0: otherwise
+ **********************************************************************************************/
+int32_t (*ppa_check_if_netif_fastpath_fn)(PPA_NETIF *, char *, uint32_t) = NULL;
+
+/**********************************************************************************************
+ * PPA interface hook function:ppa_hook_disconn_if_fn
+ * It is used to delete one WAVE500 STA from PPA
+ * input parameter PPA_NETIF *: the linux interface name, like wlan0
+ * input parameter PPA_DP_SUBIF *: WAVE500 port id and subif id including station id
+ * input parameter uint8_t *: WAVE500 STA mac address
+ * input parameter uint32_t: for future purpose
+ * return: PPA_SUCCESS: delete sucessfully
+ * PPA_FAILURE: fail to delete
+ **********************************************************************************************/
+int32_t (*ppa_hook_disconn_if_fn)(PPA_NETIF *, PPA_DP_SUBIF *, uint8_t *, uint32_t) = NULL;
+
+#if defined(WMM_QOS_CONFIG) && WMM_QOS_CONFIG
+int32_t (*ppa_register_qos_class2prio_hook_fn)(int32_t, PPA_NETIF *, PPA_QOS_CLASS2PRIO_CB, uint32_t) = NULL;
+#endif
+#endif
+
+/**********************************************************************************************
+ * PPA Extra ethernet interface hook function :ppa_hook_addppa_hook_directpath_register_dev_fn_if_fn
+ * it is used to register/de-register a device for direct path support
+ * output parameter uint32_t *: return the virtual port id
+ * input parameter PPA_NETIF *: the linux interface name, like wlan0
+ * input parameter PPA_DIRECTPATH_CB *: mainly provide callback function, like start_tx_fn, stop_tx_fn, rx_fn
+ * input parameter uint32_t: PPA_F_DIRECTPATH_REGISTER for register, otherwise for de-register
+ * return: PPA_SUCCESS: register sucessfully
+ * others: fail to register
+ **********************************************************************************************/
+int32_t (*ppa_hook_directpath_register_dev_fn)(uint32_t *, PPA_NETIF *, PPA_DIRECTPATH_CB *, uint32_t) = NULL;
+
+/**********************************************************************************************
+ * PPA Extended ethernet interface hook function :ppa_hook_addppa_hook_directpath_register_dev_fn_if_fn
+ * it is used to register/de-register a device for direct path support
+ * output parameter PPA_SUBIF *: return the virtual port id and sub interface id
+ * input parameter PPA_NETIF *: the linux interface name, like wlan0
+ * input parameter PPA_DIRECTPATH_CB *: mainly provide callback function, like start_tx_fn, stop_tx_fn, rx_fn
+ * input parameter uint32_t: PPA_F_DIRECTPATH_REGISTER for register, otherwise for de-register
+ * return: PPA_SUCCESS: register sucessfully
+ * others: fail to register
+ **********************************************************************************************/
+int32_t (*ppa_hook_directpath_ex_register_dev_fn)(PPA_SUBIF *, PPA_NETIF *, PPA_DIRECTPATH_CB *, uint32_t) = NULL;
+
+/**********************************************************************************************
+ * PPA Extra ethernet interface hook function :ppa_hook_directlink_register_dev_fn, a wrap function of directpath registration for directlink
+ * it is used to register/de-register a device for directlink support
+ * output parameter int32_t *: return the virtual port id
+ * input parameter PPA_DTLK_T *: directlink information
+ * input parameter PPA_DIRECTPATH_CB *: mainly provide callback function, like start_tx_fn, stop_tx_fn, rx_fn
+ * input parameter uint32_t: PPA_F_DIRECTPATH_REGISTER for register, otherwise for de-register
+ * return: IFX_SUCCESS: register sucessfully
+ * others: fail to register
+ **********************************************************************************************/
+int32_t (*ppa_hook_directlink_register_dev_fn)(int32_t *, PPA_DTLK_T *, PPA_DIRECTPATH_CB *, uint32_t) = NULL;
+
+/**********************************************************************************************
+ * PPA Extra interface hook function :ppa_hook_directpath_send_fn
+ * it is used to send a packet to PPE FW when extra ethernet interface receive a packet
+ * input parameter uint32_t: the virtual port id
+ * input parameter PPA_SKBUF *: the packet to send
+ * input parameter int32_t *: the packet length
+ * input parameter uint32_t: for future purpose
+ * return: PPA_SUCCESS: send sucessfully
+ * others: fail to send
+ **********************************************************************************************/
+int32_t (*ppa_hook_directpath_send_fn)(uint32_t, PPA_SKBUF *, int32_t, uint32_t) = NULL;
+
+/**********************************************************************************************
+ * PPA Extra interface hook function :ppa_hook_directpath_ex_send_fn
+ * it is used to send a packet to PPE FW when extra ethernet interface receive a packet
+ * input parameter PPA_SUBIF: the virtual port id and sub interface id
+ * input parameter int32_t *: the packet length
+ * input parameter uint32_t: for future purpose
+ * return: PPA_SUCCESS: send sucessfully
+ * others: fail to send
+ **********************************************************************************************/
+int32_t (*ppa_hook_directpath_ex_send_fn)(PPA_SUBIF *, PPA_SKBUF *, int32_t, uint32_t) = NULL;
+
+/*Note, ppa_hook_directpath_enqueue_to_imq_fn will be set by imq module during initialization */
+int32_t (*ppa_hook_directpath_enqueue_to_imq_fn)(PPA_SKBUF *skb, uint32_t portID) = NULL;
+/*it will be called by imq module */
+int32_t (*ppa_hook_directpath_reinject_from_imq_fn)(int32_t rx_if_id, PPA_SKBUF *buf, int32_t len, uint32_t flags) = NULL;
+int32_t ppa_directpath_imq_en_flag;
+
+/**********************************************************************************************
+ * PPA Extra interface hook function :ppa_hook_directpath_rx_stop_fn
+ * it is used to stop forward packet to extra ethernet interface
+ * input parameter uint32_t: the virtual port id
+ * input parameter uint32_t: for future purpose
+ * return: PPA_SUCCESS: stop sucessfully
+ * others: fail to stop
+ **********************************************************************************************/
+int32_t (*ppa_hook_directpath_rx_stop_fn)(uint32_t, uint32_t) = NULL;
+
+/**********************************************************************************************
+ * PPA Extra interface hook function :ppa_hook_directpath_ex_rx_stop_fn
+ * it is used to stop forward packet to extra ethernet interface
+ * input parameter PPA_SUBIF: the virtual port id and sub interface id
+ * input parameter uint32_t: for future purpose
+ * return: PPA_SUCCESS: stop sucessfully
+ * others: fail to stop
+ **********************************************************************************************/
+int32_t (*ppa_hook_directpath_ex_rx_stop_fn)(PPA_SUBIF *, uint32_t) = NULL;
+
+/**********************************************************************************************
+ * PPA Extra interface hook function :ppa_hook_directpath_rx_restart_fn
+ * it is used to restart forwarding packet to extra ethernet interface
+ * input parameter uint32_t: the virtual port id
+ * input parameter uint32_t: for future purpose
+ * return: PPA_SUCCESS: restart forwarding sucessfully
+ * others: fail to restart forwarding
+ **********************************************************************************************/
+int32_t (*ppa_hook_directpath_rx_restart_fn)(uint32_t, uint32_t) = NULL;
+
+/**********************************************************************************************
+ * PPA Extra interface hook function :ppa_hook_directpath_ex_rx_restart_fn
+ * it is used to restart forwarding packet to extra ethernet interface
+ * input parameter PPA_SUBIF: the virtual port id and sub interface id
+ * input parameter uint32_t: for future purpose
+ * return: PPA_SUCCESS: restart forwarding sucessfully
+ * others: fail to restart forwarding
+ **********************************************************************************************/
+int32_t (*ppa_hook_directpath_ex_rx_restart_fn)(PPA_SUBIF *, uint32_t) = NULL;
+int32_t (*ppa_hook_directpath_recycle_skb_fn)(PPA_SUBIF*, PPA_SKBUF*, uint32_t) = NULL;
+PPA_SKBUF* (*ppa_hook_directpath_alloc_skb_fn)(PPA_SUBIF*, int32_t, uint32_t) = NULL;
+
+/**********************************************************************************************
+ * PPA Extra interface hook function :ppa_hook_get_ifid_for_netif_fn
+ * it is used to get one extran ethernet interface virtual port id according to its interface pointer
+ * input parameter uint32_t: network interface pointer
+ * return: virtual port id: if sucessully, otherwise return -1, ie, PPA_FAILURE
+ **********************************************************************************************/
+int32_t (*ppa_hook_get_ifid_for_netif_fn)(PPA_NETIF *) = NULL;
+
+/*#ifdef CONFIG_PPA_GRE*/
+uint32_t (*ppa_is_ipv4_gretap_fn)(struct net_device *dev) = NULL;
+uint32_t (*ppa_is_ipv6_gretap_fn)(struct net_device *dev) = NULL;
+EXPORT_SYMBOL(ppa_is_ipv4_gretap_fn);
+EXPORT_SYMBOL(ppa_is_ipv6_gretap_fn);
+/*#endif*/
+
+/*PPP related functions */
+/* ppp_generic.c will register function for getting ppp info once the ppp.ko is insmoded */
+int32_t (*ppa_ppp_get_chan_info_fn)(struct net_device *ppp_dev, struct ppp_channel **chan) = NULL;
+EXPORT_SYMBOL(ppa_ppp_get_chan_info_fn);
+
+int32_t (*ppa_check_pppoe_addr_valid_fn)(struct net_device *dev, struct pppoe_addr *pa) = NULL;
+EXPORT_SYMBOL(ppa_check_pppoe_addr_valid_fn);
+
+int32_t (*ppa_get_pppoa_info_fn)(struct net_device *dev, void *pvcc, uint32_t pppoa_id, void *value) = NULL;
+EXPORT_SYMBOL(ppa_get_pppoa_info_fn);
+
+int32_t (*ppa_get_pppol2tp_info_fn)(struct net_device *dev, void *po, uint32_t pppol2tp_id, void *value) = NULL;
+EXPORT_SYMBOL(ppa_get_pppol2tp_info_fn);
+
+int32_t (*ppa_if_is_ipoa_fn)(struct net_device *netdev, char *ifname) = NULL;
+EXPORT_SYMBOL(ppa_if_is_ipoa_fn);
+
+int32_t (*ppa_if_is_br2684_fn)(struct net_device *netdev, char *ifname) = NULL;
+EXPORT_SYMBOL(ppa_if_is_br2684_fn);
+
+int32_t (*ppa_br2684_get_vcc_fn)(struct net_device *netdev, struct atm_vcc **pvcc) = NULL;
+EXPORT_SYMBOL(ppa_br2684_get_vcc_fn);
+
+int32_t (*ppa_if_ops_veth_xmit_fn)(struct net_device *dev) = NULL;
+EXPORT_SYMBOL(ppa_if_ops_veth_xmit_fn);
+
+#ifdef CONFIG_PPA_QOS
+int32_t (*ppa_hook_get_qos_qnum)(uint32_t portid, uint32_t flag) = NULL;
+int32_t (*ppa_hook_get_qos_mib)(uint32_t portid, uint32_t queueid, PPA_QOS_MIB *mib, uint32_t flag) = NULL;
+/*#ifdef CONFIG_PPA_QOS_RATE_SHAPING*/
+int32_t (*ppa_hook_set_ctrl_qos_rate)(uint32_t portid, uint32_t enable, uint32_t flag) = NULL;
+int32_t (*ppa_hook_get_ctrl_qos_rate)(uint32_t portid, uint32_t *enable, uint32_t flag) = NULL;
+int32_t (*ppa_hook_set_qos_rate)(uint32_t portid, uint32_t queueid, uint32_t rate, uint32_t burst, uint32_t flag) = NULL;
+int32_t (*ppa_hook_get_qos_rate)(uint32_t portid, uint32_t queueid, uint32_t *rate, uint32_t *burst, uint32_t flag) = NULL;
+int32_t (*ppa_hook_reset_qos_rate)(uint32_t portid, uint32_t queueid, uint32_t flag) = NULL;
+/*#endif end of CONFIG_PPA_QOS_RATE_SHAPING*/
+
+/*#ifdef CONFIG_PPA_QOS_WFQ*/
+int32_t (*ppa_hook_set_ctrl_qos_wfq)(uint32_t portid, uint32_t enable, uint32_t flag) = NULL;
+int32_t (*ppa_hook_get_ctrl_qos_wfq)(uint32_t portid, uint32_t *enable, uint32_t flag) = NULL;
+int32_t (*ppa_hook_set_qos_wfq)(uint32_t portid, uint32_t queueid, uint32_t weight_level, uint32_t flag) = NULL;
+int32_t (*ppa_hook_get_qos_wfq)(uint32_t portid, uint32_t queueid, uint32_t *weight_level, uint32_t flag) = NULL;
+int32_t (*ppa_hook_reset_qos_wfq)(uint32_t portid, uint32_t queueid, uint32_t flag) = NULL;
+/*#endif end of CONFIG_PPA_QOS_WFQ*/
+
+#endif /*end of CONFIG_PPA_QOS*/
+
+int32_t (*qos_mgr_hook_setup_tc)(struct net_device *dev, u32 handle, __be16 protocol, struct tc_to_netdev *tc) = NULL;
+EXPORT_SYMBOL(qos_mgr_hook_setup_tc);
+
+#ifdef CONFIG_INTEL_IPQOS_MARK_SKBPRIO
+/*
+ * Function to mark priority based on specific criteria
+ */
+static inline
+int skb_mark_priority(struct sk_buff *skb)
+{
+	unsigned old_priority = skb->priority;
+	/*
+	 * IPQoS in UGW: added copy of nfmark set in classifier to skb->priority to be used in hardware queues.
+	 * nfmark range = 1-8 if QoS is enabled; priority range = 0-7; else preserve original priority
+	 */
+#ifdef CONFIG_NETWORK_EXTMARK
+	if (skb->extmark) {
+		unsigned value;
+		GET_DATA_FROM_MARK_OPT(skb->extmark, QUEPRIO_MASK, QUEPRIO_START_BIT_POS, value);
+		if (value)
+			skb->priority = value - 1;
+	}
+#endif /* CONFIG_NETWORK_EXTMARK*/
+
+	return old_priority;
+}
+
+#endif /* CONFIG_INTEL_IPQOS_MARK_SKBPRIO*/
+
+#if defined(CONFIG_PPA_API_SW_FASTPATH)
+/**************************************************************************************************
+ * PPA based software acceleration function hook
+ * gets called from netif_rx in dev.c
+ * bye pass the linux sw stack and routes the packet based on the ppa session entry
+ * input : sk_buff of incoming packet
+ * output: PPA_SUCCESS if the packet is accelerated
+ * 	 PPA_FAILURE if the packet is not accelerated
+ **************************************************************************************************/
+int32_t (*ppa_hook_sw_fastpath_send_fn)(struct sk_buff *skb) = NULL;
+int32_t (*ppa_hook_set_sw_fastpath_enable_fn)(uint32_t flags) = NULL;
+int32_t (*ppa_hook_get_sw_fastpath_status_fn)(uint32_t flags) = NULL;
+#endif
+
+int32_t (*ppa_hook_set_lan_seperate_flag_fn)(uint32_t flag) = NULL;
+uint32_t (*ppa_hook_get_lan_seperate_flag_fn)(uint32_t flag) = NULL;
+int32_t (*ppa_hook_set_wan_seperate_flag_fn)(uint32_t flag) = NULL;
+uint32_t (*ppa_hook_get_wan_seperate_flag_fn)(uint32_t flag) = NULL;
+
+#if defined(CONFIG_L2NAT_MODULE) || defined(CONFIG_L2NAT)
+/**********************************************************************************************
+ * PPA interface hook function:ppa_check_if_netif_l2nat_fn
+ * It it used to check if network interface is an l2nat interface
+ * input parameter PPA_NETIF *: pointer to stack network interface structure
+ * input parameter char *: interface name
+ * input parameter uint32_t: for future purpose
+ * return: 1: if network interafce is an l2nat interface
+ * 0: otherwise
+ **********************************************************************************************/
+int32_t (*ppa_check_if_netif_l2nat_fn)(PPA_NETIF *, char *, uint32_t) = NULL;
+#endif
+
+#if PPA_DP_DBG_PARAM_ENABLE
+/*Below varabiles are used for debugging only: force PPE driver to use kernel's boot parameter:
+  if ppa_drv_datapath_dbg_param_enable is enabled, then PPE driver will take parameter from kernel's boot paramter whether
+  PPE driver is static build in kernel or dynamic modules.
+
+  Note, only if ppa_drv_dp_dbg_param_enable is enabled and PPE driver is in loadable module, then this feature may be activated.
+  Otherwise, it will never be activated at all.
+
+  For other non-linux OS, just disabled this feature, ie, not enable macro PPA_DP_DBG_PARAM_ENABLE
+ */
+int ppa_drv_dp_dbg_param_enable;
+int ppa_drv_dp_dbg_param_ethwan;
+int ppa_drv_dp_dbg_param_wanitf = ~0;
+int ppa_drv_dp_dbg_param_ipv6_acc_en = 1;
+int ppa_drv_dp_dbg_param_wanqos_en = 8;
+
+static int __init ppa_drv_dp_dbg_param_enable_setup(char *line)
+{
+	if (strcmp(line, "1") == 0)
+		ppa_drv_dp_dbg_param_enable = 1;
+
+	return 0;
+}
+
+static int __init ppa_drv_dp_dbg_param_wan_mode_setup(char *line)
+{
+	if (strcmp(line, "1") == 0)
+		ppa_drv_dp_dbg_param_ethwan = 1;
+	else if (strcmp(line, "2") == 0)
+		ppa_drv_dp_dbg_param_ethwan = 2;
+
+	return 0;
+}
+
+static int __init ppa_drv_dp_dbg_param_wanitf_setup(char *line)
+{
+	ppa_drv_dp_dbg_param_wanitf = simple_strtoul(line, NULL, 0);
+
+	if (ppa_drv_dp_dbg_param_wanitf > 0xFF)
+		ppa_drv_dp_dbg_param_wanitf = ~0;
+
+	return 0;
+}
+
+static int __init ppa_drv_dp_dbg_param_ipv6_acc_en_setup(char *line)
+{
+	if (strcmp(line, "0") == 0)
+		ppa_drv_dp_dbg_param_ipv6_acc_en = 0;
+	else
+		ppa_drv_dp_dbg_param_ipv6_acc_en = 1;
+
+	return 0;
+}
+
+static int __init ppa_drv_dp_dbg_param_wanqos_en_setup(char *line)
+{
+	ppa_drv_dp_dbg_param_wanqos_en = simple_strtoul(line, NULL, 0);
+
+	if (ppa_drv_dp_dbg_param_wanqos_en > 8)
+		ppa_drv_dp_dbg_param_wanqos_en = 0;
+
+	return 0;
+}
+
+__setup("param_en=", ppa_drv_dp_dbg_param_enable_setup);
+__setup("ethwan=", ppa_drv_dp_dbg_param_wan_mode_setup);
+__setup("wanitf=", ppa_drv_dp_dbg_param_wanitf_setup);
+__setup("ipv6_acc_en=", ppa_drv_dp_dbg_param_ipv6_acc_en_setup);
+__setup("wanqos_en=", ppa_drv_dp_dbg_param_wanqos_en_setup);
+#endif /*end of PPA_DP_DBG_PARAM_ENABLE*/
+
+EXPORT_SYMBOL(ppa_drv_dp_dbg_param_enable);
+EXPORT_SYMBOL(ppa_drv_dp_dbg_param_ethwan);
+EXPORT_SYMBOL(ppa_drv_dp_dbg_param_wanitf);
+EXPORT_SYMBOL(ppa_drv_dp_dbg_param_ipv6_acc_en);
+EXPORT_SYMBOL(ppa_drv_dp_dbg_param_wanqos_en);
+/* End of debugging code */
+
+EXPORT_SYMBOL(ppa_hook_session_add_fn);
+EXPORT_SYMBOL(ppa_hook_get_ct_stats_fn);
+EXPORT_SYMBOL(ppa_hook_session_bradd_fn);
+EXPORT_SYMBOL(ppa_hook_session_del_fn);
+#if defined(CONFIG_PPA_MPE_IP97)
+EXPORT_SYMBOL(ppa_hook_session_ipsec_add_fn);
+EXPORT_SYMBOL(ppa_hook_session_ipsec_del_fn);
+#endif
+EXPORT_SYMBOL(ppa_hook_session_prio_fn);
+EXPORT_SYMBOL(ppa_hook_inactivity_status_fn);
+EXPORT_SYMBOL(ppa_hook_set_inactivity_fn);
+EXPORT_SYMBOL(ppa_hook_bridge_entry_add_fn);
+EXPORT_SYMBOL(ppa_hook_bridge_entry_delete_fn);
+EXPORT_SYMBOL(ppa_hook_bridge_entry_hit_time_fn);
+#if defined(PPA_IF_MIB) && PPA_IF_MIB
+EXPORT_SYMBOL(ppa_hook_get_netif_accel_stats_fn);
+#endif
+#if defined(CONFIG_PPA_API_DIRECTCONNECT) && CONFIG_PPA_API_DIRECTCONNECT
+EXPORT_SYMBOL(ppa_check_if_netif_fastpath_fn);
+EXPORT_SYMBOL(ppa_hook_disconn_if_fn);
+#if defined(WMM_QOS_CONFIG) && WMM_QOS_CONFIG
+EXPORT_SYMBOL(ppa_register_qos_class2prio_hook_fn);
+#endif
+#endif
+EXPORT_SYMBOL(ppa_hook_directpath_register_dev_fn);
+EXPORT_SYMBOL(ppa_hook_directpath_ex_register_dev_fn);
+EXPORT_SYMBOL(ppa_hook_directlink_register_dev_fn);
+EXPORT_SYMBOL(ppa_hook_directpath_send_fn);
+EXPORT_SYMBOL(ppa_hook_directpath_ex_send_fn);
+EXPORT_SYMBOL(ppa_hook_directpath_rx_stop_fn);
+EXPORT_SYMBOL(ppa_hook_directpath_ex_rx_stop_fn);
+EXPORT_SYMBOL(ppa_hook_directpath_rx_restart_fn);
+EXPORT_SYMBOL(ppa_hook_directpath_ex_rx_restart_fn);
+EXPORT_SYMBOL(ppa_hook_directpath_alloc_skb_fn);
+EXPORT_SYMBOL(ppa_hook_directpath_recycle_skb_fn);
+EXPORT_SYMBOL(ppa_hook_get_ifid_for_netif_fn);
+#ifdef CONFIG_PPA_QOS
+EXPORT_SYMBOL(ppa_hook_get_qos_qnum);
+EXPORT_SYMBOL(ppa_hook_get_qos_mib);
+
+/*#ifdef CONFIG_PPA_QOS_RATE_SHAPING*/
+EXPORT_SYMBOL(ppa_hook_set_ctrl_qos_rate);
+EXPORT_SYMBOL(ppa_hook_get_ctrl_qos_rate);
+EXPORT_SYMBOL(ppa_hook_set_qos_rate);
+EXPORT_SYMBOL(ppa_hook_get_qos_rate);
+EXPORT_SYMBOL(ppa_hook_reset_qos_rate);
+/*#endif CONFIG_PPA_QOS_RATE_SHAPING*/
+
+/*#ifdef CONFIG_PPA_QOS_WFQ*/
+EXPORT_SYMBOL(ppa_hook_set_ctrl_qos_wfq);
+EXPORT_SYMBOL(ppa_hook_get_ctrl_qos_wfq);
+EXPORT_SYMBOL(ppa_hook_set_qos_wfq);
+EXPORT_SYMBOL(ppa_hook_get_qos_wfq);
+EXPORT_SYMBOL(ppa_hook_reset_qos_wfq);
+/*#endif end of CONFIG_PPA_QOS_WFQ*/
+#endif /*end of CONFIG_PPA_QOS*/
+EXPORT_SYMBOL(ppa_hook_directpath_enqueue_to_imq_fn);
+EXPORT_SYMBOL(ppa_directpath_imq_en_flag);
+EXPORT_SYMBOL(ppa_hook_directpath_reinject_from_imq_fn);
+EXPORT_SYMBOL(ppa_hook_set_lan_seperate_flag_fn);
+EXPORT_SYMBOL(ppa_hook_get_lan_seperate_flag_fn);
+EXPORT_SYMBOL(ppa_hook_set_wan_seperate_flag_fn);
+EXPORT_SYMBOL(ppa_hook_get_wan_seperate_flag_fn);
+#if defined(CONFIG_PPA_API_SW_FASTPATH)
+EXPORT_SYMBOL(ppa_hook_set_sw_fastpath_enable_fn);
+EXPORT_SYMBOL(ppa_hook_get_sw_fastpath_status_fn);
+EXPORT_SYMBOL(ppa_hook_sw_fastpath_send_fn);
+#endif
+#if defined(CONFIG_L2NAT_MODULE) || defined(CONFIG_L2NAT)
+EXPORT_SYMBOL(ppa_check_if_netif_l2nat_fn);
+#endif
+
+/*/ Stack adaptation layer APIs that directly hooks with un exported kernel APIs needs to be in builtin /*/
+int sysctl_ip_default_ttl __read_mostly = IPDEFTTL;
+EXPORT_SYMBOL(sysctl_ip_default_ttl);
+
+int32_t ppa_is_pkt_local(PPA_BUF *ppa_buf)
+{
+	struct dst_entry *dst = ppa_dst(ppa_buf);
+
+	return dst != NULL && (uint32_t)(dst->input) == (uint32_t)ip_local_deliver ? 1 : 0;
+}
+EXPORT_SYMBOL(ppa_is_pkt_local);
+
+int32_t ppa_is_pkt_routing(PPA_BUF *ppa_buf)
+{
+	struct dst_entry *dst = ppa_dst(ppa_buf);
+#if IS_ENABLED(CONFIG_IPV6)
+	if (ppa_is_pkt_ipv6(ppa_buf)) {
+		return dst != NULL && (uint32_t)(dst->input) == (uint32_t)ip6_forward ? 1 : 0;
+	}
+#endif
+	return dst != NULL && (uint32_t)(dst->input) == (uint32_t)ip_forward ? 1 : 0;
+}
+EXPORT_SYMBOL(ppa_is_pkt_routing);
+
+int32_t ppa_is_pkt_mc_routing(PPA_BUF *ppa_buf)
+{
+	struct dst_entry *dst = ppa_dst(ppa_buf);
+#if IS_ENABLED(CONFIG_IPV6)
+	if (ppa_is_pkt_ipv6(ppa_buf)) {
+		return 0;/*dst != NULL && (uint32_t)(dst->input) == (uint32_t)ip6_mc_input ? 1 : 0;*/
+	}
+#endif
+	return dst != NULL && (uint32_t)(dst->output) == (uint32_t)ip_mc_output ? 1 : 0;
+}
+EXPORT_SYMBOL(ppa_is_pkt_mc_routing);
+
+int ppa_dev_is_br(PPA_NETIF *netif)
+{
+	if (netif->netdev_ops)
+		return (netif->netdev_ops->ndo_start_xmit == br_dev_xmit);
+
+	return 0;
+}
+EXPORT_SYMBOL(ppa_dev_is_br);
+
+struct net_bridge_fdb_entry *ppa_br_fdb_get(struct net_bridge *br,
+		const unsigned char *addr,
+		uint16_t vid)
+{
+	return __br_fdb_get(br, addr, vid);
+}
+EXPORT_SYMBOL(ppa_br_fdb_get);
+
+struct rtable *ppa_ip_route_output_key(struct net *net, struct flowi4 *flp)
+{
+	return ip_route_output_key(net, flp);
+}
+EXPORT_SYMBOL(ppa_ip_route_output_key);
+
+#if IS_ENABLED(CONFIG_IPV6)
+struct dst_entry *ppa_ip6_route_output(struct net *net,
+		const struct sock *sk,
+		struct flowi6 *fl6)
+{
+	return ip6_route_output(net, sk, fl6);
+}
+EXPORT_SYMBOL(ppa_ip6_route_output);
+#endif
+/* calculate teh hash for the conntrack 			 */
+/* copied from the nf_conntrack_core.c function hash_conntrack_raw*/
+/* needs to be updated if the original function is updated */
+
+static unsigned int ppa_nf_conntrack_hash_rnd;
+
+u32 ppa_hash_conntrack_raw(const struct nf_conntrack_tuple *tuple,
+		const struct net *net)
+{
+	unsigned int n;
+	u32 seed;
+
+	get_random_once(&ppa_nf_conntrack_hash_rnd, sizeof(ppa_nf_conntrack_hash_rnd));
+
+	/* The direction must be ignored, so we hash everything up to the
+	 * destination ports (which is a multiple of 4) and treat the last
+	 * three bytes manually.
+	 */
+	seed = ppa_nf_conntrack_hash_rnd ^ net_hash_mix(net);
+	n = (sizeof(tuple->src) + sizeof(tuple->dst.u3)) / sizeof(u32);
+	return jhash2((u32 *)tuple, n, seed ^
+			(((__force __u16)tuple->dst.u.all << 16) |
+			 tuple->dst.protonum));
+}
+EXPORT_SYMBOL_GPL(ppa_hash_conntrack_raw);
+
+#if defined(CONFIG_PPA_TCP_LITEPATH)
+int32_t ppa_sw_litepath_local_deliver(struct sk_buff *skb)
+{
+	int ret = 0;
+	const struct net_protocol *ipprot;
+	int protocol = ip_hdr(skb)->protocol;
+	struct net *net = dev_net(skb->dev);
+
+	rcu_read_lock();
+resubmit:
+	ipprot = rcu_dereference(inet_protos[protocol]);
+	if (ipprot != NULL) {
+		if (!ipprot->no_policy) {
+			if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
+				kfree_skb(skb);
+				printk("ppa_sw_litepath_local_deliver failed: %d\n", __LINE__);
+				goto out;
+			}
+			nf_reset(skb);
+		}
+		ret = ipprot->handler(skb);
+		if (ret < 0) {
+			protocol = -ret;
+			printk("ppa_sw_litepath_local_deliver failed: %d\n", __LINE__);
+			goto resubmit;
+		}
+		__IP_INC_STATS(net, IPSTATS_MIB_INDELIVERS);
+	} else {
+		__IP_INC_STATS(net, IPSTATS_MIB_INDELIVERS);
+		consume_skb(skb);
+	}
+out:
+	rcu_read_unlock();
+	return ret;
+}
+EXPORT_SYMBOL_GPL(ppa_sw_litepath_local_deliver);
+#endif
+
+/* session learning hooks */
+static unsigned int ppa_prert_hook_fn (void *priv,
+		struct sk_buff *skb,
+		const struct nf_hook_state *state)
+{
+	struct nf_conn *ct = NULL;
+	enum ip_conntrack_info ctinfo;
+
+	uint32_t flags;
+
+	if (ppa_hook_session_add_fn != NULL) {
+
+		ct = nf_ct_get(skb, &ctinfo);
+
+		if (ct) {
+			ct = nf_ct_is_confirmed(ct) ? ct : NULL;
+		}
+
+		flags = PPA_F_BEFORE_NAT_TRANSFORM;
+		flags |= CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL ? PPA_F_SESSION_ORG_DIR : PPA_F_SESSION_REPLY_DIR;
+
+		ppa_hook_session_add_fn(skb, ct, flags);
+	}
+
+	return NF_ACCEPT;
+}
+
+static unsigned int ppa_postrt_hook_fn(void *priv,
+		struct sk_buff *skb,
+		const struct nf_hook_state *state)
+{
+#if IS_ENABLED(CONFIG_PPA_MPE_IP97)
+	struct iphdr *hdr = ip_hdr(skb);
+	/* exclude the encrypted ipsec tunnel packets */
+	if (hdr->protocol != IPPROTO_ESP) {
+#endif /* CONFIG_PPA_MPE_IP97*/
+		if (!ppa_hook_session_add_fn)
+			return NF_ACCEPT;
+
+#if IS_ENABLED(CONFIG_INTEL_IPQOS_ACCEL_DISABLE)
+		/* check for 13th bit in NFMARK set by IPQOS classifier */
+		/* If this bit is set, dont call PPA session add fn*/
+		bool accel_st = 0;
+#if IS_ENABLED(CONFIG_NETWORK_EXTMARK)
+		GET_DATA_FROM_MARK_OPT(skb->extmark, ACCELSEL_MASK,
+				       ACCELSEL_START_BIT_POS, accel_st);
+#endif /* CONFIG_NETWORK_EXTMARK*/
+		if (accel_st != 0)
+			return NF_ACCEPT;
+#endif /* CONFIG_INTEL_IPQOS_ACCEL_DISABLE*/
+
+		struct nf_conn *ct = NULL;
+		enum ip_conntrack_info ctinfo;
+		uint32_t flags;
+
+		ct = nf_ct_get(skb, &ctinfo);
+
+		flags = 0; /* post routing */
+		flags |= CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL ?
+			 PPA_F_SESSION_ORG_DIR : PPA_F_SESSION_REPLY_DIR;
+
+		ppa_hook_session_add_fn(skb, ct, flags);
+#if IS_ENABLED(CONFIG_PPA_MPE_IP97)
+	}
+#endif /* CONFIG_PPA_MPE_IP97*/
+	return NF_ACCEPT;
+}
+
+static unsigned int ppa_localin_hook_fn(void *priv,
+		struct sk_buff *skb,
+		const struct nf_hook_state *state)
+{
+	struct nf_conn *ct = NULL;
+	enum ip_conntrack_info ctinfo;
+	uint32_t flags;
+
+	if (ppa_hook_session_add_fn != NULL) {
+
+		ct = nf_ct_get(skb, &ctinfo);
+		flags = PPA_F_SESSION_LOCAL_IN;
+		flags |= CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL ? PPA_F_SESSION_ORG_DIR : PPA_F_SESSION_REPLY_DIR;
+
+		ppa_hook_session_add_fn(skb, ct, flags);
+	}
+
+	return NF_ACCEPT;
+}
+static struct nf_hook_ops ipt_hook_ops[] __read_mostly = {
+	/* hook for pre-routing ipv4 packets */
+	{
+		.hook 		= ppa_prert_hook_fn,
+		.hooknum 	= 0, /*NF_IP_PRE_ROUTING*/
+		.pf		= PF_INET,
+		.priority	= NF_IP_PRI_CONNTRACK,
+	},
+	/* hook for pre-routing ipv6 packets */
+	{
+		.hook 		= ppa_prert_hook_fn,
+		.hooknum 	= 0, /*NF_IP_PRE_ROUTING*/
+		.pf		= PF_INET6,
+		.priority	= NF_IP6_PRI_CONNTRACK,
+	},
+	/* hook for post-routing ipv4 packets */
+	{
+		.hook 		= ppa_postrt_hook_fn,
+		.hooknum 	= 4, /*NF_IP_POST_ROUTING*/
+		.pf		= PF_INET,
+		.priority	= NF_IP_PRI_LAST,
+	},
+	/* hook for post-routing ipv6 packets */
+	{
+		.hook 		= ppa_postrt_hook_fn,
+		.hooknum 	= 4, /*NF_IP_POST_ROUTING*/
+		.pf		= PF_INET6,
+		.priority	= NF_IP6_PRI_LAST,
+	},
+	/* hook for local in ipv4 packets */
+	{
+		.hook 		= ppa_localin_hook_fn,
+		.hooknum 	= 1, /*NF_IP_LOCAL_IN*/
+		.pf		= PF_INET,
+		.priority	= NF_IP_PRI_LAST,
+	},
+	/* hook for post-routing ipv6 packets */
+	{
+		.hook 		= ppa_localin_hook_fn,
+		.hooknum 	= 1, /*NF_IP_LOCAL_IN*/
+		.pf		= PF_INET6,
+		.priority	= NF_IP6_PRI_LAST,
+	},
+	/* hook for local-out ipv4 packets */
+	{
+		.hook 		= ppa_prert_hook_fn,
+		.hooknum 	= 3, /*NF_IP_LOCAL_OUT*/
+		.pf		= PF_INET,
+		.priority	= NF_IP_PRI_LAST,
+	},
+	/* hook for local-out ipv6 packets */
+	{
+		.hook 		= ppa_prert_hook_fn,
+		.hooknum 	= 3, /*NF_IP_LOCAL_OUT*/
+		.pf		= PF_INET6,
+		.priority	= NF_IP6_PRI_LAST,
+	}
+};
+
+#if defined(CONFIG_INTEL_IPQOS)
+static unsigned int ppa_qos_postrt_hook_fn(void *priv,
+		struct sk_buff *skb,
+		const struct nf_hook_state *state)
+{
+#if defined(CONFIG_INTEL_IPQOS_MARK_SKBPRIO)
+	skb_mark_priority(skb);
+#endif
+	return NF_ACCEPT;
+}
+
+static struct nf_hook_ops qos_hook_ops[] __read_mostly = {
+	/* hook for post-routing ipv4 packets */
+	{
+		.hook		= ppa_qos_postrt_hook_fn,
+		.hooknum	= 4, /*NF_IP_POST_ROUTING*/
+		.pf		= PF_INET,
+		.priority	= NF_IP_PRI_LAST,
+	},
+	/* hook for post-routing ipv6 packets */
+	{
+		.hook		= ppa_qos_postrt_hook_fn,
+		.hooknum	= 4, /*NF_IP_POST_ROUTING*/
+		.pf		= PF_INET6,
+		.priority	= NF_IP6_PRI_LAST,
+	}
+};
+#endif /* CONFIG_INTEL_IPQOS*/
+
+#if defined(CONFIG_PPA_BR_SESS_LEARNING)
+static unsigned int ppa_br_prert_hook_fn (void *priv,
+		struct sk_buff *skb,
+		const struct nf_hook_state *state)
+{
+	if (ppa_hook_session_add_fn != NULL) {
+
+		ppa_hook_session_add_fn(skb,
+				NULL, PPA_F_BRIDGED_SESSION|PPA_F_BEFORE_NAT_TRANSFORM);
+	}
+	return NF_ACCEPT;
+}
+
+static unsigned int ppa_br_postrt_hook_fn(void *priv,
+		struct sk_buff *skb,
+		const struct nf_hook_state *state)
+{
+	if (ppa_hook_session_add_fn != NULL) {
+		//printk(KERN_INFO"br Post-routing hook \n");
+		ppa_hook_session_add_fn(skb,
+				NULL,
+				PPA_F_BRIDGED_SESSION);
+	}
+	return NF_ACCEPT;
+}
+
+static struct nf_hook_ops ebt_hook_ops[] __read_mostly = {
+	/* hook for bridge pre-routing packets */
+	{
+		.hook 		= ppa_br_prert_hook_fn,
+		.hooknum 	= 0, /*NF_IP_PRE_ROUTING*/
+		.pf		= NFPROTO_BRIDGE,
+		.priority	= NF_BR_PRI_NAT_DST_BRIDGED,
+	},
+	/* hook for bridge post-routing packets */
+	{
+		.hook 		= ppa_br_postrt_hook_fn,
+		.hooknum 	= 4, /*NF_IP_POST_ROUTING*/
+		.pf		= NFPROTO_BRIDGE,
+		.priority	= NF_BR_PRI_NAT_SRC,
+	}
+};
+
+#endif /* CONFIG_PPA_BR_SESS_LEARNING*/
+
+#if defined(CONFIG_INTEL_IPQOS)
+#if defined(CONFIG_VLAN_8021Q_COPY_TO_EXTMARK)
+static unsigned int ppa_qos_br_prert_hook_fn(void *priv,
+					     struct sk_buff *skb,
+					     const struct nf_hook_state *state)
+{
+	u16 vlan_id = skb_vlan_tag_get_id(skb);
+	u16 vlan_tci = skb->vlan_tci;
+	u32 vprio = (vlan_tci >> VLAN_PRIO_SHIFT);
+
+	SET_DATA_FROM_MARK_OPT(skb->extmark, VLANID_MASK,
+				VLANID_START_BIT_POS, vlan_id);
+	SET_DATA_FROM_MARK_OPT(skb->extmark, VPRIO_MASK,
+				VPRIO_START_BIT_POS, vprio);
+	return NF_ACCEPT;
+}
+#endif
+
+static unsigned int ppa_qos_br_postrt_hook_fn(void *priv,
+		struct sk_buff *skb,
+		const struct nf_hook_state *state)
+{
+#if defined(CONFIG_INTEL_IPQOS_MARK_SKBPRIO)
+	skb_mark_priority(skb);
+#endif
+	return NF_ACCEPT;
+}
+
+static struct nf_hook_ops qos_ebt_hook_ops[] __read_mostly = {
+#if defined(CONFIG_VLAN_8021Q_COPY_TO_EXTMARK)
+	/* hook for bridge pre-routing packets */
+	{
+		.hook           = ppa_qos_br_prert_hook_fn,
+		.hooknum        = NF_BR_PRE_ROUTING,
+		.pf             = NFPROTO_BRIDGE,
+		.priority       = NF_BR_PRI_NAT_DST_BRIDGED,
+	},
+#endif
+	/* hook for bridge post-routing packets */
+	{
+		.hook		= ppa_qos_br_postrt_hook_fn,
+		.hooknum	= 4, /*NF_BR_POST_ROUTING*/
+		.pf		= NFPROTO_BRIDGE,
+		.priority	= NF_BR_PRI_NAT_SRC,
+	}
+};
+#endif /* CONFIG_INTEL_IPQOS*/
+
+/*Refresh conntrack for this many jiffies and do accounting */
+/*This replictes the functionality of kernel api __nf_ct_refresh_acct*/
+void ppa_nf_ct_refresh_acct(struct nf_conn *ct,
+		enum ip_conntrack_info ctinfo,
+		unsigned long extra_jiffies,
+		unsigned long bytes,
+		unsigned int pkts)
+{
+	struct nf_conn_acct *acct = NULL;
+	unsigned long more_jiffies = 0;
+
+	if (!ct)
+		return;
+
+	/* Only update if this is not a fixed timeout */
+	if (test_bit(IPS_FIXED_TIMEOUT_BIT, &ct->status))
+		goto do_acct;
+
+	/* If not in hash table, timer will not be active yet */
+	if (nf_ct_is_confirmed(ct)) {
+		more_jiffies = nfct_time_stamp;
+
+		/*	printk(KERN_INFO" function %s ct->timeout =%lu extra_jiffies,=%lu\n", __FUNCTION__, ct->timeout, extra_jiffies+more_jiffies);*/
+		/* Update the timeout only if it is more than existing timeout value */
+		if (ct->timeout < (more_jiffies+extra_jiffies))
+			ct->timeout = (more_jiffies + 3*extra_jiffies); /* update with three times extra_jiffies*/
+	}
+
+do_acct:
+	acct = nf_conn_acct_find(ct);
+	if (acct) {
+		struct nf_conn_counter *counter = acct->counter;
+
+		atomic64_add(pkts, &counter[CTINFO2DIR(ctinfo)].packets);
+		atomic64_add(bytes, &counter[CTINFO2DIR(ctinfo)].bytes);
+	}
+}
+EXPORT_SYMBOL(ppa_nf_ct_refresh_acct);
+
+void (*orig_nfct_destroy)(struct nf_conntrack *) = NULL;
+
+void ppa_destroy_conntrack (struct nf_conntrack *nfct)
+{
+
+	struct nf_conn *ct = (struct nf_conn *)nfct;
+	if (ppa_hook_session_del_fn != NULL) {
+		ppa_hook_session_del_fn(ct, PPA_F_SESSION_ORG_DIR | PPA_F_SESSION_REPLY_DIR);
+	}
+
+	orig_nfct_destroy(nfct);
+}
+
+void ppa_register_delhook(void)
+{
+	orig_nfct_destroy = nf_ct_destroy;
+	RCU_INIT_POINTER(nf_ct_destroy, ppa_destroy_conntrack);
+}
+
+void ppa_unregister_delhook(void)
+{
+	RCU_INIT_POINTER(nf_ct_destroy, orig_nfct_destroy);
+	orig_nfct_destroy = NULL;
+}
+
+int ppa_api_register_hooks(void)
+{
+	int ret = 0;
+#if defined(CONFIG_INTEL_IPQOS)
+	/*qos ipt hooks*/
+	nf_register_hooks(qos_hook_ops, ARRAY_SIZE(qos_hook_ops));
+#endif /* CONFIG_INTEL_IPQOS*/
+
+	/*ipt hooks*/
+	nf_register_hooks(ipt_hook_ops, ARRAY_SIZE(ipt_hook_ops));
+
+#if defined(CONFIG_INTEL_IPQOS)
+	/*qos ebt hooks*/
+	nf_register_hooks(qos_ebt_hook_ops, ARRAY_SIZE(qos_ebt_hook_ops));
+#endif /* CONFIG_INTEL_IPQOS*/
+
+#if defined(CONFIG_PPA_BR_SESS_LEARNING)
+	/*ebt hooks*/
+	nf_register_hooks(ebt_hook_ops, ARRAY_SIZE(ebt_hook_ops));
+#endif
+	/*delete conntrack hook*/
+	ppa_register_delhook();
+
+	printk(KERN_INFO"Installed the ppa learning netfilter hooks\n");
+	return ret;
+}
+EXPORT_SYMBOL(ppa_api_register_hooks);
+
+void ppa_api_unregister_hooks(void)
+{
+	/*ipt hooks*/
+	nf_unregister_hooks(ipt_hook_ops, ARRAY_SIZE(ipt_hook_ops));
+
+#if defined(CONFIG_PPA_BR_SESS_LEARNING)
+	/*ebt hooks*/
+	nf_unregister_hooks(ebt_hook_ops, ARRAY_SIZE(ebt_hook_ops));
+#endif
+	/*delete conntrack hook*/
+	ppa_unregister_delhook();
+
+	printk(KERN_INFO"Uninstalled the ppa learning netfilter hooks\n");
+}
+EXPORT_SYMBOL(ppa_api_unregister_hooks);
+
diff --git a/include/net/ppa/ltq_mpe_hal.h b/include/net/ppa/ltq_mpe_hal.h
new file mode 100644
index 000000000000..d662bb4dc35f
--- /dev/null
+++ b/include/net/ppa/ltq_mpe_hal.h
@@ -0,0 +1,65 @@
+#ifndef __LTQ_MPE_HAL_H__20081119_1144__
+#define __LTQ_MPE_HAL_H__20081119_1144__
+/*******************************************************************************
+ **
+ ** FILE NAME    : ltq_mpe_hal.h
+ ** PROJECT      : PPA
+ ** MODULES      : PPA API (Routing/Bridging Acceleration APIs)
+ **
+ ** DATE         : 1 APRIL 2015
+ ** AUTHOR       : Purnendu Ghosh
+ ** DESCRIPTION  : MPE HAL API's to reserve memory and start feature
+ **                File
+ ** COPYRIGHT    : Copyright (c) 2017 Intel Corporation
+ ** Copyright (c) 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+ ** HISTORY
+ ** $Date        $Author         $Comment
+ ** 1 APRIL 2015  Purnendu Ghosh     Initiate Version
+ *******************************************************************************/
+/*! \file ltq_mpe_hal.h
+  \brief This file contains: MPE HAL API's to reserve memory and start feature.
+ */
+#include <net/ppa/ppa_api_common.h>
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+#include <net/datapath_api.h>
+#endif
+#define F_FEATURE_START		1
+#define F_FEATURE_STOP		0
+/*#define F_FEATURE_START	(1 << 25)*/
+/*#define F_FEATURE_STOP	(1 << 26)*/
+enum MPE_Feature_Type {
+	DL_TX_1 = 0,
+	DL_TX_2
+};
+struct device *mpe_hal_dl_get_dev(void);
+void mpe_hal_dl_enable_gic(int irq_no);
+int mpe_hal_dl_alloc_resource(
+		uint32_t memSize,
+		uint32_t *memAddr,
+		uint32_t flags);
+int mpe_hal_feature_start(
+		enum MPE_Feature_Type mpeFeature,
+		uint32_t port_id,
+		uint32_t *featureCfgBase,
+		uint32_t flags);
+#if defined(CONFIG_PPA_TMU_MIB_SUPPORT)
+struct mpe_hal_if_stats {
+	uint32_t txPkts; /* Transmitted packets Count */
+	uint32_t txBytes; /* Transmitted Bytes Count */
+	uint32_t dropPkts; /* Dropped packets count */
+	uint32_t dropBytes; /* Dropped packets bytes size count */
+	uint32_t rxPkts; /* Received packets Count - UNUSED FOR NOW */
+	uint32_t rxBytes; /* Received Bytes Count - UNUSED FOR NOW */
+};
+extern int32_t (*mpe_hal_get_netif_mib_hook_fn) (struct net_device *dev,
+		dp_subif_t *subif_id, struct mpe_hal_if_stats *mpe_mib,
+		uint32_t flag);
+extern int32_t (*mpe_hal_clear_if_mib_hook_fn) (struct net_device *dev,
+		dp_subif_t *subif_id, uint32_t flag);
+#endif
+extern int (*mpe_hal_feature_start_fn)(
+		enum MPE_Feature_Type mpeFeature,
+		uint32_t port_id,
+		uint32_t *featureCfgBase,
+		uint32_t flags);
+#endif  /*  ___MPE_HAL_H__20081119_1144__*/
diff --git a/include/net/ppa/ltq_tmu_hal_api.h b/include/net/ppa/ltq_tmu_hal_api.h
new file mode 100644
index 000000000000..8f45fa958ceb
--- /dev/null
+++ b/include/net/ppa/ltq_tmu_hal_api.h
@@ -0,0 +1,70 @@
+#ifndef __TMU_HAL_API_H__20081119_1007__
+#define __TMU_HAL_API_H__20160621_1007__
+/*******************************************************************************
+ **
+ ** FILE NAME    : tmu_hal_api.h
+ ** PROJECT      : PPA
+ ** MODULES      : PPA API (Routing/Bridging Acceleration APIs)
+ **
+ ** DATE         : 21 JUN 2016
+ ** AUTHOR       : Purnendu Ghosh
+ ** DESCRIPTION  : PPA Protocol Stack Hook for TMU HAL API Functions Header
+ **                File
+ ** COPYRIGHT    : Copyright (c) 2017 Intel Corporation
+ ** Copyright (c) 2016 Lantiq Beteiligungs-GmbH & Co. KG
+ ** HISTORY
+ ** $Date        $Author         $Comment
+ ** 21 JUN 2016  PURNENDU GHOSH  Initiate Version
+ *******************************************************************************/
+/*! \file tmu_hal_api.h
+  \brief This file contains: TMU HAL api.
+ */
+#include <net/ppa/ppa_api_common.h>
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+#include <net/datapath_api.h>
+#endif
+#if defined(CONFIG_PPA_TMU_MIB_SUPPORT)
+struct tmu_hal_qos_stats {
+	uint64_t enqPkts; /* Enqueued packets Count */
+	uint64_t enqBytes; /* Enqueued Bytes Count */
+	uint64_t deqPkts; /* Dequeued packets Count */
+	uint64_t deqBytes; /* Dequeued Bytes Count */
+	uint64_t dropPkts; /* Dropped Packets Count */
+	uint64_t dropBytes; /* Dropped Bytes Count - UNUSED for now */
+	uint32_t qOccPkts; /* Queue Occupancy Packets Count - Only at Queue level */
+};
+extern int32_t (*tmu_hal_get_csum_ol_mib_hook_fn)(
+		struct tmu_hal_qos_stats *csum_mib,
+		uint32_t flag);
+extern int32_t (*tmu_hal_clear_csum_ol_mib_hook_fn)(
+		uint32_t flag);
+extern int32_t(*tmu_hal_get_qos_mib_hook_fn)(
+		struct net_device *netdev,
+		dp_subif_t *subif_id,
+		int32_t queueid,
+		struct tmu_hal_qos_stats *qos_mib,
+		uint32_t flag);
+extern int32_t (*tmu_hal_clear_qos_mib_hook_fn)(
+		struct net_device *netdev,
+		dp_subif_t *subif_id,
+		int32_t queueid,
+		uint32_t flag);
+#endif
+extern int(*tmu_hal_set_checksum_queue_map_hook_fn)(
+               uint32_t pmac_port);
+
+int tmu_hal_setup_dp_ingress_connectivity(
+		struct net_device *netdev,
+		uint32_t pmac_port);
+int tmu_hal_setup_dp_egress_connectivity(
+		struct net_device *netdev,
+		uint32_t pmac_port);
+int tmu_hal_remove_dp_egress_connectivity(
+		struct net_device *netdev,
+		uint32_t pmac_port);
+int tmu_hal_remove_dp_ingress_connectivity(
+		struct net_device *netdev,
+		uint32_t pmac_port);
+int tmu_hal_set_checksum_queue_map( 
+		uint32_t pmac_port);
+#endif  /*  __TMU_HAL_API_H__20160621_1007__*/
diff --git a/include/net/ppa/ppa_api.h b/include/net/ppa/ppa_api.h
new file mode 100644
index 000000000000..4f6679f8c843
--- /dev/null
+++ b/include/net/ppa/ppa_api.h
@@ -0,0 +1,1127 @@
+#ifndef __PPA_API_H_
+#define __PPA_API_H
+/*******************************************************************************
+ **
+ ** FILE NAME: ppa_api.h
+ ** PROJECT: PPA
+ ** MODULES: PPA API (Routing/Bridging Acceleration APIs)
+ **
+ ** DATE: 31 OCT 2008
+ ** AUTHOR: Xu Liang
+ ** DESCRIPTION: PPA Protocol Stack Hook API Header File
+ ** COPYRIGHT: Copyright (c) 2017 Intel Corporation
+ ** Copyright (c) 2010 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+ ** HISTORY
+ ** $Date $Author			$Comment
+ ** 31 OCT 2008 Xu Liang		Initiate Version
+ ** 10 DEC 2012 Manamohan Shetty	Added the support for RTP,MIB mode and CAPWAP
+ ** 08 APR 2014 Kamal Eradath		GRX500 Adaptations
+ ** 18 AUG 2017 Kamal Eradath		Splitting to UAPI
+ *******************************************************************************/
+/*! \file ppa_api.h
+  \brief This file contains es.
+  provide PPA API.
+ */
+/** \defgroup PPA_API PPA Kernel Hook and Userspace Function API
+  \brief PPA is a loadable network module. Hence, it exports its API though function pointer hooks. Callers need to check that hooks are non-NULL before invoking them. The hooks are initialized when the PPA is initialized. Certain API which are control / configuration related are also exposed to user space applications through the ioctl API. The PPA Kernel and Userspace API are discussed in the following sections:
+ */
+/* @{*/
+/** \defgroup PPA_IOCTL PPA Userspace API
+  \brief The subset of PPA API which is exposed to userspace for control and configuration of the PPA is invoked through
+  an ioctls()/system call interface as described in this section.
+  The API is defined in the following two source files:
+  - ppa_api.h: Header file for PPA API
+  - ppa_api.c: C Implementation file for PPA API
+ */
+/** \defgroup PPA_HOOK_API PPA Hook API
+  \brief PPA is a loadable network module. Hence, it exports its API though function pointer hooks. Callers need to check that hooks are non-NULL before invoking them. The hooks are initialized when the PPA is initialized.
+  - ppa_hook.h: Header file for PPA API
+  - ppa_hook.c: C Implementation file for PPA API
+ */
+/** \defgroup PPA_PWM_API PPA Power Management API
+  \brief PPA Power Management API provide PPA Power Management and IOCTL API
+  The API is defined in the following two source files
+  - ppa_api_pwm.h: Header file for PPA API
+  - ppa_api_pwm.c: C Implementation file for PPA Power management API
+  - ppa_api_pwm_logic.c: C impelementation file for Powr management Logic and interface with PPE driver
+ */
+/** \defgroup PPA_API_DIRECTPATH PPA Direct Path API
+  \brief This section describes the PPA DirectPath API that allows a driver on a CPU to bypass the protocol stack and send and receive packets directly from the PPA acceleration function. For a 2-CPU system, this API is used to communicate with devices whose drivers are running on the 2nd CPU (or Core 1) - usually Core 1 is not running any protocol stack, and all protocol stack intelligence is on Core 0. This API is not yet implemented for PPE D4 or A4 firmware. It is provided as advance information on the DirectPath interfaces.The PPA DirectPath aims to accelerate packet processing by reducing CPU load when the protocol stack processes the packet. It allows a CPU-bound driver to directly talk to the PPA and to the PPE engine bypassing the stack path and providing a short-cut.
+  - ppa_api_directpath.h: Header file for PPA API
+  - ppa_api_directpath.c: C Implementation file for PPA API
+ */
+/** \defgroup PPA_ADAPTATION_LAYER PPA Stack Adaptation API
+  \brief PPA module aims for OS and Protocol stack independence, and the
+  core PPA logic does not access any OS or Protocol stack implementation
+  specific structures directly. The PPA Protocol Stack Adaptation layer
+  provides API that allows for straight-forward and structured OS / protocol
+  stack porting of the PPA just by porting the Adaptation Layer (AL) API.
+  The AL API is defined in the following two source files
+  - ppa_stack_al.h: Header file for AL layer
+  - ppa_stack_al.c: C Implementation file for AL API
+ */
+/* @}*/
+#ifdef __KERNEL__
+#include <net/ppa/ppa_api_common.h>
+#include <net/ppa/ppa_stack_al.h>
+#include <net/ppa/ppa_api_directpath.h>
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+#include <net/switch_api/gsw_types.h>
+#include <net/switch_api/lantiq_gsw_flow.h>
+#endif
+#endif
+#include <uapi/net/ppa_api.h>
+#include<stdbool.h>
+/*
+ * ####################################
+ * Definition
+ * ####################################
+ */
+#if defined(WMM_QOS_CONFIG) && WMM_QOS_CONFIG
+#define WMM_QOS_DEV_F_REG			0x00000001
+#define WMM_QOS_DEV_F_DREG			0x00000002
+#endif/* WMM_QOS_CONFIG */
+#ifdef NO_DOXY
+#define VLAN_ID_SPLIT(full_id, pri, cfi, vid)  do { pri = ((full_id) >> 13) & 7; cfi = ((full_id) >> 12) & 1; vid = (full_id) & 0xFFF } while (0)
+#define VLAN_ID_CONBINE(full_id, pri, cfi, vid) full_id  = (((uint16_t)(pri) & 7) << 13) | (((uint16_t)(cfi) & 1) << 12) | ((uint16_t) (vid) & 0xFFF)
+#define PPA_JIFFY_MILLSEC(x, hz) (x * 1000 / (hz))
+#define WRAPROUND_32BITS ((uint64_t)0xFFFFFFFF)
+#define WRAPROUND_64BITS ((uint64_t)0xFFFFFFFFFFFFFFFF)
+#if !(defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500)
+#define WRAPROUND_SESSION_MIB ((uint64_t)0x1FFFFFE0) /*note, 0xFFFFFF * 0x20. In PPE FW, 1 means 32 bytes, ie 0x20 this value will be different with GRX500 platform */
+#else
+#define WRAPROUND_SESSION_MIB WRAPROUND_32BITS
+#endif
+#if defined(WMM_QOS_CONFIG) && WMM_QOS_CONFIG
+typedef int (*PPA_QOS_CLASS2PRIO_CB)(int32_t , PPA_NETIF *, uint8_t *);
+#endif
+#if defined(CONFIG_PPA_MPE_IP97)
+struct ipsec_tunnel_intf {
+	PPA_IPADDR src_ip;
+	PPA_NETIF *tx_if;
+};
+typedef enum {
+	OUTBOUND = 0,
+	INBOUND
+} sa_direction;
+typedef struct {
+	int tunnel_id;
+	uint32_t tx_pkt_count;
+	uint32_t tx_byte_count;
+	uint32_t rx_pkt_count;
+	uint32_t rx_byte_count;
+} IPSEC_TUNNEL_MIB_INFO;
+#endif
+#if defined(CONFIG_PPA_HAL_SELECTOR)
+typedef enum {
+	PPE_HAL = 0,
+	PAE_HAL,
+	MPE_HAL,
+	TMU_HAL,
+	LRO_HAL,
+	DSL_HAL,
+	SWAC_HAL,
+	PUMA_HAL,
+	MAX_HAL
+} PPA_HAL_ID;
+typedef enum {
+	SESS_BRIDG = 1,
+	SESS_IPV4,
+	SESS_IPV6,
+	SESS_MC_DS,
+	SESS_MC_DS_VAP,
+	TUNNEL_6RD,
+	TUNNEL_DSLITE,
+	TUNNEL_L2TP_US,
+	TUNNEL_L2TP_DS,
+	TUNNEL_CAPWAP_US,
+	TUNNEL_CAPWAP_DS,
+	TUNNEL_ENCRYPT,
+	TUNNEL_DECRYPT,
+	TUNNEL_GRE_US,
+	TUNNEL_GRE_DS,
+	TUNNEL_IPSEC_US,
+	TUNNEL_IPSEC_DS,
+	TUNNEL_IPSEC_MIB,
+	QOS_INIT,
+	QOS_UNINIT,
+	QOS_CLASSIFY,
+	QOS_QUEUE,
+	QOS_INGGRP,
+	Q_SCH_WFQ,
+	Q_SCH_SP,
+	Q_DROP_DT,
+	Q_DROP_RED,
+	Q_DROP_WRED,
+	Q_SHAPER,
+	PORT_SHAPER,
+	QOS_LAN_CLASSIFY,
+	QOS_LAN_QUEUE,
+	QOS_WMM_INIT,
+	QOS_WMM_UNINIT,
+	XDSL_PHY,
+	SESS_NAT_LOOPBACK,
+	MAX_CAPS
+} PPA_API_CAPS;
+#define MAX_TUNNEL_ENTRIES 16
+#define FLAG_SESSION_HI_PRIO 0x0001
+#define FLAG_SESSION_SWAPPED 0x0002
+#define FLAG_SESSION_LOCK_FAIL 0x0004
+/* tunnel table datastructures*/
+#endif /*defined(CONFIG_PPA_HAL_SELECTOR)*/
+/* PPA default values */
+#define PPA_IPV4_HDR_LEN 20
+#define PPA_IPV6_HDR_LEN 40
+#define PPA_VLAN_PROTO_8021Q 0x8100
+#define PPA_VLAN_PROTO_8021AD 0x88A8
+#endif /*NO_DOXY*/
+/*
+ * ####################################
+ * Data Type
+ * ####################################
+ */
+/* -------------------------------------------------------------------------- */
+/* Structure and Enumeration Type Defintions */
+/* -------------------------------------------------------------------------- */
+/** \addtogroup PPA_HOOK_API */
+/*@{*/
+/*!
+  \brief ppa_ct_counter holds the connection statistics.
+ */
+typedef struct {
+	uint32_t txPackets; /*!< Tx Packets - Packets from LAN to WAN. Currently not available */
+	uint64_t txBytes; /*!< Tx bytes - Bytes from LAN to WAN */
+	uint32_t rxPackets; /*!< Rx Packets - Packets from WAN to LAN. Currently not available */
+	uint64_t rxBytes; /*!< Rx Bytes - Bytes from WAN to LAN */
+	uint32_t lastHitTime; /*!< Last hit time in secs. It is approximate
+							time in seconds when a packet is seen on this
+							connection. Note that seconds calculation is
+							based on jiffies */
+} PPA_CT_COUNTER;
+/*!
+  \brief This is the data structure for PPA Interface Info specification.
+ */
+typedef struct {
+	PPA_IFNAME *ifname; /*!< Name of the stack interface */
+	uint32_t if_flags; /*!< Flags for Interface. Valid values are below: PPA_F_LAN_IF and PPA_F_WAN_IF */
+	uint32_t port; /*!< physical port id for this Interface. Valid values are below: 0 ~ */
+	uint32_t force_wanitf_flag; /*!< force_wanitf_flag is used for force change PPE FW's LAN/WAN interface */
+	PPA_IFNAME *ifname_lower; /*!< Name of the manually configured its lower interface */
+	uint8_t hw_disable; /*!< If this flag is set then only HW acceleration would be disabled for ifname (SW acceleration would still work for ifname) */
+} PPA_IFINFO;
+/*!
+  \brief This is the data structure for PPA Initialization kernel hook function
+ */
+typedef struct {
+	PPA_VERIFY_CHECKS lan_rx_checks; /*!< LAN Ingress packet checks */
+	PPA_VERIFY_CHECKS wan_rx_checks; /*!< WAN Ingress packet checks */
+	uint32_t num_lanifs; /*!< Number of LAN side interfaces */
+	PPA_IFINFO *p_lanifs; /*!< Pointer to array of LAN Interfaces. */
+	uint32_t num_wanifs; /*!< Number of WAN side interfaces */
+	PPA_IFINFO *p_wanifs; /*!< Pointer to array of WAN Interfaces. */
+	uint32_t max_lan_source_entries; /*!< Maximum Number of session entries with LAN source */
+	uint32_t max_wan_source_entries; /*!< Maximum Number of session entries with WAN source */
+	uint32_t max_mc_entries; /*!< Maximum Number of multicast sessions */
+	uint32_t max_bridging_entries; /*!< Maximum Number of bridging entries */
+	uint32_t add_requires_min_hits; /*!< Minimum number of calls to ppa_add_session() before session would be added in h/w - calls from the same hook position in stack. Currently, set to 1 */
+#if defined(CONFIG_PPA_HANDLE_CONNTRACK_SESSIONS)
+	uint32_t	add_requires_lan_collisions;/*!< Minimum number of LAN collision entries to be reserved in h/w*/
+	uint32_t	add_requires_wan_collisions;/*!< Minimum number of WAN collision entries to be reserved in h/w*/
+#endif
+} PPA_INIT_INFO;
+/*!
+  \brief This is the data structure which specifies an interface and its TTL value as applicable for multicast routing.
+ */
+typedef struct {
+	PPA_IFNAME *ifname; /*!< Pointer to interface name. */
+	uint8_t ttl; /*!< Time to Live (TTL) value of interface which is used for multicast routing to decide if a packet can be routed onto that interface
+				   Note, it is not used at present.
+				  */
+} IF_TTL_ENTRY;
+/*!
+  \brief This is the data structure for PPA Multicast Group membership. It specifies the interfaces which are members of
+  the specified IP Multicast Group address. Please see the discussion on outer and inner VLAN tags in the
+  section on PPA_SESSION_EXTRA data structure.
+ */
+typedef struct {
+	IP_ADDR_C ip_mc_group; /*!< Multicast IP address group */
+	int8_t num_ifs; /*!< Number of Interfaces which are member of this Multicast IP group address */
+	IF_TTL_ENTRY array_mem_ifs[PPA_MAX_MC_IFS_NUM]; /*!< Array of interface elements of maximum PPA_MAX_MC_IFS_NUM elements.
+													  Actual number of entries is specified by num_ifs */
+	uint8_t if_mask; /*!< Mask of Interfaces corresponding to num_ifs interfaces specified in array_mem_ifs. For internaly use only. */
+	PPA_IFNAME *src_ifname; /*!< the source interface of specified multicast IP address group */
+	uint32_t vlan_insert:1; /*!< If inner VLAN tag should be inserted into the frame at egress. Valid values are: PPA_ENABLED and PPA_DISABLED */
+	uint32_t vlan_remove:1; /*!< If inner VLAN untagging should be performed on the received frame. Untagging, if enabled, is
+							  carried out before any VLAN tag insert. Valid values are:PPA_ENABLED and PPA_DISABLED */
+	uint32_t out_vlan_insert:1; /*!< If outer VLAN tag should be inserted into the frame at egress. Valid values are: PPA_ENABLED and PPA_DISABLED */
+	uint32_t out_vlan_remove:1; /*!< If outer VLAN untagging should be performed on the received frame. Untagging, if enabled, is
+								  carried out before any VLAN tag insert. Valid values are:PPA_ENABLED and PPA_DISABLED */
+	uint32_t dslwan_qid_remark:1; /*!< not use at present */
+	uint32_t reserved1:3; /*!< valid in A4/A5 */
+	uint32_t vlan_prio:3; /*!< 802.1p VLAN priority configuration. Valid values are 0-7. */
+	uint32_t vlan_cfi:1; /*!< Always set to 1 for Ethernet frames */
+	uint32_t vlan_id:12; /*!< VLAN Id to be used to tag the frame. Valid values are 0-4095 */
+	uint32_t out_vlan_tag; /*!< Outer VLAN tag value including VLAN Id. */
+	uint32_t new_dscp_en:1; /*!< If new dscp value should be set. Valid values are:PPA_ENABLED and PPA_DISABLED */
+	uint32_t res:15; /*!< reserved */
+	uint32_t new_dscp:16; /*!< New DSCP code point value for the session.Valid values are 0-63. */
+	uint16_t dslwan_qid; /*!< not use at present */
+	uint32_t bridging_flag; /*!< 0 - routing mode/igmp proxy, 1 - bridge mode/igmp snooping. */
+	uint8_t mac[PPA_ETH_ALEN]; /*!< reserved for future */
+	uint8_t SSM_flag; /*!< Set the flag if source specific forwarding is required default 0*/
+	IP_ADDR_C source_ip; /*!< source ip address */
+#if defined(RTP_SAMPLING_ENABLE) && RTP_SAMPLING_ENABLE
+	uint8_t RTP_flag; /*!< rtp flag */
+#endif
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+	uint16_t	 group_id;		 /*!< Multicast group identifier allocated by the multicast daemon */
+	uint8_t src_mac[PPA_ETH_ALEN]; /*!< source mac address for grx5xx. */
+#endif
+} PPA_MC_GROUP;
+/*!
+  \brief This data structure is an abstraction for unicast and multicast routing sessions.
+  Pointer to any kind of PPA session
+ */
+typedef void PPA_U_SESSION;
+/*!
+  \brief This is the data structure for standard packet and byte statistics for an interface.
+ */
+typedef struct {
+	uint32_t    tx_pkts;            /*!<   Number of transmitted packets through the interface */
+	uint32_t    rx_pkts;            /*!<   Number of received packets through the interface */
+	uint32_t    tx_discard_pkts;    /*!<   Number of packets discarded while transmitting through the interface. */
+	uint32_t    tx_error_pkts;      /*!<   Number of transmit errors through the interface. */
+	uint32_t    rx_discard_pkts;    /*!<   Number of received packets through the interface that were discarded */
+	uint32_t    rx_error_pkts;      /*!<   Number of received errors through the interface. */
+	uint32_t    tx_bytes;           /*!<   Number of transmit bytes through the interface */
+	uint32_t    rx_bytes;           /*!<   Number of received bytes through the interface */
+
+#if defined(CONFIG_PPA_HAL_SELECTOR)
+        uint32_t    rx_pkts_prev[MAX_HAL];     
+        uint32_t    tx_pkts_prev[MAX_HAL];    
+#endif
+
+} PPA_IF_STATS;
+/*!
+  \brief This is the data structure for PPA accelerated statistics for an interface. Depending on the platform and
+  acceleration capabilities, some of the statistics may not be available.
+ */
+typedef struct {
+	uint32_t fast_routed_tcp_pkts; /*!< Fastpath routed TCP unicast packets Tx */
+	uint32_t fast_routed_udp_pkts; /*!< Fastpath routed UDP unicast packets Tx */
+	uint32_t fast_routed_udp_mcast_pkts; /*!< Fastpath routed UDP multicast packets Tx */
+	uint32_t fast_drop_pkts; /*!< Fastpath ingress pkts dropped */
+	uint32_t fast_drop_bytes; /*!< Fastpath ingress bytes dropped */
+	uint32_t fast_ingress_cpu_pkts; /*!< Fastpath ingress CPU pkts */
+	uint32_t fast_ingress_cpu_bytes; /*!< Fastpath ingress CPU bytes */
+	uint32_t rx_pkt_errors; /*!< Fastpath packet error */
+	uint32_t fast_bridged_ucast_pkts; /*!< Fastpath bridged unicast pkts */
+	uint32_t fast_bridged_mcast_pkts; /*!< Fastpath bridged multicast pkts */
+	uint32_t fast_bridged_bcast_pkts; /*!< Fastpath bridged broadcast pkts */
+	uint32_t fast_bridged_bytes; /*!< Fastpath bridged bytes */
+} PPA_ACCEL_STATS;
+/*!
+  \brief Union of PPA VLAN filter criteria.
+ */
+typedef union {
+	PPA_IFNAME *ifname; /*!< Pointer to interface name on which VLAN filter match is to be performed. */
+	IPADDR ip_src; /*!< IP source address of ingress frame for VLAN filter matching. */
+	uint32_t eth_protocol; /*!< Ethernet protocol as a match filter for VLAN filter matching */
+	uint32_t ingress_vlan_tag; /*!< Ingress frame VLAN tag as match criteria for VLAN filter matching */
+} match_criteria_vlan;
+/*!
+  \brief This data structure specifies the filter or match criteria for applying VLAN transforms based on rules. It is currently supported only for bridging paths.
+ */
+typedef struct {
+	match_criteria_vlan match_field; /*!< Union of VLAN filter criteria */
+	uint32_t match_flags; /*!< Indicates which VLAN filter criteria is specified in this VLAN match entry.
+							Valid values are one of the following: \n
+							PPA_F_VLAN_FILTER_IFNAME \n
+							PPA_F_VLAN_FILTER_IP_SRC \n
+							PPA_F_VLAN_FILTER_ETH_PROTO \n
+							PPA_F_VLAN_FILTER_VLAN_TAG \n
+						   */
+} PPA_VLAN_MATCH_FIELD;
+/*!
+  \brief This is the data structure for PPA VLAN configuration ioctl() on a per interface basis from userspace. It is currently
+  supported only for bridging paths.
+ */
+typedef struct {
+	uint16_t vlan_vci; /*!< VLAN Information including VLAN Id, 802.1p and CFI bits. */
+	uint16_t qid; /*!< queue index */
+	uint32_t out_vlan_id; /*!< out vlan id */
+	uint32_t inner_vlan_tag_ctrl;/*!< none(0)/remove(1)/insert(2)/replac(3), for vlan tag based only. */
+	uint32_t out_vlan_tag_ctrl; /*!< none(0)/remove(1)/insert(2)/replac(3), for vlan tag based only. */
+	uint16_t num_ifs; /*!< Number of interfaces in the array of PPA_IFINFO structures. */
+	PPA_IFINFO *vlan_if_membership; /*!< Pointer to array of interface info structures for each interface which is a member of this VLAN group. The number of entries is given by num_ifs. */
+} PPA_VLAN_INFO;
+/*!
+  \brief This is the data structure for PPA VLAN filter configuration. It is currently supported only for bridging paths
+ */
+typedef struct {
+	PPA_VLAN_MATCH_FIELD match_field; /*!< VLAN Match field information */
+	PPA_VLAN_INFO vlan_info; /*!< VLAN Group and Membership Info */
+} PPA_VLAN_FILTER_CONFIG;
+#if defined(CONFIG_LTQ_PMCU) || defined(CONFIG_LTQ_PMCU_MODULE)
+/*!
+  \brief Union of ppa power transitin watermark.
+ */
+union watermark {
+	uint32_t ppa_pwm_wm1; /*!< Watermark value for PPE transition between D0 and D1 */
+	uint32_t ppa_pwm_wm2; /*!< Watermark value for PPE transition between D1 and D2 */
+	uint32_t ppa_pwm_wm3; /*!< Watermark value for PPE transition between D2 and D3 */
+};
+/*!
+  \brief This is the data structure definition for PPA PWM states water mark
+ */
+typedef struct {
+	int16_t flag; /*!< flag indicating if watermark type. flag = 1: watermark is packet count; flag = 2: watermark is byte count */
+	int32_t time_interval; /*!< time interval of watermarks in milliseconds. */
+	union watermark WM; /*!< Watermark value for PPE transition */
+} WM_t;
+/*!
+  \brief This is the data structure for PPA Power management basic watermark configuration
+ */
+typedef struct {
+	WM_t ppa_pwm_wm1; /*!< Watermark value for PPE transition between D0 and D1 */
+	WM_t ppa_pwm_wm2; /*!< Watermark value for PPE transition between D1 and D2*/
+	WM_t ppa_pwm_wm3; /*!< Watermark value for PPE transition between D2 and D3*/
+} PPA_PWM_WM_t;
+/*!
+  \brief This is the data structure for PPA Power management configuration
+ */
+typedef struct {
+	uint8_t ppa_pwm; /*!< PPA power management mode: 0/1-OFF/ON */
+	PPA_PWM_WM_t ppa_pwm_wm_up; /*!< Watermark value for PPE transition for various states. */
+	PPA_PWM_WM_t ppa_pwm_wm_down; /*!< Watermark value for PPE transition for various states. */
+	PPA_PWM_STATE_t e_ppa_pwm_init_state; /*!< Initial power/performance state for PPE */
+	uint32_t flag; /*!< reserved.*/
+} PPA_PWM_CONFIG_t;
+#endif /*end of CONFIG_LTQ_PMCU*/
+/*!
+  \brief This is the data structure for PPA hooks list
+ */
+typedef struct PPA_HOOK_INFO_LIST {
+	PPA_HOOK_INFO info; /*!< ppa hook info */
+	struct PPA_HOOK_INFO_LIST *next; /*!< point to next ppa hook info */
+} PPA_HOOK_INFO_LIST;
+/*!
+  \brief This is the data structure for changing to FPI address
+ */
+typedef struct{
+	uint32_t addr_orig; /*!< original address */
+	uint32_t addr_fpi; /*!< converted FPI address */
+	uint32_t flags; /*!< reserved for future */
+} PPA_FPI_ADDR;
+#if defined(PPA_IF_MIB) && PPA_IF_MIB
+/*!
+  \brief This is the data structure for PPA accelerated statistics for an interface. Depending on the platform and
+  acceleration capabilities, some of the statistics may not be available.
+ */
+typedef struct {
+	PPA_PORT_MIB_INFO port_mib_stats;
+	PPA_IF_STATS hw_accel_stats;
+	PPA_IF_STATS sw_accel_stats;
+} PPA_NETIF_ACCEL_STATS;
+#endif
+#if defined(L2TP_CONFIG) && L2TP_CONFIG
+/*!
+  \brief This is the data structure for L2TP INFO
+ */
+typedef struct {
+	uint32_t source_ip;
+	uint32_t dest_ip;
+	uint16_t tunnel_id;
+	uint16_t session_id;
+	uint32_t tunnel_idx;
+	uint32_t tunnel_type;
+	uint16_t ip_chksum;
+	uint16_t udp_chksum;
+} PPA_L2TP_INFO;
+#endif
+#ifdef NO_DOXY
+typedef struct {
+	uint32_t mtu_ix;
+	uint32_t mtu; /* for add/del/get mtu entry only*/
+} PPE_MTU_INFO;
+typedef struct {
+	uint32_t pppoe_ix;
+	uint32_t pppoe_session_id; /* for add/del/get a pppoe entry only*/
+} PPE_PPPOE_INFO;
+#if defined(L2TP_CONFIG) && L2TP_CONFIG
+typedef struct {
+	uint32_t pppol2tp_ix;
+	uint32_t pppol2tp_session_id; /* for add/del/get a pppoe entry only*/
+	uint32_t pppol2tp_tunnel_id;
+} PPE_PPPOL2TP_INFO;
+#endif
+typedef struct {
+	uint32_t mac_ix;
+	uint8_t mac[PPA_ETH_ALEN]; /* for add/del/get a MAC entry only*/
+} PPE_ROUTE_MAC_INFO;
+typedef struct {
+	uint32_t vlan_id; /*out vlanid or ctag_vlan_id*/
+	uint32_t vlan_entry;
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+	uint16_t port_id;
+	uint16_t subif_id;
+	uint16_t vlan_type;
+	uint8_t ctag_rem;
+	uint8_t ctag_ins;
+	uint8_t stag_rem;
+	uint8_t stag_ins;
+	uint32_t stag_vlan_id;
+#endif
+} PPE_OUT_VLAN_INFO;
+typedef struct {
+	IP_ADDR ip;
+	uint32_t ipv6_entry;
+	uint32_t psuedo_ip;
+} PPE_IPV6_INFO;
+typedef enum {
+	TUNNEL_TYPE_NULL  = 0, /*!< Not Tunnel */
+	TUNNEL_TYPE_6RD, /*!< 6rd Tunnel */
+	TUNNEL_TYPE_DSLITE, /*!< DSLITE Tunnel */
+	TUNNEL_TYPE_CAPWAP, /*!< CAPWAP Tunnel */
+	TUNNEL_TYPE_L2TP, /*!< L2TP Tunnel */
+	TUNNEL_TYPE_EOGRE, /*!< IPv4 Ethernet Over GRE Tunnel */
+	TUNNEL_TYPE_6EOGRE, /*!< IPv6 Ethernet Over GRE Tunnel */
+	TUNNEL_TYPE_IPOGRE, /*!< IPv4 IP Over GRE Tunnel */
+	TUNNEL_TYPE_IP6OGRE, /*!< IPv6 IP Over GRE Tunnel */
+	TUNNEL_TYPE_IPSEC, /*!< IPSEC Tunnel */
+	TUNNEL_TYPE_MAX /*!< Not Valid Tunnel type */
+} e_Tunnel_Types;
+typedef struct {
+	uint32_t tunnel_idx;
+	uint32_t tunnel_type;
+	struct net_device *tx_dev;
+} PPE_TUNNEL_INFO;
+typedef struct {
+	uint8_t f_ipv6;
+	IP_ADDR src_ip;
+	IP_ADDR dst_ip;
+	uint32_t src_port;
+	uint32_t dst_port;
+	uint8_t session_id;
+} PPA_LRO_INFO;
+typedef struct {
+	uint32_t f_is_lan;
+	IP_ADDR_C src_ip;
+	uint32_t src_port;
+	IP_ADDR_C dst_ip;
+	uint32_t dst_port;
+	uint32_t f_is_tcp; /* 1: TCP, 0: UDP*/
+	uint32_t route_type;
+	IP_ADDR_C new_ip; /*NAT IP*/
+	uint16_t new_port; /*NAT UDP/TCP Port*/
+	uint8_t new_dst_mac[PPA_ETH_ALEN];
+	PPE_ROUTE_MAC_INFO src_mac;
+	PPE_MTU_INFO mtu_info;
+	uint32_t pppoe_mode;
+	PPE_PPPOE_INFO pppoe_info;
+	PPE_TUNNEL_INFO tnnl_info;
+#if defined(L2TP_CONFIG) && L2TP_CONFIG
+	PPE_PPPOL2TP_INFO pppol2tp_info;
+	PPE_TUNNEL_INFO l2tptnnl_info;
+#endif
+	uint32_t f_new_dscp_enable;
+	uint32_t new_dscp;
+	uint32_t f_vlan_ins_enable;
+	uint32_t new_vci;
+	uint32_t f_vlan_rm_enable;
+	uint32_t f_out_vlan_ins_enable;
+	PPE_OUT_VLAN_INFO out_vlan_info;
+	uint32_t f_out_vlan_rm_enable;
+	uint32_t dslwan_qid;
+	uint32_t dest_list;
+	uint32_t entry;
+	uint32_t update_flags; /*for update_routing_entry only*/
+	uint64_t bytes; /*for MIB*/
+	uint32_t f_hit; /*only for test_and_clear_hit_stat*/
+	uint8_t collision_flag; /* 1 mean the entry is in collsion table or no hashed table, like ASE/Danube*/
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+	int32_t hash_val;
+	uint16_t dest_subif_id;
+	uint16_t flags;
+	uint8_t hi_prio;
+	uint32_t sessionAction; /* Pointer to session action */
+#if defined(PPA_IF_MIB) && PPA_IF_MIB
+	bool	is_rx_logical;
+	bool is_tx_logical;
+	PPA_IFNAME rxifname[PPA_IF_NAME_SIZE];
+	PPA_IFNAME txifname[PPA_IF_NAME_SIZE];
+#endif
+#endif
+	uint32_t f_tc_remark_enable;
+	uint32_t tc_remark;
+	uint8_t nFlowId; /* FlowId */
+} PPE_ROUTING_INFO;
+typedef struct{
+	uint32_t f_is_lan;
+	uint32_t entry_num;
+	uint32_t mc_entry_num;
+	uint32_t f_ip_verify;
+	uint32_t f_tcpudp_verify;
+	uint32_t f_tcpudp_err_drop;
+	uint32_t f_drop_on_no_hit;
+	uint32_t f_mc_drop_on_no_hit;
+	uint32_t flags;
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+	uint8_t f_mpe_route;
+	uint8_t f_l2tp_ds;
+	uint8_t f_capwap_ds;
+	uint8_t f_mc_vaps;
+#endif
+} PPE_ROUTING_CFG;
+typedef struct{
+	uint32_t entry_num;
+	uint32_t br_to_src_port_mask;
+	uint32_t br_to_src_port_en;
+	uint32_t f_dest_vlan_en;
+	uint32_t f_src_vlan_en;
+	uint32_t f_mac_change_drop;
+	uint32_t flags;
+} PPE_BRDG_CFG;
+typedef struct{
+	uint32_t mode;
+	uint32_t flags;
+} PPE_FAST_MODE_CFG;
+typedef struct {
+	uint32_t f_is_lan;
+	uint32_t f_enable;
+	uint32_t flags;
+} PPE_ACC_ENABLE;
+#if defined(MIB_MODE_ENABLE) && MIB_MODE_ENABLE
+typedef struct {
+	uint8_t session_mib_unit;
+} PPE_MIB_MODE_ENABLE;
+#endif
+typedef struct {
+	uint32_t uc_dest_list;
+	uint32_t mc_dest_list;
+	uint32_t if_no;
+} PPE_DEST_LIST;
+typedef struct {
+	uint32_t if_no;
+	uint32_t f_eg_vlan_insert;
+	uint32_t f_eg_vlan_remove;
+	uint32_t f_ig_vlan_aware;
+	uint32_t f_ig_src_ip_based;
+	uint32_t f_ig_eth_type_based;
+	uint32_t f_ig_vlanid_based;
+	uint32_t f_ig_port_based;
+	uint32_t f_eg_out_vlan_insert;
+	uint32_t f_eg_out_vlan_remove;
+	uint32_t f_ig_out_vlan_aware;
+} PPE_BRDG_VLAN_CFG;
+typedef struct {
+	uint32_t entry; /*so far it is only for get command*/
+	uint32_t ig_criteria_type;
+	uint32_t ig_criteria;;
+	uint32_t new_vci;
+	uint32_t dest_qos;
+	PPE_OUT_VLAN_INFO out_vlan_info;
+	uint32_t in_out_etag_ctrl;
+	uint32_t vlan_port_map;
+} PPE_BRDG_VLAN_FILTER_MAP;
+typedef struct {
+	uint32_t dest_ip_compare;
+	uint32_t src_ip_compare;
+	uint32_t f_vlan_ins_enable;
+	uint32_t new_vci;
+	uint32_t f_vlan_rm_enable;
+	uint32_t f_src_mac_enable;
+	uint32_t src_mac_ix;
+	uint32_t pppoe_mode;
+	uint32_t f_out_vlan_ins_enable;
+	uint32_t f_tunnel_rm_enable;
+	PPE_OUT_VLAN_INFO out_vlan_info;
+	PPE_IPV6_INFO dst_ipv6_info;
+	PPE_IPV6_INFO src_ipv6_info;
+	uint32_t f_out_vlan_rm_enable;
+	uint32_t f_new_dscp_enable;
+	uint32_t new_dscp;
+	uint32_t dest_qid;
+	uint32_t dest_list;
+	uint32_t route_type;
+	uint32_t p_entry;
+	uint64_t bytes;
+	uint32_t f_hit; /*only for test_and_clear_hit_stat*/
+	uint32_t update_flags; /*only for update only,not for new added one*/
+#if defined(RTP_SAMPLING_ENABLE) && RTP_SAMPLING_ENABLE
+	uint8_t sample_en; /*!< rtp flag */
+	uint32_t rtp_pkt_cnt; /*!< RTP packet mib */
+	uint32_t rtp_seq_num; /*!< RTP sequence number */
+#endif
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+	int32_t	hash_val;
+	uint32_t	f_ipv6;
+	uint16_t	src_port;
+	uint16_t	dst_port;
+	uint16_t	group_id; /*multicast grout id passed from mcastd*/
+	uint16_t	subif_id;
+	uint8_t	num_vap;
+	uint8_t		src_mac[PPA_ETH_ALEN];
+	PPE_TUNNEL_INFO tnnl_info;
+	uint32_t	mtu;
+	uint16_t	flags;	/*input FLAG_SESSION_HI_PRIO*/
+	/*output FLAG_SESSION_SWAPPED*/
+	uint16_t dest_subif[16];
+	uint32_t sessionAction;
+#endif
+} PPE_MC_INFO;
+typedef struct {
+	uint32_t port;
+	uint8_t mac[PPA_ETH_ALEN];
+	uint32_t f_src_mac_drop;
+	uint32_t dslwan_qid;
+	uint32_t dest_list;
+	uint32_t p_entry;
+	uint32_t f_hit; /*only for test_and_clear_bridging_hit_stat*/
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+	uint32_t fid;
+	int32_t age_timer;
+	uint16_t static_entry;
+	uint16_t sub_ifid;
+#endif
+} PPE_BR_MAC_INFO;
+typedef struct {
+	uint16_t brid;
+	uint32_t port;
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+	uint16_t subif_en;
+	uint16_t subif;
+#endif
+	uint16_t vid;
+	uint16_t index;
+} PPA_BR_PORT_INFO;
+struct ppe_itf_mib {
+	uint32_t             ig_fast_brg_pkts;           // 0 bridge ?
+	uint32_t             ig_fast_brg_bytes;          // 1 ?
+
+	uint32_t             ig_fast_rt_ipv4_udp_pkts;   // 2 IPV4 routing
+	uint32_t             ig_fast_rt_ipv4_tcp_pkts;   // 3
+	uint32_t             ig_fast_rt_ipv4_mc_pkts;    // 4
+	uint32_t             ig_fast_rt_ipv4_bytes;      // 5
+
+	uint32_t             ig_fast_rt_ipv6_udp_pkts;   // 6 IPV6 routing
+	uint32_t             ig_fast_rt_ipv6_tcp_pkts;   // 7
+	uint32_t             res0;                       // 8
+	uint32_t             ig_fast_rt_ipv6_bytes;      // 9
+
+	uint32_t             res1;                       // A
+	uint32_t             ig_cpu_pkts;
+	uint32_t             ig_cpu_bytes;
+
+	uint32_t             ig_drop_pkts;
+	uint32_t             ig_drop_bytes;
+
+	uint32_t             eg_fast_pkts;
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+	uint32_t		 ig_fast_rt_ipv6_mc_pkts;
+	uint32_t		 eg_fast_bytes;
+#endif
+};
+typedef struct {
+	uint32_t itf ; /*port*/
+	struct ppe_itf_mib mib;
+	uint32_t flag;
+} PPE_ITF_MIB_INFO;
+
+/* The main device statistics structure */
+struct intf_mib {
+       uint64_t    rx_packets;             /* total packets received       */
+       uint64_t    tx_packets;             /* total packets transmitted    */
+       uint64_t    rx_bytes;               /* total bytes received         */
+       uint64_t    tx_bytes;               /* total bytes transmitted      */
+       uint64_t    rx_errors;              /* bad packets received         */
+       uint64_t    tx_errors;              /* packet transmit problems     */
+       uint64_t    rx_dropped;             /* no space in linux buffers    */
+       uint64_t    tx_dropped;             /* no space available in linux  */
+       uint64_t    multicast;              /* multicast packets received   */
+       uint64_t    collisions;
+
+        /* detailed rx_errors: */
+       uint64_t    rx_length_errors;
+       uint64_t    rx_over_errors;         /* receiver ring buff overflow  */
+       uint64_t    rx_crc_errors;          /* recved pkt with crc error    */
+       uint64_t    rx_frame_errors;        /* recv'd frame alignment error */
+       uint64_t    rx_fifo_errors;         /* recv'r fifo overrun          */
+       uint64_t    rx_missed_errors;       /* receiver missed packet       */
+
+        /* detailed tx_errors */
+       uint64_t    tx_aborted_errors;
+       uint64_t    tx_carrier_errors;
+       uint64_t    tx_fifo_errors;
+       uint64_t    tx_heartbeat_errors;
+       uint64_t    tx_window_errors;
+
+        /* for cslip etc */
+       uint64_t    rx_compressed;
+       uint64_t    tx_compressed;
+};
+
+typedef struct {
+	struct intf_mib mib; 
+	struct netif_info *ifinfo;
+} PPA_ITF_MIB_INFO;
+
+
+
+typedef struct {
+	uint32_t f_enable ;
+	uint32_t flags ;
+} PPE_ENABLE_CFG;
+typedef struct {
+	int32_t num ;
+	uint32_t flags ;
+} PPE_COUNT_CFG;
+typedef struct {
+	uint32_t vfitler_type;
+	int32_t num ;
+	uint32_t flags ;
+} PPE_VFILTER_COUNT_CFG;
+typedef struct {
+	PPA_MULTIFIELD_FLOW_INFO multifield_info;
+	uint32_t entry;
+	uint32_t flag;
+} PPE_MULTIFILED_FLOW;
+typedef struct {
+	uint32_t vid;
+} PPE_WAN_VID_RANGE;
+typedef struct {
+	PPA_IFNAME ifname[PPA_IF_NAME_SIZE]; /*!< Name of the stack interface */
+	uint32_t if_flags; /*!< Flags for Interface. Valid values are below: PPA_F_LAN_IF and PPA_F_WAN_IF */
+	uint32_t port; /*!< physical port id for this Interface. Valid values are below: 0 ~ */
+} PPE_IFINFO;
+typedef struct {
+	uint8_t lan_flag; /* 1 means lan port, 0 means wan ports*/
+	uint32_t physical_port;
+	uint32_t old_lan_flag; /* 1 means lan port, 0 means wan ports*/
+} PPE_WANITF_CFG;
+typedef struct {
+	uint8_t f_is_lan; /* input:1 means lan port, 0 means wan ports*/
+	uint32_t src_ip; /* input:*/
+	uint32_t src_port; /*input:*/
+	uint32_t dst_ip; /* input:*/
+	uint32_t dst_port; /* input:*/
+	uint32_t hash_index; /*output*/
+	uint32_t hash_table_id; /*output mainly reserved for future GRX500 since LAN/WAN will share same hash table*/
+	uint32_t flag; /*reserved*/
+} PPE_SESSION_HASH;
+#endif /*end of NO_DOXY*/
+/*!
+  \brief QoS HAL Rate Shaping configuration structure
+ */
+typedef struct {
+	PPA_IFNAME ifname[PPA_IF_NAME_SIZE];/*!< ifname of the interface on which the Queues & its shapers exist */
+	char *dev_name;/*!<  dev name of the base interface for interface like pppoatm which do not have base netif */
+	uint32_t portid;/*!< Port Id corresponding the interface/netif on which Queues/shapers exist */
+	uint32_t queueid;/*!< Logical queue id while creating queue/physical queue id passed to TMU while shaper->queue assign */
+#if defined(MBR_CONFIG) && MBR_CONFIG
+	int32_t shaperid;/*!< Logical shaper id while creating shaper/physical shaper id passed to TMU while shaper->queue assign */
+#endif
+	int32_t phys_shaperid;/*!< Physical shaper ID returned by TMU when a shaper is created*/
+	PPA_QOS_SHAPER_CFG shaper;/*!< Shaper Info*/
+	uint32_t rate_in_kbps;/*!< Peak rate in kbps*/
+	uint32_t burst;/*!< Peak burst in kbps*/
+	uint32_t flag;/*!< Flags for further use */
+} QOS_RATE_SHAPING_CFG;
+/*!
+  \brief QoS Queue HAL DEL configuration structure
+ */
+typedef struct qos_q_del_cfg{
+	char						*ifname;/*!< Interface name on which the Queue is modified*/
+	char						*dev_name;/*!<  dev name of the base interface for interface like pppoatm which do not have base netif */
+	int32_t						priority; /*!< Queue Priority or Precedence. Start from 1-16, with 1 as highest priority */
+	int32_t						q_id; /*!< Original Queue id of the queue to be deleted */
+	uint16_t					intfId;/*!< flow Id + tc bits used for VAP's & Vlan interfaces*/
+	uint32_t					portid;/*!< Portid*/
+	uint32_t					flags;/*!< Flags for future use*/
+} QOS_Q_DEL_CFG;
+/*!
+  \brief QoS Queue HAL ADD configuration structure
+ */
+typedef struct qos_q_add_cfg{
+	char						*ifname;/*!< Interface name on which the Queue is modified*/
+	char						*dev_name;/*!<  dev name of the base interface for interface like pppoatm which do not have base netif */
+	char						tc_map[MAX_TC_NUM];/*!< Which all Traffic Class(es) map to this Queue */
+	uint8_t						tc_no; /*!< Number of Traffic Class(es) map to this Queue */
+	uint8_t						intfId_en;/*!<Enable/Disable for flow Id + tc bits used for VAP's & Vlan interfaces*/
+	int32_t						weight; /*!< WFQ Weight */
+	int32_t						priority; /*!< Queue Priority or Precedence. Start from 1-16, with 1 as highest priority */
+	int32_t						qlen; /*!< Length of Queue in bytes */
+	int32_t						q_id; /*!< Original Queue id of the Queue added */
+	uint32_t					portid;/*!< Portid*/
+	uint16_t					intfId;/*!< flow Id + tc bits used for VAP's & Vlan interfaces*/
+	/* PPA_QOS_QSCHED_MODE may not be required as tmu hal can internaly find this out: Need to remove later*/
+	PPA_QOS_QSCHED_MODE				q_type;/*!< Scheduler type */
+	PPA_QOS_DROP_CFG				drop; /*!< Queue Drop Properties */
+	uint32_t					flags;/*!< Flags for future use*/
+} QOS_Q_ADD_CFG;
+/*!
+  \brief QoS Queue HAL MOD configuration structure
+ */
+typedef struct qos_q_mod_cfg{
+	char						*ifname;/*!< Interface name on which the Queue is modified*/
+	uint32_t					enable; /*!< Whether Queue is enabled */
+	int32_t						weight; /*!< WFQ Weight */
+	int32_t						priority; /*!< Queue Priority or Precedence. Start from 1-16, with 1 as highest priority */
+	int32_t						qlen; /*!< Length of Queue in bytes */
+	int32_t						q_id; /*!< Original Queue id of the Queue modified */
+	uint32_t					portid;/*!< Portid*/
+	PPA_QOS_QSCHED_MODE				q_type;/*!< Scheduler type */
+	PPA_QOS_DROP_CFG				drop; /*!< Queue Drop Properties */
+	uint32_t					flags;/*!< Flags for future use*/
+} QOS_Q_MOD_CFG;
+/*!
+  \brief QoS Modify QOS Sub interface to Port configuration structure
+ */
+typedef struct qos_mod_subif_port_cfg{
+	char						ifname[PPA_IF_NAME_SIZE];/*!< Interface name on which the Queue is modified*/
+	uint32_t					port_id;/*!< Portid*/
+	int32_t						priority_level; /*!< Queue Priority or Precedence. Start from 1-16, with 1 as highest priority */
+	int32_t						weight; /*!< WFQ Weight */
+	uint32_t					flags;/*!< Flags for future use*/
+} QOS_MOD_SUBIF_PORT_CFG;
+/*!
+  \brief PPA API QoS Add Shaper Configuration structure
+ */
+typedef struct ppa_qos_add_shaper_cfg {
+	PPA_QOS_SHAPER_MODE mode; /*!< Mode of Token Bucket shaper */
+	uint32_t		enable; /*!< Enable for Shaper */
+	uint32_t cir; /*!< Committed Information Rate in bytes/s */
+	uint32_t cbs; /*!< Committed Burst Size in bytes */
+	uint32_t pir; /*!< Peak Information Rate in bytes/s */
+	uint32_t pbs; /*!< Peak Burst Size */
+	uint32_t flags; /*!< Flags define which shapers are enabled
+					  - QOS_SHAPER_F_PIR
+					  - QOS_SHAPER_F_CIR */
+	uint32_t	phys_shaperid;/*!< Physical Queue id of Queue that is added*/
+#ifdef CONFIG_PPA_PUMA7
+	char ifname[PPA_IF_NAME_SIZE];/*!< Interface name on which the shaper is created*/
+#endif
+} PPA_QOS_ADD_SHAPER_CFG;
+/*!
+  \brief PPA API QoS Add Queue Configuration structure
+ */
+typedef struct ppa_qos_add_queue_cfg {
+	char		tc_map[MAX_TC_NUM];/*!< Which all Traffic Class(es) map to this Queue */
+	uint8_t		tc_no; /*!< Number of Traffic Class(es) map to this Queue */
+	uint8_t		intfId_en;/*!<Enable/Disable for flow Id + tc bits used for VAP's & Vlan interfaces*/
+	uint16_t	intfId;/*!< flow Id + tc bits used for VAP's & Vlan interfaces */
+	uint32_t	portid;/*!< PORT ID */
+	int32_t		weight; /*!< WFQ Weight */
+	int32_t		priority; /*!< Queue Priority or Precedence. Start from 1-16, with 1 as highest priority */
+	int32_t		qlen; /*!< Length of Queue in bytes */
+	PPA_QOS_QSCHED_MODE q_type; /*!< QoS scheduler mode - Priority, WFQ */
+	uint32_t	queue_id;/*!< Physical Queue id of Queue that is added*/
+	PPA_QOS_DROP_CFG	drop; /*!< Queue Drop Properties */
+} PPA_QOS_ADD_QUEUE_CFG;
+/*!
+  \brief PPA API QoS Modify Queue Configuration structure
+ */
+typedef struct ppa_qos_mod_queue_cfg {
+	uint32_t		enable; /*!< Whether Queue is enabled */
+	int32_t			weight; /*!< WFQ Weight */
+	int32_t			priority; /*!< Queue Priority or Precedence. Start from 1-16, with 1 as highest priority */
+	uint32_t	portid;/*!< PORT ID */
+	PPA_QOS_QSCHED_MODE q_type; /*!< QoS scheduler mode - Priority, WFQ */
+	int32_t			qlen; /*!< Length of Queue in bytes */
+	uint32_t		queue_id; /*!< Physical Queue id of Queue being modified*/
+	uint32_t		flags; /*!< Flags for future use*/
+	PPA_QOS_DROP_CFG	drop; /*!< Queue Drop Properties */
+} PPA_QOS_MOD_QUEUE_CFG;
+#define PPA_QOS_MAX_IF_PER_INGGRP 20
+#define PPA_NUM_INGRESS_GROUPS		PPA_QOS_INGGRP_MAX
+#define PPA_INGGRP_INVALID(g)		((g < PPA_QOS_INGGRP0) || (g >= PPA_QOS_INGGRP_MAX))
+#define PPA_INGGRP_VALID(g)		(!PPA_INGGRP_INVALID(g))
+/*!
+  \brief PPA API QoS Ingress Group structure
+ */
+typedef struct ppa_qos_inggrp_cfg {
+	PPA_IFNAME ifname[PPA_IF_NAME_SIZE];/*!< Ingress Interface name corresponding to a Ingress QoS group*/
+	PPA_QOS_INGGRP ingress_group;/*!< Ingress QoS Group*/
+	uint16_t flowId;/*!< FlowId value for a particular ingress group*/
+	uint8_t flowId_en;/*!< FlowId enable/disable*/
+	uint8_t enc;/*!< Encrytption bit used to select particular ingress group*/
+	uint8_t dec;/*!< Decrytption bit used to select particular ingress group*/
+	uint8_t mpe1;/*!< MPE1 bit used to select particular ingress group*/
+	uint8_t mpe2;/*!< MPe2 bit used to select particular ingress group*/
+	uint16_t tc;/*!< Traffic class used to select queue in a particular ingress group*/
+	uint32_t ep;/*!< Egress port corresponding to a particular ingress flow*/
+	uint32_t flags;/*!< Flags for Future use*/
+} PPA_QOS_INGGRP_CFG;
+#if defined(CONFIG_PPA_HAL_SELECTOR)
+typedef struct {
+	uint8_t hop_limit;		/*!< PPA ip6hdr hop limit*/
+	uint32_t	saddr[4];	/*!< PPA ip6hdr src address*/
+	uint32_t daddr[4];	/*!< PPA ip6hdr dst address*/
+} PPA_IP6HDR;
+typedef struct {
+	uint32_t saddr;		/*!< PPA ip4hdr src address*/
+	uint32_t daddr;		/*!< PPA ip4hdr src address*/
+} PPA_IP4HDR;
+#if defined(CONFIG_PPA_MPE_IP97) && CONFIG_PPA_MPE_IP97
+#define PPA_IPSEC_NOT_ADDED -1
+#define PPA_IPSEC_EXISTS 0
+#define PPA_IPSEC_ADDED 1
+#define IP_PROTO_ESP 50
+#define	 ESP_HEADER	 73
+typedef struct {
+	PPA_XFRM_STATE *inbound;
+	PPA_XFRM_STATE *outbound;
+	sa_direction dir;
+	uint32_t routeindex;
+#if 1
+	uint32_t inbound_pkt_cnt;
+	uint32_t inbound_byte_cnt;
+	uint32_t outbound_pkt_cnt;
+	uint32_t outbound_byte_cnt;
+#endif
+} PPA_IPSEC_INFO;
+#endif
+typedef union {
+	PPA_IP4HDR		ip4_hdr;	/*!< PPA ip4 hdr*/
+	PPA_IP6HDR		ip6_hdr;	/*!< PPA ip6 hdr*/
+#if defined(L2TP_CONFIG) && L2TP_CONFIG
+	PPA_L2TP_INFO	l2tp_hdr;	/*!< PPA l2tp hdr*/
+#endif
+#if defined(CAP_WAP_CONFIG) && CAP_WAP_CONFIG
+	PPA_CMD_CAPWAP_INFO	capwap_hdr;	/*!< PPA capwap hdr*/
+#endif
+#if defined(CONFIG_PPA_MPE_IP97) && CONFIG_PPA_MPE_IP97
+	PPA_IPSEC_INFO	ipsec_hdr;	/*!< PPA ipsec hdr*/
+#endif
+} ppa_tunnel_info;
+typedef struct {
+	int32_t		tunnel_type;	/*!< PPA tunnel type*/
+	ppa_tunnel_info	tunnel_info;	/*!< PPA tunnel info*/
+	void	 *hal_buffer;	/*!< PPA hal buffer*/
+} ppa_tunnel_entry;
+typedef struct{
+	uint16_t enabled; /*!< Entry is valid*/
+	uint16_t f_ipv6;	/*!< PPA flag ipv6*/
+	IP_ADDR srcip;	/*!< PPA source ip*/
+	IP_ADDR dstip;	/*!< PPA destination ip*/
+	uint32_t srcport;	/*!< PPA source port*/
+	uint32_t dstport;	/*!< PPA destination port*/
+	uint16_t aggr_mtu;	/*!< PPA aggrate mtu*/
+	uint32_t timeout;	/*!< PPA timeout*/
+	uint16_t session_uid[2];	/*!< PPA session id*/
+} ppa_lro_entry;
+#endif
+/*
+ * ####################################
+ * Declaration
+ * ####################################
+ */
+#ifdef __KERNEL__
+#ifdef NO_DOXY
+#ifdef CONFIG_LTQ_PORT_MIRROR
+extern struct net_device *(*get_mirror_netdev)(void);
+extern uint32_t (*is_device_type_wireless)(void);
+#define SKB_MIRROR_FLAG 0x2000
+#endif
+#define ENUM_STRING(x) #x
+void ppa_subsystem_id(uint32_t *,
+		uint32_t *,
+		uint32_t *,
+		uint32_t *,
+		uint32_t *,
+		uint32_t *,
+		uint32_t *,
+		uint32_t *);
+void ppa_get_api_id(uint32_t *,
+		uint32_t *,
+		uint32_t *,
+		uint32_t *,
+		uint32_t *,
+		uint32_t *,
+		uint32_t *);
+int32_t ppa_init(PPA_INIT_INFO *, uint32_t);
+void ppa_exit(void);
+int32_t ppa_enable(uint32_t, uint32_t, uint32_t);
+int32_t ppa_get_status(uint32_t *, uint32_t *, uint32_t);
+#if defined(MIB_MODE_ENABLE) && MIB_MODE_ENABLE
+int32_t ppa_set_mib_mode(uint8_t);
+int32_t ppa_get_mib_mode(uint8_t *);
+#endif
+int32_t ppa_get_ct_stats(PPA_SESSION *p_session, PPA_CT_COUNTER *pCtCounter);
+int32_t ppa_session_add(PPA_BUF *, PPA_SESSION *, uint32_t);
+int32_t ppa_session_modify(PPA_SESSION *, PPA_SESSION_EXTRA *, uint32_t);
+int32_t ppa_session_get(PPA_SESSION ***, PPA_SESSION_EXTRA **, int32_t *, uint32_t);
+int32_t ppa_mc_group_update(PPA_MC_GROUP *, uint32_t);
+int32_t ppa_mc_group_get(IP_ADDR_C, IP_ADDR_C, PPA_MC_GROUP *, uint32_t);
+int32_t ppa_mc_entry_modify(IP_ADDR_C, IP_ADDR_C, PPA_MC_GROUP *, PPA_SESSION_EXTRA *, uint32_t);
+int32_t ppa_mc_entry_get(IP_ADDR_C, IP_ADDR_C, PPA_SESSION_EXTRA *, uint32_t);
+#if defined(CONFIG_PPA_MPE_IP97)
+int32_t ppa_session_ipsec_add(PPA_XFRM_STATE *ppa_x, sa_direction dir);
+int32_t ppa_session_ipsec_delete(PPA_XFRM_STATE *ppa_x);
+#endif
+#if defined(RTP_SAMPLING_ENABLE) && RTP_SAMPLING_ENABLE
+int32_t ppa_mc_entry_rtp_get(IP_ADDR_C, IP_ADDR_C, uint8_t*);
+int32_t ppa_mc_entry_rtp_set(PPA_MC_GROUP *);
+#endif
+#if defined(CAP_WAP_CONFIG) && CAP_WAP_CONFIG
+int32_t ppa_capwap_update(PPA_CMD_CAPWAP_INFO *);
+int32_t ppa_capwap_delete(PPA_CMD_CAPWAP_INFO *);
+#endif
+int32_t ppa_multicast_pkt_srcif_add(PPA_BUF *, PPA_NETIF *);
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+int32_t ppa_add_class_rule(PPA_CLASS_RULE *rule);
+int32_t ppa_mod_class_rule(PPA_CLASS_RULE *rule);
+int32_t ppa_del_class_rule(PPA_CLASS_RULE *rule);
+int32_t ppa_get_class_rule(PPA_CLASS_RULE *rule);
+#endif
+int32_t ppa_inactivity_status(PPA_U_SESSION *);
+int32_t ppa_set_session_inactivity(PPA_U_SESSION *, int32_t);
+int32_t ppa_bridge_entry_add(uint8_t *, PPA_NETIF *, PPA_NETIF *, uint32_t);
+int32_t ppa_bridge_entry_delete(uint8_t *, PPA_NETIF *, uint32_t);
+int32_t ppa_bridge_entry_delete_all(uint32_t f_enable);
+int32_t ppa_bridge_entry_hit_time(uint8_t *, PPA_NETIF *, uint32_t *);
+int32_t ppa_bridge_entry_inactivity_status(uint8_t *, PPA_NETIF *);
+int32_t ppa_set_bridge_entry_timeout(uint8_t *, PPA_NETIF *, uint32_t);
+int32_t ppa_hook_bridge_enable(uint32_t f_enable, uint32_t flags);
+int32_t ppa_hook_get_bridge_status(uint32_t *f_enable, uint32_t flags);
+int32_t ppa_set_bridge_if_vlan_config(PPA_NETIF *, PPA_VLAN_TAG_CTRL *, PPA_VLAN_CFG *, uint32_t);
+int32_t ppa_get_bridge_if_vlan_config(PPA_NETIF *, PPA_VLAN_TAG_CTRL *, PPA_VLAN_CFG *, uint32_t);
+int32_t ppa_vlan_filter_add(PPA_VLAN_MATCH_FIELD *, PPA_VLAN_INFO *, uint32_t);
+int32_t ppa_vlan_filter_del(PPA_VLAN_MATCH_FIELD *, PPA_VLAN_INFO *, uint32_t);
+int32_t ppa_vlan_filter_get_all(int32_t *, PPA_VLAN_FILTER_CONFIG *, uint32_t);
+int32_t ppa_vlan_filter_del_all(uint32_t);
+int32_t ppa_get_if_stats(PPA_IFNAME *, PPA_IF_STATS *, uint32_t);
+int32_t ppa_get_accel_stats(PPA_IFNAME *, PPA_ACCEL_STATS *, uint32_t);
+#if defined(PPA_IF_MIB) && PPA_IF_MIB
+int32_t ppa_get_netif_accel_stats(PPA_IFNAME *, PPA_NETIF_ACCEL_STATS *, uint32_t);
+#endif
+int32_t ppa_hook_set_ppe_fastpath_enable(uint32_t f_enable, uint32_t flags);
+int32_t ppa_hook_get_ppe_fastpath_enable(uint32_t *f_enable, uint32_t flags);
+int32_t ppa_set_if_mac_address(PPA_IFNAME *, uint8_t *, uint32_t);
+int32_t ppa_get_if_mac_address(PPA_IFNAME *, uint8_t *, uint32_t);
+int32_t ppa_add_if(PPA_IFINFO *, uint32_t);
+int32_t ppa_del_if(PPA_IFINFO *, uint32_t);
+int32_t ppa_get_if(int32_t *, PPA_IFINFO **, uint32_t);
+#if defined(CONFIG_PPA_API_DIRECTCONNECT) && CONFIG_PPA_API_DIRECTCONNECT
+int32_t ppa_disconn_if(PPA_NETIF *, PPA_DP_SUBIF *, uint8_t *, uint32_t);
+#if defined(WMM_QOS_CONFIG) && WMM_QOS_CONFIG
+int32_t ppa_register_for_qos_class2prio(int32_t , struct net_device *, PPA_QOS_CLASS2PRIO_CB , uint32_t);
+#endif
+#endif
+int32_t ppa_hook_wan_mii0_vlan_range_add(PPA_VLAN_RANGE *, uint32_t);
+int32_t ppa_hook_wan_mii0_vlan_range_del(PPA_VLAN_RANGE *, int32_t);
+int32_t ppa_hook_wan_mii0_vlan_ranges_get(int32_t *, PPA_VLAN_RANGE *, uint32_t);
+int32_t ppa_get_max_entries(PPA_MAX_ENTRY_INFO *max_entry, uint32_t flags);
+int32_t ppa_ip_comare(PPA_IPADDR ip1, PPA_IPADDR ip2, uint32_t flag);
+int32_t ppa_zero_ip(PPA_IPADDR ip);
+int32_t ppa_ip_sprintf(char *buf, PPA_IPADDR ip, uint32_t flag);
+extern uint32_t g_ppa_ppa_mtu;
+extern uint32_t g_ppa_min_hits;
+extern volatile u_int8_t g_ppe_fastpath_enabled;
+#endif /*NO_DOXY*/
+#endif /*end of __KERNEL__*/
+#ifdef __KERNEL__
+/* this header file uses many of the above structure definitions*/
+#include <net/ppa/ppa_hook.h>
+#endif
+#endif /* __PPA_API_H*/
diff --git a/include/net/ppa/ppa_api_common.h b/include/net/ppa/ppa_api_common.h
new file mode 100644
index 000000000000..1223c6ad7d5d
--- /dev/null
+++ b/include/net/ppa/ppa_api_common.h
@@ -0,0 +1,68 @@
+#ifndef __PPA_API_COMMON_H__20100203__1740__
+#define __PPA_API_COMMON_H__20100203__1740__
+/*******************************************************************************
+**
+** FILE NAME    : ppa_api_common.h
+** PROJECT      : PPA
+** MODULES      : PPA Common header file
+**
+** DATE         : 3 NOV 2008
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : PPA Common Header File
+** COPYRIGHT    : Copyright (c) 2017 Intel Corporation
+** Copyright (c) 2010 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+** HISTORY
+** $Date        $Author         $Comment
+** 03 NOV 2008  Xu Liang        Initiate Version
+*******************************************************************************/
+#define NO_DOXY                 1
+#ifndef PPA_DSLITE   /*if not defined in kernel's .configure file, then use local's definition*/
+#define PPA_DSLITE            1
+#endif
+#ifndef RTP_SAMPLING_ENABLE     /*if not defined in kernel's .configure file, then use local's definition*/
+#define RTP_SAMPLING_ENABLE               1
+#endif
+#ifndef MIB_MODE_ENABLE     /*if not defined in kernel's .configure file, then use local's definition*/
+#define MIB_MODE_ENABLE               1
+#endif
+#ifndef CAP_WAP_CONFIG     /*if not defined in kernel's .configure file, then use local's definition*/
+#define CAP_WAP_CONFIG               1
+#endif
+#ifndef L2TP_CONFIG     /*if not defined in kernel's .configure file, then use local's definition*/
+#define L2TP_CONFIG               1
+#endif
+#ifndef MBR_CONFIG     /*if not defined in kernel's .configure file, then use local's definition*/
+#define MBR_CONFIG               1
+#endif
+#ifndef QOS_AL_CONFIG     /*if not defined in kernel's .configure file, then use local's definition*/
+#define QOS_AL_CONFIG               1
+#endif
+#ifndef PPA_MFE      /*if not defined in kernel's .configure file, then use local's definition*/
+#define PPA_MFE               0
+#endif
+#ifndef VLAN_VAP_QOS     /*if not defined in kernel's .configure file, then use local's definition*/
+#define VLAN_VAP_QOS               1
+#endif
+#ifndef WMM_QOS_CONFIG     /*if not defined in kernel's .configure file, then use local's definition*/
+#define WMM_QOS_CONFIG               1
+#endif
+#ifndef PPA_API_PROC      /*if not defined in kernel's .configure file, then use local's definition*/
+#define PPA_API_PROC               1
+#endif
+/*force dynamic ppe driver's module parameter */
+#define PPA_DP_DBG_PARAM_ENABLE  1   /*for PPA automation purpose. for non-linux os porting, just disable it*/
+#define PPA_IF_MIB 1   /*Flag to enable/disable PPA software interface based mib counter*/
+#define SESSION_STATISTIC_DEBUG 1 /*flag to enable session management statistics support*/
+#define MPE_IFMIB	1
+#define PPA_INTF_MIB_TIMER	1
+
+
+
+#if PPA_DP_DBG_PARAM_ENABLE
+extern int ppa_drv_dp_dbg_param_enable;
+extern int  ppa_drv_dp_dbg_param_ethwan;
+extern int ppa_drv_dp_dbg_param_wanitf;
+extern int ppa_drv_dp_dbg_param_ipv6_acc_en;
+extern int ppa_drv_dp_dbg_param_wanqos_en;
+#endif /* end of PPA_DP_DBG_PARAM_ENABLE*/
+#endif
diff --git a/include/net/ppa/ppa_api_directpath.h b/include/net/ppa/ppa_api_directpath.h
new file mode 100644
index 000000000000..63dd14296cb3
--- /dev/null
+++ b/include/net/ppa/ppa_api_directpath.h
@@ -0,0 +1,438 @@
+#ifndef __PPA_API_DIRECTPATH_H__20081119_1144__
+#define __PPA_API_DIRECTPATH_H__20081119_1144__
+/*******************************************************************************
+ **
+ ** FILE NAME    : ppa_api_directpath.h
+ ** PROJECT      : PPA
+ ** MODULES      : PPA API (Routing/Bridging Acceleration APIs)
+ **
+ ** DATE         : 19 NOV 2008
+ ** AUTHOR       : Xu Liang
+ ** DESCRIPTION  : PPA Protocol Stack Hook API Directpath Functions Header
+ **                File
+ ** COPYRIGHT    : Copyright (c) 2017 Intel Corporation
+ ** Copyright (c) 2010 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+ ** HISTORY
+ ** $Date        $Author         $Comment
+ ** 19 NOV 2008  Xu Liang        Initiate Version
+ *******************************************************************************/
+/*! \file ppa_api_directpath.h
+  \brief This file contains: PPA direct path api.
+ */
+#include <net/ppa/ppa_api_common.h>
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+#include <net/datapath_api.h>
+#endif
+/*
+ * ####################################
+ *              Data Type
+ * ####################################
+ */
+/*
+ * ####################################
+ *              Definition
+ * ####################################
+ */
+/*
+ *  Directpath API Flags
+ */
+/*!
+  \brief PPA_F_DIRECTPATH_REGISTER
+ */
+#define PPA_F_DIRECTPATH_REGISTER               0x00100000  /*!< Directpath register flag*/
+/*!
+  \brief PPA_F_DIRECTPATH_CORE1
+ */
+#define PPA_F_DIRECTPATH_CORE1                  0x00200000  /*!< Directpath flag: run in CPU Core 1*/
+/*!
+  \brief PPA_F_DIRECTPATH_ETH_IF
+ */
+#define PPA_F_DIRECTPATH_ETH_IF                 0x00400000  /*!< Directpath flag: Ethernet type*/
+/*!
+  \brief PPA_F_DIRECTPATH_WAN
+ */
+#define PPA_F_DIRECTPATH_WAN                    0x00800000  /*!< Directpath flag: Ethernet type*/
+/*!
+  \brief PPA_F_DIRECTLINK
+ */
+#define PPA_F_DIRECTLINK                        0x01000000  /*!< DirectLink flag: Ethernet type*/
+/*!
+  \brief PPA_F_DIRECTLINK_XMIT_TO_WIFI
+ */
+#define PPA_F_DIRECTLINK_XMIT_TO_WIFI           (1 << 0)  /*!< Directlink send flag*/
+/*!
+  \brief PPA_F_DIRECTLINK_XMIT_FROM_WIFI
+ */
+#define PPA_F_DIRECTLINK_XMIT_FROM_WIFI         (1 << 1)  /*!< Directlink send flag*/
+/*!
+  \brief PPA_F_DIRECTPATH_XMIT_QOS
+ */
+#define PPA_F_DIRECTPATH_XMIT_QOS               (1 << 2)  /*!< Directpath send flag*/
+/*
+ *  Directpath Internal Flags
+ */
+/*!
+  \brief PPE_DIRECTPATH_DATA_ENTRY_VALID
+ */
+#define PPE_DIRECTPATH_DATA_ENTRY_VALID         (1 << 31)   /*!< define flag */
+/*!
+  \brief PPE_DIRECTPATH_DATA_RX_ENABLE
+ */
+#define PPE_DIRECTPATH_DATA_RX_ENABLE           (1 << 0)    /*!< define flag */
+/*!
+  \brief PPE_DIRECTPATH_ETH
+ */
+#define PPE_DIRECTPATH_ETH                      (1 << 4)    /*!< define flag */
+/*!
+  \brief PPE_DIRECTPATH_CORE0
+ */
+#define PPE_DIRECTPATH_CORE0                    (1 << 8)    /*!< define flag */
+/*!
+  \brief PPE_DIRECTPATH_CORE1
+ */
+#define PPE_DIRECTPATH_CORE1                    (1 << 9)    /*!< define flag */
+/*!
+  \brief PPE_DIRECTPATH_LAN
+ */
+#define PPE_DIRECTPATH_LAN                      (1 << 10)   /*!< define flag */
+/*!
+  \brief PPE_DIRECTPATH_WAN
+ */
+#define PPE_DIRECTPATH_WAN                      (1 << 11)   /*!< define flag */
+/*!
+  \brief PPE_DIRECTPATH_LEGACY
+ */
+#define PPE_DIRECTPATH_LEGACY                      (1 << 12)   /*!< define flag */
+/*!
+  \brief PPE_DIRECTPATH_ITF_TYPE_MASK
+ */
+#define PPE_DIRECTPATH_ITF_TYPE_MASK            (PPE_DIRECTPATH_ETH)    /*!< define flag */
+/*!
+  \brief PPE_DIRECTPATH_CORE_MASK
+ */
+#define PPE_DIRECTPATH_CORE_MASK                (PPE_DIRECTPATH_CORE0 | PPE_DIRECTPATH_CORE1)   /*!< define flag */
+/*!
+  \brief PPE_DIRECTPATH_LANWAN_MASK
+ */
+#define PPE_DIRECTPATH_LANWAN_MASK              (PPE_DIRECTPATH_LAN | PPE_DIRECTPATH_WAN)       /*!< define flag */
+/*!
+  \brief PPE_DIRECTPATH_MASK
+ */
+#define PPE_DIRECTPATH_MASK                     (PPE_DIRECTPATH_ITF_TYPE_MASK | PPE_DIRECTPATH_CORE_MASK | PPE_DIRECTPATH_LANWAN_MASK)  /*!< define flag */
+/*!
+  \brief PPE_F_DTLK_REGISTER
+ */
+#define PPE_F_DTLK_REGISTER                     (1 << 0)
+/*!
+  \brief PPE_F_DTLK_DP_REGISTER
+ */
+#define PPE_F_DTLK_DP_REGISTER                  (1 << 1)
+/*!
+  \brief PPE_F_DTLK_DP_DEREGISTER
+ */
+#define PPE_F_DTLK_DP_DEREGISTER                (1 << 2)
+/*!
+  \brief PPE_F_DTLK_DEREGISTER
+ */
+#define PPE_F_DTLK_DEREGISTER                   (1 << 3)
+/*!
+  \brief PPE_DTLK_VALID
+ */
+#define PPE_DTLK_VALID                          (1 << 20)
+/** \addtogroup  PPA_API_DIRECTPATH */
+/*@{*/
+/*! \fn PPA_FP_STOP_TX_FN
+  \brief This is the definition for the PPA DirectPath Stop Transmit function callback used for flow control when transmitting
+  packets through the PPA DirectPath. The PPA DirectPath calls this hook to indicate to the device driver that it
+  cannot receive any more packets for transmission.
+  \param[in] dev  The protocol stack network interface structure on which to signal Stop Tx for flow control
+  \return  The return value can be any one of the following:  \n
+  PPA_SUCCESS on sucess \n
+  PPA_FAILURE on error if the driver cannot handle flow control
+  \note This function must be provided by the CPU-bound interface driver and will be called by the PPA Directpath to pass
+  on frames directly to the driver for transmitting out of its interface.
+ */
+typedef int32_t (*PPA_FP_STOP_TX_FN)(PPA_NETIF *dev);
+/*! \fn PPA_FP_RESTART_TX_FN
+  \brief   This is the definition for the PPA DirectPath Restart Transmit function callback used for flow control when
+  transmitting packets through the PPA DirectPath. The PPA DirectPath calls this hook to indicate to the device
+  driver that it is ready to receive packets for transmission after having asserted stop flow control using
+  PPA_FP_STOP_TX_FN.
+  \param[in] dev  The protocol stack network interface structure on which to signal restart Tx for flow control.
+  \return  The return value can be any one of the following:  \n
+  PPA_SUCCESS on sucess \n
+  PPA_FAILURE on error if the driver cannot handle flow control
+  \note It is recommended for a device driver to use the PPA DirectPath flow control functions for efficient packet
+  processing. This callback must always be used in conjunction with the PPA_FP_STOP_TX_FN callback, i.e.,
+  either both callbacks or none must be configure
+ */
+typedef int32_t (*PPA_FP_RESTART_TX_FN)(PPA_NETIF *dev);
+/*! \fn PPA_FP_RX_FN
+  \brief This is the definition for the PPA DirectPath receive function callback that passes packet from PPA DirectPath to
+  the CPU bound driver.  This callback is registered for the device with the PPA module by the device driver. This is required to allow the PPA acceleration layer to directly pass packets to the relevant device driver bypassing the protocol stack. It is also the only way for the PPA to deliver packets to drivers running on Core 1.
+  The packet buffer passed to the rx_fn callback will have the data pointer point to the start of Link layer header (i.e. Ethernet header). For eg., on Linux, skb->data will point to the Ethernet header.
+  \param[in] rxif  PPA Receive interface pointer on which the packet is received.
+  \param[in] txif  PPA Tx interface pointer to which the packet is transmitted.
+  \param[in] skb   Pointer to SKB buffer received.
+  \param[in] len  Length of packet frame.
+  \return  The return value can be any one of the following:  \n
+  PPA_SUCCESS on sucess. \n
+  PPA_FAILURE on error if the driver process the packet for some reason.
+  \note This function must be provided by the CPU-bound interface driver and will be called by the PPA Directpath to pass on frames directly to the driver for transmitting out of its interface.
+ */
+typedef int32_t (*PPA_FP_RX_FN)(PPA_NETIF *rxif, PPA_NETIF *txif, PPA_SKBUF *skb, int32_t len);
+/*@}*/ /*PPA_API_DIRECTPATH */
+/** \addtogroup  PPA_API_DIRECTPATH */
+/*@{*/
+/*!
+  \brief This is the data structure for the PPA DirectPath device registration which provides the necessary callback
+  registration for receiving packets from PPA DirectPath to the driver for transmit, and for flow control to be asserted
+  by the PPA DirectPath for packets from the driver to the PPA DirectPath.
+ */
+typedef struct {
+	PPA_FP_STOP_TX_FN       stop_tx_fn; /*!< Pointer to the Driver Stop Tx function callback. Providing a NULL pointer disables the callback functionality. */
+	PPA_FP_RESTART_TX_FN    start_tx_fn; /*!< Pointer to the Driver Restart Tx function callback. Providing a NULL pointer disables the callback functionality.*/
+	PPA_FP_RX_FN            rx_fn; /*!< Device Receive Function callback for packets. Setting a value of NULL pointer disables Receive callback for the device */
+} PPA_DIRECTPATH_CB;
+/*!
+  \brief This is the data structure used by the PPA DirectLink device to provides the necessary
+  Information of the device for PPA Directlink registration and data transmit.
+ */
+typedef struct {
+	PPA_NETIF *dev;	/*!< Pointer to the netif device */
+	uint32_t  vap_id;   /*!< VAP identifier */
+	uint32_t  flags;    /*!< Flags */
+} PPA_DTLK_T;
+#ifndef CONFIG_LTQ_DATAPATH
+typedef struct {
+	int32_t port_id;  /*!< Datapath Port Id corresponds to PMAC Port Id */
+	int32_t subif:15; /*!< Sub-interface Id info. In GRX500,
+						this is 15 bits, only 13 bits in PAE are handled [14, 11:0].\n
+						DMA subif format is mc_flag[14:14]  Res[13:12] VAP[11:8]
+						GRP[7:7] Index/StationID[6:0] \n
+					   */
+} PPA_SUBIF;
+#endif
+/*
+ *  Internal Structure of directpath
+ */
+/*!
+  \brief This is the data structure for the PPA DirectPath device status
+ */
+struct ppe_directpath_data {
+	PPA_DIRECTPATH_CB               callback;       /*!< Callback Pointer to PPA_DIRECTPATH_CB */
+	PPA_NETIF                      *netif;          /*!< pointer to  PPA_NETIF*/
+	uint32_t                        ifid;           /*!< directpath interface id */
+#if defined(CONFIG_PPA_DIRECTPATH_TX_QUEUE_SIZE) || defined(CONFIG_PPA_DIRECTPATH_TX_QUEUE_PKTS)
+	PPA_SKBUF                        *skb_list;       /*!< the directpath interface's skb list */
+	spinlock_t                      txq_lock;       /*!< the lock to protect the skb list queue */
+#ifdef CONFIG_PPA_DIRECTPATH_TX_QUEUE_SIZE
+	uint32_t                        skb_list_size;  /*!< the skb list size */
+#else
+	uint32_t                        skb_list_len;   /*!< the skb list length */
+#endif
+#endif
+	uint32_t                        rx_fn_rxif_pkt; /*!< received packet counter */
+	uint32_t                        rx_fn_txif_pkt; /*!< transmitted packet coutner */
+	uint32_t                        tx_pkt;         /*!< transmitted packet counter */
+	uint32_t                        tx_pkt_dropped; /*!< dropped packet counter */
+	uint32_t                        tx_pkt_queued;  /*!< queued packet counter */
+	uint32_t                        flags;          /*!<  bit 0 - directpath send valid, 31 - entry valid  */
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+	uint32_t                    dp_port_id;
+	struct                      module *owner;
+	dp_subif_t                  dp_subif;
+#endif
+};
+/*@}*/ /* PPA_API_DIRECTPATH */
+/*
+ * ####################################
+ *             Declaration
+ * ####################################
+ */
+/** \addtogroup  PPA_API_DIRECTPATH */
+/*@{*/
+#ifdef CONFIG_PPA_API_DIRECTPATH
+#if defined(CONFIG_ACCL_11AC) || defined(CONFIG_ACCL_11AC_MODULE)
+/*!
+  \brief   This function allows a device driver to register or deregister a network device to the PPA.
+  \param[out] if_id  PPA specific Interface Identifier. It is currently a number between 0 to 15. This Id is returned by the PPA module.
+  \param[in]  PPA_DTLK_T  Pointer to the structure which contain network device structure in the protocol stack and a VAP ID.\n
+  flag inside to indicate if device is being registered or deregisered. Valid values are: \n
+  - PPE_F_DTLK_REGISTER, if de-register, the corresponding bit is zero.\n
+  - PPE_F_DTLK_DP_REGISTER, \n
+  - PPE_F_DTLK_DP_UNREGISTER
+  \param[in]  pDirectpathCb  Pointer to the DirectPath callback structure which provides the driver callbacks for rx_fn, stop_tx_fn and restart_tx_fn. This parameter is only available on new PPA API.
+  \param[in]  flags  Flag to indicate if device is being registered or deregistered. Valid values are:\n
+  - PPA_F_DIRECTPATH_DEREGISTER, if de-registering, zero otherwise \n
+  - PPA_F_DIRECTPATH_CORE1 if the driver for the network interface is running on Core 1 (i.e. 2nd CPU) \n
+  - PPA_F_DIRECTPATH_ETH_IF if the network interface is an Ethernet-like interface
+  \return  The return value can be any one of the following:  \n
+  -	IFX_SUCCESS on sucess \n
+  -	IFX_FAILURE
+  \note
+ */
+#ifdef CONFIG_SOC_GRX500
+extern int (*datapath_dtlk_register_fn)(PPA_SUBIF *subIf, PPA_DTLK_T *dtlk);
+int32_t ppa_directlink_register_dev(PPA_SUBIF *subIf, PPA_DTLK_T *dtlk, PPA_DIRECTPATH_CB *pDirectpathCb, uint32_t flags);
+#else
+int32_t ppa_directlink_register_dev(int32_t *if_id, PPA_DTLK_T *dtlk, PPA_DIRECTPATH_CB *pDirectpathCb, uint32_t flags);
+#endif
+#endif
+/*!
+  \brief   This function allows a QCA 11AC wifi device driver to register or deregister a network device to the PPA.
+  \param[out] if_id  PPA specific Interface Identifier. It is currently a number between 0 to 7. This Id is returned by the PPA module.
+  \param[in]  dev  Pointer to the network device structure in the protocol stack. For e.g. pointer to a struct netdevice.
+  \param[in]  pDirectpathCb  Pointer to the DirectPath callback structure which provides the driver callbacks for rx_fn, stop_tx_fn and restart_tx_fn. This parameter is only available on new PPA API.
+  \param[in]  flags  Flag to indicate if device is being registered or deregistered. Valid values are:\n
+  - PPA_F_DIRECTPATH_DEREGISTER, if de-registering, zero otherwise \n
+  - PPA_F_DIRECTPATH_CORE1 if the driver for the network interface is running on Core 1 (i.e. 2nd CPU) \n
+  - PPA_F_DIRECTPATH_ETH_IF if the network interface is an Ethernet-like interface
+  \return  The return value can be any one of the following:  \n
+  -	PPA_SUCCESS on sucess \n
+  -	PPA_FAILURE
+  \note
+ */
+int32_t ppa_directpath_register_dev(uint32_t *if_id, PPA_NETIF *dev, PPA_DIRECTPATH_CB *pDirectpathCb, uint32_t flags);
+/*#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500*/
+/*!
+  \brief   This function allows a CPU bound device driver to register or deregister a network device to the PPA.
+  \param[out] subif  PPA Sub Interface pointer including PortNo. For legacy systen only port no is used. if subif.port_id == -1, registration for physical interface. If subif.port_id > 0, registration is for logical interface/ sub interface.
+  \param[in]  dev  Pointer to the network device structure in the protocol stack. For e.g. pointer to a struct netdevice.
+  \param[in]  pDirectpathCb  Pointer to the DirectPath callback structure which provides the driver callbacks for rx_fn, stop_tx_fn and restart_tx_fn. This parameter is only available on new PPA API.
+  \param[in]  flags  Flag to indicate if device is being registered or deregistered. Valid values are:\n
+  - PPA_F_DIRECTPATH_REGISTER, if registering,  \n
+  - PPA_F_DIRECTPATH_DEREGISTER, if de-registering, zero otherwise \n
+  - PPA_F_DIRECTPATH_CORE1 if the driver for the network interface is running on Core 1 (i.e. 2nd CPU) \n
+  - PPA_F_DIRECTPATH_ETH_IF if the network interface is an Ethernet-like interface
+  \return  The return value can be any one of the following:  \n
+  -	PPA_SUCCESS on sucess \n
+  -	PPA_FAILURE
+  \note
+ */
+int32_t ppa_directpath_ex_register_dev(PPA_SUBIF *subif, PPA_NETIF *dev, PPA_DIRECTPATH_CB *pDirectpathCb, uint32_t flags);
+/*#endif*/
+/*!  \brief   This function allows the device driver to transmit a packet using the PPA DirectPath interface.
+  \param[in] rx_if_id  Receive interface Id in the protocol stack.
+  \param[in] buf  Pointer to the packet buffer structure of the stack for the packet which is to be transmitted.
+  \param[in] len  Size of packet in bytes.
+  \param[in] flags  Currently Reserved
+  \return  The return value can be any one of the following:  \n
+  -	PPA_SUCCESS on sucess \n
+  -	PPA_FAILURE
+  \note The DirectPath Tx API can have internal "shortcut" path to the destination or fallback to passing the packet to the protocol stack. The aim is to insulate the device driver calling the API from such details. For Linux, the driver must call this function through the hook pointer where it passes packets to the network stack by calling the "netif_rx()" or "netif_receive_skb()" functions. \n
+Note: The CPU-bound device driver is strongly recommended to call this API from tasklet mode (or equivalent non-interrupt context on non-Linux OS) and not from IRQ context for better system dynamics.
+ */
+#if defined(CONFIG_PPA_DIRECTPATH_TX_IMQ)
+int32_t ppa_directpath_reinject_from_imq(int32_t rx_if_id, PPA_SKBUF *buf, int32_t len, uint32_t flags);
+extern int32_t ppa_directpath_imq_en_flag;
+#endif
+/*!  \brief   This function allows the device driver to dequeue the traffic and return the packet to  PPA DirectPath interface.
+  \param[in] rx_if_id  Receive interface Id in the protocol stack.
+  \param[in] buf  Pointer to the packet buffer structure of the stack for the packet which is to be transmitted.
+  \param[in] len  Size of packet in bytes.
+  \param[in] flags  Currently Reserved
+  \return  The return value can be any one of the following:  \n
+  -	PPA_SUCCESS on sucess \n
+  -	PPA_FAILURE
+ */
+int32_t ppa_directpath_send(uint32_t rx_if_id, PPA_SKBUF *buf, int32_t len, uint32_t flags);
+/*#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500*/
+/*!  \brief   This function allows the device driver to dequeue the traffic and return the packet to  PPA DirectPath interface.
+  \param[in] subif  PPA Sub interface pointer including PortNo. For legacy PPA support, only port number is used.
+  \param[in] buf  Pointer to the packet buffer structure of the stack for the packet which is to be transmitted.
+  \param[in] len  Size of packet in bytes.
+  \param[in] flags  Currently Reserved
+  \return  The return value can be any one of the following:  \n
+  -	PPA_SUCCESS on sucess \n
+  -	PPA_FAILURE
+ */
+int32_t ppa_directpath_ex_send(PPA_SUBIF *subif, PPA_SKBUF *skb, int32_t len, uint32_t flags);
+/*#endif*/
+/*!  \brief   This function allows the device driver to indicate to the PPA that it cannot receive any further packets from the latter. The device driver can call this function for flow control.
+  \param[in] if_id  Interface Id for which to apply flow control.
+  \param[in] flags  Currently Reserved
+  \return  The return value can be any one of the following:  \n
+  -	PPA_SUCCESS on sucess \n
+  -	PPA_FAILURE
+  \note   1. Even if the return value is PPA_FAILURE , skb will be freed by PPA. Don't reuse this skb for any purpose\n
+  2. For linux, skb->data must point to ethernet destination mac address, not ip header.
+ */
+int32_t ppa_directpath_rx_stop(uint32_t if_id, uint32_t flags);
+/*!  \brief     This function allows the device driver to indicate to the PPA that it can again receive packets from the latter. The device driver can call this function for flow control after it has called the "Rx Stop" function to halt supply of packets from the PPA.
+  \param[in] if_id  Interface Id for which the driver requests the flow control action to restart transmission.
+  \param[in] flags  Currently Reserved
+  \return  The return value can be any one of the following:  \n
+  -	PPA_SUCCESS on sucess \n
+  -	PPA_FAILURE
+  \note   It is recommended for a device driver to use the PPA DirectPath flow control functions for efficient packet processing. This function must be used in conjunction with the PPA_FP_STOP_TX_FN. \n
+ */
+int32_t ppa_directpath_rx_restart(uint32_t if_id, uint32_t flags);
+/*!  \brief     This function maps the PPA Interface Id to Protocol stack interface structure.
+  \param[in] if_id  PPA Interface Identifier.
+  \return  The return value can be any one of the following:  \n
+  -	Pointer to the interface structure in the protocol stack \n
+  -	NULL
+  \note  This API may not implemented on older PPA version. \n
+ */
+PPA_NETIF *ppa_get_netif_for_ppa_ifid(uint32_t if_id);
+/*!  \brief    This function maps the Protocol stack interface structure to the PPA Interface Id.
+  \param[in] dev  Pointer to the protocol stack network interface structure for the device.
+  \return  The return value can be any one of the following: \n
+  -	PPA Interface Identifier, if_id \n
+  -	PPA_FAILUREPPA_NETIF. \n
+  \note  This API may not implemented on older PPA version. \n
+ */
+int32_t ppa_get_ifid_for_netif(PPA_NETIF *dev);
+/*!  \brief     This function is used to initialize the interation of ppe_directpath_data information
+  \param[in,out] ppos  offset of current ppe_directpath_data, after call, its value will be changed to next offset
+  \param[out]    info  Buffer to store the ppe_directpath_data.
+  \return  The return value can be any one of the following: \n
+  -	PPA_SUCCESS, if succeed \n
+  -	PPA_FAILURE, if fail to get \n
+ */
+int32_t ppa_directpath_data_start_iteration(uint32_t *ppos, struct ppe_directpath_data **info);
+/*!  \brief  This function is used to ge the next ppe_directpath_data information during its iteration
+  \param[in,out] ppos  offset of ppe_directpath_data, after call, its value will be changed to next offset
+  \param[out]    info  Buffer to store the ppe_directpath_data.
+  \return  The return value can be any one of the following: \n
+  -	PPA_SUCCESS, if succeed \n
+  -	PPA_FAILURE, if fail to get \n
+ */
+int32_t ppa_directpath_data_iterate_next(uint32_t *ppos, struct ppe_directpath_data **info);
+/*!  \brief     This function is used to stop ppe_directpath_data iteration
+  \return NULL
+ */
+void ppa_directpath_data_stop_iteration(void);
+/*!  \brief     This function is used to get directpath's ifid range
+  \param[out] p_start_ifid  Buffer to store the directpath's start ifid
+  \param[out] p_end_ifid  Buffer to store the directpath's end ifid
+  \return NULL\n
+ */
+void ppa_directpath_get_ifid_range(uint32_t *p_start_ifid, uint32_t *p_end_ifid);
+int32_t ppa_directpath_ex_rx_restart(PPA_SUBIF *subif, uint32_t flags);
+int32_t ppa_directpath_ex_rx_stop(PPA_SUBIF *subif, uint32_t flags);
+PPA_SKBUF *ppa_directpath_alloc_skb(PPA_SUBIF *psubif, int32_t len, uint32_t flags);
+int32_t  ppa_directpath_recycle_skb(PPA_SUBIF *psubif, PPA_SKBUF *skb, uint32_t flags);
+#endif
+/* @}*/  /* PPA_API_DIRECTPATH */
+#ifdef CONFIG_PPA_API_DIRECTPATH
+extern struct ppe_directpath_data *ppa_drv_g_ppe_directpath_data;
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+extern  int (*ppa_drv_directpath_send_hook)(PPA_SUBIF *, PPA_BUF *, int32_t, uint32_t);
+extern  int (*ppa_drv_directpath_register_hook)(PPA_SUBIF *, PPA_NETIF *, PPA_DIRECTPATH_CB *, int32_t*, uint32_t);
+#else
+extern  int (*ppa_drv_directpath_send_hook)(uint32_t, PPA_BUF *, int32_t, uint32_t);
+#endif
+extern  int (*ppa_drv_directpath_rx_stop_hook)(uint32_t, uint32_t);
+extern  int (*ppa_drv_directpath_rx_start_hook)(uint32_t, uint32_t);
+#endif
+#if defined(CONFIG_ACCL_11AC) || defined(CONFIG_ACCL_11AC_MODULE)
+#ifdef CONFIG_SOC_GRX500
+extern int datapath_dtlk_register(PPA_SUBIF *subIf, PPA_DTLK_T *dtlk);
+#else
+extern int datapath_dtlk_register(int32_t *p_if_id, PPA_DTLK_T *dtlk);
+extern int datapath_dtlk_update(int32_t dl_id, PPA_DTLK_T *dtlk, uint32_t *dp_if_id);
+#endif
+#endif
+#endif  /*  _PPA_API_DIRECTPATH_H__20081119_1144__*/
diff --git a/include/net/ppa/ppa_api_netif.h b/include/net/ppa/ppa_api_netif.h
new file mode 100644
index 000000000000..ef1e20992199
--- /dev/null
+++ b/include/net/ppa/ppa_api_netif.h
@@ -0,0 +1,242 @@
+#ifndef __PPA_API_NETIF_H__20081104_1138__
+#define __PPA_API_NETIF_H__20081104_1138__
+
+/*******************************************************************************
+ **
+ ** FILE NAME    : ppa_api_netif.h
+ ** PROJECT      : PPA
+ ** MODULES      : PPA API (Routing/Bridging Acceleration APIs)
+ **
+ ** DATE         : 4 NOV 2008
+ ** AUTHOR       : Xu Liang
+ ** DESCRIPTION  : PPA Protocol Stack Hook API Network Interface Functions
+ **					Header File
+ ** COPYRIGHT    : Copyright (c) 2017 Intel Corporation
+ ** Copyright (c) 2010 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+ ** HISTORY
+ ** $Date        $Author         $Comment
+ ** 04 NOV 2008  Xu Liang        Initiate Version
+ ******************************************************************************
+ */
+/*! \file ppa_api_netif.h
+  \brief This file contains network related api
+ */
+
+/** \defgroup PPA_NETIF_API PPA Network Interface API
+  \brief  provide network interface related api to get/add/delete/update information
+  - ppa_api_netif.h: Header file for PPA API
+  - ppa_api_netif.c: C Implementation file for PPA API
+ */
+/* @{ */
+
+/* ####################################
+ *              Definition
+ * ####################################
+ */
+
+#define PPA_IS_PORT_CPU0_AVAILABLE()	(g_phys_port_cpu == ~0 ? 0 : 1)
+#define PPA_IS_PORT_ATM_AVAILABLE()	(g_phys_port_atm_wan == ~0 ? 0 : 1)
+
+#define PPA_PORT_CPU0                   g_phys_port_cpu
+#define PPA_PORT_ATM                    g_phys_port_atm_wan
+
+#define PPA_DEST_LIST_CPU0              (1 << g_phys_port_cpu)
+#define PPA_DEST_LIST_ATM               (1 << g_phys_port_atm_wan)
+
+#define PPA_PORT_ATM_VLAN_FLAGS         g_phys_port_atm_wan_vlan
+#define ETH_WAN_PORT_ID         	15
+/*  net interface type
+ */
+#define NETIF_VLAN                              0x00000001
+#define NETIF_BRIDGE                            0x00000002
+#define NETIF_PHY_ETH                           0x00000010
+#define NETIF_PHY_ATM                           0x00000020
+#define NETIF_PHY_TUNNEL                        0x00000040
+#define NETIF_BR2684                            0x00000100
+#define NETIF_EOA                               0x00000200
+#define NETIF_IPOA                              0x00000400
+#define NETIF_PPPOATM                           0x00000800
+#define NETIF_PPPOE                             0x00001000
+#define NETIF_VLAN_INNER                        0x00002000
+#define NETIF_VLAN_OUTER                        0x00004000
+#define NETIF_VLAN_CANT_SUPPORT                 0x00008000
+#define NETIF_LAN_IF                            0x00010000
+#define NETIF_WAN_IF                            0x00020000
+#define NETIF_PHY_IF_GOT                        0x00040000
+#define NETIF_PHYS_PORT_GOT                     0x00080000
+#define NETIF_MAC_AVAILABLE                     0x00100000
+#define NETIF_MAC_ENTRY_CREATED                 0x00200000
+#define NETIF_PPPOL2TP                          0x00400000
+#define NETIF_DIRECTPATH			0x00800000
+#define NETIF_GRE_TUNNEL                        0x01000000
+#define NETIF_DIRECTCONNECT                     0x02000000
+#define NETIF_L2NAT                             0x04000000
+
+/* ####################################
+ *              Data Type
+ * ####################################
+ */
+
+/* 0: CPU, 1: LAN, 2: WAN, 3: MIX (LAN/WAN)
+ * 0: CPU, 1: ATM, 2: ETH, 3: EXT
+ * 0: no VLAN, 1: inner VLAN, 2: outer VLAN
+ */
+struct phys_port_info {
+	struct phys_port_info	*next;
+	unsigned int		mode:2;
+	unsigned int		type:2;
+	unsigned int		vlan:2;
+	unsigned int		port:26;
+	PPA_IFNAME		ifname[PPA_IF_NAME_SIZE];
+};
+
+/* flag whether it is a root interface, 1 means it is a physical root interface
+ * flag: whether force wanitf set or not. 1 means the force flag is set by
+ * ppacmd/hook.
+ * flag whether wanitf value is already set or not.
+ * old lan flag value: 1 means it is LAN port, 0 means WAN port
+ */
+struct flag_wanitf {
+	uint32_t	flag_root_itf:1;
+	uint32_t	flag_force_wanitf:1;
+	uint32_t	flag_already_wanitf:1;
+	uint32_t        old_lan_flag:1;
+};
+
+enum e_flowid {
+	FLOWID_IPV4_EoGRE = 0,
+	FLOWID_IPV6_EoGRE,
+	FLOWID_IPV4GRE,
+	FLOWID_IPV6GRE,
+	FLOWID_CAPWAP
+};
+
+struct gre_tunnel_info {
+	uint32_t	pceRuleIndex;
+	/* Tunnel flow id - for egress PMAC handling  */
+	enum e_flowid	flowId;
+	/* Extension id - defined in PCE rule */
+	uint32_t	extId;
+	uint16_t	tnl_hdrlen;
+};
+
+struct netif_info {
+	struct netif_info	*next;
+	bool			enable;
+	PPA_ATOMIC		count;
+	PPA_IFNAME		name[PPA_IF_NAME_SIZE];
+	/*only for simple network interface, like macvlan, wlan multiple SSIS,
+	 * not for tunnel/pppoe/...
+	 */
+	PPA_IFNAME		manual_lower_ifname[PPA_IF_NAME_SIZE];
+	PPA_IFNAME		phys_netif_name[PPA_IF_NAME_SIZE];
+	PPA_NETIF		*netif;
+	PPA_VCC			*vcc;
+	PPA_NETIF		*brif;
+	uint8_t			mac[PPA_ETH_ALEN];
+	uint32_t		flags;
+	uint32_t		mtu;
+	/* Each bit in the flags value represents below flags info.
+	 * NETIF_VLAN, NETIF_BRIDGE, NETIF_PHY_ETH, NETIF_PHY_ATM,
+	 * NETIF_BR2684, NETIF_EOA, NETIF_IPOA, NETIF_PPPOATM,
+	 * NETIF_PPPOE, NETIF_PHY_TUNNEL
+	 * NETIF_VLAN_INNER, NETIF_VLAN_OUTER, NETIF_VLAN_CANT_SUPPORT,
+	 * NETIF_LAN_IF, NETIF_WAN_IF,
+	 * NETIF_PHY_IF_GOT, NETIF_PHYS_PORT_GOT,
+	 * NETIF_MAC_AVAILABLE, NETIF_MAC_ENTRY_CREATED
+	 */
+	uint32_t		vlan_layer;
+	uint32_t		inner_vid;
+	uint32_t		outer_vid;
+	uint32_t		pppoe_session_id;
+#if defined(L2TP_CONFIG) && L2TP_CONFIG
+	uint32_t		pppol2tp_session_id;
+	uint32_t		pppol2tp_tunnel_id;
+#endif
+	struct gre_tunnel_info	greInfo;
+	uint32_t		dslwan_qid;
+	uint32_t		phys_port;
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+	uint16_t		fid;
+	uint16_t		fid_index;
+	uint16_t		subif_id;
+#endif
+	uint8_t			tc;
+	uint8_t			flowId;
+	uint8_t			flowId_en;
+	uint32_t		mac_entry;
+	PPA_NETIF		*out_vlan_netif;
+	PPA_NETIF		*in_vlan_netif;
+	struct flag_wanitf	f_wanitf;
+#if defined(PPA_IF_MIB) && PPA_IF_MIB
+	uint8_t			sub_if_index;
+	PPA_IFNAME	sub_if_name[PPA_IF_SUB_NAME_MAX_NUM][PPA_IF_NAME_SIZE];
+	PPA_IF_STATS		hw_accel_stats;
+	PPA_IF_STATS		sw_accel_stats;
+	uint64_t		prev_clear_acc_tx;
+	uint64_t		prev_clear_acc_rx;
+#endif
+};
+
+struct iface_list {
+	PPA_IFNAME name[PPA_IF_NAME_SIZE];
+	PPA_LIST_NODE	node_ptr;
+};
+
+
+/* ####################################
+ *             Declaration
+ * ####################################
+ */
+
+/*  variable
+ */
+extern uint32_t g_phys_port_cpu;
+extern uint32_t g_phys_port_atm_wan;
+extern uint32_t g_phys_port_atm_wan_vlan;
+
+extern PPA_LIST_HEAD manual_del_iface_list;
+/*  physical network interface
+ */
+int32_t ppa_phys_port_add(PPA_IFNAME *, uint32_t);
+void ppa_phys_port_remove(uint32_t);
+int32_t ppa_phys_port_get_first_eth_lan_port(uint32_t *, PPA_IFNAME **);
+
+int32_t ppa_phys_port_start_iteration(uint32_t *, struct phys_port_info **);
+int32_t ppa_phys_port_iterate_next(uint32_t *, struct phys_port_info **);
+void ppa_phys_port_stop_iteration(void);
+
+/*  network interface
+ */
+int32_t ppa_netif_add(PPA_IFNAME *, int, struct netif_info **, PPA_IFNAME *,
+		      int);
+void ppa_netif_remove(PPA_IFNAME *, int);
+int32_t ppa_netif_lookup(PPA_IFNAME *, struct netif_info **);
+int32_t __ppa_netif_lookup(PPA_IFNAME *, struct netif_info **);
+int32_t ppa_get_netif_info(const PPA_IFNAME *ifname,
+			   struct netif_info **pp_info);
+void ppa_netif_put(struct netif_info *);
+int32_t ppa_netif_update(PPA_NETIF *, PPA_IFNAME *);
+
+int32_t ppa_netif_start_iteration(uint32_t *, struct netif_info **);
+int32_t ppa_netif_iterate_next(uint32_t *, struct netif_info **);
+void ppa_netif_stop_iteration(void);
+void ppa_netif_lock_list(void);
+void ppa_netif_unlock_list(void);
+
+
+
+/*  inline functions
+ */
+
+/*  Init/Uninit Functions
+ */
+int32_t ppa_api_netif_manager_init(void);
+void ppa_api_netif_manager_exit(void);
+int32_t ppa_api_netif_manager_create(void);
+void ppa_api_netif_manager_destroy(void);
+
+
+
+/* @} */
+#endif  /*  __PPA_API_NETIF_H__20081104_1138__ */
diff --git a/include/net/ppa/ppa_datapath.h b/include/net/ppa/ppa_datapath.h
new file mode 100644
index 000000000000..261bd09240ad
--- /dev/null
+++ b/include/net/ppa/ppa_datapath.h
@@ -0,0 +1,295 @@
+#ifndef PPA_DATAPATH_H
+#define PPA_DATAPATH_H
+/******************************************************************************
+ **
+ ** FILE NAME : ppa_datapath.h
+ ** PROJECT : UEIP
+ ** MODULES : Acceleration Package (PPA A4/D4/A5/D5)
+ **
+ ** DATE : 2 SEP 2009
+ ** AUTHOR : Xu Liang
+ ** DESCRIPTION : Acceleration Package Data Path Header File
+ ** COPYRIGHT : Copyright (c) 2017 Intel Corporation
+ ** Copyright (c) 2010 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+ ** This program is free software; you can redistribute it and/or modify
+ ** it under the terms of the GNU General Public License as published by
+ ** the Free Software Foundation; either version 2 of the License, or
+ ** (at your option) any later version.
+ **
+ ** HISTORY
+ ** $Date $Author $Comment
+ ** 2 SEP 2009 Xu Liang Initiate Version
+ *******************************************************************************/
+#include <net/ppa/ppa_ppe_hal.h>
+#include <linux/version.h>
+#ifdef CONFIG_LTQ_ETHSW_API
+#include <net/switch_api/lantiq_gsw.h>
+#endif
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+#include <net/datapath_api.h>
+#include <net/ppa/ltq_mpe_hal.h>
+#include <net/ppa/ltq_tmu_hal_api.h>
+#endif
+#include <asm/io.h>
+/*
+ * Register Operation
+ */
+#define IFX_REG_R32(_r) __raw_readl((volatile unsigned int *)(_r))
+#define IFX_REG_W32(_v, _r) __raw_writel((_v), (volatile unsigned int *)(_r))
+#define IFX_REG_W32_MASK(_clr, _set, _r) IFX_REG_W32((IFX_REG_R32((_r)) & ~(_clr)) | (_set), (_r))
+#define IFX_REG_R16(_r) __raw_readw((_r))
+#define IFX_REG_W16(_v, _r) __raw_writew((_v), (_r))
+#define IFX_REG_W16_MASK(_clr, _set, _r) IFX_REG_W16((IFX_REG_R16((_r)) & ~(_clr)) | (_set), (_r))
+#define IFX_REG_R8(_r) __raw_readb((_r))
+#define IFX_REG_W8(_v, _r) __raw_writeb((_v), (_r))
+#define IFX_REG_W8_MASK(_clr, _set, _r) IFX_REG_W8((IFX_REG_R8((_r)) & ~(_clr)) | (_set), (_r))
+/*
+ * Register manipulation macros that expect bit field defines
+ * to follow the convention that an _S suffix is appended for
+ * a shift count, while the field mask has no suffix. Or can use
+ * _M as suffix
+ */
+/* Shift first, then mask, usually for write operation */
+#define SM(_v, _f) (((_v) << _f##_S) & (_f))
+/* Mask first , then shift, usually for read operation */
+#define MS(_v, _f) (((_v) & (_f)) >> _f##_S)
+#define IFX_REG_RMW32(_set, _clr, _r) \
+	IFX_REG_W32((IFX_REG_R32((_r)) & ~(_clr)) | (_set), (_r))
+#define IFX_REG_RMW32_FILED(_f, _v, _r) \
+	IFX_REG_W32(\
+			(IFX_REG_R32((_r)) & ~(_f)) | (((_v) << (_f##_S)) & (_f)), (_r))
+#define IFX_REG_SET_BIT(_f, _r) \
+	IFX_REG_W32((IFX_REG_R32((_r)) & ~(_f)) | (_f), (_r))
+#define IFX_REG_CLR_BIT(_f, _r) \
+	IFX_REG_W32(IFX_REG_R32((_r)) & ~(_f), (_r))
+#define IFX_REG_IS_BIT_SET(_f, _r) \
+	((IFX_REG_R32((_r)) & (_f)) != 0)
+/*
+ * Bits Operation
+ */
+#define GET_BITS(x, msb, lsb) \
+	(((x) >> (lsb)) & ((1 << ((msb) + 1 - (lsb))) - 1))
+#define SET_BITS(x, msb, lsb, value) \
+	(((x) & ~(((1 << ((msb) + 1)) - 1) ^ ((1 << (lsb)) - 1))) | (((value) & ((1 << (1 + (msb) - (lsb))) - 1)) << (lsb)))
+
+#ifdef CONFIG_PPA_PORT_SEPARATION
+#ifdef CONFIG_NETWORK_EXTMARK
+#define LAN_SKB_MARK(skb, header) SET_DATA_FROM_MARK_OPT(skb->mark, LAN_PORT_SEP_MASK, LAN_PORT_SEP_START_BIT_POS, (header->sppid + 1));
+#else
+#define LAN_SKB_MARK(skb, header) skb->mark = (header->sppid + 1) << 29
+#endif
+#define WAN_SKB_MARK(skb, header) /* Do nothing */
+/* The driver increments skb mark by 1 (to avoid confuson between port 0 and packet coming from non-switch). Hence decrease by 1. */
+#ifdef CONFIG_NETWORK_EXTMARK
+#define SET_LAN_SWITCH_PORT_MAP(skb, pkth) { \
+	pkth.port_map_en	= 1; \
+	GET_DATA_FROM_MARK_OPT(skb->mark, LAN_PORT_SEP_MASK, LAN_PORT_SEP_START_BIT_POS, pkth.port_map); \
+}
+#else
+#define SET_LAN_SWITCH_PORT_MAP(skb, pkth) { \
+	pkth.port_map_en	= 1; \
+	pkth.port_map		= 1 << ((skb->mark >> 29) - 1); \
+}
+#endif
+#define SET_WAN_SWITCH_PORT_MAP(skb, pkth) /* Do nothing */
+#define PPA_PORT_SEPARATION_TX(skb, pkth, lan_port_seperate_enabled, wan_port_seperate_enabled, port) { \
+	if (lan_port_seperate_enabled && port == 0 && ((skb->mark >> LAN_PORT_SEP_START_BIT_POS) != 0)) { \
+		SET_LAN_SWITCH_PORT_MAP(skb, pkth); \
+	} else if (wan_port_seperate_enabled && port == 1) { \
+		SET_WAN_SWITCH_PORT_MAP(skb, pkth); \
+	} \
+}
+#define PPA_PORT_SEPARATION_RX(header, skb, lan_port_seperate_enabled, wan_port_seperate_enabled) { \
+	if (header->src_itf == 0) { \
+		if (lan_port_seperate_enabled) \
+		LAN_SKB_MARK(skb, header); \
+	} else { \
+		if (wan_port_seperate_enabled) \
+		WAN_SKB_MARK(skb, header); \
+	} \
+}
+#define PPA_PORT_SEPARATION_COPY_MARK(skb, new_skb) new_skb->mark = skb->mark
+#else
+#define PPA_PORT_SEPARATION_TX(skb, pkth, lan_port_seperate_enabled, wan_port_seperate_enabled, port)
+#define PPA_PORT_SEPARATION_RX(header, skb, lan_port_seperate_enabled, wan_port_seperate_enabled) { \
+	skb->mark = header->sppid << 29; \
+}
+#define PPA_PORT_SEPARATION_COPY_MARK(skb, new_skb)
+#endif
+/*
+ * ####################################
+ * Definition
+ * ####################################
+ */
+/*
+ * ATM ioctl Command
+ */
+#define PPE_ATM_IOC_MAGIC 'o'
+#define PPE_ATM_MIB_CELL _IOW(PPE_ATM_IOC_MAGIC, 0, atm_cell_ifEntry_t)
+#define PPE_ATM_MIB_AAL5 _IOW(PPE_ATM_IOC_MAGIC, 1, atm_aal5_ifEntry_t)
+#define PPE_ATM_MIB_VCC _IOWR(PPE_ATM_IOC_MAGIC, 2, atm_aal5_vcc_x_t)
+#define PPE_ATM_MAP_PKT_PRIO_TO_Q _IOR(PPE_ATM_IOC_MAGIC, 3, struct ppe_prio_q_map)
+#define PPE_ATM_TX_Q_OP _IOR(PPE_ATM_IOC_MAGIC, 4, struct tx_q_op)
+#define PPE_ATM_GET_MAP_PKT_PRIO_TO_Q _IOWR(PPE_ATM_IOC_MAGIC, 5, struct ppe_prio_q_map_all)
+#define PPE_ATM_IOC_MAXNR 6
+#define PPE_ATM_TX_Q_OP_CHG_MASK 0x01
+#define PPE_ATM_TX_Q_OP_ADD 0x02
+/*
+ * PTM ioctl Command
+ */
+#define IFX_PTM_MIB_CW_GET SIOCDEVPRIVATE + 1
+#define IFX_PTM_MIB_FRAME_GET SIOCDEVPRIVATE + 2
+#define IFX_PTM_CFG_GET SIOCDEVPRIVATE + 3
+#define IFX_PTM_CFG_SET SIOCDEVPRIVATE + 4
+#define IFX_PTM_MAP_PKT_PRIO_TO_Q ETH_MAP_PKT_PRIO_TO_Q
+/*
+ * ethernet ioctl Command
+ */
+#define SET_VLAN_COS SIOCDEVPRIVATE + 0
+#define SET_DSCP_COS SIOCDEVPRIVATE + 1
+#define ENABLE_VLAN_CLASSIFICATION SIOCDEVPRIVATE + 2
+#define DISABLE_VLAN_CLASSIFICATION SIOCDEVPRIVATE + 3
+#define VLAN_CLASS_FIRST SIOCDEVPRIVATE + 4
+#define VLAN_CLASS_SECOND SIOCDEVPRIVATE + 5
+#define ENABLE_DSCP_CLASSIFICATION SIOCDEVPRIVATE + 6
+#define DISABLE_DSCP_CLASSIFICATION SIOCDEVPRIVATE + 7
+#define PASS_UNICAST_PACKETS SIOCDEVPRIVATE + 8
+#define FILTER_UNICAST_PACKETS SIOCDEVPRIVATE + 9
+#define KEEP_BROADCAST_PACKETS SIOCDEVPRIVATE + 10
+#define DROP_BROADCAST_PACKETS SIOCDEVPRIVATE + 11
+#define KEEP_MULTICAST_PACKETS SIOCDEVPRIVATE + 12
+#define DROP_MULTICAST_PACKETS SIOCDEVPRIVATE + 13
+#define ETH_MAP_PKT_PRIO_TO_Q SIOCDEVPRIVATE + 14
+/*
+ * ####################################
+ * Data Type
+ * ####################################
+ */
+/*
+ * ATM MIB
+ */
+typedef struct {
+	__u32 ifHCInOctets_h;
+	__u32 ifHCInOctets_l;
+	__u32 ifHCOutOctets_h;
+	__u32 ifHCOutOctets_l;
+	__u32 ifInErrors;
+	__u32 ifInUnknownProtos;
+	__u32 ifOutErrors;
+} atm_cell_ifEntry_t;
+typedef struct {
+	__u32 ifHCInOctets_h;
+	__u32 ifHCInOctets_l;
+	__u32 ifHCOutOctets_h;
+	__u32 ifHCOutOctets_l;
+	__u32 ifInUcastPkts;
+	__u32 ifOutUcastPkts;
+	__u32 ifInErrors;
+	__u32 ifInDiscards;
+	__u32 ifOutErros;
+	__u32 ifOutDiscards;
+} atm_aal5_ifEntry_t;
+typedef struct {
+	__u32 aal5VccCrcErrors;
+	__u32 aal5VccSarTimeOuts;/*no timer support yet*/
+	__u32 aal5VccOverSizedSDUs;
+	__u32 aal5VccRxPDU;
+	__u32 aal5VccRxBytes;
+	__u32 aal5VccRxCell; /* reserved*/
+	__u32 aal5VccRxOAM; /* reserved*/
+	__u32 aal5VccTxPDU;
+	__u32 aal5VccTxBytes;
+	__u32 aal5VccTxDroppedPDU;
+	__u32 aal5VccTxCell; /* reserved*/
+	__u32 aal5VccTxOAM; /* reserved*/
+} atm_aal5_vcc_t;
+/*
+ * Data Type Used to Call ATM ioctl
+ */
+typedef struct {
+	int vpi;
+	int vci;
+	atm_aal5_vcc_t mib_vcc;
+} atm_aal5_vcc_x_t;
+struct ppe_prio_q_map { /* also used in ethernet ioctl*/
+	int pkt_prio;
+	int qid;
+	int vpi; /* ignored in eth interface*/
+	int vci; /* ignored in eth interface*/
+};
+struct tx_q_op {
+	int vpi;
+	int vci;
+	unsigned int flags;
+};
+struct ppe_prio_q_map_all {
+	int vpi;
+	int vci;
+	int total_queue_num;
+	int pkt_prio[8];
+	int qid[8];
+};
+/*
+ * Data Type Used to Call PTM ioctl
+ */
+typedef struct ptm_cw_ifEntry_t {
+	uint32_t ifRxNoIdleCodewords; /*!< output, number of ingress user codeword */
+	uint32_t ifRxIdleCodewords; /*!< output, number of ingress idle codeword */
+	uint32_t ifRxCodingViolation; /*!< output, number of error ingress codeword */
+	uint32_t ifTxNoIdleCodewords; /*!< output, number of egress user codeword */
+	uint32_t ifTxIdleCodewords; /*!< output, number of egress idle codeword */
+} PTM_CW_IF_ENTRY_T;
+typedef struct ptm_frame_mib_t {
+	uint32_t RxCorrect; /*!< output, number of ingress packet */
+	uint32_t TC_CrcError; /*!< output, number of egress packet with CRC error */
+	uint32_t RxDropped; /*!< output, number of dropped ingress packet */
+	uint32_t TxSend; /*!< output, number of egress packet */
+} PTM_FRAME_MIB_T;
+typedef struct ptm_cfg_t {
+	uint32_t RxEthCrcPresent; /*!< input/output, ingress packet has ETH CRC */
+	uint32_t RxEthCrcCheck; /*!< input/output, check ETH CRC of ingress packet */
+	uint32_t RxTcCrcCheck; /*!< input/output, check TC CRC of ingress codeword */
+	uint32_t RxTcCrcLen; /*!< input/output, length of TC CRC of ingress codeword */
+	uint32_t TxEthCrcGen; /*!< input/output, generate ETH CRC for egress packet */
+	uint32_t TxTcCrcGen; /*!< input/output, generate TC CRC for egress codeword */
+	uint32_t TxTcCrcLen; /*!< input/output, length of TC CRC of egress codeword */
+} IFX_PTM_CFG_T;
+/*
+ * Data Type Used to Call ethernet ioctl
+ */
+struct vlan_cos_req {
+	int pri;
+	int cos_value;
+};
+struct dscp_cos_req {
+	int dscp;
+	int cos_value;
+};
+/*
+ * ####################################
+ * Declaration
+ * ####################################
+ */
+#if defined(__KERNEL__)
+struct port_cell_info {
+	unsigned int port_num;
+	unsigned int tx_link_rate[2];
+};
+/*extern void atm_set_cell_rate(int, u32);*/
+/*extern int IFX_ATM_LED_Callback_Register(void (*)(void));*/
+/*extern int IFX_ATM_LED_Callback_Unregister(void (*)(void));*/
+#if defined(CONFIG_AMAZON_SE)
+extern unsigned int ephy_read_mdio_reg(int, int);
+extern int ephy_write_mdio_reg (int, int, u32);
+extern int ephy_auto_negotiate(int);
+#endif
+/*import API from ppa_api_hook.c--start*/
+extern int (*ppa_drv_get_dslwan_qid_with_vcc_hook)(PPA_VCC *);
+extern int (*ppa_drv_get_atm_qid_with_pkt_hook)(struct sk_buff *, void *, int);
+extern int (*ppa_drv_get_netif_qid_with_pkt_hook)(struct sk_buff *, void *, int);
+extern int (*ppa_drv_ppe_clk_change_hook)(unsigned int, unsigned int);
+extern int (*ppa_drv_ppe_pwm_change_hook)(unsigned int, unsigned int); /* arg1 - parameter, arg2 - 1: clock gating on/off, 2: power gating on/off*/
+extern int32_t (*ppa_drv_datapath_generic_hook)(PPA_GENERIC_HOOK_CMD cmd, void *buffer, uint32_t flag);
+extern int32_t (*ppa_drv_datapath_mac_entry_setting)(uint8_t *mac, uint32_t fid, uint32_t portid, uint32_t agetime, uint32_t st_entry , uint32_t action) ;
+#endif /* __KERNEL__*/
+#endif /* PPA_DATAPATH_H*/
diff --git a/include/net/ppa/ppa_drv_wrapper.h b/include/net/ppa/ppa_drv_wrapper.h
new file mode 100644
index 000000000000..a5692c29bf5b
--- /dev/null
+++ b/include/net/ppa/ppa_drv_wrapper.h
@@ -0,0 +1,151 @@
+/******************************************************************************
+**
+** FILE NAME    : ppa_drv_wrapper.h
+** PROJECT      : PPA
+** MODULES      : PPA Wrapper for PPE Driver API
+**
+** DATE         : 14 Mar 2011
+** AUTHOR       : Shao Guohua
+** DESCRIPTION  : PPA Wrapper for PPE Driver API
+** COPYRIGHT    : Copyright (c) 2017 Intel Corporation
+** Copyright (c) 2011 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+** HISTORY
+** $Date        $Author         $Comment
+** 14 MAR 2011  Shao Guohua       Initiate Version
+** 05 JUL 2017  Kamal eradath    merged ppe_drv_wrapper.h and ppa_datapath_wrapper.h
+*******************************************************************************/
+#ifndef PPA_DRV_WRAPPER_2011_03_14
+#define PPA_DRV_WRAPPER_2011_03_14
+extern uint32_t ppa_drv_dp_sb_addr_to_fpi_addr_convert(PPA_FPI_ADDR *a, uint32_t flag);
+#ifndef CONFIG_PPA_HAL_SELECTOR
+extern uint32_t ppa_drv_get_ppe_hal_id(PPA_VERSION *v, uint32_t flag);
+#endif
+extern uint32_t ppa_drv_get_firmware_id(PPA_VERSION *v, uint32_t flag);
+extern uint32_t ppa_drv_get_number_of_phys_port(PPE_COUNT_CFG *count, uint32_t flag);
+extern uint32_t ppa_drv_get_phys_port_info(PPE_IFINFO *info, uint32_t flag);
+extern uint32_t ppa_drv_get_max_entries(PPA_MAX_ENTRY_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_set_mixed_wan_vlan_id(PPE_WAN_VID_RANGE *vlan_id, uint32_t flag);
+extern uint32_t ppa_drv_get_mixed_wan_vlan_id(PPE_WAN_VID_RANGE *vlan_id, uint32_t flag);
+extern uint32_t ppa_drv_set_route_cfg(PPE_ROUTING_CFG *cfg, uint32_t flag);
+extern uint32_t ppa_drv_set_bridging_cfg(PPE_BRDG_CFG *cfg, uint32_t flag);
+extern uint32_t ppa_drv_set_fast_mode(PPE_FAST_MODE_CFG *cfg, uint32_t flag);
+extern uint32_t ppa_drv_get_acc_mode(PPE_ACC_ENABLE *acc_enable, uint32_t flag);
+extern uint32_t ppa_drv_set_acc_mode(PPE_ACC_ENABLE *acc_enable, uint32_t flag);
+extern uint32_t ppa_drv_set_default_dest_list(PPE_DEST_LIST *cfg, uint32_t flag);
+extern uint32_t ppa_drv_set_bridge_if_vlan_config(PPE_BRDG_VLAN_CFG *cfg, uint32_t flag);
+extern uint32_t ppa_drv_get_bridge_if_vlan_config(PPE_BRDG_VLAN_CFG *cfg, uint32_t flag);
+extern uint32_t ppa_drv_add_vlan_map(PPE_BRDG_VLAN_FILTER_MAP *filter, uint32_t flag);
+extern uint32_t ppa_drv_del_vlan_map(PPE_BRDG_VLAN_FILTER_MAP *filter, uint32_t flag);
+extern uint32_t ppa_drv_get_vlan_map(PPE_BRDG_VLAN_FILTER_MAP *filter , uint32_t flag);
+extern uint32_t ppa_drv_del_all_vlan_map(uint32_t flag);
+extern uint32_t ppa_drv_get_max_vfilter_entries(PPE_VFILTER_COUNT_CFG *count, uint32_t flag);
+extern uint32_t ppa_drv_is_ipv6_enabled(uint32_t flag);
+extern uint32_t ppa_drv_add_routing_entry(PPE_ROUTING_INFO *entry , uint32_t flag);
+extern uint32_t ppa_drv_del_routing_entry(PPE_ROUTING_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_update_routing_entry(PPE_ROUTING_INFO *entry , uint32_t flag);
+extern uint32_t ppa_drv_add_wan_mc_entry(PPE_MC_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_del_wan_mc_entry(PPE_MC_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_update_wan_mc_entry(PPE_MC_INFO *entry, uint32_t flag);
+#if defined(RTP_SAMPLING_ENABLE) && RTP_SAMPLING_ENABLE
+extern uint32_t ppa_drv_set_wan_mc_rtp(PPE_MC_INFO *entry);
+extern uint32_t ppa_drv_get_mc_rtp_sampling_cnt(PPE_MC_INFO *entry);
+#endif
+#if defined(MIB_MODE_ENABLE) && MIB_MODE_ENABLE
+extern uint32_t ppa_drv_set_mib_mode(PPE_MIB_MODE_ENABLE *cfg, uint32_t);
+extern uint32_t ppa_drv_get_mib_mode(PPE_MIB_MODE_ENABLE *cfg);
+#endif
+#if defined(CAP_WAP_CONFIG) && CAP_WAP_CONFIG
+extern uint32_t ppa_drv_add_capwap_entry(PPA_CMD_CAPWAP_INFO *entry , uint32_t flag);
+extern uint32_t ppa_drv_delete_capwap_entry(PPA_CMD_CAPWAP_INFO *entry , uint32_t flag);
+extern uint32_t ppa_drv_get_capwap_mib(PPA_CMD_CAPWAP_INFO *entry, uint32_t flag);
+#endif
+/*extern uint32_t ppa_drv_get_dest_ip_from_wan_mc_entry(PPE_MC_INFO *entry, uint32_t flag);*/
+extern uint32_t ppa_drv_add_bridging_entry(PPE_BR_MAC_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_del_bridging_entry(PPE_BR_MAC_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_add_tunnel_entry(PPE_TUNNEL_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_del_tunnel_entry(PPE_TUNNEL_INFO *entry, uint32_t flag);
+#if defined(L2TP_CONFIG) && L2TP_CONFIG
+extern uint32_t ppa_drv_add_l2tptunnel_entry(PPA_L2TP_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_del_l2tptunnel_entry(PPA_L2TP_INFO *entry, uint32_t flag);
+#endif
+extern uint32_t ppa_drv_add_pppoe_entry(PPE_PPPOE_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_del_pppoe_entry(PPE_PPPOE_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_get_pppoe_entry(PPE_PPPOE_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_add_mtu_entry(PPE_MTU_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_del_mtu_entry(PPE_MTU_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_get_mtu_entry(PPE_MTU_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_get_routing_entry_bytes(PPE_ROUTING_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_get_mc_entry_bytes(PPE_MC_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_add_mac_entry(PPE_ROUTE_MAC_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_del_mac_entry(PPE_ROUTE_MAC_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_get_mac_entry(PPE_ROUTE_MAC_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_add_outer_vlan_entry(PPE_OUT_VLAN_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_del_outer_vlan_entry(PPE_OUT_VLAN_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_get_outer_vlan_entry(PPE_OUT_VLAN_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_add_ipv6_entry(PPE_IPV6_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_del_ipv6_entry(PPE_IPV6_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_multifield_control(PPE_ENABLE_CFG *cfg, uint32_t flag);
+extern uint32_t ppa_drv_get_multifield_status(PPE_ENABLE_CFG *cfg, uint32_t flag);
+extern uint32_t ppa_drv_get_multifield_max_entry(PPE_COUNT_CFG *count, uint32_t flag);
+extern uint32_t ppa_drv_add_multifield_entry(PPE_MULTIFILED_FLOW *flow, uint32_t flag);
+extern uint32_t ppa_drv_get_multifield_entry(PPE_MULTIFILED_FLOW *flow, uint32_t flag);
+extern uint32_t ppa_drv_del_multifield_entry(PPE_MULTIFILED_FLOW *flow, uint32_t flag);
+extern uint32_t ppa_drv_del_multifield_entry_via_index(PPE_MULTIFILED_FLOW *flow, uint32_t flag);
+#ifdef CONFIG_PPA_QOS
+extern uint32_t ppa_drv_get_qos_status(PPA_QOS_STATUS *status, uint32_t flag);
+extern uint32_t ppa_drv_get_qos_qnum(PPE_QOS_COUNT_CFG *count, uint32_t flag);
+extern uint32_t ppa_drv_get_qos_mib(PPE_QOS_MIB_INFO *mib, uint32_t flag);
+/*#ifdef CONFIG_PPA_QOS_RATE_SHAPING*/
+extern uint32_t ppa_drv_set_ctrl_qos_rate(PPE_QOS_ENABLE_CFG *enable_cfg, uint32_t flag);
+extern uint32_t ppa_drv_get_ctrl_qos_rate(PPE_QOS_ENABLE_CFG *enable_cfg, uint32_t flag);
+extern uint32_t ppa_drv_set_qos_rate(PPE_QOS_RATE_SHAPING_CFG *cfg , uint32_t flag);
+extern uint32_t ppa_drv_get_qos_rate(PPE_QOS_RATE_SHAPING_CFG *cfg , uint32_t flag);
+extern uint32_t ppa_drv_reset_qos_rate(PPE_QOS_RATE_SHAPING_CFG *cfg , uint32_t flag);
+extern uint32_t ppa_drv_init_qos_rate(uint32_t flag);
+/*#endif*/
+/*#ifdef CONFIG_PPA_QOS_WFQ*/
+extern uint32_t ppa_drv_set_ctrl_qos_wfq(PPE_QOS_ENABLE_CFG *enable_cfg, uint32_t flag);
+extern uint32_t ppa_drv_get_ctrl_qos_wfq(PPE_QOS_ENABLE_CFG *enable_cfg, uint32_t flag);
+extern uint32_t ppa_drv_set_qos_wfq(PPE_QOS_WFQ_CFG *cfg, uint32_t flag);
+extern uint32_t ppa_drv_get_qos_wfq(PPE_QOS_WFQ_CFG *cfg, uint32_t flag);
+extern uint32_t ppa_drv_reset_qos_wfq(PPE_QOS_WFQ_CFG *cfg, uint32_t flag);
+extern uint32_t ppa_drv_init_qos_wfq(uint32_t flag);
+/*#endif*/
+#endif
+extern uint32_t ppa_drv_get_dsl_mib(PPA_DSL_QUEUE_MIB *mib, uint32_t flag);
+extern uint32_t ppa_drv_get_ports_mib(PPA_PORT_MIB *mib, uint32_t flag);
+extern uint32_t ppa_drv_get_itf_mib(PPE_ITF_MIB_INFO *mib, uint32_t flag);
+extern uint32_t ppa_drv_get_generic_itf_mib(PPA_ITF_MIB_INFO *mib, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_drv_test_and_clear_hit_stat(PPE_ROUTING_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_test_and_clear_mc_hit_stat(PPE_MC_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_test_and_clear_bridging_hit_stat(PPE_BR_MAC_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_set_value(PPA_CMD_VARIABLE_VALUE_INFO *v, uint32_t flag);
+extern uint32_t ppa_drv_get_value(PPA_CMD_VARIABLE_VALUE_INFO *v, uint32_t flag);
+extern uint32_t ppa_set_wan_itf(PPE_WANITF_CFG *cfg, uint32_t flag);
+extern uint32_t ppa_drv_hal_init(uint32_t flag);
+extern uint32_t ppa_drv_hal_exit(uint32_t flag);
+extern uint32_t ppa_get_session_hash(PPE_SESSION_HASH *cfg, uint32_t flag);
+#if defined(MBR_CONFIG) && MBR_CONFIG
+extern uint32_t ppa_drv_set_qos_shaper(PPE_QOS_RATE_SHAPING_CFG *cfg , uint32_t flag);
+extern uint32_t ppa_drv_get_qos_shaper(PPE_QOS_RATE_SHAPING_CFG *cfg , uint32_t flag);
+#endif
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+extern int ppa_drv_directpath_register(PPA_SUBIF *subif, PPA_NETIF *netif, PPA_DIRECTPATH_CB *pDirectpathCb, int32_t *index,  uint32_t flags);
+#endif
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+extern int ppa_drv_directpath_send(PPA_SUBIF *subif, PPA_SKBUF *skb, int32_t len, uint32_t flags);
+#else
+extern int ppa_drv_directpath_send(uint32_t if_id, PPA_SKBUF *skb, int32_t len, uint32_t flags);
+#endif
+extern int ppa_drv_directpath_rx_stop(uint32_t if_id, uint32_t flags);
+extern int ppa_drv_directpath_rx_start(uint32_t if_id, uint32_t flags);
+extern int ppa_drv_get_dslwan_qid_with_vcc(struct atm_vcc *vcc);
+extern int ppa_drv_get_netif_qid_with_pkt(struct sk_buff *skb, void *arg, int is_atm_vcc);
+extern int ppa_drv_ppe_clk_change(unsigned int arg, unsigned int flags);
+extern int ppa_drv_ppe_pwm_change(unsigned int arg, unsigned int flags);   /*  arg - parameter, flags - 1: clock gating on/off, 2: power gating on/off*/
+extern struct ppe_directpath_data *ppa_drv_g_ppe_directpath_data;
+extern int32_t ppa_hook_set_lan_seperate_flag(uint32_t flag);
+extern int32_t ppa_hook_get_lan_seperate_flag(uint32_t flag);
+extern uint32_t ppa_hook_set_wan_seperate_flag(uint32_t flag);
+extern uint32_t ppa_hook_get_wan_seperate_flag(uint32_t flag);
+#endif /*end of PPA_DRV_WRAPPER_2011_03_14*/
diff --git a/include/net/ppa/ppa_hal_wrapper.h b/include/net/ppa/ppa_hal_wrapper.h
new file mode 100644
index 000000000000..b7bc47628d81
--- /dev/null
+++ b/include/net/ppa/ppa_hal_wrapper.h
@@ -0,0 +1,97 @@
+/******************************************************************************
+ **
+ ** FILE NAME    : ppe_hal_wrapper.h
+ ** PROJECT      : PPA
+ ** MODULES      : PPA Wrapper for various HAL drivers
+ **
+ ** DATE         : 27 Feb 2014
+ ** AUTHOR       : Kamal Eradath
+ ** DESCRIPTION  : PPA Wrapper for HAL Driver API
+ ** COPYRIGHT    : Copyright (c) 2017 Intel Corporation
+ ** Copyright (c) 2014 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+ ** HISTORY
+ ** $Date        $Author         $Comment
+ ** 27 Feb 2014  Kamal Eradath   Initiate Version
+ *******************************************************************************/
+#ifndef PPA_HAL_WRAPPER_2014_02_27
+#define PPA_HAL_WRAPPER_2014_02_27
+#if defined(CONFIG_PPA_HAL_SELECTOR) && CONFIG_PPA_HAL_SELECTOR
+/* HAL selector table node;*/
+#ifndef MAX_TUNNEL_ENTRIES
+#define MAX_TUNNEL_ENTRIES			16
+#endif
+#define MAX_RT_SESS_CAPS 3
+#define MAX_MC_SESS_CAPS 2
+#define MAX_QOS_CAPS 2
+typedef struct ppa_hsel_cnode{
+	PPA_HLIST_NODE  cap_list;
+	uint8_t wt;
+	PPA_HAL_ID hal_id;
+	PPA_API_CAPS cap;
+} PPA_HSEL_CAP_NODE;
+extern uint8_t ppa_drv_get_num_tunnel_entries(void);
+extern uint8_t ppa_drv_get_num_registred_hals(void);
+extern uint32_t ppa_drv_generic_hal_register(uint32_t hal_id, ppa_generic_hook_t generic_hook);
+extern void ppa_drv_generic_hal_deregister(uint32_t hal_id);
+/* All the HAL layers initialized must get registered with the HAL selectors regarding the "capabilities" it supports*/
+/* This funcion must be invoked by the all HALs while hal_init is called to register all the supported capabilities*/
+extern uint32_t ppa_drv_register_cap(PPA_API_CAPS cap, uint8_t wt, PPA_HAL_ID hal_id);
+extern uint32_t ppa_drv_deregister_cap(PPA_API_CAPS cap, PPA_HAL_ID hal_id);
+/* helper functions*/
+extern int32_t ppa_select_hals_from_caplist(uint8_t start, uint8_t num_entries, PPA_HSEL_CAP_NODE *caps_list);
+extern int32_t ppa_group_hals_in_capslist(uint8_t start, uint8_t num_entries, PPA_HSEL_CAP_NODE *caps_list);
+/* **1** Functions that need to be invoked on all the HALs registered*/
+extern uint32_t ppa_drv_get_hal_id(PPA_VERSION *v, uint32_t flag);
+/* Function to be called for adding additional switch port configuration for bridge acceleration*/
+extern uint32_t ppa_drv_add_br_port(PPA_BR_PORT_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_del_br_port(PPA_BR_PORT_INFO *entry, uint32_t flag);
+extern uint32_t ppa_drv_set_hal_dbg(PPA_CMD_GENERAL_ENABLE_INFO *cfg, uint32_t flag);
+/******************************************************************************************************/
+/* functions to be used in ppa_api_hal_selector.c*/
+/******************************************************************************************************/
+extern uint32_t ppa_hsel_add_complement(PPE_ROUTING_INFO *entry , uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_del_complement(PPE_ROUTING_INFO *entry , uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_add_routing_entry(PPE_ROUTING_INFO *entry , uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_del_routing_entry(PPE_ROUTING_INFO *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_update_routing_entry(PPE_ROUTING_INFO *entry , uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_add_wan_mc_entry(PPE_MC_INFO *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_del_wan_mc_entry(PPE_MC_INFO *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_update_wan_mc_entry(PPE_MC_INFO *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_add_tunnel_entry(PPE_TUNNEL_INFO *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_del_tunnel_entry(PPE_TUNNEL_INFO *entry, uint32_t flag, uint32_t hal_id);
+#if defined(CONFIG_LTQ_TOE_DRIVER) && CONFIG_LTQ_TOE_DRIVER
+extern uint32_t ppa_hsel_add_lro_entry(PPA_LRO_INFO *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_del_lro_entry(PPA_LRO_INFO *entry, uint32_t flag, uint32_t hal_id);
+#endif /* defined(CONFIG_LTQ_TOE_DRIVER) && CONFIG_LTQ_TOE_DRIVER*/
+#if defined(CONFIG_PPA_MPE_IP97)
+extern uint32_t ppa_hsel_get_ipsec_tunnel_mib(IPSEC_TUNNEL_MIB_INFO *entry, uint32_t flag, uint32_t hal_id);
+#endif
+extern uint32_t ppa_hsel_get_routing_entry_bytes(PPE_ROUTING_INFO *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_get_mc_entry_bytes(PPE_MC_INFO *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_test_and_clear_hit_stat(PPE_ROUTING_INFO *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_test_and_clear_mc_hit_stat(PPE_MC_INFO *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_add_outer_vlan_entry(PPE_OUT_VLAN_INFO *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_del_outer_vlan_entry(PPE_OUT_VLAN_INFO *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_get_outer_vlan_entry(PPE_OUT_VLAN_INFO *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_init_qos_cfg(uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_uninit_qos_cfg(uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_add_qos_queue_entry(QOS_Q_ADD_CFG *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_modify_qos_queue_entry(QOS_Q_MOD_CFG *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_delete_qos_queue_entry(QOS_Q_DEL_CFG *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_set_qos_rate_entry(QOS_RATE_SHAPING_CFG *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_reset_qos_rate_entry(QOS_RATE_SHAPING_CFG *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_set_qos_shaper_entry(QOS_RATE_SHAPING_CFG *entry, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_mod_subif_port_cfg(QOS_MOD_SUBIF_PORT_CFG *entry, uint32_t flag, uint32_t hal_id);
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+extern uint32_t ppa_hsel_add_class_rule(PPA_CLASS_RULE *rule, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_mod_class_rule(PPA_CLASS_RULE *rule, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_del_class_rule(PPA_CLASS_RULE *rule, uint32_t flag, uint32_t hal_id);
+extern uint32_t ppa_hsel_get_class_rule(PPA_CLASS_RULE *rule, uint32_t flag, uint32_t hal_id);
+#endif
+#if defined(RTP_SAMPLING_ENABLE) && RTP_SAMPLING_ENABLE
+extern uint32_t ppa_hsel_set_wan_mc_rtp(PPE_MC_INFO *entry, uint32_t hal_id);
+extern uint32_t ppa_hsel_get_mc_rtp_sampling_cnt(PPE_MC_INFO *entry, uint32_t hal_id);
+#endif
+/******************************************************************************************************/
+#endif /*defined(CONFIG_PPA_HAL_SELECTOR) && CONFIG_PPA_HAL_SELECTOR*/
+#endif /*end of PPA_HAL_WRAPPER_2014_02_27*/
diff --git a/include/net/ppa/ppa_hook.h b/include/net/ppa/ppa_hook.h
new file mode 100644
index 000000000000..6b0260c193cd
--- /dev/null
+++ b/include/net/ppa/ppa_hook.h
@@ -0,0 +1,750 @@
+#ifndef __PPA_HOOK_H__20081103_1736__
+#define __PPA_HOOK_H__20081103_1736__
+/******************************************************************************
+ **
+ ** FILE NAME    : ppa_hook.h
+ ** PROJECT      : PPA
+ ** MODULES      : PPA Protocol Stack Hooks
+ **
+ ** DATE         : 3 NOV 2008
+ ** AUTHOR       : Xu Liang
+ ** DESCRIPTION  : PPA Protocol Stack Hook Pointers Header File
+ ** COPYRIGHT    : Copyright (c) 2017 Intel Corporation
+ ** Copyright (c) 2010 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+ ** HISTORY
+ ** $Date        $Author         $Comment
+ ** 03 NOV 2008  Xu Liang        Initiate Version
+ *******************************************************************************/
+/*! \file ppa_hook.h
+  \brief This file contains all exported HOOK API to linux Kernel and user space via ioctl API.
+ */
+#include <net/ppa/ppa_api_common.h>
+/** \addtogroup  PPA_HOOK_API */
+/*@{*/
+/*
+ * ####################################
+ *             Declaration
+ * ####################################
+ */
+#ifdef __KERNEL__
+/*!
+  \brief Add a PPA routing session entry
+  \param[in] skb Pointer to the packet buffer for which PPA session addition is to be done.
+  \param[in] p_session Points to the connection tracking session to which this packet belongs. It maybe passed as NULL in which case PPA will try to determine it using the PPA stack adaptation layer.
+  \param[in] flags  Flags as valid for the PPA session Valid \n
+  values are one or more of: \n
+  - PPA_F_SESSION_BIDIRECTIONAL \n
+  - PPA_F_BRIDGED_SESSION \n
+  - PPA_F_STATIC_ENTRY \n
+  - PPA_F_DROP_PACKET \n
+  - PPA_F_SESSION_ORG_DIR \n
+  - PPA_F_SESSION_REPLY_DIR \n
+  - PPA_F_BEFORE_NAT_TRANSFORM \n
+  \return The return value can be any one of the following:  \n
+  - PPA_SESSION_NOT_ADDED \n
+  - PPA_SESSION_ADDED \n
+  - PPA_SESSION_EXISTS \n
+  \note   Linux 2.4 Hook-up recommendation \n
+  Must be hooked into the stack before the PREROUTING and after the POSTROUTING hooks In ip_conntrack_in() function in file ip_conntrack_core.c, with the flag PPA_F_BEFORE_NAT_TRANSFORM specified. \n
+  1) In ip_finish_output2(), the hook should be invoked after NAT transforms are applied and at the very beginning of function call. \n
+  Linux 2.6 Hook-up recommendation \n
+  Must be in netfilter IPV4 or IPV6 hook PREROUTRING and POSTROUTING hooks. In nf_conntrack_in for function which is common for both IPV4 and V6 connection tracking, PPA_F_BEFORE_NAT_TRANSFORM. In ip_finish_output2(), the hook should be invoked after NAT transforms are applied at netfilter POSTROUTING hooks and at the very beginning of function call.
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_session_add_fn)(PPA_BUF *skb, PPA_SESSION *p_session, uint32_t flags);
+#else
+extern int32_t ppa_hook_session_add_fn(PPA_BUF *skb, PPA_SESSION *p_session, uint32_t flags);
+#endif
+extern int32_t (*ppa_hook_session_bradd_fn)(PPA_BUF *skb, PPA_SESSION *p_session, uint32_t flags);
+#if defined(CONFIG_PPA_MPE_IP97)
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_session_ipsec_add_fn)(PPA_XFRM_STATE *, sa_direction);
+extern int32_t (*ppa_hook_session_ipsec_del_fn)(PPA_XFRM_STATE *);
+#else
+extern int32_t ppa_hook_session_ipsec_add_fn(PPA_XFRM_STATE *, sa_direction);
+extern int32_t ppa_hook_session_ipsec_del_fn(PPA_XFRM_STATE *);
+#endif
+#endif
+/*!
+  \brief Del a PPA routing session entry
+  \param[in] p_session Points to the connection tracking session to which this packet belongs. It maybe passed as NULL in which case PPA will try to determine it using the PPA stack adaptation layer.
+  \param[in] flags Reserved currently.
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS \n
+  - PPA_FAILURE
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_session_del_fn)(PPA_SESSION *p_session, uint32_t flags);
+#else
+extern int32_t ppa_hook_session_del_fn(PPA_SESSION *p_session, uint32_t flags);
+#endif
+/*!
+  \brief It is used to get session priority  of a ppa session
+  \param[in] p_session Points to the connection tracking session to which this packet belongs. It maybe passed as NULL in which case PPA will try to determine it using the PPA stack adaptation layer.
+  \param[in] flags Reserved currently.
+  \return The return value is PPA session priority
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_session_prio_fn)(PPA_SESSION *p_session, uint32_t flags);
+#else
+extern int32_t ppa_hook_session_prio_fn(PPA_SESSION *p_session, uint32_t flags);
+#endif
+/*!
+  \brief Returns session statistics
+  \param[in]  p_session   Pointer to the session
+  \param[in]  pCtCounter  Pointer to the statistics structure
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS \n
+  - PPA_FAILURE
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_get_ct_stats_fn)(PPA_SESSION *p_session, PPA_CT_COUNTER *pCtCounter);
+#else
+extern int32_t ppa_hook_get_ct_stats_fn(PPA_SESSION *p_session, PPA_CT_COUNTER *pCtCounter);
+#endif
+/*!
+  \brief Checks if the "accelerated" PPA session should be timed out due to inactivity.
+  \param[in]  p_session Pointer to PPA unicast or multicast session.
+  \return The return value can be any one of the following:  \n
+  - PPA_TIMEOUT if the PPA session inactivity timer has expired \n
+  - PPA_HIT if the PPA session has been active
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_inactivity_status_fn)(PPA_U_SESSION *p_session);
+#else
+extern int32_t ppa_hook_inactivity_status_fn(PPA_U_SESSION *p_session);
+#endif
+/*!
+  \brief Update the session inactivity timeout for a PPA session as per the session inactivity configuration in the protocol stack.
+  \param[in] p_session Pointer to PPA unicast or multicast session.
+  \param[in] timeout  Timeout value for session inactivity in  seconds.
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS \n
+  - PPA_FAILURE \n
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_set_inactivity_fn)(PPA_U_SESSION *p_session, int32_t timeout);
+#else
+extern int32_t ppa_hook_set_inactivity_fn(PPA_U_SESSION *p_session, int32_t timeout);
+#endif
+/*!
+  \brief Add or update a MAC entry and its source ethernet port information in the PPA bridge table.
+  \param[in]  mac_addr Pointer to MAC address to add to PPA bridge table.
+  \param[in]  brif pointer to PPA net interface sttructure of the bridge.
+  \param[in]  netif   Pointer to PPA net interface which is the source of the MAC address.
+  \param[in]  flags Valid values are:
+  - PPA_F_BRIDGE_LOCAL - traffic is destined for local termination.
+  - PPA_F_STATIC_ENTRY - static MAC address entry in the PPA bridge table. It will not be aged out.
+  - PPA_F_DROP_PACKET - firewall action. Always drop packets with this MAC destination.
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS \n
+  - PPA_FAILURE \n
+  \note Static MAC entry updates and MAC address drop filters can be configured from userspace.  For dynamic entries, the function must be hooked from bridging code where new entries are inserted into bridge mac table (or forwarding database, fdb).
+  Linux 2.4 Hook-up recommendation \n
+  Hook in kernel function br_fdb_insert() in net/bridge/br_fdb.c.  For Linux bridging code, the netif is given by fdb->dst->dev field where fdb points to a MAC entry.
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_bridge_entry_add_fn)(uint8_t *mac_addr, PPA_NETIF *brif, PPA_NETIF *netif, uint32_t flags);
+#else
+extern int32_t ppa_hook_bridge_entry_add_fn(uint8_t *mac_addr, PPA_NETIF *brif, PPA_NETIF *netif, uint32_t flags);
+#endif
+/*!
+  \brief Delete a MAC entry from PPA Bridge table since the MAC entry is aged out or administratively triggered.
+  \param[in]  mac_addr Pointer to MAC address to delete from PPA bridge table.
+  \param[in]  brif pointer to PPA net interface sttructure of the bridge.
+  \param[in]  flags Reserved
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS \n
+  - PPA_FAILURE
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_bridge_entry_delete_fn)(uint8_t *mac_addr, PPA_NETIF *brif, uint32_t flags);
+#else
+extern int32_t ppa_hook_bridge_entry_delete_fn(uint8_t *mac_addr, PPA_NETIF *brif, uint32_t flags);
+#endif
+/*!
+  \brief Get latest packet arriving time for the specified MAC address entry. This is used for aging out decisions for the MAC entry.
+  \param[in]  mac_addr Pointer to MAC address whose entry hit time is being queried
+  \param[in]  brif pointer to PPA net interface sttructure of the bridge.
+  \param[out] p_hit_time Provides the latest packet arriving time in seconds from system bootup.
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS \n
+  - PPA_FAILURE
+  \note Linux 2.4 Hook-up recommendation \n
+  This API can be hooked in function br_fdb_cleanup(). In Linux, there is a kernel thread (br_fdb_cleanup) polling each entry in the MAC table and removes entries without traffic for a long time.
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_bridge_entry_hit_time_fn)(uint8_t *mac_addr, PPA_NETIF *brif, uint32_t *p_hit_time);
+#else
+extern int32_t ppa_hook_bridge_entry_hit_time_fn(uint8_t *mac_addr, PPA_NETIF *brif, uint32_t *p_hit_time);
+#endif
+#if defined(PPA_IF_MIB) && PPA_IF_MIB
+/*!
+  \brief Returns per interface statistics kept by the PPA which is a superset of the per Interface statistics above. This provides, for example, fastpath routed and bridged statistics.
+  \param[in] ifname Pointer to the interface name
+  \param[out] p_stats  Pointer to the Statistics data structure of the interface.
+  \param[in] flags Reserved.
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on sucess \n
+  - PPA_FAILURE on error
+  \note  This function is only implemented for D4 firmware.
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_get_netif_accel_stats_fn)(PPA_IFNAME *ifname, PPA_NETIF_ACCEL_STATS *p_stats, uint32_t flags);
+#else
+extern int32_t ppa_hook_get_netif_accel_stats_fn(PPA_IFNAME *ifname, PPA_NETIF_ACCEL_STATS *p_stats, uint32_t flags);
+#endif
+#endif
+#if defined(CONFIG_PPA_API_DIRECTCONNECT) && CONFIG_PPA_API_DIRECTCONNECT
+/*!
+  \brief Check if network interafce like ACA is a fastpath interface
+  \param[in] netif Pointer to the network interface structure in the protocol stack. For eg. pointer to a struct net_device
+  \param[in] ifname Interface name
+  \param[in] flags  Reserved for future use
+  \return The return value can be any one of the following:  \n
+  - 1 if ACA or WLAN fastpath interface \n
+  - 0 otherwise
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_check_if_netif_fastpath_fn)(PPA_NETIF *netif, char *ifname, uint32_t flags);
+#else
+extern int32_t ppa_check_if_netif_fastpath_fn(PPA_NETIF *netif, char *ifname, uint32_t flags);
+#endif
+/*!
+  \brief Deletes an WAVE500 STA session information from the PPA session list.
+  \param[in] dev Pointer to the network device structure in the protocol stack. For eg. pointer to a struct netdevice
+  \param[in] subif Pointer to the sub-interface structure in the datapath library.
+  \param[in] mac station mac address
+  \param[in] flags  Reserved for future use
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on sucess \n
+  - PPA_FAILURE on error
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_disconn_if_fn)(PPA_NETIF *dev, PPA_DP_SUBIF *subif, uint8_t *mac, uint32_t flags);
+#if defined(WMM_QOS_CONFIG) && WMM_QOS_CONFIG
+extern int32_t (*ppa_register_qos_class2prio_hook_fn)(int32_t port_id, PPA_NETIF *netif, PPA_QOS_CLASS2PRIO_CB qos_class2prio_cb, uint32_t flags);
+#endif /* WMM*/
+#else
+extern int32_t ppa_hook_disconn_if_fn(PPA_NETIF *dev, PPA_DP_SUBIF *subif, uint8_t *mac, uint32_t flags);
+#if defined(WMM_QOS_CONFIG) && WMM_QOS_CONFIG
+extern int32_t ppa_register_qos_class2prio_hook_fn(int32_t port_id, PPA_NETIF *netif, PPA_QOS_CLASS2PRIO_CB qos_class2prio_cb, uint32_t flags);
+#endif /* WMM*/
+#endif
+#endif
+/*!
+  \brief This function allows a device driver to register or deregister a network device to the PPA
+  \param[out] if_id  PPA specific Interface Identifier. It is currently a number between 0 to 7. This Id is returned by the PPA module
+  \param[in] dev Pointer to the network device structure in  the protocol stack. For eg. pointer to a struct netdevice
+  \param[in] pDirectpathCb   Pointer to the DirectPath callback structure which provides the driver callbacks for rx_fn, stop_tx_fn and restart_tx_fn.
+  \param[in] flags Flag to indicate if device is being registered or deregisterd. Valid values are: \n
+  PPA_F_DIRECTPATH_DEREGISTER, if de-registering, zero otherwise
+  PPA_F_DIRECTPATH_CORE1 if the driver for the network interface is running on Core 1 (i.e. 2nd CPU)
+  PPA_F_DIRECTPATH_ETH_IF if the network interface is an Ethernet-like interface
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on sucess \n
+  - PPA_FAILURE on error
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_directpath_register_dev_fn)(uint32_t *if_id, PPA_NETIF *dev, PPA_DIRECTPATH_CB *pDirectpathCb, uint32_t flags);
+#else
+extern int32_t ppa_hook_directpath_register_dev_fn(uint32_t *if_id, PPA_NETIF *dev, PPA_DIRECTPATH_CB *pDirectpathCb, uint32_t flags);
+#endif
+/*!
+  \brief This function allows a device driver to register or deregister a network device to the PPA
+  \param[out] subif  PPA specific Interface Identifier. It is currently a number between 0 to 16. This Id is returned by the PPA module
+  \param[in] dev Pointer to the network device structure in  the protocol stack. For eg. pointer to a struct netdevice
+  \param[in] pDirectpathCb   Pointer to the DirectPath callback structure which provides the driver callbacks for rx_fn, stop_tx_fn and restart_tx_fn.
+  \param[in] flags Flag to indicate if device is being registered or deregisterd. Valid values are: \n
+  PPA_F_DIRECTPATH_DEREGISTER, if de-registering, zero otherwise
+  PPA_F_DIRECTPATH_CORE1 if the driver for the network interface is running on Core 1 (i.e. 2nd CPU)
+  PPA_F_DIRECTPATH_ETH_IF if the network interface is an Ethernet-like interface
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on sucess \n
+  - PPA_FAILURE on error
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_directpath_ex_register_dev_fn)(PPA_SUBIF *subif, PPA_NETIF *dev, PPA_DIRECTPATH_CB *pDirectpathCb, uint32_t flags);
+#else
+extern int32_t ppa_hook_directpath_ex_register_dev_fn(PPA_SUBIF *subif, PPA_NETIF *dev, PPA_DIRECTPATH_CB *pDirectpathCb, uint32_t flags);
+#endif
+/*!
+  \brief This function allows a device driver to register or deregister a network device to the PPA directlink
+  \param[out] if_id  PPA virtual Interface Identifier. It is currently a number between 0 to 15. This Id is returned by the PPA module
+  \param[in] dtlk Pointer to the directlink structure. inside the structure, it has some elements:\n
+dev: pointer to network device
+vap_id:  VAP index from wifi driver
+flags:  flag to indicate the actions
+\param[in] pDirectpathCb   Pointer to the DirectPath callback structure which provides the driver callbacks for rx_fn, stop_tx_fn and restart_tx_fn.
+\param[in] flags Flag to indicate if device is being registered or deregisterd. Valid values are: \n
+PPA_F_DIRECTPATH_DEREGISTER, if de-registering, zero otherwise
+PPA_F_DIRECTPATH_CORE1 if the driver for the network interface is running on Core 1 (i.e. 2nd CPU)
+PPA_F_DIRECTPATH_ETH_IF if the network interface is an Ethernet-like interface
+\return The return value can be any one of the following:  \n
+- PPA_SUCCESS on sucess \n
+- PPA_FAILURE on error
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_directlink_register_dev_fn)(int32_t *if_id, PPA_DTLK_T *dtlk, PPA_DIRECTPATH_CB *pDirectpathCb, uint32_t flags);
+#else
+extern int32_t ppa_hook_directlink_register_dev_fn(int32_t *if_id, PPA_DTLK_T *dtlk, PPA_DIRECTPATH_CB *pDirectpathCb, uint32_t flags);
+#endif
+/*!
+  \brief This function allows the device driver to transmit a packet using the PPA DirectPath interface. The packet buffer
+  passed to the function must have its packet data pointer set to the IP header with the Ethernet
+  header/Link layer header etc preceding the IP header (For eg., on Linux skb->data points to IP header, and
+  doing the appropriate skb_push() will allow skb->data to move backwards and point to Ethernet header).
+  In other words, PPA Directpath must be able to access the full frame even though the packet buffer points to the
+  IP header as required by the Linux netif_rx() function.
+  \param[in] rx_if_id  Receive interface Id in the protocol stack
+  \param[in] buf     Pointer to the packet buffer structure of the stack for the packet which is to be transmitted
+  \param[in] len     Size of packet in bytes
+  \param[in] flags  reserved
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on sucess \n
+  - PPA_FAILURE on error
+  \note The DirectPath Tx API can have internal shortcut path to the destination or fallback to passing the packet to the
+  protocol stack. The aim is to insulate the device driver calling the API from such details. \n
+  For Linux, the driver must call this function through the hook pointer where it passes packets to the network stack by calling the netif_rx() or netif_receive_skb() functions. \n
+Note : The CPU-bound device driver is strongly recommended to call this API from tasklet mode (or equivalent non-interrupt context on non-Linux OS) and not from IRQ context for better system dynamics.
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_directpath_send_fn)(uint32_t rx_if_id, PPA_SKBUF *buf, int32_t len, uint32_t flags);
+#else
+extern int32_t ppa_hook_directpath_send_fn(uint32_t rx_if_id, PPA_SKBUF *buf, int32_t len, uint32_t flags);
+#endif
+/*!
+  \brief This function allows the device driver to transmit a packet using the PPA DirectPath interface. The packet buffer
+  passed to the function must have its packet data pointer set to the IP header with the Ethernet
+  header/Link layer header etc preceding the IP header (For eg., on Linux skb->data points to IP header, and
+  doing the appropriate skb_push() will allow skb->data to move backwards and point to Ethernet header).
+  In other words, PPA Directpath must be able to access the full frame even though the packet buffer points to the
+  IP header as required by the Linux netif_rx() function.
+  \param[in] subif  Receive interface Id and sub interface id
+  \param[in] buf     Pointer to the packet buffer structure of the stack for the packet which is to be transmitted
+  \param[in] len     Size of packet in bytes
+  \param[in] flags  reserved
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on sucess \n
+  - PPA_FAILURE on error
+  \note The DirectPath Tx API can have internal shortcut path to the destination or fallback to passing the packet to the
+  protocol stack. The aim is to insulate the device driver calling the API from such details. \n
+  For Linux, the driver must call this function through the hook pointer where it passes packets to the network stack by calling the netif_rx() or netif_receive_skb() functions. \n
+Note : The CPU-bound device driver is strongly recommended to call this API from tasklet mode (or equivalent non-interrupt context on non-Linux OS) and not from IRQ context for better system dynamics.
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_directpath_ex_send_fn)(PPA_SUBIF *subif, PPA_SKBUF *buf, int32_t len, uint32_t flags);
+#else
+extern int32_t ppa_hook_directpath_ex_send_fn(PPA_SUBIF *subif, PPA_SKBUF *buf, int32_t len, uint32_t flags);
+#endif
+/*!
+  \brief This function allows the device driver to indicate to the PPA that it cannot receive any further packets from the
+  latter. The device driver can call this function for flow control.
+  \param[in] if_id  interface Id for which to apply flow control
+  \param[in] flags  reserved
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on sucess\n
+  - PPA_FAILURE on fail\n
+  - PPA_EINVAL if the interface not exist
+  \note It is recommended for a device driver to use the PPA DirectPath flow control functions for efficient packet processing.
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_directpath_rx_stop_fn)(uint32_t if_id, uint32_t flags);
+#else
+extern int32_t ppa_hook_directpath_rx_stop_fn(uint32_t if_id, uint32_t flags);
+#endif
+/*!
+  \brief This function allows the device driver to indicate to the PPA that it cannot receive any further packets from the
+  latter. The device driver can call this function for flow control.
+  \param[in] subif  Receive interface Id and sub interface id
+  \param[in] flags  reserved
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on sucess\n
+  - PPA_FAILURE on fail\n
+  - PPA_EINVAL if the interface not exist
+  \note It is recommended for a device driver to use the PPA DirectPath flow control functions for efficient packet processing.
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_directpath_ex_rx_stop_fn)(PPA_SUBIF *subif, uint32_t flags);
+#else
+extern int32_t ppa_hook_directpath_ex_rx_stop_fn(PPA_SUBIF *subif, uint32_t flags);
+#endif
+/*!
+  \brief This function allows the device driver to indicate to the PPA that it can again receive packets from the latter. The
+  device driver can call this function for flow control after it has called the Rx Stop function to halt supply of packets
+  from the PPA.
+  \param[in] if_id  interface Id for which the driver requests the flow control action to restart transmission.
+  \param[in] flags  reserved
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on sucess\n
+  - PPA_FAILURE on fail\n
+  - PPA_EINVAL if the interface not exist
+  \note   It is recommended for a device driver to use the PPA DirectPath flow control functions for efficient packet processing. This function must be used in conjunction with the PPA_FP_STOP_TX_FN.
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_directpath_rx_restart_fn)(uint32_t if_id, uint32_t flags);
+#else
+extern int32_t ppa_hook_directpath_rx_restart_fn(uint32_t if_id, uint32_t flags);
+#endif
+/*!
+  \brief This function allows the device driver to indicate to the PPA that it can again receive packets from the latter. The
+  device driver can call this function for flow control after it has called the Rx Stop function to halt supply of packets
+  from the PPA.
+  \param[in] subif  Receive interface Id and sub interface id
+  \param[in] flags  reserved
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on sucess\n
+  - PPA_FAILURE on fail\n
+  - PPA_EINVAL if the interface not exist
+  \note   It is recommended for a device driver to use the PPA DirectPath flow control functions for efficient packet processing. This function must be used in conjunction with the PPA_FP_STOP_TX_FN.
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_directpath_ex_rx_restart_fn)(PPA_SUBIF *subif, uint32_t flags);
+#else
+extern int32_t ppa_hook_directpath_ex_rx_restart_fn(PPA_SUBIF *subif, uint32_t flags);
+#endif
+/*!
+  \brief This function allows the device driver to allocate the skb buffer.
+  \param[in] subif  Receive interface Id and sub interface id
+  \param[in] len    Length of the skb buffer
+  \param[in] flags  reserved
+  \return The return value can be any one of the following:  \n
+  - Not-null PPA_SKBUF pointer on sucess\n
+  - NULL or (void *)PPA_FAILURE or (void *)PPA_EINVAL on fail\n
+  \note      It is recommended for a device driver to recycle this buffer using ppa_hook_directpath_recycle_skb_fn function.
+ */
+#ifdef NO_DOXY
+extern PPA_SKBUF * (*ppa_hook_directpath_alloc_skb_fn)(PPA_SUBIF *psubif, int32_t len, uint32_t flags);
+#else
+extern PPA_SKBUF *ppa_hook_directpath_alloc_skb_fn(PPA_SUBIF *psubif, int32_t len, uint32_t flags);
+#endif
+/*!
+  \brief This function allows the device driver to de-allocate the skb buffer.
+  \param[in] subif  Receive interface Id and sub interface id
+  \param[in] skb    Allocated skb pointer
+  \param[in] flags  reserved
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on sucess\n
+  - PPA_FAILURE on fail\n
+  - PPA_EINVAL if the interface not exist
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_directpath_recycle_skb_fn)(PPA_SUBIF *psubif, PPA_SKBUF *skb, uint32_t flags);
+#else
+extern int32_t ppa_hook_directpath_recycle_skb_fn(PPA_SUBIF *psubif, PPA_SKBUF *skb, uint32_t flags);
+#endif
+/*!
+  \brief This function maps the Protocol stack interface structure to the PPA Interface Id.
+  \param[in] netif Pointer to the protocol stack network interface structure for the device
+  \return The return value can be any one of the following: \n
+  - PPA Interface Identifier, if_id \n
+  - PPA_FAILURE
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_get_ifid_for_netif_fn)(PPA_NETIF *netif);
+#else
+extern int32_t ppa_hook_get_ifid_for_netif_fn(PPA_NETIF *netif);
+#endif
+#ifdef CONFIG_PPA_QOS
+/*!
+  \brief This is to get the maximum queue number supported on specified port
+  \param[in] portid the physical port id which support qos queue
+  \param[in] flag reserved for future
+  \return returns the queue number supported on this port.
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_get_qos_qnum)(uint32_t portid, uint32_t flag);
+#else
+extern int32_t ppa_hook_get_qos_qnum(uint32_t portid, uint32_t flag);
+#endif
+/*!
+  \brief This is to get the mib counter on specified port and queueid
+  \param[in] portid the physical port id which support qos queue
+  \param[in] queueid the queue id for the mib
+  \param[out] mib the buffer to store qos mib
+  \param[in] flag reserved for future
+  \return returns the queue number supported on this port.
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_get_qos_mib)(uint32_t portid, uint32_t queueid, PPA_QOS_MIB *mib, uint32_t flag);
+#else
+extern int32_t ppa_hook_get_qos_mib(uint32_t portid, uint32_t queueid, PPA_QOS_MIB *mib, uint32_t flag);
+#endif
+#ifdef CONFIG_PPA_QOS_RATE_SHAPING
+/*!
+  \brief This is to eanble/disable Rate Shaping feature
+  \param[in] portid the phisical port id which support qos queue
+  \param[in] enable 1:enable 0: disable
+  \param[in] flag reserved for future
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on success \n
+  - PPA_FAILURE on error \n
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_set_ctrl_qos_rate)(uint32_t portid, uint32_t enable, uint32_t flag);
+#else
+extern int32_t ppa_hook_set_ctrl_qos_rate(uint32_t portid, uint32_t enable, uint32_t flag);
+#endif
+/*!
+  \brief This is to get Rate Shaping feature status: enabled or disabled
+  \param[in] portid the phisical port id which support qos queue
+  \param[out] enable buffer to store status: 1:enable 0: disable
+  \param[in] flag reserved for future
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on success \n
+  - PPA_FAILURE on error \n
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_get_ctrl_qos_rate)(uint32_t portid, uint32_t *enable, uint32_t flag);
+#else
+extern int32_t ppa_hook_get_ctrl_qos_rate(uint32_t portid, uint32_t *enable, uint32_t flag);
+#endif
+/*!
+  \brief This is to set Rate Shaping for one specified port and queue
+  \param[in] portid the phisical port id which support qos queue
+  \param[in] queueid the queue id need to set rate shaping
+  \param[in] rate the maximum rate limit in kbps
+  \param[in] burst the maximun burst in bytes
+  \param[in] flag reserved for future
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on success \n
+  - PPA_FAILURE on error \n
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_set_qos_rate)(uint32_t portid, uint32_t queueid, uint32_t rate, uint32_t burst, uint32_t flag);
+#else
+extern int32_t ppa_hook_set_qos_rate(uint32_t portid, uint32_t queueid, uint32_t rate, uint32_t burst, uint32_t flag);
+#endif
+/*!
+  \brief This is to get Rate Shaping settings for one specified port and queue
+  \param[in] portid the phisical port id which support qos queue
+  \param[in] queueid the queue id need to set rate shaping
+  \param[out] rate the maximum rate limit in kbps
+  \param[out] burst the maximun burst in bytes
+  \param[in] flag reserved for future
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on success \n
+  - PPA_FAILURE on error \n
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_get_qos_rate)(uint32_t portid, uint32_t queueid, uint32_t *rate, uint32_t *burst, uint32_t flag);
+#else
+extern int32_t ppa_hook_get_qos_rate(uint32_t portid, uint32_t queueid, uint32_t *rate, uint32_t *burst, uint32_t flag);
+#endif
+/*!
+  \brief This is to reset Rate Shaping for one specified port and queue (
+  \param[in] portid the phisical port id which support qos queue
+  \param[in] queueid the queue id need to set rate shaping
+  \param[in] flag reserved for future
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on success \n
+  - PPA_FAILURE on error \n
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_reset_qos_rate)(uint32_t portid, uint32_t queueid, uint32_t flag);
+#else
+extern int32_t ppa_hook_reset_qos_rate(uint32_t portid, uint32_t queueid, uint32_t flag);
+#endif
+#endif /*end of CONFIG_PPA_QOS_RATE_SHAPING*/
+#ifdef CONFIG_PPA_QOS_WFQ
+/*!
+  \brief This is to eanble/disable WFQ feature
+  \param[in] portid the phisical port id which support qos queue
+  \param[in] enable 1:enable 0: disable
+  \param[in] flag reserved for future
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on success \n
+  - PPA_FAILURE on error \n
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_set_ctrl_qos_wfq)(uint32_t portid, uint32_t enable, uint32_t flag);
+#else
+extern int32_t ppa_hook_set_ctrl_qos_wfq(uint32_t portid, uint32_t enable, uint32_t flag);
+#endif
+/*!
+  \brief This is to get WFQ feature status: enabled or disabled
+  \param[in] portid the phisical port id which support qos queue
+  \param[out] enable 1:enable 0: disable
+  \param[in] flag reserved for future
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on success \n
+  - PPA_FAILURE on error \n
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_get_ctrl_qos_wfq)(uint32_t portid, uint32_t *enable, uint32_t flag);
+#else
+extern int32_t ppa_hook_get_ctrl_qos_wfq(uint32_t portid, uint32_t *enable, uint32_t flag);
+#endif
+/*!
+  \brief This is to set WFQ weight level for one specified port and queue
+  \param[in] portid the phisical port id which support qos queue
+  \param[in] queueid the queue id need to set WFQ
+  \param[out] weight_level the value should be 0 ~ 100.
+  \param[in] flag reserved for future
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on success \n
+  - PPA_FAILURE on error \n
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_set_qos_wfq)(uint32_t portid, uint32_t queueid, uint32_t weight_level, uint32_t flag);
+#else
+extern int32_t ppa_hook_set_qos_wfq(uint32_t portid, uint32_t queueid, uint32_t weight_level, uint32_t flag);
+#endif
+/*!
+  \brief This is to get WFQ settings for one specified port and queue (default value should be 0xFFFF)
+  \param[in] portid the phisical port id which support qos queue
+  \param[in] queueid the queue id need to set WFQ
+  \param[out] weight_level the value should be 0 ~ 100.
+  \param[in] flag reserved for future
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on success \n
+  - PPA_FAILURE on error \n
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_get_qos_wfq)(uint32_t portid, uint32_t queueid, uint32_t *weight_level, uint32_t flag);
+#else
+extern int32_t ppa_hook_get_qos_wfq(uint32_t portid, uint32_t queueid, uint32_t *weight_level, uint32_t flag);
+#endif
+/*!
+  \brief This is to reset WFQ for one specified port and queue (default value should be 0xFFFF)
+  \param[in] portid the phisical port id which support qos queue
+  \param[in] queueid the queue id need to set WFQ
+  \param[in] flag reserved for future
+  \return The return value can be any one of the following:  \n
+  - PPA_SUCCESS on success \n
+  - PPA_FAILURE on error \n
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_reset_qos_wfq)(uint32_t portid, uint32_t queueid, uint32_t flag);
+#else
+extern int32_t ppa_hook_reset_qos_wfq(uint32_t portid, uint32_t queueid, uint32_t flag);
+#endif
+#endif /*end of CONFIG_PPA_QOS_WFQ*/
+#endif /*end of CONFIG_PPA_QOS*/
+/*#ifdef CONFIG_PPA_GRE*/
+extern uint32_t (*ppa_is_ipv4_gretap_fn)(struct net_device *dev);
+extern uint32_t (*ppa_is_ipv6_gretap_fn)(struct net_device *dev);
+/*#endif*/
+extern int32_t (*ppa_ppp_get_chan_info_fn)(struct net_device *ppp_dev, struct ppp_channel **chan);
+extern int32_t (*ppa_check_pppoe_addr_valid_fn)(struct net_device *dev, struct pppoe_addr *pa);
+extern int32_t (*ppa_get_pppoa_info_fn)(struct net_device *dev, void *pvcc, uint32_t pppoa_id, void *value);
+extern int32_t (*ppa_get_pppol2tp_info_fn)(struct net_device *dev, void *po, uint32_t pppol2tp_id, void *value);
+extern int32_t (*ppa_if_is_ipoa_fn)(struct net_device *netdev, char *ifname);
+extern int32_t (*ppa_if_is_br2684_fn)(struct net_device *netdev, char *ifname);
+extern int32_t (*ppa_br2684_get_vcc_fn)(struct net_device *netdev, struct atm_vcc **pvcc);
+extern int32_t (*ppa_if_ops_veth_xmit_fn)(struct net_device *dev);
+/*!
+  \brief This is to enqueue skb to linux imq for rateshaping
+  \param[in] skb skb buffer
+  \param[in] portID directpath port id
+  \return int32_t, The return value can be 0 or 1
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_directpath_enqueue_to_imq_fn)(PPA_SKBUF *skb, uint32_t portID);
+#else
+extern int32_t ppa_hook_directpath_enqueue_to_imq_fn(PPA_SKBUF *skb, uint32_t portID);
+#endif
+/*!
+  \brief This is to reinject skb from linux imq for rateshaping
+  \param[in] rx_if_id Recive interface id
+  \param[in] buf skb buffer
+  \param[in] len
+  \param[in] flags
+  \return int32_t, The return value can be 0 or 1
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_directpath_reinject_from_imq_fn)(int32_t rx_if_id, PPA_SKBUF *buf, int32_t len, uint32_t flags);
+#else
+extern int32_t ppa_hook_directpath_reinject_from_imq_fn(int32_t rx_if_id, PPA_SKBUF *buf, int32_t len, uint32_t flags);
+#endif
+/*!
+  \brief This is to set the lan separation flag
+  \param[in] flag Lan separation flag
+  \return int32_t, The return value can be 0 or 1
+ */
+#ifdef NO_DOXY
+extern int32_t(*ppa_hook_set_lan_seperate_flag_fn)(uint32_t flag);
+#else
+extern int32_t ppa_hook_set_lan_seperate_flag_fn(uint32_t flag);
+#endif
+/*!
+  \brief This is to set the wan separation flag
+  \param[in] flag Wan separation flag
+  \return int32_t, The return value can be 0 or 1
+ */
+#ifdef NO_DOXY
+extern int32_t(*ppa_hook_set_wan_seperate_flag_fn)(uint32_t flag);
+#else
+extern int32_t ppa_hook_set_wan_seperate_flag_fn (uint32_t flag);
+#endif
+/*!
+  \brief This is to get the lan separation flag
+  \param[in] flag Lan separation flag
+  \return int32_t, The return value can be 0 or 1
+ */
+#ifdef NO_DOXY
+extern uint32_t (*ppa_hook_get_lan_seperate_flag_fn)(uint32_t flag);
+#else
+extern uint32_t ppa_hook_get_lan_seperate_flag_fn(uint32_t flag);
+#endif
+/*!
+  \brief This is to get the wan separation flag
+  \param[in] flag Wan separation flag
+  \return int32_t, The return value can be 0 or 1
+ */
+#ifdef NO_DOXY
+extern uint32_t (*ppa_hook_get_wan_seperate_flag_fn)(uint32_t flag);
+#else
+extern uint32_t ppa_hook_get_wan_seperate_flag_fn(uint32_t flag);
+#endif
+#if defined(CONFIG_PPA_API_SW_FASTPATH)
+/*!
+  \brief This is to send skb through software fastpath
+  \param[in] skb skb buffer
+  \return int32_t, The return value can be 0 or 1
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_sw_fastpath_send_fn)(struct sk_buff *skb);
+#else
+extern int32_t ppa_hook_sw_fastpath_send_fn(struct sk_buff *skb);
+#endif
+/*!
+  \brief This is to enable software fastpath
+  \param[in] flags for software fp enable disable
+  \return int32_t, The return value can be 0 or 1
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_set_sw_fastpath_enable_fn)(uint32_t flags);
+#else
+extern int32_t ppa_hook_set_sw_fastpath_enable_fn(uint32_t *flags);
+#endif
+/*!
+  \brief This is to get software fastpath status
+  \param[in] flags for software fp enable disable
+  \return int32_t, The return value can be 0 or 1
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_hook_get_sw_fastpath_status_fn)(uint32_t flags);
+#else
+extern int32_t ppa_hook_get_sw_fastpath_status_fn(uint32_t *flags);
+#endif
+#endif
+#if defined(CONFIG_L2NAT_MODULE) || defined(CONFIG_L2NAT)
+/*!
+  \brief Check if network interafce is a part of l2nat
+  \param[in] netif Pointer to the network interface structure in the protocol stack. For eg. pointer to a struct net_device
+  \param[in] ifname Interface name
+  \param[in] flags  Reserved for future use
+  \return The return value can be any one of the following:  \n
+  - 1 if network interafce is a part of l2nat \n
+  - 0 otherwise
+ */
+#ifdef NO_DOXY
+extern int32_t (*ppa_check_if_netif_l2nat_fn)(PPA_NETIF *netif, char *ifname, uint32_t flags);
+#else
+extern int32_t ppa_check_if_netif_l2nat_fn(PPA_NETIF *netif, char *ifname, uint32_t flags);
+#endif
+#endif /* CONFIG_L2NAT*/
+#endif /*end of __KERNEL__*/
+/* @} */
+#endif  /*  __PPA_HOOK_H__20081103_1736__*/
diff --git a/include/net/ppa/ppa_ppe_hal.h b/include/net/ppa/ppa_ppe_hal.h
new file mode 100644
index 000000000000..8fdc31479cb7
--- /dev/null
+++ b/include/net/ppa/ppa_ppe_hal.h
@@ -0,0 +1,367 @@
+#ifndef __PPA_PPE_HAL_H__20081104_1318__
+#define __PPA_PPE_HAL_H__20081104_1318__
+/*******************************************************************************
+ **
+ ** FILE NAME    : ppa_ppe_hal.h
+ ** PROJECT      : PPA
+ ** MODULES      : PPA API (Routing/Bridging Acceleration APIs)
+ **
+ ** DATE         : 4 NOV 2008
+ ** AUTHOR       : Xu Liang
+ ** DESCRIPTION  : PPA PPE Firmware Hardware/Firmware Adaption Layer Header File
+ ** COPYRIGHT   : Copyright (c) 2017 Intel Corporation
+ ** Copyright (c) 2010 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+ **
+ ** HISTORY
+ ** $Date        $Author         $Comment
+ ** 04 NOV 2008  Xu Liang        Initiate Version
+ *******************************************************************************/
+/*
+ * ####################################
+ *              Definition
+ * ####################################
+ */
+#define PPA_IF_NOT_FOUND                            0
+#define PPA_IF_TYPE_LAN                             1
+#define PPA_IF_TYPE_WAN                             2
+#define PPA_IF_TYPE_MIX                             3
+#define PPA_ACC_MODE_NONE                           0
+#define PPA_ACC_MODE_BRIDGING                       1
+#define PPA_ACC_MODE_ROUTING                        2
+#define PPA_ACC_MODE_HYBRID                         3
+#define PPA_SET_ROUTE_CFG_ENTRY_NUM                 0x01
+#define PPA_SET_ROUTE_CFG_MC_ENTRY_NUM              0x02
+#define PPA_SET_ROUTE_CFG_IP_VERIFY                 0x04
+#define PPA_SET_ROUTE_CFG_TCPUDP_VERIFY             0x08
+#define PPA_SET_ROUTE_CFG_TCPUDP_ERR_DROP           0x10
+#define PPA_SET_ROUTE_CFG_DROP_ON_NOT_HIT           0x20
+#define PPA_SET_ROUTE_CFG_MC_DROP_ON_NOT_HIT        0x40
+#define PPA_SET_BRIDGING_CFG_ENTRY_NUM              0x01
+#define PPA_SET_BRIDGING_CFG_BR_TO_SRC_PORT_EN      0x02
+#define PPA_SET_BRIDGING_CFG_DEST_VLAN_EN           0x04
+#define PPA_SET_BRIDGING_CFG_SRC_VLAN_EN            0x08
+#define PPA_SET_BRIDGING_CFG_MAC_CHANGE_DROP        0x10
+#define PPA_ROUTE_TYPE_NULL                         0
+#define PPA_ROUTE_TYPE_IPV4                         1
+#define PPA_ROUTE_TYPE_NAT                          2
+#define PPA_ROUTE_TYPE_NAPT                         3
+/*#define PPA_DEST_LIST_ETH0                          0x01*/
+/*#define PPA_DEST_LIST_ETH1                          0x02*/
+/*#define PPA_DEST_LIST_CPU0                          0x04*/
+/*#define PPA_DEST_LIST_EXT_INT1                      0x08*/
+/*#define PPA_DEST_LIST_EXT_INT2                      0x10*/
+/*#define PPA_DEST_LIST_EXT_INT3                      0x20*/
+/*#define PPA_DEST_LIST_EXT_INT4                      0x40*/
+/*#define PPA_DEST_LIST_EXT_INT5                      0x80*/
+/*#define PPA_DEST_LIST_ATM                           PPA_DEST_LIST_EXT_INT5    EoA*/
+/*#define PPA_DEST_LIST_ETH0                          0x0001*/
+/*#define PPA_DEST_LIST_ETH1                          0x0002*/
+/*#define PPA_DEST_LIST_CPU0                          0x0004*/
+/*#define PPA_DEST_LIST_EXT_INT1                      0x0008*/
+/*#define PPA_DEST_LIST_EXT_INT2                      0x0010*/
+/*#define PPA_DEST_LIST_EXT_INT3                      0x0020*/
+/*#define PPA_DEST_LIST_EXT_INT4                      0x0040*/
+/*#define PPA_DEST_LIST_EXT_INT5                      0x0080*/
+/*#define PPA_DEST_LIST_ATM                           0x0100*/
+/*#define PPA_DEST_LIST_NO_REMAP                      (1 << 31)*/
+#define PPA_PHYS_PORT_FLAGS_VALID                   0x0001
+#define PPA_PHYS_PORT_FLAGS_TYPE_CPU                0x0000
+#define PPA_PHYS_PORT_FLAGS_TYPE_ATM                0x0010
+#define PPA_PHYS_PORT_FLAGS_TYPE_ETH                0x0020
+#define PPA_PHYS_PORT_FLAGS_TYPE_EXT                0x0030
+#define PPA_PHYS_PORT_FLAGS_TYPE_MASK               0x0030
+#define PPA_PHYS_PORT_FLAGS_MODE_LAN                0x0100
+#define PPA_PHYS_PORT_FLAGS_MODE_WAN                0x0200
+#define PPA_PHYS_PORT_FLAGS_MODE_MIX                (PPA_PHYS_PORT_FLAGS_MODE_LAN | PPA_PHYS_PORT_FLAGS_MODE_WAN)
+#define PPA_PHYS_PORT_FLAGS_MODE_MASK               0x0300
+#define PPA_PHYS_PORT_FLAGS_OUTER_VLAN              0x1000
+#define PPA_PHYS_PORT_FLAGS_EXT_CPU0                0x4000
+#define PPA_PHYS_PORT_FLAGS_EXT_CPU1                0x8000
+#define PPA_PHYS_PORT_FLAGS_MODE_ETH_LAN_VALID      (PPA_PHYS_PORT_FLAGS_TYPE_ETH | PPA_PHYS_PORT_FLAGS_MODE_LAN | PPA_PHYS_PORT_FLAGS_VALID)
+#define PPA_PHYS_PORT_FLAGS_MODE_ETH_WAN_VALID      (PPA_PHYS_PORT_FLAGS_TYPE_ETH | PPA_PHYS_PORT_FLAGS_MODE_WAN | PPA_PHYS_PORT_FLAGS_VALID)
+#define PPA_PHYS_PORT_FLAGS_MODE_ETH_MIX_VALID      (PPA_PHYS_PORT_FLAGS_TYPE_ETH | PPA_PHYS_PORT_FLAGS_MODE_MIX | PPA_PHYS_PORT_FLAGS_VALID)
+#define PPA_PHYS_PORT_FLAGS_MODE_CPU_VALID          (PPA_PHYS_PORT_FLAGS_TYPE_CPU | PPA_PHYS_PORT_FLAGS_VALID)
+#define PPA_PHYS_PORT_FLAGS_MODE_ATM_WAN_VALID      (PPA_PHYS_PORT_FLAGS_TYPE_ATM | PPA_PHYS_PORT_FLAGS_MODE_WAN | PPA_PHYS_PORT_FLAGS_VALID)
+#define PPA_PHYS_PORT_FLAGS_MODE_EXT_LAN_VALID      (PPA_PHYS_PORT_FLAGS_TYPE_EXT | PPA_PHYS_PORT_FLAGS_MODE_LAN | PPA_PHYS_PORT_FLAGS_VALID)
+#define PPA_PHYS_PORT_FLAGS_MODE_EXT_WAN_VALID		(PPA_PHYS_PORT_FLAGS_TYPE_EXT | PPA_PHYS_PORT_FLAGS_MODE_WAN | PPA_PHYS_PORT_FLAGS_VALID)
+#define PPA_PPPOE_MODE_TRANSPARENT                  0
+#define PPA_PPPOE_MODE_TERMINATION                  1
+#define PPA_UPDATE_ROUTING_ENTRY_ROUTE_TYPE         0x0001
+#define PPA_UPDATE_ROUTING_ENTRY_NEW_IP             0x0002
+#define PPA_UPDATE_ROUTING_ENTRY_NEW_PORT           0x0004
+#define PPA_UPDATE_ROUTING_ENTRY_NEW_MAC            0x0008
+#define PPA_UPDATE_ROUTING_ENTRY_NEW_SRC_MAC_IX     0x0010
+#define PPA_UPDATE_ROUTING_ENTRY_MTU_IX             0x0020
+#define PPA_UPDATE_ROUTING_ENTRY_NEW_DSCP_EN        0x0040
+#define PPA_UPDATE_ROUTING_ENTRY_NEW_DSCP           0x0080
+#define PPA_UPDATE_ROUTING_ENTRY_VLAN_INS_EN        0x0100
+#define PPA_UPDATE_ROUTING_ENTRY_NEW_VCI            0x0200
+#define PPA_UPDATE_ROUTING_ENTRY_VLAN_RM_EN         0x0400
+#define PPA_UPDATE_ROUTING_ENTRY_PPPOE_MODE         0x0800
+#define PPA_UPDATE_ROUTING_ENTRY_PPPOE_IX           0x1000
+#define PPA_UPDATE_ROUTING_ENTRY_OUT_VLAN_INS_EN    0x0100
+#define PPA_UPDATE_ROUTING_ENTRY_OUT_VLAN_IX        0x0200
+#define PPA_UPDATE_ROUTING_ENTRY_OUT_VLAN_RM_EN     0x0400
+#define PPA_UPDATE_ROUTING_ENTRY_DEST_LIST          0x2000
+#define PPA_UPDATE_ROUTING_ENTRY_DEST_QID           0x4000
+#define PPA_UPDATE_WAN_MC_ENTRY_VLAN_INS_EN         0x0001
+#define PPA_UPDATE_WAN_MC_ENTRY_NEW_VCI             0x0002
+#define PPA_UPDATE_WAN_MC_ENTRY_VLAN_RM_EN          0x0004
+#define PPA_UPDATE_WAN_MC_ENTRY_SRC_MAC_EN          0x0008
+#define PPA_UPDATE_WAN_MC_ENTRY_SRC_MAC_IX          0x0010
+#define PPA_UPDATE_WAN_MC_ENTRY_DEST_LIST           0x0020
+#define PPA_UPDATE_WAN_MC_ENTRY_DEST_CHID           0x0040
+#define PPA_UPDATE_WAN_MC_ENTRY_PPPOE_MODE          0x0080
+#define PPA_UPDATE_WAN_MC_ENTRY_OUT_VLAN_INS_EN     0x0100
+#define PPA_UPDATE_WAN_MC_ENTRY_OUT_VLAN_IX         0x0200
+#define PPA_UPDATE_WAN_MC_ENTRY_OUT_VLAN_RM_EN      0x0400
+#define PPA_UPDATE_WAN_MC_ENTRY_NEW_DSCP_EN         0x0800
+#define PPA_UPDATE_WAN_MC_ENTRY_NEW_DSCP            0x1000
+#define PPA_UPDATE_WAN_MC_ENTRY_DEST_QID            PPA_UPDATE_WAN_MC_ENTRY_DEST_CHID
+#define PPA_ADD_MAC_ENTRY_PPPOE                     0x01
+#define PPA_ADD_MAC_ENTRY_LAN                       0x02
+#define PPA_ADD_MAC_ENTRY_WAN                       0x00
+#define PPA_SET_FAST_MODE_CPU1                      0x01
+#define PPA_SET_FAST_MODE_APP2                      PPA_SET_FAST_MODE_CPU1
+#define PPA_SET_FAST_MODE_ETH1                      0x02
+#define PPA_SET_FAST_MODE_ATM                       PPA_SET_FAST_MODE_ETH1
+#define PPA_SET_FAST_MODE_CPU1_DIRECT               PPA_SET_FAST_MODE_CPU1
+#define PPA_SET_FAST_MODE_CPU1_INDIRECT             0
+#define PPA_SET_FAST_MODE_APP2_DIRECT               PPA_SET_FAST_MODE_CPU1_DIRECT
+#define PPA_SET_FAST_MODE_APP2_INDIRECT             PPA_SET_FAST_MODE_CPU1_INDIRECT
+#define PPA_SET_FAST_MODE_ETH1_DIRECT               PPA_SET_FAST_MODE_ETH1
+#define PPA_SET_FAST_MODE_ETH1_INDIRECT             0
+#define PPA_SET_FAST_MODE_ATM_DIRECT                PPA_SET_FAST_MODE_ETH1_DIRECT
+#define PPA_SET_FAST_MODE_ATM_INDIRECT              PPA_SET_FAST_MODE_ETH1_INDIRECT
+/*#define PPA_PORT_ETH0                               0x00*/
+/*#define PPA_PORT_ETH1                               0x01*/
+/*#define PPA_PORT_CPU0                               0x02*/
+/*#define PPA_PORT_CPU1_EXT_IF0                       0x05*/
+/*#define PPA_PORT_ATM                                0x07*/
+/*#define PPA_PORT_ANY                                PPA_PORT_CPU0*/
+/*#define PPA_PORT_NUM                                0x08*/
+/*  Obsolete, for bridging only*/
+/*#define PPA_PORT_ETH0                               0x00*/
+/*#define PPA_PORT_ETH1                               0x01*/
+/*#define PPA_PORT_CPU0                               0x02*/
+/*#define PPA_PORT_CPU1_EXT_IF0                       0x05*/
+/*#define PPA_PORT_ATM                                0x08*/
+/*#define PPA_PORT_ANY                                PPA_PORT_CPU0*/
+/*#define PPA_PORT_NUM                                0x09*/
+#define PPA_BRG_VLAN_IG_COND_TYPE_DEF               0
+#define PPA_BRG_VLAN_IG_COND_TYPE_SRC_IP            1
+#define PPA_BRG_VLAN_IG_COND_TYPE_ETH_TYPE          2
+#define PPA_BRG_VLAN_IG_COND_TYPE_VLAN              3
+typedef enum {
+	PPA_GENERIC_HAL_GET_DSL_MIB = 0,   /*Get dsl mib*/
+	PPA_GENERIC_HAL_CLEAR_DSL_MIB,   /*clear dsl mib*/
+	PPA_GENERIC_WAN_INFO,   /*get wan information*/
+	PPA_GENERIC_HAL_GET_PORT_MIB,  /*get alls ports mib*/
+	PPA_GENERIC_HAL_SET_DEBUG,    /* turn on/off hal debug information*/
+	PPA_GENERIC_HAL_GET_FEATURE_LIST, /*get featuer list*/
+	/*Fix warning message when exports API from different PPE FW Driver--begin*/
+	PPA_GENERIC_HAL_GET_MAX_ENTRIES,  /*get maximum ipv4 routing entry number*/
+	PPA_GENERIC_HAL_GET_HAL_VERSION,  /*get hal version number*/
+	PPA_GENERIC_HAL_GET_PPE_FW_VERSION,  /*get ppe fw version number*/
+	PPA_GENERIC_HAL_GET_PHYS_PORT_NUM,  /*get maixum physical port number*/
+	PPA_GENERIC_HAL_GET_PHYS_PORT_INFO,  /*get physical port information*/
+	PPA_GENERIC_HAL_SET_MIX_WAN_VLAN_ID,  /*set WAN interface's vlan range for mixed mode*/
+	PPA_GENERIC_HAL_GET_MIX_WAN_VLAN_ID,  /*get WAN interface's vlan range for mixed mode*/
+	PPA_GENERIC_HAL_SET_ROUT_CFG,   /*set routing configuration*/
+	PPA_GENERIC_HAL_SET_BRDG_CFG,  /*set bridge confgiration*/
+	PPA_GENERIC_HAL_SET_FAST_MODE_CFG,  /*set fact mode configuration*/
+	PPA_GENERIC_HAL_SET_DEST_LIST,  /* set destion list*/
+	PPA_GENERIC_HAL_SET_ACC_ENABLE,  /* eanble/disable Lan/wan routing acceleration respectively*/
+	PPA_GENERIC_HAL_GET_ACC_ENABLE,  /*get lan/wan routing eanble flag*/
+	PPA_GENERIC_HAL_SET_BRDG_VLAN_CFG,  /*set vlan briding configuration for a4/d4/e4 only*/
+	PPA_GENERIC_HAL_GET_BRDG_VLAN_CFG,  /*get vlan briding configuration for a4/d4/e4 only*/
+	PPA_GENERIC_HAL_ADD_BRDG_VLAN_FITLER, /*set vlan briding flow  for a4/d4/e4 only*/
+	PPA_GENERIC_HAL_DEL_BRDG_VLAN_FITLER,  /*del vlan briding flow  for a4/d4/e4 only*/
+	PPA_GENERIC_HAL_GET_BRDG_VLAN_FITLER,  /*get vlan briding flow  for a4/d4/e4 only*/
+	PPA_GENERIC_HAL_DEL_BRDG_VLAN_ALL_FITLER_MAP, /*delete all vlan briding filter's mapping*/
+	PPA_GENERIC_HAL_GET_MAX_VFILTER_ENTRY_NUM, /*get the maxumum entry for vlan filter*/
+	PPA_GENERIC_HAL_GET_IPV6_FLAG,  /*get ipv6 status : enabled or disabled*/
+	PPA_GENERIC_HAL_ADD_COMPLEMENT_ENTRY, /*add an ipv4 routing entry - complimentary processing*/
+	PPA_GENERIC_HAL_DEL_COMPLEMENT_ENTRY, /*del an ipv4 routing entry - complimentary processing*/
+	PPA_GENERIC_HAL_ADD_ROUTE_ENTRY, /*add an ipv4 routing entry*/
+	PPA_GENERIC_HAL_DEL_ROUTE_ENTRY,  /*del an ipv4 routing entry*/
+	PPA_GENERIC_HAL_UPDATE_ROUTE_ENTRY,    /*modify an ipv4 routing entry*/
+	PPA_GENERIC_HAL_ADD_MC_ENTRY,   /*add a multicast entry*/
+	PPA_GENERIC_HAL_DEL_MC_ENTRY,  /*del a multicast entry*/
+	PPA_GENERIC_HAL_UPDATE_MC_ENTRY,   /*modify a multicast entry*/
+	PPA_GENERIC_HAL_ADD_BR_MAC_BRIDGING_ENTRY,  /*add an mac address from brdging learning*/
+	PPA_GENERIC_HAL_DEL_BR_MAC_BRIDGING_ENTRY,  /*del an mac address from brdging learning*/
+	PPA_GENERIC_HAL_ADD_BR_PORT,	/*add port under a bridge*/
+	PPA_GENERIC_HAL_DEL_BR_PORT,  /*delete port from bridge*/
+	PPA_GENERIC_HAL_ADD_PPPOE_ENTRY,   /*add a pppoe entry*/
+	PPA_GENERIC_HAL_DEL_PPPOE_ENTRY,  /*del a pppoe entry*/
+	PPA_GENERIC_HAL_GET_PPPOE_ENTRY,   /*get a ppoe entry*/
+	PPA_GENERIC_HAL_ADD_6RD_TUNNEL_ENTRY,  /*add a 6rd tunnel entry*/
+	PPA_GENERIC_HAL_DEL_6RD_TUNNEL_ENTRY,  /*del a 6rd tunnel entry*/
+	PPA_GENERIC_HAL_GET_6RD_TUNNEL_ENTRY,  /*get a 6rd tunnel entry*/
+	PPA_GENERIC_HAL_ADD_DSLITE_TUNNEL_ENTRY,  /*add a dslite tunnel entry*/
+	PPA_GENERIC_HAL_DEL_DSLITE_TUNNEL_ENTRY,  /*del a dslite tunnel entry*/
+	PPA_GENERIC_HAL_GET_DSLITE_TUNNEL_ENTRY,  /*get a dslite tunnel entry*/
+	PPA_GENERIC_HAL_ADD_MTU_ENTRY,   /*and a MTU entry*/
+	PPA_GENERIC_HAL_DEL_MTU_ENTRY,    /*del a MTU entry*/
+	PPA_GENERIC_HAL_GET_MTU_ENTRY,    /*get a MUT entry*/
+	PPA_GENERIC_HAL_GET_ROUTE_ACC_BYTES, /*get the acclerated bytes counter for a specified acceleration routing entry*/
+	PPA_GENERIC_HAL_GET_IPSEC_TUNNEL_MIB, /*get the acclerated bytes counter for a specified acceleration tunnel entry*/
+	PPA_GENERIC_HAL_GET_MC_ACC_BYTES, /*get the acclerated bytes counter for a specified acceleration multicast entry*/
+	PPA_GENERIC_HAL_ADD_MAC_ENTRY,   /*add a routing mac address*/
+	PPA_GENERIC_HAL_DEL_MAC_ENTRY,  /*del a routing mac address*/
+	PPA_GENERIC_HAL_GET_MAC_ENTRY,    /*get a routing mac address*/
+	PPA_GENERIC_HAL_ADD_OUT_VLAN_ENTRY, /*add a out vlan entry*/
+	PPA_GENERIC_HAL_DEL_OUT_VLAN_ENTRY,  /*del a out vlan entry*/
+	PPA_GENERIC_HAL_GET_OUT_VLAN_ENTRY,  /*get a out vlan entry info*/
+	PPA_GENERIC_HAL_ADD_IPV6_ENTRY, /*add a IPv6 entry*/
+	PPA_GENERIC_HAL_DEL_IPV6_ENTRY,  /*del a IPv6 entry*/
+	PPA_GENERIC_HAL_GET_IPV6_ENTRY,  /*get a IPv6 entry info*/
+	PPA_GENERIC_HAL_GET_ITF_MIB,   /*get one port's mib counter. I think it should be merged with PPA_GENERIC_HAL_GET_PORT_MIB */
+	PPA_GENERIC_HAL_GET_NEW_ITF_MIB,   /*get one port's mib counter. I think it should be merged with PPA_GENERIC_HAL_GET_PORT_MIB */
+	PPA_GENERIC_HAL_MFE_CONTROL,   /*enable/disable multiple field vlan editing feature*/
+	PPA_GENERIC_HAL_MFE_STATUS,  /* get a multiple field vlan editing feature status: enabled/disabled*/
+	PPA_GENERIC_HAL_MFE_GET_FLOW_MAX_ENTRY, /* get muaximum entry number for multiple field vlan editing*/
+	PPA_GENERIC_HAL_MFE_ADD_FLOW,   /*add a multiple field vlan editing entry*/
+	PPA_GENERIC_HAL_MFE_DEL_FLOW,   /*del a multiple field vlan editing entry*/
+	PPA_GENERIC_HAL_MFE_DEL_FLOW_VIA_ENTRY,  /*del a multiple field vlan editing entry*/
+	PPA_GENERIC_HAL_MFE_GET_FLOW,  /*get a multiple field vlan editing entry*/
+	PPA_GENERIC_HAL_TEST_CLEAR_ROUTE_HIT_STAT, /*check whether a routing session is hit or not*/
+	PPA_GENERIC_HAL_TEST_CLEAR_BR_HIT_STAT, /*check whether a bridge session is hit or not*/
+	PPA_GENERIC_HAL_TEST_CLEAR_MC_HIT_STAT, /*check whether a multicast session is hit or not*/
+	PPA_GENERIC_HAL_INIT, /*init HAL*/
+	PPA_GENERIC_HAL_EXIT, /*exit HAL*/
+	PPA_GENERIC_HAL_ADD_CLASS_RULE, /* add classification rule*/
+	PPA_GENERIC_HAL_MOD_CLASS_RULE, /* modify classification rule*/
+	PPA_GENERIC_HAL_DEL_CLASS_RULE, /* delete classification rule*/
+	PPA_GENERIC_HAL_GET_CLASS_RULE, /* get classification rule*/
+	PPA_GENERIC_HAL_QOS_INIT_CFG,
+	PPA_GENERIC_HAL_QOS_UNINIT_CFG,
+	PPA_GENERIC_HAL_GET_QOS_QUEUE_NUM,  /*get maximum QOS queue number*/
+	PPA_GENERIC_HAL_GET_QOS_MIB,  /*get maximum QOS queue number*/
+	PPA_GENERIC_HAL_SET_QOS_WFQ_CTRL,  /*enable/disable WFQ*/
+	PPA_GENERIC_HAL_GET_QOS_WFQ_CTRL,  /*get  WFQ status: enabeld/disabled*/
+	PPA_GENERIC_HAL_SET_QOS_WFQ_CFG,  /*set WFQ cfg*/
+	PPA_GENERIC_HAL_RESET_QOS_WFQ_CFG,  /*reset WFQ cfg*/
+	PPA_GENERIC_HAL_GET_QOS_WFQ_CFG,  /*get WFQ cfg*/
+	PPA_GENERIC_HAL_INIT_QOS_WFQ, /* init QOS Rateshapping*/
+	PPA_GENERIC_HAL_SET_QOS_RATE_SHAPING_CTRL,  /*enable/disable Rate shaping*/
+	PPA_GENERIC_HAL_GET_QOS_RATE_SHAPING_CTRL,  /*get  Rateshaping status: enabeld/disabled*/
+	PPA_GENERIC_HAL_SET_QOS_RATE_SHAPING_CFG,  /*set rate shaping*/
+	PPA_GENERIC_HAL_GET_QOS_RATE_SHAPING_CFG,  /*get rate shaping cfg*/
+	PPA_GENERIC_HAL_RESET_QOS_RATE_SHAPING_CFG,  /*reset rate shaping cfg*/
+	PPA_GENERIC_HAL_INIT_QOS_RATE_SHAPING, /* init QOS Rateshapping*/
+#if defined(MBR_CONFIG) && MBR_CONFIG
+	PPA_GENERIC_HAL_SET_QOS_SHAPER_CFG,  /*set shaper*/
+	PPA_GENERIC_HAL_GET_QOS_SHAPER_CFG,  /*get shaper*/
+	PPA_GENERIC_HAL_RESET_QOS_SHAPER_CFG, /*reset shaper*/
+#endif
+	PPA_GENERIC_HAL_SET_WANITF, /* Set HAL WANITF*/
+	PPA_GENERIC_HAL_GET_SESSION_HASH, /* Get Hash Index*/
+	/*Fix warning message when exports API from different PPE FW Driver--End*/
+	PPA_GENERIC_HAL_GET_QOS_STATUS, /* get QOS tatus*/
+	PPA_GENERIC_HAL_SET_VALUE, /* set value*/
+	PPA_GENERIC_HAL_GET_VALUE, /* get value*/
+	/*Below macro is used for PPE datapath*/
+	PPA_GENERIC_DATAPATH_GET_PPE_VERION,  /*for VR9 E5 only so far for there is two PP32 core*/
+	/*make sure it is the last one */
+	PPA_GENERIC_DATAPATH_TSET,   /*test only*/
+	PPA_GENERIC_DATAPATH_ADDR_TO_FPI_ADDR,  /*change to FPI address*/
+	PPA_GENERIC_DATAPATH_CLEAR_MIB,  /*change to FPI address*/
+#if defined(RTP_SAMPLING_ENABLE) && RTP_SAMPLING_ENABLE
+	PPA_GENERIC_HAL_SET_MC_RTP,  /*Set rtp sampling for a multicast entry*/
+	PPA_GENERIC_HAL_GET_MC_RTP_SAMPLING_CNT, /*RTP sampling count*/
+#endif
+#if defined(L2TP_CONFIG) && L2TP_CONFIG
+	PPA_GENERIC_HAL_ADD_L2TP_TUNNEL_ENTRY,  /*add a L2TP tunnel entry*/
+	PPA_GENERIC_HAL_DEL_L2TP_TUNNEL_ENTRY,  /*del a L2TP tunnel entry*/
+	PPA_GENERIC_HAL_GET_L2TP_TUNNEL_ENTRY,  /*get a L2TP tunnel entry*/
+#endif
+#if defined(CAP_WAP_CONFIG) && CAP_WAP_CONFIG
+	PPA_GENERIC_HAL_ADD_CAPWAP_ENTRY,   /*add a CAPWAP entry*/
+	PPA_GENERIC_HAL_DEL_CAPWAP_ENTRY,   /*delete a CAPWAP entry*/
+	PPA_GENERIC_HAL_GET_CAPWAP_MIB,     /*CAWAP mib*/
+#endif
+	PPA_GENERIC_HAL_QOS_MODQUE_CFG,
+	PPA_GENERIC_HAL_QOS_ADDQUE_CFG,
+	PPA_GENERIC_HAL_QOS_DELQUE_CFG,
+#if defined(MIB_MODE_ENABLE) && MIB_MODE_ENABLE
+	PPA_GENERIC_HAL_SET_MIB_MODE_ENABLE, /*configure the mib mode*/
+	PPA_GENERIC_HAL_GET_MIB_MODE_ENABLE,
+#endif
+	PPA_GENERIC_HAL_ADD_LRO_ENTRY,
+	PPA_GENERIC_HAL_DEL_LRO_ENTRY,
+	PPA_GENERIC_DATAPATH_SET_LAN_SEPARATE_FLAG,
+	PPA_GENERIC_DATAPATH_GET_LAN_SEPARATE_FLAG,
+	PPA_GENERIC_DATAPATH_SET_WAN_SEPARATE_FLAG,
+	PPA_GENERIC_DATAPATH_GET_WAN_SEPARATE_FLAG,
+	PPA_GENERIC_HAL_MOD_SUBIF_PORT_CFG,
+	/*make sure it is the last one */
+	PPA_GENERIC_HAL_MAX_FLAG
+} PPA_GENERIC_HOOK_CMD;
+#define PPA_PWM_LEVEL_D0                            0
+#define PPA_PWM_LEVEL_D1                            1
+#define PPA_PWM_LEVEL_D2                            2
+#define PPA_PWM_LEVEL_D3                            3
+/*
+ * ####################################
+ *              Data Type
+ * ####################################
+ */
+typedef int32_t (*ppe_generic_hook_t)(PPA_GENERIC_HOOK_CMD cmd, void *buffer, uint32_t flag);
+#if defined(CONFIG_PPA_HAL_SELECTOR) && CONFIG_PPA_HAL_SELECTOR
+typedef int32_t (*ppa_generic_hook_t)(PPA_GENERIC_HOOK_CMD cmd, void *buffer, uint32_t flag);
+#endif
+/*
+ * ####################################
+ *             Declaration
+ * ####################################
+ */
+#ifdef __KERNEL__
+/*
+ *    implemented in datapath driver
+ */
+extern int32_t (*ppa_drv_hal_generic_hook)(PPA_GENERIC_HOOK_CMD cmd, void *buffer, uint32_t flag);
+extern int32_t (*ppa_drv_hal_get_mpoa_type_hook)(uint32_t dslwan_qid, uint32_t *mpoa_type);
+#endif  /*  __KERNEL__*/
+#if defined(CONFIG_ACCL_11AC) || defined(CONFIG_ACCL_11AC_MODULE)
+#define PPA_F_INIT          1
+#define PPA_F_UNINIT        2
+#define DTLK_TX_RSV_MEM_SIZE 0x800000
+#define DTLK_RX_RSV_MEM_SIZE 0x400000
+
+typedef struct {
+	int64_t txpdu;
+	int64_t txbytes;
+	unsigned int txdrop;
+	unsigned int rx_fwd_pdu;
+	unsigned int rx_fwd_bytes;
+	unsigned int rx_inspect_pdu;
+	unsigned int rx_inspect_bytes;
+	unsigned int rx_discard_pdu;
+	unsigned int rx_discard_bytes;
+	unsigned int rx_pn_pdu;
+	unsigned int rx_pn_bytes;
+	unsigned int rx_drop_pdu;
+	unsigned int rx_drop_bytes;
+	int64_t rx_rcv_pdu;
+	int64_t rx_rcv_bytes;
+	unsigned int _dw_res0;
+} PPA_WLAN_VAP_Stats_t;
+extern void ppa_directlink_enable (uint32_t flags);
+extern int32_t ppa_directlink_get_status (uint32_t flag);
+extern uint32_t ppa_dl_qca_h2t_ring_init (uint32_t h2tRingSize, uint32_t entrySize, uint32_t src_ring_base, uint32_t pcie_base, uint32_t flags);
+extern uint32_t ppa_dl_qca_cpu_h2t_ring_init (uint32_t h2tCpuMsgRingSize, uint32_t entrySize, uint32_t flags
+#if defined(CONFIG_ACCL_11AC_CS2)
+		,
+		uint32_t irq_base
+#endif
+		);
+extern int32_t ppa_dl_qca_cpu_h2t_ring_get_write_idx (uint32_t flags);
+extern int32_t ppa_dl_qca_cpu_h2t_ring_write_msg (uint32_t writeIndex, uint32_t *msgPtr, uint32_t msgLen, uint32_t next_writeIndex, uint32_t flags);
+extern int32_t ppa_dl_dre_txpkt_buf_release (uint32_t num_msdus, uint32_t *msg, uint32_t flags);
+extern uint32_t ppa_dl_qca_get_vap_stats (uint32_t vapId, PPA_WLAN_VAP_Stats_t *vapStats, uint32_t flags);
+extern void dtlk_mem_base_get(uint32_t *dltx_base, uint32_t *dlrx_base);
+extern void (*set_vap_itf_tbl_fn)(uint32_t, uint32_t);
+#endif
+#endif  /*  __PPA_PPE_HAL_H__20081104_1318__*/
diff --git a/include/net/ppa/ppa_stack_al.h b/include/net/ppa/ppa_stack_al.h
new file mode 100644
index 000000000000..15dbf2dc08d6
--- /dev/null
+++ b/include/net/ppa/ppa_stack_al.h
@@ -0,0 +1,2281 @@
+#ifndef __PPA_STACK_AL_H__20081103_1153__
+#define __PPA_STACK_AL_H__20081103_1153__
+/******************************************************************************
+ **
+ ** FILE NAME : ppa_stack_al.h
+ ** PROJECT : PPA
+ ** MODULES : PPA Protocol Stack Adaption Layer (Linux)
+ **
+ ** DATE : 3 NOV 2008
+ ** AUTHOR : Xu Liang
+ ** DESCRIPTION : PPA Protocol Stack Adaption Layer (Linux) Header File
+ ** COPYRIGHT : Copyright (c) 2017 Intel Corporation
+ ** Copyright (c) 2010 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+ **
+ ** HISTORY
+ ** $Date $Author $Comment
+ ** 03 NOV 2008 Xu Liang Initiate Version
+ *******************************************************************************/
+/*! \file ppa_stack_al.h
+  \brief This file contains es.
+  provide linux os depenent api for PPA to use
+ */
+#include <net/ppa/ppa_api_common.h>
+#ifdef __KERNEL__
+#include <linux/version.h>
+#include <linux/if_arp.h>
+#include <linux/if_pppox.h>
+#include <linux/list.h>
+#include <../net/bridge/br_private.h>
+#if defined(CONFIG_NF_CONNTRACK_SUPPORT) || defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
+#include <net/netfilter/nf_conntrack.h> /* protocol independent conntrack */
+#else
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#endif
+#ifdef CONFIG_PPA_HANDLE_CONNTRACK_SESSIONS
+#include <net/netfilter/nf_conntrack_session_limit.h>
+#endif
+#if defined(CONFIG_PPA_MPE_IP97)
+#include <net/xfrm.h>
+#endif
+#endif /*end of __KERNEL__*/
+#if defined(CONFIG_LTQ_PMCU) || defined(CONFIG_LTQ_PMCU_MODULE) || defined(CONFIG_LTQ_CPU_FREQ)
+/*PMCU specific Head File*/
+#include <linux/version.h>
+#include <cpufreq/ltq_cpufreq.h>
+#endif /*end of CONFIG_LTQ_PMCU*/
+#if defined(CONFIG_LTQ_DATAPATH) && CONFIG_LTQ_DATAPATH
+#include <net/datapath_api.h>
+#endif
+#ifdef NO_DOXY
+#if defined(__KERNEL__)
+typedef struct port_cell_info port_cell_info;
+typedef int (*ltq_mei_atm_showtime_check_t)(const unsigned char, int *, struct port_cell_info *, void **);
+typedef int (*ltq_mei_atm_showtime_enter_t)(const unsigned char, struct port_cell_info *, void *);
+typedef int (*ltq_mei_atm_showtime_exit_t)(const unsigned char);
+#endif
+typedef enum {
+	LTQ_MEI_UNKNOWN  =  0,
+	/** To register function for getting showtime status. */
+	LTQ_MEI_SHOWTIME_CHECK  =  1,
+	/** To register function for showtime entry signalling. */
+	LTQ_MEI_SHOWTIME_ENTER  =  2,
+	/** To register function for showtime exit signalling. */
+	LTQ_MEI_SHOWTIME_EXIT  =  3,
+	/** To register function for TC-Layer selection.
+	  For DSL/PP switchover concept (also refer to DSLCPE_SW-858) */
+	LTQ_MEI_TC_REQUEST  =  4,
+	/** To register function for performing reset of TC-Layer.
+	  (also refer to PPA_SYS-353) */
+	LTQ_MEI_TC_RESET  =  5
+} e_ltq_mei_cb_type;
+/**
+  This definition is used by the MEI Driver within TC request trigger to
+  inform the PPA about the TC-Layer that has been negotiated during handshake
+  and therefore needs to be loaded/configured on the PPA side. */
+typedef enum {
+	/** Request to disable the TC */
+	MEI_TC_REQUEST_OFF  =  0,
+	/** Request to load/configure the PTM (EFM) TC */
+	MEI_TC_REQUEST_PTM  =  1,
+	/** Request to load/configure the ATM TC */
+	MEI_TC_REQUEST_ATM  =  2,
+	/** Delimiter only! */
+	MEI_TC_REQUEST_LAST  =  3
+} mei_tc_request_type;
+/**
+  This bit-field definition is used by the MEI Driver to trigger reset
+  handling(s) within TC-Layer of the PPA. */
+typedef enum {
+	/** This value is defined for initialization purpose only.
+	  At least one of the defined bits of the bitmask shall be set. */
+	MEI_TC_RESET_CLEAN  =  0x00000000,
+	/** Request to perform a reset of the TC codeword buffer */
+	MEI_TC_RESET_CW_BUFFER  =  0x00000001
+} mei_tc_reset_type;
+struct ltq_mei_atm_showtime_info {
+	void *check_ptr;
+	void *enter_ptr;
+	void *exit_ptr;
+	void *req_tc_ptr;
+	void *tc_reset_ptr;
+};
+/** Function pointer for new DSL/PP switchover concept(also refer to DSLCPE_SW-858)
+  \param line Line number
+  \param tc_reqest_type TC-Layer to be used/configured
+  \param is_bonding Defines whether bonding is used (> = 1) or not (0)
+  \return 0 if successful
+ */
+typedef int (*mei_tc_request_t)(
+		const unsigned char line,
+		mei_tc_request_type tc_reqest_type,
+		int is_bonding);
+/** Function pointer for triggering a reset of the TC (also refer to PPA_SYS-353)
+  \param line Line number
+  \param tc_reset_type TC Reset type to be performed
+  \return 0 if successful */
+typedef int (*mei_tc_reset_t)(
+		const unsigned char,
+		mei_tc_reset_type tc_reset_type);
+#endif
+/*
+ * ####################################
+ * Definition
+ * ####################################
+ */
+/*! \def PPA_ETH_ALEN
+  \brief Macro that specifies the maximum length of an Ethernet MAC address.
+ */
+#define PPA_ETH_ALEN ETH_ALEN
+/*! \def PPA_ETH_HLEN
+  \brief Macro that specifies the maximum length of an Ethernet MAC header.
+ */
+#define PPA_ETH_HLEN ETH_HLEN
+/*! \def PPA_ETH_CRCLEN
+  \brief Macro that specifies the maximum length of an Ethernet CRC.
+ */
+#define PPA_ETH_CRCLEN 4
+/*! \def PPA_IF_NAME_SIZE
+  \brief Macro that specifies the maximum size of one interface name
+ */
+#define PPA_IF_NAME_SIZE IFNAMSIZ
+/*! \def PPA_IF_SUB_NAME_MAX_NUM
+  \brief Macro that specifies the maximum size of one interface name
+ */
+#define PPA_IF_SUB_NAME_MAX_NUM 5
+/*! \def PPA_IPPROTO_TCP
+  \brief Macro that specifies TCP flag
+ */
+#define PPA_IPPROTO_TCP 6
+/*! \def PPA_IPPROTO_UDP
+  \brief Macro that specifies UDP flag
+ */
+#define PPA_IPPROTO_UDP 17
+/*! \def PPA_USER
+  \brief Macro that specifies the flag for the buffer type from User Space via ioctl
+ */
+#define PPA_USER __user
+/*
+ * definition for application layer
+ */
+#ifndef __KERNEL__
+/*! \def ETH_ALEN
+  \brief Macro that specifies the maximum length of an Ethernet MAC address.
+ */
+#define ETH_ALEN 6
+/*! \def IFNAMSIZ
+  \brief Macro that specifies the maximum size of an interface NAME
+ */
+#define IFNAMSIZ 16
+#endif
+#undef NIPQUAD
+/*! \def NIPQUAD
+  \brief Macro that specifies NIPQUAD definition for printing IPV4 address
+ */
+#define NIPQUAD(addr) \
+	((unsigned char *)&addr)[0], \
+((unsigned char *)&addr)[1], \
+((unsigned char *)&addr)[2], \
+((unsigned char *)&addr)[3]
+#undef NIPQUAD_FMT
+/*! \def NIPQUAD_FMT
+  \brief Macro that specifies NIPQUAD_FMT format definition for printing IPV4 address
+ */
+#define NIPQUAD_FMT "%u.%u.%u.%u"
+#undef NIP6
+/*! \def NIP6
+  \brief Macro that specifies NIP6 definition for printing IPV6 address
+ */
+#define NIP6(addr) \
+	ntohs(((unsigned short *)addr)[0]), \
+ntohs(((unsigned short *)addr)[1]), \
+ntohs(((unsigned short *)addr)[2]), \
+ntohs(((unsigned short *)addr)[3]), \
+ntohs(((unsigned short *)addr)[4]), \
+ntohs(((unsigned short *)addr)[5]), \
+ntohs(((unsigned short *)addr)[6]), \
+ntohs(((unsigned short *)addr)[7])
+#undef NIP6_FMT
+/*! \def NIP6_FMT
+  \brief Macro that specifies NIP6_FMT format definition for printing IPV6 address
+ */
+#define NIP6_FMT "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x"
+/*
+ * ####################################
+ * Data Type
+ * ####################################
+ */
+/*
+ * data type for API
+ */
+/*!
+  \brief Pointer to interface name
+ */
+typedef char PPA_IFNAME;
+/*!
+  \brief This is the data structure holding the IP address. It helps to provide future compatibility for IPv6 support.
+  Currently it only supports IPv4.
+ */
+typedef uint32_t IPADDR;
+/*!
+  \brief Union of PPA network address
+ */
+typedef union {
+	uint32_t ip; /*!< the storage buffer for ipv4 */
+#if IS_ENABLED(CONFIG_IPV6)
+	uint32_t ip6[4]; /*!< the storage buffer for ipv6 */
+#endif
+} PPA_IPADDR;
+#ifdef __KERNEL__
+
+typedef union {
+	PPA_IPADDR ip;           /*!< nat ip */
+	PPA_IPADDR srcip;        /*!< source nat ip */
+}PPA_NATSRCIP;
+
+typedef struct {
+
+#if IS_ENABLED(CONFIG_NAT_LOOP_BACK)
+	PPA_IPADDR natdstip;        /*!< nat destination ip for NAT Loopback */
+#endif
+	PPA_NATSRCIP natsrcip;      /*!< nat source ip */
+}PPA_NATIP;
+
+typedef enum {
+	SESSION_IPV4 = 2,
+	SESSION_IPV6 = 10,
+} session_type;
+/*!
+  \brief xfrm state structure.
+ */
+typedef struct xfrm_state PPA_XFRM_STATE;
+/*!
+  \brief xfrm address union.
+ */
+typedef xfrm_address_t PPA_XFRM_ADDR;
+/*!
+  \brief socket address family.
+ */
+typedef sa_family_t PPA_SA_FAMILY;
+/*!
+  \brief session information from xfrm state structure.
+ */
+session_type ppa_is_ipv4_ipv6(PPA_XFRM_STATE *x);
+/*!
+  \brief session information from xfrm state structure.
+ */
+bool ppa_ipsec_addr_equal(PPA_XFRM_ADDR *a, PPA_XFRM_ADDR *b, PPA_SA_FAMILY family);
+/*bool ppa_ipsec_addr_equal(xfrm_address_t *a, xfrm_address_t *b, sa_family_t family);*/
+/*!
+  \brief Packet buffer structure. For Linux OS, this is the sk_buff structure to be used for control path (learning).
+ */
+typedef struct sk_buff PPA_BUF;
+/*!
+  \brief Packet buffer structure. For Linux OS, this is the sk_buff structure to be used in datapath.
+ */
+typedef struct sk_buff PPA_SKBUF;
+/*!
+  \brief Stateful Packet inspection / connection tracking session data structure.
+  A packet is classified to such a session by SPI/NAT infrastructure.
+  In Linux, this is defined to the Linux ip_conntrack/nf_conntrack structure.
+ */
+#if IS_ENABLED(CONFIG_NF_CONNTRACK)
+typedef struct nf_conn PPA_SESSION;
+#else
+typedef struct ip_conntrack PPA_SESSION;
+#endif
+
+typedef enum ip_conntrack_info PPA_CTINFO;   
+/*!
+  \brief This holds information of a session - 5 tuples.
+ */
+typedef struct nf_conntrack_tuple PPA_TUPLE;
+/*!
+  \brief Packet buffer structure. For Linux OS, this is the sk_buff structure.
+ */
+typedef struct udphdr		PPA_UDPHDR;
+/*!
+  \brief Packet buffer structure. For Linux OS, this is the sk_buff structure.
+ */
+typedef struct tcphdr		PPA_TCPHDR;
+/*!
+  \brief Packet buffer structure. For Linux OS, this is the sk_buff structure.
+ */
+typedef struct iphdr		PPA_IPHDR;
+#if IS_ENABLED(CONFIG_IPV6)
+/*!
+  \brief Packet buffer structure. For Linux OS, this is the sk_buff structure.
+ */
+typedef struct ipv6hdr		PPA_IPV6HDR;
+#endif
+/*!
+  \brief Packet buffer structure. For Linux OS, this is the sk_buff structure.
+ */
+typedef struct pppoe_hdr	PPA_PPPOEHDR;
+/*!
+  \brief Packet buffer structure. For Linux OS, this is the sk_buff structure.
+ */
+typedef struct in6_addr	PPA_IN6ADDR;
+/*!
+  \brief Macro that specifies PPA network interface data structure
+ */
+typedef struct net_device PPA_NETIF;
+/*!
+  \brief Macro that specifies PPA network interface data structure
+ */
+typedef struct notifier_block	PPA_NOTIFIER_BLOCK;
+/*!
+  \brief Macro that specifies PPA network interface data structure
+ */
+typedef struct notifier_block	PPA_NOTIFIER_BLOCK;
+#if defined(CONFIG_LTQ_DATAPATH) && CONFIG_LTQ_DATAPATH
+/*!
+  \brief Macro that specifies PPA sub-interface data structure
+ */
+typedef struct dp_subif PPA_DP_SUBIF;
+#endif
+#if defined(CONFIG_PPA_HANDLE_CONNTRACK_SESSIONS)
+/*!
+  \brief Macro that specifies PPA time spec data structure
+ */
+typedef struct timespec	PPA_TIMESPEC;
+#endif
+/*!
+  \brief Macro that specifies PPA network interface status structure
+ */
+typedef struct net_device_stats PPA_NETIF_STATS;
+/*!
+  \brief This is the data structure for the PPA ATM VC structure. In Linux, this is defined to the Linux atm_vcc structure
+ */
+typedef struct atm_vcc PPA_VCC;
+/*!
+  \brief PPA synchroniztion primitive for exclusion and/or synchroniztion, especially for PPE share buffer access
+ */
+typedef spinlock_t PPE_LOCK;
+/*!
+  \brief PPA datastructure for task structure; In Linux this is defined as Linux task structure
+ */
+typedef struct task_struct	PPA_TASK;
+#define PPA_TASK_RUNNING TASK_RUNNING
+#define PPA_TASK_INTERRUPTIBLE TASK_INTERRUPTIBLE
+/*!
+  \brief PPA alias for return values from the notifier calls.
+ */
+#define PPA_NOTIFY_DONE			NOTIFY_DONE
+#define PPA_NOTIFY_OK			NOTIFY_OK
+#define PPA_NOTIFY_STOP_MASK		NOTIFY_STOP_MASK
+#define PPA_NOTIFY_BAD			NOTIFY_BAD
+/*!
+  \brief PPA alias for return values from the notifier calls.
+ */
+#define PPA_NOTIFY_DONE			NOTIFY_DONE
+#define PPA_NOTIFY_OK			NOTIFY_OK
+#define PPA_NOTIFY_STOP_MASK		NOTIFY_STOP_MASK
+#define PPA_NOTIFY_BAD			NOTIFY_BAD
+/*!
+  \brief PPA synchronization primitive for exclusion and/or synchronization
+ */
+typedef struct ppa_lock{
+	PPE_LOCK lock; /*!< PPA lock */
+	unsigned long flags; /*!< flag */
+	uint32_t cnt; /*!< lock counter */
+} PPA_LOCK;
+/*!
+  \brief PPA memory pool cache for efficient allocation of PPA data structures. Can be mapped to
+  suitable OS allocation logic
+ */
+typedef struct kmem_cache PPA_MEM_CACHE;
+/*!
+  \brief PPA Timer data structure. Should allow one shot timers to be configured with a passed
+  timer callback function
+ */
+typedef struct timer_list PPA_TIMER;
+/*!
+  \brief PPA atomic timer structure. In linux, it is atomic_t structure.
+ */
+typedef atomic_t PPA_ATOMIC;
+/*!
+  \brief PPA hash list head structure
+ */
+typedef struct hlist_head PPA_HLIST_HEAD;
+/*!
+  \brief PPA hash list node structure
+ */
+typedef struct hlist_node PPA_HLIST_NODE;
+/*!
+  \brief PPA SIZE_T. For Linux OS, the size_t is unsigned int.
+ */
+typedef size_t PPA_SIZE_T;
+/*!
+  \brief PPA FILE PPA_FILE_OPERATIONS. For Linux OS, it is file_operations
+ */
+typedef struct file_operations PPA_FILE_OPERATIONS;
+/*!
+  \brief PPA SYS INFO. For Linux OS, it is file_operations
+ */
+typedef struct sysinfo PPA_SYSINFO;
+/*!
+  \brief PPA sync. For Linux OS, it is __sync
+  \note, someties GCC will wrongly optimize the code, so __sync is used to avoid it. \n
+  otherwise, just define PPA_SYNC to do { } while (0)
+ */
+#ifdef CONFIG_X86
+#define __sync() do { } while (0)
+#endif
+#define PPA_SYNC __sync
+#if defined(CONFIG_LTQ_CPU_FREQ) || defined(CONFIG_LTQ_PMCU) || defined(CONFIG_LTQ_PMCU_MODULE)
+/*!
+  \brief PPA POWER MANAGEMENT RETURN VALUE.
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 7)
+typedef IFX_PMCU_STATE_t PPA_PWM_STATE_t;
+#else
+typedef enum ltq_cpufreq_state PPA_PWM_STATE_t;
+#endif
+/*!
+  \brief PPA POWER MANAGEMENT RETURN VALUE.
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 7)
+typedef IFX_PMCU_RETURN_t PPA_PWM_RETURN_t;
+#else
+/* typedef IFX_PMCU_RETURN_t PPA_PWM_RETURN_t;*/
+#endif
+/*!
+  \brief PPA POWER MANAGEMENT MODUE STATE VALUE.
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 7)
+typedef IFX_PMCU_MODULE_STATE_t PPA_PWM_MODULE_STATE_t;
+#else
+typedef struct ltq_cpufreq_module_state PPA_PWM_MODULE_STATE_t;
+#endif
+#endif /*end of CONFIG_LTQ_PMCU*/
+/*
+ * definition
+ */
+/*!
+  \brief PPA session list traversal
+ */
+/*					(tpos, pos, head, member) */
+#define ppa_hlist_for_each_entry		hlist_for_each_entry
+/*!
+  \brief PPA session list safe traversal
+ */
+/* (tpos, pos, n, head, member) */
+#define ppa_hlist_for_each_entry_safe		hlist_for_each_entry_safe
+/*!
+  \brief PPA session list traversal
+ */
+/*					(ptr, type, member) */
+#define ppa_hlist_entry				hlist_entry
+/*!
+  \brief PPA session list delete
+ */
+/*					(struct hlist_node *n) */
+#define ppa_hlist_del				hlist_del_init
+/*!
+  \brief PPA session list empty
+ */
+/*					(struct hlist_node *n) */
+#define ppa_hlist_empty				hlist_empty
+/*!
+  \brief PPA session list empty
+ */
+/*					(struct hlist_node *n) */
+#define ppa_hlist_add_before			hlist_add_before
+/*!
+  \brief PPA session list empty
+ */
+/*					(struct hlist_node *n) */
+#define ppa_hlist_add_after			hlist_add_behind
+/*!
+  \brief PPA session list op: get list header
+ */
+/*					(ptr)*/
+#define PPA_INIT_HLIST_HEAD			INIT_HLIST_HEAD
+/*!
+  \brief PPA session list op: get one session list
+ */
+/*					(struct hlist_node *h) */
+#define PPA_INIT_HLIST_NODE			INIT_HLIST_NODE
+/*!
+  \brief PPA session list op: add new list to the list header
+ */
+/*				(struct hlist_node *n, struct hlist_head *h) */
+#define ppa_hlist_add_head			hlist_add_head
+/*!
+  \brief PPA session list traversal
+ */
+/*					(pos, head) */
+#define ppa_hlist_for_each			hlist_for_each
+/* hlist rcu operations */
+#define ppa_hlist_add_head_rcu		hlist_add_head_rcu
+#define ppa_hlist_del_rcu		hlist_del_rcu
+#define ppa_hlist_for_each_rcu		__hlist_for_each_rcu
+#define ppa_hlist_for_each_entry_rcu	hlist_for_each_entry_rcu
+typedef struct rcu_head			PPA_RCU_HEAD;
+#define ppa_call_rcu			call_rcu
+/* #if defined(CAP_WAP_CONFIG) && CAP_WAP_CONFIG */
+/*!
+  \brief PPA list head structure
+ */
+typedef struct list_head		PPA_LIST_HEAD;
+/*!
+  \brief PPA hash list node structure
+ */
+typedef struct list_head		PPA_LIST_NODE;
+/*!
+  \brief PPA list traversal
+ */
+/*					(tpos, pos, head, member) */
+#define ppa_list_for_each_entry			list_for_each_entry
+/*!
+  \brief PPA list safe traversal
+ */
+/*					(tpos, pos, n, head, member) */
+#define ppa_list_for_each_entry_safe		list_for_each_entry_safe
+/*!
+  \brief PPA list safe traversal in reverse
+ */
+/*					(tpos, pos, head, member) */
+#define ppa_list_for_each_entry_safe_reverse	list_for_each_entry_safe_reverse
+/*!
+  \brief PPA list traversal
+ */
+/*					(ptr, type, member) */
+#define ppa_list_entry				list_entry
+/*!
+  \brief PPA session list delete
+ */
+/*					(struct hlist_node *n) */
+#define ppa_list_del				list_del
+/*!
+  \brief PPA list op: get list header
+ */
+/*					(ptr)*/
+#define PPA_INIT_LIST_HEAD		LIST_HEAD
+#define PPA_LIST_HEAD_INIT		INIT_LIST_HEAD
+/*!
+  \brief PPA session list op: add new list to the list header
+ */
+#define ppa_list_add_head list_add
+#define ppa_list_add list_add
+/*!
+  \brief PPA list traversal
+ */
+#define ppa_list_for_each list_for_each
+/*!
+  \brief PPA list delete
+ */
+#define ppa_list_delete list_del
+/*!
+  \brief PPA list iterate backwards over list with safe
+ */
+#define ppa_list_for_each_entry_safe_reverse list_for_each_entry_safe_reverse
+/* #endif */
+/*!
+  \brief synchronize_rcu
+ */
+#define ppa_synchronize_rcu synchronize_rcu
+/*!
+  \brief spin_lock_irqsave
+ */
+#define ppa_spin_lock_irqsave spin_lock_irqsave
+/*!
+  \brief spin_unlock_irqrestore
+ */
+#define ppa_spin_unlock_irqstore spin_unlock_irqrestore
+/*!
+  \brief spin_lock_bh
+ */
+#define ppa_spin_lock_bh spin_lock_bh
+/*!
+  \brief spin_unlock_bh
+ */
+#define ppa_spin_unlock_bh spin_unlock_bh
+/*!
+  \brief spin_lock_irq
+ */
+#define ppa_spin_lock_irq spin_lock_irq
+/*!
+  \brief spin_unlock_irq
+ */
+#define ppa_spin_unlock_irq spin_unlock_irq
+/*!
+  \brief rcu_read_lock
+ */
+#define ppa_rcu_read_lock rcu_read_lock
+/*!
+  \brief rcu_read_unlock
+ */
+#define ppa_rcu_read_unlock rcu_read_unlock
+/*!
+  \brief to dereference any member of any structure
+ */
+#define ppa_get_member(x, y)	x->y
+/*!
+  \brief to calculate ip partial checksum
+ */
+#define ppa_ip_fast_csum	ip_fast_csum
+/*!
+  \brief netdevice event registeration/unregisteration functions
+ */
+#define ppa_register_netdevice_notifier register_netdevice_notifier
+#define ppa_unregister_netdevice_notifier unregister_netdevice_notifier
+/*
+ * ####################################
+ * Inline Functions
+ * ####################################
+ */
+/*!
+  \brief skb_set_mac_header
+ */
+static inline void ppa_skb_set_mac_header(PPA_BUF *skb, const int offset)
+{
+	return skb_set_mac_header(skb, offset);
+}
+/*!
+  \brief skb_set_mac_header
+ */
+static inline void ppa_skb_reset_mac_header(PPA_BUF *skb)
+{
+	return skb_reset_mac_header(skb);
+}
+/*!
+  \brief ppa session entry criteria
+ */
+static inline int ppa_session_entry_pass(uint32_t num_adds, uint32_t min_hits)
+{
+	return (num_adds < min_hits);
+}
+/*!
+  \brief skb_get_length
+ */
+static inline uint32_t ppa_skb_len(PPA_BUF *skb)
+{
+	return skb ? skb->len : 0;
+}
+/*!
+  \brief get skb priority
+ */
+static inline uint32_t ppa_get_pkt_priority(PPA_BUF *skb)
+{
+	return skb ? skb->priority : 0;
+}
+/*!
+  \brief set skb priority
+ */
+static inline uint32_t ppa_set_pkt_priority(PPA_BUF *ppa_buf, uint32_t new_pri)
+{
+	if (ppa_buf) {
+		ppa_buf->priority  =  new_pri;
+		return ppa_buf->priority;
+	}
+	return 0;
+}
+/*!
+  \brief get skb mark
+ */
+static inline uint32_t ppa_get_skb_mark(PPA_BUF *skb)
+{
+	return skb ? skb->mark : 0;
+}
+#ifdef CONFIG_NETWORK_EXTMARK
+/*!
+  \brief get skb extmark
+ */
+static inline uint32_t ppa_get_skb_extmark(PPA_BUF *skb)
+{
+	return skb ? skb->extmark : 0;
+}
+/*!
+  \brief skb_set_extmark
+ */
+static inline void ppa_set_skb_extmark(PPA_BUF *skb, uint32_t flag)
+{
+	if (skb) {
+		skb->extmark |=  flag;
+	}
+}
+#endif
+/*!
+  \brief ppa netif type
+ */
+static inline uint16_t ppa_netif_type(PPA_NETIF *netif)
+{
+	return netif ? netif->type : 0;
+}
+/*!
+  \brief spinlock init
+ */
+static inline void ppe_lock_init(PPE_LOCK *p_lock)
+{
+	spin_lock_init(p_lock);
+}
+/*!
+  \brief spinlock get
+ */
+static inline void ppe_lock_get(PPE_LOCK *p_lock)
+{
+	spin_lock_bh(p_lock);
+}
+/*!
+  \brief spinlock release
+ */
+static inline void ppe_lock_release(PPE_LOCK *p_lock)
+{
+	spin_unlock_bh(p_lock);
+}
+/*!
+  \brief copy data from skb
+ */
+static inline void ppa_copy_skb_data(void *dst, PPA_BUF *src, uint32_t offset)
+{
+	memcpy(dst, src->data, offset);
+}
+/*!
+  \brief get netif name
+ */
+static inline char *ppa_get_netif_name(PPA_NETIF *netif)
+{
+	return netif ? netif->name : NULL;
+}
+/*!
+  \brief check if netif is up
+ */
+static inline int32_t ppa_check_is_ifup(PPA_NETIF *netif)
+{
+	return netif && (netif->flags & IFF_UP) ? 1 : 0;
+}
+/*!
+  \brief check if netif is in bridge
+ */
+static inline int32_t ppa_is_netif_bridged(PPA_NETIF *netif)
+{
+	return netif && (netif->priv_flags & IFF_BRIDGE_PORT) ? 1 : 0;
+}
+/*!
+  \brief is netif equal
+ */
+static inline uint32_t ppa_is_netif_equal(PPA_NETIF *netif1, PPA_NETIF *netif2)
+{
+	return netif1 && netif2 && netif1->ifindex  ==  netif2->ifindex ? 1 : 0;
+}
+/*!
+  \brief is netif name set
+ */
+static inline uint32_t ppa_is_netif_name(PPA_NETIF *netif, PPA_IFNAME *ifname)
+{
+	return netif && ifname && strcmp(netif->name, ifname)  ==  0 ? 1 : 0;
+}
+#ifdef CONFIG_PPA_PUMA7
+/*!
+  \brief get session handle
+ */
+static inline uint32_t ppa_get_session_handle(PPA_BUF *skb)
+{
+	return skb->pp_packet_info->pp_session.session_handle;
+}
+#endif
+/*!
+  \brief get dst entry
+ */
+static inline struct dst_entry *ppa_dst(const PPA_BUF *buf)
+{
+	return skb_dst(buf);
+}
+/*!
+  \brief get netdevice by name
+ */
+static inline struct net_device *ppa_dev_get_by_name(const PPA_IFNAME *ifname)
+{
+#ifdef CONFIG_NET_NS
+	struct net *net;
+	struct net_device *net_dev = dev_get_by_name(&init_net, ifname);
+
+	if (net_dev == NULL) {
+		for_each_net(net) {
+			net_dev = dev_get_by_name(net, ifname);
+			if (net_dev)
+				break;
+		}
+	}
+	return net_dev;
+#else
+	return dev_get_by_name(&init_net, ifname);
+#endif
+}
+
+/*!
+  \brief get the net device pointer from notifier
+ */
+static inline struct net_device *ppa_netdev_notifier_info_to_dev(const void *ptr)
+{
+	return netdev_notifier_info_to_dev((struct netdev_notifier_info *)ptr);
+}
+
+/*!
+  \brief get the nat helper function
+ */
+static inline uint32_t ppa_get_nat_helper(PPA_SESSION *p_session)
+{
+	return 0;
+}
+/*!
+  \brief is tcp state established
+ */
+static inline int32_t ppa_is_tcp_established(PPA_SESSION *ppa_session)
+{
+	return ppa_session->proto.tcp.state  ==  TCP_CONNTRACK_ESTABLISHED ? 1 : 0;
+}
+/*!
+  \brief is tcp state open
+ */
+static inline int32_t ppa_is_tcp_open(PPA_SESSION *ppa_session)
+{
+	/* return nonzero if the tcp state is not TIME_WAIT or error*/
+	return ppa_session->proto.tcp.state < TCP_CONNTRACK_TIME_WAIT ? 1 : 0;
+}
+/*!
+  \brief is packet host output
+ */
+static inline int32_t ppa_is_pkt_host_output(PPA_BUF *ppa_buf)
+{
+	return ppa_buf->dev  ==  NULL || ppa_buf->pkt_type  ==  PACKET_OUTGOING ? 1 : 0;
+}
+/*!
+  \brief is packet destined to host
+ */
+static inline int32_t ppa_is_pkt_host_in(PPA_BUF *ppa_buf)
+{
+	return ppa_buf->dev  ==  NULL || ppa_buf->pkt_type  ==  PACKET_HOST ? 1 : 0;
+}
+/*!
+  \brief is packet broadcast
+ */
+static inline int32_t ppa_is_pkt_broadcast(PPA_BUF *ppa_buf)
+{
+	return ppa_buf->pkt_type  ==  PACKET_BROADCAST ? 1 : 0;
+}
+/*!
+  \brief is packet loopback
+ */
+static inline int32_t ppa_is_pkt_loopback(PPA_BUF *ppa_buf)
+{
+	return ppa_buf->pkt_type  ==  PACKET_LOOPBACK ? 1 : 0;
+}
+/*!
+  \brief is compare connection tuple
+ */
+static inline int ppa_compare_connection_tuple(PPA_TUPLE *t1,
+		uint16_t l3num,
+		uint16_t ip_proto,
+		uint16_t src_port,
+		uint16_t dst_port,
+		PPA_IPADDR *src_ip,
+		PPA_IPADDR *dst_ip)
+{
+	if (t1->src.l3num  ==  l3num &&
+			t1->dst.protonum  ==  ip_proto &&
+			t1->src.u.all  ==  src_port &&
+			t1->dst.u.all  ==  dst_port) {
+#if IS_ENABLED(CONFIG_IPV6)
+		if (t1->src.u3.all[0]  ==  src_ip->ip6[0] &&
+				t1->src.u3.all[1]  ==  src_ip->ip6[1] &&
+				t1->src.u3.all[2]  ==  src_ip->ip6[2] &&
+				t1->src.u3.all[3]  ==  src_ip->ip6[3] &&
+				t1->dst.u3.all[0]  ==  dst_ip->ip6[0] &&
+				t1->dst.u3.all[1]  ==  dst_ip->ip6[1] &&
+				t1->dst.u3.all[2]  ==  dst_ip->ip6[2] &&
+				t1->dst.u3.all[3]  ==  dst_ip->ip6[3])
+#else
+			if (t1->src.u3.all[0]  ==  src_ip->ip &&
+					t1->dst.u3.all[0]  ==  dst_ip->ip)
+#endif
+			{
+				return 1;
+			}
+	}
+	return 0;
+}
+#if IS_ENABLED(CONFIG_IPV6)
+/*!
+  \brief copy ipv6 address
+ */
+static inline void ipv6_addr_copy(const PPA_IN6ADDR *a1, const PPA_IN6ADDR *a2)
+{
+	memcpy((void *) a1, (void *)a2, sizeof(PPA_IN6ADDR));
+}
+/*! \brief return the judgement of IPv6 packet type check.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return The function returns one of the following. \n
+  - IFX_TRUE, if the packet is an IPv6 packet. \n
+  - IFX_FALSE, if the packet is not an IPv6 packet.
+  \note Provide anything required to put in remark section.
+ */
+static inline uint8_t ppa_is_pkt_ipv6(const PPA_BUF *ppa_buf)
+{
+	struct ipv6hdr *hdr  =  ipv6_hdr(ppa_buf);
+	return (hdr->version  ==  6);
+}
+#endif
+#endif /*#ifdef __KERNEL__*/
+/*
+ * ####################################
+ * Declaration
+ * ####################################
+ */
+/** \addtogroup PPA_ADAPTATION_LAYER */
+/*@{*/
+#ifdef __KERNEL__
+/*! \brief Get the ppa adaption layer version
+  \param[in] p_family Pointer to the hardware family
+  \param[in] p_type Pointer to hardware type
+  \param[in] p_if Pointer interface
+  \param[in] p_mode Pointer mode
+  \param[in] p_major Pointer major version number
+  \param[in] p_mid Pointer to min version number
+  \param[in] p_minor Pointer to minor version number
+  \note Provide anything required to put in remark section.
+ */
+void ppa_get_stack_al_id(uint32_t *p_family,
+		uint32_t *p_type,
+		uint32_t *p_if,
+		uint32_t *p_mode,
+		uint32_t *p_major,
+		uint32_t *p_mid,
+		uint32_t *p_minor);
+/*! \brief Get the PPA session according to PPA_BUF
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return returns the PPA session pointer if found, otherwise return NULL
+ */
+PPA_SESSION *ppa_get_session(PPA_BUF *ppa_buf);
+/*! \brief The neighbour cache initialization
+  \param[in] n Pointer to the neighbour.
+  \param[in] dst Pointer to the destination entry.
+ */
+/*void ppa_neigh_hh_init(struct neighbour *n, struct dst_entry *dst);*/
+/*! \brief The neighbour cache update
+  \param[in] neigh Pointer to the neighbour.
+ */
+/*void ppa_neigh_update_hhs(struct neighbour *neigh);*/
+#if IS_ENABLED(CONFIG_IPV6)
+/*! \brief Get the PPA buffer IPv6 transport protocol.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return transport protocol value.
+  \note Provide anything required to put in remark section.
+ */
+uint8_t ppa_get_ipv6_l4_proto(PPA_BUF *ppa_buf);
+/*! \brief Get the PPA buffer IPv6 packet's Type of Service value.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return Type of Service value.
+  \note Provide anything required to put in remark section.
+ */
+uint8_t ppa_get_ipv6_tos(PPA_BUF *ppa_buf);
+/*! \brief Get the PPA buffer IPv6 packet's source IP address.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return source IP address value.
+  \note Provide anything required to put in remark section.
+ */
+PPA_IPADDR ppa_get_ipv6_saddr(PPA_BUF *ppa_buf);
+/*! \brief Get the PPA buffer IPv6 packet's destination IP address.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return destination IP address value.
+  \note Provide anything required to put in remark section.
+ */
+PPA_IPADDR ppa_get_ipv6_daddr(PPA_BUF *ppa_buf);
+/*! \brief Returns if the packet pointed to by ppa_buf is an IPv6 multicast packet.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return This function returns the one of the following values: \n
+  - IFX_TRUE if the packet is an IPv6 multicast packet. \n
+  - IFX_FALSE otherwise. \n
+  \note Provide anything required to put in remark section.
+ */
+int32_t ppa_is_ipv6_multicast(PPA_BUF *ppa_buf);
+/*! \brief Returns if the packet pointed to by ppa_buf is an IPv6 fragment packet.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return This function returns the one of the following values: \n
+  - IFX_TRUE if the packet is an IPv6 fragment packet. \n
+  - IFX_FALSE otherwise. \n
+  \note Provide anything required to put in remark section.
+ */
+uint32_t ppa_is_ipv6_fragment(PPA_BUF *ppa_buf);
+#endif /*CONFIG_IPV6*/
+/*! \brief Get the PPA buffer IPv4 packet's transport protocol value.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return transport protocol value.
+  \note Provide anything required to put in remark section.
+ */
+uint8_t ppa_get_ip_l4_proto(PPA_BUF *ppa_buf);
+/*! \brief Get the PPA buffer IPv4 packet's Type of Service value.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return Type of Service value.
+  \note Provide anything required to put in remark section.
+ */
+uint8_t ppa_get_ip_tos(PPA_BUF *ppa_buf);
+/*! \brief Get the PPA buffer IPv4 packet's source IP address.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return source IP address value.
+  \note Provide anything required to put in remark section.
+ */
+PPA_IPADDR ppa_get_ip_saddr(PPA_BUF *ppa_buf);
+/*! \brief Get the PPA buffer IPv4 packet's destination IP address.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return destination IP address value.
+  \note Provide anything required to put in remark section.
+ */
+PPA_IPADDR ppa_get_ip_daddr(PPA_BUF *ppa_buf);
+/*! \brief Returns if the packet pointed to by ppa_buf is an IPv4 multicast packet.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return This function returns the one of the following values: \n
+  - IFX_TRUE if the packet is an IPv4 multicast packet. \n
+  - IFX_FALSE otherwise. \n
+  \note Provide anything required to put in remark section.
+ */
+int32_t ppa_is_ip_multicast(PPA_BUF *ppa_buf);
+/*! \brief Returns if the packet pointed to by ppa_buf is an IPv4 fragment packet.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return This function returns the one of the following values: \n
+  - IFX_TRUE if the packet is an IPv4 fragment packet. \n
+  - IFX_FALSE otherwise. \n
+  \note Provide anything required to put in remark section.
+ */
+uint32_t ppa_is_ip_fragment(PPA_BUF *ppa_buf);
+/*! \brief Turn the given IP to string and put it to the given buffer.
+  \param[in] ppa_ip the source ip address
+  \param[in] flag the flag of ipv6 or ipv4: 1--ipv6, 0-ipv4
+  \param[out] strbuf contains the string format of IP (the storage buffer should be allocated before calling the api).
+  \return return the point to the given buffer.
+  \note Provide anything required to put in remark section.
+ */
+int8_t *ppa_get_pkt_ip_string(PPA_IPADDR ppa_ip, uint32_t flag, int8_t *strbuf);
+/*! \brief Turn the given MAC address to string and put it to the given buffer.
+  \param[in] *mac point to MAC address buffer.
+  \param[out] *strbuf contains the string format of MAC.
+  \return return the point to the given buffer.
+  \note Provide anything required to put in remark section.
+ */
+int8_t *ppa_get_pkt_mac_string(uint8_t *mac, int8_t *strbuf);
+/*! \brief return the length of IP address.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return return the number of bytes of the length of IP address.
+  \note Provide anything required to put in remark section.
+ */
+uint32_t ppa_get_pkt_ip_len(PPA_BUF *ppa_buf);
+/*! \brief Get the PPA buffer IP protocol
+  \param[in] buf Pointer to the packet buffer.
+  \return The return value can be IP protocol value between 0-255. A value of 0
+  \note Provide anything required to put in remark section.
+ */
+uint8_t ppa_get_pkt_ip_proto(PPA_BUF *buf);
+#ifdef CONFIG_PPA_PP_LEARNING
+/*! \brief Get the PPA buffer ethernet type
+  \param[in] buf Pointer to the packet buffer.
+  \return The return value can be ethernet frame type
+  \note Provide anything required to put in remark section.
+ */
+uint16_t ppa_get_pkt_protocol(PPA_BUF *buf);
+#endif
+/*! \brief Get the PPA buffer IP Type of Service field.
+  \param[in] buf Pointer to the packet buffer.
+  \return The return value is IP header ToS value.
+  \note
+ */
+uint8_t ppa_get_pkt_ip_tos(PPA_BUF *buf);
+/*! \brief Returns source IP address of the packet.
+  \param[in] buf Pointer to the Packet buffer.
+  \param[in] pointer to the he Source IP address of the packet.
+  \note
+ */
+void ppa_get_pkt_src_ip(PPA_IPADDR *ip, PPA_BUF *buf);
+/*! \brief Get multicast packet's dest & src IP address
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \param[out] dst_ip Pointer to the dst ip buffer.
+  \param[out] src_ip Pointer to the src ip buffer.
+  \return Success if the packet is a mulitcast packet
+  \note
+ */
+int ppa_get_multicast_pkt_ip(PPA_BUF *ppa_buf, void *dst_ip, void *src_ip);
+/*! \brief Returns destination IP address of the packet.
+  \param[in] buf Pointer to the packet buffer.
+  \param[in] Pointer the Destination IP address of the packet..
+  \note
+ */
+void ppa_get_pkt_dst_ip(PPA_IPADDR *ip, PPA_BUF *buf);
+/*! \brief Returns source TCP/UDP port of the IP packet.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return TCP/UDP Source Port of the packet.
+  \note
+ */
+uint16_t ppa_get_pkt_src_port(PPA_BUF *ppa_buf);
+/*! \brief Returns destination TCP/UDP port of the packet.
+  \param[in] ppa_buf Pointer to the PPA packet buffer.
+  \return TCP/UDP Destination Port of the packet.
+  \note
+ */
+uint16_t ppa_get_pkt_dst_port(PPA_BUF *ppa_buf);
+/*! \brief Get the Source MAC address pointer of the packet.
+  \param[in] ppa_buf Pointer to the PPA packet buffer.
+  \return Pointer to the start of the packet source MAC address.
+  \note This API may not implemented on older PPA version.
+ */
+uint8_t *ppa_get_pkt_src_mac_ptr(PPA_BUF *ppa_buf);
+/*! \brief Get the Source MAC address of the packet as received by the router.
+  \param[in] ppa_buf Pointer to the PPA packet buffer.
+  \param[out] mac MAC address buffer in which the source MAC address is copied by the function.
+  \return This function does not return anything.
+  \note This API may not implemented on older PPA version.
+ */
+void ppa_get_pkt_rx_src_mac_addr(PPA_BUF *ppa_buf, uint8_t mac[PPA_ETH_ALEN]);
+/*! \brief Get the Source MAC address.
+  \param[in] ppa_buf Pointer to the PPA packet buffer.
+  \param[out] mac MAC address buffer in which the source MAC address is copied by the function.
+  \param[in] offset Offest from skb data pointer to extract the mac address.
+  \return This function does not return anything.
+ */
+void ppa_get_src_mac_addr(PPA_BUF *ppa_buf, uint8_t mac[PPA_ETH_ALEN], const int offset);
+/*! \brief Get the Destination MAC address of the packet as received by the router.
+  \param[in] ppa_buf Pointer to the PPA packet buffer.
+  \param[out] mac MAC address buffer in which the Destination MAC address is copied by the function.
+  \return This function does not return anything.
+  \note This API may not implemented on older PPA version.
+ */
+void ppa_get_pkt_rx_dst_mac_addr(PPA_BUF *ppa_buf, uint8_t mac[PPA_ETH_ALEN]);
+/*! \brief Returns source (i.e. Received) interface of the packet at the router.
+  \param[in] ppa_buf Pointer to the PPA packet buffer.
+  \return Pointer to the Source /Rx Interface of the packet. The following values can be returned.\n
+  - NULL on error
+  - Pointer to Rx interface of the packet
+  \note This API may not implemented on older PPA version.
+ */
+PPA_NETIF *ppa_get_pkt_src_if (PPA_BUF *ppa_buf);
+/*! \brief Returns Destination (i.e. Tx) interface of the packet at the router (for packets forwarded at IP or bridge level).
+  \param[in] ppa_buf Pointer to the PPA packet buffer.
+  \return Pointer to the Destination /Tx Interface of the packet. The following values can be returned.\n
+  - NULL on error
+  - Pointer to Rx interface of the packet
+  \note This API may not implemented on older PPA version.
+ */
+PPA_NETIF *ppa_get_pkt_dst_if (PPA_BUF *ppa_buf);
+#if defined(CONFIG_PPA_HANDLE_CONNTRACK_SESSIONS)
+/*! \brief Returns session priority based on skb
+  \param[in] ppa_buf Pointer to the PPA packet buffer.
+  \return mark if sucessful. otherwise return -1;
+ */
+uint32_t ppa_get_session_priority(PPA_BUF *ppa_buf);
+/*! \brief Returns low priority session threshold value
+  \param[in] flags (for future use)
+  \return nf_conntrack_low_prio_thresh;
+ */
+uint32_t ppa_get_low_prio_thresh(uint32_t flags);
+/*! \brief Returns default priority session threshold value
+  \param[in] flags (for future use)
+  \return nf_conntrack_def_prio_thresh;
+ */
+uint32_t ppa_get_def_prio_thresh(uint32_t flags);
+/*! \brief Returns low priority session data rate
+  \param[in] flags (for future use)
+  \return nf_conntrack_low_prio_data_rate;
+ */
+uint32_t ppa_get_low_prio_data_rate(uint32_t flags);
+/*! \brief Returns tcp initial offset
+  \param[in] flags (for future use)
+  \return nf_conntrack_tcp_initial_offset;
+ */
+uint32_t ppa_get_tcp_initial_offset(uint32_t flags);
+/*! \brief Returns tcp steady offset
+  \param[in] flags (for future use)
+  \return nf_conntrack_tcp_steady_offset;
+ */
+uint32_t ppa_get_tcp_steady_offset(uint32_t flags);
+/*! \brief Returns default priority session data rate
+  \param[in] flags (for future use)
+  \return nf_conntrack_def_prio_data_rate;
+ */
+uint32_t ppa_get_def_prio_data_rate(uint32_t flags);
+/*! \brief Returns nf_conntrack_session_limit_enable value
+  \param[in] flags (for future use)
+  \return nf_conntrack_session_limit_enable;
+ */
+uint32_t ppa_get_session_limit_enable(uint32_t flags);
+/*! \brief Returns delta timespec structure between lhs and rhs
+  \param[in] lhs timespec structure, rhs timespec structure
+  \return delta timespec structure;
+ */
+struct timespec ppa_timespec_sub(struct timespec lhs, struct timespec rhs);
+/*! \brief Returns time in nano seconds for a timespec structure
+  \param[in] Pointer to timespec structure
+  \return time in nanoseconds;
+ */
+s64 ppa_timespec_to_ns(struct timespec *lhs);
+/*! \brief Returns time in nano seconds for a timespec structure
+  \param[in] Pointer to timespec structure
+  \return time in nanoseconds;
+ */
+void ppa_get_monotonic(struct timespec *lhs);
+#endif
+/*!
+  \brief get ppoe mac address and session id
+  \param[in] netif Pointer to pppoe network interface.
+  \param[out] *pa Pointer to pppoe addres.
+  \return Pointer to the Destination /Tx Interface of the packet. The following values can be returned.\n
+  - NULL on error
+  - Pointer to Rx interface of the packet
+  \note This API may not implemented on older PPA version.
+ */
+int32_t ppa_pppoe_get_pppoe_addr(PPA_NETIF *netif, struct pppoe_addr *pa);
+/*! \brief Returns the PPPoE session Id of the net interface structure.
+  \param[in] netif Pointer network interface structure.
+  \return The return value can be any one of the following:\n
+  - Non-zero value is PPPoE Session Id
+  - Zero indicates no valid PPPoE session.
+  \note
+ */
+__u16 ppa_pppoe_get_pppoe_session_id(PPA_NETIF *netif);
+/*! \brief Returns the PPPoE session Id of the packet.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return The return value can be any one of the following:\n
+  - Non-zero value is PPPoE Session Id. \n
+  - Zero indicates no valid PPPoE session i.e. not a PPPoE session packet.
+  \note
+ */
+__u16 ppa_get_pkt_pppoe_session_id(PPA_BUF *ppa_buf);
+/*! \brief get the pppoe's sub ethernet interface name
+  \param[in] netif Pointer to ppp network interface
+  \param[out] pppoe_eth_ifname Provide buffer to store its sub ethernet interface name
+  \return The return value can be any one of the following:\n
+  - Non-zero fail to get its sub ethernet interface name \n
+  - Zero indicates succeed
+  \note
+ */
+int32_t ppa_pppoe_get_eth_netif (PPA_NETIF *netif, PPA_IFNAME pppoe_eth_ifname[PPA_IF_NAME_SIZE]);
+/*! \brief This function returns the physical or underlying interface (Ethernet-like) for a PPPoE interface specified by netif..
+  \param[in] netif Pointer to the network interface structure in the stack.
+  \param[in] ifname Pointer to the network interface name.
+  \param[out] phy_ifname Interface name buffer in which the Physical interface name is copied by the function.
+  \return The return value can be any one of the following:\n
+  - PPA_SUCCESS, if PPPoE physical address retrieved ok
+  - PPA_FAILURE, on error
+  \note
+ */
+int32_t ppa_pppoe_get_physical_if (PPA_NETIF *netif, PPA_IFNAME *ifname, PPA_IFNAME phy_ifname[PPA_IF_NAME_SIZE]);
+/*! \brief check whether it is a ppp interface
+  \param[in] netif Pointer to the network interface structure in the stack.
+  \return The return value can be any one of the following:\n
+  - PPA_SUCCESS, on success. \n
+  - PPA_FAILURE, on error.
+  \note This API may not implemented on older PPA version.
+ */
+uint32_t ppa_check_is_ppp_netif (PPA_NETIF *netif);
+/*! \brief check whether it is a pppoe interface
+  \param[in] netif Pointer to the network interface structure in the stack.
+  \return The return value can be any one of the following:\n
+  - PPA_SUCCESS, on success. \n
+  - PPA_FAILURE, on error.
+  \note This API may not implemented on older PPA version.
+ */
+uint32_t ppa_check_is_pppoe_netif (PPA_NETIF *netif);
+/*! \brief get pppoe's destination mac address, ie, remote peer's mac address
+  \param[in] netif Pointer to the network interface structure in the stack.
+  \param[out] mac provide buffer to store desnation mac address
+  \return The return value can be any one of the following:\n
+  - PPA_SUCCESS, on success. \n
+  - PPA_FAILURE, on error.
+  \note This API may not implemented on older PPA version.
+ */
+int32_t ppa_pppoe_get_dst_mac(PPA_NETIF *netif , uint8_t mac[PPA_ETH_ALEN]);
+int32_t ppa_pppol2tp_get_base_netif (PPA_NETIF *netif, PPA_IFNAME pppol2tp_eth_ifname[PPA_IF_NAME_SIZE]);
+int32_t ppa_pppol2tp_get_src_addr(PPA_NETIF *netif, uint32_t *outer_srcip);
+int32_t ppa_pppol2tp_get_dst_addr(PPA_NETIF *netif, uint32_t *outer_dstip);
+int32_t ppa_pppol2tp_get_l2tp_addr(PPA_NETIF *netif, struct pppol2tp_addr *pa);
+int32_t ppa_pppol2tp_get_physical_if (PPA_NETIF *netif, PPA_IFNAME *ifname, PPA_IFNAME phy_ifname[PPA_IF_NAME_SIZE]);
+/*! \brief get pppol2tp's destination mac address, ie, remote peer's mac address
+  \param[in] netif Pointer to the network interface structure in the stack.
+  \param[out] mac provide buffer to store desnation mac address
+  \return The return value can be any one of the following:\n
+  - IFX_SUCCESS, on success. \n
+  - IFX_FAILURE, on error.
+  \note This API may not implemented on older PPA version.
+ */
+int32_t ppa_pppol2tp_get_l2tp_dmac(PPA_NETIF *netif, uint8_t *mac);
+/*! \brief Returns the PPPoL2TP Session Id of the packet.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return The return value can be any one of the following:\n
+  - Non-zero value is PPPoL2TP Session Id. \n
+  - Zero indicates no valid PPPoL2TP Session i.e. not a PPPoL2TP Session packet.
+  \note
+ */
+__u16 ppa_pppol2tp_get_l2tp_session_id(PPA_NETIF *netif);
+/*! \brief Returns the PPPoL2TP tunnel Id of the packet.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return The return value can be any one of the following:\n
+  - Non-zero value is PPPoL2TP tunnel Id. \n
+  - Zero indicates no valid PPPoL2TP tunnel i.e. not a PPPoL2TP tunnel packet.
+  \note
+ */
+__u16 ppa_pppol2tp_get_l2tp_tunnel_id(PPA_NETIF *netif);
+/*! \brief check whether it is a pppol2tp interface
+  \param[in] netif Pointer to the network interface structure in the stack.
+  \return The return value can be any one of the following:\n
+  - IFX_SUCCESS, on success. \n
+  - IFX_FAILURE, on error.
+  \note This API may not implemented on older PPA version.
+ */
+uint32_t ppa_check_is_pppol2tp_netif (PPA_NETIF *netif);
+/*! \brief check whether lro is enabled on interface
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \param[in] netif Pointer to the network interface structure in the stack.
+  \return The return value can be any one of the following:\n
+  - IFX_SUCCESS, on success. \n
+  - IFX_FAILURE, on error.
+  \note This API may not implemented on older PPA version.
+ */
+uint32_t ppa_check_is_lro_enabled_netif (PPA_NETIF *netif, uint8_t mac[PPA_ETH_ALEN]);
+/*! \brief This function returns the destination MAC address to be used in the Ethernet frame when transmitted out of the router.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \param[in] p_session Pointer to the NAT connection tracking session to which the packet belongs. This parameter may not be required in the function implementation, for eg. on Linux 2.4 adaptation.
+  \param[out] mac The destination MAC address for the specific packet is copied into this field.
+  \return The return value can be any one of the following: \n
+  - PPA_SUCCESS, if destination MAC address is retrieved ok \n
+  - PPA_FAILURE, on error
+  \note
+ */
+int32_t ppa_get_dst_mac(PPA_BUF *ppa_buf, PPA_SESSION *p_session, uint8_t mac[PPA_ETH_ALEN], uint32_t daddr);
+/*! \brief Returns the pointer to network interface data structure in the stack for the specified interface name. For Linux, this is the netdevice structure pointer.
+  \param[in] ifname Pointer to the interface name.
+  \return The return value can be any one of the following: \n
+  - Pointer to network interface structure, on success. \n
+  - NULL on error.
+  \note This function needs to ensure that it has a handle / reference count to the network interface structure, so that the interface structure cannot be deleted while the PPA has a reference to it. Please see the section Release Reference to network interface structure for the function to release the PPA's reference to the PPA_NETIF structure when done.
+ */
+PPA_NETIF *ppa_get_netif (const PPA_IFNAME *ifname);
+/*! \brief Returns the pointer to network interface data structure in the stack for the specified interface name in the net namespace passed. For Linux, this is the netdevice structure pointer.
+  \param[in] ifname Pointer to the network namespace.
+  \param[in] ifname Pointer to the interface name.
+  \return The return value can be any one of the following: \n
+  - Pointer to network interface structure, on success. \n
+  - NULL on error.
+  \note This function needs to ensure that it has a handle / reference count to the network interface structure, so that the interface structure cannot be deleted while the PPA has a reference to it. Please see the section Release Reference to network interface structure for the function to release the PPA's reference to the PPA_NETIF structure when done.
+ */
+PPA_NETIF *ppa_get_netif_by_net(const struct net *net, const PPA_IFNAME *ifname);
+
+/*#ifdef CONFIG_LTQ_MINI_JUMBO_FRAME_SUPPORT*/
+/*! \brief This function returns the MTU of the interface.
+  \param[in] netif Pointer to the netif structure.
+  \return MTU size.
+  \note
+ */
+int ppa_get_mtu(PPA_NETIF *netif);
+/*#endif*/
+#if defined(CONFIG_PPA_TCP_LITEPATH) && CONFIG_PPA_TCP_LITEPATH
+/*! \brief This function calls the ip routing function.
+  \param[in] skb Pointer to the sk_buff structure.
+  \param[in] netif Pointer to the netif structure.
+  \return error if there is any proplem in routing the packet.
+  \note
+ */
+int ppa_do_ip_route(PPA_BUF *skb, PPA_NETIF *netif);
+#endif
+/*! \brief This function releases the reference to a PPA_NETIF structure obtained through the function ppa_get_netif.
+  \param[in] netif Pointer to the netif structure.
+  \return No return value.
+  \note
+ */
+void ppa_put_netif (PPA_NETIF *netif);
+/*! \brief Get the MAC address of the specified interface of the router. It is valid for an Ethernet-like interface or a PPPoE interface bound to the former.
+  \param[in] netif Pointer to the network interface structure.
+  \param[out] mac MAC address buffer in which the MAC address of the interface is copied by the function if its an Ethernet like interface.
+  \param[in] flag_down_only down search only or up stream search also
+  \return No return value.
+  \note This API may not implemented on older PPA version.
+ */
+int32_t ppa_get_netif_hwaddr(PPA_NETIF *netif, uint8_t mac[PPA_ETH_ALEN], uint32_t flag_down_only);
+/*! \brief Get the bridge device from given device
+  \param[in] netif Pointer to the network interface structure.
+  \return return bridge netdevice pointer or NULL
+  \note This API may not implemented on older PPA version.
+ */
+PPA_NETIF *ppa_get_br_dev(PPA_NETIF *netif);
+/*! \brief This function checks if the interface name prefix specified applies for the interface name of the specified PPA_NETIF structure. For eg., eth0 and eth1 both have network prefix of eth (n = 3).
+  \param[in] netif Pointer to the network interface structure.
+  \param[in] ifname_prefix Pointer to the network interface name prefix.
+  \param[in] n Number of bytes of the prefix to compare with the interface name of the netif.
+  \return The function returns one of the following. \n
+  - IFX_TRUE, if the netif corresponds to the ifname prefix. \n
+  - IFX_FALSE, if the netif is not matching the ifname prefix.
+  \note This API may not implemented on older PPA version.
+ */
+uint32_t ppa_is_netif_name_prefix(PPA_NETIF *netif, PPA_IFNAME *ifname_prefix, int32_t n);
+/*! \brief Get the Physical or underlying Interface for the interface specified by netif or ifname pointers. If netif is specified, it is used for the lookup, else ifname is used.
+  \param[in] netif Pointer to the network interface structure for which physical interface needs to be determined.
+  \param[in] ifname Pointer to the network interface name for which physical interface needs to be determined.
+  \param[in] phy_ifname Interface name buffer in which the Physical interface name is copied by the function.
+  \return This function returns the following values. \n
+  - PPA_SUCCESS, on success. \n
+  - PPA_FAILURE, on error. \n
+  \note This API may not implemented on older PPA version.
+ */
+int32_t ppa_get_physical_if (PPA_NETIF *netif, PPA_IFNAME *ifname, PPA_IFNAME phy_ifname[PPA_IF_NAME_SIZE]);
+/*! \brief Get the lower or macvlan base Interface for the interface specified by netif or ifname pointers. If netif is specified, it is used for the lookup, else ifname is used.
+  \param[in] netif Pointer to the network interface structure for which physical interface needs to be determined.
+  \param[in] ifname Pointer to the network interface name for which physical interface needs to be determined.
+  \param[in] lower_ifname Interface name buffer in which the lower or macvlan interface name is copied by the function.
+  \return This function returns the following values. \n
+  - PPA_SUCCESS, on success. \n
+  - PPA_FAILURE, on error. \n
+  \note This API may not implemented on older PPA version.
+ */
+int32_t ppa_get_lower_if (PPA_NETIF *netif, PPA_IFNAME *ifname, PPA_IFNAME lower_ifname[PPA_IF_NAME_SIZE]);
+/*! \brief Get the lower or macvlan base Interface for the interface specified by netif or ifname pointers. If netif is specified, it is used for the lookup, else ifname is used.
+  \param[in] netif Pointer to the network interface structure for which physical interface needs to be determined.
+  \param[in] ifname Pointer to the network interface name for which physical interface needs to be determined.
+  \param[in] lower_ifname Interface name buffer in which the lower or macvlan interface name is copied by the function.
+  \return This function returns the following values. \n
+  - PPA_SUCCESS, on success. \n
+  - PPA_FAILURE, on error. \n
+  \note This API may not implemented on older PPA version.
+ */
+int32_t ppa_get_lower_if (PPA_NETIF *netif, PPA_IFNAME *ifname, PPA_IFNAME lower_ifname[PPA_IF_NAME_SIZE]);
+/*! \brief This function gives the vlan interface name specified by netif strucutre or ifname pointers. One of the two arguments needs to be specified in the function.
+  \param[in] netif Pointer to the network interface structure for VLAN interface check is to be done.
+  \param[in] ifname Pointer to the network interface name for which VLAN check is to be done.
+  \param[in] vlan_ifname Buffer where the vlan interface name is copied by the function.
+  \return The function returns one of the following. \n
+  - IFX_TRUE, if the interface exist. \n
+  - IFX_FALSE, if the interface doesn't exist.
+  \note
+ */
+int32_t ppa_get_underlying_vlan_if (PPA_NETIF *netif, PPA_IFNAME *ifname, PPA_IFNAME vlan_ifname[PPA_IF_NAME_SIZE]);
+/*! \brief This function checks whether the interface specified by netif or ifname pointers is a VLAN interface. One of the two arguments needs to be specified in the function.
+  \param[in] netif Pointer to the network interface structure for VLAN interface check is to be done.
+  \param[in] ifname Pointer to the network interface name for which VLAN check is to be done.
+  \return This function returns the following values. \n
+  - PPA_SUCCESS, if the VLAN interface exist. \n
+  - IFX_FALSE, if the interface is does not exist.
+  \note
+ */
+int32_t ppa_if_is_vlan_if (PPA_NETIF *netif, PPA_IFNAME *ifname);
+int32_t ppa_is_macvlan_if (PPA_NETIF *netif, PPA_IFNAME *ifname);
+/*! \brief This function returns the physical or underlying interface (Ethernet-like) for a pseudo VLAN interface specified by netif structure or interface name.
+  \param[in] netif Pointer to the VLAN net interface structure.
+  \param[in] ifname Pointer to the VLAN interface name for which underlying interface is to be determined
+  \param[out] phy_ifname Buffer where the physical/underlying interface is copied by the function for the VLAN interface ifname.
+  \return This function returns the following values. \n
+  - IFX_TRUE, if the interface is a VLAN interface \n
+  - PPA_FAILURE, if the interface is not a VLAN interface
+  \note
+ */
+int32_t ppa_vlan_get_underlying_if (PPA_NETIF *netif, PPA_IFNAME *ifname, PPA_IFNAME phy_ifname[PPA_IF_NAME_SIZE]);
+/*! \brief This function returns the physical or underlying interface (Ethernet-like) for a pseudo VLAN interface specified by netif structure or interface name.
+  \param[in] netif Pointer to the VLAN network interface structure.
+  \param[in] ifname Pointer to the VLAN interface name for which underlying interface is to be determined.
+  \param[out] phy_ifname Buffer where the physical/underlying interface is copied by the function for the VLAN interface.
+  \return This function returns the following values. \n
+  - PPA_SUCCESS, if the VLAN interface exist \n
+  - PPA_FAILURE, if the interface is does not exist\n
+  \note
+ */
+int32_t ppa_vlan_get_physical_if (PPA_NETIF *netif, PPA_IFNAME *ifname, PPA_IFNAME phy_ifname[PPA_IF_NAME_SIZE]);
+/*! \brief This function returns the VLAN Id and tag info for a VLAN interface specified by netif. This includes the VLAN tag, 802.1P bits and the CFI bit. The caller will first determine if the network interface is a VLAN interface before invoking this function.
+  \param[in] netif Pointer to the network interface structure for which VLANId is to be returned.
+  \return This function returns the VLAN TCI (Tag control information).
+  \note
+ */
+uint32_t ppa_get_vlan_id(PPA_NETIF *netif);
+/*! \brief This function returns the VLAN type and for a VLAN interface specified by netif. The caller will first determine if the network interface is a VLAN interface before invoking this function.
+  \param[in] netif Pointer to the network interface structure for which VLANId is to be returned.
+  \return This function returns the VLAN type (802.1q or 802.1ad)
+  \note
+ */
+uint16_t ppa_get_vlan_type(PPA_NETIF *netif);
+/*! \brief This function returns the TCI including priority and VLAN Id for a PPA buffer pointer by buf.
+  \param[in] buf Pointer to PPA buffer.
+  \return This function returns the VLAN TCI (Tag control information).
+  \note
+ */
+uint32_t ppa_get_vlan_tag(PPA_BUF *buf);
+#ifdef NO_DOXY
+int32_t ppa_get_bridge_member_ifs(PPA_IFNAME *ifname, int *, PPA_IFNAME **);
+uint32_t cal_64_div(uint64_t t1, uint64_t t2);
+#define PPA_SKB_FREE dev_kfree_skb_any
+#endif
+/*! \brief This function returns whether the interface specified by ifname or netif pointer is a bridge interface, i.e. other interfaces are enslaved to this bridge interface. For eg., br0 is a bridge interface in Linux which may have bridge members like eth0, nas0 etc.
+  \param[in] netif Pointer to the network interface structure for which bridge interface check is to be done.
+  \param[in] ifname Pointer to the network interface name for which bridge interface check is to be done.
+  \return This function returns the one of the following values: \n
+  - IFX_TRUE, if the network interface is a bridge interface/port. \n
+  - IFX_FALSE, if the network interface is not a bridge interface/port.
+  \note
+ */
+int32_t ppa_if_is_br_if (PPA_NETIF *netif, PPA_IFNAME *ifname);
+/*! \brief This function performs a bridge forwarding database lookup for the bridge specified by netif and returns the member interface on which the packet needs to be forwarded.
+  \param[in] netif Pointer to the network interface structure for the bridge interface where destination lookup is to be performed.
+  \param[in] buf Pointer to the packet buffer for the frame which has to be bridged (forwarded at Layer-2).
+  \param[out] p_netif Pointer to the bridge member network interface structure to which the packet needs to be forwarded.
+  \return This function returns the one of the following values: \n
+  - PPA_SUCCESS, if the lookup is successful in the bridge forwarding database. \n
+  - PPA_FAILURE, if the lookup is not successful.\n
+  \note
+ */
+
+/*! \brief This function checks if the interface specified by netif is a loopback device.
+  \param[in] netif Pointer to the network interface structure for the check is to be performed.
+  \return This function returns the one of the following values: \n
+  - PPA_SUCCESS, Interface is a loopback device. \n
+  - PPA_FAILURE, Error.
+  \note
+ */
+int ppa_dev_is_loopback(PPA_NETIF *netif);
+
+/*! \brief This function checks if the interface specified by netif is a Virtual Ethernet Tunnel device.
+  \param[in] netif Pointer to the network interface structure for the check is to be performed.
+  \param[in] ifname Pointer to the interface name for which the check is to be performed.
+  \return This function returns the one of the following values: \n
+  - PPA_SUCCESS, Interface is a veth device. \n
+  - PPA_FAILURE, Error.
+  \note
+ */
+int32_t ppa_if_is_veth_if(PPA_NETIF *netif, PPA_IFNAME *ifname);
+
+/*! \brief This function returns the current net namespace.
+  \return This function returns the current namespace: \n
+  \note
+ */
+
+struct net *ppa_get_current_net_ns(void);
+
+int32_t ppa_get_br_dst_port(PPA_NETIF *netif, PPA_BUF *buf, PPA_NETIF **p_netif);
+/*! \brief This function returns the ip address of the network interface.
+  \param[in] ip Pointer to the buffer which holds the ip address.
+  \param[in] netif Pointer to the network interface structure for which bridge interface check is to be done.
+  \return This function returns the one of the following values: \n
+  - PPA_SUCCESS, if the network interface ip address is found. \n
+  - PPA_FAILURE, if the network interface is not having any ip address assigned.
+  \note
+ */
+int32_t ppa_get_netif_ip(uint32_t *ip, PPA_NETIF *netif);
+/*! \brief This function computes 6rd destination address based on the ipv6 prefix match if not then BR address as the destination address.
+  \param[in] dev Pointer to the network interface structure.
+  \param[in] ppa_buf Pointer to the packet buffer.
+  \return This function returns the tunnel destination address
+  \note
+ */
+extern uint32_t ppa_get_6rdtunel_dst_ip(PPA_BUF *skb, PPA_NETIF *dev);
+/*! \brief This function computes 6rd physical netif.
+  \param[in] dev Pointer to the network interface structure.
+  \return This function returns base netdevie datastructure
+  \note
+ */
+extern struct net_device *ppa_get_6rd_phyif (struct net_device *dev);
+/*! \brief This function computes dslite physical netif.
+  \param[in] dev Pointer to the network interface structure.
+  \return This function returns base netdevie datastructure
+  \note
+ */
+extern struct net_device *ppa_get_ip4ip6_phyif (struct net_device *dev);
+/*! \brief This function check whether given interface is GRE.
+  \param[in] dev Pointer to the network interface structure.
+  \return Returns non-zero value if given interface GRE
+  \note
+ */
+uint32_t ppa_is_gre_netif (PPA_NETIF *dev);
+/*! \brief This function check whether given interface is GRE and also returns
+  type of GRE tunnel - IPv4/IPv6 & IP GRE/EoGRE
+  \param[in] dev Pointer to the network interface structure.
+  \param[out] isIPv4Gre Pointer to uint8_t. Set to 1 if IPv4 tunnel
+  \param[out] isGreTap Pointer to uint8_t. Set 1 if tunnel is EoGRE
+  \return Returns non-zero value if given interface GRE
+  \note
+ */
+uint32_t ppa_is_gre_netif_type(struct net_device *dev,
+		uint8_t *isIPv4Gre,
+		uint8_t *isGreTap);
+/*! \brief This function returns the base interface of GRE device.
+  \param[in] dev Pointer to the network interface structure.
+  \return On success returns base physical interface of GRE dev.
+  On failure returns NULL
+  \note
+ */
+struct net_device *ppa_get_gre_phyif (PPA_NETIF *dev);
+/*! \brief This function returns required GRE header len.
+  \param[in] dev Pointer to the network interface structure.
+  \param[out] hdrlen Pointer to the uint32_t to hold GRE header len.
+  \return On success returns PPA_SUCCESS and GRE header len is passed
+  in hdrlen
+  \note
+ */
+int32_t ppa_get_gre_hdrlen(PPA_NETIF *dev, uint16_t *hdrlen);
+/*! \brief This function forms GRE header for a given GRE interface.
+  \param[in] dev Pointer to the network interface structure.
+  \param[in] isIPv6 Set to 1 if session is IPv6
+  \param[in] Data length to be carried on GRE
+  \param[out] pHdr Pointer to buffer. The formated GRE header is returned
+  in this buffer.
+  \param[in,out] len Pointer to uint32_t. Caller should pass the len of
+  the buffer. On return it contains actual GRE header len.
+  \return Returns PPA_SUCCESS value if GRE header is formed.
+  \note
+ */
+int32_t ppa_form_gre_hdr(PPA_NETIF *dev,
+		uint8_t isIPv6,
+		uint16_t dataLen,
+		uint8_t *pHdr,
+		uint16_t *len);
+/*! \brief This function performs a bridge forwarding database lookup for the bridge specified by netif and returns the member interface on which the packet needs to be forwarded.
+  \param[in] netif Pointer to the network interface structure for the bridge interface where destination lookup is to be performed.
+  \param[in] mac Pointer to destination mac address.
+  \param[out] p_netif Pointer to the bridge member network interface structure to which the packet needs to be forwarded.
+  \return This function returns the one of the following values: \n
+  - PPA_SUCCESS, if the lookup is successful in the bridge forwarding database. \n
+  - PPA_FAILURE, if the lookup is not successful.
+  \note
+ */
+int32_t ppa_get_br_dst_port_with_mac(PPA_NETIF *netif, uint8_t mac[PPA_ETH_ALEN], PPA_NETIF **p_netif);
+/*! \brief This function returns the PPA ATM VC structure for the EoATM (RFC 2684 Ethernet over ATM) interface specified by netif.
+  \param[in] netif Pointer to the network interface structure for the bridge interface where destination lookup is to be performed.
+  \param[in] pvcc Pointer to the pointer to PPA_VCC structure which is set to the VC associated with the EoATM interface specified by netif.
+  \return This function returns the one of the following values: \n
+  - PPA_SUCCESS, if the VCC structure is found for the EoATM interface \n
+  - PPA_FAILURE, on error
+  \note
+ */
+int32_t ppa_br2684_get_vcc(PPA_NETIF *netif, PPA_VCC **pvcc);
+/*! \brief This function checks if the interface specified by netif or ifname pointers is an EoATM interface as per RFC2684. The interface will be specified by passing one of netif and ifname in the call.
+  \param[in] netif Pointer to the network interface structure for the EoATM check is to be performed.
+  \param[in] ifname Pointer to the interface name for which the EoATM check is to be performed.
+  \return This function returns the one of the following values: \n
+  - IFX_TRUE, if the interface is an EoATM interface. \n
+  - IFX_FALSE, if the interface is not an EoATM interface. \n
+  \note
+ */
+int32_t ppa_if_is_br2684(PPA_NETIF *netif, PPA_IFNAME *ifname);
+/*! \brief This function checks if the interface specified by netif or ifname pointers is bridged or routed encapsulaton.
+  \param[in] netif Pointer to the network interface structure for the check is to be performed.
+  \param[in] ifname Pointer to the interface name for which the check is to be performed.
+  \return This function returns the one of the following values: \n
+  - PPA_SUCCESS, Interface is enabled with IP encapsulation. \n
+  - PPA_FAILURE, Error.
+  \note
+ */
+
+/*! \brief This function checks if the interface specified by netif is a Virtual Ethernet Tunnel device.
+  \param[in] netif Pointer to the network interface structure for the check is to be performed.
+  \param[in] ifname Pointer to the interface name for which the check is to be performed.
+  \return This function returns the one of the following values: \n
+  - PPA_SUCCESS, Interface is a veth device. \n
+  - PPA_FAILURE, Error.
+  \note
+ */
+int32_t ppa_if_is_veth(struct net_device *dev);
+
+int32_t ppa_if_is_ipoa(PPA_NETIF *netif, PPA_IFNAME *ifname);
+/*! \brief This function returns the PPA ATM VC structure for the PPPoA (RFC 2364 PPP over AAL5) interface specified by netif.
+  \param[in] netif Pointer to the network interface structure for the bridge interface where destination lookup is to be performed.
+  \param[out] patmvcc Pointer to the pointer to PPA_VCC structure which is set to the VC associated with the PPPoATM interface specified by netif.
+  \return This function returns the one of the following values: \n
+  - PPA_SUCCESS, if the VCC structure is found for the PPPoATM interface. \n
+  - PPA_FAILURE, on error.
+  \note
+ */
+int32_t ppa_pppoa_get_vcc(PPA_NETIF *netif, PPA_VCC **patmvcc);
+/*! \brief check whether it is a pppoa session.
+  \param[in] netif Pointer to the interface's netif
+  \param[in] ifname Pointer to interface name
+  \return This function returns the one of the following values: \n
+  - IFX_TRUE if the two session pointers are the same. \n
+  - IFX_FALSE if the two session pointers point to different sessions. \n
+  \note, one of netif and ifname should be not NULL.
+ */
+int32_t ppa_if_is_pppoa(PPA_NETIF *netif, PPA_IFNAME *ifname);
+/*! \brief Returns true if the two sessions are the same.
+  \param[in] p_session1 Pointer to the PPA session 1.
+  \param[in] p_session2 Pointer to the PPA session 2.
+  \return This function returns the one of the following values: \n
+  - IFX_TRUE if the two session pointers are the same. \n
+  - IFX_FALSE if the two session pointers point to different sessions. \n
+  \note
+ */
+uint32_t ppa_is_session_equal(PPA_SESSION *p_session1, PPA_SESSION *p_session2);
+/*! \brief Get the Stack session Helper function for connection tracking. Such helper functions exist when a Connection tracking / SPI logic for the application protocol of that session. Examples are FTP control session, SIP signalling session etc.
+  \param[in] p_session Pointer to the PPA Session.
+  \return This function returns the one of the following values: \n
+  - Pointer to the session helper function as an uint32_t if helper exists. \n
+  - NULL otherwise. \n
+  \note The exact pointer of the session helper function is not of interest to PPA. Adaptations may just return IFX_TRUE if session has helper function, and return IFX_FALSE otherwise.
+ */
+uint32_t ppa_get_session_helper(PPA_SESSION *p_session);
+/*! \brief Is the PPA session pointing to a special session which needs "slow path" handling due to protocol processing requirements of connection tracking, NAT or by any other criteria. Examples are FTP control session, SIP signalling session etc.The API can check the session based on either a PPA buffer pointer or a PPA session pointer.
+  \param[in] ppa_buf Pointer to the PPA Buffer.
+  \param[in] p_session Pointer to the PPA Session.
+  \return This function returns the one of the following values: \n
+  - IFX_TRUE if the session is a special session. \n
+  - IFX_FALSE otherwise\note. \n
+  \note
+ */
+uint32_t ppa_check_is_special_session(PPA_BUF *ppa_buf, PPA_SESSION *p_session);
+/*! \brief Returns if the packet pointed to by ppa_buf is a fragmented IP datagram.
+  \param[in] ppa_buf Pointer to the PPA Buffer.
+  \return This function returns the one of the following values: \n
+  - IFX_TRUE if packet is fragment of an IP datagram. \n
+  - IFX_FALSE if the packet is a non-fragmented IP datagram. \n
+  \note
+ */
+uint32_t ppa_is_pkt_fragment(PPA_BUF *ppa_buf);
+/*! \brief Returns if the packet pointed to by ppa_buf is a multicast packet.
+  \param[in] ppa_buf Pointer to the PPA Buffer.
+  \return This function returns the one of the following values: \n
+  - IFX_TRUE if the packet is a multicast packet. \n
+  - IFX_FALSE otherwise. \n
+  \note
+ */
+int32_t ppa_is_pkt_multicast(PPA_BUF *ppa_buf);
+/*! \brief Returns if the packet pointed to by ppa_buf is routed, i.e. forwarded at IP layer.
+  \param[in] ppa_buf Pointer to the PPA Buffer.
+  \return This function returns the one of the following values: \n
+  - IFX_TRUE if packet is forwarded at IP layer. \n
+  - IFX_FALSE if the packet is not forwarded at IP layer \n
+  \note
+ */
+int32_t ppa_is_pkt_routing(PPA_BUF *ppa_buf);
+/*! \brief Returns if the packet pointed to by ppa_buf is multicast routed.
+  \param[in] ppa_buf Pointer to the PPA Buffer.
+  \return This function returns the one of the following values: \n
+  - IFX_TRUE if packet is multicast forwarded at IP layer. \n
+  - IFX_FALSE if the packet is not multicast forwarded at IP layer. \n
+  \note
+ */
+int32_t ppa_is_pkt_mc_routing(PPA_BUF *ppa_buf);
+/*! \brief Returns if the packet pointed to by ppa_buf is locally terminated/generated.
+  \param[in] ppa_buf Pointer to the PPA Buffer.
+  \return This function returns the one of the following values: \n
+  - IFX_TRUE if packet is locally terminated. \n
+  - IFX_FALSE if the packet is not locally terminated. \n
+  \note
+ */
+int32_t ppa_is_pkt_local(PPA_BUF *ppa_buf);
+/*! \brief Initialize a lock for synchronization.
+  \param[in] p_lock Pointer to the PPA lock variable which is allocated by the caller.
+  \return This function returns the one of the following values: \n
+  - PPA_SUCCESS, if PPA Lock initialization is success. \n
+  - PPA_FAILURE, if the PPA Lock initialization fails. \n
+  \note
+ */
+int32_t ppa_lock_init(PPA_LOCK *p_lock);
+/*! \brief Get or Acquire a PPA lock for synchronization.
+  \param[in] p_lock Pointer to the PPA lock variable which has been already initialized by the caller.
+  \return No value returned.
+  \note
+ */
+void ppa_lock_get(PPA_LOCK *p_lock);
+/*! \brief Release a PPA Lock acquired for synchronization.
+  \param[in] p_lock Pointer to the PPA lock variable which is to be released by the caller..
+  \return No valure returned.
+  \note
+ */
+void ppa_lock_release(PPA_LOCK *p_lock);
+/*! \brief Get or Acquire a PPA lock for synchronization.
+  \param[in] p_lock Pointer to the PPA lock variable which has been already initialized by the caller.
+  \return current flag.
+  \note
+ */
+uint32_t ppa_lock_get2(PPA_LOCK *p_lock);
+/*! \brief Release a PPA Lock acquired for synchronization.
+  \param[in] p_lock Pointer to the PPA lock variable which is to be released by the caller..
+  \param[in] flag system flag
+  \return No valure returned.
+  \note
+ */
+void ppa_lock_release2(PPA_LOCK *p_lock, uint32_t flag);
+/*! \brief Destroy a PPA lock created with the ppa_lock_init API
+  \param[in] p_lock Pointer to the PPA lock variable which is allocated by the caller.
+  \return No valure returned.
+  \note
+ */
+void ppa_lock_destroy(PPA_LOCK *p_lock);
+/*! \brief Disable interrupt processing to protect certain PPA critical regions and save current interrupt state to a global variable in the AL.
+  \return No valure returned.
+  \note
+ */
+uint32_t ppa_disable_int(void);
+/*! \brief Enable interrupt processing to protect certain PPA critical regions. This must actually restore interrupt status from the last ppa_disable_int call.
+  \param[in] flag Interrupt status flag.
+  \return No valure returned.
+  \note
+ */
+void ppa_enable_int(uint32_t flag);
+/*! \brief This function dynamically allocates memory for PPA use.
+  \param[in] size Specifies the number of bytes to be allocated.
+  \return The return value is one of the following: \n
+  - Non-NULL value, if memory allocation is successful. \n
+  - NULL, if the PPA Lock initialization fails. \n
+  \note
+ */
+void *ppa_malloc(uint32_t size);
+/*! \brief This function dynamically allocates memory in dma zone for PPA use.
+  \param[in] size Specifies the number of bytes to be allocated.
+  \return The return value is one of the following: \n
+  - Non-NULL value, if memory allocation is successful. \n
+  - NULL, if the PPA Lock initialization fails. \n
+  \note
+ */
+void *ppa_alloc_dma(uint32_t size);
+/*! \brief This function frees dynamically allocated memory.
+  \param[in] buff Pointer to buffer allocated by ppa_malloc routine, which needs to be freed.
+  \return The return value is one of the following: \n
+  - PPA_SUCCESS, if memory free is successful. \n
+  - PPA_FAILURE, if the memory free operation fails. \n
+  \note
+ */
+int32_t ppa_free(void *buff);
+/*! \brief This function dynamically allocates memory for a cache of objects of a fixed size for PPA use.
+  \param[in] name Specifies the name of the memory cache as a string.
+  \param[in] size Specifies the object size in bytes for the memory cache to be created.
+  \param[out] pp_cache Pointer to pointer to the memory cache to be created. *pp_cache is set by the function.
+  \return The return value is one of the following: \n
+  - PPA_SUCCESS value, if memory cache creation is successful. \n
+  - PPA_FAILURE, if the memory cache creation fails. \n
+  \note
+ */int32_t ppa_mem_cache_create(const char *name, uint32_t size, PPA_MEM_CACHE * *pp_cache);
+/*! \brief This function frees (or destroys) dynamically created memory cache using ppa_mem_cache_create API.
+  \param[in] p_cache Pointer to memory cache created by ppa_mem_cache_create routine, which needs to be destroyed.
+  \return The return value is one of the following: \n
+  - PPA_SUCCESS, if memory cache is destroyed. \n
+  - PPA_FAILURE, if the memory cache free operation fails \n
+  \note
+ */
+int32_t ppa_mem_cache_destroy(PPA_MEM_CACHE *p_cache);
+/*! \brief This function allocates a memory cache object from the specified memory cache created using ppa_mem_cache_create API.
+  \param[in] p_cache Pointer to memory cache created by ppa_mem_cache_create routine, to which an object needs to be freed.
+  \return No return value.
+  \note
+ */
+void *ppa_mem_cache_alloc(PPA_MEM_CACHE *p_cache);
+/*! \brief This function frees (or returns) allocated memory cache object using ppa_mem_cache_alloc API back to the memory cache pool.
+  \param[in] buf Pointer to memory cache object allocated from memory cache pointed to by p_cache pointer.
+  \param[in] p_cache Pointer to memory cache created by ppa_mem_cache_create routine, which needs to be destroyed.
+  \return The return value is one of the following: \n
+  - PPA_SUCCESS, if memory cache is destroyed. \n
+  - PPA_FAILURE, if the memory cache free operation fails. \n
+  \note
+ */
+void ppa_mem_cache_free(void *buf, PPA_MEM_CACHE *p_cache);
+/*! \brief This function does a byte copy from source buffer to destination buffer for the specified number of bytes.
+  \param[in] dst Pointer to destination buffer to copy to.
+  \param[in] src Pointer to source buffer to copy from.
+  \param[in] count Specifies the number of bytes to copy.
+  \return No return value.
+  \note
+ */
+void ppa_memcpy(void *dst, const void *src, uint32_t count);
+/*! \brief This function does a byte set to destination buffer with the specified fill byte for the specified number of bytes..
+  \param[in] dst Pointer to destination buffer to set bytes.
+  \param[in] fillbyte Byte value to fill in the destination buffer.
+  \param[in] count Specifies the number of bytes to set to fillbyte.
+  \return No return value.
+  \note
+ */
+void ppa_memset(void *dst, uint32_t fillbyte, uint32_t count);
+/*! \brief This function compares the memory areas buff1 and buff2 for specified number of bytes.
+  \param[in] buff1 Pointer to destination first buffer.
+  \param[in] buff2 Pointer to source second buffer.
+  \param[in] count Specifies the number of bytes to compare.
+  \return Returns an integer less than, equal to, or greater than zero if the first n bytes of buff1 is found, respectively, to be less than, to match, or be greater than the first n bytes of buff2.
+  \note
+ */
+int ppa_memcmp(const void *buff1, const void *buff2, size_t count);
+/*! \brief This function initializes the PPA_TIMER structure and fills in the callback function which is to be invoked by the timer facility when the timer expires. The PPA timer facility is a "one-shot" timer and not a periodic one.
+  \param[in] p_timer Pointer to the PPA_TIMER structure allocated by caller.
+  \param[in] callback Timer callback function that is invoked when the timer expires.
+  \return The function returns one of the following values: \n
+  - PPA_SUCCESS, on success. \n
+  - PPA_FAILURE, on error. \n
+  \note
+ */
+int32_t ppa_timer_init(PPA_TIMER *p_timer, void (*callback)(unsigned long));
+/*! \brief This function adds or installs a timer with the specified timer interval.
+  \param[in] p_timer Pointer to the initialized PPA_TIMER structure to be installed.
+  \param[in] timeout_in_sec Timer expiry interval in seconds after which the one-shot timer will fire.
+  \return The function returns one of the following values: \n
+  - PPA_SUCCESS, on success. \n
+  - PPA_FAILURE, on error. \n
+  \note
+ */
+int32_t ppa_timer_add(PPA_TIMER *p_timer, uint32_t timeout_in_sec);
+/*! \brief This function deletes an install timer which has not yet expired.
+  \param[in] p_timer Pointer to the installed PPA_TIMER structure to be deleted.
+  \return The function returns one of the following values: \n
+  - PPA_SUCCESS, on successful deletion of the timer. \n
+  - PPA_FAILURE, on error (for eg., timer already expired, or invalid timer pointer). \n
+  \note
+ */
+void ppa_timer_del(PPA_TIMER *p_timer);
+/*! \brief This function adds or installs a timer with the specified timer interval.
+  \return The function returns the following value: \n
+  - Current time in 10 milliseconds resolution.
+  \note
+ */
+uint32_t ppa_get_time_in_10msec(void);
+/*! \brief This function returns the current time of the system in seconds. It can be the time since reboot of the system, or an absolute time wrt NTP synced world time. PPA uses this function for timing intervals or periods.
+  \return The function returns the following values: \n
+  - Current time in seconds \n
+  \note
+ */
+uint32_t ppa_get_time_in_sec(void);
+/*! \brief This function creates a kernel thread; it executes the function in a seperate kernel thread and returns the task structure of the kernel thread.
+  \param[in] threadfn Pointer to the thread function.
+  \param[in] data Pointer to data for the threadfn
+  \param[in] fn_name Name of the thread
+  \return Pointer to the PPA_TASK structure
+ */
+PPA_TASK *ppa_kthread_create(int (*threadfn)(void *data), void *data, const char fn_name[]);
+/*! \brief This function initializes the PPA_TIMER structure and fills in the
+  callback function which is to be invoked by the timer facility
+  when the timer expires. On expiry the 'data' passed to this function
+  is passed to callback function.
+  \param[in] p_timer Pointer to the PPA_TIMER structure allocated by caller.
+  \param[in] callback Timer callback function that is invoked when the timer expires.
+  \param[in] data The value to be passed to callback function.
+  \return The function returns one of the following values: \n
+  - PPA_SUCCESS, on success. \n
+  - PPA_FAILURE, on error. \n
+ */
+int ppa_timer_setup(PPA_TIMER *p_timer,
+		void (*callback)(unsigned long),
+		unsigned long data);
+/*! \brief This function checks whether time is pending.
+  \param[in] p_timer Pointer to the PPA_TIMER.
+  \return The function returns succes if timer is pending \n
+  - PPA_SUCCESS, on success. \n
+  - PPA_FAILURE, on error. \n
+ */
+int ppa_timer_pending(PPA_TIMER *p_timer);
+/*! \brief This function checks whether someone has called kthread_stop function on this kthread
+  \param[in] void
+  \return true/false
+ */
+int ppa_kthread_should_stop (void);
+/*! \brief This function Sets kthread_should_stop for k to return true, wakes it, and waits for it to exit.
+  \param[in] Pointer to PPA_TASK pointer created by calling ppa_kthread_start
+  \return the result of threadfn, or -EINTR if ppa_wake_up_process was never called
+ */
+int ppa_kthread_stop(PPA_TASK *k);
+/*! \brief This function wakes the process k from sleep, wakes it and put in run queue.
+  \param[in] Pointer to PPA_TASK pointer created by calling ppa_kthread_start
+  \return the result of threadfn, or -EINTR if ppa_wake_up_process was never called
+ */
+void ppa_wake_up_process(PPA_TASK *k);
+/*! \brief function to call the scheduler to relinquish the CPU. This will put the calling process in sleep
+  \param[in] none
+  \return none
+ */
+void ppa_schedule(void);
+/*! \brief function set the state of current process.
+  \param[in] process state PPA_TASK_RUNNING or PPA_TASK_INTERRUPTIBLE
+  \return none
+ */
+void ppa_set_current_state(int state);
+/*! \brief function to get the master netdevice of an interface if any
+  \param[in] PPA_NETIF *netif to be checked
+  \return PPA_NETIF *bridge interface if any else NULL
+ */
+PPA_NETIF *ppa_netdev_master_upper_dev_get(PPA_NETIF *netif);
+/*! \brief function to take the rtnl_lock of kernel
+ */
+void ppa_rtnl_lock(void);
+/*! \brief function to release the rtnl_lock of kernel
+ */
+void ppa_rtnl_unlock(void);
+/*! \brief Read atomic variable.
+  \param[in] v Pointer to the PPA atomic variable which is to be read.
+  \return No return value.
+  \note
+ */
+int32_t ppa_atomic_read(PPA_ATOMIC *v);
+/*! \brief Initialize the PPA atomic variable to specified value.
+  \param[in] v Pointer to the PPA atomic variable which is to be initalized.
+  \param[in] i Intended value to be set for atomic variable p_atomic.
+  \return No return value.
+  \note
+ */
+void ppa_atomic_set(PPA_ATOMIC *v, int32_t i);
+/*! \brief Atomic Increment of variable.
+  \param[in] v Pointer to the PPA atomic variable which is to be incremented.
+  \return No return value.
+  \note
+ */
+int32_t ppa_atomic_inc(PPA_ATOMIC *v);
+/*! \brief Atomic decrement of variable.
+  \param[in] v Pointer to the PPA atomic variable which is to be decremented.
+  \return No return value.
+  \note
+ */
+int32_t ppa_atomic_dec(PPA_ATOMIC *v);
+/*! \brief Atomic Increment of variable if not zero.
+  \param[in] v Pointer to the PPA atomic variable which is to be incremented.
+  \return return value depends on low level API
+  \note
+ */
+int32_t ppa_atomic_inc_not_zero(PPA_ATOMIC *v);
+/*! \brief Atomic decrement of variable and test
+  \param[in] v Pointer to the PPA atomic variable which is to be incremented.
+  \return return value depends on low level API
+  \note
+ */
+int32_t ppa_atomic_dec_and_test(PPA_ATOMIC *v);
+/*! \brief replace the old hash item with new one
+  \param[in] old Pointer to the hash item to be replaced
+  \param[in] new Pointer to the hash item to replace
+  \return No return value
+  \note
+ */
+void ppa_hlist_replace(PPA_HLIST_NODE *old, PPA_HLIST_NODE *new);
+/*! \brief Used to perform buffer cloning.
+  \param[in] ppa_buf Pointer to ppa buffer.
+  \param[in] flags Reserved for future use.
+  \return The return value is the pointer to cloned PPA buffer structure.
+  \note
+ */
+PPA_BUF *ppa_buf_clone(PPA_BUF *ppa_buf, uint32_t flags);
+/*! \brief Used to check if the buffer is cloned.
+  \param[in] ppa_buf Pointer to ppa buffer.
+  \return The return value is IFX_TRUE if the buffer is cloned and IFX_FLASE otherwise.
+  \note
+ */
+int32_t ppa_buf_cloned(PPA_BUF *ppa_buf);
+/*! \brief get ppa prevous buffer
+  \param[in] ppa_buf Pointer to ppa buffer.
+  \return return the prevois buffer
+  \note
+ */
+PPA_BUF *ppa_buf_get_prev(PPA_BUF *ppa_buf);
+/*! \brief get ppa next buffer
+  \param[in] ppa_buf Pointer to ppa buffer.
+  \return return the next buffer
+  \note
+ */
+PPA_BUF *ppa_buf_get_next(PPA_BUF *ppa_buf);
+/*! \brief free ppa buffer
+  \param[in] ppa_buf Pointer to ppa buffer .
+  \note
+ */
+void ppa_buf_free(PPA_BUF *ppa_buf);
+/*! \brief copy data from username to kernel
+  \param[out] to destination buffer
+  \param[in] from source buffer
+  \param[in] n bytes to copy
+  \note
+ */
+uint32_t ppa_copy_from_user(void *to, const void PPA_USER * from, uint32_t n);
+/*! \brief copy data from kernel to username
+  \param[out] to destination buffer
+  \param[in] from source buffer
+  \param[in] n bytes to copy
+  \note
+ */
+uint32_t ppa_copy_to_user(void PPA_USER * to, const void *from, uint32_t n);
+/*! \brief copy string, like strcpy
+  \param[out] dest destination buffer
+  \param[in] src source buffer
+  \note
+ */
+uint8_t *ppa_strcpy(uint8_t *dest, const uint8_t *src);
+/*! \brief copy string, like strncpy
+  \param[out] dest destination buffer
+  \param[in] src source buffer
+  \param[in] n maximum bytes to copy
+  \note
+ */
+uint8_t *ppa_strncpy(uint8_t *dest, const uint8_t *src, PPA_SIZE_T n);
+/*! \brief get string length, like strlen
+  \param[in] s string buffer
+  \return return the string length
+  \note
+ */
+PPA_SIZE_T ppa_strlen(const uint8_t *s);
+/*! \brief copy string, like strncpy
+  \param[out] dest destination buffer
+  \param[in] src source buffer
+  \param[in] n maximum bytes to copy
+  \note
+ */
+int32_t ppa_str_cmp(char *str1, char *str2);
+/*! \brief shrink cache buffer. in linux, it is kmem_cache_shrink
+  \param[in] p_cache Pointer to cache buffer
+  \return return the string length
+  \note
+ */
+int32_t ppa_kmem_cache_shrink(PPA_MEM_CACHE *p_cache);
+/*! \brief lookup symble. In linux, it is kallsyms_lookup
+  \note
+ */
+const uint8_t *ppa_kallsyms_lookup(uint32_t addr, uint32_t *symbolsize, uint32_t *offset, uint8_t **modname, uint8_t *namebuf);
+/*! \brief register network device, in linux, it is register_netdev
+  \param[in] dev pointer to network device
+  \return
+  \note
+ */
+int32_t ppa_register_netdev(PPA_NETIF *dev);
+/*! \brief unregister network device, in linux, it is unregister_netdev
+  \param[in] dev pointer to network device
+  \return
+  \note
+ */
+void ppa_unregister_netdev(PPA_NETIF *dev);
+/*! \brief register char devide, in linux, it is register_chrdev
+  \param[in] major Character device major version
+  \param[in] name Character device name
+  \param[in] fops Character device operation pointer
+  \return
+  \note
+ */
+int32_t ppa_register_chrdev(int32_t major, const uint8_t *name, PPA_FILE_OPERATIONS *fops);
+/*! \brief unregister char devide, in linux, it is unregister_chrdev
+  \param[in] major char device major version
+  \param[in] name char device name
+  \return
+  \note
+ */
+void ppa_unregister_chrdev(int32_t major, const uint8_t *name);
+/*! \brief format a string to buffer, in linux, it is snprintf
+  \return
+  \note
+ */
+int ppa_snprintf(uint8_t *buf, size_t size, const uint8_t *fmt, ...);
+/*! \brief format a string to buffer, in linux, it is sprintf
+  \return
+  \note
+ */
+int ppa_sprintf(uint8_t *buf, const uint8_t *fmt, ...);
+/*! \brief get ioctl type, in linux, it is _IOC_TYPE
+  \return
+  \note
+ */
+uint32_t ppa_ioc_type(uint32_t);
+/*! \brief get ioctl nr, in linux, it is _IOC_NR
+  \return
+  \note
+ */
+uint32_t ppa_ioc_nr(uint32_t);
+/*! \brief get ioctl dir, in linux, it is _IOC_DIR
+  \return
+  \note
+ */
+uint32_t ppa_ioc_dir(uint32_t);
+/*! \brief get ioctl read flag, in linux, it is _IOC_READ
+  \return
+  \note
+ */
+uint32_t ppa_ioc_read(void);
+/*! \brief get ioctl write flag, in linux, it is _IOC_WRITE
+  \return
+  \note
+ */
+uint32_t ppa_ioc_write(void);
+/*! \brief get ioctl size, in linux, it is _IOC_SIZE
+  \return
+  \note
+ */
+uint32_t ppa_ioc_size(uint32_t);
+/*! \brief check ioctl access right, in linux, it is access_ok
+  \return
+  \note
+ */
+uint32_t ppa_ioc_access_ok(uint32_t type, uint32_t addr, uint32_t size);
+/*! \brief get ioctl verify write flag, in linux it is VERIFY_WRITE
+  \return
+  \note
+ */
+uint32_t ppa_ioc_verify_write(void);
+/*! \brief get ioctl verify read flag, in linux it is VERIFY_READ
+  \return
+  \note
+ */
+uint32_t ppa_ioc_verify_read(void);
+/*! \brief get egress qos mask
+  \param dev pointer to net device structure.
+  \param buf pointer to buffer.
+  \return
+  \note
+ */
+uint16_t ppa_vlan_dev_get_egress_qos_mask(PPA_NETIF *dev, PPA_BUF *buf);
+/*! \brief get hash value computed using connection track.
+  \param ct Pointer to PPA_SESSION
+  \param dir Direction of the session.
+  \param tuple Pointer to hold the connection tuple.
+  \return On success returns calculated hash value, else returns zero
+  \note
+ */
+uint32_t ppa_get_hash_from_ct(const PPA_SESSION *ct,
+		uint8_t dir,
+		PPA_TUPLE *tuple);
+/*! \brief get hash value computed from given packet
+  \param ppa_buf pointer to the packet buffer
+  \param pf Protocol family of the packet.
+  \param u32_hash pointer to unsigned integer. On success, this contains
+  valid hash value computed using 5 tuples of the packet.
+  \return On success returns zero
+  \note
+ */
+int ppa_get_hash_from_packet(PPA_BUF *ppa_buf,
+		unsigned char pf,
+		uint32_t *u32_hash,
+		PPA_TUPLE *tuple);
+/*! \brief get default ip ttl
+  \return ipttl
+  \note
+ */
+int32_t ppa_get_ip_ttl(void);
+/*! \brief get system meminfo
+  \param pointer to systeminfo structure
+  \return system mem info
+  \note
+ */
+void ppa_si_meminfo(PPA_SYSINFO *sysinfo);
+#ifndef CONFIG_SWAP
+/*! \brief get system meminfo
+  \param pointer to systeminfo structure
+  \return system swap info
+  \note
+ */
+void ppa_si_swapinfo(PPA_SYSINFO *sysinfo);
+/*! \brief get system free ram
+  \param pointer to systeminfo structure
+  \return system freeram
+  \note
+ */
+uint64_t ppa_si_freeram(PPA_SYSINFO *sysinfo);
+#endif
+uint32_t ppa_is_bond_slave(PPA_IFNAME *ifname, PPA_NETIF *netif);
+/*! \brief check whether device is a bridge device
+  \param pointer to netdevice
+  \return system TRUE or FALSE
+ */
+int ppa_dev_is_br(PPA_NETIF *netif);
+/*! \brief get the bridge fdb entry
+  \param bridge entry pointer
+  \param address
+  \param vlan id
+  \return fdb entry
+ */
+struct net_bridge_fdb_entry *ppa_br_fdb_get(struct net_bridge *br,
+		const unsigned char *addr,
+		uint16_t vid);
+/*! \brief get route table entry
+  \param struct net
+  \param flow id
+  \return route table entry
+ */
+struct rtable *ppa_ip_route_output_key(struct net *net, struct flowi4 *flp);
+#if IS_ENABLED(CONFIG_IPV6)
+/*! \brief get ipv6 route table entry
+  \param struct net
+  \param sock structure
+  \param flow id
+  \return route table entry
+ */
+struct dst_entry *ppa_ip6_route_output(struct net *net,
+		const struct sock *sk,
+		struct flowi6 *fl6);
+#endif
+#endif /* __KERNEL__*/
+/* @} */
+#endif /* __IFX_PPA_STACK_AL_H__20081103_1153__*/
diff --git a/include/net/ppa/qos_hal_api.h b/include/net/ppa/qos_hal_api.h
new file mode 100644
index 000000000000..713d5aee9d0c
--- /dev/null
+++ b/include/net/ppa/qos_hal_api.h
@@ -0,0 +1,59 @@
+#ifndef __QOS_HAL_API_H
+#define __QOS_HAL_API_H
+/***************************************************************************
+ *
+ * Copyright (C) 2017-2018 Intel Corporation
+ * Copyright (C) 2010-2016 Lantiq Beteiligungs-GmbH & Co. KG
+ * Author  : Purnendu Ghosh
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ ***************************************************************************/
+/*! \file qos_hal_api.h
+  \brief This file contains: QOS HAL Stats API.
+ */
+#include <net/ppa/ppa_api_common.h>
+struct qos_hal_qos_stats {
+	uint64_t enqPkts; /* Enqueued packets Count */
+	uint64_t enqBytes; /* Enqueued Bytes Count */
+	uint64_t deqPkts; /* Dequeued packets Count */
+	uint64_t deqBytes; /* Dequeued Bytes Count */
+	uint64_t dropPkts; /* Dropped Packets Count */
+	uint64_t dropBytes; /* Dropped Bytes Count - UNUSED for now */
+	uint32_t qOccPkts; /* Queue Occupancy Packets Count -
+				Only at Queue level */
+};
+extern int32_t (*qos_hal_get_csum_ol_mib_hook_fn)(
+		struct qos_hal_qos_stats *csum_mib,
+		uint32_t flag);
+extern int32_t (*qos_hal_clear_csum_ol_mib_hook_fn)(
+		uint32_t flag);
+extern int32_t(*qos_hal_get_qos_mib_hook_fn)(
+		struct net_device *netdev,
+		dp_subif_t *subif_id,
+		int32_t queueid,
+		struct qos_hal_qos_stats *qos_mib,
+		uint32_t flag);
+extern int32_t (*qos_hal_clear_qos_mib_hook_fn)(
+		struct net_device *netdev,
+		dp_subif_t *subif_id,
+		int32_t queueid,
+		uint32_t flag);
+
+int qos_hal_setup_dp_ingress_connectivity(
+		struct net_device *netdev,
+		uint32_t pmac_port);
+int qos_hal_setup_dp_egress_connectivity(
+		struct net_device *netdev,
+		uint32_t pmac_port);
+int qos_hal_remove_dp_egress_connectivity(
+		struct net_device *netdev,
+		uint32_t pmac_port);
+int qos_hal_remove_dp_ingress_connectivity(
+		struct net_device *netdev,
+		uint32_t pmac_port);
+#endif  /*  __QOS_HAL_API_H*/
diff --git a/include/net/ppa/qos_mgr_tc_hook.h b/include/net/ppa/qos_mgr_tc_hook.h
new file mode 100644
index 000000000000..d748bbc1e077
--- /dev/null
+++ b/include/net/ppa/qos_mgr_tc_hook.h
@@ -0,0 +1,30 @@
+#ifndef __QOS_MGR_TC_HOOK_H
+#define __QOS_MGR_TC_HOOK_H
+/******************************************************************************
+ *
+ * Copyright (C) 2017-2018 Intel Corporation
+ * Copyright (C) 2010-2016 Lantiq Beteiligungs-GmbH & Co. KG
+ * Author  : Purnendu Ghosh
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ *******************************************************************************/
+/*! \file qos_mgr_tc_hook.h
+  \brief This file contains TC exported HOOK API to linux Kernel builtin.
+ */
+/** \addtogroup  QOS_MGR_TC_HOOK_API */
+/*@{*/
+/*
+ * ####################################
+ *             Declaration
+ * ####################################
+ */
+#ifdef __KERNEL__
+extern int32_t (*qos_mgr_hook_setup_tc)(struct net_device *dev, u32 handle, __be16 protocol, struct tc_to_netdev *tc);
+#endif /*end of __KERNEL__*/
+/* @} */
+#endif  /*  __QOS_MGR_TC_HOOK_H */
