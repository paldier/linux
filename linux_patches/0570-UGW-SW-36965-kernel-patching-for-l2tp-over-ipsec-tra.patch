From 239b135b79ec6362a865b36551a38ba4b1ee21d5 Mon Sep 17 00:00:00 2001
From: moinakde <moinak.debnath@intel.com>
Date: Tue, 16 Apr 2019 01:45:48 +0530
Subject: [PATCH] UGW_SW-36965: kernel patching for l2tp over ipsec transport
 mode support in 8.x

---
 drivers/net/ethernet/lantiq/ppa/ppa_hook.c |  4 ++--
 include/net/ppa/ppa_api.h                  |  1 +
 include/uapi/net/ppa_api.h                 |  3 +--
 net/ipv4/esp4.c                            | 14 ++++++++++----
 4 files changed, 14 insertions(+), 8 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/ppa/ppa_hook.c b/drivers/net/ethernet/lantiq/ppa/ppa_hook.c
index c05f6b4aa4e9..df7e2fb11fef 100644
--- a/drivers/net/ethernet/lantiq/ppa/ppa_hook.c
+++ b/drivers/net/ethernet/lantiq/ppa/ppa_hook.c
@@ -722,13 +722,13 @@ static unsigned int ppa_postrt_hook_fn(void *priv,
 	packet which will eventually take the IPSec Path */
 #if IS_ENABLED(CONFIG_PPA_MPE_IP97)
 	struct iphdr *hdr = ip_hdr(skb);
-	if (hdr->protocol == IPPROTO_ESP || skb_dst(skb)->flags & DST_XFRM_TUNNEL || !ppa_hook_session_add_fn)
+	if (hdr->protocol == IPPROTO_ESP || skb_dst(skb)->flags & (DST_XFRM_TUNNEL | DST_HOST) || !ppa_hook_session_add_fn)
 		return NF_ACCEPT;
 	/* In the Second call (After Encryption) we skip again for
 	ESP type since we call this hook in xfrm_output_resume before
 	old conntrack reset, based on which the p_item was created */
 #else
-	if (skb_dst(skb)->flags & DST_XFRM_TUNNEL || !ppa_hook_session_add_fn)
+	if (skb_dst(skb)->flags & (DST_XFRM_TUNNEL | DST_HOST) || !ppa_hook_session_add_fn)
 		return NF_ACCEPT;
 #endif
 
diff --git a/include/net/ppa/ppa_api.h b/include/net/ppa/ppa_api.h
index 5e3f86cc6036..4a70f064d174 100644
--- a/include/net/ppa/ppa_api.h
+++ b/include/net/ppa/ppa_api.h
@@ -201,6 +201,7 @@ typedef struct ppa_hsel_cnode{
 #define FLAG_SESSION_HI_PRIO 0x0001
 #define FLAG_SESSION_SWAPPED 0x0002
 #define FLAG_SESSION_LOCK_FAIL 0x0004
+#define SESSION_FLAG2_VALID_IPSEC_TRANS		0x00040000 /* Flag for L2TP over IPSec Transport mode */
 /* tunnel table datastructures*/
 /* PPA default values */
 #define PPA_IPV4_HDR_LEN 20
diff --git a/include/uapi/net/ppa_api.h b/include/uapi/net/ppa_api.h
index 467b460af43b..9e8768a2944a 100755
--- a/include/uapi/net/ppa_api.h
+++ b/include/uapi/net/ppa_api.h
@@ -480,11 +480,11 @@
 #define SESSION_FLAG2_CPU_IN		 	0x00001000 /*session is locally terminating*/
 #define SESSION_FLAG2_CPU_OUT		 	0x00002000 /*session is locally generated*/
 #define SESSION_FLAG2_CPU_BOUND	(SESSION_FLAG2_CPU_IN | SESSION_FLAG2_CPU_OUT) /*local session*/
+
 /* Container Session Flags */
 #define SESSION_FLAG2_VETH 			0x00004000
 #define SESSION_FLAG2_CONTAINER 		0x00008000
 #define SESSION_FLAG2_NON_ETHWAN_SESSION 	0x00010000
-
 #define SESSION_FLAG2_DS_MPE_QOS		0x00020000 /* Flag for DS_QOS capability */
 
 /* Other flags */
@@ -492,7 +492,6 @@
 #define SESSION_FLAG_TC_REMARK		0x40000000 /*Flag to sepcify bit 30 in extmark which specifies packet classified by iptables when set to 1*/
 #define SESSION_FLAG_DSCP_REMARK	0x00000010 /*Flag to enable DSCP remark in Stack when packet is not classified using PAE Flow Rule*/
 #define SESSION_FLAG2_UPDATE_INFO_PROCESSED	0x10000000 /*Flag to specify ppa_update_session_info is complete*/
-
 #define MAX_DATA_FLOW_ENGINES 3 /* will be changed to runtime value*/
 
 #define MAX_SESSION_PRIORITY 3
diff --git a/net/ipv4/esp4.c b/net/ipv4/esp4.c
index f27a4ccf6ecd..526d63e2b39e 100644
--- a/net/ipv4/esp4.c
+++ b/net/ipv4/esp4.c
@@ -155,11 +155,17 @@ static int esp_output(struct xfrm_state *x, struct sk_buff *skb)
 	struct sk_buff *trailer;
 	uint16_t nexthdr;
 	
-	if(!ltq_get_len_param_hook) {
+	if (!ltq_get_len_param_hook) {
 		printk("param pointer is NULL\n");
 		return ;
 	}
-	ltq_get_len_param_hook(x->id.spi, &iv_len, &icv_len, &blk_size);
+
+	err = ltq_get_len_param_hook(x->id.spi, &iv_len, &icv_len, &blk_size);
+	if (err < 0) {
+		printk("Invalid IPSec params obtained, so returning\n");
+		return err;
+	}
+
 	trailer_len = icv_len + blk_size ;
 	err = skb_cow_data(skb, trailer_len, &trailer);
 	if (err < 0)
@@ -168,7 +174,7 @@ static int esp_output(struct xfrm_state *x, struct sk_buff *skb)
 	skb_linearize(skb);
 	nexthdr = ip_hdr(skb)->protocol;
 	ip_hdr(skb)->protocol = IPPROTO_ESP;
-	if(!ltq_ipsec_enc_hook) {
+	if (!ltq_ipsec_enc_hook) {
 		printk("enc hook is NULL\n");
 		return ;
 	}
@@ -179,7 +185,7 @@ static int esp_output(struct xfrm_state *x, struct sk_buff *skb)
 	if (err == -EBUSY)
 		err = NET_XMIT_DROP;
 
-	if(err > 0) {
+	if (err > 0) {
 		skb->data = skb_transport_header(skb);
 		skb->len = err;
 		skb->tail = skb->data + skb->len;
