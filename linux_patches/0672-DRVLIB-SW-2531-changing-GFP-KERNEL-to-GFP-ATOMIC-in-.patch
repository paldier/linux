From 77a425cf4b1d56a947b94e0b6b965ba5b80c48bf Mon Sep 17 00:00:00 2001
From: Rekha Eswaran <rekha.eswaran@intel.com>
Date: Fri, 5 Jul 2019 17:32:22 +0800
Subject: [PATCH] DRVLIB_SW-2531 changing GFP_KERNEL to GFP_ATOMIC in kmalloc
 for DP support in tasklet context

---
 drivers/net/datapath/dpm/datapath_api.c              |  4 ++--
 drivers/net/datapath/dpm/datapath_misc.c             |  4 ++--
 drivers/net/datapath/dpm/datapath_qos.c              |  2 +-
 drivers/net/datapath/dpm/gswip31/datapath_gswip.c    | 16 ++++++++--------
 drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c |  8 ++++----
 drivers/net/datapath/dpm/gswip32/datapath_gswip.c    | 16 ++++++++--------
 drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c |  8 ++++----
 7 files changed, 29 insertions(+), 29 deletions(-)

diff --git a/drivers/net/datapath/dpm/datapath_api.c b/drivers/net/datapath/dpm/datapath_api.c
index 940ebc074be8..88896283f0d2 100644
--- a/drivers/net/datapath/dpm/datapath_api.c
+++ b/drivers/net/datapath/dpm/datapath_api.c
@@ -972,7 +972,7 @@ int32_t dp_register_dev_ext(int inst, struct module *owner, uint32_t port_id,
 
 	DP_CB(inst, dev_platform_set)(inst, port_id, data, flags);
 
-	cbm_data = kzalloc(sizeof(*cbm_data), GFP_KERNEL);
+	cbm_data = kzalloc(sizeof(*cbm_data), GFP_ATOMIC);
 	if (!cbm_data) {
 		DP_LIB_UNLOCK(&dp_lock);
 		return res;
@@ -1117,7 +1117,7 @@ int32_t dp_register_subif_ext(int inst, struct module *owner,
 	if (!(flags & DP_F_SUBIF_LOGICAL))
 		subifid_fn_t = port_info->cb.get_subifid_fn;
 
-	subif_id_sync = kmalloc(sizeof(*subif_id_sync) * 2, GFP_KERNEL);
+	subif_id_sync = kmalloc(sizeof(*subif_id_sync) * 2, GFP_ATOMIC);
 	if (!subif_id_sync) {
 		PR_ERR("Failed to alloc %zu bytes\n",
 		       sizeof(*subif_id_sync) * 2);
diff --git a/drivers/net/datapath/dpm/datapath_misc.c b/drivers/net/datapath/dpm/datapath_misc.c
index 0dfe5043a77e..01ebfd5d345c 100644
--- a/drivers/net/datapath/dpm/datapath_misc.c
+++ b/drivers/net/datapath/dpm/datapath_misc.c
@@ -1273,7 +1273,7 @@ int32_t dp_update_subif(struct net_device *netif, void *data,
 	idx = dp_subif_hash(netif);
 	dp_subif = dp_subif_lookup_safe(&dp_subif_list[idx], netif, data);
 	if (!dp_subif) { /*alloc new */
-		dp_subif = kzalloc(sizeof(*dp_subif), GFP_KERNEL);
+		dp_subif = kzalloc(sizeof(*dp_subif), GFP_ATOMIC);
 		if (!dp_subif)
 			return -1;
 		memcpy(&dp_subif->subif, subif, sizeof(dp_subif_t));
@@ -1286,7 +1286,7 @@ int32_t dp_update_subif(struct net_device *netif, void *data,
 		hlist_add_head_rcu(&dp_subif->hlist, &dp_subif_list[idx]);
 		return 0;
 	} else {
-		dp_subif_new = kzalloc(sizeof(*dp_subif), GFP_KERNEL);
+		dp_subif_new = kzalloc(sizeof(*dp_subif), GFP_ATOMIC);
 		if (!dp_subif_new)
 			return -1;
 		memcpy(&dp_subif_new->subif, subif, sizeof(dp_subif_t));
diff --git a/drivers/net/datapath/dpm/datapath_qos.c b/drivers/net/datapath/dpm/datapath_qos.c
index a4f8417d3a77..1b56ed22a864 100644
--- a/drivers/net/datapath/dpm/datapath_qos.c
+++ b/drivers/net/datapath/dpm/datapath_qos.c
@@ -153,7 +153,7 @@ int dp_deq_port_res_get(struct dp_dequeue_res *res, int flag)
 	if (!res || !dp_port_prop[res->inst].info.dp_qos_platform_set)
 		return DP_FAILURE;
 	if (res->dev) { /*fill dp_port if dev is provided */
-		subif = kzalloc(sizeof(*subif), GFP_KERNEL);
+		subif = kzalloc(sizeof(*subif), GFP_ATOMIC);
 		if (!subif)
 			return DP_FAILURE;
 		dp_get_netif_subifid(res->dev, NULL, NULL, NULL, subif, 0);
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
index 822fbc1050f3..6821c0f51fe2 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
@@ -1210,7 +1210,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 
 	if (flag & DP_METER_ATTACH_PCE) {
 		/* pattern setting */
-		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_KERNEL);
+		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_ATOMIC);
 		if (!pce_rule) {
 			PR_ERR("ctp_cfg alloc failed\n");
 			bret = -1;
@@ -1236,7 +1236,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			bret = -1;
 			goto err;
 		}
-		ctp_cfg = kzalloc(sizeof(GSW_CTP_portConfig_t), GFP_KERNEL);
+		ctp_cfg = kzalloc(sizeof(GSW_CTP_portConfig_t), GFP_ATOMIC);
 		if (!ctp_cfg) {
 			PR_ERR("ctp_cfg alloc failed\n");
 			bret = -1;
@@ -1286,7 +1286,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			bret = -1;
 			goto err;
 		}
-		bp_cfg = kzalloc(sizeof(GSW_BRIDGE_portConfig_t), GFP_KERNEL);
+		bp_cfg = kzalloc(sizeof(GSW_BRIDGE_portConfig_t), GFP_ATOMIC);
 		if (!bp_cfg) {
 			PR_ERR("bp_cfg alloc failed\n");
 			bret = -1;
@@ -1338,7 +1338,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			goto err;
 		}
 	} else if (flag & DP_METER_ATTACH_BRIDGE) {
-		br_cfg = kzalloc(sizeof(GSW_BRIDGE_config_t), GFP_KERNEL);
+		br_cfg = kzalloc(sizeof(GSW_BRIDGE_config_t), GFP_ATOMIC);
 		if (!br_cfg) {
 			PR_ERR("br_cfg alloc failed\n");
 			bret = -1;
@@ -1407,7 +1407,7 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		return -1;
 
 	if (meter->dir & DP_METER_ATTACH_PCE) {
-		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_KERNEL);
+		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_ATOMIC);
 		if (!pce_rule) {
 			PR_ERR("ctp_cfg alloc failed\n");
 			bret = -1;
@@ -1432,7 +1432,7 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			bret = -1;
 			goto err;
 		}
-		ctp_cfg = kzalloc(sizeof(GSW_CTP_portConfig_t), GFP_KERNEL);
+		ctp_cfg = kzalloc(sizeof(GSW_CTP_portConfig_t), GFP_ATOMIC);
 		if (!ctp_cfg) {
 			PR_ERR("ctp_cfg alloc failed\n");
 			bret = -1;
@@ -1479,7 +1479,7 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			bret = -1;
 			goto err;
 		}
-		bp_cfg = kzalloc(sizeof(GSW_BRIDGE_portConfig_t), GFP_KERNEL);
+		bp_cfg = kzalloc(sizeof(GSW_BRIDGE_portConfig_t), GFP_ATOMIC);
 		if (!bp_cfg) {
 			PR_ERR("bp_cfg alloc failed\n");
 			bret = -1;
@@ -1528,7 +1528,7 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		}
 	}
 	if (flag & DP_METER_ATTACH_BRIDGE) {
-		br_cfg = kzalloc(sizeof(GSW_BRIDGE_config_t), GFP_KERNEL);
+		br_cfg = kzalloc(sizeof(GSW_BRIDGE_config_t), GFP_ATOMIC);
 		if (!br_cfg) {
 			PR_ERR("br_cfg alloc failed\n");
 			bret = -1;
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c b/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
index d57d86694e42..ede5e48009d4 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
@@ -1821,7 +1821,7 @@ int dp_node_free_31(struct dp_node_alloc *node, int flag)
 		PR_ERR("priv is NULL cannot proceed!!\n");
 		return DP_FAILURE;
 	}
-	t = kzalloc(sizeof(*t), GFP_KERNEL);
+	t = kzalloc(sizeof(*t), GFP_ATOMIC);
 	if (!t) {
 		PR_ERR("fail to alloc %d bytes\n", sizeof(*t));
 		return DP_FAILURE;
@@ -2866,7 +2866,7 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 		       info->dp_port, DP_PORT(info).dp_port);
 		info->dp_port = DP_PORT(info).dp_port;
 	}
-	t = kzalloc(sizeof(*t), GFP_KERNEL);
+	t = kzalloc(sizeof(*t), GFP_ATOMIC);
 	if (!t) {
 		PR_ERR("fail to alloc %d bytes\n", sizeof(*t));
 		return DP_FAILURE;
@@ -3147,7 +3147,7 @@ int dp_queue_conf_set_31(struct dp_queue_conf *cfg, int flag)
 		return DP_FAILURE;
 	}
 
-	conf = kzalloc(sizeof(*conf), GFP_KERNEL);
+	conf = kzalloc(sizeof(*conf), GFP_ATOMIC);
 	if (!conf) {
 		PR_ERR("fail to alloc %d bytes\n", sizeof(*conf));
 		return DP_FAILURE;
@@ -3221,7 +3221,7 @@ int dp_queue_conf_get_31(struct dp_queue_conf *cfg, int flag)
 		return DP_FAILURE;
 	}
 
-	conf = kzalloc(sizeof(*conf), GFP_KERNEL);
+	conf = kzalloc(sizeof(*conf), GFP_ATOMIC);
 	if (!conf) {
 		PR_ERR("fail to alloc %d bytes\n", sizeof(*conf));
 		return DP_FAILURE;
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_gswip.c b/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
index 76ab8d390127..d4f3dd87b539 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
@@ -1214,7 +1214,7 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 
 	if (flag & DP_METER_ATTACH_PCE) {
 		/* pattern setting */
-		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_KERNEL);
+		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_ATOMIC);
 		if (!pce_rule) {
 			PR_ERR("ctp_cfg alloc failed\n");
 			bret = -1;
@@ -1240,7 +1240,7 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			bret = -1;
 			goto err;
 		}
-		ctp_cfg = kzalloc(sizeof(GSW_CTP_portConfig_t), GFP_KERNEL);
+		ctp_cfg = kzalloc(sizeof(GSW_CTP_portConfig_t), GFP_ATOMIC);
 		if (!ctp_cfg) {
 			PR_ERR("ctp_cfg alloc failed\n");
 			bret = -1;
@@ -1290,7 +1290,7 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			bret = -1;
 			goto err;
 		}
-		bp_cfg = kzalloc(sizeof(GSW_BRIDGE_portConfig_t), GFP_KERNEL);
+		bp_cfg = kzalloc(sizeof(GSW_BRIDGE_portConfig_t), GFP_ATOMIC);
 		if (!bp_cfg) {
 			PR_ERR("bp_cfg alloc failed\n");
 			bret = -1;
@@ -1342,7 +1342,7 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			goto err;
 		}
 	} else if (flag & DP_METER_ATTACH_BRIDGE) {
-		br_cfg = kzalloc(sizeof(GSW_BRIDGE_config_t), GFP_KERNEL);
+		br_cfg = kzalloc(sizeof(GSW_BRIDGE_config_t), GFP_ATOMIC);
 		if (!br_cfg) {
 			PR_ERR("br_cfg alloc failed\n");
 			bret = -1;
@@ -1411,7 +1411,7 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		return -1;
 
 	if (meter->dir & DP_METER_ATTACH_PCE) {
-		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_KERNEL);
+		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_ATOMIC);
 		if (!pce_rule) {
 			PR_ERR("ctp_cfg alloc failed\n");
 			bret = -1;
@@ -1436,7 +1436,7 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			bret = -1;
 			goto err;
 		}
-		ctp_cfg = kzalloc(sizeof(GSW_CTP_portConfig_t), GFP_KERNEL);
+		ctp_cfg = kzalloc(sizeof(GSW_CTP_portConfig_t), GFP_ATOMIC);
 		if (!ctp_cfg) {
 			PR_ERR("ctp_cfg alloc failed\n");
 			bret = -1;
@@ -1483,7 +1483,7 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			bret = -1;
 			goto err;
 		}
-		bp_cfg = kzalloc(sizeof(GSW_BRIDGE_portConfig_t), GFP_KERNEL);
+		bp_cfg = kzalloc(sizeof(GSW_BRIDGE_portConfig_t), GFP_ATOMIC);
 		if (!bp_cfg) {
 			PR_ERR("bp_cfg alloc failed\n");
 			bret = -1;
@@ -1532,7 +1532,7 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		}
 	}
 	if (flag & DP_METER_ATTACH_BRIDGE) {
-		br_cfg = kzalloc(sizeof(GSW_BRIDGE_config_t), GFP_KERNEL);
+		br_cfg = kzalloc(sizeof(GSW_BRIDGE_config_t), GFP_ATOMIC);
 		if (!br_cfg) {
 			PR_ERR("br_cfg alloc failed\n");
 			bret = -1;
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c b/drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c
index c33d34f3a5e5..3326dd346d66 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c
@@ -1864,7 +1864,7 @@ int dp_node_free_32(struct dp_node_alloc *node, int flag)
 		PR_ERR("priv is NULL cannot proceed!!\n");
 		return DP_FAILURE;
 	}
-	t = kzalloc(sizeof(*t), GFP_KERNEL);
+	t = kzalloc(sizeof(*t), GFP_ATOMIC);
 	if (!t) {
 		PR_ERR("fail to alloc %zd bytes\n", sizeof(*t));
 		return DP_FAILURE;
@@ -2788,7 +2788,7 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 			info->dp_port, DP_PORT(info).dp_port);
 		info->dp_port = DP_PORT(info).dp_port;
 	}
-	t = kzalloc(sizeof(*t), GFP_KERNEL);
+	t = kzalloc(sizeof(*t), GFP_ATOMIC);
 	if (!t) {
 		PR_ERR("fail to alloc %zd bytes\n", sizeof(*t));
 		return DP_FAILURE;
@@ -3069,7 +3069,7 @@ int dp_queue_conf_set_32(struct dp_queue_conf *cfg, int flag)
 		return DP_FAILURE;
 	}
 
-	conf = kzalloc(sizeof(*conf), GFP_KERNEL);
+	conf = kzalloc(sizeof(*conf), GFP_ATOMIC);
 	if (!conf) {
 		PR_ERR("fail to alloc %zd bytes\n", sizeof(*conf));
 		return DP_FAILURE;
@@ -3146,7 +3146,7 @@ int dp_queue_conf_get_32(struct dp_queue_conf *cfg, int flag)
 		return DP_FAILURE;
 	}
 
-	conf = kzalloc(sizeof(*conf), GFP_KERNEL);
+	conf = kzalloc(sizeof(*conf), GFP_ATOMIC);
 	if (!conf) {
 		PR_ERR("fail to alloc %zd bytes\n", sizeof(*conf));
 		return DP_FAILURE;
