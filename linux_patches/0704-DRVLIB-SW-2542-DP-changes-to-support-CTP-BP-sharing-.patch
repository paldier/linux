From 0e13b97b4f3fa91105e13254695af3dc9fed3f67 Mon Sep 17 00:00:00 2001
From: Rekha Eswaran <rekha.eswaran@intel.com>
Date: Wed, 10 Jul 2019 11:54:06 +0800
Subject: [PATCH] DRVLIB_SW-2542 DP changes to support CTP, BP sharing for
 multiple subif in case of DSL for PRX300

---
 drivers/net/datapath/dpm/datapath.h               |  1 +
 drivers/net/datapath/dpm/datapath_api.c           | 15 +++---
 drivers/net/datapath/dpm/datapath_misc.c          |  2 +-
 drivers/net/datapath/dpm/datapath_proc.c          |  3 +-
 drivers/net/datapath/dpm/gswip30/datapath_misc.c  |  1 +
 drivers/net/datapath/dpm/gswip31/datapath_gswip.c | 31 +++++++------
 drivers/net/datapath/dpm/gswip31/datapath_misc.c  | 56 +++++++++++++++++++----
 drivers/net/datapath/dpm/gswip32/datapath_gswip.c |  2 +
 8 files changed, 79 insertions(+), 32 deletions(-)

diff --git a/drivers/net/datapath/dpm/datapath.h b/drivers/net/datapath/dpm/datapath.h
index 0d41d003abaf..f6bf127cd782 100644
--- a/drivers/net/datapath/dpm/datapath.h
+++ b/drivers/net/datapath/dpm/datapath.h
@@ -475,6 +475,7 @@ struct pmac_port_info {
 	struct net_device *dev;
 	u32 dev_port;
 	u32 num_subif;
+	u16 subif_max;
 	s32 port_id;
 	atomic_t tx_err_drop;
 	atomic_t rx_err_drop;
diff --git a/drivers/net/datapath/dpm/datapath_api.c b/drivers/net/datapath/dpm/datapath_api.c
index 1ca6c994241e..fc5ba6a48b38 100644
--- a/drivers/net/datapath/dpm/datapath_api.c
+++ b/drivers/net/datapath/dpm/datapath_api.c
@@ -567,7 +567,7 @@ int32_t dp_register_subif_private(int inst, struct module *owner,
 			}
 		}
 		start = 0;
-		end = port_info->ctp_max;
+		end = port_info->subif_max;
 	} else {
 		/*caller provided subif. Try to get its vap value as start */
 		start = GET_VAP(subif_id->subif, port_info->vap_offset,
@@ -621,7 +621,6 @@ int32_t dp_register_subif_private(int inst, struct module *owner,
 		strncpy(sif->device_name,
 			subif_name,
 		       sizeof(sif->device_name) - 1);
-		sif->flags = PORT_SUBIF_REGISTERED;
 		sif->subif_flag = flags;
 		STATS_SET(sif->rx_flag, 1);
 		port_info->status = PORT_SUBIF_REGISTERED;
@@ -728,7 +727,7 @@ int32_t dp_deregister_subif_private(int inst, struct module *owner,
 		return res;
 	}
 
-	for (i = 0; i < port_info->ctp_max; i++) {
+	for (i = 0; i < port_info->subif_max; i++) {
 		sif = get_dp_port_subif(port_info, i);
 		if (sif->subif == subif_id->subif) {
 			find = 1;
@@ -1304,7 +1303,7 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 		}
 
 		/*search sub-interfaces/VAP */
-		for (i = 0; i < port->ctp_max; i++) {
+		for (i = 0; i < port->subif_max; i++) {
 			struct dp_subif_info *sif = get_dp_port_subif(port, i);
 
 			if (!sif->flags)
@@ -1531,7 +1530,7 @@ int dp_get_port_subitf_via_dev_private(struct net_device *dev,
 	for (i = 0; i < dp_port_prop[inst].info.cap.max_num_dp_ports; i++) {
 		struct pmac_port_info *port = get_dp_port_info(inst, i);
 
-		for (j = 0; j < port->ctp_max; j++) {
+		for (j = 0; j < port->subif_max; j++) {
 			struct dp_subif_info *sif = get_dp_port_subif(port, j);
 
 			if (!sif->flags)
@@ -1570,7 +1569,7 @@ int dp_get_port_subitf_via_ifname_private(char *ifname, dp_subif_t *subif)
 	for (i = 0; i < dp_port_prop[inst].info.cap.max_num_dp_ports; i++) {
 		struct pmac_port_info *port = get_dp_port_info(inst, i);
 
-		for (j = 0; j < port->ctp_max; j++) {
+		for (j = 0; j < port->subif_max; j++) {
 			struct dp_subif_info *sif = get_dp_port_subif(port, j);
 
 			if (strcmp(sif->device_name, ifname) == 0) {
@@ -1672,7 +1671,7 @@ void dp_clear_mib(dp_subif_t *subif, uint32_t flag)
 
 	if (subif->subif == -1) {
 		start_vap = 0;
-		end_vap = port_info->ctp_max;
+		end_vap = port_info->num_subif;
 	} else {
 		start_vap = GET_VAP(subif->subif, port_info->vap_offset,
 				    port_info->vap_mask);
@@ -1733,7 +1732,7 @@ int dp_get_drv_mib(dp_subif_t *subif, dp_drv_mib_t *mib, uint32_t flag)
 
 	if (!(flag & DP_F_STATS_SUBIF)) {
 		/*get all VAP's  mib counters if it is -1 */
-		for (i = 0; i < port_info->ctp_max; i++) {
+		for (i = 0; i < port_info->num_subif; i++) {
 			sif = get_dp_port_subif(port_info, i);
 			if (!sif->flags)
 				continue;
diff --git a/drivers/net/datapath/dpm/datapath_misc.c b/drivers/net/datapath/dpm/datapath_misc.c
index 67a7f9957d69..5a7ce1030c61 100644
--- a/drivers/net/datapath/dpm/datapath_misc.c
+++ b/drivers/net/datapath/dpm/datapath_misc.c
@@ -1320,7 +1320,7 @@ int32_t dp_sync_subifid(struct net_device *dev, char *subif_name,
 	port = get_dp_port_info(0, subif_id->port_id);
 	if (!port)
 		return DP_FAILURE;
-	if (port->alloc_flags & DP_F_FAST_DSL && dev == NULL)
+	if ((port->alloc_flags & DP_F_FAST_DSL) && (dev == NULL))
 		subif_data = (void *)subif_name;
 	/*check flag for register / deregister to update/del */
 	if (flags & DP_F_DEREGISTER) {
diff --git a/drivers/net/datapath/dpm/datapath_proc.c b/drivers/net/datapath/dpm/datapath_proc.c
index 1b81c31bab89..99789aa2ee8e 100644
--- a/drivers/net/datapath/dpm/datapath_proc.c
+++ b/drivers/net/datapath/dpm/datapath_proc.c
@@ -195,6 +195,7 @@ int proc_port_dump(struct seq_file *s, int pos)
 	seq_puts(s, "\n");
 	seq_printf(s, "    mode:              %d\n", port->cqe_lu_mode);
 	seq_printf(s, "    LCT:               %d\n", port->lct_idx);
+	seq_printf(s, "    subif_max:	       %d\n", port->subif_max);
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_SWITCHDEV)
 	seq_printf(s, "    Swdev:             %d\n", port->swdev_en);
 #endif
@@ -229,7 +230,7 @@ int proc_port_dump(struct seq_file *s, int pos)
 	if (pos == 0)
 		loop = info->cap.max_num_subif_per_port;
 	else
-		loop = port->ctp_max;
+		loop = port->subif_max;
 	for (i = 0; i < loop; i++) {
 		struct dp_subif_info *sif = get_dp_port_subif(port, i);
 		struct dev_mib *mib = get_dp_port_subif_mib(sif);
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_misc.c b/drivers/net/datapath/dpm/gswip30/datapath_misc.c
index 4ed789731d23..229a72f738ad 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_misc.c
@@ -471,6 +471,7 @@ static int port_platform_set(int inst, u8 ep, struct dp_port_data *data,
 	struct pmac_port_info *port_info = get_dp_port_info(inst, ep);
 
 	port_info->ctp_max = MAX_SUBIF_PER_PORT;
+	port_info->subif_max = MAX_SUBIF_PER_PORT;
 	port_info->vap_offset = 8;
 	port_info->vap_mask = 0xF;
 	idx = port_info->deq_port_base;
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
index 0e480db318bf..47f148369148 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
@@ -38,6 +38,7 @@ struct ctp_assign {
 	u32 flag; /*Datapath Device Flag */
 	GSW_LogicalPortMode_t emode; /*mapped GSWIP CTP flag */
 	u16 num; /*Max CTP allowed for that GSWIP logical port*/
+	u16 num_subif; /*Max allowed number of subif for that logical port*/
 	u32 vap_offset; /*VAP offset */
 	u32 vap_mask;  /*VAP Mask after shift vap_offset bits */
 	u32 lookup_mode; /*CQE lookup mode  */
@@ -46,27 +47,30 @@ struct ctp_assign {
 
 static struct ctp_assign ctp_assign_info[] = {
 	/*note: multiple flags must put first */
-	{DP_F_CPU, GSW_LOGICAL_PORT_8BIT_WLAN, 16, 8, 0xF, CQE_LU_MODE0, 8},
-	{DP_F_GPON, GSW_LOGICAL_PORT_GPON, 256, 0, 0xFF, CQE_LU_MODE1, 1},
-	{DP_F_EPON, GSW_LOGICAL_PORT_EPON, 256, 0, 0xFF, CQE_LU_MODE1, 1},
-	{DP_F_GINT, GSW_LOGICAL_PORT_GINT, 16, 0, 0xFF, CQE_LU_MODE1, 1},
+	{DP_F_CPU, GSW_LOGICAL_PORT_8BIT_WLAN, 16, 16, 8, 0xF, CQE_LU_MODE0, 8},
+	{DP_F_GPON, GSW_LOGICAL_PORT_GPON, 256, 256, 0, 0xFF, CQE_LU_MODE1, 1},
+	{DP_F_EPON, GSW_LOGICAL_PORT_EPON, 256, 256, 0, 0xFF, CQE_LU_MODE1, 1},
+	{DP_F_GINT, GSW_LOGICAL_PORT_GINT, 16, 16, 0, 0xFF, CQE_LU_MODE1, 1},
 /*#define DP_ETH_TEST*/
 #ifndef DP_ETH_TEST
-	{DP_F_FAST_ETH_WAN, GSW_LOGICAL_PORT_8BIT_WLAN, 8, 8, 0xF,
+	{DP_F_FAST_ETH_WAN, GSW_LOGICAL_PORT_8BIT_WLAN, 8, 8, 8, 0xF,
 		CQE_LU_MODE2, 1},
 	{DP_F_FAST_ETH_LAN | DP_F_ALLOC_EXPLICIT_SUBIFID,
-		GSW_LOGICAL_PORT_8BIT_WLAN, 8, 8, 0xF, CQE_LU_MODE2, 1},
-	{DP_F_FAST_ETH_LAN, GSW_LOGICAL_PORT_8BIT_WLAN, 4, 8, 0xF,
+		GSW_LOGICAL_PORT_8BIT_WLAN, 8, 8, 8, 0xF, CQE_LU_MODE2, 1},
+	{DP_F_FAST_ETH_LAN, GSW_LOGICAL_PORT_8BIT_WLAN, 4, 4, 8, 0xF,
 		CQE_LU_MODE2, 1},
 #else /*testing only */
-	{DP_F_FAST_ETH_WAN, GSW_LOGICAL_PORT_OTHER, 1, 8, 0xF, CQE_LU_MODE2, 1},
+	{DP_F_FAST_ETH_WAN, GSW_LOGICAL_PORT_OTHER, 1, 1, 8, 0xF,
+		CQE_LU_MODE2, 1},
 	{DP_F_FAST_ETH_LAN | DP_F_ALLOC_EXPLICIT_SUBIFID,
-		GSW_LOGICAL_PORT_OTHER, 1, 8, 0xF, CQE_LU_MODE2, 1},
-	{DP_F_FAST_ETH_LAN, GSW_LOGICAL_PORT_OTHER, 1, 8, 0xF, CQE_LU_MODE2, 1},
+		GSW_LOGICAL_PORT_OTHER, 1, 1, 8, 0xF, CQE_LU_MODE2, 1},
+	{DP_F_FAST_ETH_LAN, GSW_LOGICAL_PORT_OTHER, 1, 1, 8, 0xF, CQE_LU_MODE2, 1},
 #endif
-	{DP_F_VUNI, GSW_LOGICAL_PORT_8BIT_WLAN, 2, 8, 0xF, CQE_LU_MODE2, 1},
-	{DP_F_FAST_WLAN, GSW_LOGICAL_PORT_8BIT_WLAN, 16, 8, 0xF, CQE_LU_MODE2, 1},
-	{DP_F_FAST_WLAN_EXT, GSW_LOGICAL_PORT_9BIT_WLAN, 8, 9, 0x7,
+	{DP_F_VUNI, GSW_LOGICAL_PORT_8BIT_WLAN, 2, 2, 8, 0xF, CQE_LU_MODE2, 1},
+	{DP_F_FAST_WLAN, GSW_LOGICAL_PORT_8BIT_WLAN, 16, 16, 8, 0xF, CQE_LU_MODE2, 1},
+	{DP_F_FAST_DSL, GSW_LOGICAL_PORT_8BIT_WLAN, 1, 16, 8, 0xF,
+		CQE_LU_MODE0, 0},
+	{DP_F_FAST_WLAN_EXT, GSW_LOGICAL_PORT_9BIT_WLAN, 8, 8, 9, 0x7,
 		CQE_LU_MODE2, 1}
 };
 
@@ -638,6 +642,7 @@ struct gsw_itf *ctp_port_assign(int inst, u8 ep, int bp_default,
 	itf_assign[ep].end = ctp_assign.nFirstCtpPortId +
 		 ctp_assign.nNumberOfCtpPort - 1;
 	itf_assign[ep].ep = ep;
+	port_info->subif_max = assign->num_subif;
 	port_info->ctp_max = ctp_assign.nNumberOfCtpPort;
 	port_info->vap_offset = assign->vap_offset;
 	port_info->vap_mask = assign->vap_mask;
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_misc.c b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
index 9b388094be70..861e33343786 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
@@ -1533,6 +1533,21 @@ static char *q_flag_str(int q_flag)
 	return "sharing_queue";
 }
 
+static int dp_get_subif_share_bp(int inst, int portid)
+{
+	struct pmac_port_info *port_info;
+	struct dp_subif_info *sif;
+	int i;
+
+	port_info = get_dp_port_info(inst, portid);
+	for (i = 0; i < port_info->subif_max; i++) {
+		sif = get_dp_port_subif(port_info, i);
+		if (sif->flags == 1)
+			return sif->bp;
+	}
+	return -1;
+}
+
 static int subif_hw_set(int inst, int portid, int subif_ix,
 			struct subif_platform_data *data, u32 flags)
 {
@@ -1579,15 +1594,23 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 			 data->subif_data->ctp_dev ?
 				data->subif_data->ctp_dev->name : "NULL");
 		sif->mac_learn_dis = data->subif_data->mac_learn_disable;
-		bp = alloc_bridge_port(inst, portid,
-				       subif_ix, CPU_FID, CPU_BP);
+		if ((port_info->ctp_max == 1) && (port_info->num_subif > 0))
+			bp = dp_get_subif_share_bp(inst, portid);
+		else
+			bp = alloc_bridge_port(inst, portid,
+					       subif_ix, CPU_FID, CPU_BP);
 		if (bp < 0) {
 			PR_ERR("Fail to alloc bridge port\n");
 			return -1;
 		}
 	}
 	sif->bp = bp;
-	set_ctp_bp(inst, subif_ix, portid, sif->bp);
+	if (port_info->ctp_max == 1) {
+		if (port_info->num_subif == 0)
+			set_ctp_bp(inst, 0, portid, sif->bp);
+	} else {
+		set_ctp_bp(inst, subif_ix, portid, sif->bp);
+	}
 	data->act = 0;
 	if (flags & DP_F_SUBIF_LOGICAL) {
 		PR_ERR("need more for logical dev??\n");
@@ -1875,12 +1898,27 @@ static int subif_hw_reset(int inst, int portid, int subif_ix,
 				 sif->device_name);
 		}
 	}
-
-	reset_ctp_bp(inst, subif_ix, portid, bp);
-	if (!dp_bp_dev_tbl[inst][bp].dev) /*NULL already, then free it */ {
-		DP_DEBUG(DP_DBG_FLAG_PAE, "Free BP[%d] vap=%d\n",
-			 bp, subif_ix);
-		free_bridge_port(inst, bp);
+	/* Check for max_ctp since CTP,BP is shared,
+	 * for all subif in case of DSL
+	 */
+	if (port_info->ctp_max == 1) {
+		if (port_info->num_subif == 0) {
+			reset_ctp_bp(inst, 0, portid, bp);
+			if (!dp_bp_dev_tbl[inst][bp].dev) {
+				/*NULL already, then free it */
+				DP_DEBUG(DP_DBG_FLAG_PAE,
+					 "Free BP[%d] vap=%d\n", bp, subif_ix);
+				free_bridge_port(inst, bp);
+			}
+		}
+	} else {
+		reset_ctp_bp(inst, subif_ix, portid, bp);
+		if (!dp_bp_dev_tbl[inst][bp].dev) {
+			/*NULL already, then free it */
+			DP_DEBUG(DP_DBG_FLAG_PAE, "Free BP[%d] vap=%d\n",
+				 bp, subif_ix);
+			free_bridge_port(inst, bp);
+		}
 	}
 #ifdef CONFIG_INTEL_DATAPATH_QOS_HAL
 	qid = sif->qid;
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_gswip.c b/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
index f90bf08e2b0c..d28f50f40cd7 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
@@ -645,6 +645,8 @@ struct gsw_itf *ctp_port_assign_32(int inst, u8 ep, int bp_default,
 		 ctp_assign.nNumberOfCtpPort - 1;
 	itf_assign[ep].ep = ep;
 	port_info->ctp_max = ctp_assign.nNumberOfCtpPort;
+	/* TODO Later change subif_max to real value from assign structure */
+	port_info->subif_max = port_info->ctp_max;
 	port_info->vap_offset = assign->vap_offset;
 	port_info->vap_mask = assign->vap_mask;
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_SWITCHDEV)
