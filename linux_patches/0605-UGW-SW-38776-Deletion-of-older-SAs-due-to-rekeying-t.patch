From b32d6a2e6bf6cd2ec21723af2129f6d92969d3e5 Mon Sep 17 00:00:00 2001
From: moinakde <moinak.debnath@intel.com>
Date: Tue, 14 May 2019 02:41:41 +0530
Subject: [PATCH] UGW_SW-38776: Deletion of older SAs due to rekeying timeout

---
 include/crypto/ltq_ipsec_ins.h |   1 +
 net/ipv4/esp4.c                | 227 +++++++++++++++++++++--------------------
 net/xfrm/xfrm_state.c          |  29 +++++-
 3 files changed, 144 insertions(+), 113 deletions(-)

diff --git a/include/crypto/ltq_ipsec_ins.h b/include/crypto/ltq_ipsec_ins.h
index e9f50b3107a1..4ee4a9dc5a9d 100644
--- a/include/crypto/ltq_ipsec_ins.h
+++ b/include/crypto/ltq_ipsec_ins.h
@@ -174,5 +174,6 @@ int ltq_ipsec_dec(u32 spi, u8 *in, u8 *out, void (*callback)(struct ltq_ipsec_co
 int ltq_get_length_params(u32 spi, unsigned int *ivsize, unsigned int *ICV_length,
 			unsigned int *blksize);
 struct ltq_crypto_ipsec_params *ltq_ipsec_get_params(u32); 
+extern struct ltq_crypto_ipsec_params *(*ltq_ipsec_get_param_hook)(u32 spi);
 #endif /* CONFIG_PPA_MPE_IP97 */ 
 #endif /* _LTQ_IPSEC_INS_H */
diff --git a/net/ipv4/esp4.c b/net/ipv4/esp4.c
index 526d63e2b39e..c71441b01d67 100644
--- a/net/ipv4/esp4.c
+++ b/net/ipv4/esp4.c
@@ -128,76 +128,9 @@ static void esp_output_done_esn(struct crypto_async_request *base, int err)
 	esp_output_restore_header(skb);
 	esp_output_done(base, err);
 }
-#if IS_ENABLED(CONFIG_PPA_MPE_IP97)
-int (*ltq_ipsec_enc_hook)(u32 spi, u16 ip_prot, u8 *in, u8 *out, void (*callback)(struct ltq_ipsec_complete *done),
-			unsigned int buflen, void *ip_data) = NULL;
-EXPORT_SYMBOL(ltq_ipsec_enc_hook);
-
-int (*ltq_get_len_param_hook)(u32 spi, unsigned int *ivsize, unsigned int *ICV_length,
-			unsigned int *blksize) = NULL;
-EXPORT_SYMBOL(ltq_get_len_param_hook);
-
-static void esp_output_done_fastpath(struct ltq_ipsec_complete *done)
-{
-	struct sk_buff *skb = (struct sk_buff *)(done->data);
-	skb->len = done->ret_pkt_len;
-	skb->data = skb_transport_header(skb);
-	skb->tail = skb->data + skb->len;
-	skb_push(skb, -skb_network_offset(skb));
-	xfrm_output_resume(skb, done->err);
-}
 
 static int esp_output(struct xfrm_state *x, struct sk_buff *skb)
 {
-	int32_t err;
-	int32_t trailer_len = 0;
-	uint32_t iv_len = 0, icv_len = 0, blk_size = 0;
-	struct sk_buff *trailer;
-	uint16_t nexthdr;
-	
-	if (!ltq_get_len_param_hook) {
-		printk("param pointer is NULL\n");
-		return ;
-	}
-
-	err = ltq_get_len_param_hook(x->id.spi, &iv_len, &icv_len, &blk_size);
-	if (err < 0) {
-		printk("Invalid IPSec params obtained, so returning\n");
-		return err;
-	}
-
-	trailer_len = icv_len + blk_size ;
-	err = skb_cow_data(skb, trailer_len, &trailer);
-	if (err < 0)
-		goto error;
-	
-	skb_linearize(skb);
-	nexthdr = ip_hdr(skb)->protocol;
-	ip_hdr(skb)->protocol = IPPROTO_ESP;
-	if (!ltq_ipsec_enc_hook) {
-		printk("enc hook is NULL\n");
-		return ;
-	}
-	err = ltq_ipsec_enc_hook(x->id.spi, nexthdr, skb->data, skb_transport_header(skb), esp_output_done_fastpath, skb->len, skb);
-	if (err == -EINPROGRESS)
-		goto error;
-
-	if (err == -EBUSY)
-		err = NET_XMIT_DROP;
-
-	if (err > 0) {
-		skb->data = skb_transport_header(skb);
-		skb->len = err;
-		skb->tail = skb->data + skb->len;
-		skb_push(skb, -skb_network_offset(skb));
-		return 0;
-	}
-error:
-	return err;
-}
-#else
-static int esp_output(struct xfrm_state *x, struct sk_buff *skb)
-{
 	int err;
 	struct esp_output_extra *extra;
 	struct ip_esp_hdr *esph;
@@ -372,6 +305,69 @@ static int esp_output(struct xfrm_state *x, struct sk_buff *skb)
 error:
 	return err;
 }
+#if IS_ENABLED(CONFIG_PPA_MPE_IP97)
+int (*ltq_ipsec_enc_hook)(u32 spi, u16 ip_prot, u8 *in, u8 *out, void (*callback)(struct ltq_ipsec_complete *done),
+			unsigned int buflen, void *ip_data) = NULL;
+EXPORT_SYMBOL(ltq_ipsec_enc_hook);
+
+int (*ltq_get_len_param_hook)(u32 spi, unsigned int *ivsize, unsigned int *ICV_length,
+			unsigned int *blksize) = NULL;
+EXPORT_SYMBOL(ltq_get_len_param_hook);
+
+static void esp_output_done_fastpath(struct ltq_ipsec_complete *done)
+{
+	struct sk_buff *skb = (struct sk_buff *)(done->data);
+	skb->len = done->ret_pkt_len;
+	skb->data = skb_transport_header(skb);
+	skb->tail = skb->data + skb->len;
+	skb_push(skb, -skb_network_offset(skb));
+	xfrm_output_resume(skb, done->err);
+}
+
+static int esp_output_eip97(struct xfrm_state *x, struct sk_buff *skb)
+{
+	int32_t err = 0;
+	int32_t trailer_len = 0;
+	uint32_t iv_len = 0, icv_len = 0, blk_size = 0;
+	struct sk_buff *trailer;
+	uint16_t nexthdr = 0;
+
+	/* If ltq_crypto kmod is absent packet will go via complete CPU Path */
+	if (!ltq_get_len_param_hook || !ltq_ipsec_enc_hook)
+		return esp_output(x, skb);
+
+	/* If Security Association is absent in EIP97's DB, EIP97 wont be able to encrypt the
+		packet so it will go via complete CPU Path and use software crypto modules */
+	err = ltq_get_len_param_hook(x->id.spi, &iv_len, &icv_len, &blk_size);
+	if (err < 0)
+		return esp_output(x, skb);
+
+	trailer_len = icv_len + blk_size ;
+	err = skb_cow_data(skb, trailer_len, &trailer);
+	if (err < 0)
+		goto error;
+
+	skb_linearize(skb);
+	nexthdr = ip_hdr(skb)->protocol;
+	ip_hdr(skb)->protocol = IPPROTO_ESP;
+
+	err = ltq_ipsec_enc_hook(x->id.spi, nexthdr, skb->data, skb_transport_header(skb), esp_output_done_fastpath, skb->len, skb);
+	if (err == -EINPROGRESS)
+		goto error;
+
+	if (err == -EBUSY)
+		err = NET_XMIT_DROP;
+
+	if (err > 0) {
+		skb->data = skb_transport_header(skb);
+		skb->len = err;
+		skb->tail = skb->data + skb->len;
+		skb_push(skb, -skb_network_offset(skb));
+		return 0;
+	}
+error:
+	return err;
+}
 #endif
 
 static int esp_input_done2(struct sk_buff *skb, int err)
@@ -478,52 +474,7 @@ static void esp_input_done_esn(struct crypto_async_request *base, int err)
 	esp_input_restore_header(skb);
 	esp_input_done(base, err);
 }
-#if IS_ENABLED(CONFIG_PPA_MPE_IP97)
-int (*ltq_ipsec_dec_hook)(u32 spi, u8 *in, u8 *out, void (*callback)(struct ltq_ipsec_complete *done),
-		unsigned int buflen, void *ip_data) = NULL;
-
-EXPORT_SYMBOL(ltq_ipsec_dec_hook);
-
-static void esp_input_done_fastpath(struct ltq_ipsec_complete *done)
-{
-	int ihl;
-	struct iphdr *iph;
-	struct sk_buff *skb = (struct sk_buff *)(done->data);
-	skb->len = done->ret_pkt_len;
-	iph = ip_hdr(skb);
-	ihl = iph->ihl * 4;
-	skb->transport_header = skb->network_header = skb->data  - ihl;
-	skb->tail = skb->data  + skb->len;
-	xfrm_input_resume(skb, done->nexthdr);
-}
-static int esp_input(struct xfrm_state *x, struct sk_buff *skb)
-{
-	int32_t err;
-	struct sk_buff *trailer;
-	
-	err = skb_cow_data(skb, 0, &trailer);
-	if (err < 0)
-		goto error;
-	
-	skb_linearize(skb);
-	if(!ltq_ipsec_dec_hook) {
-		printk("dec hook is NULL\n");
-		return;
-	}
-	err = ltq_ipsec_dec_hook(x->id.spi, skb->data, skb->data, esp_input_done_fastpath, skb->len, skb);
-	if (err == -EINPROGRESS)
-		goto error;
-	
-	if(err > 0) {
-		skb->len = err;
-		skb->tail = skb->data  + skb->len;
-		return 0;
-	}
 
-error:
-	return err;
-}
-#else
 /*
  * Note: detecting truncated vs. non-truncated authentication data is very
  * expensive, so we only support truncated data, which is the recommended
@@ -615,6 +566,53 @@ static int esp_input(struct xfrm_state *x, struct sk_buff *skb)
 out:
 	return err;
 }
+#if IS_ENABLED(CONFIG_PPA_MPE_IP97)
+int (*ltq_ipsec_dec_hook)(u32 spi, u8 *in, u8 *out, void (*callback)(struct ltq_ipsec_complete *done),
+		unsigned int buflen, void *ip_data) = NULL;
+
+EXPORT_SYMBOL(ltq_ipsec_dec_hook);
+
+static void esp_input_done_fastpath(struct ltq_ipsec_complete *done)
+{
+	uint16_t ihl = 0;
+	struct iphdr *iph;
+	struct sk_buff *skb = (struct sk_buff *)(done->data);
+	skb->len = done->ret_pkt_len;
+	iph = ip_hdr(skb);
+	ihl = iph->ihl * 4;
+	skb->transport_header = skb->network_header = (uint16_t)(skb->data  - ihl);
+	skb->tail = skb->data  + skb->len;
+	xfrm_input_resume(skb, done->nexthdr);
+}
+
+static int esp_input_eip97(struct xfrm_state *x, struct sk_buff *skb)
+{
+	int32_t err = 0;
+	struct sk_buff *trailer;
+
+	/* If ltq_crypto kmod is absent or Security Association is absent in EIP97's DB, EIP97 wont be
+	able to decrypt the packet so it will go via complete CPU Path and use software crypto modules */
+	if (!ltq_ipsec_dec_hook || !ltq_ipsec_get_param_hook || !ltq_ipsec_get_param_hook(x->id.spi))
+		return esp_input(x, skb);
+
+	err = skb_cow_data(skb, 0, &trailer);
+	if (err < 0)
+		goto error;
+
+	skb_linearize(skb);
+	err = ltq_ipsec_dec_hook(x->id.spi, skb->data, skb->data, esp_input_done_fastpath, skb->len, skb);
+	if (err == -EINPROGRESS)
+		goto error;
+
+	if(err > 0) {
+		skb->len = err;
+		skb->tail = skb->data  + skb->len;
+		return 0;
+	}
+
+error:
+	return err;
+}
 #endif
 
 static u32 esp4_get_mtu(struct xfrm_state *x, int mtu)
@@ -864,8 +862,13 @@ static const struct xfrm_type esp_type =
 	.init_state	= esp_init_state,
 	.destructor	= esp_destroy,
 	.get_mtu	= esp4_get_mtu,
+#if IS_ENABLED(CONFIG_PPA_MPE_IP97)
+	.input		= esp_input_eip97,
+	.output		= esp_output_eip97
+#else
 	.input		= esp_input,
 	.output		= esp_output
+#endif
 };
 
 static struct xfrm4_protocol esp4_protocol = {
diff --git a/net/xfrm/xfrm_state.c b/net/xfrm/xfrm_state.c
index 3734ad56b456..f3e49fda6db3 100644
--- a/net/xfrm/xfrm_state.c
+++ b/net/xfrm/xfrm_state.c
@@ -27,7 +27,16 @@
 #include <linux/kernel.h>
 
 #include "xfrm_hash.h"
-
+#if IS_ENABLED(CONFIG_PPA_MPE_IP97)
+#include <net/ppa/ppa_api.h>
+#include <net/ppa/ppa_stack_al.h>
+#include <net/ppa/ppa_hook.h>
+#include <crypto/ltq_ipsec_ins.h>
+struct ltq_crypto_ipsec_params *(*ltq_ipsec_get_param_hook)(u32 spi) = NULL;
+EXPORT_SYMBOL(ltq_ipsec_get_param_hook);
+void (*ltq_destroy_ipsec_sa_hook)(struct ltq_crypto_ipsec_params *req) = NULL;
+EXPORT_SYMBOL(ltq_destroy_ipsec_sa_hook);
+#endif
 #define xfrm_state_deref_prot(table, net) \
 	rcu_dereference_protected((table), lockdep_is_held(&(net)->xfrm.xfrm_state_lock))
 
@@ -404,6 +413,9 @@ static enum hrtimer_restart xfrm_timer_handler(struct hrtimer *me)
 	long next = LONG_MAX;
 	int warn = 0;
 	int err = 0;
+#if defined(CONFIG_PPA_MPE_IP97)
+	struct ltq_crypto_ipsec_params *params = NULL;
+#endif
 
 	spin_lock(&x->lock);
 	if (x->km.state == XFRM_STATE_DEAD)
@@ -478,6 +490,21 @@ static enum hrtimer_restart xfrm_timer_handler(struct hrtimer *me)
 
 	xfrm_audit_state_delete(x, err ? 0 : 1, true);
 
+#if defined(CONFIG_PPA_MPE_IP97)
+/* PPA Del SA callback needs to be invoked after re-keyed timeout, where older SA is removed */
+	if (ppa_hook_session_ipsec_del_fn)
+		ppa_hook_session_ipsec_del_fn(x);
+
+	if (ltq_ipsec_get_param_hook && ltq_destroy_ipsec_sa_hook) {
+		params = ltq_ipsec_get_param_hook(x->id.spi);
+		if (!params) {
+			pr_err("No entry found for spi = 0x%08x, unable to remove SA after rekeyed timeout\n", x->id.spi);
+			goto out;
+		}
+		ltq_destroy_ipsec_sa_hook(params);
+	}
+#endif /* CONFIG_PPA_MPE_IP97 */
+
 out:
 	spin_unlock(&x->lock);
 	return HRTIMER_NORESTART;
