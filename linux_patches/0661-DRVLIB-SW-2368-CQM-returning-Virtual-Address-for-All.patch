From 30b7bc14212a1acf0847c8b7a9c9cb34d08a2d02 Mon Sep 17 00:00:00 2001
From: Gu Chao <gux.chao@intel.com>
Date: Mon, 1 Jul 2019 18:07:15 +0800
Subject: [PATCH] DRVLIB_SW-2368: CQM returning Virtual Address for Allocated
 Buffers for DC

---
 drivers/net/ethernet/lantiq/cqm/prx300/cqm.c | 52 +++++++++++++++++++++-------
 include/net/datapath_api.h                   | 30 ++++++++++++++++
 include/net/lantiq_cbm_api.h                 |  4 ++-
 3 files changed, 72 insertions(+), 14 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c b/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
index 514de8d23e59..b8e9dcc51da5 100644
--- a/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
+++ b/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
@@ -2060,7 +2060,9 @@ static s32 cqm_dp_port_dealloc(struct module *owner, u32 dev_port,
 				break;
 			}
 		}
-		devm_kfree(cqm_ctrl->dev, p_info->deq_info.pkt_base);
+		dmam_free_coherent(cqm_ctrl->dev, p_info->deq_info.dma_size,
+					p_info->deq_info.pkt_base,
+					p_info->deq_info.pkt_base_paddr);
 		ltq_dma_chan_desc_free(p_info->dma_ch);
 	}
 
@@ -2189,6 +2191,9 @@ static void fill_tx_ring_data(struct cbm_dp_alloc_complete_data *dp_data)
 	struct cqm_dqm_port_info *p_info;
 	void *deq = cqm_ctrl->deq_phy + DESC0_0_CPU_EGP_0;
 	void *free = cqm_ctrl->deq_phy + PTR_RTN_CPU_DW2_EGP_0;
+	void *deq_v = cqm_ctrl->deq + DESC0_0_CPU_EGP_0;
+	void *free_v = cqm_ctrl->deq + PTR_RTN_CPU_DW2_EGP_0;
+
 	u8 ring_idx;
 
 	p_info = &dqm_port_info[dp_data->deq_port];
@@ -2199,9 +2204,17 @@ static void fill_tx_ring_data(struct cbm_dp_alloc_complete_data *dp_data)
 		dp_data->tx_ring[ring_idx].in_deq_paddr	=
 			(deq + (dp_data->deq_port * (DESC0_0_CPU_EGP_1 -
 			 DESC0_0_CPU_EGP_0)));
+		dp_data->tx_ring[ring_idx].in_deq_vaddr	=
+			(deq_v + (dp_data->deq_port * (DESC0_0_CPU_EGP_1 -
+			 DESC0_0_CPU_EGP_0)));
+
 		dp_data->tx_ring[ring_idx].out_free_paddr =
 			(free + (dp_data->deq_port * (PTR_RTN_CPU_DW2_EGP_1 -
 			 PTR_RTN_CPU_DW2_EGP_0)));
+		dp_data->tx_ring[ring_idx].out_free_vaddr =
+			(free_v + (dp_data->deq_port * (PTR_RTN_CPU_DW2_EGP_1 -
+			 PTR_RTN_CPU_DW2_EGP_0)));
+
 		dp_data->tx_ring[ring_idx].out_free_ring_size =
 			p_info->deq_info.num_free_burst;
 
@@ -2219,6 +2232,11 @@ static int fill_rx_ring_data(struct cbm_dp_alloc_complete_data *dp_data)
 	u32 buf,  cpu = smp_processor_id();
 	struct cqm_dqm_port_info *p_info;
 	int ring_idx, idx, ret = CBM_FAILURE;
+	size_t tbl_size;
+	size_t dma_size;
+	void *dma_vaddr;
+	dma_addr_t dma_paddr;
+	u32 *vbase;
 
 	p_info = &dqm_port_info[dp_data->deq_port];
 
@@ -2298,21 +2316,30 @@ static int fill_rx_ring_data(struct cbm_dp_alloc_complete_data *dp_data)
 							dp_data->num_rx_ring;
 		dp_data->rx_ring[ring_idx].out_enq_paddr =
 			(void *)ltq_dma_chan_get_desc_phys_base(p_info->dma_ch);
+		dp_data->rx_ring[ring_idx].out_enq_vaddr =
+			(void *)ltq_dma_chan_get_desc_vir_base(p_info->dma_ch);
 
 		cbm_w32((cqm_ctrl->enq + EQ_DMA_PORT(dp_data->deq_port, dptr)),
 			(dp_data->rx_ring[ring_idx].out_enq_ring_size  - 1));
 
-		p_info->deq_info.pkt_base =
-		    devm_kzalloc(cqm_ctrl->dev,
-				 (sizeof(u32) *
-				 dp_data->rx_ring[ring_idx].prefill_pkt_num),
-				 GFP_ATOMIC);
-		if (!p_info->deq_info.pkt_base) {
-			dev_err(cqm_ctrl->dev, "%s: kzalloc failed\r\n",
-				__func__);
+		tbl_size = dp_data->rx_ring[ring_idx].prefill_pkt_num
+				* sizeof(u32);
+		dma_size = tbl_size * 2;
+		dma_vaddr = dmam_alloc_coherent(cqm_ctrl->dev, dma_size,
+						&dma_paddr, GFP_DMA);
+		if (!dma_vaddr) {
+			dev_err(cqm_ctrl->dev,
+				"%s: dmam_alloc_coherent failed\n", __func__);
 			ltq_free_dma(p_info->dma_ch);
 			break;
 		}
+		p_info->deq_info.pkt_base_paddr = (void *)dma_paddr;
+		p_info->deq_info.pkt_base = dma_vaddr;
+		p_info->deq_info.dma_size = dma_size;
+		dp_data->rx_ring[ring_idx].pkt_base_paddr = (void *)dma_paddr;
+		dp_data->rx_ring[ring_idx].pkt_base_vaddr = dma_vaddr;
+		vbase = dma_vaddr + tbl_size;
+		dp_data->rx_ring[ring_idx].pkt_list_vaddr = vbase;
 
 		/* BM Buffer */
 		for (idx = 0; idx < dp_data->rx_ring[ring_idx].prefill_pkt_num;
@@ -2329,17 +2356,16 @@ static int fill_rx_ring_data(struct cbm_dp_alloc_complete_data *dp_data)
 					buf = p_info->deq_info.pkt_base[idx];
 					cqm_buffer_free(cpu, (void *)buf, 1);
 				}
-				devm_kfree(cqm_ctrl->dev,
-					   p_info->deq_info.pkt_base);
+				dmam_free_coherent(cqm_ctrl->dev, dma_size,
+						dma_vaddr, dma_paddr);
 				ltq_free_dma(p_info->dma_ch);
 				break;
 			}
 			p_info->deq_info.pkt_base[idx] =
 					__pa(buf - CQM_POOL_METADATA);
+			vbase[idx] = buf - CQM_POOL_METADATA;
 		}
 
-		dp_data->rx_ring[ring_idx].pkt_base_paddr =
-				(void *)__pa(p_info->deq_info.pkt_base);
 		dp_data->rx_ring[ring_idx].num_pkt =
 				dp_data->rx_ring[ring_idx].prefill_pkt_num;
 
diff --git a/include/net/datapath_api.h b/include/net/datapath_api.h
index bc5170afd140..fca74cddac35 100644
--- a/include/net/datapath_api.h
+++ b/include/net/datapath_api.h
@@ -1026,6 +1026,14 @@ struct dp_rx_ring {
 				*   For LGM: it is CQM enqueue register address
 				*   If NULL, it means not valid
 				*/
+	void *out_enq_vaddr;	/*!< [out] rxout ring virtual address
+				*   For software testing or debugging
+				*   For GRX350/PRX300, it is DMA coherent
+				*     virtual address of DMA Descriptor base
+				*   For LGM, it is IO mapped virtual address
+				*     of CQM enqueue register base
+				*   If NULL, it means not valid
+				*/
 	u32 out_dma_ch_to_gswip; /*!< [out] DMA TX channel base to GSWIP for
 				  *   forwarding rxout packet to GSWIP
 				  */
@@ -1044,6 +1052,12 @@ struct dp_rx_ring {
 			       *   Note:
 			       *   1. GRX350/PRX300: not support
 			       */
+	void *in_alloc_vaddr;	/*!< [out] rxin ring buf allocation virtual
+				*     address. It is for 4 ring case only
+				*   For software testing or debugging
+				*   Note:
+				*   1. GRX350/PRX300: not support
+				*/
 	u32 num_pkt; /*!< [in/out] nuber of packet for this policy */
 	int rx_pkt_size; /*!< [in/out] rx packet buffer size
 			  *   requirement rxout packets.
@@ -1070,6 +1084,16 @@ struct dp_rx_ring {
 			       *     The buffer size should based on @rx_pkt_size
 			       *     requirement
 			       */
+	void *pkt_base_vaddr;	/*!< [out] packet list base virtual address,
+				*    which stored @prefill_pkt_num of packet
+				*    physical addresses
+				*    For software testing or debugging
+				*/
+	void *pkt_list_vaddr;	/*!< [out] virtual address of 2nd pkt list,
+				*    which stored @prefill_pkt_num of packet
+				*    virtual addresses
+				*    For software testing or debugging
+				*/
 	enum DP_RXOUT_MSG_MODE out_msg_mode; /*!< [in] rxout msg mode */
 	enum DP_RXOUT_QOS_MODE out_qos_mode; /*!< [in] rxout qos mode */
 };
@@ -1087,6 +1111,9 @@ struct dp_tx_ring {
 	void *in_deq_paddr; /*!< [out] txin ring/dequeue physical base
 			     *   address
 			     */
+	void *in_deq_vaddr;	/*!< [out] txin ring/dequeue virtual base address
+					* For software testing or debugging
+					*/
 	int out_free_ring_size;/*!< [out] txout ring/free buffer burst size,
 				*     the number of buffer can be freed in
 				*     in one free operation.
@@ -1094,6 +1121,9 @@ struct dp_tx_ring {
 	void *out_free_paddr; /*!< [out] txout/free buffer
 			       *     physica address
 			       */
+	void *out_free_vaddr;	/*!< [out] txout/free buffer virtual base address
+					* For software testing or debugging
+					*/
 	u32 num_tx_pkt; /*!< [in] nuber of packet */
 	int tx_pkt_size; /*!< [in] maximum packet size
 			  *   requirement to the packet
diff --git a/include/net/lantiq_cbm_api.h b/include/net/lantiq_cbm_api.h
index 1257ecd970e1..b4c9068dc5de 100644
--- a/include/net/lantiq_cbm_api.h
+++ b/include/net/lantiq_cbm_api.h
@@ -496,7 +496,9 @@ typedef struct cbm_dq_info {
 	int32_t		dma_tx_chan;	/*! PMAC DMA Tx Channel */
 	uint32_t	num_desc; /*!< Number of Descriptors at port base */
 	u32 num_free_burst; /*!< Number of free burst size */
-	u32 *pkt_base; /*!<packet list base physical address */
+	u32 *pkt_base; /*!<packet list base DMA virtual address */
+	void *pkt_base_paddr;	/* packet list base DMA physical address */
+	size_t dma_size;	/* size of allocated DMA memory */
 } cbm_dq_info_t;
 
 /*!
