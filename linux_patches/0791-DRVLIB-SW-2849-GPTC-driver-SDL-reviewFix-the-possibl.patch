From ee51de0d2f7f8caed8b94e47db626ffe5d58ee7c Mon Sep 17 00:00:00 2001
From: Songjun Wu <songjun.wu@linux.intel.com>
Date: Fri, 13 Sep 2019 10:50:57 +0800
Subject: [PATCH] DRVLIB_SW-2849 - GPTC driver SDL reviewFix the possible
 memory leak

Signed-off-by: Songjun Wu <songjun.wu@linux.intel.com>
---
 drivers/clocksource/intel-gptc-timer.c | 36 +++++++++++++++++++++++++++-------
 1 file changed, 29 insertions(+), 7 deletions(-)

diff --git a/drivers/clocksource/intel-gptc-timer.c b/drivers/clocksource/intel-gptc-timer.c
index 04b485c57418..ddfdb6ad2d1d 100644
--- a/drivers/clocksource/intel-gptc-timer.c
+++ b/drivers/clocksource/intel-gptc-timer.c
@@ -520,6 +520,31 @@ static void gptc_put(struct gptc *gptc)
 	kref_put(&gptc->ref, __gptc_release);
 }
 
+static void gptc_free_timer(void)
+{
+	struct gptc_timer *timer, *next;
+
+	list_for_each_entry_safe(timer, next, &gptc_clksrc_list, clksrc)
+		kfree(timer);
+	INIT_LIST_HEAD(&gptc_clksrc_list);
+
+	list_for_each_entry_safe(timer, next, &gptc_heartbeat_list, heartbeat)
+		kfree(timer);
+	INIT_LIST_HEAD(&gptc_heartbeat_list);
+
+	list_for_each_entry_safe(timer, next, &gptc_clkevt_list, clkevt)
+		kfree(timer);
+	INIT_LIST_HEAD(&gptc_clkevt_list);
+
+	list_for_each_entry_safe(timer, next, &gptc_wdt_list, wdt)
+		kfree(timer);
+	INIT_LIST_HEAD(&gptc_wdt_list);
+
+	list_for_each_entry_safe(timer, next, &gptc_ht_yield_list, ht_yield)
+		kfree(timer);
+	INIT_LIST_HEAD(&gptc_ht_yield_list);
+}
+
 static int gptc_of_parse_timer(struct gptc *gptc)
 {
 	u32 type;
@@ -673,6 +698,7 @@ static int gptc_of_init(struct device_node *np)
 	gptc_of_config_print(gptc);
 	return 0;
 err_parse_fail:
+	gptc_free_timer();
 	gptc_clock_disable(gptc);
 err_clk_en:
 	gptc_clock_deinit(gptc);
@@ -1170,6 +1196,7 @@ static const struct file_operations gptc_ops = {
 	.release = seq_release,
 };
 
+#if IS_ENABLED(CONFIG_DEBUG_FS)
 static int gptc_debugfs_init(void)
 {
 	struct dentry *file;
@@ -1179,7 +1206,7 @@ static int gptc_debugfs_init(void)
 	if (!debugfs)
 		return -ENOMEM;
 
-	file = debugfs_create_file("status", 0444, debugfs, NULL, &gptc_ops);
+	file = debugfs_create_file("status", 0400, debugfs, NULL, &gptc_ops);
 	if (!file)
 		goto remove;
 
@@ -1190,6 +1217,7 @@ static int gptc_debugfs_init(void)
 	return -ENOMEM;
 }
 late_initcall(gptc_debugfs_init);
+#endif
 
 static const struct of_device_id gptc_match[] = {
 	{
@@ -1215,11 +1243,6 @@ static int gptc_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int gptc_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
 /**
  * GPTC might not be used as clock source in PRX300.
  * GPTC driver for prx300 has same function scopes as other soc,
@@ -1228,7 +1251,6 @@ static int gptc_remove(struct platform_device *pdev)
  */
 static struct platform_driver gptc_drv = {
 	.probe = gptc_probe,
-	.remove = gptc_remove,
 	.driver = {
 		.name = "gptc",
 		.of_match_table = gptc_match,
