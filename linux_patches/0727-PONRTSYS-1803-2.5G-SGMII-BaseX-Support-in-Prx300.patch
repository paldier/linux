From ac2f8d956951a1f313f2ca98f263f496f24b0747 Mon Sep 17 00:00:00 2001
From: thampan <joby.thampan@intel.com>
Date: Sun, 4 Aug 2019 23:12:10 +0800
Subject: [PATCH] PONRTSYS-1803: 2.5G SGMII BaseX Support in Prx300

    - 2.5G SGMII BaseX Support
    - phy_calibrate(), This is doing enable RX auto adapt, When board is designed with different length on the HSIO signal,
      this is required to ensure good signal quality
    - Reference Clock Frequency set to 156.1 - 182 MHz
---
 drivers/net/ethernet/lantiq/xpcs/xpcs.c | 132 +++++++++++++++++++++-----------
 drivers/net/ethernet/lantiq/xpcs/xpcs.h |  11 ++-
 2 files changed, 96 insertions(+), 47 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/xpcs/xpcs.c b/drivers/net/ethernet/lantiq/xpcs/xpcs.c
index 586673fb63be..7d0098cc55b8 100644
--- a/drivers/net/ethernet/lantiq/xpcs/xpcs.c
+++ b/drivers/net/ethernet/lantiq/xpcs/xpcs.c
@@ -41,7 +41,7 @@ static int xpcs_vs_reset(struct xpcs_prv_data *pdata);
 static int xpcs_oneg_xaui_mode(struct xpcs_prv_data *pdata);
 static int xpcs_teng_xaui_mode(struct xpcs_prv_data *pdata);
 static int xpcs_teng_kr_mode(struct xpcs_prv_data *pdata);
-static int xpcs_2p5g_xaui_mode(struct xpcs_prv_data *pdata);
+static int xpcs_2p5g_sgmii_mode(struct xpcs_prv_data *pdata);
 static int xpcs_synphy_reset_sts(struct xpcs_prv_data *pdata);
 
 struct xpcs_mode_cfg mode_cfg[MAX_XPCS_MODE] = {
@@ -68,7 +68,7 @@ struct xpcs_mode_cfg mode_cfg[MAX_XPCS_MODE] = {
 		.tx_eq_pre = 0x14,
 		.tx_eq_post = 0x14,
 		.tx_eq_ovrride = 1,
-		.ref_clk_ctrl = 0,
+		.ref_clk_ctrl = 0x171,
 		.los_thr = 4,
 		.phy_boost_gain_val = 0x774a,
 		.rx_vref_ctrl = 0,
@@ -106,7 +106,7 @@ struct xpcs_mode_cfg mode_cfg[MAX_XPCS_MODE] = {
 		.tx_eq_pre = 0,
 		.tx_eq_post = 0,
 		.tx_eq_ovrride = 1,
-		.ref_clk_ctrl = 0,
+		.ref_clk_ctrl = 0x171,
 		.los_thr = 1,
 		.phy_boost_gain_val = 0x7706,
 		.rx_vref_ctrl = 0xF,	/* Setting BIT12:8 = 5'd15 */
@@ -138,7 +138,7 @@ struct xpcs_mode_cfg mode_cfg[MAX_XPCS_MODE] = {
 		.tx_eq_post = 0,
 		.tx_eq_ovrride = 1,
 		.los_thr = 0,
-		.ref_clk_ctrl = 0,
+		.ref_clk_ctrl = 0x1F1,
 		.los_thr = 4,
 		.phy_boost_gain_val = 0x7706,
 		.rx_vref_ctrl = 0xF,	/* Setting BIT12:8 = 5'd15 */
@@ -147,36 +147,47 @@ struct xpcs_mode_cfg mode_cfg[MAX_XPCS_MODE] = {
 		.set_mode = xpcs_oneg_xaui_mode,
 	},
 	{
-		.id = TWOP5G_GMII_MODE,
+		.id = TWOP5G_SGMII_MODE,
 		.pma_type = PMA_TYPE_1G_BASE_KX,
-		.pcs_type = 0,
+		.pcs_type = PCS_TYPE_10G_BASE_X,
 		.lane = LANE_1,
-		.mplla_mult = 0,
-		.mplla_bw = 0,
-		.vco_ld_val[0] = 2,
-		.vco_ref_ld[0] = 2,
+		.mplla_mult = 0x28,
+		.mplla_bw = 0x56,
+		.mpllb_mult = 0x28,
+		.mpllb_bw = 0x56,
+		.vco_ld_val[0] = 0x550,
+		.vco_ref_ld[0] = 0x22,
+		.vco_ld_val[1] = 0x550,
 		.afe_en = 0,
 		.dfe_en = 0,
+		.afe_en_31 = 0,
+		.dfe_en_31 = 0,
 		.cont_adapt0 = 0,
-		.tx_rate[0] = 0,
-		.rx_rate[0] = 0,
-		.tx_width[0] = 0,
-		.rx_width[0] = 0,
+		.cont_adapt31 = 0,
+		.tx_rate[0] = 2, /* 3'b010 : baud/4 */
+		.rx_rate[0] = 2, /* 2'b10 : baud/4 */
+		.tx_width[0] = 1, /* 2'b01: 10-bit; 2'b11: 20-bit */
+		.rx_width[0] = 1, /* 2'b01: 10-bit; 2'b11: 20-bit */
 		.mplla_div165_clk_en = 0,
-		.mplla_div10_clk_en = 0,
+		.mplla_div10_clk_en = 1,
 		.mplla_div8_clk_en = 0,
-		.tx_eq_main = 0,
-		.tx_eq_pre = 0,
-		.tx_eq_post = 0,
-		.tx_eq_ovrride = 0,
-		.los_thr = 0,
-		.ref_clk_ctrl = 0,
-		.los_thr = 0,
-		.phy_boost_gain_val = 0,
-		.rx_vref_ctrl = 0,
+		.mplla_div_clk_en = 0,
+		.mpllb_div_clk_en = 0,
+		.mpllb_div10_clk_en = 1,
+		.mpllb_div8_clk_en = 0,
+		.rx_div165_clk_en = 0,
+		.tx_eq_main = 0x13,
+		.tx_eq_pre = 4,
+		.tx_eq_post = 4,
+		.tx_eq_ovrride = 1,
+		.los_thr = 1,
+		.ref_clk_ctrl = 0x1F1,
+		.los_thr = 1,
+		.phy_boost_gain_val = 0x7706,
+		.rx_vref_ctrl = 0xF,	/* Setting BIT12:8 = 5'd15 */
 		.vboost_lvl = 0x5,
 		.tx_iboost[0] = 0xF,
-		.set_mode = xpcs_2p5g_xaui_mode,
+		.set_mode = xpcs_2p5g_sgmii_mode,
 	},
 };
 
@@ -195,7 +206,7 @@ static int xpcs_rxtx_stable(struct xpcs_prv_data *pdata)
 			else if (pdata->mode == ONEG_XAUI_MODE)
 				pr_debug("%s: Tx/Rx stable (Power_Good State) "
 					 "Speed: 1G\n", pdata->name);
-			else if (pdata->mode == TWOP5G_GMII_MODE)
+			else if (pdata->mode == TWOP5G_SGMII_MODE)
 				pr_debug("%s: Tx/Rx stable (Power_Good State) "
 					 "Speed: 2.5G\n", pdata->name);
 
@@ -288,7 +299,6 @@ static int xpcs_2p5g_mode(struct xpcs_prv_data *pdata)
 	if (pdata->pcs_mode == BACKPL_ETH_PCS) {
 		XPCS_SET_VAL(pma_ctrl, PMA_CTRL1, SS13, 0);
 		XPCS_RGWR(pdata, PMA_CTRL1, pma_ctrl);
-	} else {
 		XPCS_SET_VAL(pcs_ctrl, PCS_CTRL1, SS13, 0);
 		XPCS_RGWR(pdata, PCS_CTRL1, pcs_ctrl);
 	}
@@ -490,6 +500,9 @@ static void xpcs_cfg_table(struct xpcs_prv_data *pdata)
 			     pdata->mode_cfg->mpllb_div8_clk_en);
 
 		XPCS_RGWR(pdata, PMA_MPLLB_C2, mplla_ctrl2);
+
+		XPCS_RGWR_VAL(pdata, PMA_VCO_CAL_LD1, VCO_LD_VAL_1,
+			      pdata->mode_cfg->vco_ld_val[1]);
 	} else {
 		mplla_ctrl2 = XPCS_RGRD(pdata, PMA_MPLLA_C2);
 
@@ -499,6 +512,8 @@ static void xpcs_cfg_table(struct xpcs_prv_data *pdata)
 			     pdata->mode_cfg->mplla_div10_clk_en);
 		XPCS_SET_VAL(mplla_ctrl2, PMA_MPLLA_C2, MPLLA_DIV8_CLK_EN,
 			     pdata->mode_cfg->mplla_div8_clk_en);
+		XPCS_SET_VAL(mplla_ctrl2, PMA_MPLLA_C2, MPLLA_DIV_CLK_EN,
+			     pdata->mode_cfg->mplla_div_clk_en);
 
 		XPCS_RGWR(pdata, PMA_MPLLA_C2, mplla_ctrl2);
 	}
@@ -618,6 +633,8 @@ static int xpcs_teng_kr_mode(struct xpcs_prv_data *pdata)
 	/* PHY ctle_pole and boost and gain register */
 	XPCS_RGWR(pdata, PMA_RX_EQ_CTRL0, pdata->mode_cfg->phy_boost_gain_val);
 
+	XPCS_RGWR(pdata, PMA_REF_CLK_CTRL, pdata->mode_cfg->ref_clk_ctrl);
+
 	/* Link Up and Down, No Configuration reset */
 	if (xpcs_vs_reset(pdata) != XPCS_SUCCESS)
 		return XPCS_FAILURE;
@@ -688,6 +705,8 @@ static int xpcs_oneg_xaui_mode(struct xpcs_prv_data *pdata)
 	XPCS_RGWR_VAL(pdata, PMA_MISC_C0, RX_VREF_CTRL,
 		      pdata->mode_cfg->rx_vref_ctrl);
 
+	XPCS_RGWR(pdata, PMA_REF_CLK_CTRL, pdata->mode_cfg->ref_clk_ctrl);
+
 	/* Link Up and Down, No Configuration reset */
 	if (xpcs_vs_reset(pdata) != XPCS_SUCCESS)
 		return XPCS_FAILURE;
@@ -698,9 +717,15 @@ static int xpcs_oneg_xaui_mode(struct xpcs_prv_data *pdata)
 	return XPCS_SUCCESS;
 }
 
-/* 2.5G XAUI Mode */
-static int xpcs_2p5g_xaui_mode(struct xpcs_prv_data *pdata)
+/* 2.5G SGMII Mode */
+static int xpcs_2p5g_sgmii_mode(struct xpcs_prv_data *pdata)
 {
+	if (!strcmp(pdata->name, "wan_xpcs")) {
+		pdata->mpllb = 0;
+	} else {
+		pdata->mpllb = 1;
+	}
+
 	if (xpcs_byp_pwrupseq(pdata) != XPCS_SUCCESS)
 		return XPCS_FAILURE;
 
@@ -719,31 +744,33 @@ static int xpcs_2p5g_xaui_mode(struct xpcs_prv_data *pdata)
 	XPCS_RGWR_VAL(pdata, PCS_CTRL2, PCS_TYPE_SEL,
 		      pdata->mode_cfg->pcs_type);
 
-	/* Set PMA_Type=1 10GBASE-X PCS Type */
+	/* Set 1GBASE-KX PCS Type */
 	XPCS_RGWR_VAL(pdata, PMA_CTRL2, PMA_TYPE,
 		      pdata->mode_cfg->pma_type);
 
 	/* 2.5G GMII Mode operation for 1000BaseX PCS Configuration */
 	XPCS_RGWR_VAL(pdata, VR_MII_DIG_CTRL1, EN_2_5G_MODE, 1);
 
-	/* Enable 2.5G GMII Mode GMII port
-	 * operating at 312.5MHz instead of 125MHz) of operation for all other
-	 * configurations other than 1000 Base X
-	 */
-	XPCS_RGWR_VAL(pdata, PCS_DIG_CTRL1, EN_2_5G_MODE, 1);
-
 	/* SGMII Mode */
 	XPCS_RGWR_VAL(pdata, SR_MII_CTRL, SS13, 0);
 	XPCS_RGWR_VAL(pdata, SR_MII_CTRL, SS6, 1);
 
-	/* TODO: Need to double check this setting is needed, default is 0
-	 * Setting Bit7:4 to 4'b0000 to de-select MPLLB
-	 */
-	XPCS_RGWR_VAL(pdata, PMA_MPLL_CMN_CTRL, MPLLB_SEL_3_1, 0);
-	XPCS_RGWR_VAL(pdata, PMA_MPLL_CMN_CTRL, MPLLB_SEL_0, 0);
+	if (pdata->mpllb) {
+		/* Select MPLLB for XAUI/10GBASE-KX4 */
+		XPCS_RGWR_VAL(pdata, PMA_MPLL_CMN_CTRL, MPLLB_SEL_3_1, 0);
+		XPCS_RGWR_VAL(pdata, PMA_MPLL_CMN_CTRL, MPLLB_SEL_0, 1);
+	} else {
+		/* De-Select MPLLB for XAUI/10GBASE-KX4 */
+		XPCS_RGWR_VAL(pdata, PMA_MPLL_CMN_CTRL, MPLLB_SEL_3_1, 0);
+		XPCS_RGWR_VAL(pdata, PMA_MPLL_CMN_CTRL, MPLLB_SEL_0, 0);
+	}
 
 	xpcs_cfg_table(pdata);
 
+	/* Receiver Divide by 16.5 output clock on lane 0 */
+	XPCS_RGWR_VAL(pdata, PMA_RX_GENCTRL1, RX_DIV16P5_CLK_EN,
+		      pdata->mode_cfg->rx_div165_clk_en);
+
 	/* PHY LOS threshold register */
 	XPCS_RGWR(pdata, PMA_RX_GENCTRL3, pdata->mode_cfg->los_thr);
 
@@ -754,15 +781,19 @@ static int xpcs_2p5g_xaui_mode(struct xpcs_prv_data *pdata)
 	XPCS_RGWR_VAL(pdata, PMA_MISC_C0, RX_VREF_CTRL,
 		      pdata->mode_cfg->rx_vref_ctrl);
 
+
+	/* Select CR Para Port This bit select the interface for accessing
+	 * PHY registers: * 0 -JTAG * 1 -CR parallel port This bit should be
+	 * changed only after disabling 'jtag_tck'to PHY.
+	 */
+	XPCS_RGWR_VAL(pdata, PMA_MISC_C0, CR_PARA_SEL, 1);
+
 	XPCS_RGWR(pdata, PMA_REF_CLK_CTRL, pdata->mode_cfg->ref_clk_ctrl);
 
 	/* Link Up and Down, No Configuration reset */
 	if (xpcs_vs_reset(pdata) != XPCS_SUCCESS)
 		return XPCS_FAILURE;
 
-	/* Enable Clause 37 Auto-negotiation */
-	xpcs_cl37_an(pdata);
-
 	return XPCS_SUCCESS;
 }
 
@@ -808,7 +839,7 @@ static void xpcs_cl37_an(struct xpcs_prv_data *pdata)
 	XPCS_RGWR_VAL(pdata, VR_MII_DIG_CTRL1, MAC_AUTO_SW, 0);
 
 	/* 2.5G Mode */
-	if (pdata->mode == TWOP5G_GMII_MODE) {
+	if (pdata->mode == TWOP5G_SGMII_MODE) {
 		/* Link timer runs for 1.6 ms */
 		XPCS_RGWR(pdata, VR_MII_LINK_TIMER_CTRL, 0x07A1);
 
@@ -1004,11 +1035,14 @@ int xpcs_ethtool_ksettings_get(struct device *dev,
 
 	ethtool_link_ksettings_add_link_mode(cmd, supported, 1000baseX_Full);
 	ethtool_link_ksettings_add_link_mode(cmd, supported, 10000baseKR_Full);
+	ethtool_link_ksettings_add_link_mode(cmd, supported, 2500baseX_Full);
 
 	if (pdata->mode == TENG_KR_MODE)
 		cmd->base.speed = SPEED_10000;
 	else if (pdata->mode == ONEG_XAUI_MODE)
 		cmd->base.speed = SPEED_1000;
+	else if (pdata->mode == TWOP5G_SGMII_MODE)
+		cmd->base.speed = SPEED_2500;
 
 	return 0;
 }
@@ -1027,13 +1061,16 @@ int xpcs_ethtool_ksettings_set(struct device *dev,
 	}
 
 	if (speed != SPEED_10000 &&
-	    speed != SPEED_1000)
+	    speed != SPEED_1000 &&
+	    speed != SPEED_2500)
 		return -EINVAL;
 
 	if (speed == SPEED_10000 && (pdata->mode != TENG_KR_MODE))
 		mode = TENG_KR_MODE;
 	else if (speed == SPEED_1000 && (pdata->mode != ONEG_XAUI_MODE))
 		mode = ONEG_XAUI_MODE;
+	else if (speed == SPEED_2500 && (pdata->mode != TWOP5G_SGMII_MODE))
+		mode = TWOP5G_SGMII_MODE;
 	else
 		return -1;
 
@@ -1179,6 +1216,9 @@ static int xpcs_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
+	/* Phy calibrate for RX Signal Adaption */
+	ret = phy_calibrate(pdata->phy);
+
 	return XPCS_SUCCESS;
 }
 
diff --git a/drivers/net/ethernet/lantiq/xpcs/xpcs.h b/drivers/net/ethernet/lantiq/xpcs/xpcs.h
index ab55a6137fa6..64bd64efd4ec 100644
--- a/drivers/net/ethernet/lantiq/xpcs/xpcs.h
+++ b/drivers/net/ethernet/lantiq/xpcs/xpcs.h
@@ -398,6 +398,9 @@
 #define PMA_RX_RATE_CTRL_RX_RATE_3_POS		12
 #define PMA_RX_RATE_CTRL_RX_RATE_3_WIDTH	2
 
+#define PMA_RX_GENCTRL1_RX_DIV16P5_CLK_EN_POS   13
+#define PMA_RX_GENCTRL1_RX_DIV16P5_CLK_EN_WIDTH 3
+
 #define PMA_TX_GENCTRL1_VBOOST_EN_0_POS		4
 #define PMA_TX_GENCTRL1_VBOOST_EN_0_WIDTH	1
 #define PMA_TX_GENCTRL1_VBOOST_LVL_POS		8
@@ -427,6 +430,8 @@
 #define PMA_MPLLA_C2_MPLLA_DIV10_CLK_EN_WIDTH	1
 #define PMA_MPLLA_C2_MPLLA_DIV8_CLK_EN_POS	8
 #define PMA_MPLLA_C2_MPLLA_DIV8_CLK_EN_WIDTH	1
+#define PMA_MPLLA_C2_MPLLA_DIV_CLK_EN_POS	7
+#define PMA_MPLLA_C2_MPLLA_DIV_CLK_EN_WIDTH	1
 
 #define PMA_MPLLB_C2_MPLLB_DIV_CLK_EN_POS	7
 #define PMA_MPLLB_C2_MPLLB_DIV_CLK_EN_WIDTH	1
@@ -447,6 +452,8 @@
 
 #define PMA_MISC_C0_RX_VREF_CTRL_POS		8
 #define PMA_MISC_C0_RX_VREF_CTRL_WIDTH		5
+#define PMA_MISC_C0_CR_PARA_SEL_POS		14
+#define PMA_MISC_C0_CR_PARA_SEL_WIDTH		1
 
 #define PMA_REF_CLK_CTRL_REF_USE_PAD_POS	1
 #define PMA_REF_CLK_CTRL_REF_USE_PAD_WIDTH	1
@@ -555,7 +562,7 @@ enum {
 	TENG_KR_MODE = 0,
 	TENG_XAUI_MODE,
 	ONEG_XAUI_MODE,
-	TWOP5G_GMII_MODE,
+	TWOP5G_SGMII_MODE,
 	MAX_XPCS_MODE,
 };
 
@@ -632,9 +639,11 @@ struct xpcs_mode_cfg {
 	u32 mplla_div165_clk_en;
 	u32 mplla_div10_clk_en;
 	u32 mplla_div8_clk_en;
+	u32 mplla_div_clk_en;
 	u32 mpllb_div_clk_en;
 	u32 mpllb_div10_clk_en;
 	u32 mpllb_div8_clk_en;
+	u32 rx_div165_clk_en;
 	u32 tx_eq_main;
 	u32 tx_eq_pre;
 	u32 tx_eq_post;
