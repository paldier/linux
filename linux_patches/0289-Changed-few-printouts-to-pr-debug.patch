From 2d15004a3fa395e519d51eb4ce6358807d337b66 Mon Sep 17 00:00:00 2001
From: thampan <joby.thampan@intel.com>
Date: Wed, 19 Sep 2018 14:10:38 +0800
Subject: [PATCH] Changed few printouts to pr_debug

---
 .../net/ethernet/lantiq/switch-api/gsw_swmcast.c   | 30 ++++++++++++----------
 1 file changed, 16 insertions(+), 14 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_swmcast.c b/drivers/net/ethernet/lantiq/switch-api/gsw_swmcast.c
index e6d0eaede913..b4133c795b55 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_swmcast.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_swmcast.c
@@ -235,10 +235,10 @@ int gsw_get_swmcast_entry(void *cdev, GSW_multicastTableRead_t *parm, u32 loc)
 		for (i = 0; i < 8; i++)
 			parm->uIP_Gsa.nIPv6[i] = pcetable.key[11 + i];
 
-                if(parm->eIPVersion == GSW_IP_SELECT_IPV4) {
-                    parm->uIP_Gda.nIPv4 = le32_to_cpu(parm->uIP_Gda.nIPv4);
-                    parm->uIP_Gsa.nIPv4 = le32_to_cpu(parm->uIP_Gsa.nIPv4);
-                }
+		if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
+			parm->uIP_Gda.nIPv4 = le32_to_cpu(parm->uIP_Gda.nIPv4);
+			parm->uIP_Gsa.nIPv4 = le32_to_cpu(parm->uIP_Gsa.nIPv4);
+		}
 
 		/* Action */
 		parm->nSubIfId = ((pcetable.val[1] >> 3) & 0x1FFF);
@@ -247,7 +247,8 @@ int gsw_get_swmcast_entry(void *cdev, GSW_multicastTableRead_t *parm, u32 loc)
 			parm->nPortMap[i] = pcetable.val[2 + i];
 		}
 
-                parm->nPortId |= 0x80000000;
+		parm->nPortId |= 0x8000;
+#ifdef __KERNEL__		
 		pr_debug("Got Loc        %d\n", loc);
 		pr_debug("Valid	         %d\n", pcetable.valid);
 		pr_debug("ExclSrcIP      %d\n", parm->bExclSrcIP);
@@ -269,9 +270,10 @@ int gsw_get_swmcast_entry(void *cdev, GSW_multicastTableRead_t *parm, u32 loc)
 		pr_debug("nPortId        %d\n", parm->nPortId);
 
 		pr_debug("ENTRY_FOUND %s:%s:%d\n", __FILE__, __func__, __LINE__);
+#endif		
 	}
 
-	return 0;
+	return pcetable.valid;
 }
 
 static int set_pce_hash_table(void *cdev, MCAST_HASHTBL *phtable, u32 loc)
@@ -344,11 +346,11 @@ int gsw_insert_hashtable_entry(void *cdev, GSW_multicastTable_t *parm)
 	if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
 		pattern.srcip.nIPv4 = cpu_to_le32(parm->uIP_Gsa.nIPv4);
 		pattern.dstip.nIPv4 = cpu_to_le32(parm->uIP_Gda.nIPv4);
-		printk("portId = %d\n parm->eIPVersion = %d\n nSubIfId = %d\n uIP_Gsa.nIPv4 = %08x\n uIP_Gda.nIPv4 = %08x\n fid = %d\n bExclSrcIP = %d\n eModeMember = %d\n", parm->nPortId, parm->eIPVersion, parm->nSubIfId, parm->uIP_Gsa.nIPv4, parm->uIP_Gda.nIPv4,
+		pr_debug("portId = %d\n parm->eIPVersion = %d\n nSubIfId = %d\n uIP_Gsa.nIPv4 = %08x\n uIP_Gda.nIPv4 = %08x\n fid = %d\n bExclSrcIP = %d\n eModeMember = %d\n", parm->nPortId, parm->eIPVersion, parm->nSubIfId, parm->uIP_Gsa.nIPv4, parm->uIP_Gda.nIPv4,
 		       parm->nFID,  parm->bExclSrcIP, parm->eModeMember);
 	} else if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
 
-		printk("portId = %d\n parm->eIPVersion = %d\n nSubIfId = %d\n fid = %d\n bExclSrcIP = %d\n eModeMember = %d\n",
+		pr_debug("portId = %d\n parm->eIPVersion = %d\n nSubIfId = %d\n fid = %d\n bExclSrcIP = %d\n eModeMember = %d\n",
 		       parm->nPortId, parm->eIPVersion, parm->nSubIfId, parm->nFID,  parm->bExclSrcIP, parm->eModeMember);
 
 		for (i = 0; i < 8; i++) {
@@ -370,7 +372,7 @@ int gsw_insert_hashtable_entry(void *cdev, GSW_multicastTable_t *parm)
 
 		/* Existing Entry Found, update the bridge portmap with the new portid and exit */
 
-		printk("Existing Entry Found, update the bridge portmap with the new portid and exit\n");
+		pr_debug("Existing Entry Found, update the bridge portmap with the new portid and exit\n");
 		table_ptr = &phtable[found_loc];
 		update_bridge_pmap(portId, table_ptr, SET);
 		set_pce_hash_table(cdev, table_ptr, found_loc);
@@ -398,14 +400,14 @@ int gsw_insert_hashtable_entry(void *cdev, GSW_multicastTable_t *parm)
 
 	/* No session yet in this hashidx, add the first entry */
 	if (ret == NO_VALID_HASHENTRY) {
-		printk("ADDING new hash idx = %x first loc %d\n", hashidx, loc);
+		pr_debug("ADDING new hash idx = %x first loc %d\n", hashidx, loc);
 		phtable[hashidx].first_idx = loc;
 		set_pce_hash_table(cdev, &phtable[hashidx], hashidx);
 	}
 	/* There is already some entry in the hash index, add new one */
 	else if (ret == MATCH_NOT_FOUND) {
 
-		printk("MATCH NOT FOUND in hash idx = %x new entry loc %d\n", hashidx, loc);
+		pr_debug("MATCH NOT FOUND in hash idx = %x new entry loc %d\n", hashidx, loc);
 
 		table_ptr = &phtable[hashidx];
 		table_ptr = &phtable[table_ptr->first_idx];
@@ -498,10 +500,10 @@ int gsw_search_hashtable_entry(void *cdev, GSW_multicastTable_t *parm, GSW_multi
 		gsw_get_swmcast_entry(cdev, read_parm, found_loc);
 	} else if (ret == NO_VALID_HASHENTRY) {
 		printk("No Valid Entry to the HASHIDX %x\n", hashidx);
-	/* There is already some entry in the hash index, add new one */
+		/* There is already some entry in the hash index, add new one */
 	} else if (ret == MATCH_NOT_FOUND) {
 		printk("MATCH_NOT_FOUND to the HASHIDX %x\n", hashidx);
-        }
+	}
 
 	return ret;
 }
@@ -559,7 +561,7 @@ static int search_hashtable_entry(u32 hashidx, MCAST_HASHTBL_PTN *pattern, u32 *
 		table_ptr = &phtable[table_ptr->nxt_idx];
 	}
 
-	printk("MATCH_NOT_FOUND %s:%s:%d\n", __FILE__, __func__, __LINE__);
+	pr_debug("MATCH_NOT_FOUND %s:%s:%d\n", __FILE__, __func__, __LINE__);
 
 	return TABLE_ERROR;
 }
