From 3e176ac46ec32e784b7d070fb0a9346f785df144 Mon Sep 17 00:00:00 2001
From: agaraix <anath.bandux.garai@intel.com>
Date: Tue, 29 Oct 2019 20:44:11 +0530
Subject: [PATCH] UGW_SW-43281 : DP MIB support for GRX interface counter.

---
 drivers/net/datapath/dpm/Kconfig                  |   6 ++
 drivers/net/datapath/dpm/datapath.h               |   1 +
 drivers/net/datapath/dpm/datapath_api.c           |  15 +++-
 drivers/net/datapath/dpm/datapath_soc.c           |   3 +
 drivers/net/datapath/dpm/gswip30/Kconfig          |   4 +-
 drivers/net/datapath/dpm/gswip30/datapath_mib.c   | 104 +++++++++++-----------
 drivers/net/datapath/dpm/gswip30/datapath_mib.h   |   2 +-
 drivers/net/datapath/dpm/gswip30/datapath_misc.h  |   4 +
 drivers/net/datapath/dpm/gswip30/datapath_rx.c    |  29 ++----
 drivers/net/ethernet/lantiq/intel_pon_hgu_vuni.c  |   2 +-
 drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c  |   2 +-
 drivers/net/ethernet/lantiq/ppa/ppa_drv_wrapper.c |   2 +-
 12 files changed, 87 insertions(+), 87 deletions(-)

diff --git a/drivers/net/datapath/dpm/Kconfig b/drivers/net/datapath/dpm/Kconfig
index e7d2409e90bb..2ee7388440a9 100644
--- a/drivers/net/datapath/dpm/Kconfig
+++ b/drivers/net/datapath/dpm/Kconfig
@@ -127,6 +127,12 @@ config INTEL_DATAPATH_CPUFREQ
 	---help---
 	  It is to support DFS(COC) in Datapath
 
+config INTEL_DATAPATH_MIB
+	bool "Datapath MIB support"
+	depends on INTEL_DATAPATH
+	---help---
+	  It is to support MIB counter in Datapath
+
 #
 # Datapath Lib
 #
diff --git a/drivers/net/datapath/dpm/datapath.h b/drivers/net/datapath/dpm/datapath.h
index 64b46428901c..b005b0974be3 100644
--- a/drivers/net/datapath/dpm/datapath.h
+++ b/drivers/net/datapath/dpm/datapath.h
@@ -873,6 +873,7 @@ extern int32_t (*qos_mgr_hook_setup_tc)(struct net_device *dev,
 #define DP_SUBIF_LIST_HASH_BIT_LENGTH 10
 #define DP_SUBIF_LIST_HASH_SIZE ((1 << DP_SUBIF_LIST_HASH_BIT_LENGTH) - 1)
 
+int dp_get_drv_mib(dp_subif_t *subif, dp_drv_mib_t *mib, uint32_t flag);
 extern struct hlist_head dp_subif_list[DP_SUBIF_LIST_HASH_SIZE];
 int32_t dp_sync_subifid(struct net_device *dev, char *subif_name,
 			dp_subif_t *subif_id, struct dp_subif_data *data,
diff --git a/drivers/net/datapath/dpm/datapath_api.c b/drivers/net/datapath/dpm/datapath_api.c
index f9a2b6822953..7acc8134a893 100644
--- a/drivers/net/datapath/dpm/datapath_api.c
+++ b/drivers/net/datapath/dpm/datapath_api.c
@@ -878,14 +878,17 @@ int32_t dp_alloc_port_ext(int inst, struct module *owner,
 {
 	int res;
 	struct dp_port_data tmp_data = {0};
+	int first = 0;
 
 	if (unlikely(!dp_init_ok)) {
 		DP_LIB_LOCK(&dp_lock);
 		if (!try_walkaround) {
-			try_walkaround = 1;
-			dp_probe(NULL); /*workaround to re-init */
+			try_walkaround++;
+			first = try_walkaround;
 		}
 		DP_LIB_UNLOCK(&dp_lock);
+		if (first == 1)
+			dp_init_module();
 		if (!dp_init_ok) {
 			pr_err("dp_alloc_port fail: datapath can't init\n");
 			return DP_FAILURE;
@@ -955,6 +958,7 @@ int32_t dp_register_dev(struct module *owner, uint32_t port_id,
 }
 EXPORT_SYMBOL(dp_register_dev);
 
+#if !IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP30)
 static int remove_umt(int inst, const struct dp_umt_port *umt)
 {
 	struct umt_ops *ops = dp_get_umt_ops(inst);
@@ -964,6 +968,7 @@ static int remove_umt(int inst, const struct dp_umt_port *umt)
 
 	return ops->umt_release(ops->umt_dev, umt->ctl.id);
 }
+#endif
 
 int32_t dp_register_dev_ext(int inst, struct module *owner, uint32_t port_id,
 			    dp_cb_t *dp_cb, struct dp_dev_data *data,
@@ -1516,9 +1521,11 @@ static int dp_register_dc(int inst, uint32_t port_id,
 			  struct dp_dev_data *data, uint32_t flags)
 {
 	struct pmac_port_info *port = get_dp_port_info(inst, port_id);
+#if !IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP30)
 	struct umt_port_res *res;
 	struct umt_ops *ops = dp_get_umt_ops(inst);
-	int i, ret;
+#endif
+	int i, ret = DP_SUCCESS;
 
 	/* Fill in the output data to the the DCDP driver for the RX rings
 	 * and Save Info for debugging
@@ -1561,7 +1568,7 @@ static int dp_register_dc(int inst, uint32_t port_id,
 	memcpy(&port->umt, data->umt, sizeof(struct dp_umt_port));
 	return ret;
 #endif
-	return DP_SUCCESS;
+	return ret;
 }
 
 /* return DP_SUCCESS -- found
diff --git a/drivers/net/datapath/dpm/datapath_soc.c b/drivers/net/datapath/dpm/datapath_soc.c
index 00e97830c59f..b97116f345a6 100644
--- a/drivers/net/datapath/dpm/datapath_soc.c
+++ b/drivers/net/datapath/dpm/datapath_soc.c
@@ -21,8 +21,11 @@
 int request_dp(u32 flag)
 {
 	struct dp_inst_info info;
+#if IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP32) || \
+	IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP31)
 	int i = 0;
 	u32 mac_ifcnt = gsw_get_mac_subifcnt(0);
+#endif
 
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP32)
 	info.type = GSWIP32_TYPE;
diff --git a/drivers/net/datapath/dpm/gswip30/Kconfig b/drivers/net/datapath/dpm/gswip30/Kconfig
index 60551dc9d4ed..585810d0a62f 100644
--- a/drivers/net/datapath/dpm/gswip30/Kconfig
+++ b/drivers/net/datapath/dpm/gswip30/Kconfig
@@ -11,15 +11,15 @@ menuconfig INTEL_DATAPATH_HAL_GSWIP30
 if INTEL_DATAPATH_HAL_GSWIP30
 config INTEL_DATAPATH_HAL_GSWIP30_MIB
 	bool "Datapath aggregated mib support"
-	depends on INTEL_DATAPATH_HAL_GSWIP30 && SOC_GRX500 && LTQ_TMU && LTQ_PPA_TMU_MIB_SUPPORT
 	default y
+	depends on INTEL_DATAPATH_HAL_GSWIP30 && SOC_GRX500 && LTQ_TMU && PPA_TMU_MIB_SUPPORT && INTEL_DATAPATH_MIB
 	---help---
 	  It is to aggregate GSWIP-L/R, TMU and driver's MIB counter
 
 config INTEL_DATAPATH_MIB_TMU_MPE_MIB
         bool "Support TMU-HAL mib API and MPE_HAL mib API"
         default n
-        depends on INTEL_DATAPATH_MIB_HAL_GSWIP30_MIB
+        depends on INTEL_DATAPATH_HAL_GSWIP30_MIB
         ---help---
           It is to provide TMU HAL mib api
 endif
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_mib.c b/drivers/net/datapath/dpm/gswip30/datapath_mib.c
index e40caa1ebab9..4fc8ee4b4ea2 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_mib.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_mib.c
@@ -26,12 +26,13 @@
 #include <net/datapath_api.h>
 #include <net/datapath_proc_api.h>
 #include "../datapath.h"
+#include "datapath_misc.h"
 #ifdef CONFIG_LTQ_TMU
 #include <net/drv_tmu_ll.h>
 #endif
-#if IS_ENABLED(CONFIG_LTQ_PPA_TMU_MIB_SUPPORT)
-#include <net/ltq_tmu_hal_api.h>
-#include <net/ltq_mpe_hal.h>
+#if IS_ENABLED(CONFIG_PPA_TMU_MIB_SUPPORT)
+#include <net/ppa/ltq_tmu_hal_api.h>
+#include <net/ppa/ltq_mpe_hal.h>
 #endif
 
 static struct gsw_itf itf_assign[] = {
@@ -142,7 +143,7 @@ struct mibs_low_lvl_port {
 	GSW_RMON_Port_cnt_t r;
 	GSW_RMON_Redirect_cnt_t redir; /*only for ethernet WAN port */
 	dp_drv_mib_t drv;
-#ifdef CONFIG_LTQ_DATAPATH_MIB_TMU_MPE_MIB
+#ifdef CONFIG_INTEL_DATAPATH_MIB_TMU_MPE_MIB
 	struct tmu_hal_qos_stats tmu_qos[MAX_SUBIF_PER_PORT];
 	struct tmu_hal_qos_stats tmu_chksum;  /*only for ethernet WAN port */
 	struct mpe_hal_if_stats mpe;
@@ -151,7 +152,7 @@ struct mibs_low_lvl_port {
 
 struct mibs_low_lvl_vap {
 	GSW_RMON_If_cnt_t gsw_if; /*for pae only(L not support interface mib)*/
-#ifdef CONFIG_LTQ_DATAPATH_MIB_TMU_MPE_MIB
+#ifdef CONFIG_INTEL_DATAPATH_MIB_TMU_MPE_MIB
 	struct tmu_hal_qos_stats tmu_qos;
 	struct mpe_hal_if_stats mpe;
 #endif
@@ -206,6 +207,8 @@ static int32_t (*mpe_hal_clear_if_m_local)(struct net_device *dev,
 					   dp_subif_t *subif_id,
 					   uint32_t flag);
 #endif
+int dp_get_port_vap_mib_30(dp_subif_t *subif, void *priv,
+			   struct rtnl_link_stats64 *net_mib, u32 flag);
 
 /*internal API: update local net mib counters periodically */
 static int update_port_mib_lower_lvl(dp_subif_t *subif, u32 flag);
@@ -219,9 +222,8 @@ static u64 wraparound(u64 curr, u64 last, u32 size)
 	if ((size > 4) || /*for 8 bytes(64bit mib),no need to do wraparound*/
 	    (curr >= last))
 		return curr - last;
-	pr_info("Wraparound happen:\n");
-	pr_info("  current mib: 0x%x\n", curr);
-	pr_info("  last    mib: 0x%x\n", last);
+	DP_DEBUG(DP_DBG_FLAG_MIB, "Wraparound happen:%s 0x%llx %s 0x%llx\n",
+		 "current mib: ", curr, "  last mib: ", last);
 	return ((u64)WRAPAROUND_MAX_32) + (u64)curr - last;
 }
 
@@ -229,10 +231,10 @@ static int port_mib_wraparound(u32 ep, struct mibs_low_lvl_port *curr,
 			       struct mibs_low_lvl_port *last)
 {
 /* RMON_PORT_WRAP: c-current, l-last x-size in bytes */
-#define RMON_PORT_WRAP(c, l, x) wraparound((c)->(x), (l)->(x), sizeof((l)->(x)))
+#define RMON_PORT_WRAP(c, l, x) wraparound((c)->x, (l)->x, sizeof((l)->x))
 	GSW_RMON_Port_cnt_t *curr_tmp;
 	GSW_RMON_Port_cnt_t *last_tmp;
-#ifdef CONFIG_LTQ_DATAPATH_MIB_TMU_MPE_MIB
+#ifdef CONFIG_INTEL_DATAPATH_MIB_TMU_MPE_MIB
 	int i;
 #endif
 
@@ -323,7 +325,7 @@ static int port_mib_wraparound(u32 ep, struct mibs_low_lvl_port *curr,
 		return 0;
 	}
 
-#ifdef CONFIG_LTQ_DATAPATH_MIB_TMU_MPE_MIB
+#ifdef CONFIG_INTEL_DATAPATH_MIB_TMU_MPE_MIB
 	/*TMU drop counters */
 	for (i = 0; i < MAX_SUBIF_PER_PORT; i++)
 		aggregate_mib[ep].curr.tx_tmu_drop_pkts +=
@@ -392,21 +394,13 @@ static int vap_mib_wraparound(dp_subif_t *subif,
 			      struct mibs_low_lvl_vap *curr,
 			      struct mibs_low_lvl_vap *last)
 {
-#define VAP_RMON_WRAP_ITF(c, l, x) do { \
-	wrapar((c)->gsw_if.x, (l)->gsw_if.x, sizeof((l)->gsw_if.x)) \
-} while (0)
-#define VAP_RMON_WRAP_TMU(c, l, x) do { \
-	wrapar((c)->tmu_qos.x, (l)->tmu_qos.x, sizeof((l)->tmu_qos.x)) \
-} while (0)
-#define VAP_RMON_WRAP_MPE(c, l, x) do { \
-	wrapar((c)->mpe.x, (l)->mpe.x, sizeof((l)->mpe.x)) \
-} while (0)
-#define VAP_RMON_WRAP_DRV(c, l, x) do { \
-	wrapar((c)->drv.x, (l)->drv.x, sizeof((l)->drv.x)) \
-} while (0)
+#define VAP_RMON_WRAP_ITF(c, l, x) wraparound((c)->gsw_if.x, (l)->gsw_if.x, sizeof((l)->gsw_if.x))
+#define VAP_RMON_WRAP_TMU(c, l, x) wraparound((c)->tmu_qos.x, (l)->tmu_qos.x, sizeof((l)->tmu_qos.x))
+#define VAP_RMON_WRAP_MPE(c, l, x) wraparound((c)->mpe.x, (l)->mpe.x, sizeof((l)->mpe.x))
+#define VAP_RMON_WRAP_DRV(c, l, x) wraparound((c)->drv.x, (l)->drv.x, sizeof((l)->drv.x))
 
 	int ep = subif->port_id;
-	struct dp_port_info *pi = get_dp_port_info(0, subif->port_id);
+	struct pmac_port_info *pi = get_dp_port_info(0, subif->port_id);
 	int vap = GET_VAP(subif->subif, pi->vap_offset, pi->vap_mask);
 
 	if ((ep <= 0) ||
@@ -424,7 +418,7 @@ static int vap_mib_wraparound(dp_subif_t *subif,
 	    VAP_RMON_WRAP_ITF(curr, last, nTxPktsCount);
 	aggregate_mib[ep].curr_vap[vap].tx_disc_pkts_itf +=
 	    VAP_RMON_WRAP_ITF(curr, last, nTxDiscPktsCount);
-#ifdef CONFIG_LTQ_DATAPATH_MIB_TMU_MPE_MIB
+#ifdef CONFIG_INTEL_DATAPATH_MIB_TMU_MPE_MIB
 	aggregate_mib[ep].curr_vap[vap].tx_disc_pkts_tmu +=
 	    VAP_RMON_WRAP_TMU(curr, last, dropPkts);
 	aggregate_mib[ep].curr_vap[vap].tx_disc_pkts_mpe +=
@@ -438,10 +432,11 @@ static int vap_mib_wraparound(dp_subif_t *subif,
 	return 0;
 }
 
-static int get_gsw_port_rmon(u32 ep, char *gsw_drv_name,
+static int get_gsw_port_rmon(u32 ep, int index,
 			     GSW_RMON_Port_cnt_t *mib)
 {
 	GSW_return_t ret;
+	struct core_ops *gsw_handle;
 
 	if (!mib) {
 		pr_err("why mib pointer is %p\n", mib);
@@ -451,10 +446,11 @@ static int get_gsw_port_rmon(u32 ep, char *gsw_drv_name,
 		return -1;
 	memset(mib, 0, sizeof(*mib));
 	mib->nPortId = ep;
-	ret = dp_port_prop[0].ops[index]->gsw_rmon_ops.RMON_Port_Get(dp_port_prop[0].ops[index], mib);
+	gsw_handle = dp_port_prop[0].ops[index];
+	ret = gsw_handle->gsw_rmon_ops.RMON_Port_Get(gsw_handle, mib);
 	if (ret) {
-		pr_err("GSW_RMON_PORT_GET failed(%d) from %s for port %d\n",
-		       ret, gsw_drv_name, ep);
+		pr_err("GSW_RMON_PORT_GET failed(%d) for port %d\n",
+		       ret, ep);
 		return -1;
 	}
 
@@ -465,6 +461,7 @@ static int get_gsw_redirect_rmon(u32 ep, int index,
 				 GSW_RMON_Redirect_cnt_t *mib)
 {
 	GSW_return_t ret;
+	struct core_ops *gsw_handle;
 
 	if (!mib) {
 		pr_err("why mib pointer is %p\n", mib);
@@ -472,31 +469,33 @@ static int get_gsw_redirect_rmon(u32 ep, int index,
 	}
 
 	memset(mib, 0, sizeof(*mib));
-	ret = dp_port_prop[0].ops[index]->gsw_rmon_ops.RMON_Redirect_Get(dp_port_prop[0].ops[index], mib);
+	gsw_handle = dp_port_prop[0].ops[index];
+	ret = gsw_handle->gsw_rmon_ops.RMON_Redirect_Get(gsw_handle, mib);
 	if (ret) {
-		pr_err("GSW_RMON_REDIRECT_GET failed from %s\n",
-		       gsw_drv_name);
+		pr_err("GSW_RMON_REDIRECT_GET failed\n");
 		return -1;
 	}
 
 	return 0;
 }
 
-static int get_gsw_itf_rmon(u32 index, int index,
+static int get_gsw_itf_rmon(u32 itf_index, int index,
 			    GSW_RMON_If_cnt_t *mib)
 {
 	GSW_return_t ret;
+	struct core_ops *gsw_handle;
 
 	if (!mib) {
 		pr_err("why mib pointer is %p\n", mib);
 		return -1;
 	}
 	memset(mib, 0, sizeof(*mib));
-	mib->nIfId = index;
-	ret = dp_port_prop[0].ops[index]->gsw_rmon_ops.RMON_If_Get(dp_port_prop[0].ops[index], mib);
+	mib->nIfId = itf_index;
+	gsw_handle = dp_port_prop[0].ops[index];
+	ret = gsw_handle->gsw_rmon_ops.RMON_If_Get(gsw_handle, mib);
 	if (ret) {
-		pr_err("GSW_RMON_PORT_GET GSW_RMON_IF_GET from %s: index %d\n",
-		       gsw_drv_name, index);
+		pr_err
+		    ("GSW_RMON_PORT_GET GSW_RMON_IF_GET for index %d\n", index);
 		return -1;
 	}
 	return 0;
@@ -531,7 +530,7 @@ int gsw_eth_wan_redirect_status(void)
 	struct qos_ops *gsw_qos;
 	#define MAX_CLASS_NUM 16
 
-	gsw_handle = dp_port_prop[inst].ops[1];
+	gsw_handle = dp_port_prop[0].ops[1];
 	gsw_qos = &gsw_handle->gsw_qos_ops;
 	memset(&q_cfg, 0, sizeof(q_cfg));
 	q_cfg.nPortId = WAN_EP;
@@ -541,7 +540,7 @@ int gsw_eth_wan_redirect_status(void)
 		if (ret) {
 			pr_err("%s failed(%d) from %s for port %d\n",
 			       "GSW_QOS_QUEUE_PORT_GET",
-			       ret, GSWIP_R, WAN_EP);
+			       ret, "GSWIP_R", WAN_EP);
 			return -1;
 		}
 		if (q_cfg.nRedirectPortId == 0)
@@ -685,7 +684,7 @@ static int update_port_mib_lower_lvl(dp_subif_t *subif, u32 flag)
 static void mib_wraparound_timer_poll(unsigned long data)
 {
 	int i;
-	dp_subif_t subif;
+	dp_subif_t subif = {0};
 #define START_PORT_ID 0
 	/*start from port 1, not 0 since 0 is no device registered*/
 	static int port = START_PORT_ID;
@@ -697,7 +696,7 @@ static void mib_wraparound_timer_poll(unsigned long data)
 	/* update vap if necessary */
 	if (port) {
 		for (i = 0; i < MAX_SUBIF_PER_PORT; i++) {
-			struct dp_port_info *pi = get_dp_port_info(0, port);
+			struct pmac_port_info *pi = get_dp_port_info(0, port);
 
 			subif.subif = SET_VAP(i, pi->vap_offset, pi->vap_mask);
 			/* update sub-interface/vap mib only */
@@ -723,7 +722,7 @@ static int update_vap_mib_lower_lvl(dp_subif_t *subif, u32 flag)
 	int itf_base;
 	struct mibs_low_lvl_vap *curr;
 	int port_id;
-	struct dp_port_info *pi;
+	struct pmac_port_info *pi;
 
 	/*update struct pmac_port_info[subif->ep].net_mib */
 	if (!subif || (subif->port_id <= 0) || (subif->port_id >= PMAC_MAX_NUM))
@@ -767,7 +766,7 @@ static int update_vap_mib_lower_lvl(dp_subif_t *subif, u32 flag)
 					      &curr->tmu_qos, 0);
 		if (ret) {
 			curr->tmu_qos = last_vap[port_id][vap].tmu_qos;
-			pr_err("%s failed for port.vap(%d.%d):%d\n",
+			DP_DEBUG(DP_DBG_FLAG_MIB, "%s failed for port.vap(%d.%d):%d\n",
 			       "tmu_hal_get_qos_mib_hook_fn",
 			       port_id, vap, ret);
 		}
@@ -842,7 +841,6 @@ static unsigned int proc_mib_port_start_id = 1;
 static unsigned int proc_mib_port_end_id = PMAC_MAX_NUM - 1;
 int proc_mib_inside_dump(struct seq_file *s, int pos)
 {
-	int ret;
 	dp_subif_t subif;
 	struct rtnl_link_stats64 net_mib;
 
@@ -900,7 +898,7 @@ int proc_mib_inside_dump(struct seq_file *s, int pos)
 		   last[pos].redir.nTxPktsCount);
 	seq_printf(s, "  %-45s=%40u\n", "last.redir.nTxDiscPktsCount",
 		   last[pos].redir.nTxDiscPktsCount);
-#ifdef CONFIG_LTQ_DATAPATH_MIB_TMU_MPE_MIB
+#ifdef CONFIG_INTEL_DATAPATH_MIB_TMU_MPE_MIB
 	/*checksum */
 	seq_printf(s, "  %-45s=%40llu\n", "last.tmu_chksum.deqPkts",
 		   last[pos].tmu_chksum.deqPkts);
@@ -1037,7 +1035,7 @@ ssize_t proc_mib_inside_write(struct file *file, const char *buf,
 int dp_get_port_vap_mib_30(dp_subif_t *subif, void *priv,
 			   struct rtnl_link_stats64 *net_mib, u32 flag)
 {
-	dp_subif_t tmp_subif;
+	dp_subif_t tmp_subif = {0};
 	unsigned int port_id, vap;
 	struct pmac_port_info *port_info;
 
@@ -1554,7 +1552,7 @@ int clear_gsw_itf_mib(dp_subif_t *subif, u32 flag)
 	struct pmac_port_info *port_info;
 	struct core_ops *gsw_handle;
 
-	gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
+	gsw_handle = dp_port_prop[0].ops[GSWIP_R];
 	if (!(flag & DP_F_STATS_SUBIF))
 		return 0;
 	if (!subif) { /* clear all */
@@ -1596,10 +1594,10 @@ int dp_clear_netif_mib_30(dp_subif_t *subif, void *priv, u32 flag)
 	int i;
 	dp_subif_t tmp_subif;
 	struct core_ops *gsw_l, *gsw_r;
-	struct dp_port_info *pi;
+	struct pmac_port_info *pi;
 
-	gsw_l = dp_port_prop[inst].ops[GSWIP_L];
-	gsw_r = dp_port_prop[inst].ops[GSWIP_R];
+	gsw_l = dp_port_prop[0].ops[GSWIP_L];
+	gsw_r = dp_port_prop[0].ops[GSWIP_R];
 
 	if (!subif) { /*clear all */
 		spin_lock_bh(&dp_mib_lock);
@@ -1704,7 +1702,7 @@ int dp_clear_netif_mib_30(dp_subif_t *subif, void *priv, u32 flag)
 		/*reset GSWIP-L/R rmon counters */
 		rmon.eRmonType = GSW_RMON_PORT_TYPE;
 		rmon.nRmonId = port_id;
-		gsw_l->gsw_rmon_ops.RMON_Clear(gsw_r, &rmon);
+		gsw_l->gsw_rmon_ops.RMON_Clear(gsw_l, &rmon);
 		gsw_r->gsw_rmon_ops.RMON_Clear(gsw_r, &rmon);
 	} else {		/*port 7 ~ 14 */
 		rmon.eRmonType = GSW_RMON_PORT_TYPE;
@@ -1955,7 +1953,7 @@ ssize_t proc_mib_port_write(struct file *file, const char *buf, size_t count,
 int proc_mib_vap_dump(struct seq_file *s, int pos)
 {
 	int j = 0;
-	int ret = 0, f_newline = 0;
+	int f_newline = 0;
 	dp_subif_t subif;
 	struct rtnl_link_stats64 stats_mib;
 	int itf_base;
@@ -2068,7 +2066,7 @@ int set_gsw_itf(u8 ep, u8 ena, int start)
 	GSW_portCfg_t port_cfg;
 	struct core_ops *gsw_r;
 
-	gsw_r = dp_port_prop[inst].ops[GSWIP_R];
+	gsw_r = dp_port_prop[0].ops[GSWIP_R];
 
 	if (ep >= PMAC_MAX_NUM)
 		return -1;
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_mib.h b/drivers/net/datapath/dpm/gswip30/datapath_mib.h
index dc4dc4e81350..148a237fdd15 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_mib.h
+++ b/drivers/net/datapath/dpm/gswip30/datapath_mib.h
@@ -16,5 +16,5 @@ struct gsw_itf *get_free_itf(u8 ep, u32 flag);
 int reset_gsw_itf(u8 ep);
 int dp_get_port_vap_mib_30(dp_subif_t *subif, void *priv,
 			   struct rtnl_link_stats64 *net_mib, u32 flag);
-
+int dp_clear_netif_mib_30(dp_subif_t *subif, void *priv, u32 flag);
 #endif
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_misc.h b/drivers/net/datapath/dpm/gswip30/datapath_misc.h
index 40016a2c6534..45fcb4cb2d9f 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_misc.h
+++ b/drivers/net/datapath/dpm/gswip30/datapath_misc.h
@@ -86,6 +86,10 @@ void proc_coc_read_30(struct seq_file *s);
 ssize_t proc_coc_write_30(struct file *file, const char *buf, size_t count,
 			  loff_t *ppos);
 #endif
+#if IS_ENABLED(CONFIG_INTEL_DATAPATH_MIB)
+int dp_reset_sys_mib(u32 flag);
+int dp_mib_init(u32 flag);
+#endif
 
 #endif
 
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_rx.c b/drivers/net/datapath/dpm/gswip30/datapath_rx.c
index 197dffebc291..27107b0c2987 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_rx.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_rx.c
@@ -86,7 +86,7 @@ static int dp_handle_lct(struct pmac_port_info *dp_port,
 	struct sk_buff *lct_skb;
 	struct dp_subif_info *sif;
 	struct dev_mib *mib;
-	int vap, ret;
+	int vap;
 
 	vap = dp_port->lct_idx;
 	sif = get_dp_port_subif(dp_port, vap);
@@ -106,16 +106,15 @@ static int dp_handle_lct(struct pmac_port_info *dp_port,
 		}
 		lct_skb->dev = sif->netif;
 		UP_STATS(mib->rx_fn_rxif_pkt);
-		DP_DEBUG(DP_DBG_FLAG_PAE, "pkt sent lct(%s) ret(%d)\n",
-			 lct_skb->dev->name ? lct_skb->dev->name : "NULL",
-			 ret);
+		DP_DEBUG(DP_DBG_FLAG_PAE, "pkt sent lct(%s)\n",
+			 lct_skb->dev->name ? lct_skb->dev->name : "NULL");
 		rx_fn(lct_skb->dev, NULL, lct_skb, lct_skb->len);
 		return 1;
 	} else if (memcmp(skb->data + PMAC_SIZE, skb->dev->dev_addr, 6) == 0) {
 		/* unicast */
 		DP_DEBUG(DP_DBG_FLAG_PAE, "LCT unicast\n");
-		DP_DEBUG(DP_DBG_FLAG_PAE, "unicast pkt sent lct(%s) ret(%d)\n",
-			 skb->dev->name ? skb->dev->name : "NULL", ret);
+		DP_DEBUG(DP_DBG_FLAG_PAE, "unicast pkt sent lct(%s)\n",
+			 skb->dev->name ? skb->dev->name : "NULL");
 		if ((STATS_GET(sif->rx_flag) <= 0)) {
 			UP_STATS(mib->rx_fn_dropped);
 			dev_kfree_skb_any(skb);
@@ -147,7 +146,6 @@ int32_t dp_rx_30(struct sk_buff *skb, u32 flags)
 	char decryp = 0;
 	u8 inst = 0;
 	struct pmac_port_info *dp_port;
-	struct mac_ops *ops;
 	int ret_lct = 1;
 	struct dp_subif_info *sif;
 	struct dev_mib *mib;
@@ -210,23 +208,6 @@ int32_t dp_rx_30(struct sk_buff *skb, u32 flags)
 	dp_port = get_dp_port_info(inst, port_id);
 	sif = get_dp_port_subif(dp_port, vap);
 	mib = get_dp_port_subif_mib(sif);
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_PTP1588)
-	if (dp_port->f_ptp) {
-		ops = dp_port_prop[inst].mac_ops[port_id];
-		if (ops)
-			ops->do_rx_hwts(ops, skb);
-	}
-#endif
-	/*PON traffic always have timestamp attached,removing Timestamp */
-	if (dp_port->alloc_flags & (DP_F_GPON | DP_F_EPON)) {
-		/* Stripping of last 10 bytes timestamp */
-#if IS_ENABLED(CONFIG_INTEL_DATAPATH_PTP1588)
-		if (!dp_port->f_ptp)
-			__pskb_trim(skb, skb->len - DP_TS_HDRLEN);
-#else
-		__pskb_trim(skb, skb->len - DP_TS_HDRLEN);
-#endif
-	}
 
 	rx_fn = dp_port->cb.rx_fn;
 	if (likely(rx_fn && dp_port->status)) {
diff --git a/drivers/net/ethernet/lantiq/intel_pon_hgu_vuni.c b/drivers/net/ethernet/lantiq/intel_pon_hgu_vuni.c
index 99e907229206..ae7e9cf4aa5e 100644
--- a/drivers/net/ethernet/lantiq/intel_pon_hgu_vuni.c
+++ b/drivers/net/ethernet/lantiq/intel_pon_hgu_vuni.c
@@ -260,7 +260,7 @@ static struct
 rtnl_link_stats64 *vuni_get_stats(struct net_device *dev,
 				  struct rtnl_link_stats64 *storage)
 {
-#ifndef CONFIG_LTQ_DATAPATH_MIB
+#ifndef CONFIG_INTEL_DATAPATH_MIB
 	struct intel_vuni_priv *priv = netdev_priv(dev);
 	*storage = priv->stats;
 #else
diff --git a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
index d90fe26f9cb5..564a69140576 100644
--- a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
+++ b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
@@ -622,7 +622,7 @@ static struct
 rtnl_link_stats64 *ltq_get_stats(struct net_device *dev,
 				 struct rtnl_link_stats64 *storage)
 {
-#ifndef CONFIG_LTQ_DATAPATH_MIB
+#ifndef CONFIG_INTEL_DATAPATH_MIB
 	struct ltq_eth_priv *priv = netdev_priv(dev);
 	*storage = priv->stats;
 #else
diff --git a/drivers/net/ethernet/lantiq/ppa/ppa_drv_wrapper.c b/drivers/net/ethernet/lantiq/ppa/ppa_drv_wrapper.c
index 5ed7111d8ad8..a766edd3a0c1 100644
--- a/drivers/net/ethernet/lantiq/ppa/ppa_drv_wrapper.c
+++ b/drivers/net/ethernet/lantiq/ppa/ppa_drv_wrapper.c
@@ -115,7 +115,7 @@ int32_t (*mpe_hal_feature_start_fn)(
 		uint32_t flags) = NULL;
 EXPORT_SYMBOL(mpe_hal_feature_start_fn);
 
-#ifdef CONFIG_LTQ_DATAPATH_DUMMY_MPE_MIB
+#ifdef CONFIG_INTEL_DATAPATH_MIB_TMU_MPE_MIB
 int32_t (*mpe_hal_get_netif_mib_hook_fn) (struct net_device *dev,
 		dp_subif_t *subif_id, struct mpe_hal_if_stats *mpe_mib,
 		uint32_t flag) = NULL;
