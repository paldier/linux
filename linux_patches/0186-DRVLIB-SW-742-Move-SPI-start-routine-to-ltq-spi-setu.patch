From 6452a7c341038d6849b098c862ac2ab40bfef3d4 Mon Sep 17 00:00:00 2001
From: Peter Harliman Liem <peter.harliman.liem@intel.com>
Date: Wed, 25 Jul 2018 14:57:14 +0800
Subject: [PATCH] DRVLIB_SW-742 - Move SPI start routine to
 ltq_spi_setup_transfer

If we use GPIO CS, ltq_spi_chipselect() function will
never get called. Hence SPI start routine must be moved to
ltq_spi_setup_transfer().
---
 drivers/spi/spi-grx500.c | 47 +++++++++++++++++++++++++++++++++--------------
 1 file changed, 33 insertions(+), 14 deletions(-)

diff --git a/drivers/spi/spi-grx500.c b/drivers/spi/spi-grx500.c
index 7db5fe078245..0637fa066fde 100644
--- a/drivers/spi/spi-grx500.c
+++ b/drivers/spi/spi-grx500.c
@@ -21,6 +21,7 @@
 #include <linux/spinlock.h>
 #include <linux/err.h>
 #include <linux/clk.h>
+#include <linux/gpio.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/spi_bitbang.h>
 #include <linux/of_irq.h>
@@ -175,7 +176,9 @@ struct ltq_spi {
 	u32			len;
 	struct spi_transfer	*curr_transfer;
 
-	u32			bytes_per_word;
+	u32			bits_per_word;
+	u32			speed_hz;
+	u32			mode;
 
 	u16			txfs;
 	u16			rxfs;
@@ -400,13 +403,6 @@ static void ltq_spi_bits_per_word_set(struct spi_device *spi)
 //		if (hw->curr_transfer->bits_per_word <= 32)
 //			bits_per_word = hw->curr_transfer->bits_per_word;
 
-	if (spi->bits_per_word <= 8)
-		hw->bytes_per_word = 1;
-	else if (spi->bits_per_word <= 16)
-		hw->bytes_per_word = 2;
-	else if (spi->bits_per_word <= 32)
-		hw->bytes_per_word = 4;
-
 	/* CON.BM value = bits_per_word - 1 */
 	bm = (spi->bits_per_word - 1) << LTQ_SPI_CON_BM_SHIFT;
 
@@ -547,16 +543,11 @@ static void ltq_spi_chipselect(struct spi_device *spi, int cs)
 
 	switch (cs) {
 	case BITBANG_CS_ACTIVE:
-		ltq_spi_bits_per_word_set(spi);
-		ltq_spi_speed_set(spi);
-		ltq_spi_clockmode_set(spi);
-		ltq_spi_run_mode_set(hw);
 		ltq_spi_internal_cs_activate(spi);
 		break;
 
 	case BITBANG_CS_INACTIVE:
 		ltq_spi_internal_cs_deactivate(spi);
-		ltq_spi_config_mode_set(hw);
 		break;
 	}
 }
@@ -582,6 +573,20 @@ static int ltq_spi_setup_transfer(struct spi_device *spi,
 	if (speed_hz > spi->max_speed_hz)
 		return -EINVAL;
 
+	if (hw->bits_per_word != bits_per_word ||
+	    hw->speed_hz != speed_hz ||
+	    hw->mode != spi->mode) {
+		ltq_spi_config_mode_set(hw);
+		ltq_spi_bits_per_word_set(spi);
+		ltq_spi_speed_set(spi);
+		ltq_spi_clockmode_set(spi);
+		ltq_spi_run_mode_set(hw);
+
+		hw->bits_per_word = bits_per_word;
+		hw->speed_hz = speed_hz;
+		hw->mode = spi->mode;
+	}
+
 	return 0;
 }
 
@@ -597,6 +602,10 @@ static int ltq_spi_setup(struct spi_device *spi)
 	if (spi->bits_per_word > 32)
 		return -EINVAL;
 
+	/* GPIOs are used for CS */
+	if (gpio_is_valid(spi->cs_gpio))
+		return 0;
+
 	/*
 	 * Up to six GPIOs can be connected to the SPI module
 	 * via GPIO alternate function to control the chip select lines.
@@ -617,13 +626,16 @@ static int ltq_spi_setup(struct spi_device *spi)
 
 static void ltq_spi_cleanup(struct spi_device *spi)
 {
+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
 
+	ltq_spi_config_mode_set(hw);
 }
 
 static void ltq_spi_txfifo_write(struct ltq_spi *hw)
 {
 	u32 fstat, data;
 	u16 fifo_space;
+	u32 bytes_per_word;
 
 	/* Determine how much FIFOs are free for TX data */
 	fstat = ltq_spi_reg_read(hw, LTQ_SPI_FSTAT);
@@ -633,8 +645,15 @@ static void ltq_spi_txfifo_write(struct ltq_spi *hw)
 	if (!fifo_space)
 		return;
 
+	if (hw->bits_per_word <= 8)
+		bytes_per_word = 1;
+	else if (hw->bits_per_word <= 16)
+		bytes_per_word = 2;
+	else if (hw->bits_per_word <= 32)
+		bytes_per_word = 4;
+
 	while (hw->tx_cnt < hw->len && fifo_space) {
-		data = ltq_spi_tx_word(hw, hw->bytes_per_word);
+		data = ltq_spi_tx_word(hw, bytes_per_word);
 		ltq_spi_reg_write(hw, data, LTQ_SPI_TB);
 		fifo_space--;
 	}
