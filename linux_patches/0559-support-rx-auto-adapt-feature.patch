From 0fc89f5e7f7b0a13ce82b739d52da0be9c08a3e1 Mon Sep 17 00:00:00 2001
From: Wu Zhixian <zhixianx.wu@intel.com>
Date: Thu, 11 Apr 2019 17:55:28 +0800
Subject: [PATCH] support rx auto adapt feature

Fix comments
this was backported from the mainline kernel commit: http://git.kernel.org/linus/36914111e6829be36b23d1109214250b5ee1ee9c
support rx auto adapt feature
For combophy auto adaaption, phy calibrate feature.
Jira ticket:
https://jira-chd.intel.com/browse/DRVLIB_SW-1183

fix comments

if auto adapt fail, run one more time

fix comments

fix comments for jira:https://gts-chd.intel.com/projects/SW_UGW/repos/linux/pull-requests/663/overview
---
 drivers/net/ethernet/lantiq/xpcs/xpcs.c |   2 +
 drivers/phy/intel/phy-intel-combo.c     | 128 ++++++++++++++++++++++++++++++++
 drivers/phy/phy-core.c                  |  15 ++++
 include/linux/phy/phy.h                 |  10 +++
 4 files changed, 155 insertions(+)

diff --git a/drivers/net/ethernet/lantiq/xpcs/xpcs.c b/drivers/net/ethernet/lantiq/xpcs/xpcs.c
index 832516c26b2f..586673fb63be 100644
--- a/drivers/net/ethernet/lantiq/xpcs/xpcs.c
+++ b/drivers/net/ethernet/lantiq/xpcs/xpcs.c
@@ -1089,6 +1089,8 @@ int xpcs_reinit(struct device *dev, u32 mode)
 		return ret;
 	}
 
+	ret = phy_calibrate(phy);
+
 	return ret;
 }
 
diff --git a/drivers/phy/intel/phy-intel-combo.c b/drivers/phy/intel/phy-intel-combo.c
index 5f78749202d6..2f46fd6369b6 100644
--- a/drivers/phy/intel/phy-intel-combo.c
+++ b/drivers/phy/intel/phy-intel-combo.c
@@ -7,6 +7,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/iopoll.h>
 #include <linux/clk.h>
 #include <linux/of_address.h>
 #include <linux/of_pci.h>
@@ -32,12 +33,20 @@
 #define COMBO_PHY_ID(x)	((x)->parent->id)
 #define PHY_ID(x)	((x)->id)
 
+#define PHY_RXADAPT_POLL_CNT	5000
+#define RAWLANEN_RX_OV_IN_3		0x3008
+#define LANEN_RX_ADPT_ATT_STAT			0x106B
+#define LANEN_RX_ADPT_VGA_STAT			0x106C
+#define LANEN_RX_ADPT_CTLE_STAT		0x106D
+#define LANEN_RX_ADPT_DFETAP1_STAT	0x106E
+
 static const char * const intel_phy_names[] = {"pcie", "xpcs", "sata"};
 
 static int intel_combo_phy_init(struct phy *phy);
 static int intel_combo_phy_exit(struct phy *phy);
 static int intel_combo_phy_power_on(struct phy *phy);
 static int intel_combo_phy_power_off(struct phy *phy);
+static int intel_combo_phy_calibrate(struct phy *phy);
 
 enum {
 	PHY_0 = 0,
@@ -52,6 +61,11 @@ enum intel_phy_mode {
 	PHY_MAX_MODE
 };
 
+struct intel_phy_calibrate{
+	u32 resv:31;
+	u32 rx_auto_adapt:1;
+};
+
 enum combo_phy_mode {
 	PCIE0_PCIE1_MODE = 0,
 	PCIE_DL_MODE, /* PCIe dual lane */
@@ -88,6 +102,7 @@ struct phy_ctx {
 	bool enable;
 	struct intel_combo_phy *parent;
 	enum intel_phy_mode phy_mode;
+	struct intel_phy_calibrate calibrate;
 	bool power_en;
 	enum intel_phy_role phy_role;
 	struct phy *phy;
@@ -134,6 +149,7 @@ static const struct phy_ops intel_cbphy_ops = {
 	.exit = intel_combo_phy_exit,
 	.power_on = intel_combo_phy_power_on,
 	.power_off = intel_combo_phy_power_off,
+	.calibrate = intel_combo_phy_calibrate,
 };
 
 static ssize_t
@@ -361,6 +377,103 @@ static int intel_pcie_set_clk_src(struct phy_ctx *iphy)
 	return 0;
 }
 
+static int phy_rxeq_autoadapt(struct phy *phy)
+{
+	struct phy_ctx *iphy;
+	int i, err;
+	u32 val;
+	struct device *dev;
+
+	iphy = phy_get_drvdata(phy);
+	dev = iphy->dev;
+	/* RAWLANEN_RX_OV_IN_3 */
+	/* 15		CONT_OVRD_EN = 0
+	 * 14		OFFCAN_CONT = 0
+	 * 13		ADAPT_CONT = 0
+	 * 12		ADAPT_REQ_OVRD_EN = 0
+	 * 11		ADAPT_REQ = 0
+	 * 10		REF_LD_VAL_OVRD_EN = 0
+	 * 9:4		REF_LD_VAL_OVRD = 0
+	 * 3		RX_LOS_THRSHLD_OVRD_EN = 0
+	 * 2:0		RX_LOS_THRSHLD_OVRD_VAL = 0
+	 */
+	/* ADAPT_REQ Bit 11 and ADAPT_REQ_OVRD_EN Bit 12 */
+	combo_phy_reg_bit_clr(iphy->cr_base, 11,
+		(RAWLANEN_RX_OV_IN_3 << 2));
+	combo_phy_reg_bit_clr(iphy->cr_base, 12,
+		(RAWLANEN_RX_OV_IN_3 << 2));
+	/* ADAPT_REQ and ADAPT_REQ_OVRD_EN set to '11' */
+	combo_phy_reg_bit_set(iphy->cr_base, 11,
+		(RAWLANEN_RX_OV_IN_3 << 2));
+	combo_phy_reg_bit_set(iphy->cr_base, 12,
+		(RAWLANEN_RX_OV_IN_3 << 2));
+
+	/* Check for RX Adaptation is done
+	 * RAWLANEN_DIG_AON_RX_ADAPT_DONE.RX_ADAPT_DONE[0]
+	 */
+	err = readl_poll_timeout(iphy->cr_base +
+		(RAWLANEN_RX_OV_IN_3 << 2), val, (!!(val & BIT(0))),
+		5, 5 * PHY_RXADAPT_POLL_CNT);
+	/* if auto adapt fail, run auto adapt one more time */
+	if (IS_ERR(err)) {
+		/* ADAPT_REQ Bit 11 and ADAPT_REQ_OVRD_EN Bit 12 */
+		combo_phy_reg_bit_clr(iphy->cr_base, 11,
+			(RAWLANEN_RX_OV_IN_3 << 2));
+		combo_phy_reg_bit_clr(iphy->cr_base, 12,
+			(RAWLANEN_RX_OV_IN_3 << 2));
+		/* ADAPT_REQ and ADAPT_REQ_OVRD_EN set to '11' */
+		combo_phy_reg_bit_set(iphy->cr_base, 11,
+			(RAWLANEN_RX_OV_IN_3 << 2));
+		combo_phy_reg_bit_set(iphy->cr_base, 12,
+			(RAWLANEN_RX_OV_IN_3 << 2));
+
+		/* Check for RX Adaptation is done
+		 * RAWLANEN_DIG_AON_RX_ADAPT_DONE.RX_ADAPT_DONE[0]
+		 */
+		err = readl_poll_timeout(iphy->cr_base +
+			(RAWLANEN_RX_OV_IN_3 << 2), val, (!!(val & BIT(0))),
+			5, 5 * PHY_RXADAPT_POLL_CNT);
+	}
+	combo_phy_reg_bit_clr(iphy->cr_base, 11, (RAWLANEN_RX_OV_IN_3 << 2));
+	combo_phy_reg_bit_set(iphy->cr_base, 12, (RAWLANEN_RX_OV_IN_3 << 2));
+	/* Stop RX Adaptation */
+	combo_phy_w32(iphy->cr_base, 0x0, (RAWLANEN_RX_OV_IN_3 << 2));
+	dev_dbg(dev, "RX Adaptation Turn off after done:\n");
+	dev_dbg(dev, "RAWLANEN_RX_OV_IN_3 (0x%08x) = 0x%08x\n",
+		(iphy->cr_base + (RAWLANEN_RX_OV_IN_3 << 2)),
+		combo_phy_r32(iphy->cr_base, (RAWLANEN_RX_OV_IN_3 << 2)));
+
+	/* Display RX Adapt Value in PMA */
+	dev_dbg(dev, "\nRead back on RX Adapted Value\n");
+	/* LANEN_RX_ADPT_ATT_STAT ATT Adaptation code */
+	dev_dbg(dev, "LANEN_RX_ADPT_ATT_STAT [ (0x%08x) = 0x%08x\n",
+		(iphy->cr_base + (LANEN_RX_ADPT_ATT_STAT << 2)),
+		combo_phy_r32(iphy->cr_base, (LANEN_RX_ADPT_ATT_STAT << 2)));
+
+	/* LANEN_RX_ADPT_VGA_STAT VGA Adaptation code */
+	dev_dbg(dev, "LANEN_RX_ADPT_VGA_STAT [ (0x%08x) = 0x%08x\n",
+		(iphy->cr_base + (LANEN_RX_ADPT_VGA_STAT << 2)),
+		combo_phy_r32(iphy->cr_base, (LANEN_RX_ADPT_VGA_STAT << 2)));
+
+	/* LANEN_RX_ADPT_CTLE_STAT CTLE Adaptation code */
+	dev_dbg(dev, "LANEN_RX_ADPT_CTLE_STAT [ (0x%08x) = 0x%08x\n",
+		(iphy->cr_base + (LANEN_RX_ADPT_CTLE_STAT << 2)),
+		combo_phy_r32(iphy->cr_base, (LANEN_RX_ADPT_CTLE_STAT << 2)));
+
+	/* LANEN_RX_ADPT_DFETAP1_STAT DFE Tap1 Adaptation code */
+	dev_dbg(dev, "LANEN_RX_ADPT_DFETAP1_STAT [ (0x%08x) = 0x%08x\n",
+		(iphy->cr_base + (LANEN_RX_ADPT_DFETAP1_STAT << 2)),
+		combo_phy_r32(iphy->cr_base, (LANEN_RX_ADPT_DFETAP1_STAT << 2)));
+
+	if (err) {
+		dev_warn(dev, "RX Adaptation not done\n", iphy->parent->id);
+		return -1;
+	} else {
+		dev_dbg(dev, "RX Adaptation done\n", iphy->parent->id);
+		return 0;
+	}
+}
+
 static int intel_phy_power_on(struct phy_ctx *iphy)
 {
 	struct device *dev = iphy->dev;
@@ -574,6 +687,18 @@ static int intel_combo_phy_power_off(struct phy *phy)
 	return 0;
 }
 
+static int intel_combo_phy_calibrate(struct phy *phy)
+{
+	struct phy_ctx *iphy;
+	int ret = 0;
+
+	iphy = phy_get_drvdata(phy);
+	if (iphy->calibrate.rx_auto_adapt) {
+		ret = phy_rxeq_autoadapt(phy);
+	}
+	return ret;
+}
+
 static void __iomem *
 intel_combo_phy_ioremap(struct phy_ctx *iphy, const char *res_name)
 {
@@ -720,6 +845,9 @@ static int intel_phy_dt_parse(struct intel_combo_phy *priv,
 		}
 	}
 
+	iphy->calibrate.rx_auto_adapt =
+		device_property_read_bool(dev, "intel-rx-auto-adapt");
+
 	if (!(BIT(iphy->phy_mode) & priv->phy_cap)) {
 		dev_err(dev,
 			"PHY mode %u is not supported by COMBO PHY id %u of %s soc platform!\n",
diff --git a/drivers/phy/phy-core.c b/drivers/phy/phy-core.c
index 48a365e303e5..8f6e8e28996d 100644
--- a/drivers/phy/phy-core.c
+++ b/drivers/phy/phy-core.c
@@ -372,6 +372,21 @@ int phy_reset(struct phy *phy)
 }
 EXPORT_SYMBOL_GPL(phy_reset);
 
+int phy_calibrate(struct phy *phy)
+{
+	int ret;
+
+	if (!phy || !phy->ops->calibrate)
+		return 0;
+
+	mutex_lock(&phy->mutex);
+	ret = phy->ops->calibrate(phy);
+	mutex_unlock(&phy->mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(phy_calibrate);
+
 /**
  * _of_phy_get() - lookup and obtain a reference to a phy by phandle
  * @np: device_node for which to get the phy
diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 78bb0d7f6b11..840b36c2a9f5 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -37,6 +37,7 @@ enum phy_mode {
  * @power_off: powering off the phy
  * @set_mode: set the mode of the phy
  * @reset: resetting the phy
+ * @calibrate: calibrate the phy
  * @owner: the module owner containing the ops
  */
 struct phy_ops {
@@ -46,6 +47,7 @@ struct phy_ops {
 	int	(*power_off)(struct phy *phy);
 	int	(*set_mode)(struct phy *phy, enum phy_mode mode);
 	int	(*reset)(struct phy *phy);
+	int (*calibrate)(struct phy *phy);
 	struct module *owner;
 };
 
@@ -139,6 +141,7 @@ int phy_power_on(struct phy *phy);
 int phy_power_off(struct phy *phy);
 int phy_set_mode(struct phy *phy, enum phy_mode mode);
 int phy_reset(struct phy *phy);
+int phy_calibrate(struct phy *phy);
 static inline int phy_get_bus_width(struct phy *phy)
 {
 	return phy->attrs.bus_width;
@@ -260,6 +263,13 @@ static inline int phy_reset(struct phy *phy)
 	return -ENOSYS;
 }
 
+static inline int phy_calibrate(struct phy *phy)
+{
+	if (!phy)
+		return 0;
+	return -ENOSYS;
+}
+
 static inline int phy_get_bus_width(struct phy *phy)
 {
 	return -ENOSYS;
