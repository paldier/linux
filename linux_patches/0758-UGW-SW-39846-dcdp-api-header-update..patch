From d6595460121475aae6ef1700ca11ffb3f7987fd5 Mon Sep 17 00:00:00 2001
From: sureshna <suresh.nagaraj@intel.com>
Date: Tue, 23 Jul 2019 16:36:13 +0530
Subject: [PATCH] UGW_SW-39846 : dcdp api header update.

- dcdp api header update for lgm and prx300 support.
- New API dc_dp_get_peripheral_config() for txin static buffer control.
- New API dc_dp_return_bufs() for grx buffer recovery.
- Few other indentation changes.
---
 include/net/directconnect_dp_api.h | 805 ++++++++++++++++++++++---------------
 1 file changed, 488 insertions(+), 317 deletions(-)

diff --git a/include/net/directconnect_dp_api.h b/include/net/directconnect_dp_api.h
index 98094cc9ae30..1b40793c856b 100644
--- a/include/net/directconnect_dp_api.h
+++ b/include/net/directconnect_dp_api.h
@@ -13,9 +13,9 @@
  ** Copyright (c) 2010 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
  *******************************************************************************/
 
-#ifdef CONFIG_LTQ_DATAPATH /* for GRX500/GRX750 */
+#if defined(CONFIG_INTEL_DATAPATH) || defined(CONFIG_LTQ_DATAPATH) /* for LGM/GRX500/GRX750 */
 #include <net/datapath_api.h>
-#else /* #ifdef CONFIG_LTQ_DATAPATH */
+#else /* #if defined(CONFIG_INTEL_DATAPATH) || defined(CONFIG_LTQ_DATAPATH) */
 #include <net/datapath_api_common.h>
 #endif /* #ifndef CONFIG_LTQ_DATAPATH */
 
@@ -52,7 +52,7 @@
 /**
   \brief DC DP API version code
  */
-#define DC_DP_API_VERSION_CODE        0x040104
+#define DC_DP_API_VERSION_CODE        0x050000
 
 /**
   \brief DC DP API version
@@ -80,19 +80,24 @@
 #define DC_DP_F_SWPATH           0x00000040
 
 /**
-  \brief Alloc flag as FASTPATH DSL
+  \brief Alloc flag as FASTPATH WLAN
  */
-#define DC_DP_F_FAST_DSL         0x00000100
+#define DC_DP_F_FAST_WLAN        0x00000100
 
 /**
-  \brief Alloc flag as shared resource
+  \brief Alloc flag as FASTPATH DSL
  */
-#define DC_DP_F_SHARED_RES       0x00000200
+#define DC_DP_F_FAST_DSL         0x00000200
 
 /**
   \brief Alloc flag as Multiport support
  */
-#define DC_DP_F_MULTI_PORT       0x00000400
+#define DC_DP_F_MULTI_PORT       0x00010000
+
+/**
+  \brief Alloc flag as shared resource
+ */
+#define DC_DP_F_SHARED_RES       0x00020000
 
 /**
   \brief Register device flag; Specify if peripheral driver want to allocate SW Tx ring
@@ -252,7 +257,7 @@
 /**
   \brief Host capability: Fragementation exception handling (Applicable for GRX350/550 FASTPATH)
  */
-#define DC_DP_F_HOST_CAP_RX_FRAG_HANDLING_RESTRICTED 	0x00020000
+#define DC_DP_F_HOST_CAP_RX_FRAG_HANDLING_RESTRICTED 0x00020000
 
 /**
   \brief Host capability: Specify when host supports 2DW desc format (Applicable for GRX330 FASTPATH)
@@ -275,6 +280,21 @@
 #define DC_DP_F_HOST_CAP_SKB_CHAIN			0x00200000
 
 /**
+  \brief Host capability: Specify when host support to enable Buffer Marking
+         to set Policy ID in the Packet Buffer meta data. This is used by host to free up
+         the non-returned buffers to the CQM buffer pool in the event of peripheral FW crash.
+ */
+#define DC_DP_F_HOST_CAP_BUFFER_MARKING                 0x00400000
+
+/**
+  \brief Host capability: Specify when host support to enable auto detection of policy and buffer pool
+         based on the address range. SoC returns the buffers to the appropriate buffer pool based on this.
+         To be set by the peripheral driver only if the corresponding ACA is not able to return
+         the Policy ID and Pool info in the return Descriptor.
+ */
+#define DC_DP_F_HOST_CAP_AUTO_DETECT_BUFFER_RETURN      0x00800000
+
+/**
   \brief Device request: Specify when device expects with Tx FCS.
  */
 #define DC_DP_F_DEV_REQ_TX_FCS				0x00000001
@@ -330,6 +350,16 @@
 #define DC_DP_F_DEV_REQ_LITEPATH_RX_SHORTCUT		0x00000400
 
 /**
+  \brief Device request: Specify when device expects the buffer marking.
+ */
+#define DC_DP_F_DEV_REQ_BUFFER_MARKING                  DC_DP_F_HOST_CAP_BUFFER_MARKING
+
+/**
+  \brief Device request: Specify when device expects auto detetction of policy and buffer pool.
+ */
+#define DC_DP_F_DEV_REQ_AUTO_DETECT_BUFFER_RETURN       DC_DP_F_HOST_CAP_AUTO_DETECT_BUFFER_RETURN
+
+/**
   \brief Register subif flags; Specify to register already registered subif/vap as LitePath Partial offload
  */
 #define DC_DP_F_REGISTER_LITEPATH			0x00000100
@@ -540,8 +570,20 @@ enum dc_dp_ring_type {
 	DC_DP_RING_SW_MODE1,
 	/** Tx/Rx ring as HW DC Mode0 (e.g., GRX350 Fast Path) */
 	DC_DP_RING_HW_MODE0,
+	/** Tx/Rx ring as HW DC Mode0 Ext (e.g., FMX Fast Path) */
+	DC_DP_RING_HW_MODE0_EXT,
 	/** Tx/Rx ring as HW DC Mode1 (e.g., GRX750 Fast Path) */
 	DC_DP_RING_HW_MODE1,
+	/** Tx/Rx ring as HW DC Mode1 Ext (e.g., LGM Fast Path) */
+	DC_DP_RING_HW_MODE1_EXT,
+};
+
+/** \brief Definition of DC UMT mode
+ */
+enum dc_dp_umt_mode {
+	DC_DP_UMT_MODE_HW_AUTO = 0,
+	DC_DP_UMT_MODE_HW_USER,
+	DC_DP_UMT_MODE_SW
 };
 
 /**
@@ -550,8 +592,12 @@ enum dc_dp_ring_type {
 enum dc_dp_mode_type {
 	/** DC Mode 0 */
 	DC_DP_MODE_TYPE_0 = 0,
+	/** DC Mode 0 Ext */
+	DC_DP_MODE_TYPE_0_EXT,
 	/** DC Mode 1 */
 	DC_DP_MODE_TYPE_1,
+	/** DC Mode 1 Ext */
+	DC_DP_MODE_TYPE_1_EXT,
 };
 
 /** \brief Definition of DC direction type
@@ -563,6 +609,15 @@ enum dc_dp_dir_type {
 	DC_DP_DIR_SOC2DEV,
 };
 
+/** \brief Definition of DC device type
+ */
+enum dc_dp_dev_type {
+	DC_DP_DEV_WAV_500 = 0,
+	DC_DP_DEV_WAV_600_24G,
+	DC_DP_DEV_WAV_600_5G,
+	DC_DP_DEV_WAV_600_CDB,
+};
+
 /** \brief Definition of Power Management module
  */
 enum dc_dp_power_module {
@@ -608,14 +663,14 @@ struct dc_dp_dev {
 /**
   \brief Ring recovery stats Structure
   \note If stats difference exceeds pre-configured threshold the system would be rebooted to recover from loss of descriptiors.
-FIXME : will be generalzed for 4 ring.
+        FIXME : will be generalzed for 4 ring.
  */
 struct dc_dp_recovery_stats {
 	uint32_t soc2dev_announced_desc_cum; /*!< Announced cumulative desc count by DC Counter */
 	uint32_t soc2dev_to_be_pulled_counter; /*!< Desc count to be pulled from DC SoC (e.g. CBM for GRX500) Dequeue port */
 	uint32_t soc2dev_to_be_freed_buffer; /*!< Buffer count to be freed to DC SoC (e.g. CBM for GRX500) Dequeue Free port */
 	uint32_t dc_rx_outstanding_desc; /*!< DC client driver/FW HD ring outstanding decsriptors-
-					   Add num_desc when written to HD ring and subtract num_desc based on DC counter value received. */
+                                              Add num_desc when written to HD ring and subtract num_desc based on DC counter value received. */
 	//FIXME : For non-GRX500 : Expand dev2soc fields.??
 };
 
@@ -626,7 +681,7 @@ struct dc_dp_recovery_stats {
   \param[in] skb  Pointer to pointer to packet buffer, like sk_buff
   \param[in] len  Length of the packet (optional as also present in skb->len)
   \param[in] flags:
-  DC_DP_F_RX_LITEPATH - recieved packet through litepath
+             - DC_DP_F_RX_LITEPATH : recieved packet through litepath
   \return 0 if OK / -1 if error / > 0, if DC DP layer needs to do LitePath Rx
   \note The receive callback is MUST to register and is invoked by DirectConnect datapath driver to pass the packets to the peripheral driver
   \note If the Peripheral Driver does not pass the packet to stack, and does
@@ -634,13 +689,13 @@ struct dc_dp_recovery_stats {
   send packet to accelerator - Valid for LitePath Rx case only.
  */
 typedef int32_t (*dc_dp_rx_fn_t) (
-		struct net_device *rx_if,
-		struct net_device *tx_if,
-		struct dp_subif *subif,
-		struct sk_buff **skb,
-		int32_t len,
-		uint32_t flags
-		); /*!< Rx function callback */
+	struct net_device *rx_if,
+	struct net_device *tx_if,
+	struct dp_subif *subif,
+	struct sk_buff **skb,
+	int32_t len,
+	uint32_t flags
+); /*!< Rx function callback */
 
 /**
   \brief   Get Meta-SubInterface Integer Identifier (e.g. Station Id) callback. Mostly applicable to DC WLAN peripheral only.
@@ -654,13 +709,13 @@ typedef int32_t (*dc_dp_rx_fn_t) (
   \note : Optional function - Not needed in case Client driver does not have peripheral specific mapping of Meta Sub Interface in the sub-interfce field.
  */
 typedef int32_t(*dc_dp_get_netif_subinterface_fn_t) (
-		struct net_device *netif,
-		struct sk_buff *skb,
-		void *subif_data,
-		char *mac_addr,
-		struct dp_subif *subif,
-		uint32_t flags
-		); /*!< Get Meta SubInterface Id callback. */
+	struct net_device *netif,
+	struct sk_buff *skb,
+	void *subif_data,
+	char *mac_addr,
+	struct dp_subif *subif,
+	uint32_t flags
+); /*!< Get Meta SubInterface Id callback. */
 
 /** \brief DirectConnect Data Path Device/Peripheral specific field info
  * structure including pos in descriptor DWORD format
@@ -700,8 +755,8 @@ struct dc_dp_fields_value_dw {
 /** \brief  Get DC Peripheral specific Desc Information callback, which is
   invoked by DC library to the Peripheral driver. Peripheral driver indicates
   the field value and mask it wants to set in the desc/HD DWORDs
-  \param[in] port_id	Port Number for which information is sought
-  \param[in] skb	Pointer to skbuff for which Peripheral specific info is
+  \param[in] port_id Port Number for which information is sought
+  \param[in] skb Pointer to skbuff for which Peripheral specific info is
   requested/
   \param[out] desc_fields  Pointer to dc_dp_fields_value_dw structure
   \param[in] flags  : Reserved
@@ -709,17 +764,17 @@ struct dc_dp_fields_value_dw {
   \remark The Acceleration layer can treat this info as 'black box' if required
  */
 typedef int32_t (*dc_dp_get_dev_specific_desc_info_t) (
-		int32_t port_id,   /* Port Identifier */
-		struct sk_buff *skb,
-		struct dc_dp_fields_value_dw *desc_fields,
-		uint32_t flags
-		);
+	int32_t port_id,   /* Port Identifier */
+	struct sk_buff *skb,
+	struct dc_dp_fields_value_dw *desc_fields,
+	uint32_t flags
+);
 
 /** \brief  Get DC Peripheral specific Desc Information, that will be passed in
   the HD to the peripheral (and read back from HD from the peripheral) - it
   indicates the mapping of the fields as well (not in use)
-  \param[in] port_id	Port Number for which information is sought
-  \param[in] skb	Pointer to skbuff for which Peripheral specific info is requested
+  \param[in] port_id Port Number for which information is sought
+  \param[in] skb Pointer to skbuff for which Peripheral specific info is requested
   \param[out] desc_fields Pointer to dc_dp_field_value structure
   \param[in] flags  : Reserved
   \return 0 if OK / -1 if error
@@ -727,11 +782,11 @@ typedef int32_t (*dc_dp_get_dev_specific_desc_info_t) (
   and combine it into a single peripheral/vendor specific field if required.
  */
 int32_t dc_dp_get_dev_specific_desc_fields (
-		int32_t port_id,   /* Port Identifier */
-		struct sk_buff *skb,
-		struct dc_dp_field_value *desc_fields,
-		uint32_t flags
-		);
+	int32_t port_id,   /* Port Identifier */
+	struct sk_buff *skb,
+	struct dc_dp_field_value *desc_fields,
+	uint32_t flags
+);
 
 /**
   \brief   Get ring/Buffer recovery stats callback
@@ -745,29 +800,45 @@ int32_t dc_dp_get_dev_specific_desc_fields (
   through rebooting system if significant buffrs lost
  */
 typedef int32_t (*dc_dp_get_recovery_stats_fn_t) (
-		struct net_device *netif,
-		int32_t port_id,
-		struct dc_dp_recovery_stats *stats,
-		uint32_t flags
-		);
+	struct net_device *netif,
+	int32_t port_id,
+	struct dc_dp_recovery_stats *stats,
+	uint32_t flags
+);
+
+/**
+   \brief   DMA Rx handler callback
+   \param[in] netif  Pointer to Linux netdevice structure
+   \param[in] port_id  Port Identifier [either netdevice or port_id - one value to be passed].
+   \param[in] flags  Reserved for future use
+   \return 0 if OK, -1 on ERROR
+   \note Optional recovery stats callback. The DC datapath driver can tally up the buffer and
+   ring stats on the DC peripheral and on the host SoC side, and trigger recovery - for exampe,
+   through rebooting system if significant buffrs lost
+*/
+typedef int32_t (*dc_dp_irq_handler_fn_t) (
+	struct net_device *netif,
+	int32_t port_id,
+	uint32_t flags
+);
 
 /** \brief  Multicast module callback to add/delete a mcast group membership to/from a DirectConnect interface.
   \param[in] grp_id  Multicast group id.
   \param[in] dev  Registered net device.
   \param[in] mc_stream  Multicast stream information.
   \param[in] flags  :
-  DC_DP_MC_F_ADD - Add a new mcast group membership to a DirectConnect interface.
-  DC_DP_MC_F_UPD - Update an existing mcast group membership to a DirectConnect interface.
-  DC_DP_MC_F_DEL - Delete an existing mcast group membership from a DirectConnect interface.
+      DC_DP_MC_F_ADD - Add a new mcast group membership to a DirectConnect interface.
+      DC_DP_MC_F_UPD - Update an existing mcast group membership to a DirectConnect interface.
+      DC_DP_MC_F_DEL - Delete an existing mcast group membership from a DirectConnect interface.
   \return none
   \note Group Identifier is allocated and managed by Multicast Subsystem.
  */
 typedef void (*dc_dp_mcast_callback_fn_t) (
-		uint32_t grp_id,
-		struct net_device *dev,
-		void *mc_stream,
-		uint32_t flags
-		);
+	uint32_t grp_id,
+	struct net_device *dev,
+	void *mc_stream,
+	uint32_t flags
+);
 
 /**
   \brief IP address data structure - used in Multicast registration.
@@ -784,13 +855,12 @@ struct dc_dp_ip_addr {
   \brief Mutlicast stream (5-tuple) structure
  */
 struct dc_dp_mcast_stream {
-	struct net_device *mem_dev;	/*!< Member Netdevice */
+	struct net_device *mem_dev; /*!< Member Netdevice */
 	struct dc_dp_ip_addr src_ip; /*!< Source ip : can be ipv4 or ipv6 */
 	struct dc_dp_ip_addr dst_ip; /*!< Destination ip - GA : can be ipv4 or ipv6 */
-	uint32_t proto;	/*!< Protocol type : Mostly UDP for Multicast */
+	uint32_t proto; /*!< Protocol type : Mostly UDP for Multicast */
 	uint32_t src_port; /*!< Source port */
 	uint32_t dst_port; /*!< Destination port */
-#define MAX_ETH_ALEN 6
 	union {
 		unsigned char mac_addr[MAX_ETH_ALEN]; /*!< LAN/WLAN Mac address */
 		unsigned char src_mac[MAX_ETH_ALEN]; /*!< LAN/WLAN source Mac address */
@@ -813,8 +883,8 @@ struct dc_dp_ps_threshold {
   \brief DirectConnect Power State Module Information to be used for registration.
  */
 struct dc_dp_ps_module_info {
-	char                *module_name;  /*!< Power State registeirng module Name */
-	enum dc_dp_power_state           power_feature_state; /*!< Current Power State */
+	char *module_name;  /*!< Power State registeirng module Name */
+	enum dc_dp_power_state power_feature_state; /*!< Current Power State */
 	int32_t (*dc_dp_ps_state_get) (enum dc_dp_power_state *pmcu_state);  /*!< Callback to query current power state */
 	int32_t (*dc_dp_ps_state_switch) (int32_t pmcu_pwr_state_ena); /*!< Callback to enable power state */
 };
@@ -828,11 +898,6 @@ struct dc_dp_wol_cfg {
 	uint8_t wol_passwd[MAX_ETH_ALEN]; /*!< Wake-on-LAN password */
 };
 
-/* @} */
-
-/** \addtogroup DirectConnect_Datapath_Lib_Structs */
-/* @{ */
-
 /**
   \brief DirectConnect Datapath Lib Registration Callback. - It is supplied by individual DC peripheral driver.
  */
@@ -842,10 +907,11 @@ struct dc_dp_cb {
 	dp_restart_tx_fn_t restart_fn;  /*!< Start Tx function callback for Tx flow control - Optional (NULL)*/
 	dc_dp_get_netif_subinterface_fn_t get_subif_fn;  /*!< Get Subinterface metaid callback - Optional (for non-WLAN) (NULL) */
 	dc_dp_get_dev_specific_desc_info_t get_desc_info_fn; /*!< Get device/peripheral specific field info for
-							       desc/HD */
+                                                                  desc/HD */
 	dp_reset_mib_fn_t reset_mib_fn;  /*!< reset registered device's network mib counters - Optional (NULL) */
 	dp_get_mib_fn_t get_mib_fn;  /*!< Retrieve registered device's network mib counters  */
 	dc_dp_get_recovery_stats_fn_t recovery_fn; /*!< Get Recovery related stats - Optional (NULL) */
+	dc_dp_irq_handler_fn_t dma_rx_handler_fn; /*!< DMA RX IRQ Handler */
 };
 
 /**
@@ -858,6 +924,13 @@ struct dc_dp_buf_pool {
 	uint32_t size; /*!< Size of pool in bytes - Must be multiple of individual buffer size */
 };
 
+/** \brief This data structure describes the ring meta-information.
+ */
+struct dc_dp_ring_metadata {
+	void *credit_add; /*!< [out] Peripheral writes the credit add value to this address */
+	void *credit_left; /*!< [out] Peripheral reads the credit left value from this address */
+};
+
 /** \brief This data structure describes the ring attributes.
  */
 /* FIXME : Any budget for burst handling mainly for sw ring handling? in form of num of desc or in fastpath it could be timer based for umt hw? */
@@ -866,10 +939,13 @@ struct dc_dp_ring {
 	void *phys_base; /*!< [out] Physical Base address of ring */
 	int32_t size; /*!< [in/out] Size of ring in terms of entries : FIXME : Zero implies ring is unused. */
 	int32_t desc_dwsz; /*!< [in/out] Size of descriptor in DW. */
-	int32_t flags; /*!< [in]  DC_DP_F_PKTDESC_ENQ, DC_DP_F_PKTDESC_RET
-			 DC_DP_F_RET_RING_SAME_AS_ENQ*/
+	int32_t flags; /*!< [in] DC_DP_F_PKTDESC_ENQ, DC_DP_F_PKTDESC_RET
+                                 DC_DP_F_RET_RING_SAME_AS_ENQ*/
 	void  *ring; /*!< [out] Place holder for ring meta-structure - only used
-		       internally in the lower layers */
+				internally in the lower layers */
+	uint8_t policy_base; /*!< [out] Buffer Manager Policy Base for this ring*/
+	uint8_t pool_id; /*!< [out] Buffer Manager Pool Id for this ring*/
+	uint8_t high_4bits; /*!< [out] High 4 bits of 36bit buffer address */
 };
 
 /**
@@ -883,10 +959,10 @@ struct dc_dp_ring {
  * -----------------------------------
  *
  * soc2dev - CBM Dequeue Port Base. SoC -> Peripheral direction and enqueue
- *  	counter update in Peripheral memory - incremental
+ *           counter update in Peripheral memory - incremental
  *
  * soc2dev_ret is CBM Buffer return port base, Peripheral -> SoC. SoC detects in HW buffer return and does not
- * 	need any enqueue counter update
+ * need any enqueue counter update
  *
  * Above Ring Sizes are fixed
  *
@@ -894,10 +970,10 @@ struct dc_dp_ring {
  * -----------------------------------
  *
  * dev2soc - It is the DMA1-Tx channel ring (Peripheral -> SoC). Enqueue counter is  ignored as HW DMA engine polls.
- *	Peripheral may track on its own for its own writes!
+ *           Peripheral may track on its own for its own writes!
  *
  * dev2soc_ret - Same as dev2soc_ring and points to DMA1-TX channel base. Can be ignored
- * 	in that mode. Size is also the same
+ *               in that mode. Size is also the same
  *
  * For DC Mode 1: (GRX750/PUMA7)
  *
@@ -910,7 +986,7 @@ struct dc_dp_ring {
  * soc2dev_ret - Peripheral -> SoC direction enqueue (desc/buffer return) and enqueue counter
  *      update (incremental) in SoC memory.
  *
- * Above Ring Sizes are equal. Currently, GRX750/PUMA7 may allocate all	peripheral rings as equal
+ * Above Ring Sizes are equal. Currently, GRX750/PUMA7 may allocate all peripheral rings as equal
  *
  * Peripheral -> SoC Pkt direction (Rx)
  * -----------------------------------
@@ -937,27 +1013,32 @@ struct dc_dp_ring {
  *      update (incremental) in SoC memory. This ring may not be allocated and
  *      then the return desc/pkt is written on the soc2dev ring.
  *
- * Above Ring Sizes are equal. Currently, GRX750/PUMA7 may allocate all	peripheral rings as equal
+ * Above Ring Sizes are equal. Currently, GRX750/PUMA7 may allocate all peripheral rings as equal
  *
  * Peripheral -> SoC Pkt direction (Rx)
  * -----------------------------------
  *
  * dev2soc - Peripheral -> SoC direction enqueue (desc/buffer) and enqueue counter
-*      update (incremental) in SoC memory
-	*
-	 * dev2soc_ret - SoC -> Peripheral direction enqueue (desc/buffer return) and enqueue counter
-	  *      update (incremental) in Peripheral memory. This ring may not be allocated and
-	  *      then the return desc/pkt is written on the dev2soc ring.
-	  * \note  soc2dev and soc2dev_ret rings must be of same size
-	  * \note  dev2soc and dev2soc_ret rings must be of same size
-	  */
-	  struct dc_dp_ring_res {
-		  struct dc_dp_ring soc2dev; /*!< Params of Tx ring - SoC to Dev */
-		  struct dc_dp_ring soc2dev_ret; /*!< Params of Tx Return ring - SoC to Dev (Optional : Mode2)*/
-		  struct dc_dp_ring dev2soc;  /*!< Params of Rx ring - Dev to SoC */
-		  struct dc_dp_ring dev2soc_ret; /*!< Params of Rx Return ring - Dev to SoC (Optional : Mode0 / Mode2) */
-		  struct dc_dp_ring dev2soc_except; /*!< Params of Rx exception ring - Dev to SoC (Optional : Mode1 / Mode2) */
-	  };
+ *      update (incremental) in SoC memory
+ *
+ * dev2soc_ret - SoC -> Peripheral direction enqueue (desc/buffer return) and enqueue counter
+ *      update (incremental) in Peripheral memory. This ring may not be allocated and
+ *      then the return desc/pkt is written on the dev2soc ring.
+ * \note  soc2dev and soc2dev_ret rings must be of same size
+ * \note  dev2soc and dev2soc_ret rings must be of same size
+ */
+struct dc_dp_ring_res {
+	struct dc_dp_ring soc2dev; /*!< Params of Tx ring - SoC to Dev */
+	struct dc_dp_ring soc2dev_ret; /*!< Params of Tx Return ring - SoC to Dev (Optional : Mode2)*/
+	struct dc_dp_ring dev2soc;  /*!< Params of Rx ring - Dev to SoC */
+	struct dc_dp_ring dev2soc_ret; /*!< Params of Rx Return ring - Dev to SoC (Optional : Mode0 / Mode2) */
+	struct dc_dp_ring dev2soc_except; /*!< Params of Rx exception ring - Dev to SoC (Optional : Mode1 / Mode2) */
+	uint32_t txout_temp_dw3; /*!< [out] TXOUT(soc2dev_ret) Template DW3 - 32bit
+                                            LGM - DW contains Policy, Pool, 4bit High Address
+                                            PRX (Falcon) - DW contains Policy, Pool */
+	uint32_t rxout_temp_dw3; /*!< [out] RXOUT (dev2soc) Template DW3  - 32bit
+                                            LGM - DW contains Policy, Pool */
+};
 
 /**
  * \brief Direct Connect DC counters (Hardware based or FW/SW simulated) attributes.
@@ -971,6 +1052,8 @@ struct dc_dp_ring {
 struct dc_dp_dccntr {
 	int32_t soc_write_dccntr_mode; /*!< [in] DC Counter Write mode in peripheral memory : Incremental/Cumulative and Big/Little endian */
 	int32_t dev_write_dccntr_mode; /*!< [out] Dc Counter Read mode from SoC memory: Incremental/Cumulative and Big/Little endian */
+	int32_t dev2soc_dccntr_timer; /*! <in] UMT Message timer for RXOUT ring */
+	enum dc_dp_umt_mode umt_mode; /*! <in] UMT mode: DC_DP_UMT_MODE_HW_AUTO, DC_DP_UMT_MODE_HW_USER, DC_DP_UMT_MODE_SW */
 
 	void *soc2dev_enq_phys_base; /*!< [in] Physical Base address of DC Counter write location (in DC peripheral memory) for soc2dev ring enq counter. It MUST be provided by peripheral driver. */
 	void *soc2dev_enq_base; /*!< [in] Base address of DC Counter write location (in DC peripheral memory) for soc2dev ring enq counter. */
@@ -1023,26 +1106,26 @@ struct dc_dp_res {
 	uint32_t num_bufs_req; /*!< [in] Number of buffers to allocate (Directconnect Peripheral -> SoC direction) */
 	int32_t num_bufpools; /*!< [out]  Number of buffer pools/chunks allocated for the desired no of buffers  */
 	struct dc_dp_buf_pool *buflist; /*!< [out] Allocated list of buffer chunks from which packet buffers are carved out.
-					  Caller needs to free the memory given by buflist pointer. */
+                                                   Caller needs to free the memory given by buflist pointer. */
 
 	uint32_t tx_num_bufs_req; /*!< [in] Number of buffers to allocate (Soc -> Directconnect Peripheral direction) */
 	int32_t tx_num_bufpools; /*!< [out]  Number of buffer pools/chunks allocated for the desired no of buffers  */
 	struct dc_dp_buf_pool *tx_buflist; /*!< [out] Allocated list of buffer chunks from which packet buffers are carved out.
-					     Caller needs to free the memory given by buflist pointer. */
+                                                      Caller needs to free the memory given by buflist pointer. */
 	uint32_t tx_desc_start_idx; /*!< [out] Tx Prefill counter to be set */
 
 	struct dc_dp_ring_res rings; /*!< [in/out] All the communication rings depending on DCMode0/DCMode1/SWModes */
-	int32_t		num_dccntr; /*!< [in] Number of DC counter units used - Could be HW or SW . Eg. VRX518 DSL Bonding will use 2 x DC counter. */
-	struct dc_dp_dccntr	*dccntr; /*!< [in/out] array of number of DC counter structures. Caller needs to allocate and free memory of dccntr pointer. */
-	void		*dev_priv_res; /*!< [in] Pointer to any dev specific resource structure */
+	int32_t num_dccntr; /*!< [in] Number of DC counter units used - Could be HW or SW . Eg. VRX518 DSL Bonding will use 2 x DC counter. */
+	struct dc_dp_dccntr *dccntr; /*!< [in/out] array of number of DC counter structures. Caller needs to allocate and free memory of dccntr pointer. */
+	void *dev_priv_res; /*!< [in] Pointer to any dev specific resource structure */
 };
 
 /**
   \brief DirectConnect Datapath Lib Counter write/read mode structure.
  */
 struct dc_dp_counter_mode {
-	uint32_t soc2dev_write;	/*!< Supported DC Counter write mode, as defined in DC_DP_F_DCCNTR_MODE flags */
-	uint32_t dev2soc_write;	/*!< Supported DC Counter read mode, as defined in DC_DP_F_DCCNTR_MODE flags */
+	uint32_t soc2dev_write; /*!< Supported DC Counter write mode, as defined in DC_DP_F_DCCNTR_MODE flags */
+	uint32_t dev2soc_write; /*!< Supported DC Counter read mode, as defined in DC_DP_F_DCCNTR_MODE flags */
 };
 
 /**
@@ -1069,13 +1152,42 @@ struct dc_dp_host_cap {
 	} swpath;
 };
 
+/** \brief DirectConnect Data Path subif registration attributes.
+ */
+struct dc_dp_res_ext {
+	int32_t deq_port_base; /*!< Base CQM port obtained for this peripheral */
+	struct dc_dp_ring soc2dev; /*!< soc2dev/TXIN ring */
+};
+
+/** \brief DirectConnect Datapath Device configuration in SoC
+ */
+struct dc_dp_dev_config {
+	uint32_t txin_ring_size; /*!< [out] Max TX_IN Ring Size supported by SoC */
+	uint32_t txout_ring_size; /*!< [out] Max TX_OUT Ring Size supported by SoC */
+	uint32_t rxin_ring_size; /*!< [out] Max RX_IN Ring Size supported by SoC */
+	uint32_t rxout_ring_size; /*!< [out] Max RX_OUT Ring Size supported by SoC */
+	uint32_t rx_bufs; /*!< [out] Max Rx Bufs requested by Peripheral for prefetching in RXIN */
+	uint32_t tx_bufs; /*!< [out] Max Tx Bufs requested by Peripheral for prefetching in TXIN */
+};
+
 /* @} */
 
 
 /** \addtogroup DirectConnect_Datapath_Lib_APIs */
 /* @{ */
 
-/** \brief  DirectConnect Datapath Allocate Data structure port may map to an exclusive netdevice
+/** \brief  Obtain device capability in SoC.
+  \param[in] dev_id  enum indicating device type
+  \param[out] dev_config  Device configuration
+  \return  0 if OK / -1 if error
+ */
+int32_t
+dc_dp_get_peripheral_config (
+	enum dc_dp_dev_type dev_id,
+	struct dc_dp_dev_config *dev_config
+);
+
+/** \brief  Obtain SoC capability.
   \param[out] cap  Pointer to DC SoC capability structure
   \param[in] flags  : Reserved
   \return  0 if OK / -1 if error
@@ -1083,12 +1195,12 @@ struct dc_dp_host_cap {
 /* FIXME : can we add port specific capability as well? */
 int32_t
 dc_dp_get_host_capability (
-		struct dc_dp_host_cap *cap,
-		uint32_t flags
-		);
+	struct dc_dp_host_cap *cap,
+	uint32_t flags
+);
 
 /** \brief  DirectConnect Datapath Allocate Data structure port may map to an exclusive netdevice
-  like in the case of ethernet LAN ports.	In other cases like WLAN, the physical port is a Radio port,
+  like in the case of ethernet LAN ports. In other cases like WLAN, the physical port is a Radio port,
   while netdevices are Virtual Access Points (VAPs). In this case, the AP netdevice can be passed.
   Alternately, driver_port & driver_id will be used to identify this port.
   \param[in] owner  Kernel module pointer which owns the port
@@ -1096,23 +1208,24 @@ dc_dp_get_host_capability (
   \param[in] dev  Pointer to Linux netdevice structure (optional)
   \param[in] port_id  Optional port_id number requested. Usually, 0 and allocated by driver
   \param[in] flags  : Use Datapath driver flags for Datapath Port Alloc
-  -  DC_DP_F_FASTPATH : Allocate the port as h/w acclerable
-  -  DC_DP_F_FAST_DSL : Allocate the DSL port as h/w acclerable
-  -  DC_DP_F_LITEPATH : Allocate the port as partial accelerable/offload
-  -  DC_DP_F_SWPATH : Allocate the port as non-accelerable
-  -  DC_DP_F_MULTI_PORT : Allocate the port as multiport device
-  -  DC_DP_F_SHARED_RES : Allocate the port as shared resources
-  -  DC_DP_F_DEREGISTER : Deallocate the already allocated port
+             - DC_DP_F_DEREGISTER : Deallocate the already allocated port
+             - DC_DP_F_FASTPATH : Allocate the port as h/w acclerable
+             - DC_DP_F_LITEPATH : Allocate the port as partial accelerable/offload
+             - DC_DP_F_SWPATH : Allocate the port as non-accelerable
+             - DC_DP_F_FAST_WLAN : Allocate the WLAN port as h/w acclerable
+             - DC_DP_F_FAST_DSL : Allocate the DSL port as h/w acclerable
+             - DC_DP_F_MULTI_PORT : Allocate the port as multiport device
+             - DC_DP_F_SHARED_RES : Allocate the port as shared resources
   \return  Returns allocated Port number for given netdevice. / -1 if error
  */
 int32_t
 dc_dp_alloc_port (
-		struct module *owner,
-		uint32_t dev_port,
-		struct net_device *dev,
-		int32_t port_id,
-		uint32_t flags
-		);
+	struct module *owner,
+	uint32_t dev_port,
+	struct net_device *dev,
+	int32_t port_id,
+	uint32_t flags
+);
 
 /** \brief  Higher Layer Driver reservation API
   \param[in] owner  Kernel module pointer which owns the port
@@ -1120,18 +1233,18 @@ dc_dp_alloc_port (
   \param[in] dev  Pointer to Linux netdevice structure (Optional)
   \param[in] dev_req Peripheral Device Requirements and Capability, as defined in DC_DP_F_DEV_* flags
   \param[in] flags  : Special input flags to reserve mode routine
-  - DC_DP_F_DEREGISTER : Free the reservation, if any.
+             - DC_DP_F_DEREGISTER : Free the reservation, if any.
   \return  0 if OK / -1 if error
   \note Optionally, DC peripheral driver may invoke this API to reserve DC fastpath mode.
  */
 int32_t
 dc_dp_reserve_fastpath (
-		struct module *owner,
-		int32_t port_id,
-		struct net_device *dev,
-		uint32_t dev_req,
-		uint32_t flags
-		);
+	struct module *owner,
+	int32_t port_id,
+	struct net_device *dev,
+	uint32_t dev_req,
+	uint32_t flags
+);
 
 /** \brief  Higher layer Driver Datapath registration API
   \param[in] owner  Kernel module pointer which owns the port
@@ -1141,26 +1254,26 @@ dc_dp_reserve_fastpath (
   \param[in,out] resources  Buffer, Tx/Rx ring and DC counter resources.
   \param[in,out] devspec  Device Specification - netdevice name, DC Mode, Context Pointer.
   \param[in] flags  : Special input flags to register device routine
-  - DC_DP_F_DEREGISTER : Deregister the device
-  - DC_DP_F_ALLOC_SW_TX_RING : Specify it if peripheral driver want to allocate sw tx ring
-  - DC_DP_F_ALLOC_SW_RX_RING : Specify it if peripheral driver want to allocate sw rx ring
-  - DC_DP_F_DONT_ALLOC_HW_TX_RING : Specify it if peripheral driver don't want to allocate hw tx ring
-  - DC_DP_F_DONT_ALLOC_HW_RX_RING : Specify it if peripheral driver don't want to allocate hw rx ring
-  - DC_DP_F_QOS : Specify it if peripheral/dev QoS class is required in DC peripheral
-  - DC_DP_F_SHARED_RES : Specify it if peripheral driver want to re-use/update dc resources, multi-port/bodning case respectively
+             - DC_DP_F_DEREGISTER : Deregister the device
+             - DC_DP_F_ALLOC_SW_TX_RING : Specify it if peripheral driver want to allocate sw tx ring
+             - DC_DP_F_ALLOC_SW_RX_RING : Specify it if peripheral driver want to allocate sw rx ring
+             - DC_DP_F_DONT_ALLOC_HW_TX_RING : Specify it if peripheral driver don't want to allocate hw tx ring
+             - DC_DP_F_DONT_ALLOC_HW_RX_RING : Specify it if peripheral driver don't want to allocate hw rx ring
+             - DC_DP_F_QOS : Specify it if peripheral/dev QoS class is required in DC peripheral
+             - DC_DP_F_SHARED_RES : Specify it if peripheral driver want to re-use/update dc resources, multi-port/bodning case respectively
   \return 0 if OK / -1 if error
   \note This is the first registration to be invoked by any DC peripheral. Subsequently additional registrations like Multicast, Ring-Recovery or Power Saving (PS) to be done.
  */
 int32_t
 dc_dp_register_dev (
-		struct module *owner,
-		uint32_t port_id,
-		struct net_device *dev,
-		struct dc_dp_cb *datapathcb,
-		struct dc_dp_res *resources,
-		struct dc_dp_dev *devspec,
-		uint32_t flags
-		);
+	struct module *owner,
+	uint32_t port_id,
+	struct net_device *dev,
+	struct dc_dp_cb *datapathcb,
+	struct dc_dp_res *resources,
+	struct dc_dp_dev *devspec,
+	uint32_t flags
+);
 
 /** \brief  Allocates datapath subif number to a sub-interface netdevice.
   Sub-interface value must be passed to the driver.
@@ -1170,9 +1283,9 @@ dc_dp_register_dev (
   \param[in] subif_name  Pointer to device name, this is MUST if Linux netdevice is NULL.
   \param[in,out] subif_id  Pointer to subif_id structure including port_id
   \param[in] flags :
-  DC_DP_F_DEREGISTER - De-register already registered subif/vap
-  DC_DP_F_REGISTER_LITEPATH - Register already registered subif/vap as LitePath Partial offload
-  DC_DP_F_DEREGISTER_LITEPATH - De-register already registered LitePath subif/logical netdev from LitePath
+             - DC_DP_F_DEREGISTER : De-register already registered subif/vap
+             - DC_DP_F_REGISTER_LITEPATH : Register already registered subif/vap as LitePath Partial offload
+             - DC_DP_F_DEREGISTER_LITEPATH : De-register already registered LitePath subif/logical netdev from LitePath
   \return 0 if OK / -1 if error
   \note Sub-Interface is applicable for logical or virtual interfaces like VAP (SSID) or VLAN.
   \note LITEPATH register/deregister only works on Partial offload or NOT, does deregister subif.
@@ -1180,12 +1293,39 @@ dc_dp_register_dev (
  */
 int32_t
 dc_dp_register_subif (
-		struct module *owner,
-		struct net_device *dev,
-		const uint8_t *subif_name,
-		struct dp_subif *subif_id,
-		uint32_t flags
-		);
+	struct module *owner,
+	struct net_device *dev,
+	const uint8_t *subif_name,
+	struct dp_subif *subif_id,
+	uint32_t flags
+);
+
+/** \brief  Allocates datapath subif number to a sub-interface netdevice.
+  Sub-interface value must be passed to the driver.
+  The port may map to an exclusive netdevice like in the case of ethernet LAN ports.
+  \param[in] owner  Kernel module pointer which owns the port
+  \param[in] dev  Pointer to Linux netdevice structure. Optional for VRX518(ATM) driver.
+  \param[in] subif_name  Pointer to device name, this is MUST if Linux netdevice is NULL.
+  \param[in,out] subif_id  Pointer to subif_id structure including port_id
+  \param[in,out] res_ext Pointer to dc_dp_res_ext structure
+  \param[in] flags :
+             - DC_DP_F_DEREGISTER : De-register already registered subif/vap
+             - DC_DP_F_REGISTER_LITEPATH : Register already registered subif/vap as LitePath Partial offload
+             - DC_DP_F_DEREGISTER_LITEPATH : De-register already registered LitePath subif/logical netdev from LitePath
+  \return 0 if OK / -1 if error
+  \note Sub-Interface is applicable for logical or virtual interfaces like VAP (SSID) or VLAN.
+  \note LITEPATH register/deregister only works on Partial offload or NOT, does deregister subif.
+  \note if subinterface has to be deregistered completely, DC_DP_F_DEREGISTER flag must be passed.
+ */
+int32_t
+dc_dp_register_subif_ext (
+	struct module *owner,
+	struct net_device *dev,
+	const uint8_t *subif_name,
+	struct dp_subif *subif_id,
+	struct dc_dp_res_ext *res_ext,
+	uint32_t flags
+);
 
 /** \brief  Transmit packet to low-level Datapath driver
   \param[in] rx_if  Rx If netdevice pointer (optional)- MUST be set when received net_device is known.
@@ -1194,21 +1334,38 @@ dc_dp_register_subif (
   \param[in] skb  Pointer to packet buffer like sk_buff
   \param[in] len  Length of packet to transmit
   \param[in] flags :
-  DC_DP_F_XMIT_LITEPATH - send packet through litepath
-  DC_DP_F_XMIT_OAM - Send packet through ATM only
+             - DC_DP_F_XMIT_LITEPATH : send packet through litepath
+             - DC_DP_F_XMIT_OAM : Send packet through ATM only
   \return 0 if OK / -1 if error
   \note Either rx_if or rx_subif would be passed in this routine if LitePath
   \note skb is freed by underlying layer if error
  */
 int32_t
 dc_dp_xmit (
-		struct net_device *rx_if,
-		struct dp_subif *rx_subif,
-		struct dp_subif *tx_subif,
-		struct sk_buff *skb,
-		int32_t len,
-		uint32_t flags
-	   );
+	struct net_device *rx_if,
+	struct dp_subif *rx_subif,
+	struct dp_subif *tx_subif,
+	struct sk_buff *skb,
+	int32_t len,
+	uint32_t flags
+);
+
+/** \brief  Enable DMA IRQ
+  \param[in] owner
+  \param[in] port_id
+  \param[in] dev
+  \param[in] subif
+  \param[in] flags :
+  \return 0 if OK / -1 if error
+ */
+int32_t
+dc_dp_enable_dma_irq (
+	struct module *owner,
+	uint32_t port_id,
+	struct net_device *dev,
+	struct dp_subif *subif,
+	uint32_t flags
+);
 
 /** \brief  Handle Tx-Confirm and/or Rx interrupts (for SWPATH - w/ or w/o LITEPATH only)
   \param[in] owner  Kernel module pointer which owns the port.
@@ -1216,20 +1373,35 @@ dc_dp_xmit (
   \param[in] dev  Pointer to Linux netdevice structure - (Optional).
   \param[in] ring Pointer to Ring  which needs processing.
   \param[in] flags  Special input flags to interrupt handling routine
-  - DC_DP_F_TX_COMPLETE : To handle Tx return interrupt
-  - DC_DP_F_RX : To handle Rx interrupt
-  - DC_DP_F_RX_FRAG_EXCEPT : To handle Rx exception (fragmentation) interrupt
+             - DC_DP_F_TX_COMPLETE : To handle Tx return interrupt
+             - DC_DP_F_RX : To handle Rx interrupt
+             - DC_DP_F_RX_FRAG_EXCEPT : To handle Rx exception (fragmentation) interrupt
   \return 0 if OK / -1 if error
   \note This processing will be called from a tasklet (Device specific)
  */
 int32_t
 dc_dp_handle_ring_sw (
-		struct module *owner,
-		uint32_t port_id,
-		struct net_device *dev,
-		struct dc_dp_ring *ring,
-		uint32_t flags
-		);
+	struct module *owner,
+	uint32_t port_id,
+	struct net_device *dev,
+	struct dc_dp_ring *ring,
+	uint32_t flags
+);
+
+/** \brief  Return the HW allocated buffers
+  \param[in] port_id  Port Id
+  \param[in] buflist  List of buffers to be returned
+  \param[in] buflist_len  Number of buffers in the buflist
+  \param[in] flags  Reserved for future use
+  \return 0 if OK / -1 if error
+ */
+int32_t
+dc_dp_return_bufs (
+	uint32_t port_id,
+	void **buflist,
+	uint32_t buflist_len,
+	uint32_t flags
+);
 
 /** \brief  Allocate skbuff buffer in DDR/SRAM
   \param[in] len  Length of the buffer required
@@ -1237,11 +1409,11 @@ dc_dp_handle_ring_sw (
   \param[in] flags  Reserved
   \return skb pointer if OK / NULL if error
  */
-struct sk_buff *dc_dp_alloc_skb (
-		uint32_t len,
-		struct dp_subif *subif,
-		uint32_t flags
-		);
+struct sk_buff * dc_dp_alloc_skb (
+	uint32_t len,
+	struct dp_subif *subif,
+	uint32_t flags
+);
 
 /** \brief  Free the allocated buffer
   \param[in] subif  Pointer to sub-interface for which free is requried
@@ -1249,9 +1421,9 @@ struct sk_buff *dc_dp_alloc_skb (
   \return 0 if OK / -1 if error
  */
 int32_t dc_dp_free_skb (
-		struct dp_subif *subif,
-		struct sk_buff *skb
-		);
+	struct dp_subif *subif,
+	struct sk_buff *skb
+);
 
 /** \brief  Allocate buffers in HW/FW/SW
   \param[in] subif  Pointer to sub-interface for which allocation is requried
@@ -1259,45 +1431,45 @@ int32_t dc_dp_free_skb (
   \param[in] num_bufs_req  Number of buffers to allocate
   \param[out] num_bufpools  Number of buffer pools/chunks allocated for the desired no of buffers
   \param[out] buflist  Allocated list of buffer chunks from which packet buffers are carved out.
-  Caller needs to free the memory given by buflist pointer.
+                       Caller needs to free the memory given by buflist pointer.
   \param[in] dir  direction, where enum values are as descrbed in enum dc_dp_dir_type.
   \param[in] flags  Reserved
   \return 0 if OK / -1 if error
  */
 /* FIXME : Any use? */
 int32_t dc_dp_alloc_bufs (
-		struct dp_subif *subif,
-		uint32_t buf_len,
-		uint32_t num_bufs_req,
-		uint32_t *num_bufpools,
-		struct dc_dp_buf_pool **buflist,
-		enum dc_dp_dir_type dir,
-		uint32_t flags
-		);
+	struct dp_subif *subif,
+	uint32_t buf_len,
+	uint32_t num_bufs_req,
+	uint32_t *num_bufpools,
+	struct dc_dp_buf_pool **buflist,
+	enum dc_dp_dir_type dir,
+	uint32_t flags
+);
 
 /** \brief  Free the allocated buffers from HW/FW/SW
   \param[in] subif  Pointer to sub-interface for which allocation is requried
   \param[in] num_bufpools  Number of buffer pools/chunks allocated for the desired no of buffers
   \param[in] buflist  Allocated list of buffer chunks from which packet buffers are carved out.
-  Caller needs to free the memory given by buflist pointer.
+                      Caller needs to free the memory given by buflist pointer.
   \param[in] dir  direction, where enum values are as descrbed in enum dc_dp_dir_type.
   \param[in] flags  Reserved
   \return 0 if OK / -1 if error
  */
 /* FIXME : Any use? */
 int32_t dc_dp_free_bufs (
-		struct dp_subif *subif,
-		uint32_t num_bufpools,
-		struct dc_dp_buf_pool *buflist,
-		enum dc_dp_dir_type dir,
-		uint32_t flags
-		);
+	struct dp_subif *subif,
+	uint32_t num_bufpools,
+	struct dc_dp_buf_pool *buflist,
+	enum dc_dp_dir_type dir,
+	uint32_t flags
+);
 
 /** \brief  Allow Acceleration subsystem to learn about session when driver shortcuts
   forwarding without going to stack.
   \param[in] subif  Pointer to sub-interface for which free is requried
   \param[in] skb  Pointer to packet with skb->dev pointing to RxIf in PREFORWARDING
-  and TxIf in POSTFORWARDING
+                  and TxIf in POSTFORWARDING
   \param[in] flags : DC_DP_F_PREFORWARDING/DC_DP_F_POSTFORWARDING
   \return 0 if OK / -1 if error
   \remark skb->dev needs to be filled based on Rx and Tx Netif in the call
@@ -1306,10 +1478,10 @@ int32_t dc_dp_free_bufs (
   \remark this will call PPA/HIL learning hook as required
  */
 int32_t dc_dp_add_session_shortcut_forward (
-		struct dp_subif *subif,
-		struct sk_buff *skb,
-		uint32_t flags
-		);
+	struct dp_subif *subif,
+	struct sk_buff *skb,
+	uint32_t flags
+);
 
 /** \brief  Set port id in Host SoC DMA Descriptor.
   \param[in,out] skb  Pointer to sk_buff structure
@@ -1318,12 +1490,12 @@ int32_t dc_dp_add_session_shortcut_forward (
   \return  0 if OK / -1 if error
   \note  This utility function will set and return DMA Decriptor's from given port value.
  */
-	static inline int32_t
+static inline int32_t
 dc_dp_set_ep_pkt (
-		struct sk_buff *skb,
-		int32_t	port_id,
-		uint32_t flags
-		)
+	struct sk_buff *skb,
+	int32_t port_id,
+	uint32_t flags
+)
 {
 	struct dma_tx_desc_1 *desc_1;
 
@@ -1344,12 +1516,12 @@ dc_dp_set_ep_pkt (
   \return  0 if OK / -1 if error
   \note This utility funciton will extract port identifier from given DMA Descriptor's DWord-1.
  */
-	static inline int32_t
+static inline int32_t
 dc_dp_get_ep_pkt (
-		struct sk_buff *skb,
-		int32_t *port_id,
-		uint32_t flags
-		)
+	struct sk_buff *skb,
+	int32_t *port_id,
+	uint32_t flags
+)
 {
 	struct dma_tx_desc_1 *desc_1;
 
@@ -1371,13 +1543,13 @@ dc_dp_get_ep_pkt (
   \return  0 if OK / -1 if error
   \note This funciton will return DMA Descriptior's DWord-0 by setting the given sub-interface id value.
  */
-	static inline int32_t
+static inline int32_t
 dc_dp_set_subifid_pkt (
-		int32_t	port_id,
-		struct sk_buff *skb,
-		int32_t subif_id,
-		uint32_t flags
-		)
+	int32_t port_id,
+	struct sk_buff *skb,
+	int32_t subif_id,
+	uint32_t flags
+)
 {
 	struct dma_tx_desc_0 *desc_0;
 
@@ -1398,13 +1570,13 @@ dc_dp_set_subifid_pkt (
   \return  0 if OK / -1 if error
   \note This utility function will extract sub-interface id from given DMA Descriptor DWord-0.
  */
-	static inline int32_t
+static inline int32_t
 dc_dp_get_subifid_pkt (
-		int32_t	port_id,
-		struct sk_buff *skb,
-		int32_t *subif_id,
-		uint32_t flags
-		)
+	int32_t port_id,
+	struct sk_buff *skb,
+	int32_t *subif_id,
+	uint32_t flags
+)
 {
 	struct dma_tx_desc_0 *desc_0;
 
@@ -1425,12 +1597,12 @@ dc_dp_get_subifid_pkt (
   \note This utility macro will set complete mark into DMA Descriptor DWord-3,
   to indicate that the peripheral specific desc fileds are all set.
  */
-	static inline int32_t
+static inline int32_t
 dc_dp_set_mark_pkt (
-		int32_t	port_id,
-		struct sk_buff *skb,
-		uint32_t flags
-		)
+	int32_t port_id,
+	struct sk_buff *skb,
+	uint32_t flags
+)
 {
 	struct dma_tx_desc_3 *desc_3;
 
@@ -1451,12 +1623,12 @@ dc_dp_set_mark_pkt (
   \note This utility macro will get complete mark into DMA Descriptor DWord-3,
   to indicate that the peripheral specific desc fileds are all set.
  */
-	static inline int32_t
+static inline int32_t
 dc_dp_get_mark_pkt (
-		int32_t	port_id,
-		struct sk_buff *skb,
-		uint32_t flags
-		)
+	int32_t port_id,
+	struct sk_buff *skb,
+	uint32_t flags
+)
 {
 	struct dma_tx_desc_3 *desc_3;
 
@@ -1468,7 +1640,7 @@ dc_dp_get_mark_pkt (
 }
 
 /** \brief  Disconnect a particular MAC addr or an network device - remove all MAC table entries
-  and/or routing sessions which use the specified MAC address.
+   and/or routing sessions which use the specified MAC address.
   \param[in] netif  netdevice pointer through which all entries must be removed from acceleration - optional
   \param[in] subif_id  Sub-interface identifier to remove on netif
   \param[in] mac_addr  MAC address to remove
@@ -1478,22 +1650,22 @@ dc_dp_get_mark_pkt (
  */
 int32_t
 dc_dp_disconn_if (
-		struct net_device *netif,
-		struct dp_subif *subif_id,
-		uint8_t mac_addr[MAX_ETH_ALEN],
-		uint32_t flags
-		);
+	struct net_device *netif,
+	struct dp_subif *subif_id,
+	uint8_t mac_addr[MAX_ETH_ALEN],
+	uint32_t flags
+);
 
 /** \brief  Register/De-register a DirectConnect interface to MCAST helper module
   \param[in] dev  Net device to be registered, e.g., wlan0_0.
   \param[in] owner  Kernel module pointer which owns the port.
   \param[in] cb  Multicast callback function.
   \param[in] flags  :
-  DC_DP_F_MC_REGISTER - Register a DirectConnect interface.
-  DC_DP_F_MC_DEREGISTER - De-register already registered DirectConnect interface.
-  DC_DP_F_MC_UPDATE_MAC_ADDR - Register a DirectConnect interface to get mcast SSM support.
-  DC_DP_F_MC_FW_RESET - Cleanup request on already learned entries on the registered DirectConnect interface.
-  DC_DP_F_MC_NEW_STA - Re-learn request on the registered DirectConnect interface.
+             - DC_DP_F_MC_REGISTER : Register a DirectConnect interface.
+             - DC_DP_F_MC_DEREGISTER : De-register already registered DirectConnect interface.
+             - DC_DP_F_MC_UPDATE_MAC_ADDR : Register a DirectConnect interface to get mcast SSM support.
+             - DC_DP_F_MC_FW_RESET : Cleanup request on already learned entries on the registered DirectConnect interface.
+             - DC_DP_F_MC_NEW_STA : Re-learn request on the registered DirectConnect interface.
   \return 0 if OK / -1 if error
   \note It can be skipped for specific peripheral driver if there is no notion
   of host connect/disconnect on the peripheral network/interface.
@@ -1501,27 +1673,27 @@ dc_dp_disconn_if (
  */
 int32_t
 dc_dp_register_mcast_module (
-		struct net_device *dev,
-		struct module *owner,
-		dc_dp_mcast_callback_fn_t cb,
-		uint32_t flags
-		);
+	struct net_device *dev,
+	struct module *owner,
+	dc_dp_mcast_callback_fn_t cb,
+	uint32_t flags
+);
 
 /** \brief  Provide a Priority (802.1D Priority) to Device QoS/WMM Class/TID map for the
  * given WiFi Radio/net_device
- \param[in] port_id  Port Id on which mapping is to be updated
- \param[in] netif  Pointer to stack network interface structure on which mapping is to be updated
- \param[in] prio2qos Array of priority to QoS/WMM Class/TID mapping values
- \return 0 if OK / -1 if error
- \note  One of port_id or netif must be specified
- \note The DC driver must  configure the Egress PMAC table to mark the WMM Class/TID in the descriptor DW1[7:4]
+  \param[in] port_id  Port Id on which mapping is to be updated
+  \param[in] netif  Pointer to stack network interface structure on which mapping is to be updated
+  \param[in] prio2qos Array of priority to QoS/WMM Class/TID mapping values
+  \return 0 if OK / -1 if error
+  \note  One of port_id or netif must be specified
+  \note The DC driver must  configure the Egress PMAC table to mark the WMM Class/TID in the descriptor DW1[7:4]
  */
 int32_t
 dc_dp_map_prio_devqos_class (
-		int32_t	port_id,
-		struct net_device *netif,
-		uint8_t prio2qos[DC_DP_MAX_DEV_CLASS]
-		);
+	int32_t port_id,
+	struct net_device *netif,
+	uint8_t prio2qos[DC_DP_MAX_DEV_CLASS]
+);
 
 /** \brief  Mark Dev QoS Class/WMM AC/TID in given packet
   \param[in] port_id  Port Id on which mapping is to be updated
@@ -1532,71 +1704,71 @@ dc_dp_map_prio_devqos_class (
  */
 int32_t
 dc_dp_mark_pkt_devqos (
-		int32_t	port_id,
-		struct net_device *dst_netif,
-		struct sk_buff *skb
-		);
+	int32_t port_id,
+	struct net_device *dst_netif,
+	struct sk_buff *skb
+);
 
 /** \brief  Get DirectConnect interface statistics. Either netdevice or subif_id has to be passed to this API.
   \param[in] netif  Pointer to Linux netdevice structure
   \param[in] subif_id  Datapath Port Number and Sub-Interface (if applicable else -1).
   \param[out] if_stats  Pointer to Linux rtnl_link_stats64 structure
   \param[in] flags  :
-  DC_DP_F_SUBIF_LOGICAL - to be used when the interface is subif type
+             - DC_DP_F_SUBIF_LOGICAL : to be used when the interface is subif type
   \return 0 if OK / -1 if error
  */
 int32_t
 dc_dp_get_netif_stats (
-		struct net_device *netif,
-		struct dp_subif *subif_id,
-		struct rtnl_link_stats64 *if_stats,
-		uint32_t flags
-		);
+	struct net_device *netif,
+	struct dp_subif *subif_id,
+	struct rtnl_link_stats64 *if_stats,
+	uint32_t flags
+);
 
 /** \brief  Clear DirectConnect interface statistics. Either netdevice or subif_id has to be passed.
   \param[in] netif  Pointer to Linux netdevice structure
   \param[in] subif_id  Datapath Port Number and Sub-Interface (if applicable else -1).
   \param[in] flags  Flag Type to pass additional info such as
-  DC_DP_F_SUBIF_LOGICAL - to be used when the interface is subif type
+             - DC_DP_F_SUBIF_LOGICAL : to be used when the interface is subif type
   \return 0 if OK / -1 if error
  */
 int32_t
 dc_dp_clear_netif_stats (
-		struct net_device *netif,
-		struct dp_subif *subif_id,
-		uint32_t flags
-		);
+	struct net_device *netif,
+	struct dp_subif *subif_id,
+	uint32_t flags
+);
 
 /**
  * \brief Disable or Enable Enqueue and/or Dequeue to/from peripheral in SoC.
- \param[in] port_id  Datapath Port Id
- \param[in] flags  : What to enable or disable
- DC_DP_F_ENQ_ENABLE,
- DC_DP_F_ENQ_DISABLE,
- DC_DP_F_DEQ_DISABLE,
- DC_DP_F_DEQ_ENABLE
- \return 0 if OK / -1 if error
+  \param[in] port_id  Datapath Port Id
+  \param[in] flags  : What to enable or disable
+             - DC_DP_F_ENQ_ENABLE
+             - DC_DP_F_ENQ_DISABLE
+             - DC_DP_F_DEQ_DISABLE
+             - DC_DP_F_DEQ_ENABLE
+  \return 0 if OK / -1 if error
  */
 int32_t
 dc_dp_change_dev_status_in_soc (
-		int32_t port_id,   /* Port Identifier */
-		uint32_t flags
-		);
+	int32_t port_id,   /* Port Identifier */
+	uint32_t flags
+);
 
 /**
  * \brief Flush the ring.
- \param[in] owner  Kernel module pointer which owns the port
- \param[in] port_id  Datapath Port Id
- \param[in] flags  : Reserved
- \return 0 if OK / -1 if error
+  \param[in] owner  Kernel module pointer which owns the port
+  \param[in] port_id  Datapath Port Id
+  \param[in] flags  : Reserved
+  \return 0 if OK / -1 if error
  */
 /* FIXME : Any use? */
 int32_t
 dc_dp_flush_ring (
-		struct module *owner,
-		int32_t port_id,
-		uint32_t flags
-		);
+	struct module *owner,
+	int32_t port_id,
+	uint32_t flags
+);
 
 /** \brief  Get Wake-on-LAN configuration.
   \param[in] port_id  Datapath Port Id
@@ -1606,10 +1778,10 @@ dc_dp_flush_ring (
  */
 int32_t
 dc_dp_get_wol_cfg (
-		int32_t port_id,
-		struct dc_dp_wol_cfg *cfg,
-		uint32_t flags
-		);
+	int32_t port_id,
+	struct dc_dp_wol_cfg *cfg,
+	uint32_t flags
+);
 
 /** \brief  Set Wake-on-LAN config
   \param[in] port_id  Datapath Port Id
@@ -1619,10 +1791,10 @@ dc_dp_get_wol_cfg (
  */
 int32_t
 dc_dp_set_wol_cfg (
-		int32_t port_id,
-		struct dc_dp_wol_cfg *cfg,
-		uint32_t flags
-		);
+	int32_t port_id,
+	struct dc_dp_wol_cfg *cfg,
+	uint32_t flags
+);
 
 /** \brief  Enable/Disable Wake-on-LAN functionality
   \param[in] port_id  Datapath Port Id
@@ -1631,9 +1803,9 @@ dc_dp_set_wol_cfg (
  */
 int32_t
 dc_dp_set_wol_ctrl (
-		int32_t port_id,
-		uint32_t enable
-		);
+	int32_t port_id,
+	uint32_t enable
+);
 
 /** \brief  Get Wake-on-LAN status
   \param[in] port_id  Datapath Port Id
@@ -1641,8 +1813,8 @@ dc_dp_set_wol_ctrl (
  */
 int32_t
 dc_dp_get_wol_ctrl_status (
-		int32_t port_id
-		);
+	int32_t port_id
+);
 
 /* @} */
 
@@ -1654,16 +1826,16 @@ dc_dp_get_wol_ctrl_status (
   \param[in] nb  Notifier function to register
   \param[in] notify_type  Notifier list type (DC_DP_PS_TRANSITION_NOTIFIER / DC_DP_PS_POLICY_NOTIFIER)
   \param[in] flags  :
-  -  DC_DP_F_PS_REGISTER : Register to CPUFreq framework
-  -  DC_DP_F_PS_DEREGISTER : De-register from CPUFreq framework
+             - DC_DP_F_PS_REGISTER : Register to CPUFreq framework
+             - DC_DP_F_PS_DEREGISTER : De-register from CPUFreq framework
   \return  0 if OK / < 0 if error
  */
 int32_t
 dc_dp_register_power_notifier (
-		struct notifier_block *nb,
-		uint32_t notify_type,
-		uint32_t flags
-		);
+	struct notifier_block *nb,
+	uint32_t notify_type,
+	uint32_t flags
+);
 
 /** \brief  Request new system power state
   \param[in] module  Module identifier
@@ -1673,10 +1845,10 @@ dc_dp_register_power_notifier (
  */
 int32_t
 dc_dp_req_power_state (
-		enum dc_dp_power_module module,
-		uint8_t module_nr,
-		enum dc_dp_power_state new_state
-		);
+	enum dc_dp_power_module module,
+	uint8_t module_nr,
+	enum dc_dp_power_state new_state
+);
 
 /** \brief  Get Power Mgmt polling period per module
   \param[in] module  Module identifier
@@ -1685,9 +1857,9 @@ dc_dp_req_power_state (
  */
 int32_t
 dc_dp_get_ps_poll_period (
-		enum dc_dp_power_module module,
-		uint8_t module_nr
-		);
+	enum dc_dp_power_module module,
+	uint8_t module_nr
+);
 
 /** \brief  Get power state related threshold values per module
   \param[in] module  Module identifier
@@ -1696,9 +1868,9 @@ dc_dp_get_ps_poll_period (
  */
 struct dc_dp_ps_threshold *
 dc_dp_get_ps_threshold (
-		enum dc_dp_power_module module,
-		uint8_t module_nr
-		);
+	enum dc_dp_power_module module,
+	uint8_t module_nr
+);
 
 /** \brief  Add/Delete module from CPUFReq module list
   \param[in] head  Module list head pointer
@@ -1707,9 +1879,9 @@ dc_dp_get_ps_threshold (
  */
 int32_t
 dc_dp_mod_ps_list (
-		struct list_head *head,
-		int32_t add
-		);
+	struct list_head *head,
+	int32_t add
+);
 
 /** \brief  Convert frequency to power state
   \param[in] freq_khz frequency (in khz)
@@ -1717,10 +1889,9 @@ dc_dp_mod_ps_list (
  */
 enum dc_dp_power_state
 dc_dp_get_ps_from_khz (
-		uint32_t freq_khz
-		);
+	uint32_t freq_khz
+);
 
 /* @} */
 
-
 #endif /* _UGW_DIRECTCONNECT_DP_API_H_ */
