From e828bc6bc7602d631ccaca7b2eec867c721e370a Mon Sep 17 00:00:00 2001
From: Waldemar Rymarkiewicz <waldemarx.rymarkiewicz@intel.com>
Date: Fri, 5 Oct 2018 15:54:29 +0200
Subject: [PATCH] cpufreq: conservative: Fix requested_freq handling

The governor updates dbs_info->requested_freq only after increasing or
decreasing frequency. There is, however, an use case when this is not
sufficient.

Imagine, external module constraining cpufreq policy in a way that policy->max
= policy->min = max_available_freq (eg. 1Ghz). CPUfreq will set freq to
max_freq and conservative gov will not downscale due to the limits. It will
exit instread

if (requested_freq > policy->max || requested_freq < policy->min)
        requested_freq = policy->cur;
       // max=min=1Ghz -> requested_freq=cur=1Ghz
[...]
if (requested_freq == policy->max)
        goto out;

As a result, dbs_info->requested_freq is not updated with newly calculated
requested_freq=1Ghz. Next, execution of update routine will use again
previously stored requested_freq (in my case it was min_available_freq)

[...]
unsigned int requested_freq = dbs_info->requested_freq;
[....]

Now, when external module returns to previous policy limits that is
policy->min = min_available_freq and policy->max = max_available_freq,
conservative governor is not able to decrease frequency because stored
requested_freq is still or rather already set to min_available_freq so
the check (for decreasing)

[...]
if (load < cs_tuners->down_threshold) {
[....]
       if (requested_freq == policy->min)
               goto out;
[...]

returns from routine before it does any freq change.

Signed-off-by: Waldemar Rymarkiewicz <waldemarx.rymarkiewicz@intel.com>
---
 drivers/cpufreq/cpufreq_conservative.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/drivers/cpufreq/cpufreq_conservative.c b/drivers/cpufreq/cpufreq_conservative.c
index 00a74351f623..1f661c857aec 100644
--- a/drivers/cpufreq/cpufreq_conservative.c
+++ b/drivers/cpufreq/cpufreq_conservative.c
@@ -79,8 +79,10 @@ static unsigned int cs_dbs_timer(struct cpufreq_policy *policy)
 	 * changed in the meantime, so fall back to current frequency in that
 	 * case.
 	 */
-	if (requested_freq > policy->max || requested_freq < policy->min)
+	if (requested_freq > policy->max || requested_freq < policy->min) {
 		requested_freq = policy->cur;
+		dbs_info->requested_freq = requested_freq;
+	}
 
 	/* Check for frequency increase */
 	if (load > dbs_data->up_threshold) {
