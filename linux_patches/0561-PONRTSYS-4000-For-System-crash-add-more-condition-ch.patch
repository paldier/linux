From 852abe59628d158cfdbea7c8ac2f571a41b02c5f Mon Sep 17 00:00:00 2001
From: Rekha Eswaran <rekha.eswaran@intel.com>
Date: Thu, 18 Apr 2019 11:27:41 +0800
Subject: [PATCH] PONRTSYS-4000: For System crash,add more condition check in
 dp_rx to support DSL/non-DSL case and checkpatch error and warning fix

---
 .../net/ethernet/lantiq/datapath/datapath_api.c    | 45 ++++++++++++----------
 1 file changed, 25 insertions(+), 20 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_api.c b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
index 292b9d436ebe..dcbf9fdaf0b0 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_api.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
@@ -1086,7 +1086,6 @@ int32_t dp_register_subif_ext(int inst, struct module *owner,
 					  subif_id, data, flags);
 	if (!(flags & DP_F_SUBIF_LOGICAL))
 		subifid_fn_t = port_info->cb.get_subifid_fn;
-	
 	subif_id_sync = kmalloc(sizeof(*subif_id_sync) * 2, GFP_KERNEL);
 	if (!subif_id_sync) {
 		PR_ERR("Failed to alloc %d bytes\n",
@@ -1962,7 +1961,7 @@ static int dp_handle_lct(struct pmac_port_info *dp_port,
 			 struct sk_buff *skb, dp_rx_fn_t rx_fn)
 {
 	struct sk_buff *lct_skb;
-	int vap, ret;
+	int vap;
 
 	vap = dp_port->lct_idx;
 
@@ -1970,7 +1969,7 @@ static int dp_handle_lct(struct pmac_port_info *dp_port,
 	if (skb->data[PMAC_SIZE] & 0x1) {
 		/* multicast/broadcast */
 		DP_DEBUG(DP_DBG_FLAG_PAE, "LCT mcast or broadcast\n");
-		if((STATS_GET(dp_port->subif_info[vap].rx_flag) <= 0)) {
+		if ((STATS_GET(dp_port->subif_info[vap].rx_flag) <= 0)) {
 			UP_STATS(dp_port->subif_info[vap].mib.rx_fn_dropped);
 			return 1;
 		}
@@ -1979,19 +1978,18 @@ static int dp_handle_lct(struct pmac_port_info *dp_port,
 			PR_ERR("LCT mcast/bcast skb clone fail\n");
 			return -1;
 		}
-		lct_skb->dev = dp_port->subif_info[vap].netif;	
+		lct_skb->dev = dp_port->subif_info[vap].netif;
 		UP_STATS(dp_port->subif_info[vap].mib.rx_fn_rxif_pkt);
-		DP_DEBUG(DP_DBG_FLAG_PAE, "pkt sent lct(%s) ret(%d)\n",
-			 lct_skb->dev->name ? lct_skb->dev->name : "NULL",
-			 ret);
+		DP_DEBUG(DP_DBG_FLAG_PAE, "pkt sent lct(%s)\n",
+			 lct_skb->dev->name ? lct_skb->dev->name : "NULL");
 		rx_fn(lct_skb->dev, NULL, lct_skb, lct_skb->len);
 		return 1;
 	} else if (memcmp(skb->data + PMAC_SIZE, skb->dev->dev_addr, 6) == 0) {
 		/* unicast */
 		DP_DEBUG(DP_DBG_FLAG_PAE, "LCT unicast\n");
-		DP_DEBUG(DP_DBG_FLAG_PAE, "unicast pkt sent lct(%s) ret(%d)\n",
-				 skb->dev->name ? skb->dev->name : "NULL", ret);
-		if((STATS_GET(dp_port->subif_info[vap].rx_flag) <= 0)) {
+		DP_DEBUG(DP_DBG_FLAG_PAE, "unicast pkt sent lct(%s)\n",
+			 skb->dev->name ? skb->dev->name : "NULL");
+		if ((STATS_GET(dp_port->subif_info[vap].rx_flag) <= 0)) {
 			UP_STATS(dp_port->subif_info[vap].mib.rx_fn_dropped);
 			dev_kfree_skb_any(skb);
 			return 0;
@@ -2019,7 +2017,7 @@ static inline int32_t dp_rx_one_skb(struct sk_buff *skb, uint32_t flags)
 	int vap; /*vap: 0-15 */
 	int paser_exist;
 	u32 port_id = ep; /*same with ep now, later set to sspid if ep is 0 */
-	struct net_device *dev;
+	struct net_device *dev = NULL;
 	dp_rx_fn_t rx_fn;
 	char decryp = 0;
 	u8 inst = 0;
@@ -2108,7 +2106,10 @@ static inline int32_t dp_rx_one_skb(struct sk_buff *skb, uint32_t flags)
 		desc_3->all &= dma_rx_desc_mask3.all;
 		skb->priority = desc_1->field.classid;
 		skb->dev = dp_port->subif_info[vap].netif;
-		dev = dp_port->subif_info[vap].netif;
+		if (((dp_port->alloc_flags & DP_F_FAST_DSL) == 0) && /*non-dsl*/
+			dp_port->subif_info[vap].flags) { /*not de-registered */
+			dev = dp_port->subif_info[vap].netif;
+		}
 		if (decryp) { /*workaround mark for bypass xfrm policy*/
 			desc_1->field.dec = 1;
 			desc_1->field.enc = 1;
@@ -2159,8 +2160,10 @@ static inline int32_t dp_rx_one_skb(struct sk_buff *skb, uint32_t flags)
 			if (dp_port->lct_idx > 0)
 				ret_lct = dp_handle_lct(dp_port, skb, rx_fn);
 			if (ret_lct) {
-				if((STATS_GET(dp_port->subif_info[vap].
-								rx_flag) <= 0)) {
+				if ((STATS_GET(dp_port->subif_info[vap].
+					rx_flag) <= 0) &&
+					((dp_port->alloc_flags & DP_F_FAST_DSL)
+						== 0)) {
 					UP_STATS(dp_port->subif_info[vap].
 							mib.rx_fn_dropped);
 					goto RX_DROP2;
@@ -2170,7 +2173,10 @@ static inline int32_t dp_rx_one_skb(struct sk_buff *skb, uint32_t flags)
 								rx_fn_rxif_pkt);
 			}
 		} else {
-			if((STATS_GET(dp_port->subif_info[vap].rx_flag) <= 0)) {
+			if ((STATS_GET(dp_port->subif_info[vap].
+					rx_flag) <= 0) &&
+					((dp_port->alloc_flags & DP_F_FAST_DSL)
+						== 0)) {
 				UP_STATS(dp_port->subif_info[vap].mib.
 						rx_fn_dropped);
 				goto RX_DROP2;
@@ -2690,7 +2696,6 @@ int dp_rx_enable(struct net_device *netif, char *ifname, uint32_t flags)
 	port_info = PORT(subif.inst, subif.port_id);
 	vap = GET_VAP(subif.subif, port_info->vap_offset,
 		      port_info->vap_mask);
-	
 	STATS_SET(port_info->subif_info[vap].rx_flag, flags ? 1 : 0);
 
 	return DP_SUCCESS;
@@ -2711,9 +2716,9 @@ int dp_vlan_set(struct dp_tc_vlan *vlan, int flags)
 	info.bp = subif.bport;
 	info.dp_port = subif.port_id;
 	info.inst = subif.inst;
-	
-	if ((vlan->def_apply == DP_VLAN_APPLY_CTP) && 
-				(subif.flag_pmapper == 1)) {
+
+	if ((vlan->def_apply == DP_VLAN_APPLY_CTP) &&
+	    (subif.flag_pmapper == 1)) {
 		PR_ERR("cannot apply VLAN rule for pmapper device\n");
 		return DP_FAILURE;
 	} else if (vlan->def_apply == DP_VLAN_APPLY_CTP) {
@@ -2721,7 +2726,7 @@ int dp_vlan_set(struct dp_tc_vlan *vlan, int flags)
 	} else {
 		info.dev_type |= subif.flag_bp;
 	}
-	if (vlan->mcast_flag == DP_MULTICAST_SESSION) 
+	if (vlan->mcast_flag == DP_MULTICAST_SESSION)
 		info.dev_type |= 0x02;
 	DP_DEBUG(DP_DBG_FLAG_PAE, "dev_type:0x%x\n", info.dev_type);
 	if (DP_CB(subif.inst, dp_tc_vlan_set))
