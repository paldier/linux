From 8146b28e8c3faeaf18ad4fb844e0e6a4bba29ed2 Mon Sep 17 00:00:00 2001
From: Xu Liang <liang.xu@intel.com>
Date: Fri, 6 Sep 2019 19:20:34 +0800
Subject: [PATCH] Title: Extended VLAN Rules are not configured on CTP for IGMP
 traffic Issue: PONRTSYS-5168 System Impact: After we moved Extended VLAN
 Rules for LAN interface   (eth0_0) from BP to CTP IGMP traffic is no longer
 able to pass transparently   through this interface when snooping is not
 enabled, so we do not use any   PCE rules to control it. It was possible on
 BP. Resolution: assign VLAN block to both IGMP and Non-IGMP session   by
 default and add option to assign to IGMP only session

---
 drivers/net/datapath/dpm/datapath.h                |  7 +-
 drivers/net/datapath/dpm/datapath_api.c            | 10 ++-
 .../datapath/dpm/gswip31/datapath_tc_asym_vlan.c   | 90 +++++++++++-----------
 .../datapath/dpm/gswip32/datapath_tc_asym_vlan.c   | 90 +++++++++++-----------
 include/net/datapath_api_vlan.h                    |  6 +-
 5 files changed, 106 insertions(+), 97 deletions(-)

diff --git a/drivers/net/datapath/dpm/datapath.h b/drivers/net/datapath/dpm/datapath.h
index 759a0966f05d..64c1ce0626d5 100644
--- a/drivers/net/datapath/dpm/datapath.h
+++ b/drivers/net/datapath/dpm/datapath.h
@@ -707,9 +707,10 @@ struct ext_vlan_info {
 struct dp_tc_vlan_info {
 	int dev_type; /* bit 0 - 1: apply VLAN to bp
 		       *         0: apply VLAN to subix (subif group)
-		       * bit 1 - 1: multicast session
-		       *         0: normal
-		       *
+		       * bit 1 - 0: apply VLAN to non-multicast session on CTP
+		       *         1: don't apply VLAN to non-multicast session
+		       * bit 2 - 0: apply VLAN to multicast session on CTP
+		       *         1: don't apply VLAN to multicast session
 		       */
 	int subix;  /*similar like GSWIP subif group*/
 	int bp;  /*bridge port id */
diff --git a/drivers/net/datapath/dpm/datapath_api.c b/drivers/net/datapath/dpm/datapath_api.c
index 04559aae9ced..8009ce73f7d2 100644
--- a/drivers/net/datapath/dpm/datapath_api.c
+++ b/drivers/net/datapath/dpm/datapath_api.c
@@ -2212,8 +2212,14 @@ int dp_vlan_set(struct dp_tc_vlan *vlan, int flags)
 	} else {
 		info.dev_type |= subif.flag_bp;
 	}
-	if (vlan->mcast_flag == DP_MULTICAST_SESSION)
-		info.dev_type |= 0x02;
+	switch (vlan->mcast_flag) {
+	case DP_MULTICAST_SESSION:
+		info.dev_type |= BIT(1);
+		break;
+	case DP_NON_MULTICAST_SESSION:
+		info.dev_type |= BIT(2);
+		break;
+	}
 	DP_DEBUG(DP_DBG_FLAG_PAE, "dev_type:0x%x\n", info.dev_type);
 	if (DP_CB(subif.inst, dp_tc_vlan_set))
 		return DP_CB(subif.inst, dp_tc_vlan_set)
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_tc_asym_vlan.c b/drivers/net/datapath/dpm/gswip31/datapath_tc_asym_vlan.c
index 85341fce773f..e1793b0359be 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_tc_asym_vlan.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_tc_asym_vlan.c
@@ -126,8 +126,8 @@ static int update_ctp(struct core_ops *ops,
 	ctpcfg1.nSubIfIdGroup = subifidg;
 	ctpcfg2.nSubIfIdGroup = subifidg;
 	if (ingress) {
-		if (multicast) {
-			ctpcfg1.eMask =
+		if (~multicast & BIT(2)) {
+			ctpcfg1.eMask |=
 				GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN_IGMP;
 			if (!pextvlan) {
 				ctpcfg2.bIngressExtendedVlanIgmpEnable =
@@ -139,8 +139,9 @@ static int update_ctp(struct core_ops *ops,
 					pextvlan->nExtendedVlanBlockId;
 				ctpcfg2.nIngressExtendedVlanBlockSizeIgmp = 0;
 			}
-		} else {
-			ctpcfg1.eMask = GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN;
+		}
+		if (~multicast & BIT(1)) {
+			ctpcfg1.eMask |= GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN;
 			if (!pextvlan) {
 				ctpcfg2.bIngressExtendedVlanEnable = LTQ_FALSE;
 			} else {
@@ -151,8 +152,8 @@ static int update_ctp(struct core_ops *ops,
 			}
 		}
 	} else {
-		if (multicast) {
-			ctpcfg1.eMask =
+		if (~multicast & BIT(2)) {
+			ctpcfg1.eMask |=
 				GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN_IGMP;
 			if (!pextvlan) {
 				ctpcfg2.bEgressExtendedVlanIgmpEnable =
@@ -164,8 +165,9 @@ static int update_ctp(struct core_ops *ops,
 					pextvlan->nExtendedVlanBlockId;
 				ctpcfg2.nEgressExtendedVlanBlockSizeIgmp = 0;
 			}
-		} else {
-			ctpcfg1.eMask = GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN;
+		}
+		if (~multicast & BIT(1)) {
+			ctpcfg1.eMask |= GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN;
 			if (!pextvlan) {
 				ctpcfg2.bEgressExtendedVlanEnable = LTQ_FALSE;
 			} else {
@@ -187,46 +189,44 @@ static int update_ctp(struct core_ops *ops,
 		return -EIO;
 
 	if (ingress) {
-		if (multicast) {
-			if (ctpcfg1.bIngressExtendedVlanIgmpEnable !=
-								LTQ_FALSE) {
-				GSW_EXTENDEDVLAN_alloc_t alloc = {0};
-
-				alloc.nExtendedVlanBlockId =
-					ctpcfg1.nIngressExtendedVlanBlockIdIgmp;
-				ops->gsw_extvlan_ops.ExtendedVlan_Free(ops,
-									&alloc);
-			}
-		} else {
-			if (ctpcfg1.bIngressExtendedVlanEnable != LTQ_FALSE) {
-				GSW_EXTENDEDVLAN_alloc_t alloc = {0};
+		u32 block = ~0;
 
-				alloc.nExtendedVlanBlockId =
-					ctpcfg1.nIngressExtendedVlanBlockId;
-				ops->gsw_extvlan_ops.ExtendedVlan_Free(ops,
-									&alloc);
-			}
+		if ((~multicast & BIT(2))
+		    && ctpcfg1.bIngressExtendedVlanIgmpEnable != LTQ_FALSE) {
+			GSW_EXTENDEDVLAN_alloc_t alloc = {0};
+
+			block = ctpcfg1.nIngressExtendedVlanBlockIdIgmp;
+			alloc.nExtendedVlanBlockId = block;
+			ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
+		}
+		if ((~multicast & BIT(1))
+		    && ctpcfg1.bIngressExtendedVlanEnable != LTQ_FALSE
+		    && block != ctpcfg1.nIngressExtendedVlanBlockId) {
+			GSW_EXTENDEDVLAN_alloc_t alloc = {0};
+
+			alloc.nExtendedVlanBlockId =
+				ctpcfg1.nIngressExtendedVlanBlockId;
+			ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 		}
 	} else {
-		if (multicast) {
-			if (ctpcfg1.bEgressExtendedVlanIgmpEnable !=
-								LTQ_FALSE) {
-				GSW_EXTENDEDVLAN_alloc_t alloc = {0};
-
-				alloc.nExtendedVlanBlockId =
-					ctpcfg1.nEgressExtendedVlanBlockIdIgmp;
-				ops->gsw_extvlan_ops.ExtendedVlan_Free(ops,
-									&alloc);
-			}
-		} else {
-			if (ctpcfg1.bEgressExtendedVlanEnable != LTQ_FALSE) {
-				GSW_EXTENDEDVLAN_alloc_t alloc = {0};
+		u32 block = ~0;
 
-				alloc.nExtendedVlanBlockId =
-					ctpcfg1.nEgressExtendedVlanBlockId;
-				ops->gsw_extvlan_ops.ExtendedVlan_Free(ops,
-									&alloc);
-			}
+		if ((~multicast & BIT(2))
+		    && ctpcfg1.bEgressExtendedVlanIgmpEnable != LTQ_FALSE) {
+			GSW_EXTENDEDVLAN_alloc_t alloc = {0};
+
+			block = ctpcfg1.nEgressExtendedVlanBlockIdIgmp;
+			alloc.nExtendedVlanBlockId = block;
+			ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
+		}
+		if ((~multicast & BIT(1))
+		    && ctpcfg1.bEgressExtendedVlanEnable != LTQ_FALSE
+		    && block != ctpcfg1.nEgressExtendedVlanBlockId) {
+			GSW_EXTENDEDVLAN_alloc_t alloc = {0};
+
+			alloc.nExtendedVlanBlockId =
+				ctpcfg1.nEgressExtendedVlanBlockId;
+			ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 		}
 	}
 
@@ -862,7 +862,7 @@ static int tc_ext_vlan(struct core_ops *ops,
 				 (u32)info->dp_port,
 				 (u32)info->subix,
 				 vlan->dir == DP_DIR_INGRESS,
-				 (info->dev_type & 0x02) != 0,
+				 info->dev_type & GENMASK(2, 1),
 				 total > 0 ? &alloc : NULL);
 	} else {
 		/* Configure bridge port */
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_tc_asym_vlan.c b/drivers/net/datapath/dpm/gswip32/datapath_tc_asym_vlan.c
index b9a1c74934b3..c5f4c97b2569 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_tc_asym_vlan.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_tc_asym_vlan.c
@@ -126,8 +126,8 @@ static int update_ctp(struct core_ops *ops,
 	ctpcfg1.nSubIfIdGroup = subifidg;
 	ctpcfg2.nSubIfIdGroup = subifidg;
 	if (ingress) {
-		if (multicast) {
-			ctpcfg1.eMask =
+		if (~multicast & BIT(2)) {
+			ctpcfg1.eMask |=
 				GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN_IGMP;
 			if (!pextvlan) {
 				ctpcfg2.bIngressExtendedVlanIgmpEnable =
@@ -139,8 +139,9 @@ static int update_ctp(struct core_ops *ops,
 					pextvlan->nExtendedVlanBlockId;
 				ctpcfg2.nIngressExtendedVlanBlockSizeIgmp = 0;
 			}
-		} else {
-			ctpcfg1.eMask = GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN;
+		}
+		if (~multicast & BIT(1)) {
+			ctpcfg1.eMask |= GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN;
 			if (!pextvlan) {
 				ctpcfg2.bIngressExtendedVlanEnable = LTQ_FALSE;
 			} else {
@@ -151,8 +152,8 @@ static int update_ctp(struct core_ops *ops,
 			}
 		}
 	} else {
-		if (multicast) {
-			ctpcfg1.eMask =
+		if (~multicast & BIT(2)) {
+			ctpcfg1.eMask |=
 				GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN_IGMP;
 			if (!pextvlan) {
 				ctpcfg2.bEgressExtendedVlanIgmpEnable =
@@ -164,8 +165,9 @@ static int update_ctp(struct core_ops *ops,
 					pextvlan->nExtendedVlanBlockId;
 				ctpcfg2.nEgressExtendedVlanBlockSizeIgmp = 0;
 			}
-		} else {
-			ctpcfg1.eMask = GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN;
+		}
+		if (~multicast & BIT(1)) {
+			ctpcfg1.eMask |= GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN;
 			if (!pextvlan) {
 				ctpcfg2.bEgressExtendedVlanEnable = LTQ_FALSE;
 			} else {
@@ -187,46 +189,44 @@ static int update_ctp(struct core_ops *ops,
 		return -EIO;
 
 	if (ingress) {
-		if (multicast) {
-			if (ctpcfg1.bIngressExtendedVlanIgmpEnable !=
-								LTQ_FALSE) {
-				GSW_EXTENDEDVLAN_alloc_t alloc = {0};
-
-				alloc.nExtendedVlanBlockId =
-					ctpcfg1.nIngressExtendedVlanBlockIdIgmp;
-				ops->gsw_extvlan_ops.ExtendedVlan_Free(ops,
-									&alloc);
-			}
-		} else {
-			if (ctpcfg1.bIngressExtendedVlanEnable != LTQ_FALSE) {
-				GSW_EXTENDEDVLAN_alloc_t alloc = {0};
+		u32 block = ~0;
 
-				alloc.nExtendedVlanBlockId =
-					ctpcfg1.nIngressExtendedVlanBlockId;
-				ops->gsw_extvlan_ops.ExtendedVlan_Free(ops,
-									&alloc);
-			}
+		if ((~multicast & BIT(2))
+		    && ctpcfg1.bIngressExtendedVlanIgmpEnable != LTQ_FALSE) {
+			GSW_EXTENDEDVLAN_alloc_t alloc = {0};
+
+			block = ctpcfg1.nIngressExtendedVlanBlockIdIgmp;
+			alloc.nExtendedVlanBlockId = block;
+			ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
+		}
+		if ((~multicast & BIT(1))
+		    && ctpcfg1.bIngressExtendedVlanEnable != LTQ_FALSE
+		    && block != ctpcfg1.nIngressExtendedVlanBlockId) {
+			GSW_EXTENDEDVLAN_alloc_t alloc = {0};
+
+			alloc.nExtendedVlanBlockId =
+				ctpcfg1.nIngressExtendedVlanBlockId;
+			ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 		}
 	} else {
-		if (multicast) {
-			if (ctpcfg1.bEgressExtendedVlanIgmpEnable !=
-								LTQ_FALSE) {
-				GSW_EXTENDEDVLAN_alloc_t alloc = {0};
-
-				alloc.nExtendedVlanBlockId =
-					ctpcfg1.nEgressExtendedVlanBlockIdIgmp;
-				ops->gsw_extvlan_ops.ExtendedVlan_Free(ops,
-									&alloc);
-			}
-		} else {
-			if (ctpcfg1.bEgressExtendedVlanEnable != LTQ_FALSE) {
-				GSW_EXTENDEDVLAN_alloc_t alloc = {0};
+		u32 block = ~0;
 
-				alloc.nExtendedVlanBlockId =
-					ctpcfg1.nEgressExtendedVlanBlockId;
-				ops->gsw_extvlan_ops.ExtendedVlan_Free(ops,
-									&alloc);
-			}
+		if ((~multicast & BIT(2))
+		    && ctpcfg1.bEgressExtendedVlanIgmpEnable != LTQ_FALSE) {
+			GSW_EXTENDEDVLAN_alloc_t alloc = {0};
+
+			block = ctpcfg1.nEgressExtendedVlanBlockIdIgmp;
+			alloc.nExtendedVlanBlockId = block;
+			ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
+		}
+		if ((~multicast & BIT(1))
+		    && ctpcfg1.bEgressExtendedVlanEnable != LTQ_FALSE
+		    && block != ctpcfg1.nEgressExtendedVlanBlockId) {
+			GSW_EXTENDEDVLAN_alloc_t alloc = {0};
+
+			alloc.nExtendedVlanBlockId =
+				ctpcfg1.nEgressExtendedVlanBlockId;
+			ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 		}
 	}
 
@@ -835,7 +835,7 @@ static int tc_ext_vlan(struct core_ops *ops,
 				 (u32)info->dp_port,
 				 (u32)info->subix,
 				 vlan->dir == DP_DIR_INGRESS,
-				 (info->dev_type & 0x02) != 0,
+				 info->dev_type & GENMASK(2, 1),
 				 total > 0 ? &alloc : NULL);
 	} else {
 		/* Configure bridge port */
diff --git a/include/net/datapath_api_vlan.h b/include/net/datapath_api_vlan.h
index d8b859886f78..f844f1fff997 100644
--- a/include/net/datapath_api_vlan.h
+++ b/include/net/datapath_api_vlan.h
@@ -140,8 +140,10 @@ struct dp_tc_vlan {
 #define DP_DIR_INGRESS 0
 #define DP_DIR_EGRESS  1
 	int dir; /* DP_DIR_INGRESS(0) and DP_DIR_EGRESS(1) */
-#define DP_MULTICAST_SESSION 1  /*IGMP Multicast session */
-	int mcast_flag; /*normal or multicast session */
+#define DP_MULTICAST_SESSION		1  /* IGMP Multicast session only */
+#define DP_NON_MULTICAST_SESSION	2  /* Non-IGMP Multicast Session only */
+	int mcast_flag; /*normal, multicast only, or non-multicast only
+			  session */
 
 	int n_vlan0, n_vlan1, n_vlan2; /*size of vlan0/vlan1/2_list*/
 	struct dp_vlan0 *vlan0_list; /* non-vlan matching rules,
