From 23eec64682cf0a6a3ffb8a63c9fecccff6c52870 Mon Sep 17 00:00:00 2001
From: ofirbitt <ofir1.bitton@intel.com>
Date: Thu, 6 Jun 2019 14:52:38 +0300
Subject: [PATCH] PONRTSYS-4204: PPv4 QoS - Disable octet optimizations

---
 drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_fw.c   |  5 ++-
 drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c |  8 ++--
 .../net/ethernet/lantiq/ppv4/qos/pp_qos_utils.c    | 45 +++++++++++++++++-----
 .../net/ethernet/lantiq/ppv4/qos/pp_qos_utils.h    | 24 +++++++++---
 4 files changed, 61 insertions(+), 21 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_fw.c b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_fw.c
index 21abaa881b99..7772d126ab73 100644
--- a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_fw.c
+++ b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_fw.c
@@ -3158,8 +3158,9 @@ void enqueue_cmds(struct pp_qos_dev *qdev)
 				continue;
 			}
 
-			rc = get_port_phy_queues(qdev, id, rlms, rlm_ids,
-						 NUM_OF_QUEUES, &num_queues);
+			rc = get_active_port_phy_queues(qdev, id, rlms,
+							rlm_ids, NUM_OF_QUEUES,
+							&num_queues);
 			if (rc) {
 				pr_err("Failed fetching port queues\n");
 				kfree(rlms);
diff --git a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c
index f383d2083fba..ac0bd3d18b1c 100644
--- a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c
+++ b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c
@@ -588,8 +588,8 @@ int pp_qos_port_get_queues(
 	return rc;
 }
 
-int get_port_phy_queues(struct pp_qos_dev *qdev, u32 port_id,
-			u16 *rlms, u16 *ids, u32 size, u32 *queues_num)
+int get_active_port_phy_queues(struct pp_qos_dev *qdev, u32 port_id,
+			       u16 *rlms, u16 *ids, u32 size, u32 *queues_num)
 {
 	s32 rc = 0;
 	u32 phy;
@@ -607,8 +607,8 @@ int get_port_phy_queues(struct pp_qos_dev *qdev, u32 port_id,
 	}
 
 	phy = get_phy_from_node(qdev->nodes, node);
-	get_port_rlms(qdev, phy, rlms, size, queues_num);
-	get_node_queues(qdev, phy, ids, size, queues_num);
+	get_active_port_rlms(qdev, phy, rlms, size, queues_num);
+	get_active_node_queues(qdev, phy, ids, size, queues_num);
 out:
 	return rc;
 }
diff --git a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_utils.c b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_utils.c
index e007a7d9e1d4..dda643ae27fa 100644
--- a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_utils.c
+++ b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_utils.c
@@ -1731,6 +1731,13 @@ static int node_queue_wrapper(const struct pp_qos_dev *qdev,
 	return node_used(node) && (node->type == TYPE_QUEUE);
 }
 
+static int node_active_queue_wrapper(const struct pp_qos_dev *qdev,
+				     const struct qos_node *node, void *data)
+{
+	return node_used(node) && (node->type == TYPE_QUEUE) &&
+		(!QOS_BITS_IS_SET(node->flags, QOS_NODE_FLAGS_QUEUE_BLOCKED));
+}
+
 void get_node_queues(struct pp_qos_dev *qdev,
 		unsigned int phy, uint16_t *queue_ids,
 		unsigned int size, unsigned int *queues_num)
@@ -1744,8 +1751,21 @@ void get_node_queues(struct pp_qos_dev *qdev,
 			update_ids_container, &data);
 }
 
-void get_port_rlms(struct pp_qos_dev *qdev, u32 phy,
-		   u16 *rlms, u32 size, u32 *queues_num)
+void get_active_node_queues(struct pp_qos_dev *qdev,
+			    unsigned int phy, uint16_t *queue_ids,
+			    unsigned int size, unsigned int *queues_num)
+{
+	struct ids_container_metadata data = {0, queue_ids, size};
+
+	if (queue_ids == NULL)
+		data.size = 0;
+	*queues_num = post_order_travers_tree(qdev, phy,
+			node_active_queue_wrapper, NULL,
+			update_ids_container, &data);
+}
+
+void get_active_port_rlms(struct pp_qos_dev *qdev, u32 phy,
+			  u16 *rlms, u32 size, u32 *queues_num)
 {
 	struct rlm_container_metadata data = {0, rlms, size};
 
@@ -1753,7 +1773,7 @@ void get_port_rlms(struct pp_qos_dev *qdev, u32 phy,
 		data.size = 0;
 
 	*queues_num = post_order_travers_tree(qdev, phy,
-					      node_queue_wrapper, NULL,
+					      node_active_queue_wrapper, NULL,
 					      update_rlm_container, &data);
 }
 
@@ -2532,10 +2552,14 @@ static unsigned int phy_alloc_parent_has_less_than_8_children(
 				    get_phy_from_node(qdev->nodes, parent));
 
 	if (parent->parent_prop.num_of_children == 0) {
-		octet = octet_get_with_at_least_free_entries(qdev->octets, 1);
+		octet = octet_get_with_at_least_free_entries(qdev->octets, 8);
 		if (!QOS_OCTET_VALID(octet)) {
-			QOS_LOG("could not find free octet\n");
-			return QOS_INVALID_PHY;
+			octet = octet_get_with_at_least_free_entries(
+				qdev->octets, 1);
+			if (!QOS_OCTET_VALID(octet)) {
+				QOS_LOG("could not find free octet\n");
+				return QOS_INVALID_PHY;
+			}
 		}
 		phy = octet * 8 + octet_get_use_count(qdev->octets, octet);
 	} else {
@@ -2601,10 +2625,13 @@ static unsigned int create_internal_scheduler_on_node(
 	uint32_t modified;
 	struct pp_qos_sched_conf conf;
 
-	octet = octet_get_with_at_least_free_entries(qdev->octets, 2);
+	octet = octet_get_with_at_least_free_entries(qdev->octets, 8);
 	if (!QOS_OCTET_VALID(octet)) {
-		QOS_LOG("could not find free octet\n");
-		return  QOS_INVALID_PHY;
+		octet = octet_get_with_at_least_free_entries(qdev->octets, 2);
+		if (!QOS_OCTET_VALID(octet)) {
+			QOS_LOG("could not find free octet\n");
+			return  QOS_INVALID_PHY;
+		}
 	}
 
 	/*
diff --git a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_utils.h b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_utils.h
index 4a3984fa7cac..60a121b378f7 100644
--- a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_utils.h
+++ b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_utils.h
@@ -576,16 +576,16 @@ void node_init(const struct pp_qos_dev *qdev,
 	       unsigned int child);
 
 /**
- * get_port_rlms() - Return all rlms on a subtree
+ * get_port_rlms() - Return all active rlms on a subtree
  * @qdev:
  * @phy:       Phy of subtree's node
  * @rlms:      Array to store the rlms - may be NULL
  * @size:      Size of array - may be 0
  * @queues_num: The number of queues on the subtree
  */
-void get_port_rlms(struct pp_qos_dev *qdev, u32 phy,
-		   u16 *rlms,
-		   u32 size, u32 *queues_num);
+void get_active_port_rlms(struct pp_qos_dev *qdev, u32 phy,
+			  u16 *rlms,
+			  u32 size, u32 *queues_num);
 
 /**
  * get_node_queues() - Return all queues on a subtree
@@ -599,6 +599,18 @@ void get_node_queues(struct pp_qos_dev *qdev, unsigned int phy,
 		     uint16_t *queue_ids,
 		     unsigned int size, unsigned int *queues_num);
 
+/**
+ * get_node_queues() - Return all active queues on a subtree
+ * @qdev:
+ * @phy:       Phy of subtree's node
+ * @queue_ids: Array to store the queues ids - may be NULL
+ * @size:      Size of array - may be 0
+ * @queues_num: The number of queues on the subtree
+ */
+void get_active_node_queues(struct pp_qos_dev *qdev, unsigned int phy,
+			    uint16_t *queue_ids,
+			    unsigned int size, unsigned int *queues_num);
+
 int check_sync_with_fw(struct pp_qos_dev *qdev);
 
 /**
@@ -692,8 +704,8 @@ int allocate_ddr_for_qm(struct pp_qos_dev *qdev);
 int allocate_ddr_for_qm_on_platform(struct pp_qos_dev *qdev);
 int check_sync_with_fw(struct pp_qos_dev *qdev);
 
-int get_port_phy_queues(struct pp_qos_dev *qdev, u32 port_id,
-			u16 *rlms, u16 *ids, u32 size, u32 *queues_num);
+int get_active_port_phy_queues(struct pp_qos_dev *qdev, u32 port_id,
+			       u16 *rlms, u16 *ids, u32 size, u32 *queues_num);
 int store_port_queue_max_allowed(struct pp_qos_dev *qdev,
 				 u32 port_id, u16 *rlms,
 				 u16 *rlms_ids,
