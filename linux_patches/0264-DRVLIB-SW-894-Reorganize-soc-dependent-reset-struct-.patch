From 261e85803bca1fc1fedd3a93264428808beaf58f Mon Sep 17 00:00:00 2001
From: Peter Harliman Liem <peter.harliman.liem@intel.com>
Date: Thu, 6 Sep 2018 14:43:17 +0800
Subject: [PATCH] DRVLIB_SW-894 - Reorganize soc-dependent reset struct in
 gphy-fw driver

---
 drivers/net/ethernet/lantiq/xrx500_phy_fw.c | 103 +++++++++++++++-------------
 1 file changed, 56 insertions(+), 47 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/xrx500_phy_fw.c b/drivers/net/ethernet/lantiq/xrx500_phy_fw.c
index bc44fc893326..03c0f64827ed 100644
--- a/drivers/net/ethernet/lantiq/xrx500_phy_fw.c
+++ b/drivers/net/ethernet/lantiq/xrx500_phy_fw.c
@@ -17,15 +17,33 @@
 
 #define XRX200_GPHY_FW_ALIGN	(16 * 1024)
 
+#define XRX500_GPHY_NUM 5 /* phy2-5 + phyf */
+struct xrx500_reset_control {
+	struct reset_control *phy[XRX500_GPHY_NUM];
+};
+
+struct prx300_reset_control {
+	struct reset_control *gphy;
+	struct reset_control *gphy_cdb;
+	struct reset_control *gphy_pwr_down;
+};
+
 struct xway_gphy_data {
 	struct device *dev;
 
-	struct reset_control *phy_rst[5];
 	size_t fw_size;
 	dma_addr_t dma_addr;
 	void *virt_addr;
 
-	/* SoC specific functions/data */
+	/* Number of resets and names are SoC specific. Hence we place it as
+	 * union here.
+	 */
+	union {
+		struct xrx500_reset_control xrx500;
+		struct prx300_reset_control prx300;
+	} rst;
+
+	/* SoC specific functions */
 	const struct xway_gphy_soc_data {
 		int (*boot_func)(struct xway_gphy_data *);
 		int (*dt_parse_func)(struct xway_gphy_data *);
@@ -93,17 +111,18 @@ static void gsw_reg_w32_mask(u32 base, u32 clear, u32 val, u32 reg_off)
 static int xrx500_gphy_boot(struct xway_gphy_data *priv)
 {
 	int i;
+	struct xrx500_reset_control *rst = &priv->rst.xrx500;
 
-	for (i = 0; i < 5; i++) {
-		if (!priv->phy_rst[i])
+	for (i = 0; i < XRX500_GPHY_NUM; i++) {
+		if (!rst->phy[i])
 			continue;
 
-		reset_control_assert(priv->phy_rst[i]);
+		reset_control_assert(rst->phy[i]);
 		gsw_reg_w32(GSW_L_TOP_BASE, (priv->dma_addr & 0xFFFF),
 			    xrx500_gphy[i]);
 		gsw_reg_w32(GSW_L_TOP_BASE, ((priv->dma_addr >> 16) & 0xFFFF),
 			    (xrx500_gphy[i] + 4));
-		reset_control_deassert(priv->phy_rst[i]);
+		reset_control_deassert(rst->phy[i]);
 		dev_info(priv->dev, "booting GPHY%u firmware for GRX500\n", i);
 	}
 
@@ -112,24 +131,18 @@ static int xrx500_gphy_boot(struct xway_gphy_data *priv)
 
 static int xrx500_dt_parse(struct xway_gphy_data *priv)
 {
-	struct property *pp;
-	unsigned char *phyids;
-	char phy_str[16];
+	char phy_str[8];
 	int i;
-	int ret;
-
-	pp = of_find_property(priv->dev->of_node, "phy_id", NULL);
-	if (!pp)
-		return -ENOENT;
+	struct xrx500_reset_control *rst = &priv->rst.xrx500;
 
-	phyids = pp->value;
-	for (i = 0; i < pp->length && !ret; i++) {
-		sprintf(phy_str, "phy%d", phyids[i]);
+	for (i = 0; i < XRX500_GPHY_NUM; i++) {
+		snprintf(phy_str, sizeof(phy_str), "phy%d", i);
 
-		priv->phy_rst[i] = devm_reset_control_get(priv->dev, phy_str);
-		if (IS_ERR(priv->phy_rst[i])) {
+		rst->phy[i] = devm_reset_control_get_optional(priv->dev,
+							      phy_str);
+		if (IS_ERR(rst->phy[i])) {
 			dev_err(priv->dev, "fail to get %s prop\n", phy_str);
-			return PTR_ERR(priv->phy_rst[i]);
+			return PTR_ERR(rst->phy[i]);
 		}
 	}
 
@@ -139,6 +152,7 @@ static int xrx500_dt_parse(struct xway_gphy_data *priv)
 /* prx300 specific boot sequence */
 static int prx300_gphy_boot(struct xway_gphy_data *priv)
 {
+	struct prx300_reset_control *rst = &priv->rst.prx300;
 	void *virt_addr;
 
 	/* Temporary workaround for PRX300 GPHY issue.
@@ -161,16 +175,16 @@ static int prx300_gphy_boot(struct xway_gphy_data *priv)
 	gsw_reg_w32_mask(PRX300_CHIP_TOP, 0x2, 0x0, PRX300_IFMUX_CFG);
 
 	/* GPHY reset */
-	reset_control_assert(priv->phy_rst[0]);
-	udelay(500);
+	reset_control_assert(rst->gphy);
+	usleep_range(500, 1000);
 
 	/* CDB and Power Down */
-	reset_control_assert(priv->phy_rst[1]);
-	reset_control_assert(priv->phy_rst[2]);
-	udelay(400);
+	reset_control_assert(rst->gphy_cdb);
+	reset_control_assert(rst->gphy_pwr_down);
+	usleep_range(400, 1000);
 
 	/* release CDB reset */
-	reset_control_deassert(priv->phy_rst[1]);
+	reset_control_deassert(rst->gphy_cdb);
 
 	/* GPHY FW address and pin strapping */
 	gsw_reg_w32(PRX300_GPHY_CGU_BASE, priv->dma_addr, PRX300_GPHY_FCR);
@@ -180,11 +194,11 @@ static int prx300_gphy_boot(struct xway_gphy_data *priv)
 		    PRX300_GPHY0_GPS1);
 
 	/* release GPHY reset */
-	reset_control_deassert(priv->phy_rst[0]);
-	udelay(500);
+	reset_control_deassert(rst->gphy);
+	usleep_range(500, 1000);
 
 	/* GPHY Power on */
-	reset_control_deassert(priv->phy_rst[2]);
+	reset_control_deassert(rst->gphy_pwr_down);
 
 	/* Set divider and misc config */
 	gsw_reg_w32_mask(PRX300_GPHY_CDB_PDI_BASE, 0xFFF0,
@@ -209,29 +223,24 @@ static int prx300_gphy_boot(struct xway_gphy_data *priv)
 
 static int prx300_dt_parse(struct xway_gphy_data *priv)
 {
-	char phy_str[16];
+	struct prx300_reset_control *rst = &priv->rst.prx300;
 
-	sprintf(phy_str, "phy%d", 0);
-	priv->phy_rst[0] = devm_reset_control_get(priv->dev, phy_str);
-	if (IS_ERR(priv->phy_rst[0])) {
-		dev_err(priv->dev, "fail to get %s prop\n", phy_str);
-		return PTR_ERR(priv->phy_rst[0]);
+	rst->gphy = devm_reset_control_get(priv->dev, "gphy");
+	if (IS_ERR(rst->gphy)) {
+		dev_err(priv->dev, "fail to get gphy prop\n");
+		return PTR_ERR(rst->gphy);
 	}
 
-	/* phy cdb reset */
-	sprintf(phy_str, "phy_cdb%d", 0);
-	priv->phy_rst[1] = devm_reset_control_get(priv->dev, phy_str);
-	if (IS_ERR(priv->phy_rst[1])) {
-		dev_err(priv->dev, "fail to get %s prop\n", phy_str);
-		return PTR_ERR(priv->phy_rst[1]);
+	rst->gphy_cdb = devm_reset_control_get(priv->dev, "gphy_cdb");
+	if (IS_ERR(rst->gphy_cdb)) {
+		dev_err(priv->dev, "fail to get gphy_cdb prop\n");
+		return PTR_ERR(rst->gphy_cdb);
 	}
 
-	/* phy power down */
-	sprintf(phy_str, "phy_pwr_down%d", 0);
-	priv->phy_rst[2] = devm_reset_control_get(priv->dev, phy_str);
-	if (IS_ERR(priv->phy_rst[2])) {
-		dev_err(priv->dev, "fail to get %s prop\n", phy_str);
-		return PTR_ERR(priv->phy_rst[2]);
+	rst->gphy_pwr_down = devm_reset_control_get(priv->dev, "gphy_pwr_down");
+	if (IS_ERR(rst->gphy_pwr_down)) {
+		dev_err(priv->dev, "fail to get gphy_pwr_down prop\n");
+		return PTR_ERR(rst->gphy_pwr_down);
 	}
 
 	return 0;
