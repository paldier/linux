From 861d3840383d1129bcdba17f6156c1e2ba918f36 Mon Sep 17 00:00:00 2001
From: Hua Ma <hua.ma@linux.intel.com>
Date: Thu, 21 Jun 2018 17:37:53 +0800
Subject: [PATCH] Add support for lantiq ppv4 driver

---
 drivers/net/ethernet/lantiq/ppv4/Kconfig        |  45 ++
 drivers/net/ethernet/lantiq/ppv4/Makefile       |  13 +
 drivers/net/ethernet/lantiq/ppv4/bm_drv_slim.c  | 562 +++++++++++++++
 drivers/net/ethernet/lantiq/ppv4/qos_drv_slim.c | 488 +++++++++++++
 include/net/bm_drv_slim.h                       | 401 +++++++++++
 include/net/pp_bm_regs.h                        |  86 +++
 include/net/pp_qos_drv.h                        | 908 ++++++++++++++++++++++++
 include/net/pp_qos_drv_slim.h                   | 305 ++++++++
 8 files changed, 2808 insertions(+)

diff --git a/drivers/net/ethernet/lantiq/ppv4/Kconfig b/drivers/net/ethernet/lantiq/ppv4/Kconfig
new file mode 100644
index 000000000000..ad99d326d1cf
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/ppv4/Kconfig
@@ -0,0 +1,45 @@
+#
+# PPV4 QOS AND BM configuration
+#
+config LTQ_PPV4
+	bool "Buffer Manager and QOS Driver"
+	depends on SOC_GRX500
+	default n
+
+	---help---
+	Turn on this option to enable BM and QOS driver which is a special hardware
+	present in the FALCONMX series of SoCs to manage the network buffers
+	in HW.
+
+# fallback if full driver is not included
+config LTQ_PPV4_QOS_SLIM
+	bool
+	depends on LTQ_PPV4 && !LTQ_PPV4_QOS
+	default y
+
+config LTQ_PPV4_QOS
+	tristate "QoS driver"
+	depends on LTQ_PPV4
+	---help---
+	  This is the driver for the PPv4 QoS hardware in Falcon Mountain.
+
+	  To compile this driver as a module, choose M here. The module
+	  will be called pp_qos_drv.
+
+config LTQ_PPV4_QOS_TEST
+	bool "Enable test code for QoS driver"
+	depends on LTQ_PPV4_QOS
+
+
+config LTQ_PPV4_BM_SLIM
+	bool
+	depends on LTQ_PPV4 && !LTQ_PPV4_BM
+	default y
+
+config LTQ_PPV4_BM
+	tristate "BM driver"
+	depends on LTQ_PPV4
+	---help---
+	  This is the driver for the PPv4 BM hardware in Falcon Mountain.
+	  To compile this driver as a module, choose M here. The module
+	  will be called pp_bm_drv.
diff --git a/drivers/net/ethernet/lantiq/ppv4/Makefile b/drivers/net/ethernet/lantiq/ppv4/Makefile
new file mode 100644
index 000000000000..54a712a5f072
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/ppv4/Makefile
@@ -0,0 +1,13 @@
+#
+# Makefile for BM and QoS drivers.
+#
+
+# initial small drivers
+#obj-$(CONFIG_LTQ_PPV4) += bm_drv_slim.o
+obj-$(CONFIG_LTQ_PPV4_BM_SLIM) += bm_drv_slim.o
+obj-$(CONFIG_LTQ_PPV4_QOS_SLIM) += qos_drv_slim.o
+
+# full drivers
+obj-$(CONFIG_LTQ_PPV4_QOS) += qos/
+#obj-$(CONFIG_LTQ_PPV4) += bm/
+obj-$(CONFIG_LTQ_PPV4_BM) += bm/
diff --git a/drivers/net/ethernet/lantiq/ppv4/bm_drv_slim.c b/drivers/net/ethernet/lantiq/ppv4/bm_drv_slim.c
new file mode 100644
index 000000000000..65f4dc43d018
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/ppv4/bm_drv_slim.c
@@ -0,0 +1,562 @@
+/*
+ *	driver:		buffer_manager platform device driver
+ *	@file		bmgr_drv.c
+ *	@brief:		Interim ppv4 buffer manager driver
+ *	 	based on register configuration given by SOC verification team
+ *	@author:	Kavitha
+ *	@date:		25/08/2017
+ */
+
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/device.h>
+#include <linux/inetdevice.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/bitops.h>
+#include <linux/byteorder/generic.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/pid.h>
+#include <linux/pid_namespace.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <lantiq.h>
+#include <lantiq_soc.h>
+#include <net/pp_bm_regs.h>
+#include <net/bm_drv_slim.h>
+
+
+#define BM_CHIPTEST_DRIVER
+//#undef BM_CHIPTEST_DRIVER
+
+#ifdef BM_CHIPTEST_DRIVER
+#define xrx500_bm_r32(m_reg) 0
+#define xrx500_bm_w32(m_reg, val)
+#define xrx500_bm_w32_mask(m, clear, set, reg)
+#define set_val_bm(reg, val, mask, offset)
+#else
+#define xrx500_bm_r32(m_reg)		__raw_readl(m_reg)
+#define xrx500_bm_w32(m_reg, val)	__raw_writel(val, m_reg)
+#define xrx500_bm_w32_mask(m, clear, set, reg) \
+		ltq_w32((ltq_r32((m) + (reg)) & ~(clear)) | (set), \
+		(m) + (reg))
+
+#define set_val_bm(reg, val, mask, offset) \
+do {\
+	xrx500_bm_w32(reg, xrx500_bm_r32(reg) & ~(mask));\
+	xrx500_bm_w32(reg, xrx500_bm_r32(reg)\
+	| (((val) << (offset)) & (mask)));\
+} while (0)
+
+#endif
+
+void __iomem *bm_config_addr_base;
+void __iomem *bm_policy_mngr_addr_base;
+
+#define BM_BASE	(bm_config_addr_base)
+#define BM_RAM_BASE	(bm_policy_mngr_addr_base)
+
+void*	pointers_table[PP_BMGR_MAX_POOLS] = {NULL};
+void*	pointers_table_1 = NULL;
+void*	pointers_table_2 = NULL;
+void*	pointers_table_3 = NULL;
+u32*	temp_pointers_table_ptr = NULL;
+u32	user_array_ptr;
+#define num_buf 128
+struct device *g_bm_dev;
+
+void* CONFIG_CQEM_BUF_BASE[PP_BMGR_MAX_POOLS];
+void* CONFIG_CQEM_BUF_LLK_BASE[PP_BMGR_MAX_POOLS];
+#define CQEM_FORCE_COUNT_NUM 0x80
+
+static void buf_addr_adjust(unsigned int buf_base_addr,
+		     unsigned int buf_size,
+		     unsigned int *adjusted_buf_base,
+		     unsigned int *adjusted_buf_size,
+		     unsigned int align)
+{
+	unsigned int base;
+	unsigned int size;
+	base = ALIGN(buf_base_addr, align);
+	size = buf_base_addr + buf_size - base;
+
+	*adjusted_buf_base = base;
+	*adjusted_buf_size = size;
+}
+
+
+
+static void qose_reg_rd_poll (void * reg, uint32_t val, uint32_t offset)
+{
+#ifndef BM_CHIPTEST_DRIVER
+	uint32_t tmpreg;
+
+	while (1) {
+		tmpreg = xrx500_bm_r32(reg) & (1 << offset);
+		if (tmpreg == (val << offset))
+			break;
+	}
+#endif
+}
+
+#ifdef BM_CHIPTEST_DRIVER
+static void qose_reg_rd_poll_2 (void * reg, uint32_t val, uint32_t offset)
+{
+	uint32_t tmpreg;
+
+	while (1) {
+		tmpreg = xrx500_bm_r32(reg) & (1 << offset);
+		if (tmpreg == (val << offset))
+			break;
+	}
+}
+#endif
+
+s32 bmgr_pool_configure(const struct bmgr_pool_params* const pool_params, u8* const pool_id)
+{
+	
+	int index;
+	int adjusted_size;
+	u32 phy_ll_base;
+	u32 reg;
+	int l_pool_id = (int)*pool_id;
+	void* bm_buf_llk_base;
+	void* bm_buf_llk_base_adjust;
+	dma_addr_t dma_handle;
+
+	pr_info("Configuring buffer manager pool..%d\n", l_pool_id);
+
+	pointers_table[l_pool_id] = kzalloc(sizeof(u32) * (pool_params->num_buffers + 64), GFP_KERNEL);
+	buf_addr_adjust((u32)pointers_table[l_pool_id],
+			sizeof(u32) * (pool_params->num_buffers + 64),
+			(u32 *)&pointers_table[l_pool_id],
+			&adjusted_size,
+			64);
+	if (pointers_table[l_pool_id] == NULL) {
+		pr_info("bmgr_pool_configure: Failed to allocate pointers_table, num_buffers %d", pool_params->num_buffers);
+		return -1;
+	}
+	temp_pointers_table_ptr = (u32 *)pointers_table[l_pool_id];
+	user_array_ptr = pool_params->base_addr_low;
+	for (index = 0; index < pool_params->num_buffers; index++) {
+		*temp_pointers_table_ptr = user_array_ptr >> 6;
+		temp_pointers_table_ptr++;
+		user_array_ptr += pool_params->size_of_buffer;
+	}
+	phy_ll_base = dma_map_single(g_bm_dev, (void *)pointers_table[l_pool_id],
+				      (pool_params->num_buffers * 4), DMA_TO_DEVICE);
+
+	CONFIG_CQEM_BUF_BASE[l_pool_id] = (void*) pool_params->base_addr_low;
+	bm_buf_llk_base = dma_alloc_attrs(g_bm_dev, sizeof(u32) * (pool_params->num_buffers + 64),
+					  &dma_handle,
+					  GFP_KERNEL,
+					  0);
+
+	if (!bm_buf_llk_base) {
+		pr_err("Error in pool %d linklist allocation\n", l_pool_id);
+		return -1;
+	}
+	buf_addr_adjust(bm_buf_llk_base,
+			sizeof(u32) * (pool_params->num_buffers + 64),
+			(u32 *)&bm_buf_llk_base_adjust, &adjusted_size,
+			64);
+
+	if (bm_buf_llk_base_adjust > bm_buf_llk_base)
+		CONFIG_CQEM_BUF_LLK_BASE[l_pool_id] = dma_handle + (bm_buf_llk_base_adjust - bm_buf_llk_base);
+	else
+		CONFIG_CQEM_BUF_LLK_BASE[l_pool_id] = dma_handle - (bm_buf_llk_base - bm_buf_llk_base_adjust);
+
+	xrx500_bm_w32(BMGR_POOL_SIZE_REG_ADDR(BM_BASE, l_pool_id), pool_params->num_buffers);
+	xrx500_bm_w32(BMGR_POOL_EXT_FIFO_OCC_REG_ADDR(BM_BASE, l_pool_id), pool_params->num_buffers);
+	xrx500_bm_w32(BMGR_POOL_EXT_FIFO_BASE_ADDR_LOW_REG_ADDR(BM_BASE, l_pool_id), phy_ll_base);
+	xrx500_bm_w32(BMGR_POOL_EXT_FIFO_BASE_ADDR_HIGH_REG_ADDR(BM_BASE, l_pool_id), 0x00000000);
+	reg = xrx500_bm_r32(BMGR_GROUP_AVAILABLE_BUFF_REG_ADDR(BM_BASE, pool_params->group_id));
+	xrx500_bm_w32(BMGR_GROUP_AVAILABLE_BUFF_REG_ADDR(BM_BASE, pool_params->group_id), reg + pool_params->num_buffers);
+	xrx500_bm_w32(BMGR_POOL_PCU_FIFO_BASE_ADDR_REG_ADDR(BM_BASE, l_pool_id),
+		BMGR_START_PCU_FIFO_SRAM_ADDR + ((l_pool_id + 1) * BMGR_DEFAULT_PCU_FIFO_SIZE));
+	xrx500_bm_w32(BMGR_POOL_PCU_FIFO_SIZE_REG_ADDR(BM_BASE, l_pool_id), 0x40);
+
+#if 0
+	status = bmgr_set_pcu_fifo_occupancy(l_pool_id, BMGR_DEFAULT_PCU_FIFO_SIZE);
+	if (status != PP_RC_SUCCESS) {
+		goto free_memory;
+	}
+#endif
+	xrx500_bm_w32(BMGR_POOL_PCU_FIFO_PROG_EMPTY_REG_ADDR(BM_BASE, l_pool_id), BMGR_DEFAULT_PCU_FIFO_LOW_THRESHOLD);
+	xrx500_bm_w32(BMGR_POOL_PCU_FIFO_PROG_FULL_REG_ADDR(BM_BASE, l_pool_id), 0x30);
+	xrx500_bm_w32(BMGR_POOL_WATERMARK_LOW_THRESHOLD_REG_ADDR(BM_BASE, l_pool_id), 0x90);
+	if (pool_params->flags & POOL_ENABLE_FOR_MIN_GRNT_POLICY_CALC) {
+		set_val_bm(BMGR_POOL_MIN_GRNT_MASK_REG_ADDR(BM_BASE), 1, (1 << l_pool_id), l_pool_id);
+	}
+
+	if (l_pool_id == 3) {
+		xrx500_bm_w32(BMGR_POOL_ENABLE_REG_ADDR(BM_BASE), 0x000f000f);
+		xrx500_bm_w32(BMGR_CTRL_REG_ADDR(BM_BASE), 0x00000001);
+		xrx500_bm_w32(BMGR_POOL_FIFO_RESET_REG_ADDR(BM_BASE), 0x0000fff0);
+		qose_reg_rd_poll(BMGR_STATUS_REG_ADDR(BM_BASE), 0x0, 0x00);
+	}
+	pr_info("pool %d Done\n", l_pool_id);
+	return 0;
+}
+
+s32 bmgr_policy_configure(const struct bmgr_policy_params* const policy_params, u8* const policy_id)
+{
+	int policy = *policy_id;
+	pr_info("Configuring buffer manager policy..%d\n", policy);
+
+	xrx500_bm_w32(BMGR_POLICY_GROUP_ASSOCIATED_ADDR(BM_RAM_BASE,policy), policy_params->group_id);
+
+	xrx500_bm_w32(BMGR_POLICY_MAX_ALLOWED_ADDR(BM_RAM_BASE,policy), policy_params->max_allowed);
+	xrx500_bm_w32(BMGR_POLICY_MIN_GUARANTEED_ADDR(BM_RAM_BASE,policy), policy_params->min_guaranteed);
+	// Set the group's reserved buffers
+	xrx500_bm_w32(BMGR_GROUP_RESERVED_BUFF_REG_ADDR(BM_BASE, policy_params->group_id), 0x00000100);
+
+	/*for (index = 0; index < policy_params->num_pools_in_policy; index++) {
+		xrx500_bm_w32(
+			BMGR_POLICY_MAX_ALLOWED_PER_POOL_ADDR(BM_RAM_BASE, policy, policy_params->pools_in_policy[index].pool_id)
+			, policy_params->pools_in_policy[index].max_allowed);
+	}*/
+	xrx500_bm_w32(BM_RAM_BASE + 0x4000, 0x00000080);//DONE
+	xrx500_bm_w32(BM_RAM_BASE + 0x4008, 0x00000080);
+	xrx500_bm_w32(BM_RAM_BASE + 0x4004, 0x00000080);
+	xrx500_bm_w32(BM_RAM_BASE + 0x400c, 0x00000080);
+	xrx500_bm_w32(BM_RAM_BASE + 0x500c, 0x00000080);
+	xrx500_bm_w32(BM_RAM_BASE + 0x5000, 0x00000080);
+	xrx500_bm_w32(BM_RAM_BASE + 0x5008, 0x00000080);
+	xrx500_bm_w32(BM_RAM_BASE + 0x5004, 0x00000080);
+	xrx500_bm_w32(BM_RAM_BASE + 0x600c, 0x00000080);
+	xrx500_bm_w32(BM_RAM_BASE + 0x6000, 0x00000080);
+	xrx500_bm_w32(BM_RAM_BASE + 0x6008, 0x00000080);
+	xrx500_bm_w32(BM_RAM_BASE + 0x6004, 0x00000080);
+	xrx500_bm_w32(BM_RAM_BASE + 0x700c, 0x00000080);
+	xrx500_bm_w32(BM_RAM_BASE + 0x7000, 0x00000080);
+	xrx500_bm_w32(BM_RAM_BASE + 0x7008, 0x00000080);
+	xrx500_bm_w32(BM_RAM_BASE + 0x7004, 0x00000080);
+	xrx500_bm_w32(BM_RAM_BASE + 0x700c, 0x00000080);
+
+	
+	xrx500_bm_w32(
+		BMGR_POLICY_POOLS_MAPPING_ADDR(BM_RAM_BASE, 0)
+		, 0x03020100);
+	xrx500_bm_w32(
+		BMGR_POLICY_POOLS_MAPPING_ADDR(BM_RAM_BASE, 1)
+		, 0x00030201);
+	xrx500_bm_w32(
+		BMGR_POLICY_POOLS_MAPPING_ADDR(BM_RAM_BASE, 2)
+		, 0x00000302);
+
+	xrx500_bm_w32(
+		BMGR_POLICY_POOLS_MAPPING_ADDR(BM_RAM_BASE, 3)
+		, 0x00000003);
+
+	qose_reg_rd_poll(BMGR_STATUS_REG_ADDR(BM_BASE), 0x0, 0x00);
+
+
+	pr_info("Policy Done\n");
+	return 0;
+
+
+}
+
+s32 bmgr_driver_init(void)
+{
+	pr_info("Buffer Manager driver is initializing....");
+	xrx500_bm_w32(BMGR_CTRL_REG_ADDR(BM_BASE), 0x1); // Buffer manager client enable
+	// OCP Master burst size
+	xrx500_bm_w32(BMGR_OCPM_BURST_SIZE_REG_ADDR(BM_BASE), 0x48);
+	// OCP Master number of bursts
+	xrx500_bm_w32(BMGR_OCPM_NUM_OF_BURSTS_REG_ADDR(BM_BASE), 0x33); // 1 burst for all pools
+	pr_info("Done\n");
+	return 0;
+}
+
+#define REG32(addr) (*((volatile uint32_t*)(addr)))
+void qose_reg_wr(uint32_t reg, uint32_t val)
+{
+        REG32(KSEG1ADDR(reg)) = val;
+}
+
+/**************************************************************************
+ *! \fn	buffer_manager_probe
+ **************************************************************************
+ *
+ *  \brief	probe platform device hook
+ * 
+ *  \param	pdev:	platform device pointer
+ *
+ *  \return	0 on success, other error code on failure
+ *
+ **************************************************************************/
+static int buffer_manager_probe(struct platform_device *pdev)
+{
+	
+	struct resource *res[2];
+	int i;
+	g_bm_dev = &pdev->dev;
+#if 1
+	/* load the memory ranges */
+	for (i = 0; i < 2; i++) {
+		res[i] = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (!res[i]) {
+			pr_err("failed to get resources %d\n", i);
+			return -ENOENT;
+		}
+	}
+#endif
+
+
+	bm_config_addr_base = devm_ioremap_resource(&pdev->dev, res[0]);
+	bm_policy_mngr_addr_base = devm_ioremap_resource(&pdev->dev, res[1]);
+
+	if (!bm_config_addr_base || !bm_policy_mngr_addr_base) {
+		pr_err("failed to request and remap io ranges\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+#ifndef BM_CHIPTEST_DRIVER
+void new_init_bm()
+{
+	return;
+}
+#else
+void new_init_bm()
+{
+	uint32_t * base, *base_org;
+	uint32_t count, i, val, val_org;
+
+	qose_reg_wr(0x18b10000, 0x00000280);
+	qose_reg_wr(0x18b10008, 0x00000280);
+	qose_reg_wr(0x18b10004, 0x00000280);
+	qose_reg_wr(0x18b1000c, 0x00000280);
+	qose_reg_wr(0x18b11000, 0x00000040);
+	qose_reg_wr(0x18b11008, 0x00000040);
+	qose_reg_wr(0x18b11004, 0x00000040);
+	qose_reg_wr(0x18b1100c, 0x00000040);
+	qose_reg_wr(0x18b14000, 0x00000080);
+	qose_reg_wr(0x18b14008, 0x00000080);
+	qose_reg_wr(0x18b14004, 0x00000080);
+	qose_reg_wr(0x18b1400c, 0x00000080);
+	qose_reg_wr(0x18b1500c, 0x00000080);
+	qose_reg_wr(0x18b15000, 0x00000080);
+	qose_reg_wr(0x18b15008, 0x00000080);
+	qose_reg_wr(0x18b15004, 0x00000080);
+	qose_reg_wr(0x18b1600c, 0x00000080);
+	qose_reg_wr(0x18b16000, 0x00000080);
+	qose_reg_wr(0x18b16008, 0x00000080);
+	qose_reg_wr(0x18b16004, 0x00000080);
+	qose_reg_wr(0x18b1700c, 0x00000080);
+	qose_reg_wr(0x18b17000, 0x00000080);
+	qose_reg_wr(0x18b17008, 0x00000080);
+	qose_reg_wr(0x18b17004, 0x00000080);
+	qose_reg_wr(0x18b1700c, 0x00000080);
+	qose_reg_wr(0x18b12000, 0x00000000);
+	qose_reg_wr(0x18b12008, 0x00000000);
+	qose_reg_wr(0x18b12004, 0x00000000);
+	qose_reg_wr(0x18b1200c, 0x00000000);
+	#if 1
+	qose_reg_wr(0x18b13000, 0x03020100);
+	qose_reg_wr(0x18b13004, 0x00030201);
+	qose_reg_wr(0x18b13008, 0x00000302);
+	qose_reg_wr(0x18b1300c, 0x00000003);
+	#else
+	qose_reg_wr(0x18b13000, 0x00000000);
+	qose_reg_wr(0x18b13004, 0x00000001);
+	qose_reg_wr(0x18b13008, 0x00000002);
+	qose_reg_wr(0x18b1300c, 0x00000003);
+	#endif
+	qose_reg_wr(0x18b00004, 0x0000000e);
+	qose_reg_wr(0x18b00020, 0x00000080);
+	qose_reg_wr(0x18b005c0, 0x00000080);
+	qose_reg_wr(0x18b00024, 0x00000080);
+	qose_reg_wr(0x18b005c4, 0x00000080);
+	qose_reg_wr(0x18b00028, 0x00000080);
+	qose_reg_wr(0x18b005c8, 0x00000080);
+	qose_reg_wr(0x18b0002c, 0x00000080);
+	qose_reg_wr(0x18b005cc, 0x00000080);
+	qose_reg_wr(0x18b00100, 0x00000400);
+	qose_reg_wr(0x18b00200, 0x00000100);
+	qose_reg_wr(0x18b00440, 0x00000040);
+	qose_reg_wr(0x18b004c0, 0x00000001);
+	qose_reg_wr(0x18b00500, 0x00000030);
+	//qose_reg_wr(0x18b00540, 0x20000000);
+
+	base = (void *)CONFIG_CQEM_BUF_LLK_BASE[0];
+	base_org = base;
+	val = (uint32_t) CONFIG_CQEM_BUF_BASE[0];
+
+	val = val & 0xFFFFFF80;
+	val_org = val;
+
+	count = CQEM_FORCE_COUNT_NUM;
+
+	for (i = 0; i < count; i ++) {
+		REG32(KSEG1ADDR(base)) = (val_org + i * 2048) >> 6 ;
+		base++;
+	}
+
+	pr_info("init bm size 0 llk base 0x%x last llk base 0x%x first val 0x%x last val 0x%x count 0x%x\n",
+		 (unsigned int)base_org, (unsigned int)base, val_org, (val_org + i * 2048), count);
+
+	qose_reg_wr(0x18b00540, (uint32_t) base_org);
+	qose_reg_wr(0x18b00580, 0x00000000);
+	qose_reg_wr(0x18b00400, 0x00000080);
+	qose_reg_wr(0x18b00444, 0x00000040);
+	qose_reg_wr(0x18b004c4, 0x00000018);
+	qose_reg_wr(0x18b00504, 0x0000002c);
+	//qose_reg_wr(0x18b00544, 0x20040000);
+
+
+	base = (void *)CONFIG_CQEM_BUF_LLK_BASE[1];
+	base_org = base;
+	val = CONFIG_CQEM_BUF_BASE[1];
+	val = val & 0xFFFFFF80;
+	val_org = val;
+	count = CQEM_FORCE_COUNT_NUM;
+
+	for (i = 0; i < count; i ++) {
+		REG32(KSEG1ADDR(base)) = (val_org + i * 2048) >> 6 ;
+		base++;
+	}
+
+	pr_info("init bm size 1 llk base 0x%x last llk base 0x%x first val 0x%x last val 0x%x count 0x%x\n",
+		(unsigned int)base_org, (unsigned int)base, val_org, (val_org + i * 2048), count);
+	qose_reg_wr(0x18b00544,  (uint32_t) base_org);
+
+	qose_reg_wr(0x18b00584, 0x00000000);
+	qose_reg_wr(0x18b00404, 0x00000100);
+	qose_reg_wr(0x18b00448, 0x00000040);
+	qose_reg_wr(0x18b004c8, 0x00000001);
+	qose_reg_wr(0x18b00508, 0x00000020);
+	//qose_reg_wr(0x18b00548, 0x20080000);
+
+	base = (void *)CONFIG_CQEM_BUF_LLK_BASE[2];
+	base_org = base;
+	val = CONFIG_CQEM_BUF_BASE[2];
+	val = val & 0xFFFFFF80;
+	val_org = val;
+	count = CQEM_FORCE_COUNT_NUM;
+
+	for (i = 0; i < count; i ++) {
+		REG32(KSEG1ADDR(base)) = (val_org + i * 2048) >> 6 ;
+		base++;
+	}
+
+	pr_info("init bm size 2 llk base 0x%x last llk base 0x%x first val 0x%x last val 0x%x count 0x%x\n",
+		(unsigned int)base_org, (unsigned int)base, val_org, (val_org + i * 2048), count);
+	qose_reg_wr(0x18b00548, (uint32_t) base_org);
+
+	qose_reg_wr(0x18b00588, 0x00000000);
+	qose_reg_wr(0x18b00408, 0x00000180);
+	qose_reg_wr(0x18b0044c, 0x00000040);
+	qose_reg_wr(0x18b004cc, 0x0000000f);
+	qose_reg_wr(0x18b0050c, 0x00000030);
+	//qose_reg_wr(0x18b0054c, 0x200c0000);
+
+        base = (void *)CONFIG_CQEM_BUF_LLK_BASE[3];
+        base_org = base;
+        val = CONFIG_CQEM_BUF_BASE[3];
+        val = val & 0xFFFFFF80;
+        val_org = val;
+	count = CQEM_FORCE_COUNT_NUM;
+	for (i = 0; i < count; i ++) {
+		REG32(KSEG1ADDR(base)) = (val_org + i * 2048) >> 6 ;
+		base++;
+	}
+
+	pr_info("init bm size 3 llk base 0x%x last llk base 0x%x first val 0x%x last val 0x%x count 0x%x\n",
+		(unsigned int)base_org, (unsigned int)base, val_org, (val_org + i * 2048) , count);
+	qose_reg_wr(0x18b0054c, (uint32_t) base_org);
+
+	qose_reg_wr(0x18b0058c, 0x00000000);
+	qose_reg_wr(0x18b0040c, 0x00000200);
+	qose_reg_wr(0x18b00014, 0x00000033);
+	qose_reg_wr(0x18b00010, 0x00000048);
+	qose_reg_wr(0x18b00740, 0x00000090);
+	qose_reg_wr(0x18b00744, 0x00000090);
+	qose_reg_wr(0x18b00748, 0x00000090);
+	qose_reg_wr(0x18b0074c, 0x00000090);
+	qose_reg_wr(0x18b00000, 0x00000001);
+	qose_reg_wr(0x18b0000c, 0x0000fff0);
+	qose_reg_wr(0x18b00008, 0x000f000f);
+	qose_reg_rd_poll_2(0x18b00018, 0x0, 0x00);
+}
+#endif
+/**************************************************************************
+ *! \fn	buffer_manager_remove
+ **************************************************************************
+ *
+ *  \brief	probe platform device hook
+ * 
+ *  \param	pdev:	platform device pointer
+ *
+ *  \return	0 on success, other error code on failure
+ *
+ **************************************************************************/
+static int buffer_manager_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static const struct of_device_id bm_match[] = {
+	{ .compatible = "intel,falconmx-bm" },
+	{},
+};
+
+static struct platform_driver	g_buffer_manager_platform_driver = {
+	.driver = { .name = "buffer_manager", .of_match_table = bm_match,},
+	.probe = buffer_manager_probe,
+	.remove = buffer_manager_remove,
+};
+
+/**************************************************************************
+ *! \fn	buffer_manager_driver_init
+ **************************************************************************
+ *
+ *  \brief	Init platform device driver
+ * 
+ *  \return	0 on success, other error code on failure
+ *
+ **************************************************************************/
+static int __init buffer_manager_driver_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&g_buffer_manager_platform_driver);
+	if (ret < 0) {
+		pr_err("buffer_manager_driver_init(): Failed to register buffer_manager platform driver: %d\n", ret);
+		return ret;
+	}
+	pr_info("buffer_manager_driver_init(): buffer_manager driver init done\n");
+
+	return 0;
+}
+
+/**************************************************************************
+ *! \fn	buffer_manager_driver_exit
+ **************************************************************************
+ *
+ *  \brief	Exit platform device driver
+ * 
+ *  \return	0 on success, other error code on failure
+ *
+ **************************************************************************/
+static void __exit buffer_manager_driver_exit(void)
+{
+	platform_driver_unregister(&g_buffer_manager_platform_driver);
+
+	pr_info("buffer_manager_driver_exit(): buffer_manager driver exit done\n");
+}
+
+/*************************************************/
+/**		Module Declarations		**/
+/*************************************************/
+arch_initcall(buffer_manager_driver_init);
+module_exit(buffer_manager_driver_exit);
+
diff --git a/drivers/net/ethernet/lantiq/ppv4/qos_drv_slim.c b/drivers/net/ethernet/lantiq/ppv4/qos_drv_slim.c
new file mode 100644
index 000000000000..6eac068ebe75
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/ppv4/qos_drv_slim.c
@@ -0,0 +1,488 @@
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/device.h>
+#include <linux/inetdevice.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/bitops.h>
+#include <linux/byteorder/generic.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/pid.h>
+#include <linux/pid_namespace.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <lantiq.h>
+#include <lantiq_soc.h>
+#include <net/bm_drv_slim.h>
+
+#define xrx500_qos_r32(m_reg)		__raw_readl(m_reg)
+#define xrx500_qos_w32(m_reg, val)	__raw_writel(val, m_reg)
+
+/**************************
+*port = 0 t_qid_data = 14 
+*port = 0 t_qid_data = 74 
+*port = 0 t_qid_data = 30 
+*port = 0 t_qid_data = 87 
+*port = 7 t_qid_data = 235 
+*port = 7 t_qid_data = 42 
+*port = 7 t_qid_data = 242 
+*port = 26 t_qid_data = 190 
+*port = 26 t_qid_data = 119 
+*port = 26 t_qid_data = 103 
+****************************/
+
+static void qose_reg_wr(uint32_t reg, uint32_t val) 
+{
+	xrx500_qos_w32((void *)(KSEG1ADDR(reg)), val);
+}
+
+static void qose_reg_rd_poll (uint32_t reg, uint32_t val, uint32_t offset)
+{
+	uint32_t tmpreg;
+
+	while (1) {
+		tmpreg = xrx500_qos_r32((void *)(KSEG1ADDR(reg))) & (1 << offset);
+		if (tmpreg == (val << offset))
+			break;
+	}
+
+}
+
+s32 qos_config(void *qmgr_buf)
+{
+	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
+	qose_reg_wr(0x18820090, 0x0002a455);
+	qose_reg_wr(0x18820094, 0x0006b264);
+	qose_reg_wr(0x18820098, 0x00000012);
+	qose_reg_wr(0x1882009c, 0x0000000b);
+	qose_reg_wr(0x18820080, 0x00000001);
+	qose_reg_wr(0x18820084, 0x00000000);
+	qose_reg_wr(0x188200a0, 0x00017c6e);
+	qose_reg_wr(0x188200a4, 0x0003f024);
+	qose_reg_wr(0x188200a8, 0x0000000a);
+	qose_reg_wr(0x188200ac, 0x00000005);
+	qose_reg_wr(0x188200b0, 0x0000265c);
+	qose_reg_wr(0x188200b4, 0x0000368a);
+	qose_reg_wr(0x188200bc, 0x0000000e);
+	qose_reg_wr(0x188200c0, 0x00000003);
+	qose_reg_wr(0x18820a38, 0x00000000);
+	qose_reg_wr(0x18820e38, 0x00000000);
+	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
+	qose_reg_wr(0x18820090, 0x00025705);
+	qose_reg_wr(0x18820094, 0x000d945c);
+	qose_reg_wr(0x18820098, 0x00000018);
+	qose_reg_wr(0x1882009c, 0x00000001);
+	qose_reg_wr(0x18820080, 0x00000001);
+	qose_reg_wr(0x18820084, 0x00000000);
+	qose_reg_wr(0x188200a0, 0x00028dbf);
+	qose_reg_wr(0x188200a4, 0x000631a9);
+	qose_reg_wr(0x188200a8, 0x0000000c);
+	qose_reg_wr(0x188200ac, 0x00000008);
+	qose_reg_wr(0x188200b0, 0x00002757);
+	qose_reg_wr(0x188200b4, 0x00003d6a);
+	qose_reg_wr(0x188200bc, 0x0000004a);
+	qose_reg_wr(0x188200c0, 0x00000003);
+	qose_reg_wr(0x18820b28, 0x00000000);
+	qose_reg_wr(0x18820f28, 0x00000000);
+	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
+	qose_reg_wr(0x18820090, 0x000210dc);
+	qose_reg_wr(0x18820094, 0x0008d8f3);
+	qose_reg_wr(0x18820098, 0x00000003);
+	qose_reg_wr(0x1882009c, 0x00000005);
+	qose_reg_wr(0x18820080, 0x00000001);
+	qose_reg_wr(0x18820084, 0x00000000);
+	qose_reg_wr(0x188200a0, 0x000229e2);
+	qose_reg_wr(0x188200a4, 0x00043f6d);
+	qose_reg_wr(0x188200a8, 0x00000011);
+	qose_reg_wr(0x188200ac, 0x0000000a);
+	qose_reg_wr(0x188200b0, 0x000022de);
+	qose_reg_wr(0x188200b4, 0x00003657);
+	qose_reg_wr(0x188200bc, 0x0000001e);
+	qose_reg_wr(0x188200c0, 0x00000003);
+	qose_reg_wr(0x18820a78, 0x00000000);
+	qose_reg_wr(0x18820e78, 0x00000000);
+	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
+	qose_reg_wr(0x18820090, 0x00021727);
+	qose_reg_wr(0x18820094, 0x000d293a);
+	qose_reg_wr(0x18820098, 0x00000004);
+	qose_reg_wr(0x1882009c, 0x0000000a);
+	qose_reg_wr(0x18820080, 0x00000001);
+	qose_reg_wr(0x18820084, 0x00000000);
+	qose_reg_wr(0x188200a0, 0x0001ad60);
+	qose_reg_wr(0x188200a4, 0x000471b9);
+	qose_reg_wr(0x188200a8, 0x00000010);
+	qose_reg_wr(0x188200ac, 0x00000001);
+	qose_reg_wr(0x188200b0, 0x000025c9);
+	qose_reg_wr(0x188200b4, 0x00003d55);
+	qose_reg_wr(0x188200bc, 0x00000057);
+	qose_reg_wr(0x188200c0, 0x00000003);
+	qose_reg_wr(0x18820b5c, 0x00000000);
+	qose_reg_wr(0x18820f5c, 0x00000000);
+	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
+	qose_reg_wr(0x18820090, 0x00027afe);
+	qose_reg_wr(0x18820094, 0x00052ea9);
+	qose_reg_wr(0x18820098, 0x00000015);
+	qose_reg_wr(0x1882009c, 0x00000009);
+	qose_reg_wr(0x18820080, 0x00000001);
+	qose_reg_wr(0x18820084, 0x00000000);
+	qose_reg_wr(0x188200a0, 0x0001f912);
+	qose_reg_wr(0x188200a4, 0x0003136e);
+	qose_reg_wr(0x188200a8, 0x00000011);
+	qose_reg_wr(0x188200ac, 0x00000007);
+	qose_reg_wr(0x188200b0, 0x000023e0);
+	qose_reg_wr(0x188200b4, 0x00003a20);
+	qose_reg_wr(0x188200bc, 0x000000eb);
+	qose_reg_wr(0x188200c0, 0x00000003);
+	qose_reg_wr(0x18820dac, 0x00000007);
+	qose_reg_wr(0x188211ac, 0x00000000);
+	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
+	qose_reg_wr(0x18820090, 0x00029224);
+	qose_reg_wr(0x18820094, 0x000b9c5e);
+	qose_reg_wr(0x18820098, 0x0000000e);
+	qose_reg_wr(0x1882009c, 0x00000006);
+	qose_reg_wr(0x18820080, 0x00000001);
+	qose_reg_wr(0x18820084, 0x00000000);
+	qose_reg_wr(0x188200a0, 0x0002cd06);
+	qose_reg_wr(0x188200a4, 0x00044b7e);
+	qose_reg_wr(0x188200a8, 0x00000012);
+	qose_reg_wr(0x188200ac, 0x00000008);
+	qose_reg_wr(0x188200b0, 0x00002328);
+	qose_reg_wr(0x188200b4, 0x00003218);
+	qose_reg_wr(0x188200bc, 0x0000002a);
+	qose_reg_wr(0x188200c0, 0x00000003);
+	qose_reg_wr(0x18820aa8, 0x00000007);
+	qose_reg_wr(0x18820ea8, 0x00000000);
+	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
+	qose_reg_wr(0x18820090, 0x00028afa);
+	qose_reg_wr(0x18820094, 0x000afdc8);
+	qose_reg_wr(0x18820098, 0x0000000b);
+	qose_reg_wr(0x1882009c, 0x00000001);
+	qose_reg_wr(0x18820080, 0x00000001);
+	qose_reg_wr(0x18820084, 0x00000000);
+	qose_reg_wr(0x188200a0, 0x0002b942);
+	qose_reg_wr(0x188200a4, 0x000d8910);
+	qose_reg_wr(0x188200a8, 0x00000011);
+	qose_reg_wr(0x188200ac, 0x0000000b);
+	qose_reg_wr(0x188200b0, 0x00002633);
+	qose_reg_wr(0x188200b4, 0x00003c36);
+	qose_reg_wr(0x188200bc, 0x000000f2);
+	qose_reg_wr(0x188200c0, 0x00000003);
+	qose_reg_wr(0x18820dc8, 0x00000007);
+	qose_reg_wr(0x188211c8, 0x00000000);
+	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
+	qose_reg_wr(0x18820090, 0x0002bed3);
+	qose_reg_wr(0x18820094, 0x0003da49);
+	qose_reg_wr(0x18820098, 0x0000000f);
+	qose_reg_wr(0x1882009c, 0x0000000a);
+	qose_reg_wr(0x18820080, 0x00000001);
+	qose_reg_wr(0x18820084, 0x00000000);
+	qose_reg_wr(0x188200a0, 0x0002c8e6);
+	qose_reg_wr(0x188200a4, 0x000a8584);
+	qose_reg_wr(0x188200a8, 0x0000000d);
+	qose_reg_wr(0x188200ac, 0x00000008);
+	qose_reg_wr(0x188200b0, 0x000025b4);
+	qose_reg_wr(0x188200b4, 0x00002ca3);
+	qose_reg_wr(0x188200bc, 0x000000be);
+	qose_reg_wr(0x188200c0, 0x00000003);
+	qose_reg_wr(0x18820cf8, 0x0000001a);
+	qose_reg_wr(0x188210f8, 0x00000000);
+	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
+	qose_reg_wr(0x18820090, 0x00023c35);
+	qose_reg_wr(0x18820094, 0x000fbf60);
+	qose_reg_wr(0x18820098, 0x0000001c);
+	qose_reg_wr(0x1882009c, 0x00000006);
+	qose_reg_wr(0x18820080, 0x00000001);
+	qose_reg_wr(0x18820084, 0x00000000);
+	qose_reg_wr(0x188200a0, 0x00029899);
+	qose_reg_wr(0x188200a4, 0x000580e1);
+	qose_reg_wr(0x188200a8, 0x00000009);
+	qose_reg_wr(0x188200ac, 0x00000005);
+	qose_reg_wr(0x188200b0, 0x00002614);
+	qose_reg_wr(0x188200b4, 0x0000283c);
+	qose_reg_wr(0x188200bc, 0x00000077);
+	qose_reg_wr(0x188200c0, 0x00000003);
+	qose_reg_wr(0x18820bdc, 0x0000001a);
+	qose_reg_wr(0x18820fdc, 0x00000000);
+	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
+	qose_reg_wr(0x18820090, 0x0002b289);
+	qose_reg_wr(0x18820094, 0x00080794);
+	qose_reg_wr(0x18820098, 0x0000001c);
+	qose_reg_wr(0x1882009c, 0x00000009);
+	qose_reg_wr(0x18820080, 0x00000001);
+	qose_reg_wr(0x18820084, 0x00000000);
+	qose_reg_wr(0x188200a0, 0x0001acc6);
+	qose_reg_wr(0x188200a4, 0x0009b984);
+	qose_reg_wr(0x188200a8, 0x00000007);
+	qose_reg_wr(0x188200ac, 0x00000001);
+	qose_reg_wr(0x188200b0, 0x000022df);
+	qose_reg_wr(0x188200b4, 0x00003746);
+	qose_reg_wr(0x188200bc, 0x00000067);
+	qose_reg_wr(0x188200c0, 0x00000003);
+	qose_reg_wr(0x18820b9c, 0x0000001a);
+	qose_reg_wr(0x18820f9c, 0x00000000);
+	qose_reg_wr(0x189c0004, 0x00000001);
+	//qose_reg_wr(0x189c0008, 0x40000000);
+	qose_reg_wr(0x189c0008, (u32)qmgr_buf);
+	qose_reg_wr(0x189c0010, 0x00000193);
+	qose_reg_wr(0x189c0014, 0x00000030);
+	qose_reg_wr(0x189c002c, 0x00000200);
+	qose_reg_rd_poll(0x189c002c, 0x1, 31);
+	qose_reg_wr(0x18820004, 0x00000fc0);
+	qose_reg_wr(0x18820008, 0x00000220);
+	qose_reg_wr(0x18820000, 0x00000001);
+	qose_reg_wr(0x1882000c, 0x00000001);
+	qose_reg_wr(0x18820004, 0x00000fc0);
+	qose_reg_wr(0x18820008, 0x00000220);
+	qose_reg_wr(0x18820000, 0x00000001);
+	qose_reg_wr(0x1882000c, 0x00000001);
+	qose_reg_wr(0x18820200, 0x00000000);
+	qose_reg_wr(0x18820400, 0x00000000);
+	qose_reg_wr(0x18820600, 0x00ffffff);
+	qose_reg_wr(0x18820800, 0x00ffffff);
+	qose_reg_wr(0x1882021c, 0x00000000);
+	qose_reg_wr(0x1882041c, 0x00000000);
+	qose_reg_wr(0x1882061c, 0x00ffffff);
+	qose_reg_wr(0x1882081c, 0x00ffffff);
+	qose_reg_wr(0x18820268, 0x00000000);
+	qose_reg_wr(0x18820468, 0x00000000);
+	qose_reg_wr(0x18820668, 0x00ffffff);
+	qose_reg_wr(0x18820868, 0x00ffffff);
+	qose_reg_rd_poll(0x18800230, 0x1, 0x03);
+	qose_reg_rd_poll(0x18800220, 0x1, 0x03);
+	qose_reg_rd_poll(0x18800224, 0x1, 0x03);
+	qose_reg_rd_poll(0x18800228, 0x1, 0x03);
+	qose_reg_rd_poll(0x18800234, 0x1, 0x03);
+	qose_reg_wr(0x18800044, 0x00200400);
+	qose_reg_wr(0x18800040, 0x00000080);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x82105c00);
+	qose_reg_wr(0x18800088, 0x24004000);
+	qose_reg_wr(0x1880008c, 0x11e3080c);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00000001);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x84109400);
+	qose_reg_wr(0x18800088, 0x34004000);
+	qose_reg_wr(0x1880008c, 0x059b1006);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00000701);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x8610d400);
+	qose_reg_wr(0x18800088, 0x38004000);
+	qose_reg_wr(0x1880008c, 0x07bb1810);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00001a01);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000400);
+	qose_reg_wr(0x18800088, 0x34004000);
+	qose_reg_wr(0x1880008c, 0x061b0006);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00020801);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000400);
+	qose_reg_wr(0x18800088, 0x28004000);
+	qose_reg_wr(0x1880008c, 0x0edb0008);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00020a01);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000400);
+	qose_reg_wr(0x18800088, 0x40004000);
+	qose_reg_wr(0x1880008c, 0x093b0708);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00021101);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000400);
+	qose_reg_wr(0x18800088, 0x2c004000);
+	qose_reg_wr(0x1880008c, 0x06db000c);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00020901);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000400);
+	qose_reg_wr(0x18800088, 0x30004000);
+	qose_reg_wr(0x1880008c, 0x11430004);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00020b01);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000400);
+	qose_reg_wr(0x18800088, 0x30004000);
+	qose_reg_wr(0x1880008c, 0x099b1a08);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00021a01);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000400);
+	qose_reg_wr(0x18800088, 0x3c004000);
+	qose_reg_wr(0x1880008c, 0x079b1a0c);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00021901);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000400);
+	qose_reg_wr(0x18800088, 0x24004000);
+	qose_reg_wr(0x1880008c, 0x0ae31a06);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00021801);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000400);
+	qose_reg_wr(0x18800088, 0x28004000);
+	qose_reg_wr(0x1880008c, 0x0ddb0704);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00021001);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000400);
+	qose_reg_wr(0x18800088, 0x3c004000);
+	qose_reg_wr(0x1880008c, 0x05db0706);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00021201);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x0000ca08);
+	qose_reg_wr(0x18800088, 0x0000800e);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00000e51);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x000ba20a);
+	qose_reg_wr(0x18800088, 0x0000801e);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00001e51);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x7070aa11);
+	qose_reg_wr(0x18800088, 0x0000802a);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00002a51);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x000e9a09);
+	qose_reg_wr(0x18800088, 0x0000804a);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00004a51);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x000c420b);
+	qose_reg_wr(0x18800088, 0x00008057);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00005751);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x21afca1a);
+	qose_reg_wr(0x18800088, 0x00008067);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00006751);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x21a13219);
+	qose_reg_wr(0x18800088, 0x00008077);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00007751);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x21af4a18);
+	qose_reg_wr(0x18800088, 0x000080be);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x0000be51);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x70709210);
+	qose_reg_wr(0x18800088, 0x000080eb);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x0000eb51);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x707a1a12);
+	qose_reg_wr(0x18800088, 0x000080f2);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x0000f251);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000000);
+	qose_reg_wr(0x18800088, 0x00000000);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00030011);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000000);
+	qose_reg_wr(0x18800088, 0x00000000);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00030011);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000007);
+	qose_reg_wr(0x18800088, 0x00000000);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00030711);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000000);
+	qose_reg_wr(0x18800088, 0x00000000);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00030011);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000000);
+	qose_reg_wr(0x18800088, 0x00000000);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00030011);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x0000001a);
+	qose_reg_wr(0x18800088, 0x00000000);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00031a11);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x0000001a);
+	qose_reg_wr(0x18800088, 0x00000000);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00031a11);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x0000001a);
+	qose_reg_wr(0x18800088, 0x00000000);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00031a11);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000007);
+	qose_reg_wr(0x18800088, 0x00000000);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00030711);
+	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
+	qose_reg_wr(0x18800084, 0x00000007);
+	qose_reg_wr(0x18800088, 0x00000000);
+	qose_reg_wr(0x1880008c, 0x00000000);
+	qose_reg_wr(0x18800090, 0x00000000);
+	qose_reg_wr(0x18800094, 0x00030711);
+	qose_reg_wr(0x18800148, 0x000030d4);
+	qose_reg_wr(0x1880014c, 0x00000010);
+	qose_reg_wr(0x18800080, 0x00000002);
+	qose_reg_wr(0x18800144, 0x00001000);
+	qose_reg_wr(0x18800154, 0x0000007f);
+	qose_reg_wr(0x188000a8, 0x00000018);
+	qose_reg_wr(0x18810000, 0x04000081);
+	qose_reg_wr(0x18810004, 0x00000000);
+	qose_reg_wr(0x18810008, 0x00000000);
+	qose_reg_wr(0x1881000c, 0x00000000);
+	qose_reg_wr(0x18810040, 0xffffffff);
+	qose_reg_wr(0x18810044, 0xffffffff);
+	qose_reg_wr(0x18810048, 0xffffffff);
+	qose_reg_wr(0x1881004c, 0xffffffff);
+	qose_reg_wr(0x18810054, 0x00200000);
+	qose_reg_wr(0x1881005c, 0xdeadbeef);
+	qose_reg_wr(0x18810060, 0x00000100);
+	qose_reg_wr(0x18810064, 0x00240000);
+	qose_reg_wr(0x18a00808, 0x00000002);
+	qose_reg_wr(0x18810098, 0x00000100);
+	qose_reg_wr(0x1881009c, 0x00240700);
+	qose_reg_wr(0x18a00878, 0x00000008);
+	qose_reg_wr(0x18810130, 0x00000100);
+	qose_reg_wr(0x18810134, 0x00241a00);
+	qose_reg_wr(0x18a009a8, 0x00000008);
+	qose_reg_wr(0x1881087c, 0x00000303);
+	return 0;
+}
+
diff --git a/include/net/bm_drv_slim.h b/include/net/bm_drv_slim.h
new file mode 100755
index 000000000000..3f866f4ad74d
--- /dev/null
+++ b/include/net/bm_drv_slim.h
@@ -0,0 +1,401 @@
+/*
+ * GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2017 Intel Corporation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *  Intel Corporation
+ *  2200 Mission College Blvd.
+ *  Santa Clara, CA  97052
+ */
+
+/*
+ *	driver:		buffer_manager platform device driver
+ *	@file		bm_drv.h
+ *	@brief:		ppv4 buffer manager implementation 
+ *	@author:	obakshe
+ *	@date:		5/3/2017
+ */
+
+#ifndef _BMGR_H_
+#define _BMGR_H_
+
+#include <net/pp_bm_regs.h>
+
+
+#define FALCON_SOC
+
+#ifdef FALCON_SOC
+	/*! \def PP_BMGR_MAX_POOLS
+	 *       Max supported pools
+	 */
+	#define PP_BMGR_MAX_POOLS		(4)
+
+	/*! \def PP_BMGR_MAX_POOLS_IN_GROUP
+	 *       Max pools in group
+	 */
+	#define PP_BMGR_MAX_POOLS_IN_GROUP	(4)
+
+	/*! \def PP_BMGR_MAX_GROUPS
+	 *       Max supported groups
+	 */
+	#define PP_BMGR_MAX_GROUPS		(2)
+
+	/*! \def PP_BMGR_MAX_POLICIES
+	 *       Max supoorted policies
+	 */
+	#define PP_BMGR_MAX_POLICIES		(32)
+#else /* PPv4 */
+	/*! \def PP_BMGR_MAX_POOLS
+	 *       Max supported pools
+	 */
+	#define PP_BMGR_MAX_POOLS		(16)
+
+	/*! \def PP_BMGR_MAX_POOLS_IN_GROUP
+	 *       Max pools in group
+	 */
+	#define PP_BMGR_MAX_POOLS_IN_GROUP	(4)
+
+	/*! \def PP_BMGR_MAX_GROUPS
+	 *       Max supported groups
+	 */
+	#define PP_BMGR_MAX_GROUPS		(16)
+
+	/*! \def PP_BMGR_MAX_POLICIES
+	 *       Max supoorted policies
+	 */
+	#define PP_BMGR_MAX_POLICIES		(256)
+#endif
+
+//-----------------------------------------------------------------------------------------------------------------------------------------------
+//
+// ########  ######## ######## #### ##    ## ########  ######
+// ##     ## ##       ##        ##  ###   ## ##       ##    ##
+// ##     ## ##       ##        ##  ####  ## ##       ##
+// ##     ## ######   ######    ##  ## ## ## ######    ######
+// ##     ## ##       ##        ##  ##  #### ##             ##
+// ##     ## ##       ##        ##  ##   ### ##       ##    ##
+// ########  ######## ##       #### ##    ## ########  ######
+//
+//-----------------------------------------------------------------------------------------------------------------------------------------------
+
+/*! \def BMGR_DRIVER_VERSION */
+#define BMGR_DRIVER_VERSION			"1.0.0"
+
+/*! \def BMGR_MIN_POOL_BUFFER_SIZE
+ *       Minimum buffer size in configured pool
+ */
+#define BMGR_MIN_POOL_BUFFER_SIZE		(64)
+
+/*! \def BMGR_START_PCU_SRAM_ADDR 
+ *       Start PCU address in SRAM. Used in confiure pool
+ */
+#define BMGR_START_PCU_FIFO_SRAM_ADDR		(0)
+
+/*! \def BMGR_DEFAULT_PCU_FIFO_SIZE 
+ *       PCU fifo size
+ */
+#define BMGR_DEFAULT_PCU_FIFO_SIZE		(0x80)
+
+/*! \def BMGR_DEFAULT_PCU_FIFO_LOW_THRESHOLD 
+ *       PCU fifo low threshold
+ */
+#define BMGR_DEFAULT_PCU_FIFO_LOW_THRESHOLD	(1)
+
+/*! \def BMGR_DEFAULT_PCU_FIFO_HIGH_THRESHOLD 
+ *       PCU fifo high threshold
+ */
+#define BMGR_DEFAULT_PCU_FIFO_HIGH_THRESHOLD	(0x70)
+
+/*! \def BMGR_DEFAULT_WATERMARK_LOW_THRESHOLD 
+ *       Watermark low threshold
+ */
+#define BMGR_DEFAULT_WATERMARK_LOW_THRESHOLD	(0x200)
+
+//-----------------------------------------------------------------------------------------------------------------------------------------------
+//
+//  ######  ######## ########  ##     ##  ######  ######## ##     ## ########  ########  ######
+// ##    ##    ##    ##     ## ##     ## ##    ##    ##    ##     ## ##     ## ##       ##    ##
+// ##          ##    ##     ## ##     ## ##          ##    ##     ## ##     ## ##       ##
+//  ######     ##    ########  ##     ## ##          ##    ##     ## ########  ######    ######
+//       ##    ##    ##   ##   ##     ## ##          ##    ##     ## ##   ##   ##             ##
+// ##    ##    ##    ##    ##  ##     ## ##    ##    ##    ##     ## ##    ##  ##       ##    ##
+//  ######     ##    ##     ##  #######   ######     ##     #######  ##     ## ########  ######
+//
+//-----------------------------------------------------------------------------------------------------------------------------------------------
+
+/**************************************************************************
+ *! \enum	bmgr_policy_pools_priority_e
+ **************************************************************************
+ *
+ * \brief enum to describe the pool's priority
+ *
+ **************************************************************************/
+enum bmgr_policy_pools_priority_e {
+	bmgr_policy_pool_priority_high,		//!< High priority
+	bmgr_policy_pool_priority_mid_high,	//!< Mid-High priority
+	bmgr_policy_pool_priority_mid_low,	//!< Mid-Low priority
+	bmgr_policy_pool_priority_low,		//!< Low priority
+	bmgr_policy_pool_priority_max		//!< Last priority
+};
+
+/*! \def POOL_ENABLE_FOR_MIN_GRNT_POLICY_CALC 
+ *       bmgr pools flags (Used in bmgr_pool_params.pool_flags)
+ *       When set pool will be take part in policy minimum guaranteed calculation
+ */
+#define POOL_ENABLE_FOR_MIN_GRNT_POLICY_CALC	BIT(0)
+
+/**************************************************************************
+ *! \struct	bmgr_pool_params
+ **************************************************************************
+ *
+ * \brief This structure is used in bmgr_pool_configure API in parameter
+ *
+ **************************************************************************/
+struct bmgr_pool_params {
+	u16	flags;			//!< Pool flags
+	u8	group_id;		//!< Group index which the pool belong to
+	u32	num_buffers;		//!< Amount of buffers in pool
+	u32	size_of_buffer;		//!< Buffer size for this pool (in bytes). Minimum is 64 bytes
+	u32	base_addr_low;		//!< Base address of the pool (low)
+	u32	base_addr_high;		//!< Base address of the pool (high)
+};
+
+/**************************************************************************
+ *! \struct	bmgr_group_params
+ **************************************************************************
+ *
+ * \brief This structure is used for buffer manager database
+ *
+ **************************************************************************/
+struct bmgr_group_params {
+	u32	available_buffers;		//!< available buffers in group
+	u32	reserved_buffers;		//!< reserved buffers in this group
+	u8	pools[PP_BMGR_MAX_POOLS];	//!< Pools in policy
+};
+
+/**************************************************************************
+ *! \struct	bmgr_pool_in_policy_info
+ **************************************************************************
+ *
+ * \brief	This structure is used in policy_params struct and holds
+ * 		the information about the pools in policy 
+ *
+ **************************************************************************/
+struct bmgr_pool_in_policy_info {
+	u8	pool_id;	//!< Pool id
+	u8	max_allowed;	//!< Max allowed per pool per policy
+};
+
+/*! \def POLICY_FLAG_RESERVED1 
+ *       bmgr policy flags (Used in bmgr_policy_param.policy_flags)
+ */
+#define POLICY_FLAG_RESERVED1	BIT(0)
+
+/**************************************************************************
+ *! \struct	bmgr_policy_params
+ **************************************************************************
+ *
+ * \brief This structure is used in bmgr_policy_configure API in parameter
+ *
+ **************************************************************************/
+struct bmgr_policy_params {
+	u16				flags;						//!< Policy flags
+	u8				group_id;					//!< Group index
+	u32				max_allowed;					//!< Policy maximum allowed
+	u32				min_guaranteed;					//!< Policy minimum guaranteed
+	struct bmgr_pool_in_policy_info	pools_in_policy[PP_BMGR_MAX_POOLS_IN_POLICY];	//!< Pools information. Sorted according to priority - highest in index 0
+	u8				num_pools_in_policy;				//!< Number of pools in pools_in_policy
+};
+
+/**************************************************************************
+ *! \struct	bmgr_buff_info
+ **************************************************************************
+ *
+ * \brief This structure is used for allocate and deallocate buffer
+ *
+ **************************************************************************/
+struct bmgr_buff_info {
+	u32	addr_low;	//!< [Out] buffer pointer low
+	u32	addr_high;	//!< [Out] buffer pointer high
+	u8	policy_id;	//!< policy to allocate from
+	u8	pool_id;	//!< pool for deallocate buffer back
+	u8	is_burst;	//!< Single/Burst allocation/s
+//	u8	num_allocs;	//!< number of pointers to allocate (up to 32 pointers)
+};
+
+/**************************************************************************
+ *! \struct	bmgr_pool_db_entry
+ **************************************************************************
+ *
+ * \brief This structure holds the pool database
+ *
+ **************************************************************************/
+struct bmgr_pool_db_entry {
+	struct bmgr_pool_params	pool_params;			//!< Pool params
+	u32			num_allocated_buffers;		//!< Number of allocated buffers
+	u32			num_deallocated_buffers;	//!< Number of deallocated buffers
+	u8			is_busy;			//!< Is entry in used
+	void*			internal_pointers_tables;	//!< Pointers table to be used in HW
+};
+
+/**************************************************************************
+ *! \struct	bmgr_group_db_entry
+ **************************************************************************
+ *
+ * \brief This structure holds the group database
+ *
+ **************************************************************************/
+struct bmgr_group_db_entry {
+	u32	available_buffers;			//!< available buffers in group
+	u32	reserved_buffers;			//!< reserved buffers in this group
+	u8	pools[PP_BMGR_MAX_POOLS_IN_GROUP];	//!< Pools in policy (if set, pool is part of this group)
+	u8	num_pools_in_group;			//!< Number of pools in group
+};
+
+/**************************************************************************
+ *! \struct	bmgr_policy_db_entry
+ **************************************************************************
+ *
+ * \brief This structure holds the policy database
+ *
+ **************************************************************************/
+struct bmgr_policy_db_entry {
+	struct bmgr_policy_params	policy_params;			//!< Policy params
+	u32				num_allocated_buffers;		//!< Number of allocated buffers
+	u32				num_deallocated_buffers;	//!< Number of deallocated buffers
+	u8				is_busy;			//!< Is entry in used
+};
+
+/**************************************************************************
+ *! \struct	bmgr_driver_db
+ **************************************************************************
+ *
+ * \brief This structure holds the buffer manager database
+ *
+ **************************************************************************/
+struct bmgr_driver_db {
+	struct bmgr_pool_db_entry	bmgr_db_pools[PP_BMGR_MAX_POOLS];	//!< Pools information
+	struct bmgr_group_db_entry	bmgr_db_groups[PP_BMGR_MAX_GROUPS];	//!< Groups information
+	struct bmgr_policy_db_entry	bmgr_db_policies[PP_BMGR_MAX_POLICIES];	//!< Policies information
+
+	// general counters
+	u32				num_active_pools;			//!< Number of active pools
+	u32				num_active_groups;			//!< Number of active groups
+	u32				num_active_policies;			//!< Number of active policies
+
+	// spinlock
+	spinlock_t			db_lock;				//!< spinlock
+};
+
+/**************************************************************************
+ *! \struct	bmgr_driver_private
+ **************************************************************************
+ *
+ * \brief This struct defines the driver's private data
+ *
+ **************************************************************************/
+struct bmgr_driver_private {
+	struct platform_device*		pdev;		//!< Platform device pointer
+	struct kobject*			kobj;		//!< Sysfs kobject
+	int				enabled;	//!< Is driver enabled
+	struct bmgr_driver_db		driver_db;	//!< Platform device DB
+};
+
+//-----------------------------------------------------------------------------------------------------------------------------------------------
+//
+// ########  ########   #######  ########  #######  ######## ##    ## ########  ########  ######
+// ##     ## ##     ## ##     ##    ##    ##     ##    ##     ##  ##  ##     ## ##       ##    ##
+// ##     ## ##     ## ##     ##    ##    ##     ##    ##      ####   ##     ## ##       ##
+// ########  ########  ##     ##    ##    ##     ##    ##       ##    ########  ######    ######
+// ##        ##   ##   ##     ##    ##    ##     ##    ##       ##    ##        ##             ##
+// ##        ##    ##  ##     ##    ##    ##     ##    ##       ##    ##        ##       ##    ##
+// ##        ##     ##  #######     ##     #######     ##       ##    ##        ########  ######
+//
+//-----------------------------------------------------------------------------------------------------------------------------------------------
+
+/**************************************************************************
+ *! \fn	bmgr_driver_init
+ **************************************************************************
+ *
+ *  \brief	Initializes the buffer manager driver.
+ *  		Must be the first driver's function to be called
+ *
+ *  \return	PP_RC_SUCCESS on success, other error code on failure
+ *
+ **************************************************************************/
+s32 bmgr_driver_init(void);
+
+/**************************************************************************
+ *! \fn	bmgr_pool_configure
+ **************************************************************************
+ *
+ *  \brief	Configure a Buffer Manager pool
+ *
+ *  \param	pool_params:	Pool param from user
+ *  \param	pool_id[OUT]:	Pool ID
+ *
+ *  \return	PP_RC_SUCCESS on success, other error code on failure
+ *
+ **************************************************************************/
+s32 bmgr_pool_configure(const struct bmgr_pool_params* const pool_params, u8* const pool_id);
+
+/**************************************************************************
+ *! \fn	bmgr_policy_configure
+ **************************************************************************
+ *
+ *  \brief	Configure a Buffer Manager policy
+ *
+ *  \param	policy_params:	Policy param from user
+ *  \param	policy_id[OUT]:	Policy ID
+ *
+ *  \return	PP_RC_SUCCESS on success, other error code on failure
+ *
+ **************************************************************************/
+s32 bmgr_policy_configure(const struct bmgr_policy_params* const policy_params, u8* const policy_id);
+
+/**************************************************************************
+ *! \fn	bmgr_pop_buffer
+ **************************************************************************
+ *
+ *  \brief	Pops a buffer from the buffer manager
+ *
+ *  \param	buff_info:	Buffer information
+ *
+ *  \return	PP_RC_SUCCESS on success, other error code on failure
+ *
+ **************************************************************************/
+s32 bmgr_pop_buffer(struct bmgr_buff_info* const buff_info);
+
+/**************************************************************************
+ *! \fn	bmgr_push_buffer
+ **************************************************************************
+ *
+ *  \brief	Pushes a buffer back to the buffer manager
+ *
+ *  \param	buff_info:	Buffer information
+ *
+ *  \return	PP_RC_SUCCESS on success, other error code on failure
+ *
+ **************************************************************************/
+s32 bmgr_push_buffer(struct bmgr_buff_info* const buff_info);
+s32 qos_config(void *qmgr_buf);
+
+void new_init_bm(void);
+#endif /* _BMGR_H_ */
diff --git a/include/net/pp_bm_regs.h b/include/net/pp_bm_regs.h
new file mode 100755
index 000000000000..b757623938c5
--- /dev/null
+++ b/include/net/pp_bm_regs.h
@@ -0,0 +1,86 @@
+/*
+ * pp_common.h
+ * Description:
+ * PP bm regs Definitions
+ *
+ * GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2017 Intel Corporation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *  Intel Corporation
+ *  2200 Mission College Blvd.
+ *  Santa Clara, CA  97052
+ */
+
+#ifndef _PP_BMGR_REGS_H_
+#define _PP_BMGR_REGS_H_
+
+/*! \def PP_BMGR_MAX_POOLS_IN_POLICY
+ *       Max pools in policy
+ */
+#define PP_BMGR_MAX_POOLS_IN_POLICY					(4)
+
+
+#define BMGR_OFFSET_OF_POLICY(policy)										((policy) * (int)0x4)
+#define BMGR_OFFSET_OF_POOL(pool)											((pool) * (int)0x4)
+#define BMGR_OFFSET_OF_GROUP(group)											((group) * (int)0x4)
+#define BMGR_OFFSET_OF_POOL_IN_POLICY(pool, policy)							((BMGR_OFFSET_OF_POLICY(policy) * PP_BMGR_MAX_POOLS_IN_POLICY) + BMGR_OFFSET_OF_POOL(pool))
+// Regs
+#define BMGR_CTRL_REG_ADDR(BMGR_REG_BASE)									(BMGR_REG_BASE + 0x000)
+#define BMGR_POOL_MIN_GRNT_MASK_REG_ADDR(BMGR_REG_BASE)						(BMGR_REG_BASE + 0x004)
+#define BMGR_POOL_ENABLE_REG_ADDR(BMGR_REG_BASE)							(BMGR_REG_BASE + 0x008)
+#define BMGR_POOL_FIFO_RESET_REG_ADDR(BMGR_REG_BASE)						(BMGR_REG_BASE + 0x00C)
+#define BMGR_OCPM_BURST_SIZE_REG_ADDR(BMGR_REG_BASE)						(BMGR_REG_BASE + 0x010)
+#define BMGR_OCPM_NUM_OF_BURSTS_REG_ADDR(BMGR_REG_BASE)						(BMGR_REG_BASE + 0x014)
+#define BMGR_STATUS_REG_ADDR(BMGR_REG_BASE)									(BMGR_REG_BASE + 0x018)
+#define BMGR_POOL_SIZE_REG_ADDR(BMGR_REG_BASE, pool)						(BMGR_REG_BASE + 0x020 + BMGR_OFFSET_OF_POOL(pool))
+#define BMGR_GROUP_AVAILABLE_BUFF_REG_ADDR(BMGR_REG_BASE, group)			(BMGR_REG_BASE + 0x100 + BMGR_OFFSET_OF_GROUP(group))
+#define BMGR_GROUP_RESERVED_BUFF_REG_ADDR(BMGR_REG_BASE, group)				(BMGR_REG_BASE + 0x200 + BMGR_OFFSET_OF_GROUP(group))
+#define BMGR_POOL_PCU_FIFO_BASE_ADDR_REG_ADDR(BMGR_REG_BASE, pool)			(BMGR_REG_BASE + 0x400 + BMGR_OFFSET_OF_POOL(pool))
+#define BMGR_POOL_PCU_FIFO_SIZE_REG_ADDR(BMGR_REG_BASE, pool)				(BMGR_REG_BASE + 0x440 + BMGR_OFFSET_OF_POOL(pool))
+#define BMGR_POOL_PCU_FIFO_OCCUPANCY_REG_ADDR(BMGR_REG_BASE, pool)			(BMGR_REG_BASE + 0x480 + BMGR_OFFSET_OF_POOL(pool))
+#define BMGR_POOL_PCU_FIFO_PROG_EMPTY_REG_ADDR(BMGR_REG_BASE, pool)			(BMGR_REG_BASE + 0x4C0 + BMGR_OFFSET_OF_POOL(pool))
+#define BMGR_POOL_PCU_FIFO_PROG_FULL_REG_ADDR(BMGR_REG_BASE, pool)			(BMGR_REG_BASE + 0x500 + BMGR_OFFSET_OF_POOL(pool))
+#define BMGR_POOL_EXT_FIFO_OCC_REG_ADDR(BMGR_REG_BASE, pool)				(BMGR_REG_BASE + 0x5C0 + BMGR_OFFSET_OF_POOL(pool))
+#define BMGR_POOL_EXT_FIFO_BASE_ADDR_LOW_REG_ADDR(BMGR_REG_BASE, pool)		(BMGR_REG_BASE + 0x540 + BMGR_OFFSET_OF_POOL(pool))
+#define BMGR_POOL_EXT_FIFO_BASE_ADDR_HIGH_REG_ADDR(BMGR_REG_BASE, pool)		(BMGR_REG_BASE + 0x580 + BMGR_OFFSET_OF_POOL(pool))
+#define BMGR_POOL_ALLOCATED_COUNTER_REG_ADDR(BMGR_REG_BASE, pool)			(BMGR_REG_BASE + 0x600 + BMGR_OFFSET_OF_POOL(pool))
+#define BMGR_POOL_POP_COUNTER_REG_ADDR(BMGR_REG_BASE, pool)					(BMGR_REG_BASE + 0x640 + BMGR_OFFSET_OF_POOL(pool))
+#define BMGR_POOL_PUSH_COUNTER_REG_ADDR(BMGR_REG_BASE, pool)				(BMGR_REG_BASE + 0x680 + BMGR_OFFSET_OF_POOL(pool))
+#define BMGR_DDR_BURST_WRITE_COUNTER_REG_ADDR(BMGR_REG_BASE, pool)			(BMGR_REG_BASE + 0x6C0 + BMGR_OFFSET_OF_POOL(pool))
+#define BMGR_DDR_BURST_READ_COUNTER_REG_ADDR(BMGR_REG_BASE, pool)			(BMGR_REG_BASE + 0x700 + BMGR_OFFSET_OF_POOL(pool))
+#define BMGR_POOL_WATERMARK_LOW_THRESHOLD_REG_ADDR(BMGR_REG_BASE, pool)		(BMGR_REG_BASE + 0x740 + BMGR_OFFSET_OF_POOL(pool))
+#define BMGR_POOL_WATERMARK_LOW_COUNTER_REG_ADDR(BMGR_REG_BASE, pool)		(BMGR_REG_BASE + 0x780 + BMGR_OFFSET_OF_POOL(pool))
+#define BMGR_POLICY_NULL_COUNTER_REG_ADDR(BMGR_REG_BASE, policy)			(BMGR_REG_BASE + 0x800 + BMGR_OFFSET_OF_POLICY(policy))
+// Ram
+#define BMGR_POLICY_MAX_ALLOWED_ADDR(BMGR_RAM_BASE, policy)					(BMGR_RAM_BASE + 0x0000 + BMGR_OFFSET_OF_POLICY(policy))
+#define BMGR_POLICY_MIN_GUARANTEED_ADDR(BMGR_RAM_BASE, policy)				(BMGR_RAM_BASE + 0x1000 + BMGR_OFFSET_OF_POLICY(policy))
+#define BMGR_POLICY_GROUP_ASSOCIATED_ADDR(BMGR_RAM_BASE, policy)			(BMGR_RAM_BASE + 0x2000 + BMGR_OFFSET_OF_POLICY(policy))
+#define BMGR_POLICY_POOLS_MAPPING_ADDR(BMGR_RAM_BASE, policy)				(BMGR_RAM_BASE + 0x3000 + BMGR_OFFSET_OF_POLICY(policy))
+#define BMGR_POLICY_MAX_ALLOWED_PER_POOL_ADDR(BMGR_RAM_BASE, policy, pool)	(BMGR_RAM_BASE + 0x4000 + BMGR_OFFSET_OF_POLICY(policy) + (pool * 0x1000))
+#define BMGR_POLICY_ALLOC_BUFF_COUNTER_ADDR(BMGR_RAM_BASE, policy)			(BMGR_RAM_BASE + 0xA000 + BMGR_OFFSET_OF_POLICY(policy))
+#define BMGR_POLICY_ALLOC_BUFF_PER_POOL_COUNTER_ADDR(BMGR_RAM_BASE, pool, policy)	(BMGR_RAM_BASE + 0xB000 + BMGR_OFFSET_OF_POOL_IN_POLICY(pool, policy))
+
+// Data
+#define BMGR_DATAPATH_BASE_HOST						(0x18BC0000)
+#define BMGR_DATAPATH_BASE						(0x3C0000)
+
+#endif // _PP_BMGR_REGS_H_
+
diff --git a/include/net/pp_qos_drv.h b/include/net/pp_qos_drv.h
new file mode 100644
index 000000000000..72a25a25c521
--- /dev/null
+++ b/include/net/pp_qos_drv.h
@@ -0,0 +1,908 @@
+/*
+ * GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2017 Intel Corporation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *  Intel Corporation
+ *  2200 Mission College Blvd.
+ *  Santa Clara, CA  97052
+ */
+#ifndef _PP_QOS_API_H
+#define _PP_QOS_API_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
+
+/******************************************************************************/
+/*                                 GENERAL                                    */
+/******************************************************************************/
+
+/**
+ * DOC: Calling context
+ *
+ * The API exported by this driver, must be called only from a thread context.
+ * Calling them from either interrupt/tasklet/buttom half is not allowed and
+ * will result in unexpexted behaviour.
+ */
+
+/**
+ * DOC: Scheduling model
+ *
+ * Ports, schedulers and queues are modeled as a scheduling tree's nodes.
+ * Each such node properties are classified to the following categories:
+ * - Common properties - relevant to all nodes
+ * - Parent properties - relevant only to parent nodes e.g. arbitration scheme
+ *                       between children
+ * - Children properties - relevant only to child nodes e.g. node's parent
+ *
+ * Note some nodes can be both parents and children e.g. schedulers
+ */
+
+/**
+ * DOC: Arbitration
+ *
+ * The way a parent arbitrates between its children can be either strict prioriy
+ * or round robin.
+ *
+ * A WRR parent round robin its children - each child gets its turn - as if all
+ * children have the same priority. The number of children for this parent type
+ * is limited only by the number of nodes (> 1024)
+ *
+ * A WSP parent employs strict priorityi arbitration on its children - a child
+ * will get scheduled only if there is no other sibling with higher priority
+ * that can be scheduled. A WSP parent can have 8 direct children at most, each
+ * child must have a different priority. To configure more that 8 children for
+ * a WSP parent, or to have several children with the same priority,
+ * intermediate schedulers should be use.
+ *
+ * Example of 5 queues q0, q1, q2, q3, q4 with priorities 0, 1, 2, 3, 3
+ *
+ *                     Port arbitrating WSP
+ *                     /   |    |     \
+ *                    q0   q1  q2  Sched arbitrating WRR
+ *                                         |	      |
+ *                                        q3          q4
+ *
+ *
+ * Example of 16 queues q0 to q15, each with a different priority
+ *
+ *		      Port arbitrating WSP
+ *		         |	       |
+ *	    Sched0 arbitrating WSP   Sched1 arbitrating WSP
+ *	       /               \       /                   \
+ *	   q0 q1 q2 q3 q4 q5 q6 q7  q8 q9 q10 q11 q12 q13 q4 q15
+ */
+
+/**
+ * enum pp_qos_arbitration - parent method for arbitrating its children on tree.
+ * @PP_QOS_ARBITRATION_WSP: strict priority
+ * @PP_QOS_ARBITRATION_WRR: round robin
+ * @PP_QOS_ARBITRATION_WFQ:
+ */
+enum pp_qos_arbitration {
+	PP_QOS_ARBITRATION_WSP,
+	PP_QOS_ARBITRATION_WRR,
+	PP_QOS_ARBITRATION_WFQ,
+};
+
+
+/**
+ * struct pp_qos_common_node_properties - Properties common to all nodes
+ * @bandwidth_limit:	    bandwidth limit in Kbps
+ * @shared_bandwidth_group: shared bandwidth group
+ */
+struct pp_qos_common_node_properties {
+	#define QOS_NO_BANDWIDTH_LIMIT          0
+	#define QOS_MAX_BANDWIDTH_LIMIT         0xFFFF
+	unsigned int bandwidth_limit;
+
+	#define QOS_NO_SHARED_BANDWIDTH_GROUP   0x0
+	#define QOS_MAX_SHARED_BANDWIDTH_GROUP  511
+	unsigned int shared_bandwidth_group;
+};
+
+
+/**
+ * @struct pp_qos_parent_node_properties - Properties relevant for parent node
+ * @arbitration:	how parent node arbitrates between its children
+ * @best_effort_enable: whether best effort scheduling is enabled for this
+ *                      node's children.
+ */
+struct pp_qos_parent_node_properties {
+	enum pp_qos_arbitration arbitration;
+	int  best_effort_enable;
+};
+
+
+/**
+ * @struct pp_qos_child_node_properties - Properties relevant for child node
+ * @parent:		parent's id
+ * @priority:		strict priority, relevant only if parent uses wsp
+ *                      arbitration
+ * @bandwidth_share:	bandwidth precentage from parent
+ */
+struct pp_qos_child_node_properties {
+	unsigned int	parent;
+	#define QOS_MAX_CHILD_PRIORITY 7
+	unsigned int	priority;
+	unsigned int	bandwidth_share;
+};
+
+
+struct pp_qos_dev;
+
+/******************************************************************************/
+/*                                      PORTS                                 */
+/******************************************************************************/
+
+/**
+ * @struct pp_qos_port_stat - Statistics per port
+ * @total_green_bytes - total green bytes currently in all queues
+ *			feeding this port
+ * @total_yellow_bytes - total yellow bytes currently in all queues
+ *			 feeding this port
+ */
+struct pp_qos_port_stat {
+	int reset;
+	unsigned int total_green_bytes;
+	unsigned int total_yellow_bytes;
+};
+
+/**
+ * @struct pp_qos_port_conf - Configuration structure for port
+ * @common_prop:		common properties
+ * @port_parent_prop:		properties as a parent
+ * @ring_address:		address of ring.
+ * @ring_size:			size of ring.
+ * @packet_credit_enable:	packet credit mode (byte credit disabled).
+ * @credit:		        amount of credit to add to the port.
+ *                              when packet_credit is enabled this designates
+ *                              packet credit, otherwise byte credit
+ * @disable			disable port transmition
+ */
+struct pp_qos_port_conf {
+	struct pp_qos_common_node_properties common_prop;
+	struct pp_qos_parent_node_properties port_parent_prop;
+	void     *ring_address;
+	unsigned int ring_size;
+	int      packet_credit_enable;
+	unsigned int credit;
+	int	disable;
+};
+
+
+/**
+ * @struct pp_qos_port_info -  Port's information
+ * @physical_id:   node id on scheduling tree.
+ * @num_of_queues: number of queues feeds this port.
+ */
+struct pp_qos_port_info {
+	unsigned int physical_id;
+	unsigned int num_of_queues;
+};
+
+
+/**
+ * pp_qos_port_conf_set_default() - Init port configuration with default values
+ * @conf: pointer to client allocated struct. This struct will be filled with
+ * default values.
+ *
+ * Defaults values:
+ *    bandwidth_limit - QOS_NO_BANDWIDTH_LIMIT
+ *    shared_bandwidth_limit - QOS_NO_SHARED_BANDWIDTH_GROUP
+ *    arbitration - WSP
+ *    best_effort_enable - no
+ *    packet_credit_enable - yes
+ *    byte_credit_enable - no
+ *    packet_credit - 0
+ *    byte_credit - 0
+ *    ring_size - 0
+ *    ring_address - 0
+ */
+void pp_qos_port_conf_set_default(struct pp_qos_port_conf *conf);
+
+
+#define ALLOC_PORT_ID 0xFFFF
+/**
+ * pp_qos_port_allocate() - Allocate a resource for a new port
+ * @qos_dev:     handle to qos device instance obtained previously
+ *               from pp_qos_dev_open
+ * @physical_id: if equal ALLOC_PORT_ID then library allocates
+ *               a free port id for the new port, otherwise must
+ *               be one of the reserved ports ids that were
+ *               configured at qos_init
+ * @id:          upon success holds new port's id
+ *
+ * @Return:  0 on success.
+ */
+int pp_qos_port_allocate(struct pp_qos_dev *qos_dev, unsigned int physical_id,
+			 unsigned int *id);
+
+
+/**
+ * pp_qos_port_remove() - Remove port
+ * @qos_dev: handle to qos hardware instance.
+ * @id: port's id obtained from port_allocate
+ *
+ * @Return: 0 on success.
+ */
+int pp_qos_port_remove(struct pp_qos_dev *qos_dev, unsigned int id);
+
+
+/**
+ * pp_qos_port_set() - Set port configuration
+ * @qos_dev:   handle to qos device instance obtained previously from
+ *         qos_dev_init
+ * @id:    port's id obtained from port_allocate
+ * @conf:  port configuration.
+ *
+ * @Return: 0 on success
+ */
+int pp_qos_port_set(struct pp_qos_dev *qos_dev, unsigned int id,
+		    const struct pp_qos_port_conf *conf);
+
+
+/**
+ * pp_qos_port_disable() - Remove port desendants from scheduling
+ * @qos_dev: handle to qos hardware instance.
+ * @id:  port's id obtained from port_allocate
+ *
+ * @Return: 0 on success
+ */
+int pp_qos_port_disable(struct pp_qos_dev *qos_dev, unsigned int id);
+
+
+/**
+ * pp_qos_port_enable() - Resume port and its decendants scheduling
+ * @qos_dev: handle to qos hardware instance.
+ * @id:  port's id obtained from port_allocate
+ *
+ * @Return: 0 on success
+ */
+int pp_qos_port_enable(struct pp_qos_dev *qos_dev, unsigned int id);
+
+/**
+ * pp_qos_port_block() - All new packets enqueued to queues feeding this port
+ *                    will be dropped
+ * @qos_dev: handle to qos hardware instance.
+ * @id:  port's id obtained from port_allocate
+ *
+ * Note	- already enportd descriptors will be transmitted
+ *
+ * Return: 0 on success
+ */
+int pp_qos_port_block(struct pp_qos_dev *qos_dev, unsigned int id);
+
+
+/**
+ * pp_qos_port_unblock() - Unblock enqueuing of new packets to queues that feeds
+ *                      this port
+ * @qos_dev: handle to qos hardware instance.
+ * @id:	 port's id obtained from port_allocate
+ *
+ * Return: 0 on success
+ */
+int pp_qos_port_unblock(struct pp_qos_dev *qos_dev, unsigned int id);
+
+
+/**
+ * pp_qos_port_flush() - Drop all enqueued packets on queues under this port
+ * @qos_dev: handle to qos hardware instance.
+ * @id:	 port's id obtained from port_allocate
+ *
+ * Return: 0 on success
+ */
+int pp_qos_port_flush(struct pp_qos_dev *qos_dev, unsigned int id);
+
+
+/**
+ * pp_qos_port_conf_get() - Get port configuration
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * id:	  port's id obtained from port_allocate
+ * @conf: pointer to struct to be filled with port's configuration
+ *
+ * Return: 0 on success
+ */
+
+int pp_qos_port_conf_get(struct pp_qos_dev *qos_dev, unsigned int id,
+			 struct pp_qos_port_conf *conf);
+
+
+/**
+ * pp_qos_port_info_get() - Get extra information about port
+ * id:	  port's id obtained from port_allocate
+ * @info: pointer to struct to be filled with port's info
+ *
+ * Return: 0 on success
+ */
+int pp_qos_port_info_get(struct pp_qos_dev *qos_dev, unsigned int id,
+			 struct pp_qos_port_info *info);
+
+
+/**
+ * pp_qos_port_get_queues() - Get all port's queues
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id:	        scheduler's id obtained from sched_allocate
+ * @queue_ids:  client allocated array that will hold queues ids
+ * @size:       size of queue_ids
+ * @queues_num: holds the number of queues
+ *
+ * Note queues_num can be bigger than size
+ *
+ * Return: 0 on success
+ */
+int pp_qos_port_get_queues(struct pp_qos_dev *qos_dev, unsigned int id,
+			   uint16_t *queue_ids, unsigned int size,
+			   unsigned int *queues_num);
+
+
+/**
+ * pp_qos_port_stat_get() - Get port's statistics
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id:	  port's id obtained from port_allocate
+ * @stat: pointer to struct to be filled with port's statistics
+ *
+ * Return: 0 on success
+ */
+int pp_qos_port_stat_get(struct pp_qos_dev *qos_dev, unsigned int id,
+			 struct pp_qos_port_stat *stat);
+
+
+/******************************************************************************/
+/*                                    QUEUES                                  */
+/******************************************************************************/
+
+/**
+ * @struct pp_qos_queue_stat - Statistics per queue
+ * @reset:		       Should statistics be reset after reading
+ * @queue_packets_occupancy:   Packetes currently in queue
+ * @queue_bytes_occupancy:     Bytes currently in queue
+ * @total_packets_accepted:    Packets accepted by WRED
+ * @total_packets_dropped:     Packets dropped by WRED due any reason
+ * @total_packets_red_dropped: Packets dropped by WRED due to being red
+ * @total_bytes_accepted:      Bytes accepted by WRED
+ * @total_bytes_dropped:       Bytes dropped by WRED
+ */
+struct pp_qos_queue_stat {
+	int reset;
+	unsigned int	queue_packets_occupancy;
+	unsigned int	queue_bytes_occupancy;
+	unsigned int	total_packets_accepted;
+	unsigned int	total_packets_dropped;
+	unsigned int	total_packets_red_dropped;
+	uint64_t	total_bytes_accepted;
+	uint64_t	total_bytes_dropped;
+};
+
+/**
+ * @struct pp_qos_queue_conf - Configuration structure for queue
+ * @common_prop:		common properties
+ * @queue_child_prop:           properties as a child node
+ * @max_burst:		        max burst in Kbps
+ * @blocked:			queue will drop new enqueued packets
+ * @aliased:			queue will be aliased by another queue
+ * @wred_enable:		WRED is applied on this queue, otherwise only
+ *                              min and max values are used
+ * @wred_fixed_drop_prob_enable:use fixed drop probability for WRED instead of
+ *                              slope
+ * @queue_wred_min_avg_green:
+ * @queue_wred_max_avg_green:
+ * @queue_wred_slope_green:
+ * @queue_wred_fixed_drop_prob_green:
+ * @queue_wred_min_avg_yellow:
+ * @queue_wred_max_avg_yellow:
+ * @queue_wred_slope_yellow:
+ * @queue_wred_fixed_drop_prob_yellow:
+ * @queue_wred_min_guaranteed:
+ * @queue_wred_max_allowed:
+ */
+struct pp_qos_queue_conf {
+	struct pp_qos_common_node_properties common_prop;
+	struct pp_qos_child_node_properties  queue_child_prop;
+	unsigned int max_burst;
+	int      blocked;
+	int      aliased;
+	int	 wred_enable;
+	int      wred_fixed_drop_prob_enable;
+	unsigned int queue_wred_min_avg_green;
+	unsigned int queue_wred_max_avg_green;
+	unsigned int queue_wred_slope_green;
+	unsigned int queue_wred_fixed_drop_prob_green;
+	unsigned int queue_wred_min_avg_yellow;
+	unsigned int queue_wred_max_avg_yellow;
+	unsigned int queue_wred_slope_yellow;
+	unsigned int queue_wred_fixed_drop_prob_yellow;
+	unsigned int queue_wred_min_guaranteed;
+	unsigned int queue_wred_max_allowed;
+};
+
+
+/**
+ * @struct pp_qos_queue_info - Queue information struct
+ * @port_id:	 port fed by this queue
+ * @physical_id: queue (ready list) number
+ * @alias_master_id: Id of the queue which is aliased by this queue,
+ *                   PP_QOS_INVALID_ID if this queue does not alias any queue
+ * @alias_slave_id: Id of the queue aliasing this queue, PP_QOS_INVALID_ID
+ *                  if this queue is not aliased by any queue.
+ *
+ */
+#define PP_QOS_INVALID_ID 0xFFFF
+struct pp_qos_queue_info {
+	unsigned int port_id;
+	unsigned int physical_id;
+	unsigned int alias_slave_id;
+	unsigned int alias_master_id;
+};
+
+
+/**
+ * pp_qos_queue_conf_set_default() - Init configuration with default values
+ * @conf: pointer to client allocated struct. This struct will be filled with
+ * default values.
+ *
+ * Defaults values:
+ *    max_burst - 0
+ *    bandwidth_limit - 0
+ *    shared_bandwidth_limit - 0
+ *    parent - 0
+ *    priority - 0
+ *    bandwidth_share - 0
+ *    wred_enable - no
+ *    ALL wred params - 0
+ */
+void pp_qos_queue_conf_set_default(struct pp_qos_queue_conf *conf);
+
+
+/**
+ * pp_qos_queue_allocate() - Allocate aresouirce for a new queue
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id:   upon success hold's new queue id
+ *
+ * Return:  0 on success.
+ */
+int pp_qos_queue_allocate(struct pp_qos_dev *qos_dev, unsigned int *id);
+
+
+/**
+ * pp_qos_queue_remove() -	Remove a queue
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id:   queue's id obtained from queue_allocate
+ *
+ * Note: client should make sure that queue is empty and
+ *       that new packets are not enqueued, by calling
+ *       pp_qos_queue_disable and pp_qos_queue_flush
+ *
+ * Return: 0 on success
+ */
+int pp_qos_queue_remove(struct pp_qos_dev *qos_dev, unsigned int id);
+
+
+/**
+ * pp_qos_queue_set() - Set queue configuration
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id:	  queue's id obtained from queue_allocate
+ * @conf: new configuration for the queue
+ *
+ * Return: 0 on success
+ */
+int pp_qos_queue_set(struct pp_qos_dev *qos_dev, unsigned int id,
+		     const struct pp_qos_queue_conf *conf);
+
+
+/**
+ * pp_qos_queue_block() - All new packets enqueue to this queue will be dropped
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id:   queue's id obtained from queue_allocate
+ *
+ * Note	- already enqueued descriptors will be transmitted
+ *
+ * Return: 0 on success
+ */
+int pp_qos_queue_block(struct pp_qos_dev *qos_dev, unsigned int id);
+
+
+/**
+ * pp_qos_queue_unblock() - Unblock enqueuing of new packets
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id:	  queue's id obtained from queue_allocate
+ *
+ * Return: 0 on success
+ */
+int pp_qos_queue_unblock(struct pp_qos_dev *qos_dev, unsigned int id);
+
+
+/**
+ * pp_qos_queue_flush() - Drop all enqueued packets
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id:	  queue's id obtained from queue_allocate
+ *
+ * Return: 0 on success
+ */
+int pp_qos_queue_flush(struct pp_qos_dev *qos_dev, unsigned int id);
+
+
+/**
+ * pp_qos_queue_conf_get() - Get queue current configuration
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * id:	  port's id obtained from queue_allocate
+ * @conf: pointer to struct to be filled with queue's configuration
+ *
+ * Return: 0 on success
+ */
+int pp_qos_queue_conf_get(struct pp_qos_dev *qos_dev, unsigned int id,
+			  struct pp_qos_queue_conf *conf);
+
+
+/**
+ * pp_qos_queue_info_get() - Get information about queue
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id:	  queue's id obtained from queue_allocate
+ * @info: pointer to struct to be filled with queue's info
+ *
+ * Return: 0 on success
+ */
+int pp_qos_queue_info_get(struct pp_qos_dev *qos_dev, unsigned int id,
+			  struct pp_qos_queue_info *info);
+
+
+/**
+ * pp_qos_queue_stat_get() - Get queue's statistics
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id:	  queue's id obtained from queue_allocate
+ * @stat: pointer to struct to be filled with queue's statistics
+ *
+ * Return: 0 on success
+ */
+int pp_qos_queue_stat_get(struct pp_qos_dev *qos_dev, unsigned int id,
+			  struct pp_qos_queue_stat *stat);
+
+
+/******************************************************************************/
+/*                                 SCHEDULER                                  */
+/******************************************************************************/
+
+/**
+ * @struct pp_qos_sched_conf - Configuration structure for scheduler
+ * @qos_dev:               handle to qos device instance obtained
+ *                     previously from pp_qos_dev_open
+ * @common_prop:       common properties as a node
+ * @sched_parent_prop: properties as a parent node
+ * @sched_child_node:  properties as a child node
+ */
+struct pp_qos_sched_conf {
+	struct pp_qos_common_node_properties common_prop;
+	struct pp_qos_parent_node_properties sched_parent_prop;
+	struct pp_qos_child_node_properties  sched_child_prop;
+};
+
+
+/**
+ * @struct pp_qos_sched_info - Scheduler information struct
+ * @qos_dev:                    handle to qos device instance obtained
+ *                          previously from pp_qos_dev_open
+ * @port_id:		    port fed by this scheduler
+ * @num_of_queues:	    number of queues feed this scheduler.
+ */
+struct pp_qos_sched_info {
+	unsigned int port_id;
+	unsigned int num_of_queues;
+};
+
+
+/**
+ * pp_qos_sched_conf_set_default() - Init scheduler config with defaults
+ * @conf: pointer to client allocated struct which will be filled with
+ *        default values
+ *
+ * Defaults values:
+ *    bandwidth_limit - 0
+ *    shared_bandwidth_limit - 0
+ *    arbitration - WSP
+ *    best_effort_enable - no
+ *    parent - 0
+ *    priority - 0
+ *    bandwidth_share - 0
+ */
+void pp_qos_sched_conf_set_default(struct pp_qos_sched_conf *conf);
+
+
+/**
+ * pp_qos_sched_allocate() - Allocate a resource for a new scheduler
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id:   upon success - holds new scheduler's id
+ *
+ * Return:  0 on success.
+ */
+int pp_qos_sched_allocate(struct pp_qos_dev *qos_dev, unsigned int *id);
+
+
+/**
+ * pp_qos_sched_remove() -	Remove scheduler
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id:	  scheduler's id obtained from sched_allocate
+ *
+ * Return:	0 on success
+ */
+int pp_qos_sched_remove(struct pp_qos_dev *qos_dev, unsigned int id);
+
+
+/**
+ * pp_qos_sched_set() - Set scheduler configuration
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id:	  scheduler's id obtained from sched_allocate
+ * @conf: new configuration for the scheduler
+ *
+ * Note: must init conf by pp_qos_sched_conf_init before calling
+ *       this function.
+ *
+ * Return: 0 on success
+ */
+int pp_qos_sched_set(struct pp_qos_dev *qos_dev, unsigned int id,
+		     const struct pp_qos_sched_conf *conf);
+
+
+/**
+ * pp_qos_sched_conf_get() - Get sched current configuration
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * id:	  port's id obtained from port_allocate
+ * @conf: pointer to struct to be filled with sched's configuration
+ *
+ * Return: 0 on success
+ */
+int pp_qos_sched_conf_get(struct pp_qos_dev *qos_dev, unsigned int id,
+			  struct pp_qos_sched_conf *conf);
+
+
+/**
+ * pp_qos_sched_info_get() - Get information about scheduler
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id:	  scheduler's id obtained from sched_allocate
+ * @info: pointer to struct to be filled with scheduler's info
+ *
+ * Return: 0 on success
+ */
+int pp_qos_sched_info_get(struct pp_qos_dev *qos_dev, unsigned int id,
+			  struct pp_qos_sched_info *info);
+
+
+/**
+ * pp_qos_sched_get_queues() - Get all scheduler's queues
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id:	        scheduler's id obtained from sched_allocate
+ * @queue_ids:  client allocated array that will hold queues ids
+ * @size:       size of queue_ids
+ * @queues_num: holds the number of queues
+ *
+ * Note queues_num can be bigger than size
+ *
+ * Return: 0 on success
+ */
+int pp_qos_sched_get_queues(struct pp_qos_dev *qos_dev, unsigned int id,
+			    uint16_t *queue_ids, unsigned int size,
+			    unsigned int *queues_num);
+
+/******************************************************************************/
+/*                                 SHARED_LIMIT                               */
+/******************************************************************************/
+
+/**
+ * qos_shared_limit_group_add() - Add new shared bandwidth group
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @limit: bandwidth limit in Kbps
+ * @id:    upon success, new group's id
+ *
+ * Return: 0 on success
+ */
+int pp_qos_shared_limit_group_add(struct pp_qos_dev *qos_dev,
+				  unsigned int limit, unsigned int *id);
+
+
+/**
+ * pp_qos_shared_limit_group_remove() - Remove shared bandwidth group
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id: group's id previously obtained when adding group
+ *
+ * Return: 0 on success
+ */
+int pp_qos_shared_limit_group_remove(struct pp_qos_dev *qos_dev,
+				     unsigned int id);
+
+
+/**
+ * pp_qos_shared_limit_group_modify() - Modify shared bandwidth group
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id: group's id previously obtained when adding group
+ * @limit: bandwidth limit in Kbps
+ *
+ * Return: 0 on success
+ */
+int pp_qos_shared_limit_group_modify(struct pp_qos_dev *qos_dev,
+				     unsigned int id, unsigned int limit);
+
+
+/**
+ * pp_qos_shared_limit_group_get_members() - Get group's members
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @id:	   shared bandwidth group id
+ * @members:   client allocated array that will hold ids members
+ * @size:        size of ids
+ * @members_num: holds the number of members
+ *
+ * Notes:
+ * members_num can be bigger than size
+ * function iterates over tree so it is rather slow
+ *
+ * Return: 0 on success
+ */
+int pp_qos_shared_limit_group_get_members(struct pp_qos_dev *qos_dev,
+					  unsigned int id, uint16_t *members,
+					  unsigned int size,
+					  unsigned int *members_num);
+
+
+
+/******************************************************************************/
+/*                                  INIT	                              */
+/******************************************************************************/
+
+/**
+ * pp_qos_dev_open() -	Initialize of a qos device
+ * @id: Identify the requested qos instance (same id that
+ *      designates the instance in the device tree)
+ *
+ * Return: on success handle to qos device
+ *         NULL otherwise
+ */
+struct pp_qos_dev *pp_qos_dev_open(unsigned int id);
+
+
+/**
+ * @struct pp_qos_init_param - qos subsystem initialization struct
+ * @wred_total_avail_resources: upper bound for the sum of bytes on all queues
+ * @wred_p_const:         WRED algorithm p, used for calculating avg queue depth
+ *                        avg = (old_avg*(1-p)) + (curr_avg*p)
+ *                        p is taken to b wred_p_const / 1023
+ *                        wred_p_const should be in the range 0..1023
+ * @wred_max_q_size:      maximum size on bytes of any queue
+ * @reserved_ports:       These ports are reserved for client to explicity
+ *                        select the physical_port ithat will be used when
+ *                        adding a new port. All other non reserved ports are
+ *                        managed by the system, i.e. when client adds a new
+ *                        port system will select a new free port from the
+ *                        unreserved ports.
+ *                        To reserve a port its value on the array should be
+ *                        not 0
+ */
+struct pp_qos_init_param {
+	unsigned int wred_total_avail_resources;
+	unsigned int wred_p_const;
+	unsigned int wred_max_q_size;
+	#define QOS_MAX_PORTS    256
+	unsigned int reserved_ports[QOS_MAX_PORTS];
+};
+
+
+/**
+ * pp_qos_dev_init() - set qos system wide configuration
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @conf:
+ *
+ * Note
+ * All other functions except pp_qos_dev_open will failed if called
+ * before this function
+ *
+ * Return: 0 on success
+ */
+int pp_qos_dev_init(struct pp_qos_dev *qos_dev, struct pp_qos_init_param *conf);
+
+/**
+ * pp_qos_dev_clean() - clean resources.
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ *
+ * Note:
+ *   qos_dev is invalid after this call
+ */
+void pp_qos_dev_clean(struct pp_qos_dev *qos_dev);
+
+
+/**
+ * pp_qos_get_fw_version () - get fw version
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @major: storage for major part of version
+ * @minor: storage for minor part of version
+ * @build: storage for build part of version
+ */
+int pp_qos_get_fw_version(
+		struct pp_qos_dev *qos_dev,
+		unsigned int *major,
+		unsigned int *minor,
+		unsigned int *build);
+
+
+enum pp_qos_node_type {
+	PPV4_QOS_NODE_TYPE_PORT,
+	PPV4_QOS_NODE_TYPE_SCHED,
+	PPV4_QOS_NODE_TYPE_QUEUE,
+};
+
+#define PPV4_QOS_INVALID (-1U)
+
+
+struct pp_qos_node_num {
+	/*
+	 * Physical node on scheduler's
+	 * node table
+	 */
+	unsigned int phy;
+
+	/*
+	 * Logical id seen by client
+	 */
+	unsigned int id;
+};
+
+/**
+ * struct pp_qos_node_info () -
+ * @ppv4_qos_node_type:
+ * @preds:		Ansectors of node (irrelevant to PORT)
+ * @num_of_children:    Number of direct children (irrelevant to QUEUE)
+ * @children:		Direct children of node (irrelevant to QUEUE)
+ * @is_internal:	Is it internal node
+ * @queue_physical_id:	Relevant only for QUEUE
+ * @bw_limit:		In Kbps
+ * @port:		The port (phy) that is fed from this queue
+ *                      (relevant only for QUEUE)
+ *
+ * Note:
+ * Since 0 is a valid value for some of the fields. PPV4_QOS_INVALID will
+ * be used to mark field value as irrelevant
+ *
+ * All above values except from type, is_internal and logical id
+ * are taken from HW and not from driver DB
+ */
+struct pp_qos_node_info {
+	enum pp_qos_node_type type;
+	struct pp_qos_node_num preds[6];
+	struct pp_qos_node_num children[8];
+	int is_internal;
+	unsigned int queue_physical_id;
+	unsigned int bw_limit;
+	unsigned int port;
+};
+
+/**
+ * pp_qos_get_node_info () - Obtain node's info
+ * @qos_dev: handle to qos device instance obtained from pp_qos_dev_open
+ * @info: Storage for info
+ * Return: 0 on success
+ */
+int pp_qos_get_node_info(
+		struct pp_qos_dev *qos_dev,
+		unsigned int id,
+		struct pp_qos_node_info *info);
+
+
+
+#endif
diff --git a/include/net/pp_qos_drv_slim.h b/include/net/pp_qos_drv_slim.h
new file mode 100644
index 000000000000..9ee7de4b7368
--- /dev/null
+++ b/include/net/pp_qos_drv_slim.h
@@ -0,0 +1,305 @@
+/*
+ * pp_qos_drv.h
+ * Description:
+ * PP QoS Manager driver definitions
+ *
+ * GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2017 Intel Corporation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *  Intel Corporation
+ *  2200 Mission College Blvd.
+ *  Santa Clara, CA  97052
+ */
+#ifndef PPQOSDRV_H_
+#define PPQOSDRV_H_
+
+#include <linux/types.h>
+
+#define PP_QOS_MAX_NODES			(2048)
+#ifdef FALCON_SOC
+	#define PP_QOS_MAX_PORT_NODES	(128)
+	#define PP_QOS_MAX_QUEUE_NODES	(256)
+#else /* PPv4 */
+	#define PP_QOS_MAX_PORT_NODES	(256)
+	#define PP_QOS_MAX_QUEUE_NODES	(512)
+#endif
+//#define BIT(x)						(1<<(x))
+
+/* enum qos_node_type_e:
+ * Describing the QoS node type
+ */
+enum qos_node_type_e {
+	QOS_NODE_PORT,
+	QOS_NODE_SCH,
+	QOS_NODE_QUEUE,
+	QOS_NODE_TYPE_MAX
+};
+
+/* enum qos_op_type_e:
+ * Describing the qos_node_config API
+ * Operation type
+ */
+enum qos_op_type_e {
+	QOS_OP_ADD,
+	QOS_OP_REMOVE,
+	QOS_OP_MODIFY,
+	QOS_OP_SUSPEND,
+	QOS_OP_RESUME,
+	QOS_OP_MOVE,
+	QOS_OP_QUERY
+};
+
+/* enum qos_sch_type_e:
+ * Describing the node
+ * Scheduling type
+ */
+enum qos_sch_type_e {
+	QOS_SCH_WSP_WRR,
+	QOS_SCH_WFQ
+};
+
+/* struct qos_init_param:
+ * This structure is using
+ * For Initialized the QoS subsystem
+ */
+struct qos_init_param {
+	u32	qm_base_addr;
+	u32	qm_num_of_pages;
+	u32	wred_prioritized_pop;
+	u32	wred_p_const;
+};
+
+/* struct qos_node_conf:
+ * General information for node
+ * Configuration
+ */
+struct qos_node_conf {
+	enum qos_node_type_e	node_type;
+	enum qos_sch_type_e	sch_type;
+	u16			node_id;
+	u16			bw_limit_Mbps;
+	u16			shared_bw_limit_group;
+	u8			bw_allocation_weight;
+	u8			priority;
+	u16			parent_node_id;
+	u16			child_node_id;
+};
+
+/* struct qos_port_conf:
+ * Information for port
+ * Configuration
+ */
+struct qos_port_conf {
+	u32		port_conf_flags;
+#define PORT_PARAM_FLAG_DISABLE_BYTES_CREDIT	BIT(0)
+#define PORT_PARAM_FLAG_BYTES_CREDIT_SET		BIT(1)
+#define PORT_PARAM_FLAG_PACKETS_CREDIT_SET		BIT(2)
+#define PORT_PARAM_FLAG_RING_ADDR_SET			BIT(3)
+#define PORT_PARAM_FLAG_RING_SIZE_SET			BIT(4)
+	u32		port_tx_packets_credit;
+	u32		port_tx_bytes_credit;
+	u32		port_tx_ring_address;
+	u32		port_tx_ring_size;
+};
+
+/* struct qos_queue_conf:
+ * Information for queue
+ * Configuration
+ */
+struct qos_queue_conf {
+	u32		queue_conf_flags;
+#define QUEUE_PARAM_FLAG_DISABLE_WRED				BIT(0)
+#define QUEUE_PARAM_FLAG_WRED_MIN_AVG_GREEN_SET		BIT(1)
+#define QUEUE_PARAM_FLAG_WRED_MAX_AVG_GREEN_SET		BIT(2)
+#define QUEUE_PARAM_FLAG_WRED_SLOPE_GREEN_SET		BIT(3)
+#define QUEUE_PARAM_FLAG_WRED_MIN_AVG_YELLOW_SET	BIT(4)
+#define QUEUE_PARAM_FLAG_WRED_MAX_AVG_YELLOW_SET	BIT(5)
+#define QUEUE_PARAM_FLAG_WRED_SLOPE_YELLOW_SET		BIT(6)
+#define QUEUE_PARAM_FLAG_DISABLE_MIN_GUARANTEED		BIT(7)
+#define QUEUE_PARAM_FLAG_MIN_GUARANTEED_SET			BIT(8)
+#define QUEUE_PARAM_FLAG_DISABLE_MAX_ALLOWED		BIT(9)
+#define QUEUE_PARAM_FLAG_MAX_ALLOWED_SET			BIT(10)
+	u16		queue_wred_min_avg_green;
+	u16		queue_wred_max_avg_green;
+	u16		queue_wred_slope_green;
+	u16		queue_wred_min_avg_yellow;
+	u16		queue_wred_max_avg_yellow;
+	u16		queue_wred_slope_yellow;
+	u16		queue_wred_min_guaranteed;
+	u16		queue_wred_max_allowed;
+};
+
+/* struct output_param:
+ * Information for output
+ * Parameters
+ */
+struct output_param {
+	u32		output_flags;
+#define OUTPUT_PARAM_FLAG_NODE_ID_SET		BIT(0)
+#define OUTPUT_PARAM_FLAG_PHY_QUEUE_ID_SET	BIT(1)
+	u16		node_id;
+	u16		queue_id;
+};
+
+/* struct qos_node_api_param:
+ * This structure is using as
+ * qos_node_config API parameter
+ */
+struct qos_node_api_param {
+	enum qos_op_type_e		op_type;
+	u32				node_conf_flags;
+	int 				deq_port;
+#define NODE_PARAM_FLAG_NODE_ID_SET		BIT(0)
+#define NODE_PARAM_FLAG_BW_LIMIT_SET		BIT(1)
+#define NODE_PARAM_FLAG_SBW_LIMIT_SET		BIT(2)
+#define NODE_PARAM_FLAG_BW_ALLOCATION_SET	BIT(3)
+#define NODE_PARAM_FLAG_PRIORITY_SET		BIT(4)
+#define NODE_PARAM_FLAG_PARENT_NODE_SET		BIT(5)
+#define NODE_PARAM_FLAG_CHILD_NODE_SET		BIT(6)
+#define NODE_PARAM_FLAG_EXTRA_PORT_CONF_SET	BIT(7)
+#define NODE_PARAM_FLAG_EXTRA_QUEUE_CONF_SET	BIT(8)
+	struct qos_node_conf	node_conf;
+	struct qos_port_conf	port_conf;
+	struct qos_queue_conf	queue_conf;
+	struct output_param	out_param;
+};
+
+/* struct qos_node_stats:
+ * Information for node statistics
+ */
+struct qos_node_stats {
+	u16	object_id;
+	u16	stats_req_flags;
+#define STATS_FLAG_GET_BY_NODE_ID			BIT(0)
+#define STATS_FLAG_GET_BY_QUEUE_ID			BIT(1)
+#define STATS_FLAG_GET_BY_PORT_ID			BIT(2)
+#define STATS_FLAG_GET_TOTAL_FWD_PACKETS	BIT(3)
+#define STATS_FLAG_GET_TOTAL_FWD_BYTES		BIT(4)
+#define STATS_FLAG_GET_TOTAL_DRP_PACKETS	BIT(5)
+#define STATS_FLAG_GET_TOTAL_DRP_BYTES		BIT(6)
+#define STATS_FLAG_GET_CURR_Q_PACKETS_SIZE	BIT(7)
+#define STATS_FLAG_GET_CURR_Q_BYTES_SIZE	BIT(8)
+#define STATS_FLAG_GET_CURR_WRED_AVG_SIZE	BIT(9)
+#define STATS_FLAG_GET_CURR_WRED_DRP_PROB_G	BIT(10)
+#define STATS_FLAG_GET_CURR_WRED_DRP_PROB_Y	BIT(11)
+#define STATS_FLAG_RESET_COUNTERS			BIT(12)
+#define STATS_FLAG_GET_ALL_COUNTERS			BIT(15)
+	u32	total_fwd_pkt;
+	u64	total_fwd_byte;
+	u32	total_drp_pkt;
+	u64	total_drp_byte;
+	u32	curr_q_pkt_size; /* Available only for node type queue */
+	u32	curr_q_byte_size; /* Available only for node type queue */
+	u32	curr_wred_avg_size; /* Available only for node type queue */
+	u32	curr_wred_drp_prob_green; /* Available only for node type queue */
+	u32	curr_wred_drp_prob_yellow; /* Available only for node type queue */
+};
+
+/* struct qos_node_api_param:
+ * enum qos_op_type_e		op_type;				Add/Remove/Modify/Suspend/Resume/Move/Query
+ * u32						node_conf_flags;
+ * NODE_PARAM_FLAG_NODE_ID_SET						Node ID set
+ * NODE_PARAM_FLAG_BW_LIMIT_SET						BW Limit set
+ * NODE_PARAM_FLAG_SBW_LIMIT_SET					Shared BW Limit set
+ * NODE_PARAM_FLAG_BW_ALLOCATION_SET				BW Allocation set
+ * NODE_PARAM_FLAG_PRIORITY_SET						Priority set
+ * NODE_PARAM_FLAG_PARENT_NODE_SET					Parent Node ID set
+ * NODE_PARAM_FLAG_CHILD_NODE_SET					Child Node ID set
+ * NODE_PARAM_FLAG_EXTRA_PORT_CONF_SET				Extra Port Configuration set
+ * NODE_PARAM_FLAG_EXTRA_QUEUE_CONF_SET				Extra Queue Configuration set
+ *
+ * struct qos_node_conf:
+ * enum qos_node_type_e	node_type;					Port/Scheduler/Queue Node
+ * enum qos_sch_type_e		sch_type;				Not relevant for queue: WSP+WRR, WFQ [Cannot be modified]
+ * u16						node_id;				Logical Node ID For Input [0:2047]
+ * u16						bw_limit_Mbps;			0 = No BW Limit applied
+ * u16						shared_bw_limit_group;	[0-511], Shared BW limit group ID
+ * u8						bw_allocation_weight;	0 = Best Effort [1 in credit]
+ * u8						priority;				[0..7], 0xFF = WRR, not relevant for WFQ
+ * u16						parent_node_id;			Relevant only for Add operation for Scheduler/Queue
+ * u16						child_node_id;			Optional.
+ *													Relevant only for Add operation in case Node need to be set up between parent and specific child.
+ *													In this case, the added Node inherits all its non-configured attributes from the child node
+ *
+ * struct qos_port_conf:
+ * u32	port_conf_flags;
+ * PORT_PARAM_FLAG_DISABLE_BYTES_CREDIT				Disable bytes credit option
+ * PORT_PARAM_FLAG_BYTES_CREDIT_SET					Bytes credit set
+ * PORT_PARAM_FLAG_PACKETS_CREDIT_SET				Packet credit set
+ * PORT_PARAM_FLAG_RING_ADDR_SET					Ring address set
+ * PORT_PARAM_FLAG_RING_SIZE_SET					Ring size set
+ * u32	port_tx_packets_credit;						TX Port Packet credit
+ * u32	port_tx_bytes_credit;						TX Port Byte Credit
+ * u32	port_tx_ring_address;						TX Port Ring address
+ * u32	port_tx_ring_size;							TX Port Ring size
+ *
+ * struct qos_queue_conf:
+ * u32	queue_conf_flags;
+ * QUEUE_PARAM_FLAG_DISABLE_WRED					Disable WRED feature
+ * QUEUE_PARAM_FLAG_WRED_MIN_AVG_GREEN_SET			WRED Min average green set
+ * QUEUE_PARAM_FLAG_WRED_MAX_AVG_GREEN_SET			WRED Max average green set
+ * QUEUE_PARAM_FLAG_WRED_SLOPE_GREEN_SET			WRED Slope green set
+ * QUEUE_PARAM_FLAG_WRED_MIN_AVG_YELLOW_SET			WRED Min average yellow set
+ * QUEUE_PARAM_FLAG_WRED_MAX_AVG_YELLOW_SET			WRED Max average yellow set
+ * QUEUE_PARAM_FLAG_WRED_SLOPE_YELLOW_SET			WRED Slope yellow set
+ * QUEUE_PARAM_FLAG_DISABLE_MIN_GUARANTEED			Disable Min guaranteed feature
+ * QUEUE_PARAM_FLAG_MIN_GUARANTEED_SET				Min guaranteed set
+ * QUEUE_PARAM_FLAG_DISABLE_MAX_ALLOWED				Disable Max allowed feature
+ * QUEUE_PARAM_FLAG_MAX_ALLOWED_SET					Max allowed set
+ * u16	queue_wred_min_avg_green;					WRED Min average green
+ * u16	queue_wred_max_avg_green;					WRED Max average green
+ * u16	queue_wred_slope_green;						WRED Slope green
+ * u16	queue_wred_min_avg_yellow;					WRED Min average yellow
+ * u16	queue_wred_max_avg_yellow;					WRED Max average yellow
+ * u16	queue_wred_slope_yellow;					WRED Slope yellow
+ * u16	queue_wred_min_guaranteed;					Min guaranteed
+ * u16	queue_wred_max_allowed;						Max allowed
+ *
+ * struct output_param:
+ * u32	output_flags;
+ * OUTPUT_PARAM_FLAG_NODE_ID_SET					Logical Node ID set (by the QoS driver)
+ * OUTPUT_PARAM_FLAG_PHY_QUEUE_ID_SET				Phisical Queue ID set (by the QoS driver)
+ * u16	node_id;									Logical Node ID
+ * u16	queue_id;									Phisical Queue ID
+ */
+
+/**
+ * qos_node_config - Configure a QoS Node
+ * This API is the main QoS driver API
+ * Supported operation types are
+ * Defined in enum qos_op_type_e
+ * @param: API param from user
+ **/
+s32 qos_node_config(struct qos_node_api_param *param);
+
+/**
+ * qos_node_get_stats - Get Node stats structure
+ * @param: Stats structure from user
+ **/
+s32 qos_node_get_stats(struct qos_node_stats *param);
+
+/**
+ * qos_init_subsystem - Initialized QoS subsystem
+ * @param: Init structure from user
+ **/
+s32 qos_init_subsystem(struct qos_init_param *param);
+
+#endif /* PPQOSDRV_H_ */
