From d7dce2699b373ecc339c3f0ec46da044e391d823 Mon Sep 17 00:00:00 2001
From: Rekha Eswaran <rekha.eswaran@intel.com>
Date: Fri, 12 Apr 2019 14:16:27 +0800
Subject: [PATCH] DRVLIB_SW-2162 - Datapath changes from lgmdev x64 to master
 branch & 1st set of review comments addressed

---
 drivers/net/ethernet/lantiq/datapath/Makefile      |  11 +-
 .../ethernet/lantiq/datapath/gswip31/datapath_rx.c |   2 +-
 .../datapath/gswip31/datapath_tc_asym_vlan.c       |  11 +
 include/net/datapath_api_gswip30.h                 |   4 +-
 include/net/datapath_api_gswip31.h                 |  12 +-
 include/net/datapath_api_gswip32.h                 | 170 +++++++++++++
 include/net/datapath_api_ppv4.h                    | 264 +++++++++++++++++++++
 include/net/lantiq_cbm_api.h                       |   2 +-
 8 files changed, 462 insertions(+), 14 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/datapath/Makefile b/drivers/net/ethernet/lantiq/datapath/Makefile
index 6d7719c1d77a..646b5d71eba6 100644
--- a/drivers/net/ethernet/lantiq/datapath/Makefile
+++ b/drivers/net/ethernet/lantiq/datapath/Makefile
@@ -1,14 +1,17 @@
 obj-$(CONFIG_LTQ_DATAPATH) = datapath_api.o datapath_proc_api.o datapath_proc.o  datapath_misc.o datapath_notifier.o datapath_logical_dev.o datapath_instance.o datapath_platform_dev.o datapath_soc.o datapath_qos.o datapath_proc_qos.o
 
+ifneq ($(CONFIG_INTEL_DATAPATH_HAL_GSWIP32),)
+obj-$(CONFIG_INTEL_DATAPATH) += gswip32/
+endif
 ifneq ($(CONFIG_INTEL_DATAPATH_HAL_GSWIP31),)
-obj-$(CONFIG_LTQ_DATAPATH) += gswip31/
+obj-$(CONFIG_INTEL_DATAPATH) += gswip31/
 endif
 ifneq ($(CONFIG_INTEL_DATAPATH_HAL_GSWIP30),)
-obj-$(CONFIG_LTQ_DATAPATH) += gswip30/
+obj-$(CONFIG_INTEL_DATAPATH) += gswip30/
 endif
 
-ifneq ($(CONFIG_LTQ_DATAPATH_SWITCHDEV),)
-obj-$(CONFIG_LTQ_DATAPATH) += datapath_swdev.o
+ifneq ($(CONFIG_INTEL_DATAPATH_SWITCHDEV),)
+obj-$(CONFIG_INTEL_DATAPATH) += datapath_swdev.o
 endif
 
 obj-$(CONFIG_LTQ_DATAPATH) += datapath_ioctl.o
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_rx.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_rx.c
index 8ce58cdb0048..8cdcfab58b7e 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_rx.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_rx.c
@@ -206,7 +206,7 @@ int32_t dp_rx_31(struct sk_buff *skb, u32 flags)
 		goto RX_DROP;
 	}
 	dp_port = &dp_port_info[inst][port_id];
-#if IS_ENABLED(CONFIG_LTQ_DATAPATH_PTP1588)
+#if IS_ENABLED(CONFIG_INTEL_DATAPATH_PTP1588)
 	if (dp_port->f_ptp) {
 		ops = dp_port_prop[inst].mac_ops[port_id];
 		if (ops)
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_tc_asym_vlan.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_tc_asym_vlan.c
index 7c9cbb792210..2e0e41ac52ac 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_tc_asym_vlan.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_tc_asym_vlan.c
@@ -411,6 +411,17 @@ static int tc_vlan_filter(struct core_ops *ops,
 		j++;
 	}
 
+	/* Check if we have anything to configure */
+	if (j <= 0) {
+		/* Update bridge port */
+		ret = update_bp(ops,
+				(u32)info->bp,
+				vlan->dir == DP_DIR_INGRESS,
+				NULL,
+				NULL);
+		goto EXIT;
+	}
+
 	if (untagged < 0)
 		untagged = 0;
 	if (tagged < 0)
diff --git a/include/net/datapath_api_gswip30.h b/include/net/datapath_api_gswip30.h
index ebe263af99ff..b169f8c505d7 100644
--- a/include/net/datapath_api_gswip30.h
+++ b/include/net/datapath_api_gswip30.h
@@ -10,7 +10,7 @@
 #ifndef DATAPATH_API_GRX500_H
 #define DATAPATH_API_GRX500_H
 
-#ifdef CONFIG_LITTLE_ENDIAN
+#if IS_ENABLED(CONFIG_LITTLE_ENDIAN)
 struct dma_rx_desc_0 {
 	/* DWORD 0 */
 	union {
@@ -271,7 +271,7 @@ struct dma_tx_desc_3 {
 } __packed;
 
 #endif
-#ifdef CONFIG_CPU_BIG_ENDIAN
+#if IS_ENABLED(CONFIG_CPU_BIG_ENDIAN)
 /*Note:pmac normally not DWORD aligned. Most time 2 bytes aligment */
 struct pmac_rx_hdr {
 	/*byte 0 */
diff --git a/include/net/datapath_api_gswip31.h b/include/net/datapath_api_gswip31.h
index 2ebcede27a1c..9537238f5bbc 100644
--- a/include/net/datapath_api_gswip31.h
+++ b/include/net/datapath_api_gswip31.h
@@ -9,7 +9,7 @@
 #ifndef DATAPATH_API_PRX300_H
 #define DATAPATH_API_PRX300_H
 
-#ifdef CONFIG_LITTLE_ENDIAN
+#if IS_ENABLED(CONFIG_LITTLE_ENDIAN)
 struct dma_rx_desc_0 {
 	/* DWORD 0 */
 	union {
@@ -41,7 +41,7 @@ struct dma_rx_desc_0 {
 } __packed;
 #endif
 
-#ifdef CONFIG_LITTLE_ENDIAN
+#if IS_ENABLED(CONFIG_LITTLE_ENDIAN)
 struct dma_rx_desc_1 {
 	/* DWORD 1 */
 	union {
@@ -83,7 +83,7 @@ struct dma_rx_desc_1 {
 } __packed;
 #endif
 
-#ifdef CONFIG_LITTLE_ENDIAN
+#if IS_ENABLED(CONFIG_LITTLE_ENDIAN)
 struct dma_rx_desc_2 {
 	/*DWORD 2 */
 	union {
@@ -106,7 +106,7 @@ struct dma_rx_desc_2 {
 } __packed;
 #endif
 
-#ifdef CONFIG_LITTLE_ENDIAN
+#if IS_ENABLED(CONFIG_LITTLE_ENDIAN)
 struct dma_rx_desc_3 {
 	/*DWORD 3 */
 	union {
@@ -153,7 +153,7 @@ struct dma_rx_desc_3 {
 #define dma_tx_desc_2 dma_rx_desc_2
 #define dma_tx_desc_3 dma_rx_desc_3
 
-#ifdef CONFIG_CPU_BIG_ENDIAN
+#if IS_ENABLED(CONFIG_CPU_BIG_ENDIAN)
 /*Note:pmac normally not DWORD aligned. Most time 2 bytes aligment */
 struct pmac_rx_hdr { /*Egress PMAC header*/
 	/*byte 0 */
@@ -234,7 +234,7 @@ struct pmac_rx_hdr { /*Egress PMAC header*/
 } __packed;
 #endif
 
-#ifdef CONFIG_CPU_BIG_ENDIAN
+#if IS_ENABLED(CONFIG_CPU_BIG_ENDIAN)
 struct pmac_tx_hdr { /*Ingress PMAC header*/
 	/*byte 0 */
 	u8 tcp_chksum:1;
diff --git a/include/net/datapath_api_gswip32.h b/include/net/datapath_api_gswip32.h
new file mode 100644
index 000000000000..752d3bd3dcbf
--- /dev/null
+++ b/include/net/datapath_api_gswip32.h
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) Intel Corporation
+ * Author: Shao Guohua <guohua.shao@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+#ifndef DATAPATH_API_LGM_H
+#define DATAPATH_API_LGM_H
+
+struct dma_rx_desc_0 {
+	/* DWORD 0 */
+	union {
+		struct {
+			u32 dest_sub_if_id:16;
+			u32 dw0bit16:1;
+			u32 flow_id:8;
+			u32 dw0bit31:7;
+		} __packed field;
+		u32 all;
+	};
+} __packed;
+
+struct dma_rx_desc_1 {
+	/* DWORD 1 */
+	union {
+		struct {
+			u32 classid:4;
+			u32 ep:8;	/* This is the Gpid/Port */
+			u32 color:2;
+			u32 lro_type:2;
+			u32 enc:1;
+			u32 dec:1;
+			u32 src_pool:4;
+			u32 pkt_type:2;
+			u32 fcs:1;
+			u32 classen:1;
+			u32 pre_l2:2;
+			u32 ts:1;
+			u32 pmac:1;
+			u32 header_mode:1;
+			u32 redir:1;  /* egflag */
+		} __packed field;
+		u32 all;
+	};
+} __packed;
+
+struct dma_rx_desc_2 {
+	/*DWORD 2 */
+	union {
+		struct {
+			u32 byte_offset:3;
+			u32 data_ptr:29;
+		} __packed field;
+		u32 all;
+	};
+
+} __packed;
+
+struct dma_rx_desc_3 {
+	/*DWORD 3 */
+	union {
+		struct {
+			u32 data_len:14;
+			u32 pool_policy:8;
+			u32 sp:1;
+			u32 haddr:4;
+			u32 dic:1;
+			u32 eop:1;
+			u32 sop:1;
+			u32 c:1;
+			u32 own:1;
+		} __packed field;
+		u32 all;
+	};
+} __packed;
+
+
+#define dma_tx_desc_0 dma_rx_desc_0
+#define dma_tx_desc_1 dma_rx_desc_1
+#define dma_tx_desc_2 dma_rx_desc_2
+#define dma_tx_desc_3 dma_rx_desc_3
+
+struct pmac_rx_hdr { /*Egress PMAC header*/
+	/*byte 0 */
+	u8 ip_offset:7;
+	u8 ver_done:1;
+
+	/*byte 1 */
+	u8 tcp_type:3;
+	u8 tcp_h_offset:5;
+
+	/*byte 2 */
+	u8 class:4;
+	u8 src_dst_subif_id_14_12:3;
+	u8 res2:1;
+
+	/*byte 3 */
+	u8 pkt_type:2;
+	u8 ext:1;
+	u8 ins:1;
+	u8 res32:2;
+	u8 oam:1;
+	u8 pre_l2:1;
+
+	/*byte 4 */
+	u8 src_dst_subif_id_msb:5;
+	u8 ptp:1;
+	u8 one_step:1;
+	u8 fcs:1;
+
+	/*byte 5 */
+	u8 src_dst_subif_id_lsb:8;
+
+	/*byte 6 */
+	u8 record_id_msb:8;
+
+	/*byte 7 */
+	u8 igp_egp:4;
+	u8 record_id_lsb:4;
+
+	/* reserving 8 bytes as LGM is 16 byte PMAC header */
+	u8 res[8];
+} __packed;
+
+struct pmac_tx_hdr { /*Ingress PMAC header*/
+	/*byte 0 */
+	u8 ip_offset:7;
+	u8 tcp_chksum:1;
+
+	/*byte 1 */
+	u8 tcp_type:3;
+	u8 tcp_h_offset:5;
+
+	/*byte 2 */
+	u8 res2:4;
+	u8 src_dst_subif_id_14_12:3;
+	u8 res1:1;
+
+	/*byte 3 */
+	u8 pkt_type:2;
+	u8 ext:1;
+	u8 ins:1;
+	u8 class_en:1;/*TC Enable*/
+	u8 lrnmd:1;
+	u8 oam:1;
+	u8 res3:1;
+
+	/*byte 4 */
+	u8 src_dst_subif_id_msb:5;
+	u8 ptp:1;
+	u8 one_step:1;
+	u8 fcs_ins_dis:1;
+
+	/*byte 5 */
+	u8 src_dst_subif_id_lsb:8;
+
+	/*byte 6 */
+	u8 record_id_msb:8;
+
+	/*byte 7 */
+	u8 record_id_lsb:4;
+	u8 igp_egp:4;
+
+	/* reserving 8 bytes as LGM is 16 byte PMAC header */
+	u8 res[8];
+} __packed;
+
+#endif /*DATAPATH_API_LGM_H*/
diff --git a/include/net/datapath_api_ppv4.h b/include/net/datapath_api_ppv4.h
new file mode 100644
index 000000000000..929de511264a
--- /dev/null
+++ b/include/net/datapath_api_ppv4.h
@@ -0,0 +1,264 @@
+/*
+ * Copyright (C) Intel Corporation
+ * Author: Shao Guohua <guohua.shao@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+#ifndef DATAPATH_API_PPV4_H
+#define DATAPATH_API_PPV4_H
+
+#if IS_ENABLED(CONFIG_LITTLE_ENDIAN)
+struct ppv4_ud_0_dw_0 {
+	/* DWORD 0 */
+	union {
+		struct {
+			u32 ig_port:8;
+			u32 int_prot_info:4;
+			u32 ext_prot_info:4;
+			u32 ttl:1;
+			u32 opt:1;
+			u32 exdf:1;
+			u32 indf:1;
+			u32 exfragt:2;
+			u32 infragt:2;
+			u32 fin:1;
+			u32 syn:1;
+			u32 rst:1;
+			u32 ack:1;
+			u32 tcp_data_off:4;
+		} __packed field;
+		u32 all;
+	};
+} __packed;
+
+struct ppv4_ud_0_dw_1 {
+	/* DWORD 1 */
+	union {
+		struct {
+			u32 ext_l3_off:8;
+			u32 int_l3_off:8;
+			u32 ext_l4_off:8;
+			u32 int_l4_off:8;
+		} __packed field;
+		u32 all;
+	};
+} __packed;
+
+struct ppv4_ud_0_dw_2 {
+	/*DWORD 2 */
+	union {
+		struct {
+			u32 ext_frag_info_off:8;
+			u32 int_frag_info_off:8;
+			u32 turbo_dox_flow:10;
+			u32 res:2;
+			u32 lro:1;
+			u32 res1:1;
+			u32 l2_off:2;
+		} __packed field;
+		u32 all;
+	};
+
+} __packed;
+
+struct ppv4_ud_0_dw_3 {
+	/*DWORD 3 */
+	union {
+		struct {
+			u32 sess_idx:24;
+			u32 ud1_exist:1;
+			u32 res:3;
+			u32 err:1;
+			u32 drop_pkt:3;
+		} __packed field;
+		u32 all;
+	};
+} __packed;
+
+struct ppv4_ud_1_dw_0 {
+	/* DWORD 0 */
+	union {
+		struct {
+			u32 cls_hash;
+		} __packed field;
+		u32 all;
+	};
+} __packed;
+
+struct ppv4_ud_1_dw_1 {
+	/* DWORD 1 */
+	union {
+		struct {
+			u32 cls_hash;
+		} __packed field;
+		u32 all;
+	};
+} __packed;
+
+struct ppv4_ud_1_dw_2 {
+	/*DWORD 2 */
+	union {
+		struct {
+			u32 cls_hash:8;
+			u32 l3_hdr_off_5:8;
+			u32 l3_hdr_off_4:8;
+			u32 l3_hdr_off_3:8;
+		} __packed field;
+		u32 all;
+	};
+
+} __packed;
+
+struct ppv4_ud_1_dw_3 {
+	/*DWORD 3 */
+	union {
+		struct {
+			u32 l3_hdr_off_2:8;
+			u32 l3_hdr_off_1:8;
+			u32 l3_hdr_off_0:8;
+			u32 tun_in_off:3;
+			u32 payload_off:3;
+			u32 res:2;
+		} __packed field;
+		u32 all;
+	};
+} __packed;
+
+#else /* Big Endian */
+
+struct ppv4_ud_0_dw_0 {
+	/* DWORD 0 */
+	union {
+		struct {
+			u32 tcp_data_off:4;
+			u32 ack:1;
+			u32 rst:1;
+			u32 syn:1;
+			u32 fin:1;
+			u32 infragt:2;
+			u32 exfragt:2;
+			u32 indf:1;
+			u32 exdf:1;
+			u32 opt:1;
+			u32 ttl:1;
+			u32 ext_prot_info:4;
+			u32 int_prot_info:4;
+			u32 ig_port:8;
+		} __packed field;
+		u32 all;
+	};
+} __packed;
+
+struct ppv4_ud_0_dw_1 {
+	/* DWORD 1 */
+	union {
+		struct {
+			u32 int_l4_off:8;
+			u32 ext_l4_off:8;
+			u32 int_l3_off:8;
+			u32 ext_l3_off:8;
+		} __packed field;
+		u32 all;
+	};
+} __packed;
+
+struct ppv4_ud_0_dw_2 {
+	/*DWORD 2 */
+	union {
+		struct {
+			u32 l2_off:2;
+			u32 res1:1;
+			u32 lro:1;
+			u32 res:2;
+			u32 turbo_dox_flow:10;
+			u32 int_frag_info_off:8;
+			u32 ext_frag_info_off:8;
+		} __packed field;
+		u32 all;
+	};
+
+} __packed;
+
+struct ppv4_ud_0_dw_3 {
+	/*DWORD 3 */
+	union {
+		struct {
+			u32 drop_pkt:3;
+			u32 err:1;
+			u32 res:3;
+			u32 ud1_exist:1;
+			u32 sess_idx:24;
+		} __packed field;
+		u32 all;
+	};
+} __packed;
+
+struct ppv4_ud_1_dw_0 {
+	/* DWORD 0 */
+	union {
+		struct {
+			u32 cls_hash;
+		} __packed field;
+		u32 all;
+	};
+} __packed;
+
+struct ppv4_ud_1_dw_1 {
+	/* DWORD 1 */
+	union {
+		struct {
+			u32 cls_hash;
+		} __packed field;
+		u32 all;
+	};
+} __packed;
+
+struct ppv4_ud_1_dw_2 {
+	/*DWORD 2 */
+	union {
+		struct {
+			u32 l3_hdr_off_3:8;
+			u32 l3_hdr_off_4:8;
+			u32 l3_hdr_off_5:8;
+			u32 cls_hash:8;
+		} __packed field;
+		u32 all;
+	};
+
+} __packed;
+
+struct ppv4_ud_1_dw_3 {
+	/*DWORD 3 */
+	union {
+		struct {
+			u32 res:2;
+			u32 payload_off:3;
+			u32 tun_in_off:3;
+			u32 l3_hdr_off_0:8;
+			u32 l3_hdr_off_1:8;
+			u32 l3_hdr_off_2:8;
+		} __packed field;
+		u32 all;
+	};
+} __packed;
+
+#endif
+
+struct ppv4_ud_0 {
+	struct ppv4_ud_0_dw_0 dw0;
+	struct ppv4_ud_0_dw_1 dw1;
+	struct ppv4_ud_0_dw_2 dw2;
+	struct ppv4_ud_0_dw_3 dw3;
+};
+
+struct ppv4_ud_1 {
+	struct ppv4_ud_1_dw_0 dw0;
+	struct ppv4_ud_1_dw_1 dw1;
+	struct ppv4_ud_1_dw_2 dw2;
+	struct ppv4_ud_1_dw_3 dw3;
+};
+
+#endif /*DATAPATH_API_PPV4_H*/
+
diff --git a/include/net/lantiq_cbm_api.h b/include/net/lantiq_cbm_api.h
index 3f5aaa47e9ac..1a4f8174c794 100644
--- a/include/net/lantiq_cbm_api.h
+++ b/include/net/lantiq_cbm_api.h
@@ -545,7 +545,7 @@ struct cbm_dp_alloc_data {
 	u32 tx_ring_offset;  /*next tx_ring_addr = current tx_ring_addr + tx_ring_offset */
 	void *tx_ring_addr_txpush; /* port ring physical base address/TXIN address  
 				    *  to configured to QOS TX Push register.
-	                            *  In falcon_mx, it needs to left
+	                            *  In PRX300, it needs to left
 				    *  shift some bits.
 				    *  In LGM,  ???
 				    */
