From 6fd64f029f33fe644522fc49288ac818c623f53f Mon Sep 17 00:00:00 2001
From: Rekha Eswaran <rekha.eswaran@intel.com>
Date: Wed, 12 Jun 2019 17:31:01 +0800
Subject: [PATCH] DRVLIB_SW-2430 DP export API to configure green,yellow
 threshold

---
 drivers/net/datapath/dpm/datapath.h                |  1 +
 drivers/net/datapath/dpm/datapath_qos.c            | 11 +++-
 drivers/net/datapath/dpm/gswip31/datapath_misc.h   |  8 +--
 .../net/datapath/dpm/gswip31/datapath_ppv4_api.c   | 58 +++++++++++++++++++++-
 drivers/net/datapath/dpm/gswip32/datapath_misc.h   |  1 +
 .../net/datapath/dpm/gswip32/datapath_ppv4_api.c   | 58 +++++++++++++++++++++-
 include/net/datapath_api_qos.h                     | 24 +++++++++
 7 files changed, 153 insertions(+), 8 deletions(-)

diff --git a/drivers/net/datapath/dpm/datapath.h b/drivers/net/datapath/dpm/datapath.h
index 4317957d749b..0747a350b672 100644
--- a/drivers/net/datapath/dpm/datapath.h
+++ b/drivers/net/datapath/dpm/datapath.h
@@ -383,6 +383,7 @@ enum QOS_FLAG {
 	QOS_LEVEL_GET,     /* get Max Scheduler level for Node */
 	QOS_Q_LOGIC,       /* get logical queue ID based on physical queue ID */
 	QOS_GLOBAL_CFG_GET, /* get global qos config info */
+	QOS_PORT_CFG_SET, /* set qos port config info */
 };
 
 struct dev_mib {
diff --git a/drivers/net/datapath/dpm/datapath_qos.c b/drivers/net/datapath/dpm/datapath_qos.c
index 24ae57f46e5a..a4f8417d3a77 100644
--- a/drivers/net/datapath/dpm/datapath_qos.c
+++ b/drivers/net/datapath/dpm/datapath_qos.c
@@ -248,4 +248,13 @@ int dp_qos_global_info_get(struct dp_qos_cfg_info *info, int flag)
 	return dp_port_prop[info->inst].info.
 		dp_qos_platform_set(QOS_GLOBAL_CFG_GET, info, flag);
 }
-EXPORT_SYMBOL(dp_qos_global_info_get);
\ No newline at end of file
+EXPORT_SYMBOL(dp_qos_global_info_get);
+
+int dp_qos_port_conf_set(struct dp_port_cfg_info *info, int flag)
+{
+	if (!dp_port_prop[info->inst].info.dp_qos_platform_set)
+		return DP_FAILURE;
+	return dp_port_prop[info->inst].info.
+		dp_qos_platform_set(QOS_PORT_CFG_SET, info, flag);
+}
+EXPORT_SYMBOL(dp_qos_port_conf_set);
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_misc.h b/drivers/net/datapath/dpm/gswip31/datapath_misc.h
index f37edc8d7759..61a71379c556 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_misc.h
+++ b/drivers/net/datapath/dpm/gswip31/datapath_misc.h
@@ -172,12 +172,12 @@ int dp_meter_del_31(struct net_device *dev,
 		    struct dp_meter_cfg *meter,
 		    int flag, struct dp_meter_subif *mtr_subif);
 int dp_qos_global_info_get_31(struct dp_qos_cfg_info *info, int flag);
+int dp_qos_port_conf_set_31(struct dp_port_cfg_info *info, int flag);
 int32_t dp_rx_31(struct sk_buff *skb, u32 flags);
 int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
-		struct sk_buff *skb, int32_t len, uint32_t flags);
-void set_chksum(struct pmac_tx_hdr *pmac, u32 tcp_type,
-		       u32 ip_offset, int ip_off_hw_adjust,
-		       u32 tcp_h_offset);
+		   struct sk_buff *skb, int32_t len, uint32_t flags);
+void set_chksum(struct pmac_tx_hdr *pmac, u32 tcp_type, u32 ip_offset,
+		int ip_off_hw_adjust, u32 tcp_h_offset);
 
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_DDR_SIMULATE_GSWIP31)
 GSW_return_t gsw_core_api_ddr_simu31(dp_gsw_cb func, void *ops, void *param);
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c b/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
index ca802a0d538e..1d8586f87f8f 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
@@ -127,7 +127,12 @@ int qos_platform_set(int cmd_id, void *node, int flag)
 		res = dp_qos_level_get_31((struct dp_qos_level *)node, flag);
 		break;
 	case QOS_GLOBAL_CFG_GET:
-		res = dp_qos_global_info_get_31((struct dp_qos_cfg_info *)node, flag);
+		res = dp_qos_global_info_get_31((struct dp_qos_cfg_info *)node,
+						flag);
+		break;
+	case QOS_PORT_CFG_SET:
+		res = dp_qos_port_conf_set_31((struct dp_port_cfg_info *)node,
+					      flag);
 		break;
 	default:
 		PR_ERR("no support yet cmd_id %d\n", cmd_id);
@@ -262,6 +267,23 @@ static int get_cqm_deq_port_by_node(int inst, int node_id, int flag)
 	return DP_FAILURE;
 }
 
+/* get_node_by_cqm_deq_port API
+ * upon Success
+ *    return port node id
+ *    else return DP_FAILURE
+ */
+static int get_node_by_cqm_deq_port(int inst, int pid, int flag)
+{
+	int i;
+	struct hal_priv *priv = HAL(inst);
+
+	for (i = 0; i < MAX_CQM_DEQ; i++) {
+		if (pid == priv->deq_port_stat[i].deq_id)
+			return priv->deq_port_stat[i].node_id;
+	}
+	return DP_FAILURE;
+}
+
 #ifndef DP_FLUSH_VIA_AUTO
 static int cqm_queue_flush_31(int cqm_inst, int cqm_drop_port, int qid)
 {
@@ -4591,3 +4613,37 @@ int dp_qos_global_info_get_31(struct dp_qos_cfg_info *info, int flag)
 
 	return DP_SUCCESS;
 }
+
+/* dp_qos_port_conf_set_31 API
+ * Get global qos config information return DP_SUCCESS
+ * else return DP_FAILURE
+ */
+int dp_qos_port_conf_set_31(struct dp_port_cfg_info *info, int flag)
+{
+	struct hal_priv *priv;
+	struct pp_qos_port_conf port_cfg = {0};
+	int node_id;
+
+	if (!info) {
+		PR_ERR("info cannot be NULL\n");
+		return DP_FAILURE;
+	}
+	priv = HAL(info->inst);
+	if (!priv) {
+		PR_ERR("priv cannot be NULL\n");
+		return DP_FAILURE;
+	}
+	node_id = get_node_by_cqm_deq_port(info->inst, info->pid, flag);
+	if (qos_port_conf_get(priv->qdev, node_id, &port_cfg)) {
+		PR_ERR("failed qos_port_conf_get\n");
+		return DP_FAILURE;
+	}
+	port_cfg.green_threshold = info->green_threshold;
+	port_cfg.yellow_threshold = info->yellow_threshold;
+	if (qos_port_set(priv->qdev, node_id, &port_cfg)) {
+		PR_ERR("fail to set yellow:%d green:%d for node:%d\n",
+		       info->yellow_threshold, info->green_threshold, node_id);
+		return DP_FAILURE;
+	}
+	return DP_SUCCESS;
+}
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_misc.h b/drivers/net/datapath/dpm/gswip32/datapath_misc.h
index 75840485b276..1d38fc1efcaf 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_misc.h
+++ b/drivers/net/datapath/dpm/gswip32/datapath_misc.h
@@ -200,6 +200,7 @@ int dp_meter_del_32(struct net_device *dev,
 		    struct dp_meter_cfg *meter,
 		    int flag, struct dp_meter_subif *mtr_subif);
 int dp_qos_global_info_get_32(struct dp_qos_cfg_info *info, int flag);
+int dp_qos_port_conf_set_32(struct dp_port_cfg_info *info, int flag);
 int32_t dp_rx_32(struct sk_buff *skb, u32 flags);
 int32_t dp_xmit_32(struct net_device *rx_if, dp_subif_t *rx_subif,
 		struct sk_buff *skb, int32_t len, uint32_t flags);
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c b/drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c
index c7212963ce48..da5dc00a343f 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c
@@ -158,11 +158,14 @@ int qos_platform_set_32(int cmd_id, void *node, int flag)
 		res = dp_qos_level_get_32((struct dp_qos_level *)node, flag);
 		break;
 	case QOS_GLOBAL_CFG_GET:
-		res = dp_qos_global_info_get_32((struct dp_qos_cfg_info *)node, flag);
+		res = dp_qos_global_info_get_32((struct dp_qos_cfg_info *)node,
+						flag);
 	case QOS_Q_LOGIC:
 		res = dp_get_queue_logic_32((struct dp_qos_q_logic*)node, flag);
 		break;
-		
+	case QOS_PORT_CFG_SET:
+		res = dp_qos_port_conf_set_32((struct dp_port_cfg_info *)node, flag);
+		break;
 	default:
 		PR_ERR("no support yet cmd_id %d\n", cmd_id);
 		break;
@@ -296,6 +299,23 @@ static int get_cqm_deq_port_by_node(int inst, int node_id, int flag)
 	return DP_FAILURE;
 }
 
+/* get_node_by_cqm_deq_port API
+ * upon Success
+ *    return port node id
+ *    else return DP_FAILURE
+ */
+static int get_node_by_cqm_deq_port(int inst, int pid, int flag)
+{
+	int i;
+	struct hal_priv *priv = HAL(inst);
+
+	for (i = 0; i < MAX_CQM_DEQ; i++) {
+		if (pid == priv->deq_port_stat[i].deq_id)
+			return priv->deq_port_stat[i].node_id;
+	}
+	return DP_FAILURE;
+}
+
 #ifndef DP_FLUSH_VIA_AUTO
 static int cqm_queue_flush_32(int cqm_inst, int cqm_drop_port, int qid)
 {
@@ -4596,3 +4616,37 @@ int dp_qos_global_info_get_32(struct dp_qos_cfg_info *info, int flag)
 
 	return DP_SUCCESS;
 }
+
+/* dp_qos_port_conf_set_32 API
+ * Get global qos config information return DP_SUCCESS
+ * else return DP_FAILURE
+ */
+int dp_qos_port_conf_set_32(struct dp_port_cfg_info *info, int flag)
+{
+	struct hal_priv *priv;
+	struct pp_qos_port_conf port_cfg = {0};
+	int node_id;
+
+	if (!info) {
+		PR_ERR("info cannot be NULL\n");
+		return DP_FAILURE;
+	}
+	priv = HAL(info->inst);
+	if (!priv) {
+		PR_ERR("priv cannot be NULL\n");
+		return DP_FAILURE;
+	}
+	node_id = get_node_by_cqm_deq_port(info->inst, info->pid, flag);
+	if (qos_port_conf_get(priv->qdev, node_id, &port_cfg)) {
+		PR_ERR("failed qos_port_conf_get\n");
+		return DP_FAILURE;
+	}
+	port_cfg.green_threshold = info->green_threshold;
+	port_cfg.yellow_threshold = info->yellow_threshold;
+	if (qos_port_set(priv->qdev, node_id, &port_cfg)) {
+		PR_ERR("fail to set yellow:%d green:%d for node:%d\n",
+		       info->yellow_threshold, info->green_threshold, node_id);
+		return DP_FAILURE;
+	}
+	return DP_SUCCESS;
+}
diff --git a/include/net/datapath_api_qos.h b/include/net/datapath_api_qos.h
index fa41c68dd20c..96592343a139 100644
--- a/include/net/datapath_api_qos.h
+++ b/include/net/datapath_api_qos.h
@@ -1267,6 +1267,30 @@ struct dp_qos_cfg_info {
 int dp_qos_global_info_get(struct dp_qos_cfg_info *info, int flag);
 
 /*!
+ * @struct dp_port_cfg_info
+ *
+ * Structure defining the QoS port config info
+ *
+ */
+struct dp_port_cfg_info {
+	int inst; /*!< [in] dp instance. For SOC side, it is always zero */
+	int pid; /*!< [in] physical qos port id */
+	u32 green_threshold; /*!< [in] QoS port Egress green bytes threshold*/
+	u32 yellow_threshold; /*!< [in] QoS port Egress yellow bytes threshold*/
+};
+
+/*!< API dp_qos_port_conf_set: Helps to retrieve global QoS
+ *  Config information.
+ *
+ * @param [in] port info struct dp_port_cfg_info *info
+ * @param [in] flag: reserved
+ * @return [out] integer value: return DP_SUCCESS if succeed,
+ *                              otherwise, return DP_FAILURE
+ *
+ */
+int dp_qos_port_conf_set(struct dp_port_cfg_info *info, int flag);
+
+/*!
  * @struct dp_qos_q_logic
  *
  * Structure defining the conversion from physical to logical queue ID
