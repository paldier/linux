From d6833a1a95687d67b4bb109ebe0ff053004808d8 Mon Sep 17 00:00:00 2001
From: "Vishnu Swaroop Kumar Sarma, Duddu" <duddu.swaroop@intel.com>
Date: Wed, 31 Jul 2019 14:46:51 +0530
Subject: [PATCH] UGW_SW-39419 GSWIP jumbo config based on MTU

Enable the switch jumbo support based on MTU without which the configs in PMAC and MAC layer are mismatched.
This results in the jumbo packet received by system to pass through mac layer but gets stuck at pmac layer.
Also configure MAC_FLEN based on MTU
---
 drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c | 43 ++++++++++++++++++++----
 1 file changed, 37 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
index 7353fe6dc844..c41f4bef522d 100644
--- a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
+++ b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
@@ -35,8 +35,10 @@
 #include "xrx500_phy_fw.h"
 #include "ltq_eth_drv_xrx500.h"
 #include "xpcs/xpcs.h"
-
-#define LTQ_ETH_MAX_DATA_LEN 9000
+/* 9600 - ethernet overhead of 18 bytes */
+#define LTQ_ETH_MAX_DATA_LEN 9582
+/* Min IPv4 MTU per RFC791 */
+#define LTQ_ETH_MIN_MTU 68
 
 #define DRV_MODULE_NAME		"lantiq_eth_drv_xrx500"
 #define DRV_MODULE_VERSION	 "1.1"
@@ -405,8 +407,6 @@ static int ltq_eth_open(struct net_device *dev)
 		return -1;
 	}
 
-	if (g_soc_data.mtu_limit)
-		ltq_change_mtu(dev, g_soc_data.mtu_limit);
 	return 0;
 }
 
@@ -736,13 +736,30 @@ static int ltq_disable_gsw_r_jumbo(struct net_device *dev)
 	return 0;
 }
 
+static void ltq_set_max_pkt_len (struct ltq_eth_priv *priv, u16 pkt_len)
+{
+	struct core_ops *ops = NULL;
+	pkt_len += ETH_HLEN + ETH_FCS_LEN;
+	if(priv != NULL) {
+		if(priv->wan)
+			ops = gsw_get_swcore_ops(1);
+		else
+			ops = gsw_get_swcore_ops(0);
+		if(ops == NULL)
+			return;
+
+		/* Set the MAC_FLEN register for max packet length */
+		pr_info("doing the GSW MAC_FLEN configuration\n");
+		gsw_reg_set_val(ops, 0x8C5, pkt_len);
+	}
+}
+
 /* Change the MTU value of the netwrok device interfaces */
 static int ltq_change_mtu(struct net_device *dev, int new_mtu)
 {
 	struct ltq_eth_priv *priv = netdev_priv(dev);
 
-	if ((new_mtu < ETH_ZLEN || new_mtu > LTQ_ETH_MAX_DATA_LEN) ||
-	    ((g_soc_data.mtu_limit) && (new_mtu > g_soc_data.mtu_limit))) {
+	if (new_mtu < LTQ_ETH_MIN_MTU || new_mtu > g_soc_data.mtu_limit) {
 		pr_err("%s: Invalid MTU size %u\n", __func__, new_mtu);
 		return -EINVAL;
 	}
@@ -756,6 +773,10 @@ static int ltq_change_mtu(struct net_device *dev, int new_mtu)
 				ops->set_mtu(ops, new_mtu);
 		}
 	} else {
+
+		/* set the max pkt length on the switch */
+		ltq_set_max_pkt_len(priv,(u16)new_mtu);
+
 		/* if the MTU > 1500, do the jumbo config in switch */
 		if (new_mtu > ETH_DATA_LEN && !(priv->jumbo_enabled)) {
 			if (priv->wan) {
@@ -864,6 +885,13 @@ static int ltq_eth_init(struct net_device *dev)
 	pr_debug("\n subif reg for owner = %s portid = %d subifid = %d dev= %s\n",
 		 priv->owner->name, priv->dp_port_id,
 		 priv->dp_subif.subif, dev->name);
+
+	/* get the minimum MTU and call the change mtu */
+	if( !(dev->mtu > LTQ_ETH_MIN_MTU && dev->mtu < g_soc_data.mtu_limit))
+		dev->mtu = g_soc_data.mtu_limit;
+
+	ltq_change_mtu(dev, dev->mtu);
+
 	return 0;
 }
 
@@ -2217,6 +2245,9 @@ static int ltq_eth_drv_init(struct platform_device *pdev)
 			     &mtu_limit);
 	if (!ltq_get_soc_rev() && mtu_limit)
 		g_soc_data.mtu_limit = mtu_limit;
+	else
+		g_soc_data.mtu_limit = LTQ_ETH_MAX_DATA_LEN;
+
 	/* bring up the mdio bus */
 	mdio_np = of_find_compatible_node(node, NULL,
 					  "lantiq,xrx500-mdio");
