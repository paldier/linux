From 22110eb15386347034059557c5e3717f93007b48 Mon Sep 17 00:00:00 2001
From: yixin zhu <yixin.zhu@intel.com>
Date: Thu, 25 Jul 2019 13:21:37 +0800
Subject: [PATCH] DRVLIB_SW-2648: UMT, Dp Lib, CQM changes after integration
 with WiFi

- update ignore setting
- Port UMT driver from LGM to PRX300
- UGW_SW-41632: add support for PRX300
- DRVLIB_SW-2631: CQM port alloc complete returns an error
  As per new design, removed unwanted codition checks
- VAP fix in DPM
- Compilation fix for GRX500
- fix CQM dealloc issue
---
 .gitignore                                       |   3 +
 drivers/net/datapath/Kconfig                     |  14 +
 drivers/net/datapath/Makefile                    |   6 +
 drivers/net/datapath/dpm/datapath.h              |   4 +-
 drivers/net/datapath/dpm/datapath_api.c          |  74 +-
 drivers/net/datapath/dpm/datapath_proc.c         |  10 +-
 drivers/net/datapath/dpm/gswip31/datapath_misc.c |  12 +-
 drivers/net/datapath/umt/Kconfig                 |  10 +
 drivers/net/datapath/umt/Makefile                |   7 +
 drivers/net/datapath/umt/umt.c                   | 961 +++++++++++++++++++++++
 drivers/net/ethernet/lantiq/Kconfig              |   2 +-
 drivers/net/ethernet/lantiq/Makefile             |   6 +-
 drivers/net/ethernet/lantiq/cqm/prx300/cqm.c     |  42 +-
 include/net/datapath_api.h                       |  97 +--
 include/net/datapath_api_umt.h                   | 155 ++--
 include/net/dc_ep.h                              |   0
 include/net/lantiq_cbm_api.h                     |   5 +-
 17 files changed, 1156 insertions(+), 252 deletions(-)

diff --git a/.gitignore b/.gitignore
index 0c39aa20b6ba..7117f63689b6 100644
--- a/.gitignore
+++ b/.gitignore
@@ -76,6 +76,9 @@ Module.symvers
 include/config
 include/generated
 arch/*/include/generated
+arch/mips/boot/compressed/ashldi3.c
+arch/mips/boot/compressed/bswapsi.c
+user_headers/
 
 # stgit generated dirs
 patches-*
diff --git a/drivers/net/datapath/Kconfig b/drivers/net/datapath/Kconfig
new file mode 100644
index 000000000000..bcca1406530b
--- /dev/null
+++ b/drivers/net/datapath/Kconfig
@@ -0,0 +1,14 @@
+# SPDX-License-Identifier: GPL-2.0
+
+menuconfig INTEL_NP_NET_CORE
+	depends on NETDEVICES
+	bool "Intel NP Network device support"
+	---help---
+	  It contains basic network driver sets
+	  required to drive INTEL NP(LGM/PRX300)
+	  to support basic network packet handling.
+
+if INTEL_NP_NET_CORE
+source "drivers/net/datapath/dpm/Kconfig"
+source "drivers/net/datapath/umt/Kconfig"
+endif # INTEL_NP_NET_CORE
diff --git a/drivers/net/datapath/Makefile b/drivers/net/datapath/Makefile
new file mode 100644
index 000000000000..78eb54e04a96
--- /dev/null
+++ b/drivers/net/datapath/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright (C) 2019 Intel Corporation.
+
+obj-$(CONFIG_INTEL_NP_NET_CORE) += dpm/
+obj-$(CONFIG_INTEL_NP_NET_CORE) += umt/
diff --git a/drivers/net/datapath/dpm/datapath.h b/drivers/net/datapath/dpm/datapath.h
index b742a5ee64fb..b8fa9c2e1bcd 100644
--- a/drivers/net/datapath/dpm/datapath.h
+++ b/drivers/net/datapath/dpm/datapath.h
@@ -49,7 +49,7 @@
 #include "datapath_swdev.h"
 #endif
 #include <net/datapath_inst.h>
-#include <net/intel_datapath_umt.h>
+#include <net/datapath_api_umt.h>
 
 #define MAX_SUBIFS 256  /* Max subif per DPID */
 #define MAX_DP_PORTS  16
@@ -560,7 +560,7 @@ struct pmac_port_info {
 	struct dp_rx_ring rx_ring[DP_RX_RING_NUM]; /*!< DC rx ring info	*/
 	struct dp_tx_ring tx_ring[DP_TX_RING_NUM]; /*!< DC tx ring info	*/
 #if !IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP30)
-	struct dp_umt_param umt_param; /*!< UMT Param */
+	struct dp_umt_port umt; /*!< UMT Param */
 #endif
 	/* These members must be end. */
 	u32 tail;
diff --git a/drivers/net/datapath/dpm/datapath_api.c b/drivers/net/datapath/dpm/datapath_api.c
index 43cf9edc2126..1e458638f42e 100644
--- a/drivers/net/datapath/dpm/datapath_api.c
+++ b/drivers/net/datapath/dpm/datapath_api.c
@@ -119,13 +119,15 @@ int aca_portid = -1;
 
 static void *dp_ops[DP_MAX_INST][DP_OPS_CNT];
 
-void dp_register_ops(int inst, enum DP_OPS_TYPE type, void *ops)
+int dp_register_ops(int inst, enum DP_OPS_TYPE type, void *ops)
 {
 	if (inst < 0 || inst >= DP_MAX_INST || type >= DP_OPS_CNT) {
 		DP_DEBUG(DP_DBG_FLAG_REG, "wrong index\n");
-		return;
+		return DP_FAILURE;
 	}
 	dp_ops[inst][type] = ops;
+
+	return DP_SUCCESS;
 }
 EXPORT_SYMBOL(dp_register_ops);
 
@@ -395,7 +397,7 @@ static int32_t dp_alloc_port_private(int inst,
 		}
 		cbm_data.deq_port = port->deq_port_base;
 		cbm_data.dma_chan = port->dma_chan;
-		cbm_dp_port_dealloc(owner, dev_port, port_id, &cbm_data, flags);
+		cbm_dp_port_dealloc(owner, dev_port, port_id, &cbm_data, port->alloc_flags | flags);
 		dp_inst_insert_mod(owner, port_id, inst, 0);
 		DP_DEBUG(DP_DBG_FLAG_REG, "de-alloc port %d\n", port_id);
 		DP_CB(inst, port_platform_set)(inst, port_id, data, flags);
@@ -950,6 +952,16 @@ int32_t dp_register_dev(struct module *owner, uint32_t port_id,
 }
 EXPORT_SYMBOL(dp_register_dev);
 
+static int remove_umt(int inst, const struct dp_umt_port *umt)
+{
+	struct umt_ops *ops = dp_get_umt_ops(inst);
+
+	if (!ops)
+		return -ENODEV;
+
+	return ops->umt_release(ops->umt_dev, umt->ctl.id);
+}
+
 int32_t dp_register_dev_ext(int inst, struct module *owner, uint32_t port_id,
 			    dp_cb_t *dp_cb, struct dp_dev_data *data,
 			    uint32_t flags)
@@ -991,8 +1003,7 @@ int32_t dp_register_dev_ext(int inst, struct module *owner, uint32_t port_id,
 			DP_CB(inst, dev_platform_set)(inst, port_id, data,
 						      flags);
 #if !IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP30)
-			if (port_info->umt_param.id)
-				dp_umt_release(&port_info->umt_param, flags);
+			remove_umt(inst, &port_info->umt);
 #endif
 			res = DP_SUCCESS;
 		} else {
@@ -1488,9 +1499,10 @@ static int dp_register_dc(int inst, uint32_t port_id,
 			  struct cbm_dp_alloc_complete_data *cbm_data,
 			  struct dp_dev_data *data, uint32_t flags)
 {
-	struct dp_umt_param umt_param = {0};
-	int i = 0;
 	struct pmac_port_info *port = get_dp_port_info(inst, port_id);
+	struct umt_port_res *res;
+	struct umt_ops *ops = dp_get_umt_ops(inst);
+	int i, ret;
 
 	/* Fill in the output data to the the DCDP driver for the RX rings
 	 * and Save Info for debugging
@@ -1515,49 +1527,23 @@ static int dp_register_dc(int inst, uint32_t port_id,
 
 	/* UMT Interface is not supported for old products */
 #if !IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP30)
-	umt_param.id = 0xFF;
-
+        res = &data->umt->res;
 	/* For PRX300, RXOUT is to DMA Channel,
 	 * For LGM, RXOUT is to CQEM Deq port
 	 */
-	umt_param.rx_src = DP_UMT_RX_FROM_DMA;
-	umt_param.dma_id = data->rx_ring[0].out_dma_ch_to_gswip;
-	umt_param.dma_ch_num = data->rx_ring[0].num_out_tx_dma_ch;
+	res->rx_src     = UMT_RX_SRC_DMA;
+	res->dma_id     = data->rx_ring[0].out_dma_ch_to_gswip;
+	res->dma_ch_num = data->rx_ring[0].num_out_tx_dma_ch;
+	res->cqm_dq_pid = port->deq_port_base;
 
-	/* For PRX300/LGM, TXIN counter is from CQM Deq port,
-	 * Message Mode is SelfCounting
-	 */
-	umt_param.cqm_dq_pid = port->deq_port_base;
-	umt_param.msg_mode = data->umt->umt_mode;
-	umt_param.period =  data->umt->umt_msg_timer;
-	umt_param.sw_msg = DP_UMT_MSG0_MSG1;
-	umt_param.daddr = (u32)data->umt->umt_msg_paddr;
-
-	if (dp_umt_request(&umt_param, 0)) {
-		PR_ERR("%s %s %x %s %d %s %d %s %d %s %d %s 0x%08x\n",
-		       "UMT request Fail!!",
-		       "DMA_ID", umt_param.dma_id,
-		       "CQM_PID", umt_param.cqm_dq_pid,
-		       "MSG_MODE", umt_param.msg_mode,
-		       "PERIOD", umt_param.period,
-		       "SW_MSG", umt_param.sw_msg,
-		       "DADDR", umt_param.daddr);
-		return DP_FAILURE;
-	}
-	if (dp_umt_set(&umt_param, 0)) {
-		PR_ERR("%s %s %x %s %d %s %d %s %d %s %d %s 0x%08x\n",
-		       "UMT port set fail!!",
-		       "DMA_ID", umt_param.dma_id,
-		       "CQM_PID", umt_param.cqm_dq_pid,
-		       "MSG_MODE", umt_param.msg_mode,
-		       "PERIOD", umt_param.period,
-		       "SW_MSG", umt_param.sw_msg,
-		       "DADDR", umt_param.daddr);
-		return DP_FAILURE;
+	if (!ops) {
+		DP_ERR("No UMT driver registered\n");
+		return -ENODEV;
 	}
 
-	/* Save umt params */
-	memcpy(&port->umt_param, &umt_param, sizeof(struct dp_umt_param));
+	ret = ops->umt_request(ops->umt_dev, data->umt);
+	memcpy(&port->umt, data->umt, sizeof(struct dp_umt_port));
+	return ret;
 #endif
 	return DP_SUCCESS;
 }
diff --git a/drivers/net/datapath/dpm/datapath_proc.c b/drivers/net/datapath/dpm/datapath_proc.c
index 9fc05c1177b5..77091626d670 100644
--- a/drivers/net/datapath/dpm/datapath_proc.c
+++ b/drivers/net/datapath/dpm/datapath_proc.c
@@ -105,12 +105,12 @@ int dump_dc_info(struct seq_file *s, struct pmac_port_info *port)
 	}
 #if !IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP30)
 	seq_printf(s, "    UMT id/CqmDeqPid/msg_mode:      %d/%d/%d\n",
-		   port->umt_param.id,
-		   port->umt_param.cqm_dq_pid,
-		   port->umt_param.msg_mode);
+		   port->umt.ctl.id,
+		   port->umt.res.cqm_dq_pid,
+		   port->umt.ctl.msg_mode);
 	seq_printf(s, "    UMT period/daddr:               %d/0x%08x\n",
-		   port->umt_param.period,
-		   port->umt_param.daddr);
+		   port->umt.ctl.msg_interval,
+		   port->umt.ctl.daddr);
 #endif
 
 	return 0;
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_misc.c b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
index a304b5650224..d686a3a2dbc5 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
@@ -2050,8 +2050,8 @@ static void update_port_vap(int inst, u32 *ep, int *vap,
 		/*get the real source port from VAP for ipsec */
 		/* related tunnel decap case */
 		*ep = GET_VAP((u32)pmac->src_dst_subif_id_lsb +
-			(u32)(pmac->src_dst_subif_id_msb << 8),
-			pi->vap_offset, pi->vap_mask);
+			      (u32)(pmac->src_dst_subif_id_msb << 8),
+			      pi->vap_offset, pi->vap_mask);
 		*vap = 0;
 		*decryp = 1;
 	} else {
@@ -2059,10 +2059,12 @@ static void update_port_vap(int inst, u32 *ep, int *vap,
 #if defined(DP_SKB_HACK)
 		desc_1 = (struct dma_rx_desc_1 *)&skb->DW1;
 #else
-	//error "Please add proper logic here"
-	return;
+		//error "Please add proper logic here"
+		return;
 #endif
-		*vap = desc_1->field.session_id;
+		*vap = GET_VAP(desc_1->field.session_id,
+			       pi->vap_offset,
+			       pi->vap_mask);
 	}
 }
 
diff --git a/drivers/net/datapath/umt/Kconfig b/drivers/net/datapath/umt/Kconfig
new file mode 100644
index 000000000000..ad563dbf14a2
--- /dev/null
+++ b/drivers/net/datapath/umt/Kconfig
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+
+config INTEL_UMT
+	bool "User message transfer driver"
+	depends on INTEL_DATAPATH
+
+	help
+	  This driver supports Intel UMT Hardware.
+	  UMT HW is designed to work with CQM HW to
+	  send the RX/TX counter to PCIe Endpoint.
diff --git a/drivers/net/datapath/umt/Makefile b/drivers/net/datapath/umt/Makefile
new file mode 100644
index 000000000000..0434892de313
--- /dev/null
+++ b/drivers/net/datapath/umt/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the Intel(R) UMT driver
+#
+# Copyright (C) 2018 Intel Corporation.
+
+obj-$(CONFIG_INTEL_UMT) += umt.o
diff --git a/drivers/net/datapath/umt/umt.c b/drivers/net/datapath/umt/umt.c
new file mode 100644
index 000000000000..4ef5589919d8
--- /dev/null
+++ b/drivers/net/datapath/umt/umt.c
@@ -0,0 +1,961 @@
+// SPDX-License-Identifier: GPL-2.0
+/*  Copyright (C) 2018 Intel Corporation.
+ *  Wu ZhiXian <zhixian.wu@intel.com>
+ *  Zhu Yixin <yixin.zhu@intel.com>
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/debugfs.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <net/datapath_api.h>
+
+/* reg definition */
+#define UMT_MODE		0x100
+#define P0_CNT_MODE_OFF		3
+#define UMT_CNT_CTRL		0xE4
+#define UMT_TRG_MUX(x)		((x) < 4 ? 0xE0 : 0xF0)
+#define UMT_RX_MUX_OFF(x)	((x) < 4 ? (x) * 4 : ((x) - 4) << 2)
+#define UMT_TX_MUX_OFF(x)	(UMT_RX_MUX_OFF(x) + 16)
+#define UMT_RX0_MUX		0xF4
+#define UMT_MUX_WIDTH		4
+#define UMT_GCTRL		0x200
+#define RST_OFF			4
+#define PORT_EN_OFF		8
+#define BYTE_SWAP_OFF		28
+#define DW_SWAP_OFF		29
+#define to_mask(x)		(BIT(x) - 1)
+#define SND_DIS_OFF(x)		((x) < 4 ? (x) : (x) + 16)
+#define CLR_CNT_OFF(x)		((x) < 4 ? (x) + 4 : (x) + 20)
+#define NOT_SND_ZERO_OFF(x)	((x) < 4 ? (x) + 8 : (x) + 24)
+#define RX_SND_DIS_OFF(x)	((x) < 4 ? (x) + 12 : (x) + 28)
+
+enum dma_cid {
+	DMA0TX,
+	DMA1TX,
+	DMA2TX,
+	DMA_CTRL_MAX
+};
+
+enum soc_ver {
+	PRX300_SOC,
+	LGM_SOC
+};
+
+struct umt_soc_data {
+	u8            umt_port_num;
+	enum soc_ver  ver;
+	unsigned long rx_src_cap;
+	unsigned long feature_cap;
+	unsigned int  enq_base;
+	unsigned int  dq_base;
+};
+
+struct umt_port {
+	struct dp_umt_port cfg;
+	int                id;
+	bool               allocated;
+	u8                 dma_cid;
+	u16                dma_chid;
+	unsigned long      rx_src_cap;
+	unsigned int       dma_chn_cap;
+	unsigned long      feature_cap;
+};
+
+/**
+ * struct umt_priv
+ * dev: platform device.
+ * membase: UMT register base address.
+ * umt_num: number of UMT entries.
+ * dw_swap: Control OCP SWAPPER WORD for UMT.
+ * byte_swap: Control OCP SWAPPER byte for UMT.
+ * umts: umt entry list.
+ * umt_lock: protect the umt global resource.
+ * clk: clock source.
+ * debugfs: debugfs proc.
+ */
+struct umt_priv {
+	struct device             *dev;
+	void __iomem              *membase;
+	u8                        umt_port_num;
+	bool                      dw_swap;
+	bool                      byte_swap;
+	struct umt_port           *ports;
+	struct clk                *clk;
+	struct dentry             *debugfs;
+	struct umt_ops            ops;
+	const struct umt_soc_data *soc;
+	spinlock_t                lock; /* lock protection */
+};
+
+#define DEFINE_SHOW_ATTRIBUTE(__name)					\
+	static int __name ## _open(struct inode *inode, struct file *file) \
+{									\
+	return single_open(file, __name ## _show, inode->i_private);	\
+}									\
+									\
+static const struct file_operations __name ## _fops = {			\
+	.owner		= THIS_MODULE,					\
+	.open		= __name ## _open,				\
+	.read		= seq_read,					\
+	.llseek		= seq_lseek,					\
+	.release	= single_release,				\
+}
+
+static const char * const umt_mode_str[] = {"Self Counting mode", "User mode"};
+static const char * const umt_sw_mode_str[] = {
+	"No MSG", "MSG0 Only", "MSG1 only", "MSG0 and MSG1"};
+
+/* Address calculate for different SoC */
+static bool is_prx300_soc(struct umt_priv *priv)
+{
+	return (priv->soc->ver == PRX300_SOC);
+}
+
+static unsigned int reg_addr_sw_mode(struct umt_priv *priv, unsigned int pid)
+{
+	if (is_prx300_soc(priv))
+		return !pid ? 0x218 : 0x334 + pid * 0x100;
+
+	return !pid ? 0x114 : 0x2b0 + pid * 0x100;
+}
+
+static unsigned int reg_addr_period(struct umt_priv *priv, unsigned int pid)
+{
+	if (is_prx300_soc(priv))
+		return !pid ? 0xdc : 0x320 + pid * 0x100;
+
+	return !pid ? 0xdc : 0x2a0 + pid * 0x100;
+}
+
+static unsigned int reg_addr_dst(struct umt_priv *priv, unsigned int pid)
+{
+	if (is_prx300_soc(priv))
+		return !pid ? 0x230 : 0x330 + pid * 0x100;
+
+	return !pid ? 0x280 : 0x280 + pid * 0x100;
+}
+
+static unsigned int reg_addr_mode(struct umt_priv *priv)
+{
+	return is_prx300_soc(priv) ? UMT_GCTRL : UMT_MODE;
+}
+
+static unsigned int reg_mode_off(struct umt_priv *priv, unsigned int pid)
+{
+	if (is_prx300_soc(priv))
+		return !pid ? 1 : 16 + (pid - 1) * 3;
+
+	return (pid << 2) + 1;
+}
+
+static unsigned int reg_en_off(struct umt_priv *priv, unsigned int pid)
+{
+	if (is_prx300_soc(priv))
+		return !pid ? 2 : 17 + (pid - 1) * 3;
+
+	return pid << 2;
+}
+
+static u32 umt_reg_read(struct umt_priv *priv, unsigned int reg)
+{
+	return readl(priv->membase + reg);
+}
+
+static void
+umt_reg_write(struct umt_priv *priv, unsigned int reg, unsigned int val)
+{
+	writel(val, priv->membase + reg);
+}
+
+static void
+umt_reg_update_bit(struct umt_priv *priv, unsigned int reg,
+		   unsigned int off, unsigned int val)
+{
+	u32 reg_val;
+
+	val = !!val;
+	reg_val = umt_reg_read(priv, reg) & ~BIT(off);
+	reg_val |= val << off;
+	umt_reg_write(priv, reg, reg_val);
+}
+
+static void
+umt_reg_write_mask(struct umt_priv *priv, unsigned int reg,
+		   unsigned int mask, unsigned int off, unsigned int val)
+{
+	u32 reg_val;
+
+	reg_val = umt_reg_read(priv, reg) & ~(mask << off);
+	reg_val |= (val & mask) << off;
+	umt_reg_write(priv, reg, reg_val);
+}
+
+/* input in term of microseconds */
+static u32 umt_us_to_cnt(struct umt_priv *priv, unsigned int usec)
+{
+	unsigned long clk;
+	u64 period;
+
+	clk = clk_get_rate(priv->clk);
+
+	period = (u64)usec * clk;
+	do_div(period, 100000);
+	if (period > 0xFFFFFFFFULL) {
+		dev_info(priv->dev, "UMT period exceeds max value! set to 0xFFFFFFFF.\n");
+		return 0xFFFFFFFF;
+	}
+
+	return (u32)period;
+}
+
+/* DP_UMT_RX_FROM_CQEM:
+ * UMT_TRG_MUX_0/UMT_TRG_MUX_1:
+ * UMT RX Counter:
+ * CQM enqueue port from 16--->UMT trigger value from 0
+ * UMT TX Counter:
+ * CQM DQ PORT 19----> UMT 0
+ *
+ * DP_UMT_RX_FROM_DMA:
+ * UMT PORT 0 (DOCSIS mode, set at UMT_MODE_REG UMT_CNT_MOD):
+ * UMT_RX0_MUX:
+ * DMATX0 CH0-7 ---> UMT 8-0xf
+ * UMT_TRG_MUX_0/UMT_TRG_MUX_1:
+ * UMT Rx Counter (DMA only to RX Counter):
+ * DMATX2 CH2-5 ---> UMT 0-3
+ * DMATX1 CH2-5 ---> UMT 4-7
+ */
+static void umt_hw_init(struct umt_priv *priv)
+{
+	/* UMT reset */
+	umt_reg_update_bit(priv, UMT_GCTRL, RST_OFF, 1);
+	usleep_range(10, 50);
+	umt_reg_update_bit(priv, UMT_GCTRL, RST_OFF, 0);
+
+	/* Enable UMT PORT */
+	umt_reg_write_mask(priv, UMT_GCTRL, BIT(priv->umt_port_num) - 1,
+			   PORT_EN_OFF, BIT(priv->umt_port_num) - 1);
+
+	umt_reg_update_bit(priv, UMT_GCTRL, BYTE_SWAP_OFF, priv->byte_swap);
+	umt_reg_update_bit(priv, UMT_GCTRL, DW_SWAP_OFF, priv->dw_swap);
+}
+
+static int umt_dma_check(struct umt_priv *priv, u32 dma_id)
+{
+	u8 cid;
+	u16 chid;
+
+	dp_dma_parse_id(dma_id, &cid, NULL, &chid);
+
+	if (priv->soc->ver == LGM_SOC) {
+		if (cid == DMA0TX && chid <= 7)
+			return 0;
+		if (cid == DMA1TX && chid >= 2 && chid <= 5)
+			return 0;
+		if (cid == DMA2TX && chid >= 2 && chid <= 5)
+			return 0;
+	} else if (cid == DMA1TX && chid < 16) {
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int
+umt_check_cfg(struct umt_priv *priv, struct umt_port *umt_p,
+	      struct dp_umt_port *port)
+{
+	struct device *dev = priv->dev;
+	struct umt_port_ctl *ctl = &port->ctl;
+	struct umt_port_res *res = &port->res;
+
+	/* check UMT RX CAP */
+	if (!(BIT(res->rx_src) & umt_p->rx_src_cap)) {
+		dev_dbg(dev, "UMT RX src: %u not supported!\n", res->rx_src);
+		return -EINVAL;
+	}
+
+	/* check UMT DMA CAP */
+	if (res->rx_src == UMT_RX_SRC_DMA) {
+		if (res->dma_ch_num > umt_p->dma_chn_cap) {
+			dev_dbg(dev, "UMT RX DMA CHNUM: %u not supported on pid: %u\n",
+				res->dma_ch_num, umt_p->id);
+			return -EINVAL;
+		}
+
+		/* check UMT DMA Ctrl/channel CAP */
+		if (umt_dma_check(priv, res->dma_id)) {
+			dev_dbg(dev, "UMT RX DMA: %u not supported on pid: %u\n",
+				res->dma_id, umt_p->id);
+			return -EINVAL;
+		}
+	}
+
+	/* check UMT feature CAP */
+	if ((ctl->fflag & umt_p->feature_cap) != ctl->fflag) {
+		dev_dbg(dev,
+			"UMT feature not supported: req:0x%lx, hwcap:0x%lx\n",
+			ctl->fflag, umt_p->feature_cap);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int umt_find_pid(struct umt_priv *priv, struct dp_umt_port *port)
+{
+	int i;
+
+	for (i = priv->umt_port_num - 1; i >= 0; i--) {
+		if (priv->ports[i].allocated)
+			continue;
+
+		if (!umt_check_cfg(priv, &priv->ports[i], port))
+			return i;
+	}
+
+	return -1;
+}
+
+static void umt_set_sw_mode(struct umt_priv *priv, struct umt_port *umt_p)
+{
+	struct umt_port_ctl *ctl = &umt_p->cfg.ctl;
+	unsigned int id = umt_p->id;
+
+	umt_reg_write(priv, reg_addr_sw_mode(priv, id), ctl->sw_msg);
+}
+
+static void umt_set_period(struct umt_priv *priv, struct umt_port *umt_p)
+{
+	struct umt_port_ctl *ctl = &umt_p->cfg.ctl;
+	unsigned int id = umt_p->id;
+	u32 period = umt_us_to_cnt(priv, ctl->msg_interval);
+
+	umt_reg_write(priv, reg_addr_period(priv, id), period);
+}
+
+static void umt_set_dst(struct umt_priv *priv, struct umt_port *umt_p)
+{
+	struct umt_port_ctl *ctl = &umt_p->cfg.ctl;
+	unsigned int id = umt_p->id;
+
+	umt_reg_write(priv, reg_addr_dst(priv, id), (u32)ctl->daddr);
+}
+
+static void umt_set_mode(struct umt_priv *priv, struct umt_port *umt_p)
+{
+	struct umt_port_ctl *ctl = &umt_p->cfg.ctl;
+	unsigned int id = umt_p->id;
+
+	umt_reg_update_bit(priv, reg_addr_mode(priv),
+			   reg_mode_off(priv, id), ctl->msg_mode);
+}
+
+static int umt_get_rxmux(struct umt_priv *priv, struct umt_port *umt_p)
+{
+	struct umt_port_res *res = &umt_p->cfg.res;
+	const unsigned int cqm_pbase = priv->soc->enq_base;
+	int rxmux;
+
+	if (is_prx300_soc(priv))
+		return umt_p->dma_chid;
+
+	/* set RX0 MUX */
+	if (res->rx_src == UMT_RX_SRC_CQEM) {
+		if (res->cqm_enq_pid < cqm_pbase) {
+			dev_err(priv->dev, "CQM invalid EQ PID: %u",
+				res->cqm_enq_pid);
+			return -EINVAL;
+		} else {
+			return res->cqm_enq_pid - cqm_pbase;
+		}
+	}
+
+	switch (umt_p->dma_cid) {
+	case DMA0TX:
+		rxmux = 8 + umt_p->dma_chid;
+		break;
+	case DMA1TX:
+		rxmux = 2 + umt_p->dma_chid;
+		break;
+	case DMA2TX:
+		rxmux = umt_p->dma_chid - 2;
+		break;
+	default:
+		rxmux = -1;
+		break;
+	}
+
+	return rxmux;
+}
+
+static int umt_rx0_mux_off(struct umt_priv *priv, unsigned int chid)
+{
+	if (chid < 3)
+		return chid << 2;
+	else if (chid >= 3 && chid < 6)
+		return ((chid - 3) << 2) + 16;
+	else if (chid == 6)
+		return 12;
+	else
+		return 28;
+}
+
+static int umt_set_rxmux(struct umt_priv *priv, struct umt_port *umt_p)
+{
+	struct umt_port_res *res = &umt_p->cfg.res;
+	const unsigned int max_mux = 0xf;
+	unsigned int id = umt_p->id;
+	int i, rxmux;
+
+	rxmux = umt_get_rxmux(priv, umt_p);
+	if (rxmux < 0 || rxmux > max_mux) {
+		dev_err(priv->dev, "UMT Port %u invalid rxmux: %d\n",
+			id, rxmux);
+		return -EINVAL;
+	}
+
+	/* set RX0 MUX */
+	if (!id && res->rx_src == UMT_RX_SRC_DMA) {
+		if (res->dma_ch_num == 1) {
+			umt_reg_update_bit(priv, UMT_MODE, P0_CNT_MODE_OFF, 0);
+		} else {
+			umt_reg_update_bit(priv, UMT_MODE, P0_CNT_MODE_OFF, 1);
+			for (i = 0; i < res->dma_ch_num; i++) {
+				if (rxmux > max_mux) {
+					dev_err(priv->dev, "UMT Port %u invalid rxmux: %d\n",
+						id, rxmux);
+					return -EINVAL;
+				}
+				umt_reg_write_mask(priv, UMT_RX0_MUX,
+						   to_mask(UMT_MUX_WIDTH),
+						   umt_rx0_mux_off(priv, i),
+						   rxmux + i);
+			}
+			return 0;
+		}
+	}
+
+	umt_reg_write_mask(priv, UMT_TRG_MUX(id), to_mask(UMT_MUX_WIDTH),
+			   UMT_RX_MUX_OFF(id), rxmux);
+
+	return 0;
+}
+
+static int umt_get_txmux(struct umt_priv *priv, struct umt_port *umt_p)
+{
+	struct umt_port_res *res = &umt_p->cfg.res;
+	const int cqm_dpbase = priv->soc->dq_base;
+
+	if (res->cqm_dq_pid < cqm_dpbase)
+		return -EINVAL;
+
+	return res->cqm_dq_pid - cqm_dpbase;
+}
+
+static int umt_set_txmux(struct umt_priv *priv, struct umt_port *umt_p)
+{
+	const unsigned int max_mux = 0xf;
+	unsigned int id = umt_p->id;
+	int txmux;
+
+	txmux = umt_get_txmux(priv, umt_p);
+	if (txmux < 0 || txmux > max_mux) {
+		dev_err(priv->dev, "UMT Port %u invalid txmux: %d\n",
+			id, txmux);
+		return -EINVAL;
+	}
+
+	umt_reg_write_mask(priv, UMT_TRG_MUX(id), to_mask(UMT_MUX_WIDTH),
+			   UMT_TX_MUX_OFF(id), txmux);
+	return 0;
+}
+
+static void
+umt_set_feature(struct umt_priv *priv, struct umt_port *umt_p,
+		unsigned long flag_mask, unsigned long vflag)
+{
+	unsigned int id = umt_p->id;
+	bool set;
+
+	if (flag_mask & UMT_SND_DIS) {
+		set = !!(vflag & UMT_SND_DIS);
+		umt_reg_update_bit(priv, UMT_CNT_CTRL, SND_DIS_OFF(id), set);
+	}
+	if (flag_mask & UMT_CLEAR_CNT) {
+		set = !!(vflag & UMT_CLEAR_CNT);
+		umt_reg_update_bit(priv, UMT_CNT_CTRL, CLR_CNT_OFF(id), set);
+	}
+	if (flag_mask & UMT_NOT_SND_ZERO_CNT) {
+		set = !!(vflag & UMT_NOT_SND_ZERO_CNT);
+		umt_reg_update_bit(priv, UMT_CNT_CTRL,
+				   NOT_SND_ZERO_OFF(id), set);
+	}
+	if (flag_mask & UMT_SND_RX_CNT_ONLY) {
+		set = !!(vflag & UMT_SND_RX_CNT_ONLY);
+		umt_reg_update_bit(priv, UMT_CNT_CTRL, RX_SND_DIS_OFF(id), set);
+	}
+}
+
+static void umt_enable(struct umt_priv *priv, struct umt_port *umt_p)
+{
+	struct umt_port_ctl *ctl = &umt_p->cfg.ctl;
+	unsigned int id = umt_p->id;
+
+	umt_reg_update_bit(priv, reg_addr_mode(priv),
+			   reg_en_off(priv, id), ctl->enable);
+}
+
+/**
+ * API to request and allocate UMT port
+ */
+static void umt_cfg(struct umt_priv *priv, struct umt_port *umt_p)
+{
+	spin_lock(&priv->lock);
+	umt_set_sw_mode(priv, umt_p);
+	umt_set_period(priv, umt_p);
+	umt_set_dst(priv, umt_p);
+	umt_set_mode(priv, umt_p);
+	umt_set_rxmux(priv, umt_p);
+	umt_set_txmux(priv, umt_p);
+	umt_set_feature(priv, umt_p,
+			umt_p->cfg.ctl.fflag, umt_p->cfg.ctl.fflag);
+	umt_enable(priv, umt_p);
+	spin_unlock(&priv->lock);
+}
+
+static int umt_port_enable(struct device *dev, unsigned int id, bool en)
+{
+	struct umt_port *umt_p;
+	struct umt_priv *priv;
+	struct umt_port_ctl *ctl;
+
+	if (!dev) {
+		dev_err(dev, "umt device pointer is NULL!\n");
+		return -EINVAL;
+	}
+
+	priv = dev_get_drvdata(dev);
+	if (id >= priv->umt_port_num) {
+		dev_err(dev, "umt ID is invalid: %u\n", id);
+		return -EINVAL;
+	}
+
+	umt_p = &priv->ports[id];
+	if (!umt_p->allocated) {
+		dev_err(dev, "umt port not allocated: %u\n", id);
+		return -EINVAL;
+	}
+
+	ctl = &umt_p->cfg.ctl;
+	spin_lock(&priv->lock);
+	ctl->enable = en;
+	umt_enable(priv, umt_p);
+	spin_unlock(&priv->lock);
+
+	return 0;
+}
+
+static int
+umt_port_set_ctrl(struct device *dev, unsigned int id,
+		  unsigned long flag_mask, unsigned long vflag)
+{
+	struct umt_port_ctl *ctl;
+	struct umt_port *umt_p;
+	struct umt_priv *priv;
+	int i;
+
+	if (!dev) {
+		dev_err(dev, "umt device pointer is NULL!\n");
+		return -EINVAL;
+	}
+
+	priv = dev_get_drvdata(dev);
+	if (id >= priv->umt_port_num) {
+		dev_err(dev, "umt ID is invalid: %u\n", id);
+		return -EINVAL;
+	}
+
+	umt_p = &priv->ports[id];
+	if (!umt_p->allocated) {
+		dev_err(dev, "umt port not allocated: %u\n", id);
+		return -EINVAL;
+	}
+
+	ctl = &umt_p->cfg.ctl;
+	for (i = 0; BIT(i) <= UMT_F_MAX; i++) {
+		if (flag_mask & BIT(i)) {
+			if (vflag & BIT(i))
+				ctl->fflag |= BIT(i);
+			else
+				ctl->fflag &= ~BIT(i);
+		}
+	}
+	spin_lock(&priv->lock);
+	umt_set_feature(priv, umt_p, flag_mask, vflag);
+	spin_unlock(&priv->lock);
+
+	return 0;
+}
+
+static int umt_port_release(struct device *dev, unsigned int id)
+{
+	struct dp_umt_port *port;
+	struct umt_port *umt_p;
+	struct umt_priv *priv;
+
+	if (!dev) {
+		dev_err(dev, "umt device pointer is NULL!\n");
+		return -EINVAL;
+	}
+
+	priv = dev_get_drvdata(dev);
+	if (id >= priv->umt_port_num) {
+		dev_err(dev, "umt ID is invalid: %u\n", id);
+		return -EINVAL;
+	}
+
+	umt_p = &priv->ports[id];
+	if (!umt_p->allocated) {
+		dev_err(dev, "umt port not allocated: %u\n", id);
+		return -EINVAL;
+	}
+	port = &umt_p->cfg;
+
+	spin_lock(&priv->lock);
+	memset(port, 0, sizeof(*port));
+	umt_p->allocated = 0;
+	spin_unlock(&priv->lock);
+
+	return 0;
+}
+
+/**
+ * API to request and allocate UMT port
+ * input:
+ * @dev: umt device
+ * @umt: UMT port info. if id is 0xff means dynamic allocate port
+ * output:
+ * ret: Fail: < 0,  Success: 0
+ */
+static int umt_port_request(struct device *dev, struct dp_umt_port *port)
+{
+	struct umt_port *umt_p;
+	struct umt_priv *priv;
+	struct umt_port_ctl *ctl = &port->ctl;
+	struct umt_port_res *res = &port->res;
+	int id;
+
+	if (!port || !dev) {
+		dev_err(dev, "umt port/dev point is NULL!\n");
+		return -EINVAL;
+	}
+	priv = dev_get_drvdata(dev);
+
+	id = umt_find_pid(priv, port);
+	if (id < 0) {
+		dev_err(dev, "Failed to find a suitable port ID\n");
+		return -EINVAL;
+	}
+
+	umt_p = &priv->ports[id];
+	memcpy(&umt_p->cfg, port, sizeof(*port));
+	ctl->id = id;
+
+	dp_dma_parse_id(res->dma_id, &umt_p->dma_cid, NULL, &umt_p->dma_chid);
+	umt_p->allocated = 1;
+	umt_cfg(priv, umt_p);
+
+	return 0;
+}
+
+#ifdef CONFIG_DEBUG_FS
+static void *umt_port_seq_start(struct seq_file *s, loff_t *pos)
+{
+	struct umt_priv *priv = s->private;
+
+	if (*pos >= priv->umt_port_num)
+		return NULL;
+
+	return &priv->ports[*pos];
+}
+
+static void *umt_port_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	struct umt_priv *priv = s->private;
+
+	if (++(*pos) >= priv->umt_port_num)
+		return NULL;
+
+	return &priv->ports[*pos];
+}
+
+static void umt_port_seq_stop(struct seq_file *s, void *v)
+{
+}
+
+static int umt_port_seq_show(struct seq_file *s, void *v)
+{
+	struct umt_port *umt_p = v;
+	struct umt_port_ctl *ctl = &umt_p->cfg.ctl;
+	struct umt_port_res *res = &umt_p->cfg.res;
+
+	seq_puts(s, "-----------------------------------------\n");
+	seq_printf(s, "UMT port %d configuration\n", umt_p->id);
+	seq_printf(s, "UMT Mode:	%s\n", umt_mode_str[ctl->msg_mode]);
+	seq_printf(s, "UMT SW Mode:	%s\n", umt_sw_mode_str[ctl->sw_msg]);
+	seq_printf(s, "UMT DEST:	0x%x\n", (u32)ctl->daddr);
+	seq_printf(s, "UMT Period:	%u(us)\n", ctl->msg_interval);
+	seq_printf(s, "UMT Status:	%s\n", ctl->enable ?
+		   "Enable" : "Disable");
+	seq_printf(s, "UMT RX from:	%s\n",
+		   res->rx_src == UMT_RX_SRC_CQEM ? "CQEM" : "DMA");
+	if (res->rx_src == UMT_RX_SRC_CQEM) {
+		seq_printf(s, "UMT RX:		CQEM ENQ PID: %u\n",
+			   res->cqm_enq_pid);
+	} else {
+		seq_printf(s, "UMT RX DMA:	DMA%dTXC%d\n",
+			   umt_p->dma_cid, umt_p->dma_chid);
+		seq_printf(s, "UMT RX DMA NUM:	%d\n", res->dma_ch_num);
+	}
+	seq_printf(s, "UMT TX:		CQM DEQ PID: %d\n", res->cqm_dq_pid);
+	seq_printf(s, "UMT Alloc:	%s\n", umt_p->allocated ? "Yes" : "No");
+
+	return 0;
+}
+
+static const struct seq_operations umt_port_seq_ops = {
+	.start = umt_port_seq_start,
+	.next = umt_port_seq_next,
+	.stop = umt_port_seq_stop,
+	.show = umt_port_seq_show,
+};
+
+static int umt_port_debugfs_open(struct inode *inode, struct file *file)
+{
+	struct seq_file *s;
+	int ret;
+
+	ret = seq_open(file, &umt_port_seq_ops);
+	if (!ret) {
+		s = file->private_data;
+		s->private = inode->i_private;
+	}
+
+	return ret;
+}
+
+static const struct file_operations umt_port_fops = {
+	.open		= umt_port_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+static int umt_reg_info_show(struct seq_file *s, void *v)
+{
+	struct umt_priv *priv = s->private;
+	int i, idx;
+
+	seq_puts(s, "------UMT Controller Configuration-------\n");
+	seq_printf(s, "UMT Port Num:	%u\n", priv->umt_port_num);
+	seq_printf(s, "Byte swap:	%u\n", priv->byte_swap);
+	seq_printf(s, "Dword swap:	%u\n", priv->dw_swap);
+	seq_puts(s, "------UMT REG Configuration--------------\n");
+	seq_printf(s, "GCTRL:		0x%08x\n",
+		   umt_reg_read(priv, UMT_GCTRL));
+	seq_printf(s, "CNT CTRL:	0x%08x\n",
+		   umt_reg_read(priv, UMT_CNT_CTRL));
+
+	if (!is_prx300_soc(priv)) {
+		seq_printf(s, "UMT MODE:	0x%08x\n",
+			   umt_reg_read(priv, UMT_MODE));
+		seq_printf(s, "RX0 MUX0:	0x%08x\n",
+			   umt_reg_read(priv, UMT_RX0_MUX));
+		seq_printf(s, "TRG MUX1:	0x%08x\n",
+			   umt_reg_read(priv, UMT_TRG_MUX(4)));
+	}
+	seq_printf(s, "TRG MUX0:	0x%08x\n",
+		   umt_reg_read(priv, UMT_TRG_MUX(0)));
+
+	seq_puts(s, "------UMT Port REG Configuration---------\n");
+	for (i = 0; i < priv->umt_port_num; i++) {
+		seq_printf(s, "Port idx:	%d\n", i);
+		seq_printf(s, "Period:		0x%x\n",
+			   umt_reg_read(priv, reg_addr_period(priv, i)));
+		seq_printf(s, "Dst addr:	0x%x\n",
+			   umt_reg_read(priv, reg_addr_dst(priv, i)));
+		idx = umt_reg_read(priv, reg_addr_sw_mode(priv, i));
+		seq_printf(s, "SW MSG mode:	%s\n", umt_sw_mode_str[idx]);
+		seq_puts(s, "\n");
+	}
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(umt_reg_info);
+
+static int umt_debugfs_init(struct umt_priv *priv)
+{
+	struct dentry *file;
+
+	priv->debugfs = debugfs_create_dir("umt", NULL);
+	if (!priv->debugfs)
+		return -ENOMEM;
+
+	file = debugfs_create_file("umt_info", 0644, priv->debugfs,
+				   priv, &umt_port_fops);
+	if (!file)
+		goto err;
+
+	file = debugfs_create_file("umt_reg", 0644, priv->debugfs,
+				   priv, &umt_reg_info_fops);
+	if (!file)
+		goto err;
+
+	return 0;
+
+err:
+	debugfs_remove_recursive(priv->debugfs);
+	priv->debugfs = NULL;
+	dev_err(priv->dev, "UMT debugfs create fail!\n");
+	return -ENOMEM;
+}
+#endif
+
+static void umt_port_init(struct umt_priv *priv)
+{
+	struct umt_port *umt_p;
+	int i;
+
+	for (i = 0; i < priv->umt_port_num; i++) {
+		umt_p = &priv->ports[i];
+
+		umt_p->id = i;
+		umt_p->rx_src_cap = priv->soc->rx_src_cap;
+		if (priv->soc->ver == PRX300_SOC)
+			umt_p->dma_chn_cap = 1;
+		else
+			umt_p->dma_chn_cap = i == 0 ? 8 : 1;
+		umt_p->feature_cap = priv->soc->feature_cap;
+	}
+}
+
+static const struct umt_soc_data lgm_umt_data = {
+	.ver          = LGM_SOC,
+	.umt_port_num = 8,
+	.rx_src_cap   = BIT(UMT_RX_SRC_CQEM) | BIT(UMT_RX_SRC_DMA),
+	.feature_cap  = UMT_SND_DIS | UMT_CLEAR_CNT
+			| UMT_NOT_SND_ZERO_CNT | UMT_SND_RX_CNT_ONLY,
+	.enq_base     = 16,
+	.dq_base      = 19,
+};
+
+static const struct umt_soc_data prx300_umt_data = {
+	.ver          = PRX300_SOC,
+	.umt_port_num = 3,
+	.rx_src_cap   = BIT(UMT_RX_SRC_DMA),
+	.feature_cap  = UMT_SND_DIS | UMT_CLEAR_CNT,
+	.dq_base      = 4,
+};
+
+static const struct of_device_id of_umt_drv_match[] = {
+	{ .compatible = "intel,lgm-umt", .data = &lgm_umt_data },
+	{ .compatible = "intel,prx300-umt", .data = &prx300_umt_data },
+	{}
+};
+MODULE_DEVICE_TABLE(of, of_umt_drv_match);
+
+static int umt_drv_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	const struct of_device_id *match;
+	struct umt_priv *priv;
+	struct resource *res;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->dev = dev;
+
+	match = of_match_device(of_umt_drv_match, dev);
+	if (!match)
+		return -ENODEV;
+	priv->soc = match->data;
+
+	priv->clk = devm_clk_get(dev, "freq");
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "No UMT clock\n");
+		return -EINVAL;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->membase = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->membase)) {
+		dev_err(dev, "ioremap mem resource failed!\n");
+		return -ENOMEM;
+	}
+
+	if (device_property_read_bool(dev, "intel,umt-dw-swap"))
+		priv->dw_swap = 1;
+
+	if (device_property_read_bool(dev, "intel,umt-byte-swap"))
+		priv->byte_swap = 1;
+
+	priv->umt_port_num = priv->soc->umt_port_num;
+	priv->ports =
+		devm_kzalloc(dev, sizeof(*priv->ports) * priv->umt_port_num,
+			     GFP_KERNEL);
+	if (!priv->ports)
+		return -ENOMEM;
+
+	spin_lock_init(&priv->lock);
+	platform_set_drvdata(pdev, priv);
+	priv->ops.umt_dev      = dev;
+	priv->ops.umt_request  = umt_port_request;
+	priv->ops.umt_enable   = umt_port_enable;
+	priv->ops.umt_set_ctrl = umt_port_set_ctrl;
+	priv->ops.umt_release  = umt_port_release;
+
+	umt_hw_init(priv);
+	umt_port_init(priv);
+
+#ifdef CONFIG_DEBUG_FS
+	umt_debugfs_init(priv);
+#endif
+	dp_register_ops(0, DP_OPS_UMT, (void *)&priv->ops);
+
+	dev_info(dev, "UMT driver init success!\n");
+
+	return 0;
+}
+
+static int umt_drv_remove(struct platform_device *pdev)
+{
+	struct umt_priv *priv;
+
+	priv = platform_get_drvdata(pdev);
+
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove_recursive(priv->debugfs);
+#endif
+	dev_info(&pdev->dev, "Intel DATAPATH UMT driver remove!\n");
+	return 0;
+}
+
+static struct platform_driver umt_driver = {
+	.probe = umt_drv_probe,
+	.remove = umt_drv_remove,
+	.driver = {
+		.name = "intel,umt",
+		.of_match_table = of_match_ptr(of_umt_drv_match),
+		.owner = THIS_MODULE,
+	},
+};
+
+module_platform_driver(umt_driver);
+
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/ethernet/lantiq/Kconfig b/drivers/net/ethernet/lantiq/Kconfig
index 04b4a3304215..3d2e253265e3 100644
--- a/drivers/net/ethernet/lantiq/Kconfig
+++ b/drivers/net/ethernet/lantiq/Kconfig
@@ -102,7 +102,7 @@ config INTEL_XPCS
 	  This driver provides support for Xpcs for 10G.
 
 
-source "drivers/net/datapath/dpm/Kconfig"
+source "drivers/net/datapath/Kconfig"
 source "drivers/net/ethernet/lantiq/switch-api/Kconfig"
 source "drivers/net/ethernet/lantiq/cqm/Kconfig"
 source "drivers/net/ethernet/lantiq/tmu/Kconfig"
diff --git a/drivers/net/ethernet/lantiq/Makefile b/drivers/net/ethernet/lantiq/Makefile
index 77fd0cee242e..046df909af68 100644
--- a/drivers/net/ethernet/lantiq/Makefile
+++ b/drivers/net/ethernet/lantiq/Makefile
@@ -1,8 +1,12 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright (C) 2019 Intel Corporation.
 obj-$(CONFIG_LANTIQ_VRX318) += ltq_vrx318.o
 obj-$(CONFIG_LANTIQ_ETH_FRAMEWORK) += lantiq_eth_framework.o
 obj-$(CONFIG_INTEL_XPCS) += xpcs/
 obj-$(CONFIG_LTQ_ETHSW_API) += switch-api/
 obj-$(CONFIG_LTQ_DATAPATH) += ../../datapath/dpm/
+obj-$(CONFIG_INTEL_UMT) += ../../datapath/umt/
 obj-$(CONFIG_LTQ_TMU) += tmu/
 obj-$(CONFIG_LTQ_PPV4) += ppv4/
 obj-$(CONFIG_LTQ_CBM) += cqm/
@@ -11,5 +15,5 @@ obj-$(CONFIG_INTEL_PON_HGU_VUNI) += intel_pon_hgu_vuni.o
 obj-$(CONFIG_INTEL_GINT_ETH) += intel_gint_eth_drv.o
 obj-$(CONFIG_XRX500_PHY_FW) += xrx500_phy_fw.o
 obj-$(CONFIG_PPA) += ppa/
-obj-$(CONFIG_INTEL_UMT_CQEM_MODE) += umt/umt.o
+#obj-$(CONFIG_INTEL_UMT_CQEM_MODE) += umt/umt.o
 obj-$(CONFIG_LTQ_TOE_DRIVER) += ltq_toe_drv.o
diff --git a/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c b/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
index 62a5c49c4849..84eaed82f846 100644
--- a/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
+++ b/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
@@ -2262,43 +2262,12 @@ static int fill_rx_ring_data(struct cbm_dp_alloc_complete_data *dp_data)
 			break;
 		}
 
-		/* in_alloc_ring_size should be 0 - 32 */
-		if ((dp_data->rx_ring[ring_idx].in_alloc_ring_size < 0) ||
-		    (dp_data->rx_ring[ring_idx].in_alloc_ring_size >
-		     p_info->deq_info.num_desc)) {
-			dev_err(cqm_ctrl->dev, "%s Inv in_alloc_ring_size %u\n",
-				__func__,
-				dp_data->rx_ring[ring_idx].in_alloc_ring_size);
-			break;
-		} else if (!dp_data->rx_ring[ring_idx].in_alloc_ring_size) {
-			dp_data->rx_ring[ring_idx].in_alloc_ring_size =
-						p_info->deq_info.num_desc;
-		}
-
-		/* out_enq_ring_size should be 0 - 32 */
-		if ((dp_data->rx_ring[ring_idx].out_enq_ring_size < 0) ||
-		    (dp_data->rx_ring[ring_idx].out_enq_ring_size >
-		     p_info->deq_info.num_desc)) {
-			dev_err(cqm_ctrl->dev, "%s Inv out_enq_ring_size %u\n",
+		/* out_enq_ring_size fixed to 4096 */
+		if (dp_data->rx_ring[ring_idx].out_enq_ring_size >= CQM_KB(4)) {
+			dev_err(cqm_ctrl->dev, "%s out_enq_ring_size %u\n",
 				__func__,
 				dp_data->rx_ring[ring_idx].out_enq_ring_size);
 			break;
-		} else if (!dp_data->rx_ring[ring_idx].out_enq_ring_size) {
-			dp_data->rx_ring[ring_idx].out_enq_ring_size =
-						p_info->deq_info.num_desc;
-		}
-
-		/* prefill_pkt_num  should be 0 - 32 */
-		if ((dp_data->rx_ring[ring_idx].prefill_pkt_num < 0) ||
-		    (dp_data->rx_ring[ring_idx].prefill_pkt_num >
-		     p_info->deq_info.num_desc)) {
-			dev_err(cqm_ctrl->dev, "%s Inv prefill_pkt_num %u\n",
-				__func__,
-				dp_data->rx_ring[ring_idx].prefill_pkt_num);
-			break;
-		} else if (!dp_data->rx_ring[ring_idx].prefill_pkt_num) {
-			dp_data->rx_ring[ring_idx].prefill_pkt_num =
-						p_info->deq_info.num_desc;
 		}
 
 		if (p_info->dma_dt_init_type != DEQ_DMA_CHNL) {
@@ -2316,7 +2285,7 @@ static int fill_rx_ring_data(struct cbm_dp_alloc_complete_data *dp_data)
 
 		if (ltq_dma_chan_desc_alloc(
 			p_info->dma_ch,
-			dp_data->rx_ring[ring_idx].in_alloc_ring_size)) {
+			dp_data->rx_ring[ring_idx].out_enq_ring_size)) {
 			ltq_free_dma(p_info->dma_ch);
 			dev_err(cqm_ctrl->dev, "%s: dma alloc failed\r\n",
 				__func__);
@@ -2332,9 +2301,6 @@ static int fill_rx_ring_data(struct cbm_dp_alloc_complete_data *dp_data)
 		dp_data->rx_ring[ring_idx].out_enq_vaddr =
 			(void *)ltq_dma_chan_get_desc_vir_base(p_info->dma_ch);
 
-		cbm_w32((cqm_ctrl->enq + EQ_DMA_PORT(dp_data->deq_port, dptr)),
-			(dp_data->rx_ring[ring_idx].out_enq_ring_size  - 1));
-
 		tbl_size = dp_data->rx_ring[ring_idx].prefill_pkt_num
 				* sizeof(u32);
 		dma_size = tbl_size * 2;
diff --git a/include/net/datapath_api.h b/include/net/datapath_api.h
index a76a8f23831b..3b85b957a148 100644
--- a/include/net/datapath_api.h
+++ b/include/net/datapath_api.h
@@ -22,13 +22,15 @@
 #include <net/datapath_api_ppv4.h>
 #elif IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP31)
 #include <net/datapath_api_gswip31.h>
-#elif IS_ENABLED(CONFIG_GRX500_CBM) /*GRX500 GSWIP30*/
+#elif IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP30) /*GRX500 GSWIP30*/
 #include <net/datapath_api_gswip30.h>
 #else
 #error "wrong DP HAL selected"
 #endif
 #endif /*DATAPATH_HAL_LAYER */
-#include <net/intel_datapath_umt.h>
+#if !IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP30) /*GRX500 GSWIP30*/
+#include <net/datapath_api_umt.h>
+#endif
 #include <net/datapath_api_vlan.h>
 #include <net/switch_api/lantiq_gsw_api.h>
 #include <net/switch_api/lantiq_gsw_flow.h>
@@ -1019,34 +1021,15 @@ enum DP_DEV_DATA_FLAG {
  *                only 13 bits in PAE are handled [14, 11:0]
  *\note
  */
-enum DP_UMT_MODE {
-	DP_UMT_MODE_HW_SELF, /*!< HW UMT self couting mode */
-	DP_UMT_MODE_HW_USER, /*!< HW UMT user Mode */
-	DP_UMT_MODE_SW, /*!< SW UMT: no need to call UMT API */
-};
 
-enum DP_UMT_MSG_MODE {
-	DP_UMT_MSG_MODE_ACCU,  /*!< Accumulated msg mode */
-	DP_UMT_MSG_MODE_INCRE, /*!< Accumulated msg mode */
-	DP_UMT_MSG_MODE_MAX  /*!< Not valid UMT msg mode */
-};
 
-enum DP_RXOUT_MSG_MODE {
-	DP_RXOUT_MSG_ADD = 0, /*!< rxout_add */
-	DP_RXOUT_MSG_SUB, /*!< rxout_sub */
-};
 
 enum DP_RXOUT_QOS_MODE {
 	DP_RXOUT_BYPASS_QOS_ONLY = 0, /*!< bypass QOS but with FSQM */
 	DP_RXOUT_QOS, /*!< with QOS */
 	DP_RXOUT_BYPASS_QOS_FSQM, /*!< bypass QOS and FSQM */
 	DP_RXOUT_QOS_MAX /*!< Not valid RXOUT qos mode */
-};
 
-enum DP_UMT_MSG_ENDIAN {
-	DP_UMT_MSG_ENDIAN_LITTLE = 0, /*!< UMT message in little endian */
-	DP_UMT_MSG_ENDIAN_BIG, /*!< UMT message in big endian */
-	DP_UMT_MSG_ENDIAN_MAX  /*!< Not valid UMT msg endian */
 };
 
 /*! @brief struct dp_rx_ring, which is used for DirectConnected (DC)
@@ -1136,7 +1119,9 @@ struct dp_rx_ring {
 				*    virtual addresses
 				*    For software testing or debugging
 				*/
-	enum DP_RXOUT_MSG_MODE out_msg_mode; /*!< [in] rxout msg mode */
+#if !IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP30) /*GRX500 GSWIP30*/
+	enum umt_rx_msg_mode out_msg_mode; /*!< [in] rxout msg mode */
+#endif
 	enum DP_RXOUT_QOS_MODE out_qos_mode; /*!< [in] rxout qos mode */
 };
 
@@ -1221,37 +1206,6 @@ struct dp_tx_ring {
 				  */
 };
 
-/*! @brief struct dp_umt, which only used for DirectConnected (DC)
- *  applications
- */
-struct dp_umt {
-	u8 enable : 1; /*!< [in] enable flag to indicate whether need to
-			*   use this UMT or not
-			*/
-	u32 umt_msg_timer; /*!< [in] UMT msg update interval in us */
-
-	void *umt_msg_paddr; /*!< [in] umt message physical base address.
-			      *   Note: umt rx/tx share same base address.
-			      *   The msg sequence is rx first, followed by tx
-			      *   For SW UMT case, it should be NULL
-			      */
-	void *umt_msg_vaddr; /*!< [in] umt message virtual base address
-			      *    If HW UMT , it should be NULL
-			      */
-	enum DP_UMT_MODE umt_mode; /*!< [in] UMT mode */
-	enum DP_UMT_MSG_MODE umt_msg_mode; /*!< [in] UMT RX MSG mode
-					    */
-	/* Note: remove enum dp_umt_rx_src umt_rx_src for LGM;
-	 * Basic rule to set inside DP:
-	 *     1) bypass both QOS and FSQM: set mode DP_UMT_RX_FROM_DMA
-	 *     2) otherwise set mode DP_UMT_RX_FROM_CQEM
-	 */
-	enum dp_umt_sw_msg usr_msg; /*!< [in] For UMT HW user mode only
-				     *    For HW_SELF counting mode, always with
-				     *      msg rx + tx
-				     */
-};
-
 /*! @brief struct dp_dev_data, which used for DirectConnected (DC)
  *  applications
  */
@@ -1287,7 +1241,9 @@ struct dp_dev_data {
 	struct dp_gpid_tx_info gpid_info; /*!< [in] for GPID tx information
 					   *   Valid only if @f_gpid valid.
 					   */
-	struct dp_umt umt[DP_MAX_UMT]; /*!< [in/out] DC umt information */
+#if !IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP30) /*GRX500 GSWIP30*/
+	struct dp_umt_port umt[DP_MAX_UMT]; /*!< [in/out] DC umt information */
+#endif
 	u32 enable_cqm_meta : 1; /*!< enable CQM buffer meta data marking */
 
 	u16 max_ctp;    /*!< [in] maximum subif required which will be mapped to
@@ -1814,7 +1770,9 @@ struct dp_spl_conn {
 	struct dp_gpid_tx_info gpid_info; /*!< [in] for GPID tx information
 					   *   Valid only if @f_gpid valid.
 					   */
-	struct dp_umt umt[DP_MAX_UMT]; /*!< [in/out] DC umt information */
+#if !IS_ENABLED(CONFIG_INTEL_DATAPATH_HAL_GSWIP30) /*GRX500 GSWIP30*/
+	struct dp_umt_port umt[DP_MAX_UMT]; /*!< [in/out] DC umt information */
+#endif
 };
 
 /*!
@@ -1841,8 +1799,9 @@ enum DP_OPS_TYPE {
  *@param[in] type: ops type
  *@param[in] ops: pointer to ops structure
  *@note  set to NULL to deregister
+ *@return return 0 if OK / -1 if error
  */
-void dp_register_ops(int inst, enum DP_OPS_TYPE type, void *ops);
+int dp_register_ops(int inst, enum DP_OPS_TYPE type, void *ops);
 
 /*!
  *@brief get ops registration
@@ -1853,4 +1812,30 @@ void dp_register_ops(int inst, enum DP_OPS_TYPE type, void *ops);
 void *dp_get_ops(int inst, enum DP_OPS_TYPE type);
 int dp_get_mtu_size(struct net_device *dev, u32 *mtu_size);
 
+/*!
+ *@brief get UMT ops registration
+ *@param[in] inst: DP instance ID
+ *@return UMT ops pointer if registered, or NULL if not registered
+ */
+static inline struct umt_ops *dp_get_umt_ops(int inst)
+{
+	return (struct umt_ops *)dp_get_ops(inst, DP_OPS_UMT);
+}
+
+/*!
+ *@brief parse dma ID
+ *@param[in] inst     : DMA ID
+ *@param[out] cid     : DMA Controller ID
+ *@param[out] pid     : DMA Port ID
+ *@param[out] chid    : DMA Channel ID
+ */
+static inline void dp_dma_parse_id(u32 dma_id, u8 *cid, u8 *pid, u16 *chid)
+{
+	if (cid)
+		*cid = dma_id >> 24;
+	if (pid)
+		*pid = (dma_id >> 16) & 0xff;
+	if (chid)
+		*chid = dma_id & 0xffff;
+}
 #endif /*DATAPATH_API_H */
diff --git a/include/net/datapath_api_umt.h b/include/net/datapath_api_umt.h
index 6f64bdc8ece8..8aa22019bae0 100644
--- a/include/net/datapath_api_umt.h
+++ b/include/net/datapath_api_umt.h
@@ -1,121 +1,78 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
  *  Copyright (C) 2018 Intel Corporation.
- *  Zhu YiXin <Yixin.zhu@intel.com>
+ *  Wu ZhiXian <zhixian.wu@intel.com>
  */
 
-/* ----define register and macro start */
-#define DP_UMT_NOT_SENDING_ZERO_COUNT	BIT(0)
-#define DP_UMT_SENDING_RX_COUNT_ONLY	BIT(1)
-#define DP_UMT_SUSPEND_SENDING_COUNT	BIT(2)
-#define DP_UMT_ENABLE			BIT(3)
+#ifndef _DATAPATH_UMT_H_
+#define _DATAPATH_UMT_H_
 
-/* ----define register and macro end */
+/* UMT feature flag */
+#define UMT_SND_DIS			BIT(0)
+#define UMT_CLEAR_CNT			BIT(1)
+#define UMT_NOT_SND_ZERO_CNT		BIT(2)
+#define UMT_SND_RX_CNT_ONLY		BIT(3)
+#define UMT_F_MAX			UMT_SND_RX_CNT_ONLY
 
-/* ----define enum start*/
-enum dp_umt_rx_src {
-	DP_UMT_RX_FROM_CQEM,
-	DP_UMT_RX_FROM_DMA
+enum umt_rx_src {
+	UMT_RX_SRC_CQEM, /* RX count from CQM */
+	UMT_RX_SRC_DMA,  /* RX count from DMA */
 };
 
-enum dp_umt_msg_mode {
-	DP_UMT_SELFCNT_MODE = 0,
-	DP_UMG_USER_MSG_MODE = 1,
+enum umt_msg_mode {
+	UMT_MSG_SELFCNT,   /* HW count mode */
+	UMT_MSG_USER_MODE, /* User count mode */
 };
 
-enum dp_umt_sw_msg { /* for DP_UMG_USER_MSG_MODE only */
-	DP_UMT_MSG0_ONLY = 0,
-	DP_UMT_MSG1_ONLY,
-	DP_UMT_MSG0_MSG1,
+enum umt_sw_msg {
+	UMT_NO_MSG,
+	UMT_MSG0_ONLY,
+	UMT_MSG1_ONLY,
+	UMT_MSG0_MSG1,
 };
 
-/* ----define enum end */
-
-/* ----define structure here start*/
-/**
- * struct dp_umt_param
- * id: umt HW ID. (0 - 7)
- * rx_src: indicate rx msg source.
- * dma_id: it contains DMA controller ID, DMA port ID and base DMA channel ID.
- * dma_ch_num: number of dma channels used by this UMT port.
- * cqm_enq_pid: cqm enqueue port ID.
- * cqm_dq_pid: cqm dequeue port ID.
- * daddr: UMT message destination address.
- * msg_mode: UMT message mode.
- * period: UMT message interval period.
- * sw_msg: software message mode.
- * flag:  UMT message control flag.
- */
-struct dp_umt_param {
-	u8			id; /* [in/out] 0xff -- auto assign,
-	 				othe value: caller provide
-	 			     */
-	enum dp_umt_rx_src	rx_src; /* [in] */
-	u32			dma_id;  /* [in] */
-	u8			dma_ch_num; /* [in] */
-	u8			cqm_enq_pid; /* [in] */
-	u8			cqm_dq_pid; /* [in] */
-	u32			daddr;  /* [in] */
-	enum dp_umt_msg_mode	msg_mode; /* [in] */
-	u32			period; /* [in] */
-	enum dp_umt_sw_msg	sw_msg; /* [in] */
-	unsigned long		flag; /* [in] control flag*/
+enum umt_cnt_mode {
+	UMT_CNT_INC, /* Incremental count */
+	UMT_CNT_ACC, /* Accumulate count */
 };
 
-/**
- * struct dp_umt_priv
- * dev: platform device.
- * membase: UMT register base address.
- * umt_num: number of UMT entries.
- * umts: umt entry list.
- */
-struct dp_umt_priv {
-	struct device		*dev;
-	void __iomem		*membase;
-	u8			umt_num;
-	struct dp_umt_entry	*umts;
+enum umt_rx_msg_mode {
+	UMT_RXOUT_MSG_SUB, /* RX OUT SUB mode */
+	UMT_RXIN_MSG_ADD   /* RX IN Add mode */
 };
 
-/**
- * struct dp_umt_entry
- * param: umt configure parameters.
- * alloced: umt entry status.
- * enabled: umt entry status.
- * halted:  umt control status.
- * not_snd_zero_cnt: umt control status.
- * snd_rx_only: umt control status.
- * max_dam_ch_num: support max DMA channel numbers.
- * debugfs: debugfs proc.
- */
-struct dp_umt_entry {
-	struct dp_umt_param	param;
-	int			alloced:1;
-	int			enabled:1;
-	int			halted:1;
-	int			not_snd_zero_cnt:1;
-	int			snd_rx_only:1;
-	int			max_dma_ch_num;
-	struct dentry		*debugfs;
+struct umt_port_ctl {
+	int                  id;	    /* UMT Port ID */
+	dma_addr_t           daddr;	    /* MSG ADDR */
+	u32                  msg_interval;  /* MSG interval */
+	enum umt_msg_mode    msg_mode;
+	enum umt_cnt_mode    cnt_mode;
+	enum umt_sw_msg      sw_msg;	    /* SW mode cfg */
+	enum umt_rx_msg_mode rx_msg_mode;
+	unsigned int         enable;
+	unsigned long        fflag;	    /* UMT feature flag */
 };
 
-/* ----define structure here end */
-
-/* ----declare APIs start */
-int dp_umt_request(struct dp_umt_param *umt, unsigned long flag);
-
-/* set flag for period  */
-#define DP_UMT_SET_Period BIT(0)
-int dp_umt_set(struct dp_umt_param *umt, unsigned long flag);
+struct umt_port_res {
+	u32               dma_id;
+	unsigned int      dma_ch_num;
+	unsigned int      cqm_enq_pid;
+	unsigned int      cqm_dq_pid;
+	enum umt_rx_src   rx_src;
+};
 
-int dp_umt_enable(struct dp_umt_param *umt, unsigned long flag, int enable);
-int dp_umt_suspend_sending(struct dp_umt_param *umt,
-			   unsigned long flag, int halt);
+struct dp_umt_port {
+	struct umt_port_ctl ctl; /* User input info, e.g. DCDP */
+	struct umt_port_res res; /* DP manager input info */
+};
 
-/* ----declare APIs end */
+struct umt_ops {
+	struct device *umt_dev;
+	int (*umt_request)(struct device *umt_dev, struct dp_umt_port *port);
+	int (*umt_enable)(struct device *umt_dev, unsigned int id, bool en);
+	int (*umt_set_ctrl)(struct device *umt_dev, unsigned int id,
+			    unsigned long flag_mask, unsigned long vflag);
+	int (*umt_release)(struct device *umt_dev, unsigned int id);
+};
 
-/**
- * debug proc should support:
- * 1. register content dump
- * 2. RX/TX trigger
- * 3. UMT status
- */
+#endif /* _DATAPATH_UMT_H_ */
diff --git a/include/net/dc_ep.h b/include/net/dc_ep.h
old mode 100755
new mode 100644
diff --git a/include/net/lantiq_cbm_api.h b/include/net/lantiq_cbm_api.h
index 259f24de53b2..3d75a01ac29f 100644
--- a/include/net/lantiq_cbm_api.h
+++ b/include/net/lantiq_cbm_api.h
@@ -854,7 +854,10 @@ struct cbm_dp_alloc_complete_data {
 						    */
 	struct dp_tx_ring tx_ring[DP_TX_RING_NUM]; /*!< [in/out] DC tx ring info
 						    */
-	struct dp_umt umt[DP_MAX_UMT]; /*!< [in/out] DC umt information */
+
+#if !IS_ENABLED(CONFIG_GRX500_CBM) /*GRX500 GSWIP30*/
+	struct dp_umt_port umt[DP_MAX_UMT]; /*!< [in/out] DC umt information */
+#endif
 	u32 enable_cqm_meta : 1; /*!< enable CQM buffer meta data marking */
 	int alloc_flags; /*!< original alloc flags used in the dp_alloc_port */
 	u32 deq_port;	/* [in] port id which was returned in the alloc */
