From 10a96bbf1b844db34f3593bac1dfc52fc2dafd9c Mon Sep 17 00:00:00 2001
From: Oren Bakshe <oren.bakshe@intel.com>
Date: Thu, 4 Apr 2019 18:21:01 +0300
Subject: [PATCH] PONRTSYS-3958: Fixed potential cmd buffer overflow

---
 drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_fw.c   | 75 ++++++++++++++++------
 .../net/ethernet/lantiq/ppv4/qos/pp_qos_linux.c    |  7 +-
 drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c |  9 ++-
 .../net/ethernet/lantiq/ppv4/qos/pp_qos_uc_defs.h  | 30 +--------
 4 files changed, 69 insertions(+), 52 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_fw.c b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_fw.c
index 0f096ec504cc..e9c6325b46bc 100644
--- a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_fw.c
+++ b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_fw.c
@@ -1,7 +1,7 @@
 /*
  * GPL LICENSE SUMMARY
  *
- *  Copyright(c) 2017 Intel Corporation.
+ *  Copyright(c) 2017-2019 Intel Corporation.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of version 2 of the GNU General Public License as
@@ -1342,16 +1342,24 @@ struct fw_internal {
 		struct fw_set_sched sched;
 		struct fw_set_queue queue;
 	} type_data;
-	unsigned int suspend_port_index;
+	unsigned int suspend_ports_index;
+	unsigned int num_suspend_ports;
 	unsigned int suspend_ports[QOS_MAX_PORTS];
-	unsigned int moved_node_index;
+	unsigned int moved_nodes_index;
+	unsigned int num_moved_nodes;
 	struct move_info {
 		unsigned int phy;
 	} moved_nodes[16 * MAX_MOVING_NODES];
 	unsigned int	pushed;
-	int		ongoing;
+	int		ongoing;	/* Suspend ports indication */
 };
 
+/* Is ongoing means, we suspended the ports without resuming yet */
+int is_ongoing(struct pp_qos_dev *qdev)
+{
+	return ((struct fw_internal *)(qdev->fwbuf))->ongoing;
+}
+
 /******************************************************************************/
 /*                         FW write functions                                 */
 /******************************************************************************/
@@ -1365,13 +1373,13 @@ void add_suspend_port(struct pp_qos_dev *qdev, unsigned int port)
 	node = get_node_from_phy(qdev->nodes, port);
 	QOS_ASSERT(node_port(node), "Node %u is not a port\n", port);
 	internals = qdev->fwbuf;
-	for (i = 0; i <  internals->suspend_port_index; ++i)
+	for (i = 0; i <  internals->num_suspend_ports; ++i)
 		if (internals->suspend_ports[i] == port)
 			return;
-	QOS_ASSERT(internals->suspend_port_index <= qdev->max_port,
+	QOS_ASSERT(internals->num_suspend_ports <= qdev->max_port,
 		   "Suspend ports buffer is full\n");
-	internals->suspend_ports[internals->suspend_port_index] = port;
-	++(internals->suspend_port_index);
+	internals->suspend_ports[internals->num_suspend_ports] = port;
+	++(internals->num_suspend_ports);
 }
 
 /*
@@ -1395,7 +1403,7 @@ static void update_moved_nodes(
 	int found;
 
 	internals = qdev->fwbuf;
-	j = internals->moved_node_index;
+	j = internals->num_moved_nodes;
 	found = 0;
 
 	for (i = 0; i < j; ++i) {
@@ -1408,12 +1416,12 @@ static void update_moved_nodes(
 			found = 1;
 	}
 
-	internals->moved_node_index = j;
-	QOS_ASSERT(internals->moved_node_index < 16 * MAX_MOVING_NODES,
+	internals->num_moved_nodes = j;
+	QOS_ASSERT(internals->num_moved_nodes < 16 * MAX_MOVING_NODES,
 			"Moved ports buffer is full\n");
 	if (!found) {
 		internals->moved_nodes[j].phy = dst;
-		++(internals->moved_node_index);
+		++(internals->num_moved_nodes);
 	}
 }
 
@@ -1993,6 +2001,7 @@ static uint32_t *restart_node(
 		struct pp_qos_dev *qdev,
 		unsigned int phy,
 		uint32_t *_cur,
+		uint32_t **_prev,
 		struct cmd_internal *cmd)
 {
 	struct qos_node *node;
@@ -2033,6 +2042,7 @@ static uint32_t *restart_node(
 
 		common.suspend = 0;
 		cmd->base.pos = cur;
+		*_prev = cur;
 		cur = fw_write_set_sched_cmd(
 				cur,
 				phy,
@@ -2067,6 +2077,7 @@ static uint32_t *restart_node(
 
 		common.suspend = 0;
 		cmd->base.pos = cur;
+		*_prev = cur;
 		cur = fw_write_set_queue_cmd(
 				cur,
 				phy,
@@ -2614,7 +2625,7 @@ static void post_process(struct pp_qos_dev *qdev, union driver_cmd *dcmd)
 	}
 }
 
-#define MAX_FW_CMD_SIZE 120U
+#define MAX_FW_CMD_SIZE sizeof(struct uc_qos_cmd_s)
 #define NUM_OF_POLLS	100000U
 
 /*
@@ -2765,7 +2776,7 @@ void enqueue_cmds(struct pp_qos_dev *qdev)
 
 	if (!internals->ongoing) {
 		common.suspend = 1;
-		for (i = 0; i < internals->suspend_port_index; ++i) {
+		for (i = 0; i < internals->num_suspend_ports; ++i) {
 			prev = cur;
 			QOS_LOG_DEBUG("CMD_INTERNAL_SUSPEND_PORT port: %u\n",
 					internals->suspend_ports[i]);
@@ -2985,11 +2996,23 @@ void enqueue_cmds(struct pp_qos_dev *qdev)
 	}
 
 	if (cmd_queue_is_empty(qdev->drvcmds.cmdq)) {
-		for (i = 0; i < internals->moved_node_index; ++i) {
+		for (i = internals->moved_nodes_index;
+		     i < internals->num_moved_nodes; ++i) {
+			// Verify space for 2 commands (suspend + resume)
+			if (remain < 2 * MAX_FW_CMD_SIZE) {
+				internals->moved_nodes_index = i;
+				QOS_LOG_DEBUG("reentry required: remain %d, move ind %u, num moved %u\n",
+					      remain,
+					      internals->moved_nodes_index,
+					      internals->num_moved_nodes);
+				goto signal_uc;
+			}
+
 			prev = cur;
 			cur = restart_node(qdev,
 					internals->moved_nodes[i].phy,
 					cur,
+					&prev,
 					&cmd_internal);
 			if (cur != prev) {
 				pushed += 2;
@@ -2997,8 +3020,10 @@ void enqueue_cmds(struct pp_qos_dev *qdev)
 			}
 		}
 
+		internals->moved_nodes_index = i;
 		common.suspend = 0;
-		for (i = 0; i < internals->suspend_port_index; ++i) {
+		for (i = internals->suspend_ports_index;
+		     i < internals->num_suspend_ports; ++i) {
 			/* In case port was suspended, and it was removed,
 			 * don't Resume it (Otherwise driver and fw will be
 			 * out of sync) */
@@ -3007,6 +3032,16 @@ void enqueue_cmds(struct pp_qos_dev *qdev)
 			if (!QOS_ID_VALID(id))
 				continue;
 
+			// Verify space for resume command
+			if (remain < MAX_FW_CMD_SIZE) {
+				internals->suspend_ports_index = i;
+				QOS_LOG_DEBUG("reentry required: remain %d, suspend ind %u, num suspend %u\n",
+					      remain,
+					      internals->suspend_ports_index,
+					      internals->num_suspend_ports);
+				goto signal_uc;
+			}
+
 			prev = cur;
 			QOS_LOG_DEBUG("CMD_INTERNAL_UPDATE_PORT_TREE port:%u\n",
 					internals->suspend_ports[i]);
@@ -3067,11 +3102,15 @@ void enqueue_cmds(struct pp_qos_dev *qdev)
 				remain -= (uintptr_t)cur - (uintptr_t)prev;
 			}
 		}
-		internals->suspend_port_index = 0;
-		internals->moved_node_index = 0;
+		/* No pending suspended ports/moving nodes - Reset counters */
+		internals->suspend_ports_index = 0;
+		internals->num_suspend_ports = 0;
+		internals->moved_nodes_index = 0;
+		internals->num_moved_nodes = 0;
 		internals->ongoing = 0;
 	}
 
+signal_uc:
 	if (pushed) {
 		internals->pushed = pushed;
 		prev += 1;
diff --git a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_linux.c b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_linux.c
index fac51cc05535..71e0bcf08922 100644
--- a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_linux.c
+++ b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_linux.c
@@ -1,7 +1,7 @@
 /*
  * GPL LICENSE SUMMARY
  *
- *  Copyright(c) 2017 Intel Corporation.
+ *  Copyright(c) 2017-2019 Intel Corporation.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of version 2 of the GNU General Public License as
@@ -47,9 +47,8 @@
  */
 struct device *cur_dev;
 
-#define PPV4_QOS_CMD_BUF_SIZE (0x4000)
-#define PPV4_QOS_CMD_BUF_OFFSET (0x4000U)
-#define MAX_CMD_SIZE 200
+#define PPV4_QOS_CMD_BUF_SIZE	(0x1000)
+#define PPV4_QOS_CMD_BUF_OFFSET	(0x4000U)
 
 void stop_run(void)
 {
diff --git a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c
index b9d43f82e266..5e3b7a976542 100644
--- a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c
+++ b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c
@@ -1,7 +1,7 @@
 /*
  * GPL LICENSE SUMMARY
  *
- *  Copyright(c) 2017 Intel Corporation.
+ *  Copyright(c) 2017-2019 Intel Corporation.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of version 2 of the GNU General Public License as
@@ -38,10 +38,13 @@ void update_cmd_id(struct driver_cmds *drvcmds)
 	drvcmds->cmd_fw_id = 0;
 }
 
+int is_ongoing(struct pp_qos_dev *qdev);
+
 void transmit_cmds(struct pp_qos_dev *qdev)
 {
-
-	while (!cmd_queue_is_empty(qdev->drvcmds.cmdq)) {
+	/* Handle commands in case there are commands in queue or in case
+	   ports were suspended and need to be resumed again */
+	while (!cmd_queue_is_empty(qdev->drvcmds.cmdq) || (is_ongoing(qdev))) {
 		enqueue_cmds(qdev);
 		check_completion(qdev);
 	}
diff --git a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_uc_defs.h b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_uc_defs.h
index 985e9fadf4f8..38c5685953a9 100644
--- a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_uc_defs.h
+++ b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_uc_defs.h
@@ -1,7 +1,7 @@
 /*
  * GPL LICENSE SUMMARY
  *
- *  Copyright(c) 2017 Intel Corporation.
+ *  Copyright(c) 2017-2019 Intel Corporation.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of version 2 of the GNU General Public License as
@@ -529,6 +529,7 @@ enum uc_qos_command {
 	UC_QOS_COMMAND_UPDATE_PORT_TREE,
 };
 
+#define UC_MAX_PARAMS	(30)
 /**************************************************************************
  *! @struct	uc_qos_cmd_s
  **************************************************************************
@@ -554,32 +555,7 @@ struct uc_qos_cmd_s {
 	/* must be synced between the host and uc! */
 	u32			num_params;
 
-	u32			param0;
-	u32			param1;
-	u32			param2;
-	u32			param3;
-	u32			param4;
-	u32			param5;
-	u32			param6;
-	u32			param7;
-	u32			param8;
-	u32			param9;
-	u32			param10;
-	u32			param11;
-	u32			param12;
-	u32			param13;
-	u32			param14;
-	u32			param15;
-	u32			param16;
-	u32			param17;
-	u32			param18;
-	u32			param19;
-	u32			param20;
-	u32			param21;
-	u32			param22;
-	u32			param23;
-	u32			param24;
-	u32			param25;
+	u32			param[UC_MAX_PARAMS];
 };
 
 #endif /* SRC_UC_HOST_DEFS_H_ */
