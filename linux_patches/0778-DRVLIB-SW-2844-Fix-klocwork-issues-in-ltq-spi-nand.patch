From f4c592262b545d5b1b124ab4d5d6d5b74e17e0b0 Mon Sep 17 00:00:00 2001
From: Peter Harliman Liem <peter.harliman.liem@intel.com>
Date: Mon, 9 Sep 2019 14:21:28 +0800
Subject: [PATCH] DRVLIB_SW-2844 - Fix klocwork issues in ltq-spi-nand

- Remove NOTIMEOUT as this could cause infinite hang
- Fix some error path handling
---
 drivers/mtd/ltq-spinand/ltq_spinand.c | 30 ++++++------------------------
 1 file changed, 6 insertions(+), 24 deletions(-)

diff --git a/drivers/mtd/ltq-spinand/ltq_spinand.c b/drivers/mtd/ltq-spinand/ltq_spinand.c
index 8076ceda7151..5870ebf547f0 100644
--- a/drivers/mtd/ltq-spinand/ltq_spinand.c
+++ b/drivers/mtd/ltq-spinand/ltq_spinand.c
@@ -34,11 +34,6 @@
  ******************************************************************************/
 #define NONANDSUBPAGEREAD
 
-/*******************************************************************************
- * No timeout while waiting for SPI NAND chip status to be ready
- ******************************************************************************/
-#define NOTIMEOUT
-
 /*============================================================================*/
 /* Global Vars */
 /*============================================================================*/
@@ -518,23 +513,7 @@ static int wait_till_ready(struct spi_device *spi)
 {
 	int retval;
 	u8 stat = 0;
-#ifndef NOTIMEOUT
 	unsigned long deadline;
-#endif
-
-#ifdef NOTIMEOUT
-
-	do {
-		retval = spinand_read_status(spi, &stat);
-		if (retval < 0)
-			return -1;
-		else if (!(stat & 0x1))
-			break;
-
-		cond_resched();
-	} while (1);
-
-#else /* NOTIMEOUT */
 
 	deadline = jiffies + msecs_to_jiffies(MAX_WAIT_MS);
 	do {
@@ -547,8 +526,6 @@ static int wait_till_ready(struct spi_device *spi)
 		cond_resched();
 	} while (!time_after_eq(jiffies, deadline));
 
-#endif /* NOTIMEOUT */
-
 	if ((stat & 0x1) == 0)
 		return 0;
 
@@ -1153,6 +1130,9 @@ static int spinand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
 
 	while (1) {
 		retval = spinand_read_status(info->spi, &status);
+		if (retval < 0)
+			return retval;
+
 		if ((status & STATUS_OIP_MASK) == STATUS_READY) {
 			spinand_ecc_status(info->spi, status, &ecc_error);
 			break;
@@ -1220,12 +1200,14 @@ static int spinand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 
 	while (time_before(jiffies, timeo)) {
 		retval = spinand_read_status(info->spi, &status);
+		if (retval < 0)
+			break;
 		if ((status & STATUS_OIP_MASK) == STATUS_READY)
 			return 0;
 
 		cond_resched();
 	}
-	return 0;
+	return NAND_STATUS_FAIL;
 }
 
 /**
