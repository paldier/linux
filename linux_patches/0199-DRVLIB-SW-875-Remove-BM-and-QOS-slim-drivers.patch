From 2639add3b5273b5ad1b50bc03fa98c7dd7542560 Mon Sep 17 00:00:00 2001
From: kavitha3 <k.subramanian@intel.com>
Date: Tue, 14 Aug 2018 12:13:27 +0800
Subject: [PATCH] DRVLIB_SW-875:Remove BM and QOS slim drivers

---
 drivers/net/ethernet/lantiq/cqm/falconmx/cqm.c     |   3 -
 .../net/ethernet/lantiq/cqm/falconmx/cqm_config.h  |   4 -
 drivers/net/ethernet/lantiq/ppv4/Kconfig           |  12 -
 drivers/net/ethernet/lantiq/ppv4/Makefile          |   6 -
 drivers/net/ethernet/lantiq/ppv4/bm_drv_slim.c     | 562 ---------------------
 drivers/net/ethernet/lantiq/ppv4/qos_drv_slim.c    | 488 ------------------
 include/net/bm_drv_slim.h                          | 401 ---------------
 include/net/pp_qos_drv_slim.h                      | 305 -----------
 8 files changed, 1781 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/cqm/falconmx/cqm.c b/drivers/net/ethernet/lantiq/cqm/falconmx/cqm.c
index 26201f354abd..336d32b73985 100644
--- a/drivers/net/ethernet/lantiq/cqm/falconmx/cqm.c
+++ b/drivers/net/ethernet/lantiq/cqm/falconmx/cqm.c
@@ -2939,9 +2939,6 @@ static int bm_init(struct platform_device *pdev)
 	for (j = 0; j < CQM_FMX_NUM_BM_POLICY; j++)
 		bmgr_policy_configure(&p_param[j], &i);
 
-#ifdef CONFIG_LTQ_PPV4_BM_SLIM
-	new_init_bm();
-#endif
 	return CBM_SUCCESS;
 }
 
diff --git a/drivers/net/ethernet/lantiq/cqm/falconmx/cqm_config.h b/drivers/net/ethernet/lantiq/cqm/falconmx/cqm_config.h
index 3c7160c0de01..d2307f74380f 100644
--- a/drivers/net/ethernet/lantiq/cqm/falconmx/cqm_config.h
+++ b/drivers/net/ethernet/lantiq/cqm/falconmx/cqm_config.h
@@ -1,11 +1,7 @@
 #ifndef __CQM_CONFIG_H__
 #define __CQM_CONFIG_H__
 
-#ifdef CONFIG_LTQ_PPV4_BM_SLIM
-#include <net/bm_drv_slim.h>
-#else
 #include "../../ppv4/bm/pp_bm_drv.h"
-#endif
 
 #define CQM_FMX_NUM_BM_POOLS	4
 #define CQM_FMX_NUM_POOLS	(CQM_FMX_NUM_BM_POOLS + 1)
diff --git a/drivers/net/ethernet/lantiq/ppv4/Kconfig b/drivers/net/ethernet/lantiq/ppv4/Kconfig
index ad99d326d1cf..36a913bfc644 100644
--- a/drivers/net/ethernet/lantiq/ppv4/Kconfig
+++ b/drivers/net/ethernet/lantiq/ppv4/Kconfig
@@ -11,12 +11,6 @@ config LTQ_PPV4
 	present in the FALCONMX series of SoCs to manage the network buffers
 	in HW.
 
-# fallback if full driver is not included
-config LTQ_PPV4_QOS_SLIM
-	bool
-	depends on LTQ_PPV4 && !LTQ_PPV4_QOS
-	default y
-
 config LTQ_PPV4_QOS
 	tristate "QoS driver"
 	depends on LTQ_PPV4
@@ -30,12 +24,6 @@ config LTQ_PPV4_QOS_TEST
 	bool "Enable test code for QoS driver"
 	depends on LTQ_PPV4_QOS
 
-
-config LTQ_PPV4_BM_SLIM
-	bool
-	depends on LTQ_PPV4 && !LTQ_PPV4_BM
-	default y
-
 config LTQ_PPV4_BM
 	tristate "BM driver"
 	depends on LTQ_PPV4
diff --git a/drivers/net/ethernet/lantiq/ppv4/Makefile b/drivers/net/ethernet/lantiq/ppv4/Makefile
index 54a712a5f072..0a2491e15a45 100644
--- a/drivers/net/ethernet/lantiq/ppv4/Makefile
+++ b/drivers/net/ethernet/lantiq/ppv4/Makefile
@@ -2,12 +2,6 @@
 # Makefile for BM and QoS drivers.
 #
 
-# initial small drivers
-#obj-$(CONFIG_LTQ_PPV4) += bm_drv_slim.o
-obj-$(CONFIG_LTQ_PPV4_BM_SLIM) += bm_drv_slim.o
-obj-$(CONFIG_LTQ_PPV4_QOS_SLIM) += qos_drv_slim.o
-
 # full drivers
 obj-$(CONFIG_LTQ_PPV4_QOS) += qos/
-#obj-$(CONFIG_LTQ_PPV4) += bm/
 obj-$(CONFIG_LTQ_PPV4_BM) += bm/
diff --git a/drivers/net/ethernet/lantiq/ppv4/bm_drv_slim.c b/drivers/net/ethernet/lantiq/ppv4/bm_drv_slim.c
deleted file mode 100644
index 65f4dc43d018..000000000000
--- a/drivers/net/ethernet/lantiq/ppv4/bm_drv_slim.c
+++ /dev/null
@@ -1,562 +0,0 @@
-/*
- *	driver:		buffer_manager platform device driver
- *	@file		bmgr_drv.c
- *	@brief:		Interim ppv4 buffer manager driver
- *	 	based on register configuration given by SOC verification team
- *	@author:	Kavitha
- *	@date:		25/08/2017
- */
-
-#include <linux/platform_device.h>
-#include <linux/netdevice.h>
-#include <linux/inetdevice.h>
-#include <linux/device.h>
-#include <linux/inetdevice.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/bitops.h>
-#include <linux/byteorder/generic.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/types.h>
-#include <linux/list.h>
-#include <linux/spinlock.h>
-#include <linux/pid.h>
-#include <linux/pid_namespace.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <lantiq.h>
-#include <lantiq_soc.h>
-#include <net/pp_bm_regs.h>
-#include <net/bm_drv_slim.h>
-
-
-#define BM_CHIPTEST_DRIVER
-//#undef BM_CHIPTEST_DRIVER
-
-#ifdef BM_CHIPTEST_DRIVER
-#define xrx500_bm_r32(m_reg) 0
-#define xrx500_bm_w32(m_reg, val)
-#define xrx500_bm_w32_mask(m, clear, set, reg)
-#define set_val_bm(reg, val, mask, offset)
-#else
-#define xrx500_bm_r32(m_reg)		__raw_readl(m_reg)
-#define xrx500_bm_w32(m_reg, val)	__raw_writel(val, m_reg)
-#define xrx500_bm_w32_mask(m, clear, set, reg) \
-		ltq_w32((ltq_r32((m) + (reg)) & ~(clear)) | (set), \
-		(m) + (reg))
-
-#define set_val_bm(reg, val, mask, offset) \
-do {\
-	xrx500_bm_w32(reg, xrx500_bm_r32(reg) & ~(mask));\
-	xrx500_bm_w32(reg, xrx500_bm_r32(reg)\
-	| (((val) << (offset)) & (mask)));\
-} while (0)
-
-#endif
-
-void __iomem *bm_config_addr_base;
-void __iomem *bm_policy_mngr_addr_base;
-
-#define BM_BASE	(bm_config_addr_base)
-#define BM_RAM_BASE	(bm_policy_mngr_addr_base)
-
-void*	pointers_table[PP_BMGR_MAX_POOLS] = {NULL};
-void*	pointers_table_1 = NULL;
-void*	pointers_table_2 = NULL;
-void*	pointers_table_3 = NULL;
-u32*	temp_pointers_table_ptr = NULL;
-u32	user_array_ptr;
-#define num_buf 128
-struct device *g_bm_dev;
-
-void* CONFIG_CQEM_BUF_BASE[PP_BMGR_MAX_POOLS];
-void* CONFIG_CQEM_BUF_LLK_BASE[PP_BMGR_MAX_POOLS];
-#define CQEM_FORCE_COUNT_NUM 0x80
-
-static void buf_addr_adjust(unsigned int buf_base_addr,
-		     unsigned int buf_size,
-		     unsigned int *adjusted_buf_base,
-		     unsigned int *adjusted_buf_size,
-		     unsigned int align)
-{
-	unsigned int base;
-	unsigned int size;
-	base = ALIGN(buf_base_addr, align);
-	size = buf_base_addr + buf_size - base;
-
-	*adjusted_buf_base = base;
-	*adjusted_buf_size = size;
-}
-
-
-
-static void qose_reg_rd_poll (void * reg, uint32_t val, uint32_t offset)
-{
-#ifndef BM_CHIPTEST_DRIVER
-	uint32_t tmpreg;
-
-	while (1) {
-		tmpreg = xrx500_bm_r32(reg) & (1 << offset);
-		if (tmpreg == (val << offset))
-			break;
-	}
-#endif
-}
-
-#ifdef BM_CHIPTEST_DRIVER
-static void qose_reg_rd_poll_2 (void * reg, uint32_t val, uint32_t offset)
-{
-	uint32_t tmpreg;
-
-	while (1) {
-		tmpreg = xrx500_bm_r32(reg) & (1 << offset);
-		if (tmpreg == (val << offset))
-			break;
-	}
-}
-#endif
-
-s32 bmgr_pool_configure(const struct bmgr_pool_params* const pool_params, u8* const pool_id)
-{
-	
-	int index;
-	int adjusted_size;
-	u32 phy_ll_base;
-	u32 reg;
-	int l_pool_id = (int)*pool_id;
-	void* bm_buf_llk_base;
-	void* bm_buf_llk_base_adjust;
-	dma_addr_t dma_handle;
-
-	pr_info("Configuring buffer manager pool..%d\n", l_pool_id);
-
-	pointers_table[l_pool_id] = kzalloc(sizeof(u32) * (pool_params->num_buffers + 64), GFP_KERNEL);
-	buf_addr_adjust((u32)pointers_table[l_pool_id],
-			sizeof(u32) * (pool_params->num_buffers + 64),
-			(u32 *)&pointers_table[l_pool_id],
-			&adjusted_size,
-			64);
-	if (pointers_table[l_pool_id] == NULL) {
-		pr_info("bmgr_pool_configure: Failed to allocate pointers_table, num_buffers %d", pool_params->num_buffers);
-		return -1;
-	}
-	temp_pointers_table_ptr = (u32 *)pointers_table[l_pool_id];
-	user_array_ptr = pool_params->base_addr_low;
-	for (index = 0; index < pool_params->num_buffers; index++) {
-		*temp_pointers_table_ptr = user_array_ptr >> 6;
-		temp_pointers_table_ptr++;
-		user_array_ptr += pool_params->size_of_buffer;
-	}
-	phy_ll_base = dma_map_single(g_bm_dev, (void *)pointers_table[l_pool_id],
-				      (pool_params->num_buffers * 4), DMA_TO_DEVICE);
-
-	CONFIG_CQEM_BUF_BASE[l_pool_id] = (void*) pool_params->base_addr_low;
-	bm_buf_llk_base = dma_alloc_attrs(g_bm_dev, sizeof(u32) * (pool_params->num_buffers + 64),
-					  &dma_handle,
-					  GFP_KERNEL,
-					  0);
-
-	if (!bm_buf_llk_base) {
-		pr_err("Error in pool %d linklist allocation\n", l_pool_id);
-		return -1;
-	}
-	buf_addr_adjust(bm_buf_llk_base,
-			sizeof(u32) * (pool_params->num_buffers + 64),
-			(u32 *)&bm_buf_llk_base_adjust, &adjusted_size,
-			64);
-
-	if (bm_buf_llk_base_adjust > bm_buf_llk_base)
-		CONFIG_CQEM_BUF_LLK_BASE[l_pool_id] = dma_handle + (bm_buf_llk_base_adjust - bm_buf_llk_base);
-	else
-		CONFIG_CQEM_BUF_LLK_BASE[l_pool_id] = dma_handle - (bm_buf_llk_base - bm_buf_llk_base_adjust);
-
-	xrx500_bm_w32(BMGR_POOL_SIZE_REG_ADDR(BM_BASE, l_pool_id), pool_params->num_buffers);
-	xrx500_bm_w32(BMGR_POOL_EXT_FIFO_OCC_REG_ADDR(BM_BASE, l_pool_id), pool_params->num_buffers);
-	xrx500_bm_w32(BMGR_POOL_EXT_FIFO_BASE_ADDR_LOW_REG_ADDR(BM_BASE, l_pool_id), phy_ll_base);
-	xrx500_bm_w32(BMGR_POOL_EXT_FIFO_BASE_ADDR_HIGH_REG_ADDR(BM_BASE, l_pool_id), 0x00000000);
-	reg = xrx500_bm_r32(BMGR_GROUP_AVAILABLE_BUFF_REG_ADDR(BM_BASE, pool_params->group_id));
-	xrx500_bm_w32(BMGR_GROUP_AVAILABLE_BUFF_REG_ADDR(BM_BASE, pool_params->group_id), reg + pool_params->num_buffers);
-	xrx500_bm_w32(BMGR_POOL_PCU_FIFO_BASE_ADDR_REG_ADDR(BM_BASE, l_pool_id),
-		BMGR_START_PCU_FIFO_SRAM_ADDR + ((l_pool_id + 1) * BMGR_DEFAULT_PCU_FIFO_SIZE));
-	xrx500_bm_w32(BMGR_POOL_PCU_FIFO_SIZE_REG_ADDR(BM_BASE, l_pool_id), 0x40);
-
-#if 0
-	status = bmgr_set_pcu_fifo_occupancy(l_pool_id, BMGR_DEFAULT_PCU_FIFO_SIZE);
-	if (status != PP_RC_SUCCESS) {
-		goto free_memory;
-	}
-#endif
-	xrx500_bm_w32(BMGR_POOL_PCU_FIFO_PROG_EMPTY_REG_ADDR(BM_BASE, l_pool_id), BMGR_DEFAULT_PCU_FIFO_LOW_THRESHOLD);
-	xrx500_bm_w32(BMGR_POOL_PCU_FIFO_PROG_FULL_REG_ADDR(BM_BASE, l_pool_id), 0x30);
-	xrx500_bm_w32(BMGR_POOL_WATERMARK_LOW_THRESHOLD_REG_ADDR(BM_BASE, l_pool_id), 0x90);
-	if (pool_params->flags & POOL_ENABLE_FOR_MIN_GRNT_POLICY_CALC) {
-		set_val_bm(BMGR_POOL_MIN_GRNT_MASK_REG_ADDR(BM_BASE), 1, (1 << l_pool_id), l_pool_id);
-	}
-
-	if (l_pool_id == 3) {
-		xrx500_bm_w32(BMGR_POOL_ENABLE_REG_ADDR(BM_BASE), 0x000f000f);
-		xrx500_bm_w32(BMGR_CTRL_REG_ADDR(BM_BASE), 0x00000001);
-		xrx500_bm_w32(BMGR_POOL_FIFO_RESET_REG_ADDR(BM_BASE), 0x0000fff0);
-		qose_reg_rd_poll(BMGR_STATUS_REG_ADDR(BM_BASE), 0x0, 0x00);
-	}
-	pr_info("pool %d Done\n", l_pool_id);
-	return 0;
-}
-
-s32 bmgr_policy_configure(const struct bmgr_policy_params* const policy_params, u8* const policy_id)
-{
-	int policy = *policy_id;
-	pr_info("Configuring buffer manager policy..%d\n", policy);
-
-	xrx500_bm_w32(BMGR_POLICY_GROUP_ASSOCIATED_ADDR(BM_RAM_BASE,policy), policy_params->group_id);
-
-	xrx500_bm_w32(BMGR_POLICY_MAX_ALLOWED_ADDR(BM_RAM_BASE,policy), policy_params->max_allowed);
-	xrx500_bm_w32(BMGR_POLICY_MIN_GUARANTEED_ADDR(BM_RAM_BASE,policy), policy_params->min_guaranteed);
-	// Set the group's reserved buffers
-	xrx500_bm_w32(BMGR_GROUP_RESERVED_BUFF_REG_ADDR(BM_BASE, policy_params->group_id), 0x00000100);
-
-	/*for (index = 0; index < policy_params->num_pools_in_policy; index++) {
-		xrx500_bm_w32(
-			BMGR_POLICY_MAX_ALLOWED_PER_POOL_ADDR(BM_RAM_BASE, policy, policy_params->pools_in_policy[index].pool_id)
-			, policy_params->pools_in_policy[index].max_allowed);
-	}*/
-	xrx500_bm_w32(BM_RAM_BASE + 0x4000, 0x00000080);//DONE
-	xrx500_bm_w32(BM_RAM_BASE + 0x4008, 0x00000080);
-	xrx500_bm_w32(BM_RAM_BASE + 0x4004, 0x00000080);
-	xrx500_bm_w32(BM_RAM_BASE + 0x400c, 0x00000080);
-	xrx500_bm_w32(BM_RAM_BASE + 0x500c, 0x00000080);
-	xrx500_bm_w32(BM_RAM_BASE + 0x5000, 0x00000080);
-	xrx500_bm_w32(BM_RAM_BASE + 0x5008, 0x00000080);
-	xrx500_bm_w32(BM_RAM_BASE + 0x5004, 0x00000080);
-	xrx500_bm_w32(BM_RAM_BASE + 0x600c, 0x00000080);
-	xrx500_bm_w32(BM_RAM_BASE + 0x6000, 0x00000080);
-	xrx500_bm_w32(BM_RAM_BASE + 0x6008, 0x00000080);
-	xrx500_bm_w32(BM_RAM_BASE + 0x6004, 0x00000080);
-	xrx500_bm_w32(BM_RAM_BASE + 0x700c, 0x00000080);
-	xrx500_bm_w32(BM_RAM_BASE + 0x7000, 0x00000080);
-	xrx500_bm_w32(BM_RAM_BASE + 0x7008, 0x00000080);
-	xrx500_bm_w32(BM_RAM_BASE + 0x7004, 0x00000080);
-	xrx500_bm_w32(BM_RAM_BASE + 0x700c, 0x00000080);
-
-	
-	xrx500_bm_w32(
-		BMGR_POLICY_POOLS_MAPPING_ADDR(BM_RAM_BASE, 0)
-		, 0x03020100);
-	xrx500_bm_w32(
-		BMGR_POLICY_POOLS_MAPPING_ADDR(BM_RAM_BASE, 1)
-		, 0x00030201);
-	xrx500_bm_w32(
-		BMGR_POLICY_POOLS_MAPPING_ADDR(BM_RAM_BASE, 2)
-		, 0x00000302);
-
-	xrx500_bm_w32(
-		BMGR_POLICY_POOLS_MAPPING_ADDR(BM_RAM_BASE, 3)
-		, 0x00000003);
-
-	qose_reg_rd_poll(BMGR_STATUS_REG_ADDR(BM_BASE), 0x0, 0x00);
-
-
-	pr_info("Policy Done\n");
-	return 0;
-
-
-}
-
-s32 bmgr_driver_init(void)
-{
-	pr_info("Buffer Manager driver is initializing....");
-	xrx500_bm_w32(BMGR_CTRL_REG_ADDR(BM_BASE), 0x1); // Buffer manager client enable
-	// OCP Master burst size
-	xrx500_bm_w32(BMGR_OCPM_BURST_SIZE_REG_ADDR(BM_BASE), 0x48);
-	// OCP Master number of bursts
-	xrx500_bm_w32(BMGR_OCPM_NUM_OF_BURSTS_REG_ADDR(BM_BASE), 0x33); // 1 burst for all pools
-	pr_info("Done\n");
-	return 0;
-}
-
-#define REG32(addr) (*((volatile uint32_t*)(addr)))
-void qose_reg_wr(uint32_t reg, uint32_t val)
-{
-        REG32(KSEG1ADDR(reg)) = val;
-}
-
-/**************************************************************************
- *! \fn	buffer_manager_probe
- **************************************************************************
- *
- *  \brief	probe platform device hook
- * 
- *  \param	pdev:	platform device pointer
- *
- *  \return	0 on success, other error code on failure
- *
- **************************************************************************/
-static int buffer_manager_probe(struct platform_device *pdev)
-{
-	
-	struct resource *res[2];
-	int i;
-	g_bm_dev = &pdev->dev;
-#if 1
-	/* load the memory ranges */
-	for (i = 0; i < 2; i++) {
-		res[i] = platform_get_resource(pdev, IORESOURCE_MEM, i);
-		if (!res[i]) {
-			pr_err("failed to get resources %d\n", i);
-			return -ENOENT;
-		}
-	}
-#endif
-
-
-	bm_config_addr_base = devm_ioremap_resource(&pdev->dev, res[0]);
-	bm_policy_mngr_addr_base = devm_ioremap_resource(&pdev->dev, res[1]);
-
-	if (!bm_config_addr_base || !bm_policy_mngr_addr_base) {
-		pr_err("failed to request and remap io ranges\n");
-		return -ENOMEM;
-	}
-	return 0;
-}
-
-#ifndef BM_CHIPTEST_DRIVER
-void new_init_bm()
-{
-	return;
-}
-#else
-void new_init_bm()
-{
-	uint32_t * base, *base_org;
-	uint32_t count, i, val, val_org;
-
-	qose_reg_wr(0x18b10000, 0x00000280);
-	qose_reg_wr(0x18b10008, 0x00000280);
-	qose_reg_wr(0x18b10004, 0x00000280);
-	qose_reg_wr(0x18b1000c, 0x00000280);
-	qose_reg_wr(0x18b11000, 0x00000040);
-	qose_reg_wr(0x18b11008, 0x00000040);
-	qose_reg_wr(0x18b11004, 0x00000040);
-	qose_reg_wr(0x18b1100c, 0x00000040);
-	qose_reg_wr(0x18b14000, 0x00000080);
-	qose_reg_wr(0x18b14008, 0x00000080);
-	qose_reg_wr(0x18b14004, 0x00000080);
-	qose_reg_wr(0x18b1400c, 0x00000080);
-	qose_reg_wr(0x18b1500c, 0x00000080);
-	qose_reg_wr(0x18b15000, 0x00000080);
-	qose_reg_wr(0x18b15008, 0x00000080);
-	qose_reg_wr(0x18b15004, 0x00000080);
-	qose_reg_wr(0x18b1600c, 0x00000080);
-	qose_reg_wr(0x18b16000, 0x00000080);
-	qose_reg_wr(0x18b16008, 0x00000080);
-	qose_reg_wr(0x18b16004, 0x00000080);
-	qose_reg_wr(0x18b1700c, 0x00000080);
-	qose_reg_wr(0x18b17000, 0x00000080);
-	qose_reg_wr(0x18b17008, 0x00000080);
-	qose_reg_wr(0x18b17004, 0x00000080);
-	qose_reg_wr(0x18b1700c, 0x00000080);
-	qose_reg_wr(0x18b12000, 0x00000000);
-	qose_reg_wr(0x18b12008, 0x00000000);
-	qose_reg_wr(0x18b12004, 0x00000000);
-	qose_reg_wr(0x18b1200c, 0x00000000);
-	#if 1
-	qose_reg_wr(0x18b13000, 0x03020100);
-	qose_reg_wr(0x18b13004, 0x00030201);
-	qose_reg_wr(0x18b13008, 0x00000302);
-	qose_reg_wr(0x18b1300c, 0x00000003);
-	#else
-	qose_reg_wr(0x18b13000, 0x00000000);
-	qose_reg_wr(0x18b13004, 0x00000001);
-	qose_reg_wr(0x18b13008, 0x00000002);
-	qose_reg_wr(0x18b1300c, 0x00000003);
-	#endif
-	qose_reg_wr(0x18b00004, 0x0000000e);
-	qose_reg_wr(0x18b00020, 0x00000080);
-	qose_reg_wr(0x18b005c0, 0x00000080);
-	qose_reg_wr(0x18b00024, 0x00000080);
-	qose_reg_wr(0x18b005c4, 0x00000080);
-	qose_reg_wr(0x18b00028, 0x00000080);
-	qose_reg_wr(0x18b005c8, 0x00000080);
-	qose_reg_wr(0x18b0002c, 0x00000080);
-	qose_reg_wr(0x18b005cc, 0x00000080);
-	qose_reg_wr(0x18b00100, 0x00000400);
-	qose_reg_wr(0x18b00200, 0x00000100);
-	qose_reg_wr(0x18b00440, 0x00000040);
-	qose_reg_wr(0x18b004c0, 0x00000001);
-	qose_reg_wr(0x18b00500, 0x00000030);
-	//qose_reg_wr(0x18b00540, 0x20000000);
-
-	base = (void *)CONFIG_CQEM_BUF_LLK_BASE[0];
-	base_org = base;
-	val = (uint32_t) CONFIG_CQEM_BUF_BASE[0];
-
-	val = val & 0xFFFFFF80;
-	val_org = val;
-
-	count = CQEM_FORCE_COUNT_NUM;
-
-	for (i = 0; i < count; i ++) {
-		REG32(KSEG1ADDR(base)) = (val_org + i * 2048) >> 6 ;
-		base++;
-	}
-
-	pr_info("init bm size 0 llk base 0x%x last llk base 0x%x first val 0x%x last val 0x%x count 0x%x\n",
-		 (unsigned int)base_org, (unsigned int)base, val_org, (val_org + i * 2048), count);
-
-	qose_reg_wr(0x18b00540, (uint32_t) base_org);
-	qose_reg_wr(0x18b00580, 0x00000000);
-	qose_reg_wr(0x18b00400, 0x00000080);
-	qose_reg_wr(0x18b00444, 0x00000040);
-	qose_reg_wr(0x18b004c4, 0x00000018);
-	qose_reg_wr(0x18b00504, 0x0000002c);
-	//qose_reg_wr(0x18b00544, 0x20040000);
-
-
-	base = (void *)CONFIG_CQEM_BUF_LLK_BASE[1];
-	base_org = base;
-	val = CONFIG_CQEM_BUF_BASE[1];
-	val = val & 0xFFFFFF80;
-	val_org = val;
-	count = CQEM_FORCE_COUNT_NUM;
-
-	for (i = 0; i < count; i ++) {
-		REG32(KSEG1ADDR(base)) = (val_org + i * 2048) >> 6 ;
-		base++;
-	}
-
-	pr_info("init bm size 1 llk base 0x%x last llk base 0x%x first val 0x%x last val 0x%x count 0x%x\n",
-		(unsigned int)base_org, (unsigned int)base, val_org, (val_org + i * 2048), count);
-	qose_reg_wr(0x18b00544,  (uint32_t) base_org);
-
-	qose_reg_wr(0x18b00584, 0x00000000);
-	qose_reg_wr(0x18b00404, 0x00000100);
-	qose_reg_wr(0x18b00448, 0x00000040);
-	qose_reg_wr(0x18b004c8, 0x00000001);
-	qose_reg_wr(0x18b00508, 0x00000020);
-	//qose_reg_wr(0x18b00548, 0x20080000);
-
-	base = (void *)CONFIG_CQEM_BUF_LLK_BASE[2];
-	base_org = base;
-	val = CONFIG_CQEM_BUF_BASE[2];
-	val = val & 0xFFFFFF80;
-	val_org = val;
-	count = CQEM_FORCE_COUNT_NUM;
-
-	for (i = 0; i < count; i ++) {
-		REG32(KSEG1ADDR(base)) = (val_org + i * 2048) >> 6 ;
-		base++;
-	}
-
-	pr_info("init bm size 2 llk base 0x%x last llk base 0x%x first val 0x%x last val 0x%x count 0x%x\n",
-		(unsigned int)base_org, (unsigned int)base, val_org, (val_org + i * 2048), count);
-	qose_reg_wr(0x18b00548, (uint32_t) base_org);
-
-	qose_reg_wr(0x18b00588, 0x00000000);
-	qose_reg_wr(0x18b00408, 0x00000180);
-	qose_reg_wr(0x18b0044c, 0x00000040);
-	qose_reg_wr(0x18b004cc, 0x0000000f);
-	qose_reg_wr(0x18b0050c, 0x00000030);
-	//qose_reg_wr(0x18b0054c, 0x200c0000);
-
-        base = (void *)CONFIG_CQEM_BUF_LLK_BASE[3];
-        base_org = base;
-        val = CONFIG_CQEM_BUF_BASE[3];
-        val = val & 0xFFFFFF80;
-        val_org = val;
-	count = CQEM_FORCE_COUNT_NUM;
-	for (i = 0; i < count; i ++) {
-		REG32(KSEG1ADDR(base)) = (val_org + i * 2048) >> 6 ;
-		base++;
-	}
-
-	pr_info("init bm size 3 llk base 0x%x last llk base 0x%x first val 0x%x last val 0x%x count 0x%x\n",
-		(unsigned int)base_org, (unsigned int)base, val_org, (val_org + i * 2048) , count);
-	qose_reg_wr(0x18b0054c, (uint32_t) base_org);
-
-	qose_reg_wr(0x18b0058c, 0x00000000);
-	qose_reg_wr(0x18b0040c, 0x00000200);
-	qose_reg_wr(0x18b00014, 0x00000033);
-	qose_reg_wr(0x18b00010, 0x00000048);
-	qose_reg_wr(0x18b00740, 0x00000090);
-	qose_reg_wr(0x18b00744, 0x00000090);
-	qose_reg_wr(0x18b00748, 0x00000090);
-	qose_reg_wr(0x18b0074c, 0x00000090);
-	qose_reg_wr(0x18b00000, 0x00000001);
-	qose_reg_wr(0x18b0000c, 0x0000fff0);
-	qose_reg_wr(0x18b00008, 0x000f000f);
-	qose_reg_rd_poll_2(0x18b00018, 0x0, 0x00);
-}
-#endif
-/**************************************************************************
- *! \fn	buffer_manager_remove
- **************************************************************************
- *
- *  \brief	probe platform device hook
- * 
- *  \param	pdev:	platform device pointer
- *
- *  \return	0 on success, other error code on failure
- *
- **************************************************************************/
-static int buffer_manager_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static const struct of_device_id bm_match[] = {
-	{ .compatible = "intel,falconmx-bm" },
-	{},
-};
-
-static struct platform_driver	g_buffer_manager_platform_driver = {
-	.driver = { .name = "buffer_manager", .of_match_table = bm_match,},
-	.probe = buffer_manager_probe,
-	.remove = buffer_manager_remove,
-};
-
-/**************************************************************************
- *! \fn	buffer_manager_driver_init
- **************************************************************************
- *
- *  \brief	Init platform device driver
- * 
- *  \return	0 on success, other error code on failure
- *
- **************************************************************************/
-static int __init buffer_manager_driver_init(void)
-{
-	int ret;
-
-	ret = platform_driver_register(&g_buffer_manager_platform_driver);
-	if (ret < 0) {
-		pr_err("buffer_manager_driver_init(): Failed to register buffer_manager platform driver: %d\n", ret);
-		return ret;
-	}
-	pr_info("buffer_manager_driver_init(): buffer_manager driver init done\n");
-
-	return 0;
-}
-
-/**************************************************************************
- *! \fn	buffer_manager_driver_exit
- **************************************************************************
- *
- *  \brief	Exit platform device driver
- * 
- *  \return	0 on success, other error code on failure
- *
- **************************************************************************/
-static void __exit buffer_manager_driver_exit(void)
-{
-	platform_driver_unregister(&g_buffer_manager_platform_driver);
-
-	pr_info("buffer_manager_driver_exit(): buffer_manager driver exit done\n");
-}
-
-/*************************************************/
-/**		Module Declarations		**/
-/*************************************************/
-arch_initcall(buffer_manager_driver_init);
-module_exit(buffer_manager_driver_exit);
-
diff --git a/drivers/net/ethernet/lantiq/ppv4/qos_drv_slim.c b/drivers/net/ethernet/lantiq/ppv4/qos_drv_slim.c
deleted file mode 100644
index 6eac068ebe75..000000000000
--- a/drivers/net/ethernet/lantiq/ppv4/qos_drv_slim.c
+++ /dev/null
@@ -1,488 +0,0 @@
-#include <linux/platform_device.h>
-#include <linux/netdevice.h>
-#include <linux/inetdevice.h>
-#include <linux/device.h>
-#include <linux/inetdevice.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/bitops.h>
-#include <linux/byteorder/generic.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/types.h>
-#include <linux/list.h>
-#include <linux/spinlock.h>
-#include <linux/pid.h>
-#include <linux/pid_namespace.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <lantiq.h>
-#include <lantiq_soc.h>
-#include <net/bm_drv_slim.h>
-
-#define xrx500_qos_r32(m_reg)		__raw_readl(m_reg)
-#define xrx500_qos_w32(m_reg, val)	__raw_writel(val, m_reg)
-
-/**************************
-*port = 0 t_qid_data = 14 
-*port = 0 t_qid_data = 74 
-*port = 0 t_qid_data = 30 
-*port = 0 t_qid_data = 87 
-*port = 7 t_qid_data = 235 
-*port = 7 t_qid_data = 42 
-*port = 7 t_qid_data = 242 
-*port = 26 t_qid_data = 190 
-*port = 26 t_qid_data = 119 
-*port = 26 t_qid_data = 103 
-****************************/
-
-static void qose_reg_wr(uint32_t reg, uint32_t val) 
-{
-	xrx500_qos_w32((void *)(KSEG1ADDR(reg)), val);
-}
-
-static void qose_reg_rd_poll (uint32_t reg, uint32_t val, uint32_t offset)
-{
-	uint32_t tmpreg;
-
-	while (1) {
-		tmpreg = xrx500_qos_r32((void *)(KSEG1ADDR(reg))) & (1 << offset);
-		if (tmpreg == (val << offset))
-			break;
-	}
-
-}
-
-s32 qos_config(void *qmgr_buf)
-{
-	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
-	qose_reg_wr(0x18820090, 0x0002a455);
-	qose_reg_wr(0x18820094, 0x0006b264);
-	qose_reg_wr(0x18820098, 0x00000012);
-	qose_reg_wr(0x1882009c, 0x0000000b);
-	qose_reg_wr(0x18820080, 0x00000001);
-	qose_reg_wr(0x18820084, 0x00000000);
-	qose_reg_wr(0x188200a0, 0x00017c6e);
-	qose_reg_wr(0x188200a4, 0x0003f024);
-	qose_reg_wr(0x188200a8, 0x0000000a);
-	qose_reg_wr(0x188200ac, 0x00000005);
-	qose_reg_wr(0x188200b0, 0x0000265c);
-	qose_reg_wr(0x188200b4, 0x0000368a);
-	qose_reg_wr(0x188200bc, 0x0000000e);
-	qose_reg_wr(0x188200c0, 0x00000003);
-	qose_reg_wr(0x18820a38, 0x00000000);
-	qose_reg_wr(0x18820e38, 0x00000000);
-	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
-	qose_reg_wr(0x18820090, 0x00025705);
-	qose_reg_wr(0x18820094, 0x000d945c);
-	qose_reg_wr(0x18820098, 0x00000018);
-	qose_reg_wr(0x1882009c, 0x00000001);
-	qose_reg_wr(0x18820080, 0x00000001);
-	qose_reg_wr(0x18820084, 0x00000000);
-	qose_reg_wr(0x188200a0, 0x00028dbf);
-	qose_reg_wr(0x188200a4, 0x000631a9);
-	qose_reg_wr(0x188200a8, 0x0000000c);
-	qose_reg_wr(0x188200ac, 0x00000008);
-	qose_reg_wr(0x188200b0, 0x00002757);
-	qose_reg_wr(0x188200b4, 0x00003d6a);
-	qose_reg_wr(0x188200bc, 0x0000004a);
-	qose_reg_wr(0x188200c0, 0x00000003);
-	qose_reg_wr(0x18820b28, 0x00000000);
-	qose_reg_wr(0x18820f28, 0x00000000);
-	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
-	qose_reg_wr(0x18820090, 0x000210dc);
-	qose_reg_wr(0x18820094, 0x0008d8f3);
-	qose_reg_wr(0x18820098, 0x00000003);
-	qose_reg_wr(0x1882009c, 0x00000005);
-	qose_reg_wr(0x18820080, 0x00000001);
-	qose_reg_wr(0x18820084, 0x00000000);
-	qose_reg_wr(0x188200a0, 0x000229e2);
-	qose_reg_wr(0x188200a4, 0x00043f6d);
-	qose_reg_wr(0x188200a8, 0x00000011);
-	qose_reg_wr(0x188200ac, 0x0000000a);
-	qose_reg_wr(0x188200b0, 0x000022de);
-	qose_reg_wr(0x188200b4, 0x00003657);
-	qose_reg_wr(0x188200bc, 0x0000001e);
-	qose_reg_wr(0x188200c0, 0x00000003);
-	qose_reg_wr(0x18820a78, 0x00000000);
-	qose_reg_wr(0x18820e78, 0x00000000);
-	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
-	qose_reg_wr(0x18820090, 0x00021727);
-	qose_reg_wr(0x18820094, 0x000d293a);
-	qose_reg_wr(0x18820098, 0x00000004);
-	qose_reg_wr(0x1882009c, 0x0000000a);
-	qose_reg_wr(0x18820080, 0x00000001);
-	qose_reg_wr(0x18820084, 0x00000000);
-	qose_reg_wr(0x188200a0, 0x0001ad60);
-	qose_reg_wr(0x188200a4, 0x000471b9);
-	qose_reg_wr(0x188200a8, 0x00000010);
-	qose_reg_wr(0x188200ac, 0x00000001);
-	qose_reg_wr(0x188200b0, 0x000025c9);
-	qose_reg_wr(0x188200b4, 0x00003d55);
-	qose_reg_wr(0x188200bc, 0x00000057);
-	qose_reg_wr(0x188200c0, 0x00000003);
-	qose_reg_wr(0x18820b5c, 0x00000000);
-	qose_reg_wr(0x18820f5c, 0x00000000);
-	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
-	qose_reg_wr(0x18820090, 0x00027afe);
-	qose_reg_wr(0x18820094, 0x00052ea9);
-	qose_reg_wr(0x18820098, 0x00000015);
-	qose_reg_wr(0x1882009c, 0x00000009);
-	qose_reg_wr(0x18820080, 0x00000001);
-	qose_reg_wr(0x18820084, 0x00000000);
-	qose_reg_wr(0x188200a0, 0x0001f912);
-	qose_reg_wr(0x188200a4, 0x0003136e);
-	qose_reg_wr(0x188200a8, 0x00000011);
-	qose_reg_wr(0x188200ac, 0x00000007);
-	qose_reg_wr(0x188200b0, 0x000023e0);
-	qose_reg_wr(0x188200b4, 0x00003a20);
-	qose_reg_wr(0x188200bc, 0x000000eb);
-	qose_reg_wr(0x188200c0, 0x00000003);
-	qose_reg_wr(0x18820dac, 0x00000007);
-	qose_reg_wr(0x188211ac, 0x00000000);
-	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
-	qose_reg_wr(0x18820090, 0x00029224);
-	qose_reg_wr(0x18820094, 0x000b9c5e);
-	qose_reg_wr(0x18820098, 0x0000000e);
-	qose_reg_wr(0x1882009c, 0x00000006);
-	qose_reg_wr(0x18820080, 0x00000001);
-	qose_reg_wr(0x18820084, 0x00000000);
-	qose_reg_wr(0x188200a0, 0x0002cd06);
-	qose_reg_wr(0x188200a4, 0x00044b7e);
-	qose_reg_wr(0x188200a8, 0x00000012);
-	qose_reg_wr(0x188200ac, 0x00000008);
-	qose_reg_wr(0x188200b0, 0x00002328);
-	qose_reg_wr(0x188200b4, 0x00003218);
-	qose_reg_wr(0x188200bc, 0x0000002a);
-	qose_reg_wr(0x188200c0, 0x00000003);
-	qose_reg_wr(0x18820aa8, 0x00000007);
-	qose_reg_wr(0x18820ea8, 0x00000000);
-	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
-	qose_reg_wr(0x18820090, 0x00028afa);
-	qose_reg_wr(0x18820094, 0x000afdc8);
-	qose_reg_wr(0x18820098, 0x0000000b);
-	qose_reg_wr(0x1882009c, 0x00000001);
-	qose_reg_wr(0x18820080, 0x00000001);
-	qose_reg_wr(0x18820084, 0x00000000);
-	qose_reg_wr(0x188200a0, 0x0002b942);
-	qose_reg_wr(0x188200a4, 0x000d8910);
-	qose_reg_wr(0x188200a8, 0x00000011);
-	qose_reg_wr(0x188200ac, 0x0000000b);
-	qose_reg_wr(0x188200b0, 0x00002633);
-	qose_reg_wr(0x188200b4, 0x00003c36);
-	qose_reg_wr(0x188200bc, 0x000000f2);
-	qose_reg_wr(0x188200c0, 0x00000003);
-	qose_reg_wr(0x18820dc8, 0x00000007);
-	qose_reg_wr(0x188211c8, 0x00000000);
-	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
-	qose_reg_wr(0x18820090, 0x0002bed3);
-	qose_reg_wr(0x18820094, 0x0003da49);
-	qose_reg_wr(0x18820098, 0x0000000f);
-	qose_reg_wr(0x1882009c, 0x0000000a);
-	qose_reg_wr(0x18820080, 0x00000001);
-	qose_reg_wr(0x18820084, 0x00000000);
-	qose_reg_wr(0x188200a0, 0x0002c8e6);
-	qose_reg_wr(0x188200a4, 0x000a8584);
-	qose_reg_wr(0x188200a8, 0x0000000d);
-	qose_reg_wr(0x188200ac, 0x00000008);
-	qose_reg_wr(0x188200b0, 0x000025b4);
-	qose_reg_wr(0x188200b4, 0x00002ca3);
-	qose_reg_wr(0x188200bc, 0x000000be);
-	qose_reg_wr(0x188200c0, 0x00000003);
-	qose_reg_wr(0x18820cf8, 0x0000001a);
-	qose_reg_wr(0x188210f8, 0x00000000);
-	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
-	qose_reg_wr(0x18820090, 0x00023c35);
-	qose_reg_wr(0x18820094, 0x000fbf60);
-	qose_reg_wr(0x18820098, 0x0000001c);
-	qose_reg_wr(0x1882009c, 0x00000006);
-	qose_reg_wr(0x18820080, 0x00000001);
-	qose_reg_wr(0x18820084, 0x00000000);
-	qose_reg_wr(0x188200a0, 0x00029899);
-	qose_reg_wr(0x188200a4, 0x000580e1);
-	qose_reg_wr(0x188200a8, 0x00000009);
-	qose_reg_wr(0x188200ac, 0x00000005);
-	qose_reg_wr(0x188200b0, 0x00002614);
-	qose_reg_wr(0x188200b4, 0x0000283c);
-	qose_reg_wr(0x188200bc, 0x00000077);
-	qose_reg_wr(0x188200c0, 0x00000003);
-	qose_reg_wr(0x18820bdc, 0x0000001a);
-	qose_reg_wr(0x18820fdc, 0x00000000);
-	qose_reg_rd_poll(0x188200c4, 0x0, 0x00);
-	qose_reg_wr(0x18820090, 0x0002b289);
-	qose_reg_wr(0x18820094, 0x00080794);
-	qose_reg_wr(0x18820098, 0x0000001c);
-	qose_reg_wr(0x1882009c, 0x00000009);
-	qose_reg_wr(0x18820080, 0x00000001);
-	qose_reg_wr(0x18820084, 0x00000000);
-	qose_reg_wr(0x188200a0, 0x0001acc6);
-	qose_reg_wr(0x188200a4, 0x0009b984);
-	qose_reg_wr(0x188200a8, 0x00000007);
-	qose_reg_wr(0x188200ac, 0x00000001);
-	qose_reg_wr(0x188200b0, 0x000022df);
-	qose_reg_wr(0x188200b4, 0x00003746);
-	qose_reg_wr(0x188200bc, 0x00000067);
-	qose_reg_wr(0x188200c0, 0x00000003);
-	qose_reg_wr(0x18820b9c, 0x0000001a);
-	qose_reg_wr(0x18820f9c, 0x00000000);
-	qose_reg_wr(0x189c0004, 0x00000001);
-	//qose_reg_wr(0x189c0008, 0x40000000);
-	qose_reg_wr(0x189c0008, (u32)qmgr_buf);
-	qose_reg_wr(0x189c0010, 0x00000193);
-	qose_reg_wr(0x189c0014, 0x00000030);
-	qose_reg_wr(0x189c002c, 0x00000200);
-	qose_reg_rd_poll(0x189c002c, 0x1, 31);
-	qose_reg_wr(0x18820004, 0x00000fc0);
-	qose_reg_wr(0x18820008, 0x00000220);
-	qose_reg_wr(0x18820000, 0x00000001);
-	qose_reg_wr(0x1882000c, 0x00000001);
-	qose_reg_wr(0x18820004, 0x00000fc0);
-	qose_reg_wr(0x18820008, 0x00000220);
-	qose_reg_wr(0x18820000, 0x00000001);
-	qose_reg_wr(0x1882000c, 0x00000001);
-	qose_reg_wr(0x18820200, 0x00000000);
-	qose_reg_wr(0x18820400, 0x00000000);
-	qose_reg_wr(0x18820600, 0x00ffffff);
-	qose_reg_wr(0x18820800, 0x00ffffff);
-	qose_reg_wr(0x1882021c, 0x00000000);
-	qose_reg_wr(0x1882041c, 0x00000000);
-	qose_reg_wr(0x1882061c, 0x00ffffff);
-	qose_reg_wr(0x1882081c, 0x00ffffff);
-	qose_reg_wr(0x18820268, 0x00000000);
-	qose_reg_wr(0x18820468, 0x00000000);
-	qose_reg_wr(0x18820668, 0x00ffffff);
-	qose_reg_wr(0x18820868, 0x00ffffff);
-	qose_reg_rd_poll(0x18800230, 0x1, 0x03);
-	qose_reg_rd_poll(0x18800220, 0x1, 0x03);
-	qose_reg_rd_poll(0x18800224, 0x1, 0x03);
-	qose_reg_rd_poll(0x18800228, 0x1, 0x03);
-	qose_reg_rd_poll(0x18800234, 0x1, 0x03);
-	qose_reg_wr(0x18800044, 0x00200400);
-	qose_reg_wr(0x18800040, 0x00000080);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x82105c00);
-	qose_reg_wr(0x18800088, 0x24004000);
-	qose_reg_wr(0x1880008c, 0x11e3080c);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00000001);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x84109400);
-	qose_reg_wr(0x18800088, 0x34004000);
-	qose_reg_wr(0x1880008c, 0x059b1006);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00000701);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x8610d400);
-	qose_reg_wr(0x18800088, 0x38004000);
-	qose_reg_wr(0x1880008c, 0x07bb1810);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00001a01);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000400);
-	qose_reg_wr(0x18800088, 0x34004000);
-	qose_reg_wr(0x1880008c, 0x061b0006);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00020801);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000400);
-	qose_reg_wr(0x18800088, 0x28004000);
-	qose_reg_wr(0x1880008c, 0x0edb0008);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00020a01);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000400);
-	qose_reg_wr(0x18800088, 0x40004000);
-	qose_reg_wr(0x1880008c, 0x093b0708);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00021101);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000400);
-	qose_reg_wr(0x18800088, 0x2c004000);
-	qose_reg_wr(0x1880008c, 0x06db000c);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00020901);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000400);
-	qose_reg_wr(0x18800088, 0x30004000);
-	qose_reg_wr(0x1880008c, 0x11430004);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00020b01);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000400);
-	qose_reg_wr(0x18800088, 0x30004000);
-	qose_reg_wr(0x1880008c, 0x099b1a08);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00021a01);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000400);
-	qose_reg_wr(0x18800088, 0x3c004000);
-	qose_reg_wr(0x1880008c, 0x079b1a0c);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00021901);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000400);
-	qose_reg_wr(0x18800088, 0x24004000);
-	qose_reg_wr(0x1880008c, 0x0ae31a06);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00021801);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000400);
-	qose_reg_wr(0x18800088, 0x28004000);
-	qose_reg_wr(0x1880008c, 0x0ddb0704);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00021001);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000400);
-	qose_reg_wr(0x18800088, 0x3c004000);
-	qose_reg_wr(0x1880008c, 0x05db0706);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00021201);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x0000ca08);
-	qose_reg_wr(0x18800088, 0x0000800e);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00000e51);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x000ba20a);
-	qose_reg_wr(0x18800088, 0x0000801e);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00001e51);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x7070aa11);
-	qose_reg_wr(0x18800088, 0x0000802a);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00002a51);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x000e9a09);
-	qose_reg_wr(0x18800088, 0x0000804a);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00004a51);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x000c420b);
-	qose_reg_wr(0x18800088, 0x00008057);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00005751);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x21afca1a);
-	qose_reg_wr(0x18800088, 0x00008067);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00006751);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x21a13219);
-	qose_reg_wr(0x18800088, 0x00008077);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00007751);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x21af4a18);
-	qose_reg_wr(0x18800088, 0x000080be);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x0000be51);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x70709210);
-	qose_reg_wr(0x18800088, 0x000080eb);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x0000eb51);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x707a1a12);
-	qose_reg_wr(0x18800088, 0x000080f2);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x0000f251);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000000);
-	qose_reg_wr(0x18800088, 0x00000000);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00030011);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000000);
-	qose_reg_wr(0x18800088, 0x00000000);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00030011);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000007);
-	qose_reg_wr(0x18800088, 0x00000000);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00030711);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000000);
-	qose_reg_wr(0x18800088, 0x00000000);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00030011);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000000);
-	qose_reg_wr(0x18800088, 0x00000000);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00030011);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x0000001a);
-	qose_reg_wr(0x18800088, 0x00000000);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00031a11);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x0000001a);
-	qose_reg_wr(0x18800088, 0x00000000);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00031a11);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x0000001a);
-	qose_reg_wr(0x18800088, 0x00000000);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00031a11);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000007);
-	qose_reg_wr(0x18800088, 0x00000000);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00030711);
-	qose_reg_rd_poll(0x188000a4, 0x0, 0x06);
-	qose_reg_wr(0x18800084, 0x00000007);
-	qose_reg_wr(0x18800088, 0x00000000);
-	qose_reg_wr(0x1880008c, 0x00000000);
-	qose_reg_wr(0x18800090, 0x00000000);
-	qose_reg_wr(0x18800094, 0x00030711);
-	qose_reg_wr(0x18800148, 0x000030d4);
-	qose_reg_wr(0x1880014c, 0x00000010);
-	qose_reg_wr(0x18800080, 0x00000002);
-	qose_reg_wr(0x18800144, 0x00001000);
-	qose_reg_wr(0x18800154, 0x0000007f);
-	qose_reg_wr(0x188000a8, 0x00000018);
-	qose_reg_wr(0x18810000, 0x04000081);
-	qose_reg_wr(0x18810004, 0x00000000);
-	qose_reg_wr(0x18810008, 0x00000000);
-	qose_reg_wr(0x1881000c, 0x00000000);
-	qose_reg_wr(0x18810040, 0xffffffff);
-	qose_reg_wr(0x18810044, 0xffffffff);
-	qose_reg_wr(0x18810048, 0xffffffff);
-	qose_reg_wr(0x1881004c, 0xffffffff);
-	qose_reg_wr(0x18810054, 0x00200000);
-	qose_reg_wr(0x1881005c, 0xdeadbeef);
-	qose_reg_wr(0x18810060, 0x00000100);
-	qose_reg_wr(0x18810064, 0x00240000);
-	qose_reg_wr(0x18a00808, 0x00000002);
-	qose_reg_wr(0x18810098, 0x00000100);
-	qose_reg_wr(0x1881009c, 0x00240700);
-	qose_reg_wr(0x18a00878, 0x00000008);
-	qose_reg_wr(0x18810130, 0x00000100);
-	qose_reg_wr(0x18810134, 0x00241a00);
-	qose_reg_wr(0x18a009a8, 0x00000008);
-	qose_reg_wr(0x1881087c, 0x00000303);
-	return 0;
-}
-
diff --git a/include/net/bm_drv_slim.h b/include/net/bm_drv_slim.h
deleted file mode 100755
index 3f866f4ad74d..000000000000
--- a/include/net/bm_drv_slim.h
+++ /dev/null
@@ -1,401 +0,0 @@
-/*
- * GPL LICENSE SUMMARY
- *
- *  Copyright(c) 2017 Intel Corporation.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of version 2 of the GNU General Public License as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *  The full GNU General Public License is included in this distribution
- *  in the file called LICENSE.GPL.
- *
- *  Contact Information:
- *  Intel Corporation
- *  2200 Mission College Blvd.
- *  Santa Clara, CA  97052
- */
-
-/*
- *	driver:		buffer_manager platform device driver
- *	@file		bm_drv.h
- *	@brief:		ppv4 buffer manager implementation 
- *	@author:	obakshe
- *	@date:		5/3/2017
- */
-
-#ifndef _BMGR_H_
-#define _BMGR_H_
-
-#include <net/pp_bm_regs.h>
-
-
-#define FALCON_SOC
-
-#ifdef FALCON_SOC
-	/*! \def PP_BMGR_MAX_POOLS
-	 *       Max supported pools
-	 */
-	#define PP_BMGR_MAX_POOLS		(4)
-
-	/*! \def PP_BMGR_MAX_POOLS_IN_GROUP
-	 *       Max pools in group
-	 */
-	#define PP_BMGR_MAX_POOLS_IN_GROUP	(4)
-
-	/*! \def PP_BMGR_MAX_GROUPS
-	 *       Max supported groups
-	 */
-	#define PP_BMGR_MAX_GROUPS		(2)
-
-	/*! \def PP_BMGR_MAX_POLICIES
-	 *       Max supoorted policies
-	 */
-	#define PP_BMGR_MAX_POLICIES		(32)
-#else /* PPv4 */
-	/*! \def PP_BMGR_MAX_POOLS
-	 *       Max supported pools
-	 */
-	#define PP_BMGR_MAX_POOLS		(16)
-
-	/*! \def PP_BMGR_MAX_POOLS_IN_GROUP
-	 *       Max pools in group
-	 */
-	#define PP_BMGR_MAX_POOLS_IN_GROUP	(4)
-
-	/*! \def PP_BMGR_MAX_GROUPS
-	 *       Max supported groups
-	 */
-	#define PP_BMGR_MAX_GROUPS		(16)
-
-	/*! \def PP_BMGR_MAX_POLICIES
-	 *       Max supoorted policies
-	 */
-	#define PP_BMGR_MAX_POLICIES		(256)
-#endif
-
-//-----------------------------------------------------------------------------------------------------------------------------------------------
-//
-// ########  ######## ######## #### ##    ## ########  ######
-// ##     ## ##       ##        ##  ###   ## ##       ##    ##
-// ##     ## ##       ##        ##  ####  ## ##       ##
-// ##     ## ######   ######    ##  ## ## ## ######    ######
-// ##     ## ##       ##        ##  ##  #### ##             ##
-// ##     ## ##       ##        ##  ##   ### ##       ##    ##
-// ########  ######## ##       #### ##    ## ########  ######
-//
-//-----------------------------------------------------------------------------------------------------------------------------------------------
-
-/*! \def BMGR_DRIVER_VERSION */
-#define BMGR_DRIVER_VERSION			"1.0.0"
-
-/*! \def BMGR_MIN_POOL_BUFFER_SIZE
- *       Minimum buffer size in configured pool
- */
-#define BMGR_MIN_POOL_BUFFER_SIZE		(64)
-
-/*! \def BMGR_START_PCU_SRAM_ADDR 
- *       Start PCU address in SRAM. Used in confiure pool
- */
-#define BMGR_START_PCU_FIFO_SRAM_ADDR		(0)
-
-/*! \def BMGR_DEFAULT_PCU_FIFO_SIZE 
- *       PCU fifo size
- */
-#define BMGR_DEFAULT_PCU_FIFO_SIZE		(0x80)
-
-/*! \def BMGR_DEFAULT_PCU_FIFO_LOW_THRESHOLD 
- *       PCU fifo low threshold
- */
-#define BMGR_DEFAULT_PCU_FIFO_LOW_THRESHOLD	(1)
-
-/*! \def BMGR_DEFAULT_PCU_FIFO_HIGH_THRESHOLD 
- *       PCU fifo high threshold
- */
-#define BMGR_DEFAULT_PCU_FIFO_HIGH_THRESHOLD	(0x70)
-
-/*! \def BMGR_DEFAULT_WATERMARK_LOW_THRESHOLD 
- *       Watermark low threshold
- */
-#define BMGR_DEFAULT_WATERMARK_LOW_THRESHOLD	(0x200)
-
-//-----------------------------------------------------------------------------------------------------------------------------------------------
-//
-//  ######  ######## ########  ##     ##  ######  ######## ##     ## ########  ########  ######
-// ##    ##    ##    ##     ## ##     ## ##    ##    ##    ##     ## ##     ## ##       ##    ##
-// ##          ##    ##     ## ##     ## ##          ##    ##     ## ##     ## ##       ##
-//  ######     ##    ########  ##     ## ##          ##    ##     ## ########  ######    ######
-//       ##    ##    ##   ##   ##     ## ##          ##    ##     ## ##   ##   ##             ##
-// ##    ##    ##    ##    ##  ##     ## ##    ##    ##    ##     ## ##    ##  ##       ##    ##
-//  ######     ##    ##     ##  #######   ######     ##     #######  ##     ## ########  ######
-//
-//-----------------------------------------------------------------------------------------------------------------------------------------------
-
-/**************************************************************************
- *! \enum	bmgr_policy_pools_priority_e
- **************************************************************************
- *
- * \brief enum to describe the pool's priority
- *
- **************************************************************************/
-enum bmgr_policy_pools_priority_e {
-	bmgr_policy_pool_priority_high,		//!< High priority
-	bmgr_policy_pool_priority_mid_high,	//!< Mid-High priority
-	bmgr_policy_pool_priority_mid_low,	//!< Mid-Low priority
-	bmgr_policy_pool_priority_low,		//!< Low priority
-	bmgr_policy_pool_priority_max		//!< Last priority
-};
-
-/*! \def POOL_ENABLE_FOR_MIN_GRNT_POLICY_CALC 
- *       bmgr pools flags (Used in bmgr_pool_params.pool_flags)
- *       When set pool will be take part in policy minimum guaranteed calculation
- */
-#define POOL_ENABLE_FOR_MIN_GRNT_POLICY_CALC	BIT(0)
-
-/**************************************************************************
- *! \struct	bmgr_pool_params
- **************************************************************************
- *
- * \brief This structure is used in bmgr_pool_configure API in parameter
- *
- **************************************************************************/
-struct bmgr_pool_params {
-	u16	flags;			//!< Pool flags
-	u8	group_id;		//!< Group index which the pool belong to
-	u32	num_buffers;		//!< Amount of buffers in pool
-	u32	size_of_buffer;		//!< Buffer size for this pool (in bytes). Minimum is 64 bytes
-	u32	base_addr_low;		//!< Base address of the pool (low)
-	u32	base_addr_high;		//!< Base address of the pool (high)
-};
-
-/**************************************************************************
- *! \struct	bmgr_group_params
- **************************************************************************
- *
- * \brief This structure is used for buffer manager database
- *
- **************************************************************************/
-struct bmgr_group_params {
-	u32	available_buffers;		//!< available buffers in group
-	u32	reserved_buffers;		//!< reserved buffers in this group
-	u8	pools[PP_BMGR_MAX_POOLS];	//!< Pools in policy
-};
-
-/**************************************************************************
- *! \struct	bmgr_pool_in_policy_info
- **************************************************************************
- *
- * \brief	This structure is used in policy_params struct and holds
- * 		the information about the pools in policy 
- *
- **************************************************************************/
-struct bmgr_pool_in_policy_info {
-	u8	pool_id;	//!< Pool id
-	u8	max_allowed;	//!< Max allowed per pool per policy
-};
-
-/*! \def POLICY_FLAG_RESERVED1 
- *       bmgr policy flags (Used in bmgr_policy_param.policy_flags)
- */
-#define POLICY_FLAG_RESERVED1	BIT(0)
-
-/**************************************************************************
- *! \struct	bmgr_policy_params
- **************************************************************************
- *
- * \brief This structure is used in bmgr_policy_configure API in parameter
- *
- **************************************************************************/
-struct bmgr_policy_params {
-	u16				flags;						//!< Policy flags
-	u8				group_id;					//!< Group index
-	u32				max_allowed;					//!< Policy maximum allowed
-	u32				min_guaranteed;					//!< Policy minimum guaranteed
-	struct bmgr_pool_in_policy_info	pools_in_policy[PP_BMGR_MAX_POOLS_IN_POLICY];	//!< Pools information. Sorted according to priority - highest in index 0
-	u8				num_pools_in_policy;				//!< Number of pools in pools_in_policy
-};
-
-/**************************************************************************
- *! \struct	bmgr_buff_info
- **************************************************************************
- *
- * \brief This structure is used for allocate and deallocate buffer
- *
- **************************************************************************/
-struct bmgr_buff_info {
-	u32	addr_low;	//!< [Out] buffer pointer low
-	u32	addr_high;	//!< [Out] buffer pointer high
-	u8	policy_id;	//!< policy to allocate from
-	u8	pool_id;	//!< pool for deallocate buffer back
-	u8	is_burst;	//!< Single/Burst allocation/s
-//	u8	num_allocs;	//!< number of pointers to allocate (up to 32 pointers)
-};
-
-/**************************************************************************
- *! \struct	bmgr_pool_db_entry
- **************************************************************************
- *
- * \brief This structure holds the pool database
- *
- **************************************************************************/
-struct bmgr_pool_db_entry {
-	struct bmgr_pool_params	pool_params;			//!< Pool params
-	u32			num_allocated_buffers;		//!< Number of allocated buffers
-	u32			num_deallocated_buffers;	//!< Number of deallocated buffers
-	u8			is_busy;			//!< Is entry in used
-	void*			internal_pointers_tables;	//!< Pointers table to be used in HW
-};
-
-/**************************************************************************
- *! \struct	bmgr_group_db_entry
- **************************************************************************
- *
- * \brief This structure holds the group database
- *
- **************************************************************************/
-struct bmgr_group_db_entry {
-	u32	available_buffers;			//!< available buffers in group
-	u32	reserved_buffers;			//!< reserved buffers in this group
-	u8	pools[PP_BMGR_MAX_POOLS_IN_GROUP];	//!< Pools in policy (if set, pool is part of this group)
-	u8	num_pools_in_group;			//!< Number of pools in group
-};
-
-/**************************************************************************
- *! \struct	bmgr_policy_db_entry
- **************************************************************************
- *
- * \brief This structure holds the policy database
- *
- **************************************************************************/
-struct bmgr_policy_db_entry {
-	struct bmgr_policy_params	policy_params;			//!< Policy params
-	u32				num_allocated_buffers;		//!< Number of allocated buffers
-	u32				num_deallocated_buffers;	//!< Number of deallocated buffers
-	u8				is_busy;			//!< Is entry in used
-};
-
-/**************************************************************************
- *! \struct	bmgr_driver_db
- **************************************************************************
- *
- * \brief This structure holds the buffer manager database
- *
- **************************************************************************/
-struct bmgr_driver_db {
-	struct bmgr_pool_db_entry	bmgr_db_pools[PP_BMGR_MAX_POOLS];	//!< Pools information
-	struct bmgr_group_db_entry	bmgr_db_groups[PP_BMGR_MAX_GROUPS];	//!< Groups information
-	struct bmgr_policy_db_entry	bmgr_db_policies[PP_BMGR_MAX_POLICIES];	//!< Policies information
-
-	// general counters
-	u32				num_active_pools;			//!< Number of active pools
-	u32				num_active_groups;			//!< Number of active groups
-	u32				num_active_policies;			//!< Number of active policies
-
-	// spinlock
-	spinlock_t			db_lock;				//!< spinlock
-};
-
-/**************************************************************************
- *! \struct	bmgr_driver_private
- **************************************************************************
- *
- * \brief This struct defines the driver's private data
- *
- **************************************************************************/
-struct bmgr_driver_private {
-	struct platform_device*		pdev;		//!< Platform device pointer
-	struct kobject*			kobj;		//!< Sysfs kobject
-	int				enabled;	//!< Is driver enabled
-	struct bmgr_driver_db		driver_db;	//!< Platform device DB
-};
-
-//-----------------------------------------------------------------------------------------------------------------------------------------------
-//
-// ########  ########   #######  ########  #######  ######## ##    ## ########  ########  ######
-// ##     ## ##     ## ##     ##    ##    ##     ##    ##     ##  ##  ##     ## ##       ##    ##
-// ##     ## ##     ## ##     ##    ##    ##     ##    ##      ####   ##     ## ##       ##
-// ########  ########  ##     ##    ##    ##     ##    ##       ##    ########  ######    ######
-// ##        ##   ##   ##     ##    ##    ##     ##    ##       ##    ##        ##             ##
-// ##        ##    ##  ##     ##    ##    ##     ##    ##       ##    ##        ##       ##    ##
-// ##        ##     ##  #######     ##     #######     ##       ##    ##        ########  ######
-//
-//-----------------------------------------------------------------------------------------------------------------------------------------------
-
-/**************************************************************************
- *! \fn	bmgr_driver_init
- **************************************************************************
- *
- *  \brief	Initializes the buffer manager driver.
- *  		Must be the first driver's function to be called
- *
- *  \return	PP_RC_SUCCESS on success, other error code on failure
- *
- **************************************************************************/
-s32 bmgr_driver_init(void);
-
-/**************************************************************************
- *! \fn	bmgr_pool_configure
- **************************************************************************
- *
- *  \brief	Configure a Buffer Manager pool
- *
- *  \param	pool_params:	Pool param from user
- *  \param	pool_id[OUT]:	Pool ID
- *
- *  \return	PP_RC_SUCCESS on success, other error code on failure
- *
- **************************************************************************/
-s32 bmgr_pool_configure(const struct bmgr_pool_params* const pool_params, u8* const pool_id);
-
-/**************************************************************************
- *! \fn	bmgr_policy_configure
- **************************************************************************
- *
- *  \brief	Configure a Buffer Manager policy
- *
- *  \param	policy_params:	Policy param from user
- *  \param	policy_id[OUT]:	Policy ID
- *
- *  \return	PP_RC_SUCCESS on success, other error code on failure
- *
- **************************************************************************/
-s32 bmgr_policy_configure(const struct bmgr_policy_params* const policy_params, u8* const policy_id);
-
-/**************************************************************************
- *! \fn	bmgr_pop_buffer
- **************************************************************************
- *
- *  \brief	Pops a buffer from the buffer manager
- *
- *  \param	buff_info:	Buffer information
- *
- *  \return	PP_RC_SUCCESS on success, other error code on failure
- *
- **************************************************************************/
-s32 bmgr_pop_buffer(struct bmgr_buff_info* const buff_info);
-
-/**************************************************************************
- *! \fn	bmgr_push_buffer
- **************************************************************************
- *
- *  \brief	Pushes a buffer back to the buffer manager
- *
- *  \param	buff_info:	Buffer information
- *
- *  \return	PP_RC_SUCCESS on success, other error code on failure
- *
- **************************************************************************/
-s32 bmgr_push_buffer(struct bmgr_buff_info* const buff_info);
-s32 qos_config(void *qmgr_buf);
-
-void new_init_bm(void);
-#endif /* _BMGR_H_ */
diff --git a/include/net/pp_qos_drv_slim.h b/include/net/pp_qos_drv_slim.h
deleted file mode 100644
index 9ee7de4b7368..000000000000
--- a/include/net/pp_qos_drv_slim.h
+++ /dev/null
@@ -1,305 +0,0 @@
-/*
- * pp_qos_drv.h
- * Description:
- * PP QoS Manager driver definitions
- *
- * GPL LICENSE SUMMARY
- *
- *  Copyright(c) 2017 Intel Corporation.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of version 2 of the GNU General Public License as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *  The full GNU General Public License is included in this distribution
- *  in the file called LICENSE.GPL.
- *
- *  Contact Information:
- *  Intel Corporation
- *  2200 Mission College Blvd.
- *  Santa Clara, CA  97052
- */
-#ifndef PPQOSDRV_H_
-#define PPQOSDRV_H_
-
-#include <linux/types.h>
-
-#define PP_QOS_MAX_NODES			(2048)
-#ifdef FALCON_SOC
-	#define PP_QOS_MAX_PORT_NODES	(128)
-	#define PP_QOS_MAX_QUEUE_NODES	(256)
-#else /* PPv4 */
-	#define PP_QOS_MAX_PORT_NODES	(256)
-	#define PP_QOS_MAX_QUEUE_NODES	(512)
-#endif
-//#define BIT(x)						(1<<(x))
-
-/* enum qos_node_type_e:
- * Describing the QoS node type
- */
-enum qos_node_type_e {
-	QOS_NODE_PORT,
-	QOS_NODE_SCH,
-	QOS_NODE_QUEUE,
-	QOS_NODE_TYPE_MAX
-};
-
-/* enum qos_op_type_e:
- * Describing the qos_node_config API
- * Operation type
- */
-enum qos_op_type_e {
-	QOS_OP_ADD,
-	QOS_OP_REMOVE,
-	QOS_OP_MODIFY,
-	QOS_OP_SUSPEND,
-	QOS_OP_RESUME,
-	QOS_OP_MOVE,
-	QOS_OP_QUERY
-};
-
-/* enum qos_sch_type_e:
- * Describing the node
- * Scheduling type
- */
-enum qos_sch_type_e {
-	QOS_SCH_WSP_WRR,
-	QOS_SCH_WFQ
-};
-
-/* struct qos_init_param:
- * This structure is using
- * For Initialized the QoS subsystem
- */
-struct qos_init_param {
-	u32	qm_base_addr;
-	u32	qm_num_of_pages;
-	u32	wred_prioritized_pop;
-	u32	wred_p_const;
-};
-
-/* struct qos_node_conf:
- * General information for node
- * Configuration
- */
-struct qos_node_conf {
-	enum qos_node_type_e	node_type;
-	enum qos_sch_type_e	sch_type;
-	u16			node_id;
-	u16			bw_limit_Mbps;
-	u16			shared_bw_limit_group;
-	u8			bw_allocation_weight;
-	u8			priority;
-	u16			parent_node_id;
-	u16			child_node_id;
-};
-
-/* struct qos_port_conf:
- * Information for port
- * Configuration
- */
-struct qos_port_conf {
-	u32		port_conf_flags;
-#define PORT_PARAM_FLAG_DISABLE_BYTES_CREDIT	BIT(0)
-#define PORT_PARAM_FLAG_BYTES_CREDIT_SET		BIT(1)
-#define PORT_PARAM_FLAG_PACKETS_CREDIT_SET		BIT(2)
-#define PORT_PARAM_FLAG_RING_ADDR_SET			BIT(3)
-#define PORT_PARAM_FLAG_RING_SIZE_SET			BIT(4)
-	u32		port_tx_packets_credit;
-	u32		port_tx_bytes_credit;
-	u32		port_tx_ring_address;
-	u32		port_tx_ring_size;
-};
-
-/* struct qos_queue_conf:
- * Information for queue
- * Configuration
- */
-struct qos_queue_conf {
-	u32		queue_conf_flags;
-#define QUEUE_PARAM_FLAG_DISABLE_WRED				BIT(0)
-#define QUEUE_PARAM_FLAG_WRED_MIN_AVG_GREEN_SET		BIT(1)
-#define QUEUE_PARAM_FLAG_WRED_MAX_AVG_GREEN_SET		BIT(2)
-#define QUEUE_PARAM_FLAG_WRED_SLOPE_GREEN_SET		BIT(3)
-#define QUEUE_PARAM_FLAG_WRED_MIN_AVG_YELLOW_SET	BIT(4)
-#define QUEUE_PARAM_FLAG_WRED_MAX_AVG_YELLOW_SET	BIT(5)
-#define QUEUE_PARAM_FLAG_WRED_SLOPE_YELLOW_SET		BIT(6)
-#define QUEUE_PARAM_FLAG_DISABLE_MIN_GUARANTEED		BIT(7)
-#define QUEUE_PARAM_FLAG_MIN_GUARANTEED_SET			BIT(8)
-#define QUEUE_PARAM_FLAG_DISABLE_MAX_ALLOWED		BIT(9)
-#define QUEUE_PARAM_FLAG_MAX_ALLOWED_SET			BIT(10)
-	u16		queue_wred_min_avg_green;
-	u16		queue_wred_max_avg_green;
-	u16		queue_wred_slope_green;
-	u16		queue_wred_min_avg_yellow;
-	u16		queue_wred_max_avg_yellow;
-	u16		queue_wred_slope_yellow;
-	u16		queue_wred_min_guaranteed;
-	u16		queue_wred_max_allowed;
-};
-
-/* struct output_param:
- * Information for output
- * Parameters
- */
-struct output_param {
-	u32		output_flags;
-#define OUTPUT_PARAM_FLAG_NODE_ID_SET		BIT(0)
-#define OUTPUT_PARAM_FLAG_PHY_QUEUE_ID_SET	BIT(1)
-	u16		node_id;
-	u16		queue_id;
-};
-
-/* struct qos_node_api_param:
- * This structure is using as
- * qos_node_config API parameter
- */
-struct qos_node_api_param {
-	enum qos_op_type_e		op_type;
-	u32				node_conf_flags;
-	int 				deq_port;
-#define NODE_PARAM_FLAG_NODE_ID_SET		BIT(0)
-#define NODE_PARAM_FLAG_BW_LIMIT_SET		BIT(1)
-#define NODE_PARAM_FLAG_SBW_LIMIT_SET		BIT(2)
-#define NODE_PARAM_FLAG_BW_ALLOCATION_SET	BIT(3)
-#define NODE_PARAM_FLAG_PRIORITY_SET		BIT(4)
-#define NODE_PARAM_FLAG_PARENT_NODE_SET		BIT(5)
-#define NODE_PARAM_FLAG_CHILD_NODE_SET		BIT(6)
-#define NODE_PARAM_FLAG_EXTRA_PORT_CONF_SET	BIT(7)
-#define NODE_PARAM_FLAG_EXTRA_QUEUE_CONF_SET	BIT(8)
-	struct qos_node_conf	node_conf;
-	struct qos_port_conf	port_conf;
-	struct qos_queue_conf	queue_conf;
-	struct output_param	out_param;
-};
-
-/* struct qos_node_stats:
- * Information for node statistics
- */
-struct qos_node_stats {
-	u16	object_id;
-	u16	stats_req_flags;
-#define STATS_FLAG_GET_BY_NODE_ID			BIT(0)
-#define STATS_FLAG_GET_BY_QUEUE_ID			BIT(1)
-#define STATS_FLAG_GET_BY_PORT_ID			BIT(2)
-#define STATS_FLAG_GET_TOTAL_FWD_PACKETS	BIT(3)
-#define STATS_FLAG_GET_TOTAL_FWD_BYTES		BIT(4)
-#define STATS_FLAG_GET_TOTAL_DRP_PACKETS	BIT(5)
-#define STATS_FLAG_GET_TOTAL_DRP_BYTES		BIT(6)
-#define STATS_FLAG_GET_CURR_Q_PACKETS_SIZE	BIT(7)
-#define STATS_FLAG_GET_CURR_Q_BYTES_SIZE	BIT(8)
-#define STATS_FLAG_GET_CURR_WRED_AVG_SIZE	BIT(9)
-#define STATS_FLAG_GET_CURR_WRED_DRP_PROB_G	BIT(10)
-#define STATS_FLAG_GET_CURR_WRED_DRP_PROB_Y	BIT(11)
-#define STATS_FLAG_RESET_COUNTERS			BIT(12)
-#define STATS_FLAG_GET_ALL_COUNTERS			BIT(15)
-	u32	total_fwd_pkt;
-	u64	total_fwd_byte;
-	u32	total_drp_pkt;
-	u64	total_drp_byte;
-	u32	curr_q_pkt_size; /* Available only for node type queue */
-	u32	curr_q_byte_size; /* Available only for node type queue */
-	u32	curr_wred_avg_size; /* Available only for node type queue */
-	u32	curr_wred_drp_prob_green; /* Available only for node type queue */
-	u32	curr_wred_drp_prob_yellow; /* Available only for node type queue */
-};
-
-/* struct qos_node_api_param:
- * enum qos_op_type_e		op_type;				Add/Remove/Modify/Suspend/Resume/Move/Query
- * u32						node_conf_flags;
- * NODE_PARAM_FLAG_NODE_ID_SET						Node ID set
- * NODE_PARAM_FLAG_BW_LIMIT_SET						BW Limit set
- * NODE_PARAM_FLAG_SBW_LIMIT_SET					Shared BW Limit set
- * NODE_PARAM_FLAG_BW_ALLOCATION_SET				BW Allocation set
- * NODE_PARAM_FLAG_PRIORITY_SET						Priority set
- * NODE_PARAM_FLAG_PARENT_NODE_SET					Parent Node ID set
- * NODE_PARAM_FLAG_CHILD_NODE_SET					Child Node ID set
- * NODE_PARAM_FLAG_EXTRA_PORT_CONF_SET				Extra Port Configuration set
- * NODE_PARAM_FLAG_EXTRA_QUEUE_CONF_SET				Extra Queue Configuration set
- *
- * struct qos_node_conf:
- * enum qos_node_type_e	node_type;					Port/Scheduler/Queue Node
- * enum qos_sch_type_e		sch_type;				Not relevant for queue: WSP+WRR, WFQ [Cannot be modified]
- * u16						node_id;				Logical Node ID For Input [0:2047]
- * u16						bw_limit_Mbps;			0 = No BW Limit applied
- * u16						shared_bw_limit_group;	[0-511], Shared BW limit group ID
- * u8						bw_allocation_weight;	0 = Best Effort [1 in credit]
- * u8						priority;				[0..7], 0xFF = WRR, not relevant for WFQ
- * u16						parent_node_id;			Relevant only for Add operation for Scheduler/Queue
- * u16						child_node_id;			Optional.
- *													Relevant only for Add operation in case Node need to be set up between parent and specific child.
- *													In this case, the added Node inherits all its non-configured attributes from the child node
- *
- * struct qos_port_conf:
- * u32	port_conf_flags;
- * PORT_PARAM_FLAG_DISABLE_BYTES_CREDIT				Disable bytes credit option
- * PORT_PARAM_FLAG_BYTES_CREDIT_SET					Bytes credit set
- * PORT_PARAM_FLAG_PACKETS_CREDIT_SET				Packet credit set
- * PORT_PARAM_FLAG_RING_ADDR_SET					Ring address set
- * PORT_PARAM_FLAG_RING_SIZE_SET					Ring size set
- * u32	port_tx_packets_credit;						TX Port Packet credit
- * u32	port_tx_bytes_credit;						TX Port Byte Credit
- * u32	port_tx_ring_address;						TX Port Ring address
- * u32	port_tx_ring_size;							TX Port Ring size
- *
- * struct qos_queue_conf:
- * u32	queue_conf_flags;
- * QUEUE_PARAM_FLAG_DISABLE_WRED					Disable WRED feature
- * QUEUE_PARAM_FLAG_WRED_MIN_AVG_GREEN_SET			WRED Min average green set
- * QUEUE_PARAM_FLAG_WRED_MAX_AVG_GREEN_SET			WRED Max average green set
- * QUEUE_PARAM_FLAG_WRED_SLOPE_GREEN_SET			WRED Slope green set
- * QUEUE_PARAM_FLAG_WRED_MIN_AVG_YELLOW_SET			WRED Min average yellow set
- * QUEUE_PARAM_FLAG_WRED_MAX_AVG_YELLOW_SET			WRED Max average yellow set
- * QUEUE_PARAM_FLAG_WRED_SLOPE_YELLOW_SET			WRED Slope yellow set
- * QUEUE_PARAM_FLAG_DISABLE_MIN_GUARANTEED			Disable Min guaranteed feature
- * QUEUE_PARAM_FLAG_MIN_GUARANTEED_SET				Min guaranteed set
- * QUEUE_PARAM_FLAG_DISABLE_MAX_ALLOWED				Disable Max allowed feature
- * QUEUE_PARAM_FLAG_MAX_ALLOWED_SET					Max allowed set
- * u16	queue_wred_min_avg_green;					WRED Min average green
- * u16	queue_wred_max_avg_green;					WRED Max average green
- * u16	queue_wred_slope_green;						WRED Slope green
- * u16	queue_wred_min_avg_yellow;					WRED Min average yellow
- * u16	queue_wred_max_avg_yellow;					WRED Max average yellow
- * u16	queue_wred_slope_yellow;					WRED Slope yellow
- * u16	queue_wred_min_guaranteed;					Min guaranteed
- * u16	queue_wred_max_allowed;						Max allowed
- *
- * struct output_param:
- * u32	output_flags;
- * OUTPUT_PARAM_FLAG_NODE_ID_SET					Logical Node ID set (by the QoS driver)
- * OUTPUT_PARAM_FLAG_PHY_QUEUE_ID_SET				Phisical Queue ID set (by the QoS driver)
- * u16	node_id;									Logical Node ID
- * u16	queue_id;									Phisical Queue ID
- */
-
-/**
- * qos_node_config - Configure a QoS Node
- * This API is the main QoS driver API
- * Supported operation types are
- * Defined in enum qos_op_type_e
- * @param: API param from user
- **/
-s32 qos_node_config(struct qos_node_api_param *param);
-
-/**
- * qos_node_get_stats - Get Node stats structure
- * @param: Stats structure from user
- **/
-s32 qos_node_get_stats(struct qos_node_stats *param);
-
-/**
- * qos_init_subsystem - Initialized QoS subsystem
- * @param: Init structure from user
- **/
-s32 qos_init_subsystem(struct qos_init_param *param);
-
-#endif /* PPQOSDRV_H_ */
