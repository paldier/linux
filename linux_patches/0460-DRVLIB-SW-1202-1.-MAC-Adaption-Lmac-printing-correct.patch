From 6836ae096d778e8597a3d9c0c418a06af1c93522 Mon Sep 17 00:00:00 2001
From: Dinesh Sudham <dineshx.sudham@intel.com>
Date: Fri, 1 Feb 2019 18:37:18 +0800
Subject: [PATCH] DRVLIB_SW-1202 1. MAC/Adaption/Lmac printing corrected 2.
 pr_err/pr_info and printk corrected 3. Bootup prints from switch removed

---
 drivers/net/ethernet/lantiq/switch-api/gsw_debug.c |   61 +-
 .../net/ethernet/lantiq/switch-api/gsw_defconf.c   |   10 +-
 .../net/ethernet/lantiq/switch-api/gsw_defconf.h   |    9 +
 .../net/ethernet/lantiq/switch-api/gsw_flow_core.c |   83 +-
 .../net/ethernet/lantiq/switch-api/gsw_flow_pce.c  |    4 +-
 drivers/net/ethernet/lantiq/switch-api/gsw_init.c  |   15 +-
 drivers/net/ethernet/lantiq/switch-api/gsw_init.h  |    3 -
 .../ethernet/lantiq/switch-api/gsw_ioctl_wrapper.c |   15 +-
 .../net/ethernet/lantiq/switch-api/gsw_ll_func.h   |    6 +-
 .../ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c |    3 +-
 .../net/ethernet/lantiq/switch-api/mac/Makefile    |    2 +-
 .../net/ethernet/lantiq/switch-api/mac/gswss_api.c |  283 +----
 .../net/ethernet/lantiq/switch-api/mac/gswss_api.h |   23 +-
 .../ethernet/lantiq/switch-api/mac/gswss_mac_api.c | 1173 +++-----------------
 .../ethernet/lantiq/switch-api/mac/gswss_mac_api.h |   56 +-
 .../net/ethernet/lantiq/switch-api/mac/lmac_api.c  |  766 ++-----------
 .../net/ethernet/lantiq/switch-api/mac/lmac_api.h  |   34 +-
 .../net/ethernet/lantiq/switch-api/mac/mac_cfg.c   |   84 +-
 .../net/ethernet/lantiq/switch-api/mac/mac_cfg.h   |   13 +-
 .../net/ethernet/lantiq/switch-api/mac/mac_cli.c   |  637 +++++++++++
 .../net/ethernet/lantiq/switch-api/mac/mac_drv.c   |   51 +-
 .../ethernet/lantiq/switch-api/mac/mac_tx_fifo.c   |    8 +-
 .../ethernet/lantiq/switch-api/mac/mac_tx_fifo.h   |   38 +-
 drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h |   87 +-
 .../ethernet/lantiq/switch-api/mac/xgmac_common.h  |  229 +---
 .../ethernet/lantiq/switch-api/mac/xgmac_debug.c   |    7 +-
 .../ethernet/lantiq/switch-api/mac/xgmac_mac_api.c |  228 ++--
 .../ethernet/lantiq/switch-api/mac/xgmac_main.c    |  891 +--------------
 .../ethernet/lantiq/switch-api/mac/xgmac_mdio.c    |  122 +-
 .../ethernet/lantiq/switch-api/mac/xgmac_mdio.h    |    3 +-
 .../ethernet/lantiq/switch-api/mac/xgmac_mtl_api.c |   96 +-
 .../net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c |    6 +-
 include/net/switch_api/adap_ops.h                  |   37 +-
 include/net/switch_api/gsw_flow_ops.h              |    6 +-
 include/net/switch_api/gsw_types.h                 |    4 +
 include/net/switch_api/lantiq_gsw.h                |   10 +-
 include/net/switch_api/mac_ops.h                   |  493 ++++++--
 37 files changed, 1903 insertions(+), 3693 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_debug.c b/drivers/net/ethernet/lantiq/switch-api/gsw_debug.c
index e0c45b717d77..9fc94a2f045e 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_debug.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_debug.c
@@ -1067,12 +1067,11 @@ GSW_return_t GSW_Debug_PceQTable(void *cdev, GSW_debug_t *parm)
 
 }
 
-GSW_return_t GSW_XgmacCfg(void *cdev, GSW_MAC_cfg_t *mac_cfg)
+GSW_return_t GSW_XgmacCfg(void *cdev, GSW_MAC_Cli_t *mac_cfg)
 {
 	struct mac_ops *ops = NULL;
-	u8 *argv[10];
-	int i = 0;
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	int ret = 0;
 
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
@@ -1092,21 +1091,16 @@ GSW_return_t GSW_XgmacCfg(void *cdev, GSW_MAC_cfg_t *mac_cfg)
 		return GSW_statusErr;
 	}
 
-	for (i = 0; i < mac_cfg->argc; i++)
-		argv[i] = mac_cfg->argv[i];
-
-
-	ops->xgmac_cli(mac_cfg->argc, argv);
+	ret = ops->xgmac_cli(mac_cfg);
 
-	return GSW_statusOk;
+	return ret;
 }
 
-GSW_return_t GSW_GswssCfg(void *cdev, GSW_MAC_cfg_t *adap_cfg)
+GSW_return_t GSW_GswssCfg(void *cdev, GSW_MAC_Cli_t *mac_cfg)
 {
 	struct adap_ops *ops = NULL;
-	u8 *argv[10];
-	int i = 0;
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	int ret = 0;
 
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
@@ -1126,19 +1120,15 @@ GSW_return_t GSW_GswssCfg(void *cdev, GSW_MAC_cfg_t *adap_cfg)
 		return GSW_statusErr;
 	}
 
-	for (i = 0; i < adap_cfg->argc; i++)
-		argv[i] = adap_cfg->argv[i];
+	ret = ops->ss_cli(mac_cfg);
 
-	ops->ss_cli(adap_cfg->argc, argv);
-
-	return GSW_statusOk;
+	return ret;
 }
 
-GSW_return_t GSW_LmacCfg(void *cdev, GSW_MAC_cfg_t *lmac_cfg)
+GSW_return_t GSW_LmacCfg(void *cdev, GSW_MAC_Cli_t *mac_cfg)
 {
 	struct mac_ops *ops = NULL;
-	u8 *argv[10];
-	int i = 0;
+	int ret = 0;
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
 
 	if (gswdev == NULL) {
@@ -1158,23 +1148,20 @@ GSW_return_t GSW_LmacCfg(void *cdev, GSW_MAC_cfg_t *lmac_cfg)
 		return GSW_statusErr;
 	}
 
-	for (i = 0; i < lmac_cfg->argc; i++)
-		argv[i] = lmac_cfg->argv[i];
+	ret = ops->lmac_cli(mac_cfg);
 
-	ops->lmac_cli(lmac_cfg->argc, argv);
-
-	return GSW_statusOk;
+	return ret;
 }
 
+
 GSW_return_t GSW_MacsecCfg(void *cdev, GSW_MAC_cfg_t *macsec_cfg)
 {
-
-	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
-#if 0	
+#if 0
 	u8 *argv[10];
 	int i = 0;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
 	struct macsec_ops *ops = NULL;
-#endif
+
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return GSW_statusErr;
@@ -1184,22 +1171,22 @@ GSW_return_t GSW_MacsecCfg(void *cdev, GSW_MAC_cfg_t *macsec_cfg)
 		pr_err("Macsec Cfg Supported only in GSWIP3.1 and above\n");
 		return GSW_statusErr;
 	}
-#if 0
-	ops = gsw_get_macsec_ops(0, 0);
+
+	if (macsec_cfg->devid > 1) {
+		pr_err("Invalid Command Name or Params\n");
+		return GSW_statusErr;
+	}
+
+	ops = gsw_get_macsec_ops(macsec_cfg->devid);
 
 	if (!ops) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return GSW_statusErr;
 	}
 
-	for (i = 0; i < macsec_cfg->argc; i++)
-		argv[i] = macsec_cfg->argv[i];
+	ops->macsec_cli(ops, macsec_cfg);
 
-
-	ops->macsec_cli(macsec_cfg->argc, argv);
 #endif
 	return GSW_statusOk;
 }
 
-
-
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c b/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c
index 0f164cb422c4..27ae5d3c8529 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c
@@ -352,7 +352,7 @@ static int pmac_ig_cfg(struct core_ops *ops, u8 pmacid, u8 dpu)
 		ops->gsw_pmac_ops.Pmac_Ig_CfgSet(ops, &ig_cfg);
 	}
 
-	pr_info("PMAC_IG_CFG_SET for PMAC %d %s\n", pmacid,
+	pr_debug("PMAC_IG_CFG_SET for PMAC %d %s\n", pmacid,
 		(dpu == NON_DPU) ? "Non-DPU" : "DPU");
 	return 0;
 }
@@ -485,7 +485,7 @@ static int pmac_eg_cfg(struct core_ops *ops, u8 pmacid, u8 dpu)
 		}
 	}
 
-	pr_info("PMAC_EG_CFG_SET for PMAC %d %s\n", pmacid,
+	pr_debug("PMAC_EG_CFG_SET for PMAC %d %s\n", pmacid,
 		(dpu == NON_DPU) ? "Non-DPU" : "DPU");
 
 	return 0;
@@ -570,7 +570,7 @@ static int pmac_glbl_cfg(struct core_ops *ops, u8 pmacid)
 
 	ops->gsw_pmac_ops.Pmac_Gbl_CfgSet(ops, &glbl_cfg);
 
-	pr_info("PMAC_GLBL_CFG_SET for PMAC %d\n", pmacid);
+	pr_debug("PMAC_GLBL_CFG_SET for PMAC %d\n", pmacid);
 
 	return 0;
 }
@@ -711,7 +711,7 @@ int gsw_pmac_init_nondpu(void)
 	pmac_eg_cfg(ops, 1, NON_DPU);
 	pmac_bp_cfg(ops, NON_DPU);
 
-	pr_info("\n\t GSW PMAC Init Done!!!\n");
+	pr_debug("\n\t GSW PMAC Init Done!!!\n");
 	return 0;
 }
 
@@ -732,7 +732,7 @@ int gsw_pmac_init_dpu(void)
 	pmac_eg_cfg(ops, 1, NON_DPU);
 	pmac_bp_cfg(ops, DPU);
 
-	pr_info("\n\t GSW PMAC Init Done!!!\n");
+	pr_debug("\n\t GSW PMAC Init Done!!!\n");
 	return 0;
 }
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.h b/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.h
index 0406ae05f6e7..14e3ef6da4f5 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.h
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.h
@@ -1,3 +1,12 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
 #ifndef _GSW_DEFCONF_
 #define _GSW_DEFCONF_
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
index 55b3d431a174..6f764fec27a0 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
@@ -10,7 +10,6 @@
 ******************************************************************************/
 
 #ifdef __KERNEL__
-//#include <linux/sched.h>
 #include <linux/jiffies.h>
 #include <linux/timer.h>
 
@@ -2604,52 +2603,50 @@ static void get_gsw_hw_cap(void *cdev)
 
 	if (1) {
 		if (gswdev->gipver == LTQ_GSWIP_3_0)
-			printk("\nGSWIP 3.0 HardWare Capability\n");
+			pr_debug("\nGSWIP 3.0 HardWare Capability\n");
 		else if (gswdev->gipver == LTQ_GSWIP_3_1)
-			printk("\nGSWIP 3.1 HardWare Capability\n");
+			pr_debug("\nGSWIP 3.1 HardWare Capability\n");
 		else
-			printk("\nGSWIP 2.2 HardWare Capability\n");
+			pr_debug("\nGSWIP 2.2 HardWare Capability\n");
 
-		printk("-----------------------------\n\n");
-		printk("Switch Version ID                =  0x%x\n", gswdev->gipver);
-		printk("\n");
-		printk("Number of logical port           =  %d\n", gswdev->pnum);
-		printk("Number of ports including V port =  %d\n", gswdev->tpnum);
+		pr_debug("-----------------------------\n\n");
+		pr_debug("Switch Version ID                =  0x%x\n", gswdev->gipver);
+		pr_debug("\n");
+		pr_debug("Number of logical port           =  %d\n", gswdev->pnum);
+		pr_debug("Number of ports including V port =  %d\n", gswdev->tpnum);
 
 		if (gswdev->gipver == LTQ_GSWIP_3_1) {
-			printk("Number of CTP Port               =  %d\n", gswdev->num_of_ctp);
-			printk("Number of Bridge                 =  %d\n", gswdev->num_of_bridge);
-			printk("Number of Bridge Port            =  %d\n", gswdev->num_of_bridge_port);
-			printk("Number of P-Mapper               =  %d\n", gswdev->num_of_pmapper);
-
-		}
-
-		printk("Number of queues                 =  %d\n", gswdev->num_of_queues);
-		printk("Number of meter instance         =  %d\n", gswdev->num_of_meters);
-		printk("Number of shapers                =  %d\n", gswdev->num_of_shapers);
-		printk("Number of PMAC                   =  %d\n", gswdev->num_of_pmac);
-		printk("Number of CPU PORT               =  %d\n", gswdev->cport);
-		printk("\n");
-		printk("PPPOE table size                 =  %d\n", gswdev->num_of_pppoe);
-		printk("IP packet length table size      =  %d\n", gswdev->ip_pkt_lnt_size);
-		printk("Protocol table size              =  %d\n", gswdev->prot_table_size);
-		printk("MAC DA/SA table size             =  %d\n", gswdev->mac_dasa_table_size);
-		printk("Application table size           =  %d\n", gswdev->app_table_size);
-		printk("IP DA/SA MSB table size          =  %d\n", gswdev->idsmtblsize);
-		printk("IP DA/SA LSB table size          =  %d\n", gswdev->idsltblsize);
-		printk("Multicast table size             =  %d\n", gswdev->mctblsize);
-		printk("Multicast Hw Snoop               =  %d\n", gswdev->mcsthw_snoop);
-		printk("TFLOW table size                 =  %d\n", gswdev->tftblsize);
-		printk("MAC bridge table size            =  %d\n", gswdev->mactblsize);
+			pr_debug("Number of CTP Port               =  %d\n", gswdev->num_of_ctp);
+			pr_debug("Number of Bridge                 =  %d\n", gswdev->num_of_bridge);
+			pr_debug("Number of Bridge Port            =  %d\n", gswdev->num_of_bridge_port);
+			pr_debug("Number of P-Mapper               =  %d\n", gswdev->num_of_pmapper);
+
+		}
+
+		pr_debug("Number of queues                 =  %d\n", gswdev->num_of_queues);
+		pr_debug("Number of meter instance         =  %d\n", gswdev->num_of_meters);
+		pr_debug("Number of shapers                =  %d\n", gswdev->num_of_shapers);
+		pr_debug("Number of PMAC                   =  %d\n", gswdev->num_of_pmac);
+		pr_debug("Number of CPU PORT               =  %d\n", gswdev->cport);
+		pr_debug("\n");
+		pr_debug("PPPOE table size                 =  %d\n", gswdev->num_of_pppoe);
+		pr_debug("IP packet length table size      =  %d\n", gswdev->ip_pkt_lnt_size);
+		pr_debug("Protocol table size              =  %d\n", gswdev->prot_table_size);
+		pr_debug("MAC DA/SA table size             =  %d\n", gswdev->mac_dasa_table_size);
+		pr_debug("Application table size           =  %d\n", gswdev->app_table_size);
+		pr_debug("IP DA/SA MSB table size          =  %d\n", gswdev->idsmtblsize);
+		pr_debug("IP DA/SA LSB table size          =  %d\n", gswdev->idsltblsize);
+		pr_debug("Multicast table size             =  %d\n", gswdev->mctblsize);
+		pr_debug("Multicast Hw Snoop               =  %d\n", gswdev->mcsthw_snoop);
+		pr_debug("TFLOW table size                 =  %d\n", gswdev->tftblsize);
+		pr_debug("MAC bridge table size            =  %d\n", gswdev->mactblsize);
 
 		if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
-			printk("TFLOW RMON counter table Size    =  %d\n", gswdev->num_of_ifrmon);
-			printk("Payload Table Size               =  %d\n", gswdev->pdtblsize);
-			printk("Extend VLAN Table Size table     =  %d\n", gswdev->num_of_extendvlan);
-			printk("VlanFilter table Size            =  %d\n\n", gswdev->num_of_vlanfilter);
+			pr_debug("TFLOW RMON counter table Size    =  %d\n", gswdev->num_of_ifrmon);
+			pr_debug("Payload Table Size               =  %d\n", gswdev->pdtblsize);
+			pr_debug("Extend VLAN Table Size table     =  %d\n", gswdev->num_of_extendvlan);
+			pr_debug("VlanFilter table Size            =  %d\n\n", gswdev->num_of_vlanfilter);
 		}
-
-		printk("\n");
 	}
 
 }
@@ -3175,7 +3172,6 @@ void *ethsw_api_core_init(ethsw_core_init_t *ethcinit)
 	struct core_ops *ops;
 	void *cdev;
 	u32 ret = 0;
-	printk("\n########## Switch Core INIT for device = %d ##########\n", ethcinit->sdev);
 
 #ifdef __KERNEL__
 
@@ -3240,7 +3236,6 @@ void *ethsw_api_core_init(ethsw_core_init_t *ethcinit)
 	PrvData->matimer = DEFAULT_AGING_TIMEOUT;
 	/** Switch Core Base Address */
 	PrvData->gsw_base = ethcinit->gsw_base_addr;
-	printk("Switch Core Base Address = 0x%08x\n", (unsigned int)PrvData->gsw_base);
 
 	/** Get Switch Hardware capablity */
 	get_gsw_hw_cap(cdev);
@@ -3275,7 +3270,7 @@ void *ethsw_api_core_init(ethsw_core_init_t *ethcinit)
 
 	if ((ethcinit->sdev == LTQ_FLOW_DEV_INT) || (ethcinit->sdev == LTQ_FLOW_DEV_INT_R)) {
 		gsw_pmicro_code_init(cdev);
-		printk("Switch API: PCE MicroCode loaded !!\n");
+		pr_debug("Switch API: PCE MicroCode loaded !!\n");
 	}
 
 #endif
@@ -12304,7 +12299,7 @@ GSW_return_t GSW_MDIO_CfgSet(void *cdev, GSW_MDIO_cfg_t *parm)
 	spin_lock_bh(&gswdev->lock_mdio);
 #endif
 
-	pr_err("**********%s:%s:%d*************\n", __FILE__, __func__, __LINE__);
+	pr_debug("**********%s:%s:%d*************\n", __FILE__, __func__, __LINE__);
 
 	if (gswdev->gipver == LTQ_GSWIP_3_0) {
 		gsw_w32(cdev, (GSWT_MDCCFG_1_FREQ_OFFSET + GSW30_TOP_OFFSET),
@@ -14044,7 +14039,7 @@ GSW_return_t GSW_RMON_Clear(void *cdev, GSW_RMON_clear_t *parm)
 
 		/* Reset all port based RMON counter */
 		for (index = 0; index < num_ports; index++) {
-			pr_err("Rmon clear for CTP RX/TX --Logical Port %u\n", index);
+			pr_debug("Rmon clear for CTP RX/TX --Logical Port %u\n", index);
 			gsw_w32(cdev,
 				BM_RMON_CTRL_RAM1_RES_OFFSET + (index * 2),
 				BM_RMON_CTRL_RAM1_RES_SHIFT,
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
index b6bf9387345a..1e4a9a3477b2 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
@@ -1587,7 +1587,7 @@ int gsw_pmicro_code_init(void *cdev)
 	else
 		no_ports = gswdev->pnum;
 
-	printk("Enter PCE micro-code init\n");
+	pr_debug("Enter PCE micro-code init\n");
 
 	/* Disable all physical port  */
 	for (j = 0; j < no_ports; j++) {
@@ -1690,7 +1690,7 @@ int gsw_pmicro_code_init(void *cdev)
 	gsw_w32(cdev, BM_QUEUE_GCTRL_GL_MOD_OFFSET, BM_QUEUE_GCTRL_GL_MOD_SHIFT,
 		Gl_Mod_Size, 0);
 
-	pr_err("Exit PCE micro-code init\n");
+	pr_debug("Exit PCE micro-code init\n");
 	return GSW_statusOk;
 }
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_init.c b/drivers/net/ethernet/lantiq/switch-api/gsw_init.c
index ecb17c8a0f83..e4708a69c1ec 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_init.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_init.c
@@ -917,7 +917,6 @@ int ltq_gsw_api_register(struct platform_device *pdev)
 	gswdev->core_dev = pdev;
 
 	memset(&core_init, 0, sizeof(ethsw_core_init_t));
-	printk("GSWIP devid = %d\n", device_id);
 
 	if (device_id < 0 || device_id >= 2)
 		return -EINVAL;
@@ -931,8 +930,6 @@ int ltq_gsw_api_register(struct platform_device *pdev)
 		return -ENOENT;
 	}
 
-	printk("memres->start = 0x%08x memres->end = 0x%08x\n", memres->start, memres->end);
-
 	/*Enable Switch Power  */
 	clk = devm_clk_get(&pdev->dev, "gate");
 
@@ -943,24 +940,20 @@ int ltq_gsw_api_register(struct platform_device *pdev)
 
 	if (device_id == 0) {
 		addr_gswl = devm_ioremap_resource(&pdev->dev, memres);
-		printk("addr_gswl = 0x%08x\n", (unsigned int)addr_gswl);
 
 		if (IS_ERR(addr_gswl))
 			return PTR_ERR(addr_gswl);
-
-		pr_err("%s:%s:%d (Register l base:0x%08x)\n",
-		       __FILE__, __func__, __LINE__, (u32)addr_gswl);
 	}
 
 	if (device_id == 1) {
 		addr_gswr = devm_ioremap_resource(&pdev->dev, memres);
-		printk("addr_gswr = 0x%08x\n", (unsigned int)addr_gswr);
+		pr_debug("addr_gswr = 0x%p\n", addr_gswr);
 
 		if (IS_ERR(addr_gswr))
 			return PTR_ERR(addr_gswr);
 
-		pr_err("%s:%s:%d (Register r base:0x%08x)\n",
-		       __FILE__, __func__, __LINE__, (u32)addr_gswr);
+		pr_err("%s:%s:%d (Register r base:0x%p)\n",
+		       __FILE__, __func__, __LINE__, addr_gswr);
 	}
 
 
@@ -981,7 +974,6 @@ int ltq_gsw_api_register(struct platform_device *pdev)
 		core_init.sdev = LTQ_FLOW_DEV_INT;
 		core_init.gsw_base_addr = addr_gswl;
 		core_init.pdev = (void *)pdev;
-		printk("addr_gswl = 0x%08x\n", (unsigned int)addr_gswl);
 
 		pEDev0 = ethsw_api_core_init(&core_init);
 
@@ -1219,7 +1211,6 @@ static void __exit ltq_etshw_api_exit(void)
 
 static int ltq_switch_api_probe(struct platform_device *pdev)
 {
-	printk("::::::: SWAPI Reached :::::: \n");
 	ltq_ethsw_api_init(pdev);
 	return 0;
 }
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_init.h b/drivers/net/ethernet/lantiq/switch-api/gsw_init.h
index decdd90eed40..e25237e6a2d7 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_init.h
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_init.h
@@ -68,11 +68,8 @@
 
 #include <net/switch_api/gsw_dev.h>
 #include <linux/netdevice.h>
-#include <net/lantiq_cbm_api.h>
 #include <net/switch_api/gsw_tbl_rw.h>
 
-/*#include <xway/switch-api/lantiq_gsw_routing.h>*/
-/*#include <xway/switch-api/gsw_types.h>*/
 
 #define LTQ_GSW_DEV_MAX 3
 #endif /* KERNEL_MODE */
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_ioctl_wrapper.c b/drivers/net/ethernet/lantiq/switch-api/gsw_ioctl_wrapper.c
index 65ffaaa6ce0f..591a3bc8beb0 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_ioctl_wrapper.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_ioctl_wrapper.c
@@ -9,8 +9,6 @@
     this software module.
 ******************************************************************************/
 
-
-
 #include <gsw_init.h>
 
 ioctl_wrapper_ctx_t *ioctlwrapctx = NULL;
@@ -64,6 +62,7 @@ int gsw_command_search(void *phandle, u32 command,
 	int retvalue;
 	ioctl_cmd_handle_t *pdrv = (ioctl_cmd_handle_t *) phandle;
 	const ltq_lowlevel_fkts_t *pLlTable = pdrv->pLlTable;
+	unsigned long ret;
 	/*  attempt to acquire the semaphore ...*/
 
 	/* This table contains the low-level function for the */
@@ -103,8 +102,8 @@ int gsw_command_search(void *phandle, u32 command,
 
 			if (apitype == ETHSW_API_USERAPP) {
 #ifdef __KERNEL__
-				copy_from_user((void *)(pdrv->paramBuffer),
-					       (const void __user *)arg, (unsigned long)size);
+				ret = copy_from_user((void *)(pdrv->paramBuffer),
+						     (const void __user *)arg, (unsigned long)size);
 				/* Now call the low-level function with the right low-level context */
 				/* handle and the local copy of the parameter structure of 'arg'. */
 
@@ -116,9 +115,9 @@ int gsw_command_search(void *phandle, u32 command,
 				/* Copy parameter to userspace. */
 				/* Only copy back to userspace if really required */
 				if (_IOC_DIR(command) & _IOC_READ) {
-					copy_to_user((void __user *)arg,
-						     (const void *)(pdrv->paramBuffer),
-						     (unsigned long)size);
+					ret = copy_to_user((void __user *)arg,
+							   (const void *)(pdrv->paramBuffer),
+							   (unsigned long)size);
 				}
 
 #endif
@@ -259,7 +258,7 @@ int gsw_api_drv_register(u32 major)
 		return result;
 	}
 
-	pr_info("SWAPI: Registered char device [%s] with major no [%d]\n",
+	pr_debug("SWAPI: Registered char device [%s] with major no [%d]\n",
 		ETHSW_API_DEV_NAME, major);
 	return 0;
 }
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_ll_func.h b/drivers/net/ethernet/lantiq/switch-api/gsw_ll_func.h
index f42c937d0dfc..fe1e97cbedc0 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_ll_func.h
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_ll_func.h
@@ -2113,7 +2113,7 @@ GSW_return_t GSW_MmdDataWrite(void *cdev, GSW_MMD_data_t *parm);
    - GSW_statusOk: if successful
    - An error code in case an error occurs
 */
-GSW_return_t GSW_XgmacCfg(void *cdev, GSW_MAC_cfg_t *parm);
+GSW_return_t GSW_XgmacCfg(void *cdev, GSW_MAC_Cli_t *parm);
 
 /**
    This is the switch API low-level function for
@@ -2131,7 +2131,7 @@ GSW_return_t GSW_XgmacCfg(void *cdev, GSW_MAC_cfg_t *parm);
    - GSW_statusOk: if successful
    - An error code in case an error occurs
 */
-GSW_return_t GSW_GswssCfg(void *cdev, GSW_MAC_cfg_t *parm);
+GSW_return_t GSW_GswssCfg(void *cdev, GSW_MAC_Cli_t *parm);
 
 /**
    This is the switch API low-level function for
@@ -2149,7 +2149,7 @@ GSW_return_t GSW_GswssCfg(void *cdev, GSW_MAC_cfg_t *parm);
    - GSW_statusOk: if successful
    - An error code in case an error occurs
 */
-GSW_return_t GSW_LmacCfg(void *cdev, GSW_MAC_cfg_t *parm);
+GSW_return_t GSW_LmacCfg(void *cdev, GSW_MAC_Cli_t *parm);
 
 /**
    This is the switch API low-level function for
diff --git a/drivers/net/ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c b/drivers/net/ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c
index 721f212adf52..401da46cfaa2 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c
@@ -9,7 +9,6 @@
  * Tree and starts multiple functional drivers for GSWIP.
  ******************************************************************************/
 
-#include <lantiq_soc.h>
 #include <net/switch_api/gsw_dev.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -654,7 +653,7 @@ static int gsw_dev_probe(struct platform_device *pdev)
 	struct reset_control *gswss_rst;
 
 	if (pdev->dev.of_node)
-		printk("Node name %s\n", base_node->full_name);
+		pr_debug("Node name %s\n", base_node->full_name);
 
 	/* parse Device tree */
 	ret = gsw_parse_dt(base_node);
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/Makefile b/drivers/net/ethernet/lantiq/switch-api/mac/Makefile
index 4ed1832637fd..cf22be60675f 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/Makefile
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/Makefile
@@ -11,7 +11,7 @@ mac_driver-objs += xgmac_debug.o
 mac_driver-objs += xgmac_mtl_api.o 
 mac_driver-objs += xgmac_ptp.o 
 mac_driver-objs += xgmac_mac_api.o 
-mac_driver-objs += xgmac_cli.o 
+mac_driver-objs += mac_cli.o 
 mac_driver-objs += xgmac_mdio.o 
 mac_driver-objs += mac_cfg.o 
 mac_driver-objs += gswss_api.o 
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.c b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.c
index 26f86c19242d..b005bd789be1 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.c
@@ -100,6 +100,30 @@ int gswss_cfg0_1588(void *pdev, u32 ref_time, u32 dig_time, u32 bin_time,
 	return 0;
 }
 
+int gswss_get_cfg0_1588(void *pdev, u32 *ref_time, u32 *dig_time,
+			u32 *bin_time, u32 *pps_sel)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 cfg0;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+
+	cfg0 = GSWSS_RGRD(pdata, CFG0_1588);
+
+	*ref_time = MAC_GET_VAL(cfg0, CFG0_1588, REFTIME);
+	*dig_time = MAC_GET_VAL(cfg0, CFG0_1588, DIGTIME);
+	*bin_time = MAC_GET_VAL(cfg0, CFG0_1588, BINTIME);
+	*pps_sel = MAC_GET_VAL(cfg0, CFG0_1588, PPSSEL);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+
+	return 0;
+}
+
 int gswss_cfg1_1588(void *pdev, u32 trig0_sel, u32 trig1_sel, u32 sw_trig)
 {
 	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
@@ -175,78 +199,21 @@ int gswss_cfg1_1588(void *pdev, u32 trig0_sel, u32 trig1_sel, u32 sw_trig)
 	return 0;
 }
 
-int gswss_get_cfg0_1588(void *pdev, u32 *ref_time, u32 *dig_time,
-			u32 *bin_time, u32 *pps_sel)
+int gswss_get_cfg1_1588(void *pdev, u32 *trig1_sel, u32 *trig0_sel,
+			u32 *sw_trig)
 {
-	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
 	u32 cfg0;
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
 
 #ifdef __KERNEL__
 	spin_lock_bh(&pdata->adap_lock);
 #endif
 
-	cfg0 = GSWSS_RGRD(pdata, CFG0_1588);
-
-	*ref_time = MAC_GET_VAL(cfg0, CFG0_1588, REFTIME);
-	*dig_time = MAC_GET_VAL(cfg0, CFG0_1588, DIGTIME);
-	*bin_time = MAC_GET_VAL(cfg0, CFG0_1588, BINTIME);
-	*pps_sel = MAC_GET_VAL(cfg0, CFG0_1588, PPSSEL);
+	cfg0 =  GSWSS_RGRD(pdata, CFG1_1588);
 
-	if (*ref_time == 0)
-		mac_printf("\tREF_TIME: PON_PCS is the master\n");
-	else if (*ref_time == 1)
-		mac_printf("\tREF_TIME: PCIE0 is the master\n");
-	else if (*ref_time == 2)
-		mac_printf("\tREF_TIME: PCIE1 is the master\n");
-	else if (*ref_time == 3)
-		mac_printf("\tREF_TIME: XGMAC2 is the master\n");
-	else if (*ref_time == 4)
-		mac_printf("\tREF_TIME: XGMAC3 is the master\n");
-	else if (*ref_time == 5)
-		mac_printf("\tREF_TIME: XGMAC4 is the master\n");
-
-	if (*dig_time == 0)
-		mac_printf("\tDIG_TIME: PON_PCS is the master\n");
-	else if (*dig_time == 1)
-		mac_printf("\tDIG_TIME: PCIE0 is the master\n");
-	else if (*dig_time == 2)
-		mac_printf("\tDIG_TIME: PCIE1 is the master\n");
-	else if (*dig_time == 3)
-		mac_printf("\tDIG_TIME: XGMAC2 is the master\n");
-	else if (*dig_time == 4)
-		mac_printf("\tDIG_TIME: XGMAC3 is the master\n");
-	else if (*dig_time == 5)
-		mac_printf("\tDIG_TIME: XGMAC4 is the master\n");
-
-	if (*bin_time == 0)
-		mac_printf("\tBIN_TIME: PON_PCS is the master\n");
-	else if (*bin_time == 1)
-		mac_printf("\tBIN_TIME: PCIE0 is the master\n");
-	else if (*bin_time == 2)
-		mac_printf("\tBIN_TIME: PCIE1 is the master\n");
-	else if (*bin_time == 3)
-		mac_printf("\tBIN_TIME: XGMAC2 is the master\n");
-	else if (*bin_time == 4)
-		mac_printf("\tBIN_TIME: XGMAC3 is the master\n");
-	else if (*bin_time == 5)
-		mac_printf("\tBIN_TIME: XGMAC4 is the master\n");
-
-	if (*pps_sel == 0)
-		mac_printf("\tPPS_SEL: PON_PCS is the master\n");
-	else if (*pps_sel == 1)
-		mac_printf("\tPPS_SEL: PCIE0 is the master\n");
-	else if (*pps_sel == 2)
-		mac_printf("\tPPS_SEL: PCIE1 is the master\n");
-	else if (*pps_sel == 3)
-		mac_printf("\tPPS_SEL: XGMAC2 is the master\n");
-	else if (*pps_sel == 4)
-		mac_printf("\tPPS_SEL: XGMAC3 is the master\n");
-	else if (*pps_sel == 5)
-		mac_printf("\tPPS_SEL: XGMAC4 is the master\n");
-	else if (*pps_sel == 6)
-		mac_printf("\tPPS_SEL: PON PPS100US is the master\n");
-	else if (*pps_sel == 7)
-		mac_printf("\tPPS_SEL: Software trigger\n");
+	*trig1_sel = MAC_GET_VAL(cfg0, CFG1_1588, TRIG1SEL);
+	*trig0_sel = MAC_GET_VAL(cfg0, CFG1_1588, TRIG0SEL);
+	*sw_trig = MAC_GET_VAL(cfg0, CFG1_1588, SWTRIG);
 
 #ifdef __KERNEL__
 	spin_unlock_bh(&pdata->adap_lock);
@@ -268,7 +235,7 @@ int gswss_macsec_reset(void *pdev, u32 reset)
 
 	MAC_SET_VAL(macsec_en, MACSEC_EN, RES, reset);
 
-	mac_printf("GSWSS: MACSEC reset : %s\n",
+	mac_dbg("GSWSS: MACSEC reset : %s\n",
 		   reset ? "ENABLED" : "DISABLED");
 
 	GSWSS_RGWR(pdata, MACSEC_EN, macsec_en);
@@ -280,28 +247,6 @@ int gswss_macsec_reset(void *pdev, u32 reset)
 	return 0;
 }
 
-int gswss_get_macsec_reset(void *pdev)
-{
-	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
-	u32 macsec_en, reset;
-
-#ifdef __KERNEL__
-	spin_lock_bh(&pdata->adap_lock);
-#endif
-	macsec_en = GSWSS_RGRD(pdata, MACSEC_EN);
-
-	reset = MAC_GET_VAL(macsec_en, MACSEC_EN, RES);
-
-	mac_printf("GSWSS: MACSEC reset : %s\n",
-		   reset ? "ENABLED" : "DISABLED");
-
-#ifdef __KERNEL__
-	spin_unlock_bh(&pdata->adap_lock);
-#endif
-
-	return 0;
-}
-
 int gswss_switch_ss_reset(void *pdev)
 {
 	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
@@ -313,7 +258,7 @@ int gswss_switch_ss_reset(void *pdev)
 
 	core_reset = GSWSS_RGRD(pdata, GSWIP_CFG);
 
-	mac_printf("Switch Subsys Resetting\n");
+	mac_dbg("Switch Subsys Resetting\n");
 
 	MAC_SET_VAL(core_reset, GSWIP_CFG, SS_HWRES, 1);
 
@@ -326,26 +271,6 @@ int gswss_switch_ss_reset(void *pdev)
 	return 0;
 }
 
-int gswss_get_switch_ss_reset(void *pdev)
-{
-	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
-	u32 core_reset, reset;
-
-#ifdef __KERNEL__
-	spin_lock_bh(&pdata->adap_lock);
-#endif
-	core_reset = GSWSS_RGRD(pdata, GSWIP_CFG);
-	reset = MAC_GET_VAL(core_reset, GSWIP_CFG, SS_HWRES);
-
-	mac_printf("Switch Subsys Reset %s\n",
-		   reset ? "ENABLED" : "DISABLED");
-
-#ifdef __KERNEL__
-	spin_unlock_bh(&pdata->adap_lock);
-#endif
-
-	return 0;
-}
 
 int gswss_set_clkmode(void *pdev, u32 clk_mode)
 {
@@ -358,16 +283,16 @@ int gswss_set_clkmode(void *pdev, u32 clk_mode)
 
 	clk_mode_cfg = GSWSS_RGRD(pdata, GSWIP_CFG);
 
-	mac_printf("GSWSS: Clock Mode Changing to :");
+	mac_dbg("GSWSS: Clock Mode Changing to :");
 
 	if (clk_mode == 0)
-		mac_printf("%s\n", "NCO1 - 666 Mhz");
+		mac_dbg("%s\n", "NCO1 - 666 Mhz");
 	else if (clk_mode == 1)
-		mac_printf("%s\n", "NCO2 - 450 Mhz");
+		mac_dbg("%s\n", "NCO2 - 450 Mhz");
 	else if (clk_mode == 2)
-		mac_printf("%s\n", "Auto Mode (666/450) Mhz");
+		mac_dbg("%s\n", "Auto Mode (666/450) Mhz");
 	else if (clk_mode == 3)
-		mac_printf("%s\n", "Auto Mode (666/450) Mhz");
+		mac_dbg("%s\n", "Auto Mode (666/450) Mhz");
 	else
 		goto end;
 
@@ -383,11 +308,11 @@ int gswss_set_clkmode(void *pdev, u32 clk_mode)
 	return 0;
 }
 
-u32 gswss_get_clkmode(void *pdev)
+int gswss_get_clkmode(void *pdev)
 {
 	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
 	u32 clk_mode_cfg;
-	u32 clk_mode;
+	int clk_mode;
 
 #ifdef __KERNEL__
 	spin_lock_bh(&pdata->adap_lock);
@@ -396,17 +321,6 @@ u32 gswss_get_clkmode(void *pdev)
 	clk_mode_cfg = GSWSS_RGRD(pdata, GSWIP_CFG);
 	clk_mode = MAC_GET_VAL(clk_mode_cfg, GSWIP_CFG, CLK_MD);
 
-	mac_printf("GSWSS: Clock Mode Got :");
-
-	if (clk_mode == 0)
-		mac_printf("%s\n", "NCO1 - 666 Mhz");
-	else if (clk_mode == 1)
-		mac_printf("%s\n", "NCO2 - 450 Mhz");
-	else if (clk_mode == 2)
-		mac_printf("%s\n", "Auto Mode (666/450) Mhz");
-	else if (clk_mode == 3)
-		mac_printf("%s\n", "Auto Mode (666/450) Mhz");
-
 #ifdef __KERNEL__
 	spin_unlock_bh(&pdata->adap_lock);
 #endif
@@ -446,10 +360,11 @@ int gswss_set_corese(void *pdev, u32 val)
 	return 0;
 }
 
-u32 gswss_get_corese(void *pdev)
+int gswss_get_corese(void *pdev)
 {
 	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
-	u32 core_en, enable;
+	u32 core_en;
+	int enable;
 
 #ifdef __KERNEL__
 	spin_lock_bh(&pdata->adap_lock);
@@ -477,11 +392,11 @@ int gswss_set_macsec_to_mac(void *pdev, u32 mac_idx, u32 enable)
 	mac_idx += 2;
 
 	if (enable) {
-		mac_printf("GSWSS: MACSEC enabled to MAC %d data traffic\n",
+		mac_dbg("GSWSS: MACSEC enabled to MAC %d data traffic\n",
 			   mac_idx);
 		MAC_SET_VAL(macsec_en, MACSEC_EN, SEL, mac_idx);
 	} else {
-		mac_printf("GSWSS: MACSEC to MAC mapping : DISABLED\n");
+		mac_dbg("GSWSS: MACSEC to MAC mapping : DISABLED\n");
 		MAC_SET_VAL(macsec_en, MACSEC_EN, SEL, 0);
 	}
 
@@ -512,38 +427,6 @@ int gswss_get_macsec_to_mac(void *pdev)
 	return mac_idx;
 }
 
-int gswss_dbg_macsec_to_mac(void *pdev)
-{
-	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
-	u32 macsec_en, mac_idx;
-
-#ifdef __KERNEL__
-	spin_lock_bh(&pdata->adap_lock);
-#endif
-
-	macsec_en = GSWSS_RGRD(pdata, MACSEC_EN);
-
-	mac_idx = MAC_GET_VAL(macsec_en, MACSEC_EN, SEL);
-
-	if (mac_idx == 0)
-		mac_printf("GSWSS: MACSEC Disabled\n");
-	else if (mac_idx == 2)
-		mac_printf("GSWSS: MACSEC enabled to MAC %d data traffic\n",
-			   mac_idx);
-	else if (mac_idx == 3)
-		mac_printf("GSWSS: MACSEC enabled to MAC %d data traffic\n",
-			   mac_idx);
-	else if (mac_idx == 4)
-		mac_printf("GSWSS: MACSEC enabled to MAC %d data traffic\n",
-			   mac_idx);
-
-#ifdef __KERNEL__
-	spin_unlock_bh(&pdata->adap_lock);
-#endif
-
-	return mac_idx;
-}
-
 /* Calling from Interrupt Context, so no lock required. */
 int gswss_set_interrupt(void *pdev, u32 mod, u32 idx, u32 enable)
 {
@@ -553,7 +436,7 @@ int gswss_set_interrupt(void *pdev, u32 mod, u32 idx, u32 enable)
 
 	switch (mod) {
 	case XGMAC:
-		//mac_printf("XGMAC %d: Interrupt %s\n", idx,
+		//mac_dbg("XGMAC %d: Interrupt %s\n", idx,
 		//	   enable ? "ENABLED" : "DISABLED");
 
 		mac_int_en0 = GSWSS_RGRD(pdata, GSWIPSS_IER0);
@@ -563,7 +446,7 @@ int gswss_set_interrupt(void *pdev, u32 mod, u32 idx, u32 enable)
 		break;
 
 	case LINK:
-		mac_printf("LINK %d: Interrupt %s\n", idx,
+		mac_dbg("LINK %d: Interrupt %s\n", idx,
 			   enable ? "ENABLED" : "DISABLED");
 
 		mac_int_en1 = GSWSS_RGRD(pdata, GSWIPSS_IER1);
@@ -580,63 +463,6 @@ int gswss_set_interrupt(void *pdev, u32 mod, u32 idx, u32 enable)
 	return ret;
 }
 
-int gswss_get_int_en_sts(void *pdev)
-{
-	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
-	u32 reg_val, reg_val1;
-	int ret = 0, i = 0;
-	u32 mac_int_isr0, mac_int_isr1;
-	u32 max_mac = gsw_get_mac_subifcnt(0);
-
-#ifdef __KERNEL__
-	spin_lock_bh(&pdata->adap_lock);
-#endif
-
-	mac_int_isr0 = GSWSS_RGRD(pdata, GSWIPSS_ISR0);
-	mac_int_isr1 = GSWSS_RGRD(pdata, GSWIPSS_ISR1);
-	reg_val = GSWSS_RGRD(pdata, GSWIPSS_IER0);
-	reg_val1 = GSWSS_RGRD(pdata, GSWIPSS_IER1);
-
-	mac_printf("GSWIPSS_IER0 %08x\n", reg_val);
-	mac_printf("GSWIPSS_IER1 %08x\n", reg_val1);
-	mac_printf("GSWIPSS_ISR0 %08x\n", mac_int_isr0);
-	mac_printf("GSWIPSS_ISR1 %08x\n", mac_int_isr1);
-
-	for (i = 0; i < max_mac; i++) {
-		mac_printf("\tXGMAC %d INT EN:  %s\n",
-			   i,
-			   GET_N_BITS(reg_val,
-				      GSWIPSS_IER0_XGMAC2_POS + i, 1) ?
-			   "ENABLED" :
-			   "DISABLED");
-		mac_printf("\tXGMAC %d INT STS: %s\n",
-			   i,
-			   GET_N_BITS(mac_int_isr0,
-				      GSWIPSS_ISR0_XGMAC2_POS + i, 1) ?
-			   "ENABLED" :
-			   "DISABLED");
-
-		mac_printf("\tLINK %d INT EN:  %s\n",
-			   i,
-			   GET_N_BITS(reg_val1,
-				      GSWIPSS_IER1_LINK2_POS + i, 1) ?
-			   "ENABLED" :
-			   "DISABLED");
-		mac_printf("\tLINK %d INT STS: %s\n",
-			   i,
-			   GET_N_BITS(mac_int_isr1,
-				      GSWIPSS_ISR1_LINK2_POS + i, 1) ?
-			   "ENABLED" :
-			   "DISABLED");
-	}
-
-#ifdef __KERNEL__
-	spin_unlock_bh(&pdata->adap_lock);
-#endif
-
-	return ret;
-}
-
 /* Calling from Interrupt Context, so no lock required. */
 int gswss_get_int_stat(void *pdev, u32 mod)
 {
@@ -685,8 +511,8 @@ int gswss_set_nco(void *pdev, u32 val, u32 nco_idx)
 	nco_lsb = (val & 0xFFFF);
 	nco_msb = ((val & 0xFFFF0000) >> 16);
 
-	mac_printf("GSWSS: NCO_LSB Configured to %x\n", nco_lsb);
-	mac_printf("GSWSS: NCO_MSB Configured to %x\n", nco_msb);
+	mac_dbg("GSWSS: NCO_LSB Configured to %x\n", nco_lsb);
+	mac_dbg("GSWSS: NCO_MSB Configured to %x\n", nco_msb);
 
 	GSWSS_RGWR(pdata, lsb_off, nco_lsb);
 	GSWSS_RGWR(pdata, msb_off, nco_msb);
@@ -698,11 +524,12 @@ int gswss_set_nco(void *pdev, u32 val, u32 nco_idx)
 	return ret;
 }
 
-u32 gswss_get_nco(void *pdev, u32 nco_idx)
+int gswss_get_nco(void *pdev, u32 nco_idx)
 {
 	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
-	u32 nco_lsb, nco_msb, nco;
+	u32 nco_lsb, nco_msb;
 	u32 lsb_off, msb_off;
+	int nco;
 
 #ifdef __KERNEL__
 	spin_lock_bh(&pdata->adap_lock);
@@ -719,8 +546,8 @@ u32 gswss_get_nco(void *pdev, u32 nco_idx)
 	nco_lsb = GSWSS_RGRD(pdata, lsb_off);
 	nco_msb = GSWSS_RGRD(pdata, msb_off);
 
-	mac_printf("GSWSS: NCO_LSB Got is %x\n", nco_lsb);
-	mac_printf("GSWSS: NCO_MSB Got is %x\n", nco_msb);
+	mac_dbg("GSWSS: NCO_LSB Got is %x\n", nco_lsb);
+	mac_dbg("GSWSS: NCO_MSB Got is %x\n", nco_msb);
 
 	nco = ((nco_msb << 16) | nco_lsb);
 
@@ -754,7 +581,7 @@ void gswss_init_fn_ptrs(struct adap_ops *adap_ops)
 
 	adap_ops->ss_set_inten = gswss_set_interrupt;
 	adap_ops->ss_get_intstat = gswss_get_int_stat;
-	adap_ops->ss_cli = gswss_main;
+	adap_ops->ss_cli = gswss_cfg_main;
 	adap_ops->ss_rg_rd = gswss_rd_reg;
 	adap_ops->ss_rg_wr = gswss_wr_reg;
 }
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.h b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.h
index 9a802d4c8eb6..a54628708378 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.h
@@ -181,12 +181,18 @@ struct adap_prv_data;
 
 struct adap_prv_data {
 	u32 flags;
-	u32 ss_addr_base;
 #ifdef __KERNEL__
+	/* Adaption layer private data */
+	void __iomem *ss_addr_base;
 	spinlock_t adap_lock;
+#else
+	/* Adaption layer private data */
+	u32 ss_addr_base;
 #endif
 	u32 core_en_cnt;
 	struct adap_ops ops;
+	/* Mac Cli */
+	GSW_MAC_Cli_t *mac_cli;
 };
 
 static inline struct adap_prv_data *GET_ADAP_PDATA(void *pdev)
@@ -205,7 +211,7 @@ static inline u32 GSWSS_RGRD(struct adap_prv_data *pdata, u32 reg)
 #if defined(PC_UTILITY) || defined(CHIPTEST)
 	u32 reg_addr = pdata->ss_addr_base + reg;
 #else
-	volatile void *reg_addr = (volatile void *)pdata->ss_addr_base + reg;
+	void __iomem *reg_addr = (void __iomem *)pdata->ss_addr_base + reg;
 #endif
 
 #if defined(CHIPTEST) && CHIPTEST
@@ -215,7 +221,7 @@ static inline u32 GSWSS_RGRD(struct adap_prv_data *pdata, u32 reg)
 	pcuart_reg_rd(reg_addr, &reg_val);
 #endif
 #ifdef __KERNEL__
-	reg_val = ltq_r32(reg_addr);
+	reg_val = mac_r32(reg_addr);
 #endif
 	return reg_val;
 }
@@ -225,7 +231,7 @@ static inline void GSWSS_RGWR(struct adap_prv_data *pdata, u32 reg, u32 val)
 #if defined(PC_UTILITY) || defined(CHIPTEST)
 	u32 reg_addr = pdata->ss_addr_base + reg;
 #else
-	volatile void *reg_addr = (volatile void *)pdata->ss_addr_base + reg;
+	void __iomem *reg_addr = (void __iomem *)pdata->ss_addr_base + reg;
 #endif
 
 #if defined(CHIPTEST) && CHIPTEST
@@ -235,7 +241,7 @@ static inline void GSWSS_RGWR(struct adap_prv_data *pdata, u32 reg, u32 val)
 	pcuart_reg_wr(reg_addr, val);
 #endif
 #ifdef __KERNEL__
-	ltq_w32(val, reg_addr);
+	mac_w32(val, reg_addr);
 #endif
 }
 
@@ -260,15 +266,16 @@ int gswss_get_int_en_sts(void *pdev);
 void gswss_test_all_reg(void *pdev);
 void gswss_check_reg(void *pdev, u32 reg, char *name, int idx,
 		     u16 set_val, u16 clr_val);
-u32 gswss_get_nco(void *pdev, u32 nco_idx);
+int gswss_get_nco(void *pdev, u32 nco_idx);
 int gswss_get_cfg0_1588(void *pdev, u32 *ref_time, u32 *dig_time,
 			u32 *bin_time, u32 *pps_sel);
-u32 gswss_get_clkmode(void *pdev);
+int gswss_get_clkmode(void *pdev);
 int gswss_get_macsec_to_mac(void *pdev);
 int gswss_dbg_macsec_to_mac(void *pdev);
-u32 gswss_get_corese(void *pdev);
+int gswss_get_corese(void *pdev);
 int gswss_get_switch_ss_reset(void *pdev);
 int gswss_get_macsec_reset(void *pdev);
+int gswss_get_cfg1_1588(void *pdev, u32 *trig1_sel, u32 *trig0_sel, u32 *sw_trig);
 
 void gswss_init_fn_ptrs(struct adap_ops *adap_ops);
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.c b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.c
index cc0e97199639..1f33d165b5fb 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.c
@@ -9,730 +9,30 @@
 
 #include <gswss_mac_api.h>
 
+#if defined(PC_UTILITY) || defined(CHIPTEST)
 struct adap_prv_data adap_priv_data = {
 	.flags = 0,
 	.ss_addr_base = GSWIP_SS_TOP_BASE,
 };
-
-struct _gswss_cfg {
-	char cmdname[256];
-	u8 args;
-	char help[1024];
-};
-
-struct _gswss_cfg gswss_mac_cfg[] = {
-	{
-		"reset",
-		3,
-		"<0/1/2: MacIdx> "
-		"<0/1/2/3/4 XGMAC/LMAC/ADAP> <1/0: Reset/No reset>"
-	},
-	{
-		"macen",
-		2,
-		"<0/1/2: MacIdx> "
-		"<1/0: Enable/Disable>"
-	},
-	{
-		"macif",
-		4,
-		"<0/1/2: MacIdx> <0/1/2: 1G/FE/2.5G> "
-		"<0/1/2/3 MII/GMII/XGMAC_GMII/XGMAC_XGMII>"
-	},
-	{
-		"macop",
-		4,
-		"<0/1/2: MacIdx> <0/1 RX/TX> "
-		"<0/1/2 FCS/SPTAG/TIME> <0/1/2/3 Mode0/Mode1/Mode2/Mode3>"
-	},
-	{
-		"mtu",
-		2,
-		"<0/1/2: MacIdx> "
-		"<mtu size>"
-	},
-	{
-		"txtstamp_fifo",
-		8,
-		"<0/1/2: MacIdx> "
-		"<ttse ostc ost_avail cic sec nsec rec_id>"
-	},
-	{
-		"w",
-		2,
-		"<reg_off> <reg_val>"
-	},
-	{
-		"r",
-		1,
-		"<reg_off>"
-	},
-};
-
-struct _gswss_cfg gswss_adap_cfg[] = {
-	{
-		"int_en",
-		3,
-		"<0/1/2 MacIdx> "
-		"<0/1/2/3 XGMAC/LMAC/ADAP/MACSEC> <1/0: Enable/Disable>"
-	},
-	{
-		"macsec",
-		2,
-		"<0/1/2 MacIdx> "
-		"<1/0: Enable/Disable>"
-	},
-	{
-		"cfg_1588",
-		4,
-		"<ref_time <0/1/2/3/4/5 PON/PCIE0/PCIE1/XGMAC2/XGMAC3/XGMAC4>"
-		"<dig_time <0/1/2/3/4/5 PON/PCIE0/PCIE1/XGMAC2/XGMAC3/XGMAC4>"
-		"<bin_time <0/1/2/3/4/5 PON/PCIE0/PCIE1/XGMAC2/XGMAC3/XGMAC4>"
-		"<pps_sel <0/1/2/3/4/5/6/7 PON/PCIE0/PCIE1/XGMAC2/XGMAC3/XGMAC4/PON100US/SW>"
-	},
-	{
-		"aux_trig",
-		3,
-		"<trig0_sel <0/1/2/3/4/5/6/8/9/10 PON/PCIE0/PCIE1/XGMAC2/XGMAC3/XGMAC4/PON100US/EXTPPS0/EXTPPS1/SW>"
-		"<trig1_sel <0/1/2/3/4/5/6/8/9/10 PON/PCIE0/PCIE1/XGMAC2/XGMAC3/XGMAC4/PON100US/EXTPPS0/EXTPPS1/SW>"
-		"<sw_trig <0/1>"
-	},
-	{
-		"clk_md",
-		1,
-		"<0/1/2/3 666/450/Auto/Auto Mhz >"
-	},
-	{
-		"nco",
-		2,
-		"<val idx>"
-	},
-	{
-		"macsec_rst",
-		1,
-		"<1/0: Reset/No-Reset>"
-	},
-	{
-		"ss_rst",
-		0,
-		"<Reset Switch Core>"
-	},
-	{
-		"corese",
-		1,
-		"<1/0: enable/disable>"
-	},
-};
-
-void gswss_help(void)
-{
-	int i = 0;
-	int num_of_elem = (sizeof(gswss_mac_cfg) / sizeof(struct _gswss_cfg));
-
-	mac_printf("\n----GSWSS MAC Commands----\n\n");
-
-	for (i = 0; i < num_of_elem; i++) {
-		if (gswss_mac_cfg[i].help) {
-#if defined(CHIPTEST) && CHIPTEST
-			mac_printf("gsw gswss %15s \t %s\n",
-				   gswss_mac_cfg[i].cmdname,
-				   gswss_mac_cfg[i].help);
-#else
-			mac_printf("switch_cli gswss %15s \t %s\n",
-				   gswss_mac_cfg[i].cmdname,
-				   gswss_mac_cfg[i].help);
-#endif
-		}
-	}
-
-	mac_printf("\n");
-
-	for (i = 0; i < num_of_elem; i++) {
-		if (gswss_mac_cfg[i].cmdname) {
-#if defined(CHIPTEST) && CHIPTEST
-
-			if (!strcmp(gswss_mac_cfg[i].cmdname,
-				    "txtstamp_fifo")) {
-				mac_printf("gsw gswss get %11s \t"
-					   "<0/1/2: MacIdx> <rec_id>\n",
-					   gswss_mac_cfg[i].cmdname);
-				continue;
-			}
-
-			if (!strcmp(gswss_mac_cfg[i].cmdname, "w") ||
-			    (!strcmp(gswss_mac_cfg[i].cmdname, "r")))
-				continue;
-
-			mac_printf("gsw gswss get %11s \t <0/1/2: MacIdx> \n",
-				   gswss_mac_cfg[i].cmdname);
-#else
-
-			if (!strcmp(gswss_mac_cfg[i].cmdname,
-				    "txtstamp_fifo")) {
-				mac_printf("switch_cli gswss get %11s \t"
-					   "<0/1/2: MacIdx> <rec_id>\n",
-					   gswss_mac_cfg[i].cmdname);
-				continue;
-			}
-
-			if (!strcmp(gswss_mac_cfg[i].cmdname, "w") ||
-			    (!strcmp(gswss_mac_cfg[i].cmdname, "r")))
-				continue;
-
-			mac_printf("switch_cli gswss get %11s \t"
-				   "<0/1/2: MacIdx> \n",
-				   gswss_mac_cfg[i].cmdname);
 #endif
-		}
-	}
-
-	num_of_elem = (sizeof(gswss_adap_cfg) / sizeof(struct _gswss_cfg));
-
-	mac_printf("\n----GSWSS Adaption Commands----\n\n");
-
-	for (i = 0; i < num_of_elem; i++) {
-		if (gswss_adap_cfg[i].help) {
-#if defined(CHIPTEST) && CHIPTEST
-			mac_printf("gsw gswss %15s \t %s\n",
-				   gswss_adap_cfg[i].cmdname,
-				   gswss_adap_cfg[i].help);
-#else
-			mac_printf("switch_cli gswss %15s \t %s\n",
-				   gswss_adap_cfg[i].cmdname,
-				   gswss_adap_cfg[i].help);
-#endif
-		}
-	}
 
-	mac_printf("\n");
-
-	for (i = 0; i < num_of_elem; i++) {
-		if (gswss_adap_cfg[i].cmdname) {
-#if defined(CHIPTEST) && CHIPTEST
-			mac_printf("gsw gswss get %11s \t \n",
-				   gswss_adap_cfg[i].cmdname);
-#else
-			mac_printf("switch_cli gswss get %11s \t \n",
-				   gswss_adap_cfg[i].cmdname);
-#endif
-		}
-	}
-}
-
-int gswss_mac_check_args(int argc, char *argv)
-{
-	int i = 0;
-	int num_of_elem = (sizeof(gswss_mac_cfg) / sizeof(struct _gswss_cfg));
-
-	for (i = 0; i < num_of_elem; i++) {
-		if (!strcmp(argv, gswss_mac_cfg[i].cmdname)) {
-			if (argc != (gswss_mac_cfg[i].args + 3)) {
-				mac_printf("\n--WRONG Command--\n");
-				mac_printf("switch_cli gswss %s %s\n",
-					   gswss_mac_cfg[i].cmdname,
-					   gswss_mac_cfg[i].help);
-				mac_printf("switch_cli gswss get %s"
-					   "<0/1/2: MacIdx> \n",
-					   gswss_mac_cfg[i].cmdname);
-				return -1;
-			}
-		}
-	}
-
-	return 0;
-}
-
-struct mac_ops *gswss_get_mac_ops(char *cmd, char *argv, u32 *start_arg)
-{
-	u32 idx, i = 0;
-	int num_of_elem = (sizeof(gswss_mac_cfg) / sizeof(struct _gswss_cfg));
-	struct mac_ops *ops = NULL;
-	u32 max_mac = 0;
-
-	for (i = 0; i < num_of_elem; i++) {
-		if (!strcmp(cmd, gswss_mac_cfg[i].cmdname))
-			break;
-	}
-
-	max_mac = gsw_get_mac_subifcnt(0);
-
-	idx = mac_nstrtoul(argv,
-			   mac_nstrlen(argv),
-			   start_arg);
-
-	if ((idx < 0) || (idx > max_mac)) {
-		gswss_help();
-		return NULL;
-	}
-
-	ops = gsw_get_mac_ops(0, idx);
-	return ops;
-}
-
-int gswss_adap_check_args(int argc, char *argv)
-{
-	int i = 0;
-	int num_of_elem = (sizeof(gswss_adap_cfg) / sizeof(struct _gswss_cfg));
-
-	for (i = 0; i < num_of_elem; i++) {
-		if (!strcmp(argv, gswss_adap_cfg[i].cmdname)) {
-			if (argc != (gswss_adap_cfg[i].args + 3)) {
-				mac_printf("\n--WRONG Command--\n");
-				mac_printf("switch_cli %s\n",
-					   gswss_adap_cfg[i].help);
-				mac_printf("switch_cli gswss get %s\n",
-					   gswss_adap_cfg[i].cmdname);
-				return -1;
-			}
-		}
-	}
-
-	return 0;
-}
-
-void gswss_wr_reg(void *pdev, u32 reg_off, u32 reg_val)
+int gswss_wr_reg(void *pdev, u32 reg_off, u32 reg_val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 
-	mac_printf("\tREG offset: 0x%04x\n\tData: %08X\n", reg_off,
-		   reg_val);
-
 	GSWSS_MAC_RGWR(pdata, reg_off, reg_val);
+
+	return 0;
 }
 
-u32 gswss_rd_reg(void *pdev, u32 reg_off)
+int gswss_rd_reg(void *pdev, u32 reg_off)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *param = pdata->mac_cli;
 
-	pdata->reg_val = GSWSS_MAC_RGRD(pdata, reg_off);
-
-	mac_printf("\tREG offset: 0x%04x\n\tData: %08X\n", reg_off,
-		   pdata->reg_val);
+	param->val[0] = GSWSS_MAC_RGRD(pdata, reg_off);
 
-	return pdata->reg_val;
-}
-
-int gswss_main(u32 argc, u8 *argv[])
-{
-	u32 start_arg = 0;
-	u32 idx;
-	u32 mod, val;
-	u32 mac_idx;
-	u32 speed;
-	u32 dir, oper;
-	u32 mtu;
-	u32 enable, rec_id;
-	u32 ref_time, dig_time, bin_time, pps_sel;
-	struct mac_ops *ops = NULL;
-	struct adap_ops *adap_ops = gsw_get_adap_ops(0);
-	u32 reg_off, reg_val;
-	struct mac_fifo_entry f_entry;
-	u32 trig1_sel, trig0_sel, sw_trig;
-
-	start_arg++;
-	start_arg++;
-
-	if (argc <= 2) {
-		gswss_help();
-		goto end;
-	}
-
-	if (!strcmp(argv[start_arg], "-help")) {
-		gswss_help();
-		goto end;
-	}
-
-	if (!strcmp(argv[start_arg], "w")) {
-		start_arg++;
-
-		ops = gsw_get_mac_ops(0, 0);
-
-		reg_off = mac_nstrtoul(argv[start_arg],
-				       mac_nstrlen(argv[start_arg]),
-				       &start_arg);
-		reg_val = mac_nstrtoul(argv[start_arg],
-				       mac_nstrlen(argv[start_arg]),
-				       &start_arg);
-		gswss_wr_reg(ops, reg_off, reg_val);
-
-		goto end;
-	}
-
-	if (!strcmp(argv[start_arg], "r")) {
-		start_arg++;
-
-		ops = gsw_get_mac_ops(0, 0);
-
-		reg_off = mac_nstrtoul(argv[start_arg],
-				       mac_nstrlen(argv[start_arg]),
-				       &start_arg);
-
-		gswss_rd_reg(ops, reg_off);
-
-		goto end;
-	}
-
-	if (!strcmp(argv[start_arg], "get")) {
-		start_arg++;
-
-		if (!strcmp(argv[start_arg], "reset")) {
-			start_arg++;
-
-			ops = gswss_get_mac_ops(argv[start_arg - 1],
-						argv[start_arg],
-						&start_arg);
-
-			if (!ops)
-				return -1;
-
-			gswss_get_mac_reset(ops);
-		} else if (!strcmp(argv[start_arg], "macen")) {
-			start_arg++;
-			ops = gswss_get_mac_ops(argv[start_arg - 1],
-						argv[start_arg],
-						&start_arg);
-
-			if (!ops)
-				return -1;
-
-			gswss_get_mac_en(ops);
-		} else if (!strcmp(argv[start_arg], "int_en")) {
-			start_arg++;
-			gswss_get_int_en_sts(adap_ops);
-		} else if (!strcmp(argv[start_arg], "macif")) {
-			start_arg++;
-			ops = gswss_get_mac_ops(argv[start_arg - 1],
-						argv[start_arg],
-						&start_arg);
-
-			if (!ops)
-				return -1;
-
-			gswss_get_macif(ops);
-		} else if (!strcmp(argv[start_arg], "macop")) {
-			start_arg++;
-			ops = gswss_get_mac_ops(argv[start_arg - 1],
-						argv[start_arg],
-						&start_arg);
-
-			if (!ops)
-				return -1;
-
-			gswss_get_macop(ops);
-		} else if (!strcmp(argv[start_arg], "mtu")) {
-			start_arg++;
-			ops = gswss_get_mac_ops(argv[start_arg - 1],
-						argv[start_arg],
-						&start_arg);
-
-			if (!ops)
-				return -1;
-
-			gswss_get_mtu(ops);
-		} else if (!strcmp(argv[start_arg], "txtstamp_fifo")) {
-			start_arg++;
-
-#ifdef __KERNEL__
-
-			if (argc != 6) {
-				mac_printf("switch_cli gswss get txtstamp_fifo"
-					   "<0/1/2: MacIdx> rec_id\n");
-				return -1;
-			}
-
-#endif
-			ops = gswss_get_mac_ops(argv[start_arg - 1],
-						argv[start_arg],
-						&start_arg);
-
-			if (!ops)
-				return -1;
-
-			rec_id = mac_nstrtoul(argv[start_arg],
-					      mac_nstrlen(argv[start_arg]),
-					      &start_arg);
-
-			gswss_get_txtstamp_fifo(ops, rec_id, &f_entry);
-		} else if (!strcmp(argv[start_arg], "phymode")) {
-			start_arg++;
-			ops = gswss_get_mac_ops(argv[start_arg - 1],
-						argv[start_arg],
-						&start_arg);
-
-			if (!ops)
-				return -1;
-
-			gswss_get_phy2mode(ops);
-		} else if (!strcmp(argv[start_arg], "macsec")) {
-			gswss_dbg_macsec_to_mac(adap_ops);
-		} else if (!strcmp(argv[start_arg], "cfg_1588")) {
-			gswss_get_cfg0_1588(adap_ops,
-					    &ref_time,
-					    &dig_time,
-					    &bin_time,
-					    &pps_sel);
-		} else if (!strcmp(argv[start_arg], "clk_md")) {
-			gswss_get_clkmode(adap_ops);
-		} else if (!strcmp(argv[start_arg], "nco")) {
-			gswss_get_nco(adap_ops, 0);
-		} else if (!strcmp(argv[start_arg], "macsec_rst")) {
-			gswss_get_macsec_reset(adap_ops);
-		} else if (!strcmp(argv[start_arg], "ss_rst")) {
-			gswss_get_switch_ss_reset(adap_ops);
-		} else if (!strcmp(argv[start_arg], "corese")) {
-			enable = gswss_get_corese(adap_ops);
-			mac_printf("Switch Core: %s\n", enable ? "ENABLED" :
-				   "DISABLED");
-		} else {
-			gswss_help();
-		}
-	} else {
-		if (gswss_mac_check_args(argc, argv[start_arg]) < 0)
-			return -1;
-
-		if (gswss_adap_check_args(argc, argv[start_arg]) < 0)
-			return -1;
-
-		if (!strcmp(argv[start_arg], "reset")) {
-			start_arg++;
-			ops = gswss_get_mac_ops(argv[start_arg - 1],
-						argv[start_arg],
-						&start_arg);
-
-			if (!ops)
-				return -1;
-
-			mod = mac_nstrtoul(argv[start_arg],
-					   mac_nstrlen(argv[start_arg]),
-					   &start_arg);
-			val = mac_nstrtoul(argv[start_arg],
-					   mac_nstrlen(argv[start_arg]),
-					   &start_arg);
-
-			if (mod == XGMAC)
-				gswss_xgmac_reset(ops, val);
-			else if (mod == LMAC)
-				gswss_lmac_reset(ops, val);
-			else if (mod == ADAP)
-				gswss_adap_reset(ops, val);
-		} else if (!strcmp(argv[start_arg], "macsec_rst")) {
-			start_arg++;
-			val = mac_nstrtoul(argv[start_arg],
-					   mac_nstrlen(argv[start_arg]),
-					   &start_arg);
-			gswss_macsec_reset(adap_ops, val);
-		} else if (!strcmp(argv[start_arg], "ss_rst")) {
-			start_arg++;
-			gswss_switch_ss_reset(adap_ops);
-		} else if (!strcmp(argv[start_arg], "macen")) {
-			start_arg++;
-			ops = gswss_get_mac_ops(argv[start_arg - 1],
-						argv[start_arg],
-						&start_arg);
-
-			if (!ops)
-				return -1;
-
-			val = mac_nstrtoul(argv[start_arg],
-					   mac_nstrlen(argv[start_arg]),
-					   &start_arg);
-			gswss_mac_enable(ops, val);
-		} else if (!strcmp(argv[start_arg], "int_en")) {
-			start_arg++;
-
-			mod = mac_nstrtoul(argv[start_arg],
-					   mac_nstrlen(argv[start_arg]),
-					   &start_arg);
-			idx = mac_nstrtoul(argv[start_arg],
-					   mac_nstrlen(argv[start_arg]),
-					   &start_arg);
-			val = mac_nstrtoul(argv[start_arg],
-					   mac_nstrlen(argv[start_arg]),
-					   &start_arg);
-			gswss_set_interrupt(adap_ops, mod, idx, val);
-
-		} else if (!strcmp(argv[start_arg], "macif")) {
-			start_arg++;
-			ops = gswss_get_mac_ops(argv[start_arg - 1],
-						argv[start_arg],
-						&start_arg);
-
-			if (!ops)
-				return -1;
-
-			speed = mac_nstrtoul(argv[start_arg],
-					     mac_nstrlen(argv[start_arg]),
-					     &start_arg);
-			val = mac_nstrtoul(argv[start_arg],
-					   mac_nstrlen(argv[start_arg]),
-					   &start_arg);
-
-			if (speed == 0)
-				gswss_set_1g_intf(ops, val);
-			else if (speed == 1)
-				gswss_set_fe_intf(ops, val);
-			else if (speed == 2)
-				gswss_set_2G5_intf(ops, val);
-		} else if (!strcmp(argv[start_arg], "macop")) {
-			start_arg++;
-			ops = gswss_get_mac_ops(argv[start_arg - 1],
-						argv[start_arg],
-						&start_arg);
-
-			if (!ops)
-				return -1;
-
-			dir = mac_nstrtoul(argv[start_arg],
-					   mac_nstrlen(argv[start_arg]),
-					   &start_arg);
-			oper = mac_nstrtoul(argv[start_arg],
-					    mac_nstrlen(argv[start_arg]),
-					    &start_arg);
-			val = mac_nstrtoul(argv[start_arg],
-					   mac_nstrlen(argv[start_arg]),
-					   &start_arg);
-
-			if (dir == RX) {
-				if (oper == 0)
-					gswss_set_mac_rxfcs_op(ops, val);
-				else if (oper == 1)
-					gswss_set_mac_rxsptag_op(ops, val);
-				else if (oper == 2)
-					gswss_set_mac_rxtime_op(ops, val);
-			} else if (dir == TX) {
-				if (oper == 0) {
-					if (val == 0 || val == 1)
-						gswss_set_mac_txfcs_ins_op(ops,
-									   val);
-					else if (val == 2 || val == 3)
-						gswss_set_mac_txfcs_rm_op(ops,
-									  val - 2);
-				} else if (oper == 1) {
-					gswss_set_mac_txsptag_op(ops, val);
-				}
-			}
-		} else if (!strcmp(argv[start_arg], "mtu")) {
-			start_arg++;
-			ops = gswss_get_mac_ops(argv[start_arg - 1],
-						argv[start_arg],
-						&start_arg);
-
-			if (!ops)
-				return -1;
-
-			mtu = mac_nstrtoul(argv[start_arg],
-					   mac_nstrlen(argv[start_arg]),
-					   &start_arg);
-			gswss_set_mtu(ops, mtu);
-		} else if (!strcmp(argv[start_arg], "txtstamp_fifo")) {
-			start_arg++;
-			ops = gswss_get_mac_ops(argv[start_arg - 1],
-						argv[start_arg],
-						&start_arg);
-
-			if (!ops)
-				return -1;
-
-			f_entry.ttse = mac_nstrtoul(argv[start_arg],
-						    mac_nstrlen(argv[start_arg]),
-						    &start_arg);
-			f_entry.ostc = mac_nstrtoul(argv[start_arg],
-						    mac_nstrlen(argv[start_arg]),
-						    &start_arg);
-			f_entry.ostpa = mac_nstrtoul(argv[start_arg],
-						     mac_nstrlen(argv[start_arg]),
-						     &start_arg);
-			f_entry.cic = mac_nstrtoul(argv[start_arg],
-						   mac_nstrlen(argv[start_arg]),
-						   &start_arg);
-			f_entry.ttsl = mac_nstrtoul(argv[start_arg],
-						    mac_nstrlen(argv[start_arg]),
-						    &start_arg);
-			f_entry.ttsh = mac_nstrtoul(argv[start_arg],
-						    mac_nstrlen(argv[start_arg]),
-						    &start_arg);
-			f_entry.rec_id = mac_nstrtoul(argv[start_arg],
-						      mac_nstrlen(argv[start_arg]),
-						      &start_arg);
-			gswss_set_txtstamp_fifo(ops, &f_entry);
-		} else if (!strcmp(argv[start_arg], "nco")) {
-			start_arg++;
-
-			val = mac_nstrtoul(argv[start_arg],
-					   mac_nstrlen(argv[start_arg]),
-					   &start_arg);
-			idx = mac_nstrtoul(argv[start_arg],
-					   mac_nstrlen(argv[start_arg]),
-					   &start_arg);
-
-			gswss_set_nco(adap_ops, val, idx);
-		} else if (!strcmp(argv[start_arg], "macsec")) {
-			start_arg++;
-
-			mac_idx = mac_nstrtoul(argv[start_arg],
-					       mac_nstrlen(argv[start_arg]),
-					       &start_arg);
-			enable = mac_nstrtoul(argv[start_arg],
-					      mac_nstrlen(argv[start_arg]),
-					      &start_arg);
-
-			gswss_set_macsec_to_mac(adap_ops,
-						mac_idx, enable);
-		} else if (!strcmp(argv[start_arg], "corese")) {
-			start_arg++;
-
-			enable = mac_nstrtoul(argv[start_arg],
-					      mac_nstrlen(argv[start_arg]),
-					      &start_arg);
-
-			gswss_set_corese(adap_ops, enable);
-		} else if (!strcmp(argv[start_arg], "cfg_1588")) {
-			start_arg++;
-
-			ref_time = mac_nstrtoul(argv[start_arg],
-						mac_nstrlen(argv[start_arg]),
-						&start_arg);
-			dig_time = mac_nstrtoul(argv[start_arg],
-						mac_nstrlen(argv[start_arg]),
-						&start_arg);
-			bin_time = mac_nstrtoul(argv[start_arg],
-						mac_nstrlen(argv[start_arg]),
-						&start_arg);
-			pps_sel = mac_nstrtoul(argv[start_arg],
-					       mac_nstrlen(argv[start_arg]),
-					       &start_arg);
-
-			gswss_cfg0_1588(adap_ops,
-					ref_time, dig_time, bin_time, pps_sel);
-		} else if (!strcmp(argv[start_arg], "clk_md")) {
-			start_arg++;
-
-			val = mac_nstrtoul(argv[start_arg],
-					   mac_nstrlen(argv[start_arg]),
-					   &start_arg);
-
-			gswss_set_clkmode(adap_ops, val);
-		} else if (!strcmp(argv[start_arg], "aux_trig")) {
-			start_arg++;
-
-			trig0_sel = mac_nstrtoul(argv[start_arg],
-						 mac_nstrlen(argv[start_arg]),
-						 &start_arg);
-			trig1_sel = mac_nstrtoul(argv[start_arg],
-						 mac_nstrlen(argv[start_arg]),
-						 &start_arg);
-			sw_trig = mac_nstrtoul(argv[start_arg],
-					       mac_nstrlen(argv[start_arg]),
-					       &start_arg);
-			gswss_cfg1_1588(adap_ops,
-					trig1_sel, trig0_sel, sw_trig);
-		} else {
-			gswss_help();
-		}
-	}
-
-end:
-	return 0;
+	return param->val[0];
 }
 
 int gswss_xgmac_reset(void *pdev, u32 reset)
@@ -744,7 +44,7 @@ int gswss_xgmac_reset(void *pdev, u32 reset)
 
 	MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, XGMAC_RES, reset);
 
-	mac_printf("GSWSS: Resetting XGMAC %d Module\n", pdata->mac_idx);
+	mac_dbg("GSWSS: Resetting XGMAC %d Module\n", pdata->mac_idx);
 
 	GSWSS_MAC_RGWR(pdata, MAC_IF_CFG(pdata->mac_idx), mac_if_cfg);
 
@@ -760,7 +60,7 @@ int gswss_lmac_reset(void *pdev, u32 reset)
 
 	MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, LMAC_RES, reset);
 
-	mac_printf("GSWSS: Resetting LMAC %d Module\n", pdata->mac_idx);
+	mac_dbg("GSWSS: Resetting LMAC %d Module\n", pdata->mac_idx);
 
 	GSWSS_MAC_RGWR(pdata, MAC_IF_CFG(pdata->mac_idx), mac_if_cfg);
 
@@ -776,7 +76,7 @@ int gswss_adap_reset(void *pdev, u32 reset)
 
 	MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, ADAP_RES, reset);
 
-	mac_printf("GSWSS: Resetting ADAP %d Module\n", pdata->mac_idx);
+	mac_dbg("GSWSS: Resetting ADAP %d Module\n", pdata->mac_idx);
 
 	GSWSS_MAC_RGWR(pdata, MAC_IF_CFG(pdata->mac_idx), mac_if_cfg);
 
@@ -792,47 +92,14 @@ int gswss_mac_enable(void *pdev, u32 enable)
 
 	MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, MAC_EN, enable);
 
-	mac_printf("GSWSS: MAC %d: %s\n", pdata->mac_idx,
-		   enable ? "ENABLED" : "DISABLED");
+	mac_dbg("GSWSS: MAC %d: %s\n", pdata->mac_idx,
+		enable ? "ENABLED" : "DISABLED");
 
 	GSWSS_MAC_RGWR(pdata, MAC_IF_CFG(pdata->mac_idx), mac_if_cfg);
 
 	return 0;
 }
 
-int gswss_get_mac_reset(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_if_cfg, reset;
-	int ret = 0, i = 0;
-
-	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
-	reset = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, XGMAC_RES);
-	mac_printf("\tXGMAC %d Reset Bit: %s\n", (i + 2),
-		   reset ? "ENABLED" : "DISABLED");
-	reset = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, LMAC_RES);
-	mac_printf("\tXGMAC %d Reset Bit: %s\n", (i + 2),
-		   reset ? "ENABLED" : "DISABLED");
-	reset = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, ADAP_RES);
-	mac_printf("\tXGMAC %d Reset Bit: %s\n", (i + 2),
-		   reset ? "ENABLED" : "DISABLED");
-
-	return ret;
-}
-
-int gswss_get_mac_en(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_if_cfg, enable;
-	int ret = 0, i = 0;
-
-	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
-	enable = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, MAC_EN);
-	mac_printf("GSWSS: MAC %d: %s\n", i, enable ? "ENABLED" : "DISABLED");
-
-	return ret;
-}
-
 int gswss_set_1g_intf(void *pdev, u32 macif)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
@@ -842,10 +109,10 @@ int gswss_set_1g_intf(void *pdev, u32 macif)
 	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
 
 	if (macif == LMAC_GMII) {
-		mac_printf("GSWSS: MACIF Set to CFG1G with LMAC_GMII\n");
+		mac_dbg("GSWSS: MACIF Set to CFG1G with LMAC_GMII\n");
 		MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, CFG1G, 0);
 	} else if (macif == XGMAC_GMII) {
-		mac_printf("GSWSS: MACIF Set to CFG1G with XGMAC_GMII\n");
+		mac_dbg("GSWSS: MACIF Set to CFG1G with XGMAC_GMII\n");
 		MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, CFG1G, 1);
 	} else {
 		mac_printf("GSWSS: MACIF Set to 1G Wrong Value\n");
@@ -866,10 +133,10 @@ u32 gswss_get_1g_intf(void *pdev)
 	macif = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, CFG1G);
 
 	if (macif == 0) {
-		mac_printf("GSWSS: MACIF got for CFG1G is LMAC_GMII\n");
+		mac_dbg("GSWSS: MACIF got for CFG1G is LMAC_GMII\n");
 		macif = LMAC_GMII;
 	} else if (macif == 1) {
-		mac_printf("GSWSS: MACIF got for CFG1G is XGMAC_GMII\n");
+		mac_dbg("GSWSS: MACIF got for CFG1G is XGMAC_GMII\n");
 		macif = XGMAC_GMII;
 	} else {
 		mac_printf("GSWSS: MACIF got for CFG1G is Wrong Value\n");
@@ -887,10 +154,10 @@ int gswss_set_fe_intf(void *pdev, u32 macif)
 	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
 
 	if (macif == LMAC_MII) {
-		mac_printf("GSWSS: MACIF Set to CFGFE with LMAC_MII\n");
+		mac_dbg("GSWSS: MACIF Set to CFGFE with LMAC_MII\n");
 		MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, CFGFE, 0);
 	} else if (macif == XGMAC_GMII) {
-		mac_printf("GSWSS: MACIF Set to CFGFE with XGMAC_GMII\n");
+		mac_dbg("GSWSS: MACIF Set to CFGFE with XGMAC_GMII\n");
 		MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, CFGFE, 1);
 	} else {
 		mac_printf("GSWSS: MACIF Set to CFGFE Wrong Value\n");
@@ -932,10 +199,10 @@ int gswss_set_2G5_intf(void *pdev, u32 macif)
 	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
 
 	if (macif == XGMAC_GMII) {
-		mac_printf("GSWSS: MACIF Set to 2.5G with XGMAC_GMII\n");
+		mac_dbg("GSWSS: MACIF Set to 2.5G with XGMAC_GMII\n");
 		MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, CFG2G5, 0);
 	} else if (macif == XGMAC_XGMII) {
-		mac_printf("GSWSS: MACIF Set to 2.5G with XGMAC_XGMII\n");
+		mac_dbg("GSWSS: MACIF Set to 2.5G with XGMAC_XGMII\n");
 		MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, CFG2G5, 1);
 	} else {
 		mac_printf("GSWSS: MACIF Set to 2.5G Wrong Value\n");
@@ -968,31 +235,6 @@ u32 gswss_get_2G5_intf(void *pdev)
 	return macif;
 }
 
-void gswss_get_macif(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_if_cfg, val;
-
-	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
-	mac_printf("GSWSS: MAC%d IF_CFG %d\n", (pdata->mac_idx + 2),
-		   mac_if_cfg);
-	val = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, CFG1G);
-	mac_printf("\t1G:            %s\n",
-		   val ?
-		   "XGMAC GMII interface mode is used" :
-		   "Legacy GMAC GMII interface mode is used");
-	val = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, CFGFE);
-	mac_printf("\tFast Ethernet: %s\n",
-		   val ?
-		   "XGMAC GMII interface mode is used" :
-		   "Legacy GMAC MII interface mode is used");
-	val = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, CFG2G5);
-	mac_printf("\t2.5G:          %s\n",
-		   val ?
-		   "XGMAC XGMII interface mode is used" :
-		   "XGMAC GMII interface mode is used");
-}
-
 int gswss_set_mac_txfcs_ins_op(void *pdev, u32 val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
@@ -1001,8 +243,8 @@ int gswss_set_mac_txfcs_ins_op(void *pdev, u32 val)
 	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
 
 	if (MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, TXFCS_INS) != val) {
-		mac_printf("GSWSS: TX FCS INS operation changing to MODE%d\n",
-			   val);
+		mac_dbg("GSWSS: TX FCS INS operation changing to MODE%d\n",
+			val);
 		MAC_SET_VAL(mac_op_cfg, MAC_OP_CFG, TXFCS_INS, val);
 		GSWSS_MAC_RGWR(pdata, MAC_OP_CFG(pdata->mac_idx), mac_op_cfg);
 	}
@@ -1018,8 +260,8 @@ int gswss_set_mac_txfcs_rm_op(void *pdev, u32 val)
 	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
 
 	if (MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, TXFCS_RM) != val) {
-		mac_printf("GSWSS: TX FCS RM operation changing to MODE%d\n",
-			   val);
+		mac_dbg("GSWSS: TX FCS RM operation changing to MODE%d\n",
+			val);
 		MAC_SET_VAL(mac_op_cfg, MAC_OP_CFG, TXFCS_RM, val);
 		GSWSS_MAC_RGWR(pdata, MAC_OP_CFG(pdata->mac_idx), mac_op_cfg);
 	}
@@ -1035,8 +277,8 @@ int gswss_set_mac_rxfcs_op(void *pdev, u32 val)
 	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
 
 	if (MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, RXFCS) != val) {
-		mac_printf("GSWSS: RX FCS operation changing to MODE%d\n",
-			   val);
+		mac_dbg("GSWSS: RX FCS operation changing to MODE%d\n",
+			val);
 		MAC_SET_VAL(mac_op_cfg, MAC_OP_CFG, RXFCS, val);
 		GSWSS_MAC_RGWR(pdata, MAC_OP_CFG(pdata->mac_idx), mac_op_cfg);
 	}
@@ -1052,8 +294,8 @@ int gswss_set_mac_rxsptag_op(void *pdev, u32 val)
 	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
 
 	if (MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, RXSPTAG) != val) {
-		mac_printf("GSWSS: RX SPTAG operation changing to MODE%d\n",
-			   val);
+		mac_dbg("GSWSS: RX SPTAG operation changing to MODE%d\n",
+			val);
 		MAC_SET_VAL(mac_op_cfg, MAC_OP_CFG, RXSPTAG, val);
 		GSWSS_MAC_RGWR(pdata, MAC_OP_CFG(pdata->mac_idx), mac_op_cfg);
 	}
@@ -1069,8 +311,8 @@ int gswss_set_mac_txsptag_op(void *pdev, u32 val)
 	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
 
 	if (MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, TXSPTAG) != val) {
-		mac_printf("GSWSS: TX SPTAG operation changing to MODE%d\n",
-			   val);
+		mac_dbg("GSWSS: TX SPTAG operation changing to MODE%d\n",
+			val);
 		MAC_SET_VAL(mac_op_cfg, MAC_OP_CFG, TXSPTAG, val);
 		GSWSS_MAC_RGWR(pdata, MAC_OP_CFG(pdata->mac_idx), mac_op_cfg);
 	}
@@ -1086,8 +328,8 @@ int gswss_set_mac_rxtime_op(void *pdev, u32 val)
 	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
 
 	if (MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, RXTIME) != val) {
-		mac_printf("GSWSS: RX TIME operation changing to MODE%d\n",
-			   val);
+		mac_dbg("GSWSS: RX TIME operation changing to MODE%d\n",
+			val);
 		MAC_SET_VAL(mac_op_cfg, MAC_OP_CFG, RXTIME, val);
 		GSWSS_MAC_RGWR(pdata, MAC_OP_CFG(pdata->mac_idx), mac_op_cfg);
 	}
@@ -1095,86 +337,76 @@ int gswss_set_mac_rxtime_op(void *pdev, u32 val)
 	return 0;
 }
 
-void gswss_get_macop(void *pdev)
+int gswss_get_mac_txfcs_ins_op(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_op_cfg;
+	int ret = 0;
+
+	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
+	ret = MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, TXFCS_INS);
+
+	return ret;
+}
+
+int gswss_get_mac_txfcs_rm_op(void *pdev)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	int i = 0;
-	u32 mac_op_cfg, val;
+	u32 mac_op_cfg;
+	int ret = 0;
 
 	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
-	mac_printf("GSWSS: MAC%d OP_CFG %d\n", (i + 2), mac_op_cfg);
-	val = MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, TXFCS_INS);
-	mac_printf("TX direction FCS\n");
-
-	if (val == MODE0)
-		mac_printf("\tPacket does not have FCS and FCS "
-			   "is not inserted\n");
-	else if (val == MODE1)
-		mac_printf("\tPacket does not have FCS and FCS "
-			   "is inserted\n");
-	else if (val == MODE2)
-		mac_printf("\tPacket has FCS and FCS is not inserted\n");
-	else if (val == MODE3)
-		mac_printf("\tReserved\n");
-
-	val = MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, RXFCS);
-	mac_printf("RX direction FCS\n");
-
-	if (val == MODE0)
-		mac_printf("\tPacket does not have FCS and FCS "
-			   "is not removed\n");
-	else if (val == MODE1)
-		mac_printf("\tReserved\n");
-	else if (val == MODE2)
-		mac_printf("\tPacket has FCS and FCS is not removed\n");
-	else if (val == MODE3)
-		mac_printf("\tPacket has FCS and FCS is removed\n");
-
-	val = MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, TXSPTAG);
-	mac_printf("TX Special Tag\n");
-
-	if (val == MODE0)
-		mac_printf("\tPacket does not have Special Tag and "
-			   "Special Tag is not removed\n");
-	else if (val == MODE1)
-		mac_printf("\tPacket has Special Tag and "
-			   "Special Tag is replaced\n");
-	else if (val == MODE2)
-		mac_printf("\tPacket has Special Tag and "
-			   "Special Tag is not removed\n");
-	else if (val == MODE3)
-		mac_printf("\tPacket has Special Tag and "
-			   "Special Tag is removed\n");
-
-	val = MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, RXSPTAG);
-	mac_printf("RX Special Tag\n");
-
-	if (val == MODE0)
-		mac_printf("\tPacket does not have Special Tag and "
-			   "Special Tag is not inserted\n");
-	else if (val == MODE1)
-		mac_printf("\tPacket does not have Special Tag and "
-			   "Special Tag is inserted\n");
-	else if (val == MODE2)
-		mac_printf("\tPacket has Special Tag and "
-			   "Special Tag is not inserted\n");
-	else if (val == MODE3)
-		mac_printf("\tReserved\n");
-
-	val = MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, RXTIME);
-	mac_printf("RX Direction Timestamp\n");
-
-	if (val == MODE0)
-		mac_printf("\tPacket does not have time stamp and "
-			   "time stamp is not inserted.\n");
-	else if (val == MODE1)
-		mac_printf("\tPacket doe not have time stamp and "
-			   "time stamp is inserted\n");
-	else if (val == MODE2)
-		mac_printf("\tPacket has time stamp and "
-			   "time stamp is not inserted\n");
-	else if (val == MODE3)
-		mac_printf("\tReserved\n");
+	ret = MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, TXFCS_RM);
+
+	return ret;
+}
+
+int gswss_get_mac_rxfcs_op(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_op_cfg;
+	int ret = 0;
+
+	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
+	ret = MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, RXFCS);
+
+	return ret;
+}
+
+int gswss_get_mac_rxsptag_op(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_op_cfg;
+	int ret = 0;
+
+	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
+	ret = MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, RXSPTAG);
+
+	return ret;
+}
+
+int gswss_get_mac_txsptag_op(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_op_cfg;
+	int ret = 0;
+
+	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
+	ret = MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, TXSPTAG);
+
+	return ret;
+}
+
+int gswss_get_mac_rxtime_op(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_op_cfg;
+	int ret = 0;
+
+	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
+	ret = MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, RXTIME);
+
+	return ret;
 }
 
 int gswss_set_mtu(void *pdev, u32 mtu)
@@ -1183,7 +415,7 @@ int gswss_set_mtu(void *pdev, u32 mtu)
 	int ret = 0;
 
 	if (GSWSS_MAC_RGRD(pdata, MAC_MTU_CFG(pdata->mac_idx)) != mtu) {
-		mac_printf("GSWSS: MTU set to %d\n", mtu);
+		mac_dbg("GSWSS: MTU set to %d\n", mtu);
 		GSWSS_MAC_RGWR(pdata, MAC_MTU_CFG(pdata->mac_idx), mtu);
 	}
 
@@ -1195,7 +427,7 @@ int gswss_get_mtu(void *pdev)
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 mtu = GSWSS_MAC_RGRD(pdata, MAC_MTU_CFG(pdata->mac_idx));
 
-	mac_printf("GSWSS: MAC%d MTU %d\n", (pdata->mac_idx + 2), mtu);
+	mac_dbg("GSWSS: MAC%d MTU %d\n", pdata->mac_idx, mtu);
 
 	return mtu;
 }
@@ -1229,7 +461,7 @@ int gswss_set_txtstamp_fifo(void *pdev,
 	GSWSS_MAC_RGWR(pdata, mac_txtstamp, val);
 
 	mac_dbg("MAC%d: TxTstamp Fifo Record ID %d written\n",
-		(pdata->mac_idx + 2), f_entry->rec_id);
+		pdata->mac_idx, f_entry->rec_id);
 
 	/* Write the entries into the 64 array record_id */
 	gswss_set_txtstamp_access(pdev, 1, f_entry->rec_id);
@@ -1237,8 +469,7 @@ int gswss_set_txtstamp_fifo(void *pdev,
 	return ret;
 }
 
-void gswss_get_txtstamp_fifo(void *pdev,
-			     u32 record_id, struct mac_fifo_entry *f_entry)
+int gswss_get_txtstamp_fifo(void *pdev, u32 record_id, struct mac_fifo_entry *f_entry)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 mac_txtstamp;
@@ -1246,7 +477,7 @@ void gswss_get_txtstamp_fifo(void *pdev,
 	gswss_set_txtstamp_access(pdev, 0, record_id);
 
 	mac_dbg("\nMAC%d: TxTstamp Fifo Record ID %d:\n",
-		(pdata->mac_idx + 2),
+		pdata->mac_idx,
 		record_id);
 
 	mac_txtstamp = GSWSS_MAC_RGRD(pdata, MAC_TXTS_CIC(pdata->mac_idx));
@@ -1265,30 +496,7 @@ void gswss_get_txtstamp_fifo(void *pdev,
 
 	f_entry->rec_id = record_id;
 
-	mac_dbg("\tTTSE: \t%s\n",
-		f_entry->ttse ? "ENABLED" : "DISABLED");
-	mac_dbg("\tOSTC: \t%s\n",
-		f_entry->ostc ? "ENABLED" : "DISABLED");
-	mac_dbg("\tOSTPA: \t%s\n",
-		f_entry->ostpa ? "ENABLED" : "DISABLED");
-
-	if (f_entry->cic == 0)
-		mac_dbg("\tCIC: \t"
-			"DISABLED\n");
-
-	if (f_entry->cic == 1)
-		mac_dbg("\tCIC: \tTime stamp IP Checksum update\n");
-
-	if (f_entry->cic == 2)
-		mac_dbg("\tCIC: \tTime stamp IP and "
-			"Payload Checksum update\n");
-
-	if (f_entry->cic == 3)
-		mac_dbg("\tCIC: \tTime stamp IP, Payload checksum and "
-			"Pseudo header update\n");
-
-	mac_dbg("\tTTSL: \t%d\n", f_entry->ttsl);
-	mac_dbg("\tTTSH: \t%d\n", f_entry->ttsh);
+	return 0;
 }
 
 int gswss_set_txtstamp_access(void *pdev, u32 op_mode, u32 addr)
@@ -1325,13 +533,13 @@ int gswss_set_duplex_mode(void *pdev, u32 val)
 
 	if (MAC_GET_VAL(phy_mode, PHY_MODE, FDUP) != val) {
 		if (val == MAC_AUTO_DPLX)
-			mac_printf("\tGSWSS: Duplex mode set: Auto Mode\n");
+			mac_dbg("\tGSWSS: Duplex mode set: Auto Mode\n");
 		else if (val == MAC_FULL_DPLX)
-			mac_printf("\tGSWSS: Duplex mode set: Full Duplex\n");
+			mac_dbg("\tGSWSS: Duplex mode set: Full Duplex\n");
 		else if (val == MAC_RES_DPLX)
-			mac_printf("\tGSWSS: Duplex mode set: Reserved\n");
+			mac_dbg("\tGSWSS: Duplex mode set: Reserved\n");
 		else if (val == MAC_HALF_DPLX)
-			mac_printf("\tGSWSS: Duplex mode set: Half Duplex\n");
+			mac_dbg("\tGSWSS: Duplex mode set: Half Duplex\n");
 
 		MAC_SET_VAL(phy_mode, PHY_MODE, FDUP, val);
 		GSWSS_MAC_RGWR(pdata, PHY_MODE(pdata->mac_idx), phy_mode);
@@ -1350,13 +558,13 @@ int gswss_get_duplex_mode(void *pdev)
 	val = MAC_GET_VAL(phy_mode, PHY_MODE, FDUP);
 
 	if (val == MAC_AUTO_DPLX)
-		mac_printf("\tGSWSS: Duplex mode got: Auto Mode\n");
+		mac_dbg("\tGSWSS: Duplex mode got: Auto Mode\n");
 	else if (val == MAC_FULL_DPLX)
-		mac_printf("\tGSWSS: Duplex mode got: Full Duplex\n");
+		mac_dbg("\tGSWSS: Duplex mode got: Full Duplex\n");
 	else if (val == MAC_RES_DPLX)
-		mac_printf("\tGSWSS: Duplex mode got: Reserved\n");
+		mac_dbg("\tGSWSS: Duplex mode got: Reserved\n");
 	else if (val == MAC_HALF_DPLX)
-		mac_printf("\tGSWSS: Duplex mode got: Half Duplex\n");
+		mac_dbg("\tGSWSS: Duplex mode got: Half Duplex\n");
 
 	return val;
 }
@@ -1373,21 +581,21 @@ int gswss_set_speed(void *pdev, u8 speed)
 	speed_lsb = GET_N_BITS(speed, 0, 2);
 
 	if (speed == SPEED_10M)
-		mac_printf("\tGSWSS: SPEED    10 Mbps\n");
+		mac_dbg("\tGSWSS: SPEED    10 Mbps\n");
 	else if (speed == SPEED_100M)
-		mac_printf("\tGSWSS: SPEED    100 Mbps\n");
+		mac_dbg("\tGSWSS: SPEED    100 Mbps\n");
 	else if (speed == SPEED_1G)
-		mac_printf("\tGSWSS: SPEED    1 Gbps\n");
+		mac_dbg("\tGSWSS: SPEED    1 Gbps\n");
 	else if (speed == SPEED_10G)
-		mac_printf("\tGSWSS: SPEED    10 Gbps\n");
+		mac_dbg("\tGSWSS: SPEED    10 Gbps\n");
 	else if (speed == SPEED_2G5)
-		mac_printf("\tGSWSS: SPEED    2.5 Gbps\n");
+		mac_dbg("\tGSWSS: SPEED    2.5 Gbps\n");
 	else if (speed == SPEED_5G)
-		mac_printf("\tGSWSS: SPEED    5 Gbps\n");
+		mac_dbg("\tGSWSS: SPEED    5 Gbps\n");
 	else if (speed == SPEED_FLEX)
-		mac_printf("\tGSWSS: SPEED    RESERVED\n");
+		mac_dbg("\tGSWSS: SPEED    RESERVED\n");
 	else if (speed == SPEED_AUTO)
-		mac_printf("\tGSWSS: SPEED    Auto Mode\n");
+		mac_dbg("\tGSWSS: SPEED    Auto Mode\n");
 
 	MAC_SET_VAL(phy_mode, PHY_MODE, SPEEDMSB, speed_msb);
 	MAC_SET_VAL(phy_mode, PHY_MODE, SPEEDLSB, speed_lsb);
@@ -1411,21 +619,21 @@ u8 gswss_get_speed(void *pdev)
 	speed = ((speed_msb << 2) | speed_lsb);
 
 	if (speed == SPEED_10M)
-		mac_printf("\tGSWSS: SPEED Got   10 Mbps\n");
+		mac_dbg("\tGSWSS: SPEED Got   10 Mbps\n");
 	else if (speed == SPEED_100M)
-		mac_printf("\tGSWSS: SPEED Got   100 Mbps\n");
+		mac_dbg("\tGSWSS: SPEED Got   100 Mbps\n");
 	else if (speed == SPEED_1G)
-		mac_printf("\tGSWSS: SPEED Got   1 Gbps\n");
+		mac_dbg("\tGSWSS: SPEED Got   1 Gbps\n");
 	else if (speed == SPEED_10G)
-		mac_printf("\tGSWSS: SPEED Got   10 Gbps\n");
+		mac_dbg("\tGSWSS: SPEED Got   10 Gbps\n");
 	else if (speed == SPEED_2G5)
-		mac_printf("\tGSWSS: SPEED Got   2.5 Gbps\n");
+		mac_dbg("\tGSWSS: SPEED Got   2.5 Gbps\n");
 	else if (speed == SPEED_5G)
-		mac_printf("\tGSWSS: SPEED Got   5 Gbps\n");
+		mac_dbg("\tGSWSS: SPEED Got   5 Gbps\n");
 	else if (speed == SPEED_FLEX)
-		mac_printf("\tGSWSS: SPEED Got   RESERVED\n");
+		mac_dbg("\tGSWSS: SPEED Got   RESERVED\n");
 	else if (speed == SPEED_AUTO)
-		mac_printf("\tGSWSS: SPEED Got   Auto Mode\n");
+		mac_dbg("\tGSWSS: SPEED Got   Auto Mode\n");
 
 	return speed;
 }
@@ -1439,13 +647,13 @@ int gswss_set_linkstatus(void *pdev, u8 linkst)
 
 	if (MAC_GET_VAL(phy_mode, PHY_MODE, LINKST) != linkst) {
 		if (linkst == 0)
-			mac_printf("\tGSWSS: LINK STS: Auto Mode\n");
+			mac_dbg("\tGSWSS: LINK STS: Auto Mode\n");
 		else if (linkst == 1)
-			mac_printf("\tGSWSS: LINK STS: Forced UP\n");
+			mac_dbg("\tGSWSS: LINK STS: Forced UP\n");
 		else if (linkst == 2)
-			mac_printf("\tGSWSS: LINK STS: Forced DOWN\n");
+			mac_dbg("\tGSWSS: LINK STS: Forced DOWN\n");
 		else if (linkst == 3)
-			mac_printf("\tGSWSS: LINK STS: Reserved\n");
+			mac_dbg("\tGSWSS: LINK STS: Reserved\n");
 
 		MAC_SET_VAL(phy_mode, PHY_MODE, LINKST, linkst);
 		GSWSS_MAC_RGWR(pdata, PHY_MODE(pdata->mac_idx), phy_mode);
@@ -1465,13 +673,13 @@ int gswss_get_linkstatus(void *pdev)
 	linkst = MAC_GET_VAL(phy_mode, PHY_MODE, LINKST);
 
 	if (linkst == 0)
-		mac_printf("\tGSWSS: LINK STS Got: Auto Mode\n");
+		mac_dbg("\tGSWSS: LINK STS Got: Auto Mode\n");
 	else if (linkst == 1)
-		mac_printf("\tGSWSS: LINK STS Got: Forced UP\n");
+		mac_dbg("\tGSWSS: LINK STS Got: Forced UP\n");
 	else if (linkst == 2)
-		mac_printf("\tGSWSS: LINK STS Got: Forced DOWN\n");
+		mac_dbg("\tGSWSS: LINK STS Got: Forced DOWN\n");
 	else if (linkst == 3)
-		mac_printf("\tGSWSS: LINK STS Got: Reserved\n");
+		mac_dbg("\tGSWSS: LINK STS Got: Reserved\n");
 
 	return linkst;
 }
@@ -1486,13 +694,13 @@ int gswss_set_flowctrl_tx(void *pdev, u8 flow_ctrl_tx)
 
 	if (MAC_GET_VAL(phy_mode, PHY_MODE, FCONTX) != flow_ctrl_tx) {
 		if (flow_ctrl_tx == 0)
-			mac_printf("\tGSWSS: Flow Ctrl Mode TX: Auto Mode\n");
+			mac_dbg("\tGSWSS: Flow Ctrl Mode TX: Auto Mode\n");
 		else if (flow_ctrl_tx == 1)
-			mac_printf("\tGSWSS: Flow Ctrl Mode TX: ENABLED\n");
+			mac_dbg("\tGSWSS: Flow Ctrl Mode TX: ENABLED\n");
 		else if (flow_ctrl_tx == 2)
-			mac_printf("\tGSWSS: Flow Ctrl Mode TX: Reserved\n");
+			mac_dbg("\tGSWSS: Flow Ctrl Mode TX: Reserved\n");
 		else if (flow_ctrl_tx == 3)
-			mac_printf("\tGSWSS: Flow Ctrl Mode TX: DISABLED\n");
+			mac_dbg("\tGSWSS: Flow Ctrl Mode TX: DISABLED\n");
 
 		MAC_SET_VAL(phy_mode, PHY_MODE, FCONTX, flow_ctrl_tx);
 		GSWSS_MAC_RGWR(pdata, PHY_MODE(pdata->mac_idx), phy_mode);
@@ -1533,13 +741,13 @@ int gswss_set_flowctrl_rx(void *pdev, u8 flow_ctrl_rx)
 
 	if (MAC_GET_VAL(phy_mode, PHY_MODE, FCONRX) != flow_ctrl_rx) {
 		if (flow_ctrl_rx == 0)
-			mac_printf("\tGSWSS: Flow Ctrl Mode RX: Auto Mode\n");
+			mac_dbg("\tGSWSS: Flow Ctrl Mode RX: Auto Mode\n");
 		else if (flow_ctrl_rx == 1)
-			mac_printf("\tGSWSS: Flow Ctrl Mode RX: ENABLED\n");
+			mac_dbg("\tGSWSS: Flow Ctrl Mode RX: ENABLED\n");
 		else if (flow_ctrl_rx == 2)
-			mac_printf("\tGSWSS: Flow Ctrl Mode RX: Reserved\n");
+			mac_dbg("\tGSWSS: Flow Ctrl Mode RX: Reserved\n");
 		else if (flow_ctrl_rx == 3)
-			mac_printf("\tGSWSS: Flow Ctrl Mode RX: DISABLED\n");
+			mac_dbg("\tGSWSS: Flow Ctrl Mode RX: DISABLED\n");
 
 		MAC_SET_VAL(phy_mode, PHY_MODE, FCONRX, flow_ctrl_rx);
 		GSWSS_MAC_RGWR(pdata, PHY_MODE(pdata->mac_idx), phy_mode);
@@ -1570,82 +778,6 @@ u32 gswss_get_flowctrl_rx(void *pdev)
 	return flow_ctrl_rx;
 }
 
-void gswss_get_phy2mode(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	int i = 0;
-	u32 phy_mode;
-	u8 speed_msb, speed_lsb, speed;
-	u8 linkst, fdup, flow_ctrl_tx, flow_ctrl_rx;
-
-	phy_mode = GSWSS_MAC_RGRD(pdata, PHY_MODE(pdata->mac_idx));
-	mac_printf("phy_mode%d %d\n", (i + 2), phy_mode);
-	speed_msb = GET_N_BITS(phy_mode, 15, 1);
-	speed_lsb = GET_N_BITS(phy_mode, 11, 2);
-	speed = (speed_msb << 2) | speed_lsb;
-
-	if (speed == 0)
-		mac_printf("\tGSWSS: SPEED    10 Mbps\n");
-	else if (speed == 1)
-		mac_printf("\tGSWSS: SPEED    100 Mbps\n");
-	else if (speed == 2)
-		mac_printf("\tGSWSS: SPEED    1 Gbps\n");
-	else if (speed == 3)
-		mac_printf("\tGSWSS: SPEED    10 Gbps\n");
-	else if (speed == 4)
-		mac_printf("\tGSWSS: SPEED    2.5 Gbps\n");
-	else if (speed == 5)
-		mac_printf("\tGSWSS: SPEED    5 Gbps\n");
-	else if (speed == 6)
-		mac_printf("\tGSWSS: SPEED    RESERVED\n");
-	else if (speed == 7)
-		mac_printf("\tGSWSS: SPEED    Auto Mode\n");
-
-	linkst = GET_N_BITS(phy_mode, 13, 2);
-
-	if (linkst == 0)
-		mac_printf("\tGSWSS: LINK STS: Auto Mode\n");
-	else if (linkst == 1)
-		mac_printf("\tGSWSS: LINK STS: Forced up\n");
-	else if (linkst == 2)
-		mac_printf("\tGSWSS: LINK STS: Forced down\n");
-	else if (linkst == 3)
-		mac_printf("\tGSWSS: LINK STS: Reserved\n");
-
-	fdup = GET_N_BITS(phy_mode, 9, 2);
-
-	if (fdup == 0)
-		mac_printf("\tGSWSS: Duplex mode set: Auto Mode\n");
-	else if (fdup == 1)
-		mac_printf("\tGSWSS: Duplex mode set: Full Duplex Mode\n");
-	else if (fdup == 2)
-		mac_printf("\tGSWSS: Duplex mode set: Reserved\n");
-	else if (fdup == 3)
-		mac_printf("\tGSWSS: Duplex mode set: Half Duplex Mode\n");
-
-	flow_ctrl_tx = GET_N_BITS(phy_mode, 7, 2);
-
-	if (flow_ctrl_tx == 0)
-		mac_printf("\tGSWSS: Flow Ctrl Mode TX: Auto Mode\n");
-	else if (flow_ctrl_tx == 1)
-		mac_printf("\tGSWSS: Flow Ctrl Mode TX: ENABLED\n");
-	else if (flow_ctrl_tx == 2)
-		mac_printf("\tGSWSS: Flow Ctrl Mode TX: Reserved\n");
-	else if (flow_ctrl_tx == 3)
-		mac_printf("\tGSWSS: Flow Ctrl Mode TX: DISABLED\n");
-
-	flow_ctrl_rx = GET_N_BITS(phy_mode, 7, 2);
-
-	if (flow_ctrl_rx == 0)
-		mac_printf("\tGSWSS: Flow Ctrl Mode RX: Auto Mode\n");
-	else if (flow_ctrl_rx == 1)
-		mac_printf("\tGSWSS: Flow Ctrl Mode RX: ENABLED\n");
-	else if (flow_ctrl_rx == 2)
-		mac_printf("\tGSWSS: Flow Ctrl Mode RX: Reserved\n");
-	else if (flow_ctrl_rx == 3)
-		mac_printf("\tGSWSS: Flow Ctrl Mode RX: DISABLED\n");
-}
-
 int gswss_set_xgmac_tx_disable(void *pdev, u32 val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
@@ -1654,8 +786,8 @@ int gswss_set_xgmac_tx_disable(void *pdev, u32 val)
 	xgmac_ctrl = GSWSS_MAC_RGRD(pdata, XGMAC_CTRL(pdata->mac_idx));
 
 	if (MAC_GET_VAL(xgmac_ctrl, XGMAC_CTRL, DISTX) != val) {
-		mac_printf("\tGSWSS: XGMAC %d TX %s\n", pdata->mac_idx,
-			   val ? "DISABLED" : "NOT DISABLED");
+		mac_dbg("\tGSWSS: XGMAC %d TX %s\n", pdata->mac_idx,
+			val ? "DISABLED" : "NOT DISABLED");
 		MAC_SET_VAL(xgmac_ctrl, XGMAC_CTRL, DISTX, val);
 		GSWSS_MAC_RGWR(pdata, XGMAC_CTRL(pdata->mac_idx), xgmac_ctrl);
 	}
@@ -1671,8 +803,8 @@ int gswss_set_xgmac_rx_disable(void *pdev, u32 val)
 	xgmac_ctrl = GSWSS_MAC_RGRD(pdata, XGMAC_CTRL(pdata->mac_idx));
 
 	if (MAC_GET_VAL(xgmac_ctrl, XGMAC_CTRL, DISRX) != val) {
-		mac_printf("\tGSWSS: XGMAC %d RX %s\n", pdata->mac_idx,
-			   val ? "DISABLED" : "NOT DISABLED");
+		mac_dbg("\tGSWSS: XGMAC %d RX %s\n", pdata->mac_idx,
+			val ? "DISABLED" : "NOT DISABLED");
 		MAC_SET_VAL(xgmac_ctrl, XGMAC_CTRL, DISRX, val);
 		GSWSS_MAC_RGWR(pdata, XGMAC_CTRL(pdata->mac_idx), xgmac_ctrl);
 	}
@@ -1740,17 +872,16 @@ void gswss_get_xgmac_ctrl(void *pdev)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 xgmac_ctrl = 0, distx, disrx, crc_ctrl;
-	u32 mac_idx = 0;
 
 	xgmac_ctrl = GSWSS_MAC_RGRD(pdata, XGMAC_CTRL(pdata->mac_idx));
-	mac_printf("GSWSS: XGMAC CTRL %d %x\n", mac_idx, xgmac_ctrl);
+	mac_printf("GSWSS: XGMAC CTRL %d %x\n", pdata->mac_idx, xgmac_ctrl);
 	distx = MAC_GET_VAL(xgmac_ctrl, XGMAC_CTRL, DISTX);
 	disrx = MAC_GET_VAL(xgmac_ctrl, XGMAC_CTRL, DISRX);
 	crc_ctrl = MAC_GET_VAL(xgmac_ctrl, XGMAC_CTRL, CPC);
 
-	mac_printf("\tGSWSS: XGMAC %d TX %s\n", mac_idx,
+	mac_printf("\tGSWSS: XGMAC %d TX %s\n", pdata->mac_idx,
 		   distx ? "DISABLED" : "NOT DISABLED");
-	mac_printf("\tGSWSS: XGMAC %d RX %s\n", mac_idx,
+	mac_printf("\tGSWSS: XGMAC %d RX %s\n", pdata->mac_idx,
 		   disrx ? "DISABLED" : "NOT DISABLED");
 
 	if (crc_ctrl == 0)
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.h b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.h
index c97b5c2e9f82..1eca9937dacc 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.h
@@ -135,7 +135,7 @@ static inline u32 GSWSS_MAC_RGRD(struct mac_prv_data *pdata, u32 reg)
 #if defined(PC_UTILITY) || defined(CHIPTEST)
 	u32 reg_addr = pdata->ss_addr_base + reg;
 #else
-	volatile void *reg_addr = (volatile void *)pdata->ss_addr_base + reg;
+	void __iomem *reg_addr = (void __iomem *)pdata->ss_addr_base + reg;
 #endif
 
 #if defined(CHIPTEST) && CHIPTEST
@@ -145,7 +145,7 @@ static inline u32 GSWSS_MAC_RGRD(struct mac_prv_data *pdata, u32 reg)
 	pcuart_reg_rd(reg_addr, &reg_val);
 #endif
 #ifdef __KERNEL__
-	reg_val = ltq_r32(reg_addr);
+	reg_val = mac_r32(reg_addr);
 #endif
 	return reg_val;
 }
@@ -156,7 +156,7 @@ static inline void GSWSS_MAC_RGWR(struct mac_prv_data *pdata, u32 reg,
 #if defined(PC_UTILITY) || defined(CHIPTEST)
 	u32 reg_addr = pdata->ss_addr_base + reg;
 #else
-	volatile void *reg_addr = (volatile void *)pdata->ss_addr_base + reg;
+	void __iomem *reg_addr = (void __iomem *)pdata->ss_addr_base + reg;
 #endif
 
 #if defined(CHIPTEST) && CHIPTEST
@@ -166,35 +166,11 @@ static inline void GSWSS_MAC_RGWR(struct mac_prv_data *pdata, u32 reg,
 	pcuart_reg_wr(reg_addr, val);
 #endif
 #ifdef __KERNEL__
-	ltq_w32(val, reg_addr);
+	mac_w32(val, reg_addr);
 #endif
 }
 
 enum {
-	LMAC2 = 0,
-	LMAC3,
-	LMAC4
-};
-
-enum {
-	ADAP2 = 0,
-	ADAP3,
-	ADAP4
-};
-
-enum {
-	MAC2 = 0,
-	MAC3,
-	MAC4
-};
-
-enum {
-	LINK2 = 0,
-	LINK3,
-	LINK4
-};
-
-enum {
 	LMAC_MII = 0,
 	LMAC_GMII,
 	XGMAC_GMII,
@@ -219,13 +195,6 @@ enum {
 };
 
 enum {
-	MODE0 = 0,
-	MODE1,
-	MODE2,
-	MODE3
-};
-
-enum {
 	EEE_CAP_AUTO = 0,
 	EEE_CAP_ON,
 	EEE_CAP_RES,
@@ -267,16 +236,21 @@ u32 gswss_get_fe_intf(void *pdev);
 int gswss_get_duplex_mode(void *pdev);
 int gswss_get_linkstatus(void *pdev);
 void gswss_get_xgmac_ctrl(void *pdev);
-void gswss_get_phy2mode(void *pdev);
-void gswss_get_macop(void *pdev);
-void gswss_get_macif(void *pdev);
+int gswss_get_phy2mode(void *pdev);
+int gswss_get_macop(void *pdev);
+int gswss_get_macif(void *pdev);
 int gswss_get_mac_en(void *pdev);
 int gswss_get_mac_reset(void *pdev);
 int gswss_set_txtstamp_fifo(void *pdev,
 			    struct mac_fifo_entry *f_entry);
-void gswss_get_txtstamp_fifo(void *pdev,
-			     u32 record_id, struct mac_fifo_entry *f_entry);
-
+int gswss_get_txtstamp_fifo(void *pdev, u32 record_id, struct mac_fifo_entry *f_entry);
 int gswss_set_eee_cap(void *pdev, u32 val);
+int gswss_cfg_main(GSW_MAC_Cli_t *params);
+int gswss_get_mac_txfcs_ins_op(void *pdev);
+int gswss_get_mac_txfcs_rm_op(void *pdev);
+int gswss_get_mac_rxfcs_op(void *pdev);
+int gswss_get_mac_rxsptag_op(void *pdev);
+int gswss_get_mac_txsptag_op(void *pdev);
+int gswss_get_mac_rxtime_op(void *pdev);
 
 #endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.c b/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.c
index 3d605104ea39..79a053072fa1 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.c
@@ -12,211 +12,23 @@
 static u32 read_lmac_cnt(void *pdev);
 static u32 write_lmac_cnt(void *pdev, u32 val);
 
-struct _lmac_cfg {
-	char cmdname[256];
-	u8 args;
-	char help[1024];
-};
-
-struct _lmac_cfg lmac_cfg[] = {
-	{
-		"rmon",
-		0,
-		"lmac <0/1/2: Mac Idx> get rmon"
-	},
-	{
-		"all",
-		0,
-		"lmac <0/1/2: Mac Idx> get all"
-	},
-	{
-		"w",
-		2,
-		"lmac <0/1/2: Mac Idx> w <reg_off> <reg_val>"
-	},
-	{
-		"r",
-		1,
-		"lmac <0/1/2: Mac Idx> r <reg_off>"
-	},
-};
-
-void lmac_help(void)
-{
-	int i = 0;
-	int num_of_elem = (sizeof(lmac_cfg) / sizeof(struct _lmac_cfg));
-
-	mac_printf("\n----Legacy MAC Commands----\n\n");
-
-	for (i = 0; i < num_of_elem; i++) {
-		if (lmac_cfg[i].help) {
-#if defined(CHIPTEST) && CHIPTEST
-			mac_printf("gsw %s\n",
-				   lmac_cfg[i].help);
-#else
-			mac_printf("switch_cli %s\n",
-				   lmac_cfg[i].help);
-#endif
-		}
-	}
-}
-
-int lmac_check_args(int argc, char *argv)
-{
-	int i = 0;
-	int num_of_elem = (sizeof(lmac_cfg) / sizeof(struct _lmac_cfg));
-
-	for (i = 0; i < num_of_elem; i++) {
-		if (!strcmp(argv, lmac_cfg[i].cmdname)) {
-			if (argc != (lmac_cfg[i].args + 4)) {
-				mac_printf("\n--WRONG Command--\n");
-				mac_printf("switch_cli %s\n",
-					   lmac_cfg[i].help);
-				return -1;
-			}
-		}
-	}
-
-	return 0;
-}
-
-void lmac_wr_reg(void *pdev, u32 reg_off, u32 reg_val)
+int lmac_wr_reg(void *pdev, u32 reg_off, u32 reg_val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 
-	mac_printf("\tREG offset: 0x%04x\n\tData: %08X\n", reg_off,
-		   reg_val);
-
 	LMAC_RGWR(pdata, reg_off, reg_val);
-}
-
-u32 lmac_rd_reg(void *pdev, u32 reg_off)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 
-	pdata->reg_val = LMAC_RGRD(pdata, reg_off);
-
-	mac_printf("\tREG offset: 0x%04x\n\tData: %08X\n", reg_off,
-		   pdata->reg_val);
-
-	return pdata->reg_val;
+	return 0;
 }
 
-int lmac_main(u32 argc, u8 *argv[])
+int lmac_rd_reg(void *pdev, u32 reg_off)
 {
-	int idx = 0;
-	u32 start_arg = 0;
-	u32 mode_en, lpi_waitg, lpi_waitm;
-	struct mac_ops *ops;
-	u32 reg_off, reg_val;
-
-	start_arg++;
-	start_arg++;
-
-	if (argc <= 2) {
-		lmac_help();
-		goto end;
-	}
-
-	if (!strcmp(argv[start_arg], "-help")) {
-		lmac_help();
-		goto end;
-	}
-
-	idx = mac_nstrtoul(argv[start_arg],
-			   mac_nstrlen(argv[start_arg]),
-			   &start_arg);
-
-	if (idx > 2 || idx < 0) {
-		mac_printf("Give valid lmac index 0/1/2/\n");
-		return -1;
-	}
-
-	ops = gsw_get_mac_ops(0, idx);
-
-	if (!strcmp(argv[start_arg], "r")) {
-		if (0 != lmac_check_args(argc, (char *)argv[start_arg]))
-			return -1;
-
-		start_arg++;
-#if defined(PC_UTILITY) || defined(__KERNEL__)
-
-		if ((strstr(argv[start_arg], "0x")) ||
-		    (strstr(argv[start_arg], "0X")))
-			mac_printf("matches with 0x\n");
-		else
-			mac_printf("Please give the address with "
-				   "0x firmat\n");
-
-#endif
-		reg_off = mac_nstrtoul(argv[start_arg],
-				       mac_nstrlen(argv[start_arg]),
-				       &start_arg);
-		lmac_rd_reg(ops, reg_off);
-
-		goto end;
-	}
-
-	if (!strcmp(argv[start_arg], "w")) {
-		if (0 != lmac_check_args(argc, (char *)argv[start_arg]))
-			return -1;
-
-		start_arg++;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *param = pdata->mac_cli;
 
-#if defined(PC_UTILITY) || defined(__KERNEL__)
+	param->val[0] = LMAC_RGRD(pdata, reg_off);
 
-		if ((strstr(argv[start_arg], "0x")) ||
-		    (strstr(argv[start_arg], "0X")))
-			mac_printf("matches with 0x\n");
-		else
-			mac_printf("Please give the address with "
-				   "0x format\n");
-
-#endif
-		reg_off = mac_nstrtoul(argv[start_arg],
-				       mac_nstrlen(argv[start_arg]),
-				       &start_arg);
-		reg_val = mac_nstrtoul(argv[start_arg],
-				       mac_nstrlen(argv[start_arg]),
-				       &start_arg);
-		lmac_wr_reg(ops, reg_off, reg_val);
-
-		goto end;
-	}
-
-	if (!strcmp(argv[start_arg], "get")) {
-		start_arg++;
-
-		if (!strcmp(argv[start_arg], "rmon")) {
-			lmac_get_rmon();
-			goto end;
-		} else if (!strcmp(argv[start_arg], "all")) {
-			lmac_get_intf_mode(ops);
-			lmac_get_duplex_mode(ops);
-			lmac_get_txfcs(ops);
-			lmac_get_flowcon_mode(ops);
-			lmac_get_ipg(ops);
-			lmac_get_preamble(ops);
-			lmac_get_defermode(ops);
-			lmac_get_jps(ops);
-			lmac_get_loopback(ops);
-			lmac_get_txer(ops);
-			lmac_get_lpimonitor_mode(ops);
-			lmac_get_lpi(ops, &mode_en,
-				     &lpi_waitg, &lpi_waitm);
-			lmac_get_mac_pstat(ops);
-			lmac_get_mac_pisr(ops);
-
-			lmac_get_pauseframe_samode(gsw_get_mac_ops(0, 0));
-		} else {
-			lmac_help();
-		}
-	} else {
-		lmac_help();
-	}
-
-end:
-	return 0;
+	return param->val[0];
 }
 
 int lmac_set_intf_mode(void *pdev, u32 val)
@@ -226,17 +38,17 @@ int lmac_set_intf_mode(void *pdev, u32 val)
 
 	if (MAC_GET_VAL(mac_ctrl0, MAC_CTRL0, GMII) != val) {
 		if (val == 0)
-			mac_printf("LMAC %d Intf: AUTO\n",
-				   pdata->mac_idx);
+			mac_dbg("LMAC %d Intf: AUTO\n",
+				pdata->mac_idx);
 		else if (val == 1)
-			mac_printf("LMAC %d Intf: MII(10/100/200 Mbps)\n",
-				   pdata->mac_idx);
+			mac_dbg("LMAC %d Intf: MII(10/100/200 Mbps)\n",
+				pdata->mac_idx);
 		else if (val == 2)
-			mac_printf("LMAC %d Intf: GMII (1000 Mbps)\n",
-				   pdata->mac_idx);
+			mac_dbg("LMAC %d Intf: GMII (1000 Mbps)\n",
+				pdata->mac_idx);
 		else if (val == 3)
-			mac_printf("LMAC %d Intf: GMII_2G (2000 Mbps)\n",
-				   pdata->mac_idx);
+			mac_dbg("LMAC %d Intf: GMII_2G (2000 Mbps)\n",
+				pdata->mac_idx);
 
 		MAC_SET_VAL(mac_ctrl0, MAC_CTRL0, GMII, val);
 
@@ -246,27 +58,6 @@ int lmac_set_intf_mode(void *pdev, u32 val)
 	return 0;
 }
 
-int lmac_get_intf_mode(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_ctrl0 = LMAC_RGRD(pdata, MAC_CTRL0(pdata->mac_idx));
-	u32 val = 0;
-
-	mac_printf("LMAC %d INTF MODE %08x\n", pdata->mac_idx, mac_ctrl0);
-	val = MAC_GET_VAL(mac_ctrl0, MAC_CTRL0, GMII);
-
-	if (val == 0)
-		mac_printf("\tIntf mode set to : AUTO\n");
-	else if (val == 1)
-		mac_printf("\tIntf mode set to : MII (10/100/200 Mbps)\n");
-	else if (val == 2)
-		mac_printf("\tIntf mode set to : GMII (1000 Mbps)\n");
-	else if (val == 3)
-		mac_printf("\tIntf mode set to : GMII_2G (2000 Mbps)\n");
-
-	return 0;
-}
-
 int lmac_set_duplex_mode(void *pdev, u32 val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
@@ -274,17 +65,17 @@ int lmac_set_duplex_mode(void *pdev, u32 val)
 
 	if (MAC_GET_VAL(mac_ctrl0, MAC_CTRL0, FDUP) != val) {
 		if (val == 0)
-			mac_printf("LMAC %d FDUP set to: AUTO\n",
-				   pdata->mac_idx);
+			mac_dbg("LMAC %d FDUP set to: AUTO\n",
+				pdata->mac_idx);
 		else if (val == 1)
-			mac_printf("LMAC %d FDUP set to: Full Duplex Mode\n",
-				   pdata->mac_idx);
+			mac_dbg("LMAC %d FDUP set to: Full Duplex Mode\n",
+				pdata->mac_idx);
 		else if (val == 2)
-			mac_printf("LMAC %d FDUP set to: Reserved\n",
-				   pdata->mac_idx);
+			mac_dbg("LMAC %d FDUP set to: Reserved\n",
+				pdata->mac_idx);
 		else if (val == 3)
-			mac_printf("LMAC %d FDUP set to: Half Duplex Mode\n",
-				   pdata->mac_idx);
+			mac_dbg("LMAC %d FDUP set to: Half Duplex Mode\n",
+				pdata->mac_idx);
 
 		MAC_SET_VAL(mac_ctrl0, MAC_CTRL0, FDUP, val);
 
@@ -294,28 +85,6 @@ int lmac_set_duplex_mode(void *pdev, u32 val)
 	return 0;
 }
 
-int lmac_get_duplex_mode(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_ctrl0 = LMAC_RGRD(pdata, MAC_CTRL0(pdata->mac_idx));
-	u32 val;
-
-	mac_printf("LMAC %d DUPLEX MODE %08x\n", pdata->mac_idx, mac_ctrl0);
-
-	val = MAC_GET_VAL(mac_ctrl0, MAC_CTRL0, FDUP);
-
-	if (val == 0)
-		mac_printf("\tFDUP mode set to : AUTO\n");
-	else if (val == 1)
-		mac_printf("\tFDUP mode set to : Full Duplex Mode\n");
-	else if (val == 2)
-		mac_printf("\tFDUP mode set to : Reserved\n");
-	else if (val == 3)
-		mac_printf("\tFDUP mode set to : Half Duplex Mode\n");
-
-	return val;
-}
-
 int lmac_set_flowcon_mode(void *pdev, u32 val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
@@ -323,20 +92,20 @@ int lmac_set_flowcon_mode(void *pdev, u32 val)
 
 	if (MAC_GET_VAL(mac_ctrl0, MAC_CTRL0, FCON) != val) {
 		if (val == 0)
-			mac_printf("LMAC %d FCON mode set to : AUTO\n",
-				   pdata->mac_idx);
+			mac_dbg("LMAC %d FCON mode set to : AUTO\n",
+				pdata->mac_idx);
 		else if (val == 1)
-			mac_printf("LMAC %d FCON mode set to : RX only\n",
-				   pdata->mac_idx);
+			mac_dbg("LMAC %d FCON mode set to : RX only\n",
+				pdata->mac_idx);
 		else if (val == 2)
-			mac_printf("LMAC %d FCON mode set to : TX only\n",
-				   pdata->mac_idx);
+			mac_dbg("LMAC %d FCON mode set to : TX only\n",
+				pdata->mac_idx);
 		else if (val == 3)
-			mac_printf("LMAC %d FCON mode set to : RXTX \n",
-				   pdata->mac_idx);
+			mac_dbg("LMAC %d FCON mode set to : RXTX \n",
+				pdata->mac_idx);
 		else if (val == 4)
-			mac_printf("LMAC %d FCON mode set to : DISABLED\n",
-				   pdata->mac_idx);
+			mac_dbg("LMAC %d FCON mode set to : DISABLED\n",
+				pdata->mac_idx);
 
 		MAC_SET_VAL(mac_ctrl0, MAC_CTRL0, FCON, val);
 
@@ -346,39 +115,14 @@ int lmac_set_flowcon_mode(void *pdev, u32 val)
 	return 0;
 }
 
-u32 lmac_get_flowcon_mode(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_ctrl0 = LMAC_RGRD(pdata, MAC_CTRL0(pdata->mac_idx));
-	u32 val;
-
-	mac_printf("LMAC %d FLOWCONTROL MODE %08x\n",
-		   pdata->mac_idx, mac_ctrl0);
-
-	val = MAC_GET_VAL(mac_ctrl0, MAC_CTRL0, FCON);
-
-	if (val == 0)
-		mac_printf("\tFCON mode set to : AUTO\n");
-	else if (val == 1)
-		mac_printf("\tFCON mode set to : Receive only\n");
-	else if (val == 2)
-		mac_printf("\tFCON mode set to : transmit only\n");
-	else if (val == 3)
-		mac_printf("\tFCON mode set to : RXTX\n");
-	else if (val == 4)
-		mac_printf("\tFCON mode set to : DISABLED\n");
-
-	return val;
-}
-
 int lmac_set_txfcs(void *pdev, u32 val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 mac_ctrl0 = LMAC_RGRD(pdata, MAC_CTRL0(pdata->mac_idx));
 
 	if (MAC_GET_VAL(mac_ctrl0, MAC_CTRL0, FCS) != val) {
-		mac_printf("LMAC %d FCS generation : %s\n", pdata->mac_idx,
-			   val ? "ENABLED" : "DISABLED");
+		mac_dbg("LMAC %d FCS generation : %s\n", pdata->mac_idx,
+			val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(mac_ctrl0, MAC_CTRL0, FCS, val);
 
 		LMAC_RGWR(pdata, MAC_CTRL0(pdata->mac_idx), mac_ctrl0);
@@ -387,20 +131,6 @@ int lmac_set_txfcs(void *pdev, u32 val)
 	return 0;
 }
 
-int lmac_get_txfcs(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_ctrl0 = LMAC_RGRD(pdata, MAC_CTRL0(pdata->mac_idx));
-	u32 val;
-
-	mac_printf("LMAC %d FCS %08x\n", pdata->mac_idx, mac_ctrl0);
-
-	val = MAC_GET_VAL(mac_ctrl0, MAC_CTRL0, FCS);
-	mac_printf("\tFCS generation : %s\n", val ? "ENABLED" : "DISABLED");
-
-	return val;
-}
-
 int lmac_set_int(void *pdev, u32 val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
@@ -409,7 +139,7 @@ int lmac_set_int(void *pdev, u32 val)
 	pdata->mac_idx += LMAC_IER_MAC2_POS;
 	SET_N_BITS(lmac_ier, pdata->mac_idx, LMAC_IER_MAC2_WIDTH, val);
 
-	//mac_printf("LMAC %d Interrupt : %s\n", pdata->mac_idx,
+	//mac_dbg("LMAC %d Interrupt : %s\n", pdata->mac_idx,
 	//	   val ? "ENABLED" : "DISABLED");
 	LMAC_RGWR(pdata, LMAC_IER, lmac_ier);
 
@@ -605,8 +335,8 @@ int lmac_set_ipg(void *pdev, u32 val)
 	u32 mac_ctrl1 = LMAC_RGRD(pdata, MAC_CTRL1(pdata->mac_idx));
 
 	if (MAC_GET_VAL(mac_ctrl1, MAC_CTRL1, IPG) != val) {
-		mac_printf("LMAC %d IPG set to : %d bytes\n",
-			   pdata->mac_idx, val);
+		mac_dbg("LMAC %d IPG set to : %d bytes\n",
+			pdata->mac_idx, val);
 		MAC_SET_VAL(mac_ctrl1, MAC_CTRL1, IPG, val);
 
 		LMAC_RGWR(pdata, MAC_CTRL1(pdata->mac_idx), mac_ctrl1);
@@ -615,28 +345,14 @@ int lmac_set_ipg(void *pdev, u32 val)
 	return 0;
 }
 
-int lmac_get_ipg(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_ctrl1 = LMAC_RGRD(pdata, MAC_CTRL1(pdata->mac_idx));
-	u32 val;
-
-	mac_printf("LMAC %d IPG %08x\n", pdata->mac_idx, mac_ctrl1);
-
-	val = MAC_GET_VAL(mac_ctrl1, MAC_CTRL1, IPG);
-	mac_printf("\tIPG set to %d : bytes\n", val);
-
-	return val;
-}
-
 int lmac_set_preamble(void *pdev, u32 val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 mac_ctrl1 = LMAC_RGRD(pdata, MAC_CTRL1(pdata->mac_idx));
 
 	if (MAC_GET_VAL(mac_ctrl1, MAC_CTRL1, SHORTPRE) != val) {
-		mac_printf("LMAC %d Preamble is : %s\n", pdata->mac_idx,
-			   val ? "0 byte" : "7 byte");
+		mac_dbg("LMAC %d Preamble is : %s\n", pdata->mac_idx,
+			val ? "0 byte" : "7 byte");
 		MAC_SET_VAL(mac_ctrl1, MAC_CTRL1, SHORTPRE, val);
 
 		LMAC_RGWR(pdata, MAC_CTRL1(pdata->mac_idx), mac_ctrl1);
@@ -645,30 +361,16 @@ int lmac_set_preamble(void *pdev, u32 val)
 	return 0;
 }
 
-int lmac_get_preamble(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_ctrl1 = LMAC_RGRD(pdata, MAC_CTRL1(pdata->mac_idx));
-	u32 val;
-
-	mac_printf("LMAC %d PREAMBLE %08x\n", pdata->mac_idx, mac_ctrl1);
-
-	val = MAC_GET_VAL(mac_ctrl1, MAC_CTRL1, SHORTPRE);
-	mac_printf("\tPreamble is : %s\n", val ? "0 byte" : "7 byte");
-
-	return val;
-}
-
 int lmac_set_defermode(void *pdev, u32 val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 mac_ctrl1 = LMAC_RGRD(pdata, MAC_CTRL1(pdata->mac_idx));
 
 	if (MAC_GET_VAL(mac_ctrl1, MAC_CTRL1, DEFERMODE) != val) {
-		mac_printf("LMAC %d CRS backpressure : %s\n", pdata->mac_idx,
-			   val ?
-			   "Enabled in Full Duplex mode" :
-			   "Enabled in Half Duplex mode");
+		mac_dbg("LMAC %d CRS backpressure : %s\n", pdata->mac_idx,
+			val ?
+			"Enabled in Full Duplex mode" :
+			"Enabled in Half Duplex mode");
 		MAC_SET_VAL(mac_ctrl1, MAC_CTRL1, DEFERMODE, val);
 
 		LMAC_RGWR(pdata, MAC_CTRL1(pdata->mac_idx), mac_ctrl1);
@@ -677,43 +379,26 @@ int lmac_set_defermode(void *pdev, u32 val)
 	return 0;
 }
 
-int lmac_get_defermode(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_ctrl1 = LMAC_RGRD(pdata, MAC_CTRL1(pdata->mac_idx));
-	u32 val;
-
-	mac_printf("LMAC %d DEFERMODE %08x\n", pdata->mac_idx, mac_ctrl1);
-
-	val = MAC_GET_VAL(mac_ctrl1, MAC_CTRL1, DEFERMODE);
-	mac_printf("\tCRS backpressure : %s\n",
-		   val ?
-		   "Enabled in Full Duplex mode" :
-		   "Enabled in Half Duplex mode");
-
-	return val;
-}
-
 int lmac_set_lpi(void *pdev, u32 mode_en, u32 lpi_waitg, u32 lpi_waitm)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 mac_ctrl4 = LMAC_RGRD(pdata, MAC_CTRL4(pdata->mac_idx));
 
 	if (MAC_GET_VAL(mac_ctrl4, MAC_CTRL4, LPIEN) != mode_en) {
-		mac_printf("LMAC %d LPI Mode : %s\n", pdata->mac_idx,
-			   mode_en ? "ENABLED" : "DISABLED");
+		mac_dbg("LMAC %d LPI Mode : %s\n", pdata->mac_idx,
+			mode_en ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(mac_ctrl4, MAC_CTRL4, LPIEN, mode_en);
 	}
 
 	if (MAC_GET_VAL(mac_ctrl4, MAC_CTRL4, WAIT) != lpi_waitm) {
-		mac_printf("LMAC %d LPI Wait time for 100M : %d usec\n",
-			   pdata->mac_idx, lpi_waitm);
+		mac_dbg("LMAC %d LPI Wait time for 100M : %d usec\n",
+			pdata->mac_idx, lpi_waitm);
 		MAC_SET_VAL(mac_ctrl4, MAC_CTRL4, WAIT, lpi_waitm);
 	}
 
 	if (MAC_GET_VAL(mac_ctrl4, MAC_CTRL4, GWAIT) != lpi_waitg) {
-		mac_printf("LMAC %d LPI Wait time for 1G : %d usec\n",
-			   pdata->mac_idx, lpi_waitg);
+		mac_dbg("LMAC %d LPI Wait time for 1G : %d usec\n",
+			pdata->mac_idx, lpi_waitg);
 		MAC_SET_VAL(mac_ctrl4, MAC_CTRL4, GWAIT, lpi_waitg);
 	}
 
@@ -722,45 +407,26 @@ int lmac_set_lpi(void *pdev, u32 mode_en, u32 lpi_waitg, u32 lpi_waitm)
 	return 0;
 }
 
-int lmac_get_lpi(void *pdev, u32 *mode_en, u32 *lpi_waitg, u32 *lpi_waitm)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_ctrl4 = LMAC_RGRD(pdata, MAC_CTRL4(pdata->mac_idx));
-
-	mac_printf("LMAC %d LPI %08x\n", pdata->mac_idx, mac_ctrl4);
-
-	*mode_en = MAC_GET_VAL(mac_ctrl4, MAC_CTRL4, LPIEN);
-	mac_printf("\tLPI Mode : %s\n", *mode_en ? "ENABLED" : "DISABLED");
-
-	*lpi_waitm = MAC_GET_VAL(mac_ctrl4, MAC_CTRL4, WAIT);
-	mac_printf("\tLPI Wait time for 100M : %d usec\n", *lpi_waitm);
-
-	*lpi_waitg = MAC_GET_VAL(mac_ctrl4, MAC_CTRL4, GWAIT);
-	mac_printf("\tLPI Wait time for 1G : %d usec\n", *lpi_waitg);
-
-	return 0;
-}
-
 int lmac_set_jps(void *pdev, u32 pjps_bp, u32 pjps_nobp)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 mac_ctrl5 = LMAC_RGRD(pdata, MAC_CTRL5(pdata->mac_idx));
 
 	if (MAC_GET_VAL(mac_ctrl5, MAC_CTRL5, PJPS_BP) != pjps_bp) {
-		mac_printf("LMAC %d Prolong Jam Pattern Size during "
-			   "backpressure : %s\n",
-			   pdata->mac_idx, pjps_bp ?
-			   "64 bit jam pattern" :
-			   "32 bit jam pattern");
+		mac_dbg("LMAC %d Prolong Jam Pattern Size during "
+			"backpressure : %s\n",
+			pdata->mac_idx, pjps_bp ?
+			"64 bit jam pattern" :
+			"32 bit jam pattern");
 		MAC_SET_VAL(mac_ctrl5, MAC_CTRL5, PJPS_BP, pjps_bp);
 	}
 
 	if (MAC_GET_VAL(mac_ctrl5, MAC_CTRL5, PJPS_NOBP) != pjps_nobp) {
-		mac_printf("LMAC %d Prolong Jam Pattern Size during "
-			   "no-backpressure : %s\n",
-			   pdata->mac_idx, pjps_nobp ?
-			   "64 bit jam pattern" :
-			   "32 bit jam pattern");
+		mac_dbg("LMAC %d Prolong Jam Pattern Size during "
+			"no-backpressure : %s\n",
+			pdata->mac_idx, pjps_nobp ?
+			"64 bit jam pattern" :
+			"32 bit jam pattern");
 		MAC_SET_VAL(mac_ctrl5, MAC_CTRL5, PJPS_NOBP, pjps_nobp);
 	}
 
@@ -769,37 +435,14 @@ int lmac_set_jps(void *pdev, u32 pjps_bp, u32 pjps_nobp)
 	return 0;
 }
 
-int lmac_get_jps(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_ctrl5 = LMAC_RGRD(pdata, MAC_CTRL5(pdata->mac_idx));
-	u32 pjps_bp, pjps_nobp;
-
-	mac_printf("LMAC %d JPS %08x\n", pdata->mac_idx, mac_ctrl5);
-
-	pjps_bp = MAC_GET_VAL(mac_ctrl5, MAC_CTRL5, PJPS_BP);
-	mac_printf("\tProlong Jam Pattern Size during backpressure : %s\n",
-		   pjps_bp ?
-		   "64 bit jam pattern" :
-		   "32 bit jam pattern");
-
-	pjps_nobp = MAC_GET_VAL(mac_ctrl5, MAC_CTRL5, PJPS_NOBP);
-	mac_printf("\tProlong Jam Pattern Size during no-backpressure : %s\n",
-		   pjps_nobp ?
-		   "64 bit jam pattern" :
-		   "32 bit jam pattern");
-
-	return 0;
-}
-
 int lmac_set_loopback(void *pdev, u32 val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 mac_testen = LMAC_RGRD(pdata, MAC_TESTEN(pdata->mac_idx));
 
 	if (MAC_GET_VAL(mac_testen, MAC_TESTEN, LOOP) != val) {
-		mac_printf("LMAC %d Loopback : %s\n", pdata->mac_idx,
-			   val ? "ENABLED" : "DISABLED");
+		mac_dbg("LMAC %d Loopback : %s\n", pdata->mac_idx,
+			val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(mac_testen, MAC_TESTEN, LOOP, val);
 
 		LMAC_RGWR(pdata, MAC_TESTEN(pdata->mac_idx), mac_testen);
@@ -808,20 +451,6 @@ int lmac_set_loopback(void *pdev, u32 val)
 	return 0;
 }
 
-int lmac_get_loopback(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_testen = LMAC_RGRD(pdata, MAC_TESTEN(pdata->mac_idx));
-	u32 val;
-
-	mac_printf("LMAC %d Loopback: %08x\n", pdata->mac_idx, mac_testen);
-
-	val = MAC_GET_VAL(mac_testen, MAC_TESTEN, LOOP);
-	mac_printf("\tLMAC: Loopback : %s\n", val ? "ENABLED" : "DISABLED");
-
-	return val;
-}
-
 int lmac_set_txer(void *pdev, u32 val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
@@ -829,8 +458,8 @@ int lmac_set_txer(void *pdev, u32 val)
 	u32 mac_testen = LMAC_RGRD(pdata, MAC_TESTEN(pdata->mac_idx));
 
 	if (MAC_GET_VAL(mac_testen, MAC_TESTEN, TXER) != val) {
-		mac_printf("LMAC %d Inject transmit error : %s\n",
-			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		mac_dbg("LMAC %d Inject transmit error : %s\n",
+			pdata->mac_idx, val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(mac_testen, MAC_TESTEN, TXER, val);
 
 		LMAC_RGWR(pdata, MAC_TESTEN(pdata->mac_idx), mac_testen);
@@ -839,21 +468,6 @@ int lmac_set_txer(void *pdev, u32 val)
 	return 0;
 }
 
-int lmac_get_txer(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_testen = LMAC_RGRD(pdata, MAC_TESTEN(pdata->mac_idx));
-	u32 val;
-
-	mac_printf("LMAC %d TXER %08x\n", pdata->mac_idx, mac_testen);
-
-	val = MAC_GET_VAL(mac_testen, MAC_TESTEN, TXER);
-	mac_printf("\tInject transmit error : %s\n",
-		   val ? "ENABLED" : "DISABLED");
-
-	return val;
-}
-
 int lmac_set_lpimonitor_mode(void *pdev, u32 val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
@@ -861,14 +475,14 @@ int lmac_set_lpimonitor_mode(void *pdev, u32 val)
 
 	if (MAC_GET_VAL(mac_testen, MAC_TESTEN, LPITM) != val) {
 		if (val == 0)
-			mac_printf("LMAC %d LPI to be monitored in "
-				   "time recording : TX\n", pdata->mac_idx);
+			mac_dbg("LMAC %d LPI to be monitored in "
+				"time recording : TX\n", pdata->mac_idx);
 		else if (val == 1)
-			mac_printf("LMAC %d LPI to be monitored in "
-				   "time recording : RX\n", pdata->mac_idx);
+			mac_dbg("LMAC %d LPI to be monitored in "
+				"time recording : RX\n", pdata->mac_idx);
 		else if (val == 2)
-			mac_printf("LMAC %d LPI to be monitored in "
-				   "time recording : TXRX\n", pdata->mac_idx);
+			mac_dbg("LMAC %d LPI to be monitored in "
+				"time recording : TXRX\n", pdata->mac_idx);
 
 		MAC_SET_VAL(mac_testen, MAC_TESTEN, LPITM, val);
 
@@ -878,37 +492,16 @@ int lmac_set_lpimonitor_mode(void *pdev, u32 val)
 	return 0;
 }
 
-int lmac_get_lpimonitor_mode(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_testen = LMAC_RGRD(pdata, MAC_TESTEN(pdata->mac_idx));
-	u32 val;
-
-	mac_printf("LMAC %d LPI MONITORING MODE %08x\n",
-		   pdata->mac_idx, mac_testen);
-
-	val = MAC_GET_VAL(mac_testen, MAC_TESTEN, LPITM);
-
-	if (val == 0)
-		mac_printf("\tLPI to be monitored in time recording : TX\n");
-	else if (val == 1)
-		mac_printf("\tLPI to be monitored in time recording : RX\n");
-	else if (val == 2)
-		mac_printf("\tLPI to be monitored in time recording : TXRX\n");
-
-	return val;
-}
-
 int lmac_set_pauseframe_samode(void *pdev, u32 val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 mac_pfad = LMAC_RGRD(pdata, MAC_PFADCFG);
 
 	if (MAC_GET_VAL(mac_pfad, MAC_PFADCFG, SAMOD) != val) {
-		mac_printf("LMAC: Pause frame use : %s\n",
-			   val ?
-			   "PORT specific MAC source address" :
-			   "COMMON MAC source address");
+		mac_dbg("LMAC: Pause frame use : %s\n",
+			val ?
+			"PORT specific MAC source address" :
+			"COMMON MAC source address");
 		MAC_SET_VAL(mac_pfad, MAC_PFADCFG, SAMOD, val);
 
 		LMAC_RGWR(pdata, MAC_PFADCFG, mac_pfad);
@@ -917,23 +510,6 @@ int lmac_set_pauseframe_samode(void *pdev, u32 val)
 	return 0;
 }
 
-int lmac_get_pauseframe_samode(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_pfad = LMAC_RGRD(pdata, MAC_PFADCFG);
-	u32 val;
-
-	mac_printf("LMAC: PAUSE FRAME SAMODE %08x\n", mac_pfad);
-
-	val = MAC_GET_VAL(mac_pfad, MAC_PFADCFG, SAMOD);
-	mac_printf("\tPause frame use : %s\n",
-		   val ?
-		   "PORT specific MAC source address" :
-		   "COMMON MAC source address");
-
-	return val;
-}
-
 int lmac_set_pauseframe_addr(void *pdev, u8 *mac_addr)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
@@ -944,17 +520,17 @@ int lmac_set_pauseframe_addr(void *pdev, u8 *mac_addr)
 	mac_addr_0 = (mac_addr[1] <<  8) | (mac_addr[0] <<  0);
 
 	if (LMAC_RGRD(pdata, MAC_PFSA_0) != mac_addr_0) {
-		mac_printf("Setting mac_addr_0 as %08x\n", mac_addr_0);
+		mac_dbg("Setting mac_addr_0 as %08x\n", mac_addr_0);
 		LMAC_RGWR(pdata, MAC_PFSA_0, mac_addr_0);
 	}
 
 	if (LMAC_RGRD(pdata, MAC_PFSA_1) != mac_addr_1) {
-		mac_printf("Setting mac_addr_1 as %08x\n", mac_addr_1);
+		mac_dbg("Setting mac_addr_1 as %08x\n", mac_addr_1);
 		LMAC_RGWR(pdata, MAC_PFSA_1, mac_addr_1);
 	}
 
 	if (LMAC_RGRD(pdata, MAC_PFSA_2) != mac_addr_2) {
-		mac_printf("Setting mac_addr_2 as %08x\n", mac_addr_2);
+		mac_dbg("Setting mac_addr_2 as %08x\n", mac_addr_2);
 		LMAC_RGWR(pdata, MAC_PFSA_2, mac_addr_2);
 	}
 
@@ -981,143 +557,15 @@ int lmac_get_pauseframe_addr(void *pdev, u8 *mac_addr)
 	return 0;
 }
 
-int lmac_get_mac_pstat(void *pdev)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_pstat = LMAC_RGRD(pdata, MAC_PSTAT(pdata->mac_idx));
-
-	mac_printf("LMAC %d PORT STAT: %08x\n", pdata->mac_idx, mac_pstat);
-
-	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, RXLPI))
-		mac_printf("\tReceive Low Power Idle Status : "
-			   "LPI Low power idle state\n");
-	else
-		mac_printf("\tReceive Low Power Idle Status : "
-			   "Normal Power state\n");
-
-	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, TXLPI))
-		mac_printf("\tTransmit Low Power Idle Status : "
-			   "LPI Low power idle state\n");
-	else
-		mac_printf("\tTransmit Low Power Idle Status : "
-			   "Normal Power state\n");
-
-	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, CRS))
-		mac_printf("\tCarrier Detected\n");
-	else
-		mac_printf("\tNo Carrier Detected\n");
-
-	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, LSTAT))
-		mac_printf("\tLink is : UP\n");
-	else
-		mac_printf("\tLink is : DOWN\n");
-
-	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, TXPAUEN))
-		mac_printf("\tLink Partner accepts Pause frames\n");
-	else
-		mac_printf("\tLink Partner doesnot accepts Pause frames\n");
-
-	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, RXPAUEN))
-		mac_printf("\tLink Partner sends Pause frames\n");
-	else
-		mac_printf("\tLink Partner doesnot sends Pause frames\n");
-
-	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, TXPAU))
-		mac_printf("\tTransmit Pause status is active\n");
-	else
-		mac_printf("\tNormal transmit operation\n");
-
-	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, RXPAU))
-		mac_printf("\tReceive Pause status is active\n");
-	else
-		mac_printf("\tNormal Receive operation\n");
-
-	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, FDUP))
-		mac_printf("\tFull duplex Mode\n");
-	else
-		mac_printf("\thalf Duplex mode\n");
-
-	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, MBIT))
-		mac_printf("\tAttached PHY runs at a data rate of "
-			   "100 Mbps\n");
-	else
-		mac_printf("\tAttached PHY runs at a data rate of "
-			   "10 Mbps\n");
-
-	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, GBIT))
-		mac_printf("\tAttached PHY runs at a data rate of "
-			   "1000 or 2000 Mbps\n");
-	else
-		mac_printf("\tAttached PHY runs at a data rate of "
-			   "10 or 100 Mbps\n");
-
-	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, PACT))
-		mac_printf("\tPHY is active and responds to MDIO accesses\n");
-	else
-		mac_printf("\tPHY is inactive or not present\n");
-
-	return 0;
-}
-
-int lmac_get_mac_pisr(void *pdev)
+int lmac_get_pauseframe_samode(void *pdev)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_pisr = LMAC_RGRD(pdata, MAC_PISR(pdata->mac_idx));
-
-	mac_printf("LMAC %d PORT INTERRUPT STATUS: %08x\n",
-		   pdata->mac_idx, mac_pisr);
-
-	if (MAC_GET_VAL(mac_pisr, MAC_PISR, RXPAUSE))
-		mac_printf("\tAtleast 1 pause frame has been Received\n");
-
-	if (MAC_GET_VAL(mac_pisr, MAC_PISR, TXPAUSE))
-		mac_printf("\tAtleast 1 pause frame has been transmitted\n");
-
-	if (MAC_GET_VAL(mac_pisr, MAC_PISR, FCSERR))
-		mac_printf("\tFrame checksum Error Detected\n");
-
-	if (MAC_GET_VAL(mac_pisr, MAC_PISR, LENERR))
-		mac_printf("\tLength mismatch Error Detected\n");
-
-	if (MAC_GET_VAL(mac_pisr, MAC_PISR, TOOLONG))
-		mac_printf("\tToo Long frame Error Detected\n");
-
-	if (MAC_GET_VAL(mac_pisr, MAC_PISR, TOOSHORT))
-		mac_printf("\tToo Short frame Error Detected\n");
-
-	if (MAC_GET_VAL(mac_pisr, MAC_PISR, JAM))
-		mac_printf("\tJam status detected\n");
-
-	if (MAC_GET_VAL(mac_pisr, MAC_PISR, LPION))
-		mac_printf("\tReceive low power idle mode is entered\n");
-
-	if (MAC_GET_VAL(mac_pisr, MAC_PISR, LPIOFF))
-		mac_printf("\tReceive low power idle mode is left\n");
-
-	if (MAC_GET_VAL(mac_pisr, MAC_PISR, TXPAUEN))
-		mac_printf("\tA change of Transmit Pause Enable Status\n");
-
-	if (MAC_GET_VAL(mac_pisr, MAC_PISR, RXPAUEN))
-		mac_printf("\tA change of Receive Pause Enable Status\n");
-
-	if (MAC_GET_VAL(mac_pisr, MAC_PISR, FDUP))
-		mac_printf("\tA change of half- or full-duplex mode\n");
-
-	if (MAC_GET_VAL(mac_pisr, MAC_PISR, SPEED))
-		mac_printf("\tA change of speed mode\n");
-
-	if (MAC_GET_VAL(mac_pisr, MAC_PISR, PACT))
-		mac_printf("\tA change of link activity\n");
-
-	if (MAC_GET_VAL(mac_pisr, MAC_PISR, ALIGN))
-		mac_printf("\tA frame has been received which an "
-			   "alignment error\n");
+	u32 mac_pfad = LMAC_RGRD(pdata, MAC_PFADCFG);
+	u32 val;
 
-	if (MAC_GET_VAL(mac_pisr, MAC_PISR, PHYERR))
-		mac_printf("\tA frame has been received which has an "
-			   "active rx_err signal\n");
+	val = MAC_GET_VAL(mac_pfad, MAC_PFADCFG, SAMOD);
 
-	return 0;
+	return val;
 }
 
 void lmac_test_all_reg(void *pdev)
@@ -1302,7 +750,7 @@ void lmac_rmon_wr(void *pdev, struct lmac_rmon_cnt *lmac_cnt)
 	}
 }
 
-void lmac_rmon_clr(void *pdev)
+int lmac_rmon_clr(void *pdev)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 lmac_cnt_acc = 0;
@@ -1319,6 +767,8 @@ void lmac_rmon_clr(void *pdev)
 		if ((LMAC_RGRD(pdata, REG_LMAC_CNT_ACC) & 0x8000) == 0)
 			break;
 	}
+
+	return 0;
 }
 
 void lmac_rmon_clr_allmac(void *pdev)
@@ -1340,49 +790,3 @@ void lmac_rmon_clr_allmac(void *pdev)
 	}
 }
 
-void lmac_get_rmon(void)
-{
-	struct lmac_rmon_cnt lmac_cnt[3];
-	int i = 0;
-	struct mac_ops *ops;
-	u32 max_mac = gsw_get_mac_subifcnt(0);
-
-	for (i = 0; i < max_mac; i++) {
-		ops = gsw_get_mac_ops(0, i);
-		lmac_rmon_rd(ops, &lmac_cnt[i]);
-	}
-
-	mac_printf("\nTYPE                            %11s %11s %11s\n", "       LMAC 2", "     LMAC 3", "     LMAC 4\n");
-
-	mac_printf("Single Collision Cnt            = ");
-
-	mac_printf("%11u %11u %11u", lmac_cnt[0].sing_coln_cnt,
-		   lmac_cnt[1].sing_coln_cnt, lmac_cnt[2].sing_coln_cnt);
-
-	mac_printf("Multiple Collision Cnt          = ");
-
-	mac_printf("%11u %11u %11u", lmac_cnt[0].mple_coln_cnt,
-		   lmac_cnt[1].mple_coln_cnt, lmac_cnt[2].mple_coln_cnt);
-
-	mac_printf("Late Collision Cnt              = ");
-
-	mac_printf("%11u %11u %11u", lmac_cnt[0].late_coln_cnt,
-		   lmac_cnt[1].late_coln_cnt, lmac_cnt[2].late_coln_cnt);
-
-	mac_printf("Excess Collision Cnt            = ");
-
-	mac_printf("%11u %11u %11u", lmac_cnt[0].excs_coln_cnt,
-		   lmac_cnt[1].excs_coln_cnt, lmac_cnt[2].excs_coln_cnt);
-
-	mac_printf("Rx Pause Cnt                    = ");
-
-	mac_printf("%11u %11u %11u", lmac_cnt[0].rx_pause_cnt,
-		   lmac_cnt[1].rx_pause_cnt, lmac_cnt[2].rx_pause_cnt);
-
-	mac_printf("Tx Pause Cnt                    = ");
-
-	mac_printf("%11u %11u %11u", lmac_cnt[0].tx_pause_cnt,
-		   lmac_cnt[1].tx_pause_cnt, lmac_cnt[2].tx_pause_cnt);
-
-	mac_printf("\n");
-}
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.h b/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.h
index 1b7351603768..569e664333d2 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.h
@@ -244,22 +244,13 @@ enum {
 	LMAC_RMON_CLRALL
 };
 
-struct lmac_rmon_cnt {
-	u32 sing_coln_cnt;
-	u32 mple_coln_cnt;
-	u32 late_coln_cnt;
-	u32 excs_coln_cnt;
-	u32 rx_pause_cnt;
-	u32 tx_pause_cnt;
-};
-
 static inline u32 LMAC_RGRD(struct mac_prv_data *pdata, u32 reg)
 {
 	u32 reg_val;
 #if defined(PC_UTILITY) || defined(CHIPTEST)
 	u32 reg_addr = pdata->lmac_addr_base + reg;
 #else
-	volatile void *reg_addr = (volatile void *)pdata->lmac_addr_base + reg;
+	void __iomem *reg_addr = (void __iomem *)pdata->lmac_addr_base + reg;
 #endif
 
 #if defined(CHIPTEST) && CHIPTEST
@@ -269,7 +260,7 @@ static inline u32 LMAC_RGRD(struct mac_prv_data *pdata, u32 reg)
 	pcuart_reg_rd(reg_addr, &reg_val);
 #endif
 #ifdef __KERNEL__
-	reg_val = ltq_r32(reg_addr);
+	reg_val = mac_r32(reg_addr);
 #endif
 	return reg_val;
 }
@@ -279,7 +270,7 @@ static inline void LMAC_RGWR(struct mac_prv_data *pdata, u32 reg, u32 val)
 #if defined(PC_UTILITY) || defined(CHIPTEST)
 	u32 reg_addr = pdata->lmac_addr_base + reg;
 #else
-	volatile void *reg_addr = (volatile void *)pdata->lmac_addr_base + reg;
+	void __iomem *reg_addr = (void __iomem *)pdata->lmac_addr_base + reg;
 #endif
 
 #if defined(CHIPTEST) && CHIPTEST
@@ -289,7 +280,7 @@ static inline void LMAC_RGWR(struct mac_prv_data *pdata, u32 reg, u32 val)
 	pcuart_reg_wr(reg_addr, val);
 #endif
 #ifdef __KERNEL__
-	ltq_w32(val, reg_addr);
+	mac_w32(val, reg_addr);
 #endif
 }
 
@@ -325,21 +316,7 @@ int lmac_set_int(void *pdev, u32 val);
 int lmac_set_event_int(void *pdev, u32 evnt, u32 val);
 
 int lmac_get_event_int(void *pdev, u32 evnt);
-int lmac_get_intf_mode(void *pdev);
-int lmac_get_duplex_mode(void *pdev);
-u32 lmac_get_flowcon_mode(void *pdev);
-int lmac_get_txfcs(void *pdev);
-int lmac_get_ipg(void *pdev);
-int lmac_get_preamble(void *pdev);
-int lmac_get_defermode(void *pdev);
-int lmac_get_lpi(void *pdev, u32 *mode_en, u32 *lpi_waitg, u32 *lpi_waitm);
-int lmac_get_jps(void *pdev);
-int lmac_get_loopback(void *pdev);
-int lmac_get_txer(void *pdev);
-int lmac_get_lpimonitor_mode(void *pdev);
 int lmac_get_pauseframe_samode(void *pdev);
-int lmac_get_mac_pstat(void *pdev);
-int lmac_get_mac_pisr(void *pdev);
 int lmac_get_pauseframe_addr(void *pdev, u8 *mac_addr);
 int lmac_get_int_stat(void *pdev);
 int lmac_get_int(void *pdev);
@@ -351,8 +328,7 @@ void lmac_check_reg(void *pdev, u32 reg, char *name, int idx,
 
 void lmac_rmon_rd(void *pdev, struct lmac_rmon_cnt *lmac_cnt);
 void lmac_rmon_wr(void *pdev, struct lmac_rmon_cnt *lmac_cnt);
-void lmac_rmon_clr(void *pdev);
+int lmac_rmon_clr(void *pdev);
 void lmac_rmon_clr_allmac(void *pdev);
-void lmac_get_rmon(void);
 
 #endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.c b/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.c
index 4e1ee6ad5d78..48a7254db076 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.c
@@ -114,7 +114,7 @@ int mac_get_flowctrl(void *pdev)
 	return flow_ctrl;
 }
 
-int mac_reset(void *pdev)
+int mac_reset(void *pdev, u32 reset)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 
@@ -122,11 +122,15 @@ int mac_reset(void *pdev)
 	spin_lock_bh(&pdata->mac_lock);
 #endif
 
-	gswss_xgmac_reset(pdev, 1);
-	gswss_set_xgmac_rx_disable(pdev, 1);
-	gswss_set_xgmac_tx_disable(pdev, 1);
+	gswss_xgmac_reset(pdev, reset);
+	gswss_set_xgmac_rx_disable(pdev, reset);
+	gswss_set_xgmac_tx_disable(pdev, reset);
+	gswss_lmac_reset(pdev, reset);
 
-	gswss_lmac_reset(pdev, 1);
+	if (reset == RESET_OFF)
+		gswss_mac_enable(pdev, MAC_DIS);
+	else
+		gswss_mac_enable(pdev, MAC_EN);
 
 #ifdef __KERNEL__
 	spin_unlock_bh(&pdata->mac_lock);
@@ -466,7 +470,6 @@ int mac_get_speed(void *pdev)
 	else if (mac_speed == SPEED_AUTO)
 		mac_speed = 0;
 
-	mac_printf("Returning Speed = %d\n", mac_speed);
 #ifdef __KERNEL__
 	spin_unlock_bh(&pdata->mac_lock);
 #endif
@@ -474,7 +477,7 @@ int mac_get_speed(void *pdev)
 	return mac_speed;
 }
 
-int mac_set_linksts(void *pdev, u8 linksts)
+int mac_set_linksts(void *pdev, u32 linksts)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 
@@ -514,8 +517,6 @@ int mac_get_linksts(void *pdev)
 	else
 		linksts = -1;
 
-	mac_printf("Returning linksts = %d\n", linksts);
-
 #ifdef __KERNEL__
 	spin_unlock_bh(&pdata->mac_lock);
 #endif
@@ -671,6 +672,64 @@ int mac_oper_cfg(void *pdev, MAC_OPER_CFG oper)
 	return 0;
 }
 
+int mac_get_oper_cfg(void *pdev, MAC_OPER_CFG oper)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mode;
+	int ret = 0;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+	mode = oper % 4;
+
+	switch (oper) {
+	case TX_FCS_NO_INSERT:
+	case TX_FCS_INSERT:
+		ret = gswss_get_mac_txfcs_ins_op(pdev);
+		break;
+
+	case TX_FCS_NO_REMOVE:
+	case TX_FCS_REMOVE:
+		ret = gswss_get_mac_txfcs_rm_op(pdev);
+		break;
+
+	case TX_SPTAG_KEEP:
+	case TX_SPTAG_NOTAG:
+	case TX_SPTAG_REMOVE:
+	case TX_SPTAG_REPLACE:
+		ret = gswss_get_mac_txsptag_op(pdev);
+		break;
+
+	case RX_FCS_NOFCS:
+	case RX_FCS_NO_REMOVE:
+	case RX_FCS_REMOVE:
+		ret = gswss_get_mac_rxfcs_op(pdev);
+		break;
+
+	case RX_TIME_INSERT:
+	case RX_TIME_NOTS:
+	case RX_TIME_NO_INSERT:
+		ret = gswss_get_mac_rxtime_op(pdev);
+		break;
+
+	case RX_SPTAG_INSERT:
+	case RX_SPTAG_NOTAG:
+	case RX_SPTAG_NO_INSERT:
+		ret = gswss_get_mac_rxsptag_op(pdev);
+		break;
+
+	default:
+		break;
+	}
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return ret;
+}
+
 static int mac_set_rxcrccheck(void *pdev, u8 disable)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
@@ -1010,10 +1069,9 @@ int mac_init(void *pdev)
 	int i = 0;
 
 	xgmac_init_pdata(pdata, -1);
-#endif
-	xgmac_cli_init();
 
 	mac_printf("XGMAC INIT for Module %d\n", pdata->mac_idx);
+#endif
 
 	/* Get all hw capability */
 	xgmac_get_hw_capability(pdev);
@@ -1380,8 +1438,8 @@ void mac_init_fn_ptrs(struct mac_ops *mac_op)
 
 	mac_op->init = mac_init;
 	mac_op->exit = mac_exit;
-	mac_op->xgmac_cli = xgmac_main;
-	mac_op->lmac_cli = lmac_main;
+	mac_op->xgmac_cli = xgmac_cfg_main;
+	mac_op->lmac_cli = lmac_cfg_main;
 	mac_op->xgmac_reg_rd = xgmac_rd_reg;
 	mac_op->xgmac_reg_wr = xgmac_wr_reg;
 	mac_op->lmac_reg_rd = lmac_rd_reg;
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.h b/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.h
index 7135f1efe456..b26ae76cd556 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.h
@@ -12,6 +12,12 @@
 
 #include <xgmac_common.h>
 
+#define RESET_OFF 	0
+#define RESET_ON 	1
+
+#define MAC_EN		1
+#define MAC_DIS		0
+
 /* MAC Interface API's */
 int mac_config_loopback(void *pdev, u32 loopback);
 int mac_config_ipg(void *pdev, u32 ipg);
@@ -32,19 +38,18 @@ int mac_get_mtu(void *pdev);
 int mac_set_pfsa(void *pdev, u8 *mac_addr, u32 mode);
 int mac_get_pfsa(void *pdev, u8 *mac_addr, u32 *mode);
 
-int mac_reset(void *pdev);
+int mac_reset(void *pdev, u32 reset);
 
 int mac_init(void *pdev);
 int mac_exit(void *pdev);
 
-
 int mac_set_flowctrl(void *pdev, u32 val);
 int mac_get_flowctrl(void *pdev);
 
 int mac_set_lpien(void *pdev, u32 enable, u32 lpi_waitg, u32 lpi_waitm);
 int mac_get_lpien(void *pdev);
 
-int mac_set_linksts(void *pdev, u8 linksts);
+int mac_set_linksts(void *pdev, u32 linksts);
 int mac_get_linksts(void *pdev);
 
 int mac_set_fcs_gen(void *pdev, u32 val);
@@ -62,5 +67,7 @@ int mac_int_enable(void *pdev);
 int mac_int_disable(void *pdev);
 
 int mac_oper_cfg(void *pdev, MAC_OPER_CFG oper);
+int xgmac_cfg_main(GSW_MAC_Cli_t *params);
+
 #endif
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_cli.c b/drivers/net/ethernet/lantiq/switch-api/mac/mac_cli.c
new file mode 100644
index 000000000000..c3e0a89f1663
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_cli.c
@@ -0,0 +1,637 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017, 2018 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#include <xgmac.h>
+#include <gswss_mac_api.h>
+#include <lmac_api.h>
+#include <xgmac_mdio.h>
+#include <mac_tx_fifo.h>
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(arr)	(sizeof(arr)/sizeof((arr)[0]))
+#endif
+
+struct mac_api_cfg {
+	u32 cmdType;
+	int (*set_func_0)(void *);
+	int (*set_func_1)(void *, u32);
+	int (*set_func_2)(void *, u32, u32);
+	int (*set_func_3)(void *, u32, u32, u32);
+	int (*get_func)(void *);
+
+};
+
+static int cli_set_mtl_tx(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	xgmac_set_mtl_tx_mode(pdev, pdata->val[0]);
+	xgmac_set_mtl_tx_thresh(pdev, pdata->val[1]);
+
+	return 0;
+}
+
+static int cli_set_mtl_rx(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	xgmac_set_mtl_rx_mode(pdev, pdata->val[0]);
+	xgmac_set_mtl_rx_thresh(pdev, pdata->val[1]);
+
+	return 0;
+}
+
+static int cli_set_int(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	mac_int_enable(pdev);
+	xgmac_set_mac_int(pdev, pdata->val[1], 1);
+	xgmac_set_mtl_int(pdev, pdata->val[0]);
+
+	return 0;
+}
+
+/* MAC REGISTER SETTINGS */
+static int cli_set_mac_enable(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	if (pdata->val[0])
+		xgmac_powerup(pdev);
+	else
+		xgmac_powerdown(pdev);
+
+	return 0;
+}
+
+static int cli_set_mac_address(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	xgmac_set_mac_address(pdev, pdata->mac_addr);
+
+	return 0;
+}
+
+static int cli_set_mac_rx_mode(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	xgmac_set_promiscuous_mode(pdev, pdata->val[0]);
+	xgmac_set_all_multicast_mode(pdev, pdata->val[1]);
+
+	return 0;
+}
+
+static int cli_mdio_wr(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	xgmac_mdio_single_wr(pdev, pdata->val[0], pdata->val[1], pdata->val[2],
+			     pdata->val[3]);
+
+	return 0;
+}
+
+static int cli_mdio_get_clause(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	return mdio_get_clause(pdev, pdata->val[1]);
+}
+
+static int cli_add_fifo(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	fifo_entry_add(pdev, pdata->val[0], pdata->val[1],
+		       pdata->val[2], pdata->val[3], pdata->val[4],
+		       pdata->val[5]);
+
+	return 0;
+}
+
+static int cli_get_rmon(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	if (!pdata) {
+		mac_printf("MAC Cli pointer is NULL\n");
+		return -1;
+	}
+
+	xgmac_read_mmc_stats(pdev, &pdata->pstats);
+
+	return 0;
+}
+
+static int cli_get_systime(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	if (!pdata) {
+		mac_printf("MAC Cli pointer is NULL\n");
+		return -1;
+	}
+
+	pdata->time = xgmac_get_systime(pdev);
+
+	return 0;
+}
+
+static int cli_get_txtstamp(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	if (!pdata) {
+		mac_printf("MAC Cli pointer is NULL\n");
+		return -1;
+	}
+
+	pdata->time = xgmac_get_tx_tstamp(pdev);
+
+	return 0;
+}
+
+static int cli_get_hwcap(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	if (!pdata) {
+		mac_printf("MAC Cli pointer is NULL\n");
+		return -1;
+	}
+
+	xgmac_get_hw_capability(pdev);
+
+	memcpy(&pdata->hw_feat, &priv_data->hw_feat, sizeof(priv_data->hw_feat));
+
+	return 0;
+}
+
+static const struct mac_api_cfg xgmac_cfg[] = {
+	{MAC_CLI_INIT, mac_init, 0, 0, 0, 0},
+	{MAC_CLI_RESET, 0, mac_reset, 0, 0, 0},
+	{MAC_CLI_MTL_TX, cli_set_mtl_tx, 0, 0, 0, 0},
+	{MAC_CLI_MTL_RX, cli_set_mtl_rx, 0, 0, 0, 0},
+	{MAC_CLI_FCTHR, 0, 0, xgmac_set_flow_control_threshold, 0, 0},
+	{MAC_CLI_SET_TS_ADDEND, 0, xgmac_set_tstamp_addend, 0, 0, 0},
+	{MAC_CLI_GET_SYSTEM_TIME, 0, 0, 0, 0, cli_get_systime},
+	{MAC_CLI_GET_TX_TSTAMP, 0, 0, 0, 0, cli_get_txtstamp},
+	{MAC_CLI_GET_TXTSTAMP_CNT, 0, 0, 0, 0, xgmac_get_txtstamp_cnt},
+	{MAC_CLI_GET_TXTSTAMP_PKTID, 0, 0, 0, 0, xgmac_get_txtstamp_pktid},
+	{MAC_CLI_SET_TSTAMP_EN, mac_enable_ts, 0, 0, 0, 0},
+	{MAC_CLI_SET_TSTAMP_DIS, mac_disable_ts, 0, 0, 0, 0},
+	{MAC_CLI_TXTSTAMP_MODE, 0, 0, 0, xgmac_ptp_txtstamp_mode, 0},
+	{MAC_CLI_HW_TSTAMP, 0, 0, xgmac_set_hwtstamp_settings, 0, 0},
+	{MAC_CLI_FLUSH_TX_Q, xgmac_flush_tx_queues, 0, 0, 0, 0},
+	{MAC_CLI_ERR_PKT_FWD, 0, 0, xgmac_forward_fup_fep_pkt, 0, 0},
+	{MAC_CLI_SET_INT, cli_set_int, 0, 0, 0, 0},
+	{MAC_CLI_EN, cli_set_mac_enable, 0, 0, 0, 0},
+	{MAC_CLI_SET_MAC_ADDR, cli_set_mac_address, 0, 0, 0, 0},
+	{MAC_CLI_SET_RX_MODE, cli_set_mac_rx_mode, 0, 0, 0, 0},
+	{MAC_CLI_SET_MTU, 0, mac_set_mtu, 0, 0, mac_get_mtu},
+	{MAC_CLI_PFCTRL, 0, mac_set_flowctrl, 0, 0, 0},
+	{MAC_CLI_SET_PF_FILTER, 0, xgmac_pause_frame_filtering, 0, 0, 0},
+	{MAC_CLI_PAUSE_TX, xgmac_initiate_pause_tx, 0, 0, 0, 0},
+	{MAC_CLI_SPEED, 0, mac_set_physpeed, 0, 0, mac_get_speed},
+	{MAC_CLI_SET_DPX_MODE, 0, mac_set_duplex, 0, 0, 0},
+	{MAC_CLI_CSUM_OFFLOAD, 0, xgmac_set_checksum_offload, 0, 0, 0},
+	{MAC_CLI_LB, 0, mac_config_loopback, 0, 0, 0},
+	{MAC_CLI_EEE, 0, 0, 0, mac_set_lpien, 0},
+	{MAC_CLI_CRC_STRIP, 0, xgmac_set_crc_strip_type, 0, 0, 0},
+	{MAC_CLI_CRC_STRIP_ACS, 0, xgmac_set_acs, 0, 0, 0},
+	{MAC_CLI_IPG, 0, mac_config_ipg, 0, 0, 0},
+	{MAC_CLI_MAGIC_PMT, 0, xgmac_set_magic_pmt, 0, 0, 0},
+	{MAC_CLI_PMT_GUCAST, 0, xgmac_set_pmt_gucast, 0, 0, 0},
+	{MAC_CLI_EXTCFG, 0, xgmac_set_extcfg, 0, 0, 0},
+	{MAC_CLI_SET_RXTXCFG, 0, 0, xgmac_set_mac_rxtx, 0, 0},
+	{MAC_CLI_SET_LINKSTS, 0, mac_set_linksts, 0, 0, 0},
+	{MAC_CLI_SET_LPITX, 0, xgmac_set_mac_lpitx, 0, 0, 0},
+	{MAC_CLI_SET_MDIO_CL, 0, 0, mdio_set_clause, 0, 0},
+	{MAC_CLI_SET_MDIO_RD, 0, 0, 0, xgmac_mdio_single_rd, 0},
+	{MAC_CLI_SET_MDIO_WR, cli_mdio_wr, 0, 0, 0, 0},
+	{MAC_CLI_SET_MDIO_INT, 0, mdio_set_interrupt, 0, 0, 0},
+	{MAC_CLI_SET_FCSGEN, 0, mac_set_fcs_gen, 0, 0, 0},
+	{MAC_CLI_SET_GINT, 0, xgmac_set_gint, 0, 0, 0},
+	{MAC_CLI_SET_RXCRC, 0, xgmac_set_rxcrc, 0, 0, 0},
+	{MAC_CLI_GET_FIFO, 0, 0, 0, 0, print_fifo},
+	{MAC_CLI_ADD_FIFO, cli_add_fifo, 0, 0, 0, 0},
+	{MAC_CLI_DEL_FIFO, 0, fifo_entry_del, 0, 0, 0},
+	{MAC_CLI_SET_EXT_TS_SRC, 0, xgmac_set_exttime_source, 0, 0, 0},
+	{MAC_CLI_GET_RMON, 0, 0, 0, 0, cli_get_rmon},
+	{MAC_CLI_CLEAR_RMON, xgmac_clear_rmon, 0, 0, 0, 0},
+	{MAC_CLI_GET_CNTR_CFG, 0, 0, 0, 0, 0},
+	{MAC_CLI_GET_HW_FEAT, 0, 0, 0, 0, cli_get_hwcap},
+	{MAC_CLI_GET_MDIO_CL, 0, 0, 0, 0, cli_mdio_get_clause},
+	{MAC_CLI_REG_RD, 0, xgmac_rd_reg, 0, 0, 0},
+	{MAC_CLI_REG_WR, 0, 0, xgmac_wr_reg, 0, 0},
+};
+
+int xgmac_cfg_main(GSW_MAC_Cli_t *params)
+{
+	struct mac_ops *ops = gsw_get_mac_ops(0, 0);
+	struct mac_prv_data *pdata = GET_MAC_PDATA(ops);
+	int i = 0, ret = 0;
+	int num_of_elem = ARRAY_SIZE(xgmac_cfg);
+
+	for (i = 0; i < num_of_elem; i++) {
+		if (xgmac_cfg[i].cmdType == params->cmdType) {
+			break;
+		}
+	}
+
+	ops = gsw_get_mac_ops(0, params->mac_idx);
+	pdata = GET_MAC_PDATA(ops);
+	pdata->set_all = 0;
+
+	pdata->mac_cli = params;
+
+#if 0
+
+	for (k = 0; k < MAX_MAC_CLI_ARG; k++)
+		pdata->val[k] = params->val[k];
+
+	for (k = 0; k < 6; k++)
+		pdata->mac_addr[k] = params->mac_addr[k];
+
+#endif
+#if 0
+
+	printk("%x\n", pdata->mac_cli);
+	printk("%x\n", pdata->mac_cli->pstats);
+	printk("%x\n", pdata->mac_cli->hw_feat);
+
+	for (k = 0; k < MAX_MAC_CLI_ARG; k++)
+		printk("val %x\n", pdata->mac_cli->val[k]);
+
+#endif
+
+	if (params->get) {
+		if (xgmac_cfg[i].get_func)
+			ret = xgmac_cfg[i].get_func(ops);
+		else if (xgmac_cfg[i].set_func_0)
+			ret = xgmac_cfg[i].set_func_0(ops);
+		else if (xgmac_cfg[i].set_func_1)
+			ret = xgmac_cfg[i].set_func_1(ops, params->val[0]);
+		else if (xgmac_cfg[i].set_func_2)
+			ret = xgmac_cfg[i].set_func_2(ops,
+						      params->val[0],
+						      params->val[1]);
+		else if (xgmac_cfg[i].set_func_3)
+			ret = xgmac_cfg[i].set_func_3(ops,
+						      params->val[0],
+						      params->val[1],
+						      params->val[2]);
+
+	} else {
+		if (xgmac_cfg[i].set_func_0)
+			ret = xgmac_cfg[i].set_func_0(ops);
+		else if (xgmac_cfg[i].set_func_1)
+			ret = xgmac_cfg[i].set_func_1(ops, params->val[0]);
+		else if (xgmac_cfg[i].set_func_2)
+			ret = xgmac_cfg[i].set_func_2(ops,
+						      params->val[0],
+						      params->val[1]);
+		else if (xgmac_cfg[i].set_func_3)
+			ret = xgmac_cfg[i].set_func_3(ops,
+						      params->val[0],
+						      params->val[1],
+						      params->val[2]);
+	}
+
+
+	return ret;
+}
+
+static int cli_set_cfg1588(void *pdev)
+{
+	struct adap_prv_data *prv_data = GET_ADAP_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = prv_data->mac_cli;
+
+	gswss_cfg0_1588(pdev,
+			pdata->val[0], pdata->val[1],
+			pdata->val[2], pdata->val[3]);
+	return 0;
+
+}
+
+static int cli_set_txtstamp_fifo(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	struct mac_fifo_entry f_entry;
+
+	f_entry.ttse = pdata->val[0];
+	f_entry.ostc = pdata->val[1];
+	f_entry.ostpa = pdata->val[2];
+	f_entry.cic = pdata->val[3];
+	f_entry.ttsl = pdata->val[4];
+	f_entry.ttsh = pdata->val[5];
+	f_entry.rec_id = pdata->val[6];
+
+	gswss_set_txtstamp_fifo(pdev, &f_entry);
+	return 0;
+}
+
+static int cli_set_macop(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+
+	if (pdata->val[0] == RX) {
+		if (pdata->val[1] == 0)
+			gswss_set_mac_rxfcs_op(pdev, pdata->val[2]);
+		else if (pdata->val[1] == 1)
+			gswss_set_mac_rxsptag_op(pdev, pdata->val[2]);
+		else if (pdata->val[1] == 2)
+			gswss_set_mac_rxtime_op(pdev, pdata->val[2]);
+	} else if (pdata->val[0] == TX) {
+		if (pdata->val[1] == 0) {
+			if (pdata->val[2] == 0 || pdata->val[2] == 1)
+				gswss_set_mac_txfcs_ins_op(pdev,
+							   pdata->val[2]);
+			else if (pdata->val[2] == 2 || pdata->val[2] == 3)
+				gswss_set_mac_txfcs_rm_op(pdev,
+							  pdata->val[2] - 2);
+		} else if (pdata->val[1] == 1)
+			gswss_set_mac_txsptag_op(pdev, pdata->val[2]);
+	}
+
+	return 0;
+}
+
+static int cli_set_macif(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	if (pdata->val[0] == 0)
+		gswss_set_1g_intf(pdev, pdata->val[1]);
+	else if (pdata->val[0] == 1)
+		gswss_set_fe_intf(pdev, pdata->val[1]);
+	else if (pdata->val[0] == 2)
+		gswss_set_2G5_intf(pdev, pdata->val[1]);
+
+	return 0;
+}
+
+static int cli_mac_reset(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	if (pdata->val[0] == XGMAC)
+		gswss_xgmac_reset(pdev, pdata->val[1]);
+	else if (pdata->val[0] == LMAC)
+		gswss_lmac_reset(pdev, pdata->val[1]);
+	else if (pdata->val[0] == ADAP)
+		gswss_adap_reset(pdev, pdata->val[1]);
+
+	return 0;
+}
+
+static int cli_get_txtstamp_fifo(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	gswss_get_txtstamp_fifo(pdev, pdata->val[0], &pdata->f_entry);
+
+	return 0;
+}
+
+static int cli_get_cfg0_1588(void *pdev)
+{
+	struct adap_prv_data *priv_data = GET_ADAP_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+	gswss_get_cfg0_1588(pdev,
+			    &pdata->val[0],
+			    &pdata->val[1],
+			    &pdata->val[2],
+			    &pdata->val[3]);
+	return 0;
+}
+
+static int cli_get_cfg1_1588(void *pdev)
+{
+	struct adap_prv_data *priv_data = GET_ADAP_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	gswss_get_cfg1_1588(pdev,
+			    &pdata->val[0],
+			    &pdata->val[1],
+			    &pdata->val[2]);
+	return 0;
+}
+
+static int cli_get_nco(void *pdev)
+{
+	struct adap_prv_data *priv_data = GET_ADAP_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+	int nco;
+
+	nco = gswss_get_nco(pdev, pdata->val[0]);
+
+	return nco;
+}
+
+struct mac_api_cfg ss_cfg[] = {
+	{GSWSS_REG_WR, 0, 0, gswss_wr_reg, 0, 0},
+	{GSWSS_REG_RD, 0, gswss_rd_reg, 0, 0, 0},
+	{GSWSS_MAC_RESET, cli_mac_reset, 0, 0, 0, 0},
+	{GSWSS_MAC_EN, 0, gswss_mac_enable, 0, 0, 0},
+	{GSWSS_MAC_IF, cli_set_macif, 0, 0, 0, 0},
+	{GSWSS_MAC_OP, cli_set_macop, 0, 0, 0, 0},
+	{GSWSS_MAC_MTU, 0, gswss_set_mtu, 0, 0, gswss_get_mtu},
+	{GSWSS_MAC_TXTSTAMP_FIFO, cli_set_txtstamp_fifo, 0, 0, 0, cli_get_txtstamp_fifo},
+	{GSWSS_MAC_PHY2MODE, 0, 0, 0, 0, 0},
+	{GSWSS_ADAP_INT, 0, 0, 0, gswss_set_interrupt, 0},
+	{GSWSS_ADAP_CFG_1588, cli_set_cfg1588, 0, 0, 0, cli_get_cfg0_1588},
+	{GSWSS_ADAP_NCO, 0, 0, gswss_set_nco, 0, cli_get_nco},
+	{GSWSS_ADAP_MACSEC_RST, 0, gswss_macsec_reset, 0, 0, 0},
+	{GSWSS_ADAP_SS_RST, gswss_switch_ss_reset, 0, 0, 0, 0},
+	{GSWSS_ADAP_MACSEC_TO_MAC, 0, 0, gswss_set_macsec_to_mac, 0, 0},
+	{GSWSS_ADAP_CORESE, 0, gswss_set_corese, 0, 0, gswss_get_corese},
+	{GSWSS_ADAP_CLK_MD, 0, gswss_set_clkmode, 0, 0, gswss_get_clkmode},
+	{GSWSS_ADAP_1588_CFG1, 0, 0, 0, gswss_cfg1_1588, cli_get_cfg1_1588},
+};
+
+int gswss_cfg_main(GSW_MAC_Cli_t *params)
+{
+	struct mac_ops *mac_ops;
+	struct adap_ops *adap_ops = gsw_get_adap_ops(0);
+	struct mac_prv_data *mac_pdata;
+	struct adap_prv_data *adap_pdata = GET_ADAP_PDATA(adap_ops);
+	void *ops = NULL;
+	int i = 0, ret = 0;
+	int num_of_elem = ARRAY_SIZE(ss_cfg);
+
+	for (i = 0; i < num_of_elem; i++) {
+		if (ss_cfg[i].cmdType == params->cmdType) {
+			break;
+		}
+	}
+
+	if (params->cmdType < GSWSS_MAX_MAC) {
+
+		if (params->cmdType == GSWSS_REG_WR || params->cmdType == GSWSS_REG_RD) {
+			params->mac_idx = 0;
+		}
+		mac_ops = gsw_get_mac_ops(0, params->mac_idx);
+		mac_pdata = GET_MAC_PDATA(mac_ops);
+
+		mac_pdata->mac_cli = params;
+
+		ops = mac_ops;
+
+	} else if (params->cmdType > GSWSS_MAX_MAC) {
+
+		adap_pdata->mac_cli = params;
+
+		ops = adap_ops;
+	}
+
+	if (params->get) {
+		if (ss_cfg[i].get_func)
+			ret = ss_cfg[i].get_func(ops);
+		else if (ss_cfg[i].set_func_0)
+			ret = ss_cfg[i].set_func_0(ops);
+		else if (ss_cfg[i].set_func_1)
+			ret = ss_cfg[i].set_func_1(ops, params->val[0]);
+		else if (ss_cfg[i].set_func_2)
+			ret = ss_cfg[i].set_func_2(ops,
+						   params->val[0],
+						   params->val[1]);
+		else if (ss_cfg[i].set_func_3)
+			ret = ss_cfg[i].set_func_3(ops,
+						   params->val[0],
+						   params->val[1],
+						   params->val[2]);
+
+	} else {
+		if (ss_cfg[i].set_func_0)
+			ret = ss_cfg[i].set_func_0(ops);
+		else if (ss_cfg[i].set_func_1)
+			ret = ss_cfg[i].set_func_1(ops, params->val[0]);
+		else if (ss_cfg[i].set_func_2)
+			ret = ss_cfg[i].set_func_2(ops,
+						   params->val[0],
+						   params->val[1]);
+		else if (ss_cfg[i].set_func_3)
+			ret = ss_cfg[i].set_func_3(ops,
+						   params->val[0],
+						   params->val[1],
+						   params->val[2]);
+	}
+
+	return ret;
+}
+
+static int cli_lmac_get_rmon(void *pdev)
+{
+	struct mac_prv_data *priv_data = GET_MAC_PDATA(pdev);
+	GSW_MAC_Cli_t *pdata = priv_data->mac_cli;
+
+	if (!pdata) {
+		mac_printf("MAC Cli pointer is NULL\n");
+		return -1;
+	}
+
+	lmac_rmon_rd(pdev, &pdata->lpstats);
+
+	return 0;
+}
+
+static const struct mac_api_cfg lmac_api_cfg[] = {
+	{LMAC_REG_WR, 0, 0, lmac_wr_reg, 0, 0},
+	{LMAC_REG_RD, 0, lmac_rd_reg, 0, 0, 0},
+	{LMAC_RMON, 0, 0, 0, 0, cli_lmac_get_rmon},
+	{LMAC_CLR_RMON, lmac_rmon_clr, 0, 0, 0, 0},
+	{LMAC_IF_MODE, 0, lmac_set_intf_mode, 0, 0, 0},
+	{LMAC_DPX, 0, lmac_set_duplex_mode, 0, 0, 0},
+	{LMAC_XFCS, 0, lmac_set_txfcs, 0, 0, 0},
+	{LMAC_FLOWCON, 0, lmac_set_flowcon_mode, 0, 0, 0},
+	{LMAC_IPG, 0, lmac_set_ipg, 0, 0, 0},
+	{LMAC_PREAMBLE, 0, lmac_set_preamble, 0, 0, 0},
+	{LMAC_DEFERMODE, 0, lmac_set_defermode, 0, 0, 0},
+	{LMAC_JPS, 0, 0, lmac_set_jps, 0, 0},
+	{LMAC_LB, 0, lmac_set_loopback, 0, 0, 0},
+	{LMAC_TXER, 0, lmac_set_txer, 0, 0, 0},
+	{LMAC_LPIMONIT, 0, lmac_set_lpimonitor_mode, 0, 0, 0},
+	{LMAC_PSTAT, 0, 0, 0, 0, 0},
+	{LMAC_PISR, 0, 0, 0, 0, 0},
+	{LMAC_PAUSE_SA_MODE, 0, lmac_set_pauseframe_samode, 0, 0, 0},
+};
+
+int lmac_cfg_main(GSW_MAC_Cli_t *params)
+{
+	struct mac_ops *mac_ops;
+	struct mac_prv_data *mac_pdata;
+	int i = 0, ret = 0;
+	int num_of_elem = ARRAY_SIZE(lmac_api_cfg);
+
+	for (i = 0; i < num_of_elem; i++) {
+		if (lmac_api_cfg[i].cmdType == params->cmdType) {
+			break;
+		}
+	}
+
+	mac_ops = gsw_get_mac_ops(0, params->mac_idx);
+	mac_pdata = GET_MAC_PDATA(mac_ops);
+
+	mac_pdata->mac_cli = params;
+
+	if (params->get) {
+		if (lmac_api_cfg[i].get_func)
+			ret = lmac_api_cfg[i].get_func(mac_ops);
+		else if (lmac_api_cfg[i].set_func_1)
+			ret = lmac_api_cfg[i].set_func_1(mac_ops, params->val[0]);
+		else if (lmac_api_cfg[i].set_func_2)
+			ret = lmac_api_cfg[i].set_func_2(mac_ops,
+							 params->val[0],
+							 params->val[1]);
+		else if (lmac_api_cfg[i].set_func_3)
+			ret = lmac_api_cfg[i].set_func_3(mac_ops,
+							 params->val[0],
+							 params->val[1],
+							 params->val[2]);
+
+	} else {
+		if (lmac_api_cfg[i].set_func_1)
+			ret = lmac_api_cfg[i].set_func_1(mac_ops, params->val[0]);
+		else if (lmac_api_cfg[i].set_func_2)
+			ret = lmac_api_cfg[i].set_func_2(mac_ops,
+							 params->val[0],
+							 params->val[1]);
+		else if (lmac_api_cfg[i].set_func_3)
+			ret = lmac_api_cfg[i].set_func_3(mac_ops,
+							 params->val[0],
+							 params->val[1],
+							 params->val[2]);
+	}
+
+	return ret;
+}
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c b/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c
index e4eee8d34a98..1e1595e5708f 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c
@@ -7,7 +7,6 @@
  *
  ******************************************************************************/
 
-#include <lantiq_soc.h>
 #include <net/switch_api/gsw_dev.h>
 #include <net/switch_api/adap_ops.h>
 #include <gswss_api.h>
@@ -35,6 +34,9 @@ static irqreturn_t mac_isr(int irq, void *dev_id)
 		mac_int_sts = gswss_get_int_stat(adap_ops, XGMAC);
 
 		mac_ops = gsw_get_mac_ops(devid, i);
+		if (!mac_ops)
+			return IRQ_HANDLED;
+
 		pdata = GET_MAC_PDATA(mac_ops);
 
 		/* Check XGMAC i Interrupts */
@@ -131,6 +133,8 @@ static int mac_probe(struct platform_device *pdev)
 	struct mac_prv_data *pdata =
 		GET_MAC_PDATA(platform_get_drvdata(pdev));
 	struct device *dev = &pdev->dev;
+	int linksts = 0, duplex = 0, speed = 0;
+	char *load, *ls, *dp;
 
 	gswdev->mac_dev[pdev->id] = pdev;
 
@@ -153,14 +157,13 @@ static int mac_probe(struct platform_device *pdev)
 	/* Update Adaption layer pointer and Lmac base address per Mac private
 	 * data.This is needed since all MAC api's have Private data as argument
 	 */
-	pdata->ss_addr_base = (u32)base[0];
-	adap_pdata->ss_addr_base = (u32)base[0];
-	pdata->lmac_addr_base = (u32)base[1];
+	pdata->ss_addr_base = base[0];
+	adap_pdata->ss_addr_base = base[0];
+	pdata->lmac_addr_base = base[1];
 
 	pdata->max_mac = gsw_get_mac_subifcnt(0);
 
 	if (device_property_present(dev, "board_type")) {
-		pr_info("Board Type: HAPS\n");
 		pdata->haps = 1;
 	} else {
 		pdata->haps = 0;
@@ -183,9 +186,41 @@ static int mac_probe(struct platform_device *pdev)
 	/* Request IRQ for MAC */
 	mac_irq_init(pdata);
 
-	pr_info("XGMAC INIT %d Started\n", pdata->mac_idx);
 	pdata->ops.init(&pdata->ops);
-	pr_info("XGMAC INIT %d completed\n\n", pdata->mac_idx);
+
+	linksts = pdata->ops.get_link_sts(&pdata->ops);
+	duplex = pdata->ops.get_duplex(&pdata->ops);
+	speed = pdata->ops.get_speed(&pdata->ops);
+
+	if (speed == GSW_PORT_SPEED_10)
+		load = "10 Mbps";
+	else if (speed == GSW_PORT_SPEED_100)
+		load = "100 Mbps";
+	else if (speed == GSW_PORT_SPEED_1000)
+		load = "1 Gbps";
+	else if (speed == GSW_PORT_SPEED_100000)
+		load = "10 Gbps";
+	else if (speed == GSW_PORT_SPEED_25000)
+		load = "2.5 Gbps";
+	else
+		load = "AUTO";
+
+	if (linksts == GSW_PORT_LINK_UP)
+		ls = "UP";
+	else if (linksts == GSW_PORT_LINK_DOWN)
+		ls = "DOWN";
+	else
+		ls = "AUTO";
+
+	if (duplex == GSW_DUPLEX_FULL)
+		dp = "Full";
+	else if (duplex == GSW_DUPLEX_HALF)
+		dp = "Half";
+	else
+		dp = "AUTO";
+
+	pr_debug("XGMAC Init %d: Speed: %s Link: %s Duplex: %s\n",
+		pdata->mac_idx, load, ls, dp);
 
 	return 0;
 }
@@ -207,7 +242,7 @@ static struct platform_driver gsw_mac_driver = {
 
 module_platform_driver(gsw_mac_driver);
 
-MODULE_AUTHOR("Intel");
+MODULE_AUTHOR("Joby Thampan");
 MODULE_DESCRIPTION("Intel GSW_MAC Device driver");
 MODULE_LICENSE("GPL");
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.c b/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.c
index 05676fde2087..024c4cb41b4c 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.c
@@ -77,7 +77,7 @@ int fifo_entry_add(void *pdev, u8 ttse, u8 ostc, u8 ostpa, u8 cic,
 	return f_entry->rec_id;
 }
 
-void fifo_entry_del(void *pdev, u32 rec_id)
+int fifo_entry_del(void *pdev, u32 rec_id)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	struct mac_fifo_entry *f_entry = &pdata->ts_fifo[rec_id];
@@ -96,6 +96,8 @@ void fifo_entry_del(void *pdev, u32 rec_id)
 
 	/* Fifo available for the next packet */
 	f_entry->is_used = 0;
+
+	return 0;
 }
 
 static void fifo_update_hw_clrsts(void *pdev,
@@ -138,7 +140,7 @@ u32 timer_in_sec(u32 jiffies)
 #endif
 }
 
-void print_fifo(void *pdev)
+int print_fifo(void *pdev)
 {
 	int i = 0;
 	struct mac_fifo_entry f_entry;
@@ -170,6 +172,8 @@ void print_fifo(void *pdev)
 			   pdata->ts_fifo[i].jiffies);
 #endif
 	}
+
+	return 0;
 }
 
 static int fifo_freeid_get(void *pdev, u8 ttse)
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.h b/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.h
index 1e1cdc94fc93..a0d0ba7b42ae 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.h
@@ -20,45 +20,11 @@ enum {
 	FIFO_ENTRY_NOT_AVAIL = -3,
 };
 
-/* GSWIP Tx Fifo to send signal from GSWIP to Xgmac
- * to do the action on the packet
- * Actions include
- * 1) Store Tx Timestamp
- * 2) One Step TImestamp update for Sync packets
- * 3) Packet ID update for the stored timestamp
- * 4) Timestamp correction needed
- * Entry will be cleared by the HW when packet is sent out
- */
-struct mac_fifo_entry {
-	u32 is_used;
-	/* RecordID, denotes index to the 64 entry Fifo */
-	u32 rec_id;
-	/* Transmit Timestamp Store Enable */
-	u8 ttse;
-	/* One Step Timestamp Capture Enable */
-	u8 ostc;
-	/* One Step Timestamp Available/PacketID Available */
-	u8 ostpa;
-	/* Checksum Insertion or Update information */
-	u8 cic;
-	/* Lower 32 byte of time correction */
-	u32 ttsl;
-	/* Upper 32 byte of time correction */
-	u32 ttsh;
-	/* Timeout for this Fifo Entry */
-	u32 timeout;
-	u32 jiffies;
-#ifdef __KERNEL__
-	struct timer_list timer;
-#endif
-};
-
-
 u32 fifo_init(void *pdev);
 int fifo_entry_add(void *pdev, u8 ttse, u8 ostc, u8 ostpa, u8 cic,
 		   u32 ttsl, u32 ttsh);
-void fifo_entry_del(void *pdev, u32 rec_id);
+int fifo_entry_del(void *pdev, u32 rec_id);
 void fifo_isr_handler(void *pdev);
-void print_fifo(void *pdev);
+int print_fifo(void *pdev);
 
 #endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h
index 695562c14784..9e6f52dbb02a 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h
@@ -43,7 +43,6 @@
 #define __XGMAC_H__
 
 #include <xgmac_common.h>
-#include <xgmac_cli.h>
 #include <mac_cfg.h>
 
 #define XGMAC_MIN_PACKET        60
@@ -393,6 +392,8 @@
 #define MAC_RX_CFG_GPSLCE_WIDTH		   1
 #define MAC_RX_CFG_GPSL_POS                16
 #define MAC_RX_CFG_GPSL_WIDTH		   14
+#define MAC_RX_CFG_PRXM_POS                15
+#define MAC_RX_CFG_PRXM_WIDTH		   1
 
 #define MAC_RX_FCR_PFCE_POS               8
 #define MAC_RX_FCR_PFCE_WIDTH             1
@@ -428,6 +429,10 @@
 #define MAC_TX_CFG_IPG_WIDTH		   3
 #define MAC_TX_CFG_IFP_POS                 11
 #define MAC_TX_CFG_IFP_WIDTH		   1
+#define MAC_TX_CFG_PEN_POS                 19
+#define MAC_TX_CFG_PEN_WIDTH		   1
+#define MAC_TX_CFG_PCHM_POS                18
+#define MAC_TX_CFG_PCHM_WIDTH		   1
 #define MAC_TX_CFG_G9991EN_POS             28
 #define MAC_TX_CFG_G9991EN_WIDTH	   1
 
@@ -467,6 +472,8 @@
 #define MAC_TSTAMP_CR_TSUPDT_WIDTH           1
 #define MAC_TSTAMP_CR_ESTI_POS               20
 #define MAC_TSTAMP_CR_ESTI_WIDTH             1
+#define MAC_TSTAMP_CR_CSC_POS               19
+#define MAC_TSTAMP_CR_CSC_WIDTH             1
 
 #define MAC_TSTAMP_STSR_ATSNS_POS              25
 #define MAC_TSTAMP_STSR_ATSNS_WIDTH            5
@@ -676,26 +683,6 @@
 #define MTL_TCPR_MAP0_PSTC0_POS		0
 #define MTL_TCPR_MAP0_PSTC0_WIDTH	8
 
-/* RX THRESHOLD operations */
-#define MTL_RX_THRESHOLD_32		0x01
-#define MTL_RX_THRESHOLD_64             0x00
-#define MTL_RX_THRESHOLD_96             0x02
-#define MTL_RX_THRESHOLD_128            0x03
-#define MTL_TX_THRESHOLD_32             0x01
-#define MTL_TX_THRESHOLD_64             0x00
-#define MTL_TX_THRESHOLD_96             0x02
-#define MTL_TX_THRESHOLD_128            0x03
-#define MTL_TX_THRESHOLD_192            0x04
-#define MTL_TX_THRESHOLD_256            0x05
-#define MTL_TX_THRESHOLD_384            0x06
-#define MTL_TX_THRESHOLD_512            0x07
-
-#define MTL_ETSALG_WRR                  0x00
-#define MTL_ETSALG_WFQ                  0x01
-#define MTL_ETSALG_DWRR                 0x02
-#define MTL_RAA_SP                      0x00
-#define MTL_RAA_WSP                     0x01
-
 enum {
 	XGMAC_256 = 0x0,
 	XGMAC_512 = 0x1,
@@ -773,22 +760,22 @@ enum  {
 static inline u32 XGMAC_IO_R32(struct mac_prv_data *pdata, u16 reg)
 {
 	u32 reg_val;
-	volatile void *xgmac_ctrl_reg  =
-		(volatile void *)(pdata->ss_addr_base + pdata->xgmac_ctrl_reg);
-	volatile void *xgmac_data0_reg =
-		(volatile void *)pdata->ss_addr_base + pdata->xgmac_data0_reg;
-	volatile void *xgmac_data1_reg =
-		(volatile void *)pdata->ss_addr_base + pdata->xgmac_data1_reg;
+	void __iomem *xgmac_ctrl_reg  =
+		(void __iomem *)(pdata->ss_addr_base + pdata->xgmac_ctrl_reg);
+	void __iomem *xgmac_data0_reg =
+		(void __iomem *)pdata->ss_addr_base + pdata->xgmac_data0_reg;
+	void __iomem *xgmac_data1_reg =
+		(void __iomem *)pdata->ss_addr_base + pdata->xgmac_data1_reg;
 
-	ltq_w32((0x8000 | reg), xgmac_ctrl_reg);
+	mac_w32((0x8000 | reg), xgmac_ctrl_reg);
 
 	while (1) {
-		if ((ltq_r32(xgmac_ctrl_reg) & 0x8000) == 0)
+		if ((mac_r32(xgmac_ctrl_reg) & 0x8000) == 0)
 			break;
 	}
 
-	reg_val = ((ltq_r32(xgmac_data1_reg) << 16) |
-		   (ltq_r32(xgmac_data0_reg)));
+	reg_val = ((mac_r32(xgmac_data1_reg) << 16) |
+		   (mac_r32(xgmac_data0_reg)));
 
 	return reg_val;
 }
@@ -796,19 +783,19 @@ static inline u32 XGMAC_IO_R32(struct mac_prv_data *pdata, u16 reg)
 static inline void XGMAC_IO_W32(struct mac_prv_data *pdata, u16 reg,
 				u32 val)
 {
-	volatile void *xgmac_ctrl_reg  =
-		(volatile void *)(pdata->ss_addr_base + pdata->xgmac_ctrl_reg);
-	volatile void *xgmac_data0_reg =
-		(volatile void *)(pdata->ss_addr_base + pdata->xgmac_data0_reg);
-	volatile void *xgmac_data1_reg =
-		(volatile void *)(pdata->ss_addr_base + pdata->xgmac_data1_reg);
+	void __iomem *xgmac_ctrl_reg  =
+		(void __iomem *)(pdata->ss_addr_base + pdata->xgmac_ctrl_reg);
+	void __iomem *xgmac_data0_reg =
+		(void __iomem *)(pdata->ss_addr_base + pdata->xgmac_data0_reg);
+	void __iomem *xgmac_data1_reg =
+		(void __iomem *)(pdata->ss_addr_base + pdata->xgmac_data1_reg);
 
-	ltq_w32(((val & 0xFFFF0000) >> 16), xgmac_data1_reg);
-	ltq_w32((val & 0x0000FFFF), xgmac_data0_reg);
-	ltq_w32((0xC000 | reg), xgmac_ctrl_reg);
+	mac_w32(((val & 0xFFFF0000) >> 16), xgmac_data1_reg);
+	mac_w32((val & 0x0000FFFF), xgmac_data0_reg);
+	mac_w32((0xC000 | reg), xgmac_ctrl_reg);
 
 	while (1) {
-		if ((ltq_r32(xgmac_ctrl_reg) & 0x8000) == 0)
+		if ((mac_r32(xgmac_ctrl_reg) & 0x8000) == 0)
 			break;
 	}
 }
@@ -953,7 +940,7 @@ int xgmac_set_flow_control_threshold(void *pdev,
 				     u32 rfa, u32 rfd);
 int xgmac_set_mmc(void *pdev);
 
-int xgmac_clear_rmon(void *pdev, u32 rmon_reset);
+int xgmac_clear_rmon(void *pdev);
 int xgmac_read_mmc_stats(void *pdev, struct xgmac_mmc_stats *stats);
 int xgmac_set_debug_ctl(void *pdev, u32 dbg_en, u32 dbg_mode);
 int xgmac_set_debug_data(void *pdev, u32 dbg_data);
@@ -1001,11 +988,10 @@ int xgmac_config_std_pkt(void *pdev);
 int xgmac_powerup(void *pdev);
 int xgmac_powerdown(void *pdev);
 int xgmac_config_subsec_inc(void *pdev, u32 ptp_clk);
-void xgmac_ptp_txtstamp_mode(void *pdev,
-			     u32 snaptypesel,
-			     u32 tsmstrena,
-			     u32 tsevntena);
-
+int xgmac_ptp_txtstamp_mode(void *pdev,
+			    u32 snaptypesel,
+			    u32 tsmstrena,
+			    u32 tsevntena);
 int xgmac_set_eee_mode(void *pdev, u32 val);
 int xgmac_set_eee_pls(void *pdev, u32 val);
 int xgmac_set_eee_timer(void *pdev, u32 twt, u32 lst);
@@ -1015,7 +1001,7 @@ int xgmac_set_ipg(void *pdev, u32 ipg);
 int xgmac_set_magic_pmt(void *pdev, u32 val);
 int xgmac_set_rwk_pmt(void *pdev, u32 val);
 int xgmac_set_extcfg(void *pdev, u32 val);
-void xgmac_set_mac_rxtx(void *pdev, u32 wd, u32 jd);
+int xgmac_set_mac_rxtx(void *pdev, u32 wd, u32 jd);
 int xgmac_set_rwk_filter_registers(void *pdev, u32 count,
 				   u32 *val);
 int xgmac_set_pmt_gucast(void *pdev, u32 val);
@@ -1023,9 +1009,11 @@ int xgmac_set_ptp_offload(void *pdev, u32 type, u32 val);
 int xgmac_set_ptp_offload_msg_gen(void *pdev, u32 mode);
 int xgmac_set_mac_lpitx(void *pdev, u32 val);
 int xgmac_pause_frame_filtering(void *pdev, u32 val);
+int xgmac_set_pch(void *pdev, u32 pch_en, u32 pch_rx, u32 pch_tx);
+int xgmac_set_pfc(void *pdev, u32 enable);
 int xgmac_set_gint(void *pdev, u32 val);
 int xgmac_set_rxcrc(void *pdev, u32 val);
-void xgmac_set_exttime_source(void *pdev, u32 val);
+int xgmac_set_exttime_source(void *pdev, u32 val);
 
 
 /* GET API's */
@@ -1064,6 +1052,7 @@ int xgmac_dbg_int_sts(void *pdev);
 int xgmac_get_ipg(void *pdev);
 int xgmac_get_txtstamp_cnt(void *pdev);
 int xgmac_get_txtstamp_pktid(void *pdev);
+int xgmac_get_pch_crc_cnt(void *pdev);
 
 
 #if defined(CHIPTEST) && CHIPTEST
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h
index a667af289935..2b718af4e34f 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h
@@ -77,8 +77,6 @@
 #include <linux/irq.h>
 #include <linux/seq_file.h>
 #include <linux/semaphore.h>
-#include <lantiq.h>
-#include <lantiq_soc.h>
 #include <linux/netdevice.h>
 #include <linux/net_tstamp.h>
 #include <linux/clocksource.h>
@@ -113,6 +111,7 @@ extern int pc_uart_datawrite_32(u32 Offset, u32 value);
 #endif
 
 #define UPTIME 0
+#define MAX_RETRY 2000
 
 #if defined(PC_UTILITY) && PC_UTILITY
 #define NANOSEC_IN_ONESEC 550000
@@ -143,6 +142,8 @@ extern int pc_uart_datawrite_32(u32 Offset, u32 value);
 		   reg##_##field##_WIDTH, (val))
 
 #define N_EXT_TS 2
+#define mac_r32(reg)       readl(reg)
+#define mac_w32(val, reg)  writel(val, reg)
 
 #if defined(PC_UTILITY) && PC_UTILITY
 
@@ -199,63 +200,6 @@ FILE *get_fp(void);
 #define mac_dbg pr_debug
 #endif
 
-static inline int mac_nstrlen(char *s)
-{
-	int cnt = 0;
-
-	if (s == (void *)0)
-		return 0;
-
-	while (s[cnt])
-		cnt++;
-
-	return cnt;
-}
-
-static inline unsigned long mac_nstrtoul(const char *s, int len,
-		u32 *next_idx)
-{
-	unsigned long acc;
-	int cnt = 0;
-	char c;
-	int base = 0;
-
-	acc = 0;
-
-	c = s[cnt];
-
-	if (s[cnt] == '0') {
-		cnt++;
-
-		if ((s[cnt] == 'x') || (s[cnt] == 'X')) {
-			base = 16;
-			cnt++;
-		}
-	}
-
-	if (!base)
-		base = 10;
-
-	for (; cnt < len; cnt++) {
-		c = s[cnt];
-
-		if ((c >= '0') && (c <= '9'))
-			c -= '0';
-		else if ((c >= 'a') && (c <= 'f'))
-			c -= 'a' - 10;
-		else if ((c >= 'A') && (c <= 'F'))
-			c -= 'A' - 10;
-		else
-			c = 0;
-
-		acc *= base;
-		acc += c;
-	}
-
-	(*next_idx)++;
-
-	return acc;
-}
 
 enum {
 	MAC_AUTO_DPLX = 0,
@@ -381,129 +325,6 @@ struct ptp_flags {
 	u32 ptp_tx_en;
 };
 
-#if defined(CHIPTEST) && CHIPTEST
-struct xgmac_mmc_stats {
-	/* Tx Stats */
-	u32 txoctetcount_gb;
-	u32 txframecount_gb;
-	u32 txbroadcastframes_g;
-	u32 txmulticastframes_g;
-	u32 txunicastframes_gb;
-	u32 txmulticastframes_gb;
-	u32 txbroadcastframes_gb;
-	u32 txunderflowerror;
-	u32 txoctetcount_g;
-	u32 txframecount_g;
-	u32 txpauseframes;
-	u32 txvlanframes_g;
-
-	/* Rx Stats */
-	u32 rxframecount_gb;
-	u32 rxoctetcount_gb;
-	u32 rxoctetcount_g;
-	u32 rxbroadcastframes_g;
-	u32 rxmulticastframes_g;
-	u32 rxcrcerror;
-	u32 rxrunterror;
-	u32 rxjabbererror;
-	u32 rxundersize_g;
-	u32 rxoversize_g;
-	u32 rxunicastframes_g;
-	u32 rxlengtherror;
-	u32 rxoutofrangetype;
-	u32 rxpauseframes;
-	u32 rxfifooverflow;
-	u32 rxvlanframes_gb;
-	u32 rxwatchdogerror;
-};
-#else
-struct xgmac_mmc_stats {
-	/* Tx Stats */
-	u64 txoctetcount_gb;
-	u64 txframecount_gb;
-	u64 txbroadcastframes_g;
-	u64 txmulticastframes_g;
-	u64 txunicastframes_gb;
-	u64 txmulticastframes_gb;
-	u64 txbroadcastframes_gb;
-	u64 txunderflowerror;
-	u64 txoctetcount_g;
-	u64 txframecount_g;
-	u64 txpauseframes;
-	u64 txvlanframes_g;
-
-	/* Rx Stats */
-	u64 rxframecount_gb;
-	u64 rxoctetcount_gb;
-	u64 rxoctetcount_g;
-	u64 rxbroadcastframes_g;
-	u64 rxmulticastframes_g;
-	u64 rxcrcerror;
-	u64 rxrunterror;
-	u64 rxjabbererror;
-	u64 rxundersize_g;
-	u64 rxoversize_g;
-	u64 rxunicastframes_g;
-	u64 rxlengtherror;
-	u64 rxoutofrangetype;
-	u64 rxpauseframes;
-	u64 rxfifooverflow;
-	u64 rxvlanframes_gb;
-	u64 rxwatchdogerror;
-};
-
-#endif
-/* This structure contains flags that indicate what hardware features
- * or configurations are present in the device.
- */
-struct xgmac_hw_features {
-	/* HW Version */
-	u32 version;
-
-	/* HW Feature Register0 */
-	u32 gmii;              /* 1000 Mbps support */
-	u32 vlhash;            /* VLAN Hash Filter */
-	u32 sma;               /* SMA(MDIO) Interface */
-	u32 rwk;               /* PMT remote wake-up packet */
-	u32 mgk;               /* PMT magic packet */
-	u32 mmc;               /* RMON module */
-	u32 aoe;               /* ARP Offload */
-	u32 ts;                /* IEEE 1588-2008 Advanced Timestamp */
-	u32 eee;               /* Energy Efficient Ethernet */
-	u32 tx_coe;            /* Tx Checksum Offload */
-	u32 rx_coe;            /* Rx Checksum Offload */
-	u32 addn_mac;          /* Additional MAC Addresses */
-	u32 ts_src;            /* Timestamp Source */
-	u32 sa_vlan_ins;       /* Source Address or VLAN Insertion */
-	u32 vxn;				/* VxLAN/NVGRE Support */
-	u32 ediffc;			/* Different Descriptor Cache */
-	u32 edma;				/* Enhanced DMA */
-
-	/* HW Feature Register1 */
-	u32 rx_fifo_size;      /* MTL Receive FIFO Size */
-	u32 tx_fifo_size;      /* MTL Transmit FIFO Size */
-	u32 osten;      		/* One-Step Timestamping Enable */
-	u32 ptoen;      		/* PTP Offload Enable */
-	u32 adv_ts_hi;         /* Advance Timestamping High Word */
-	u32 dma_width;         /* DMA width */
-	u32 dcb;               /* DCB Feature */
-	u32 sph;               /* Split Header Feature */
-	u32 tso;               /* TCP Segmentation Offload */
-	u32 dma_debug;         /* DMA Debug Registers */
-	u32 rss;               /* Receive Side Scaling */
-	u32 tc_cnt;            /* Number of Traffic Classes */
-	u32 hash_table_size;   /* Hash Table Size */
-	u32 l3l4_filter_num;   /* Number of L3-L4 Filters */
-
-	/* HW Feature Register2 */
-	u32 rx_q_cnt;          /* Number of MTL Receive Queues */
-	u32 tx_q_cnt;          /* Number of MTL Transmit Queues */
-	u32 rx_ch_cnt;         /* Number of DMA Receive Channels */
-	u32 tx_ch_cnt;         /* Number of DMA Transmit Channels */
-	u32 pps_out_num;       /* Number of PPS outputs */
-	u32 aux_snap_num;      /* Number of Aux snapshot inputs */
-};
-
 struct mac_irq_hdl {
 	u32 irq_event;
 	void (*cb)(void *);
@@ -515,16 +336,24 @@ struct mac_irq_hdl {
 struct mac_prv_data;
 
 struct mac_prv_data {
-	/* Lmac addr base */
-	u32 lmac_addr_base;
 
 	/* XGMAC registers for indirect accessing */
 	u32 xgmac_ctrl_reg;
 	u32 xgmac_data0_reg;
 	u32 xgmac_data1_reg;
 
+#ifdef __KERNEL__
+	/* Adaption layer private data */
+	void __iomem *ss_addr_base;
+	/* Lmac addr base */
+	void __iomem *lmac_addr_base;
+#else
 	/* Adaption layer private data */
 	u32 ss_addr_base;
+	/* Lmac addr base */
+	u32 lmac_addr_base;
+
+#endif
 	/* Index to point XGMAC 2/3/4 */
 	u32 mac_idx;
 
@@ -575,6 +404,7 @@ struct mac_prv_data {
 	 * queued for transmission and device
 	 * will take timesstamp for this skb
 	 */
+	struct platform_device *pdev;
 	struct device *dev;
 	struct sk_buff *ptp_tx_skb;
 	struct work_struct ptp_tx_work;
@@ -666,8 +496,6 @@ struct mac_prv_data {
 	u32 set_all;
 	u32 duplex_mode;
 
-	u32 init_val;
-
 	u32 jd;
 	u32 wd;
 
@@ -685,10 +513,21 @@ struct mac_prv_data {
 	u32 mdio_int;
 
 	u32 phyadr;
+	u32 bus_id;
 
 	u32 ptp_clk;
 
-	u32 val;
+	/* PCH */
+	u32 pch_en;
+	u32 pch_tx;
+	u32 pch_rx;
+
+	/* PFC enable/disable */
+	u32 pfc_en;
+
+	/* Mac Cli */
+	GSW_MAC_Cli_t *mac_cli;
+
 	/* Maximum number of MAC present */
 	u32 max_mac;
 
@@ -729,14 +568,14 @@ u32 gsw_get_mac_subifcnt(u32 devid);
 #endif
 
 int xgmac_main(u32 argc, u8 *argv[]);
-int gswss_main(u32 argc, u8 *argv[]);
-int lmac_main(u32 argc, u8 *argv[]);
-void lmac_wr_reg(void *pdev, u32 reg_off, u32 reg_val);
-u32 lmac_rd_reg(void *pdev, u32 reg_off);
-void xgmac_wr_reg(void *pdev, u16 reg_off, u32 reg_val);
-u32 xgmac_rd_reg(void *pdev, u16 reg_off);
-void gswss_wr_reg(void *pdev, u32 reg_off, u32 reg_val);
-u32 gswss_rd_reg(void *pdev, u32 reg_off);
+int gswss_cfg_main(GSW_MAC_Cli_t *);
+int lmac_cfg_main(GSW_MAC_Cli_t *);
+int lmac_wr_reg(void *pdev, u32 reg_off, u32 reg_val);
+int lmac_rd_reg(void *pdev, u32 reg_off);
+int xgmac_wr_reg(void *pdev, u32 reg_off, u32 reg_val);
+int xgmac_rd_reg(void *pdev, u32 reg_off);
+int gswss_wr_reg(void *pdev, u32 reg_off, u32 reg_val);
+int gswss_rd_reg(void *pdev, u32 reg_off);
 void mac_init_fn_ptrs(struct mac_ops *mac_op);
 int xgmac_init(void *pdev);
 int xgmac_exit(void *pdev);
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_debug.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_debug.c
index 85f7602ea79b..32e32eecbaa1 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_debug.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_debug.c
@@ -482,10 +482,7 @@ int xgmac_get_mac_addr(void *pdev)
 	mac_addr_hi = XGMAC_RGRD(pdata, MAC_MACA0HR);
 	mac_addr_lo = XGMAC_RGRD(pdata, MAC_MACA0LR);
 
-	mac_printf("XGMAC %d: MAC ADDR\n", pdata->mac_idx);
-
-	mac_printf("\tmac_addr_hi = %08x\n", mac_addr_hi);
-	mac_printf("\tmac_addr_lo = %08x\n", mac_addr_lo);
+	mac_printf("XGMAC %d: MAC ADDR ", pdata->mac_idx);
 
 	mac_addr[5] = ((mac_addr_hi & 0x0000FF00) >> 8);
 	mac_addr[4] = (mac_addr_hi & 0x000000FF);
@@ -494,7 +491,7 @@ int xgmac_get_mac_addr(void *pdev)
 	mac_addr[1] = ((mac_addr_lo & 0x0000FF00) >> 8);
 	mac_addr[0] = (mac_addr_lo & 0x000000FF);
 
-	mac_printf("\tSet mac address %02x:%02x:%02x:%02x:%02x:%02x\n",
+	mac_printf(" %02x:%02x:%02x:%02x:%02x:%02x\n",
 		   mac_addr[0],
 		   mac_addr[1],
 		   mac_addr[2],
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mac_api.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mac_api.c
index f52b72ec98c8..ecae66d1f3e4 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mac_api.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mac_api.c
@@ -63,8 +63,8 @@ int xgmac_set_loopback(void *pdev, u32 val)
 	reg_val = XGMAC_RGRD(pdata, MAC_RX_CFG);
 
 	if (MAC_GET_VAL(reg_val, MAC_RX_CFG, LM) != val) {
-		mac_printf("XGMAC %d: LOOPBACK mode: %s\n",
-			   pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: LOOPBACK mode: %s\n",
+			pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(reg_val, MAC_RX_CFG, LM, val);
 		XGMAC_RGWR(pdata, MAC_RX_CFG, reg_val);
 	}
@@ -98,8 +98,8 @@ int xgmac_disable_tx_flow_ctl(void *pdev)
 	reg_val = XGMAC_RGRD(pdata, MAC_TX_FCR);
 
 	if (MAC_GET_VAL(reg_val, MAC_TX_FCR, TFE) != 0) {
-		mac_printf("XGMAC %d: Disable TX Flow Control\n",
-			   pdata->mac_idx);
+		mac_dbg("XGMAC %d: Disable TX Flow Control\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(reg_val, MAC_TX_FCR, TFE, 0);
 		XGMAC_RGWR(pdata, MAC_TX_FCR, reg_val);
 	}
@@ -115,8 +115,8 @@ int xgmac_disable_rx_flow_ctl(void *pdev)
 	reg_val = XGMAC_RGRD(pdata, MAC_RX_FCR);
 
 	if (MAC_GET_VAL(reg_val, MAC_RX_FCR, RFE) != 0) {
-		mac_printf("XGMAC %d: Disable RX Flow Control\n",
-			   pdata->mac_idx);
+		mac_dbg("XGMAC %d: Disable RX Flow Control\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(reg_val, MAC_RX_FCR, RFE, 0);
 		XGMAC_RGWR(pdata, MAC_RX_FCR, reg_val);
 	}
@@ -132,8 +132,8 @@ int xgmac_enable_tx_flow_ctl(void *pdev, u32 pause_time)
 	reg_val = XGMAC_RGRD(pdata, MAC_TX_FCR);
 
 	if (MAC_GET_VAL(reg_val, MAC_TX_FCR, TFE) != 1) {
-		mac_printf("XGMAC %d: Enable TX Flow Control\n",
-			   pdata->mac_idx);
+		mac_dbg("XGMAC %d: Enable TX Flow Control\n",
+			pdata->mac_idx);
 		/* Enable transmit flow control */
 		MAC_SET_VAL(reg_val, MAC_TX_FCR, TFE, 1);
 		/* Set pause time */
@@ -153,8 +153,8 @@ int xgmac_enable_rx_flow_ctl(void *pdev)
 	reg_val = XGMAC_RGRD(pdata, MAC_RX_FCR);
 
 	if (MAC_GET_VAL(reg_val, MAC_RX_FCR, RFE) != 1) {
-		mac_printf("XGMAC %d: Enable RX Flow Control\n",
-			   pdata->mac_idx);
+		mac_dbg("XGMAC %d: Enable RX Flow Control\n",
+			pdata->mac_idx);
 		/* Enable Receive flow control */
 		MAC_SET_VAL(reg_val, MAC_RX_FCR, RFE, 1);
 		// TODO: Need to check whether this is needed
@@ -177,13 +177,13 @@ int xgmac_enable_rx_flow_ctl(void *pdev)
 int xgmac_initiate_pause_tx(void *pdev)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 reg_val;
+	u32 reg_val, idx = 0;
 
 	reg_val = XGMAC_RGRD(pdata, MAC_TX_FCR);
 
 	if (MAC_GET_VAL(reg_val, MAC_TX_FCR, TFE) == 0) {
-		mac_printf("XGMAC %d: Pause pkt txd only if TFE bit is set\n",
-			   pdata->mac_idx);
+		mac_dbg("XGMAC %d: Pause pkt txd only if TFE bit is set\n",
+			pdata->mac_idx);
 		return 0;
 	}
 
@@ -192,15 +192,25 @@ int xgmac_initiate_pause_tx(void *pdev)
 	/* Initiate Pause TX */
 	XGMAC_RGWR(pdata, MAC_TX_FCR, reg_val);
 
-	while (1) {
+	do {
 		reg_val = XGMAC_RGRD(pdata, MAC_TX_FCR);
 
 		if (MAC_GET_VAL(reg_val, MAC_TX_FCR, FCB) == 0) {
-			mac_printf("XGMAC %d: Pause Pkt Txd complete\n",
-				   pdata->mac_idx);
+			mac_dbg("XGMAC %d: Pause Pkt Txd complete\n",
+				pdata->mac_idx);
 			break;
 		}
-	}
+
+
+		idx++;
+
+#ifdef __KERNEL__
+		/* To put a small delay and make sure previous operations
+		 * are complete
+		 */
+		usleep_range(100, 200);
+#endif
+	} while (idx <= MAX_RETRY);
 
 	return 0;
 }
@@ -213,8 +223,8 @@ int xgmac_clear_mac_int(void *pdev)
 
 	/* Clear all the interrupts which are set */
 	mac_isr = XGMAC_RGRD(pdata, MAC_ISR);
-	mac_printf("XGMAC %d Clearing MAC ISR registers with %08x\n",
-		   pdata->mac_idx, mac_isr);
+	mac_dbg("XGMAC %d Clearing MAC ISR registers with %08x\n",
+		pdata->mac_idx, mac_isr);
 	XGMAC_RGWR(pdata, MAC_ISR, mac_isr);
 	return 0;
 }
@@ -274,7 +284,7 @@ int xgmac_set_mac_int(void *pdev, u32 event, u32 val)
 		break;
 
 	default:
-		mac_printf("Unsupported Mac Event\n");
+		mac_dbg("Unsupported Mac Event\n");
 		return GSW_statusErr;
 	}
 
@@ -305,8 +315,8 @@ int xgmac_set_gmii_speed(void *pdev)
 		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, USS, 0);
 
 	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, SS) != 0x3) {
-		mac_printf("XGMAC %d: Setting SPEED to GMII 1G\n",
-			   pdata->mac_idx);
+		mac_dbg("XGMAC %d: Setting SPEED to GMII 1G\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, SS, 0x3);
 	}
 
@@ -328,8 +338,8 @@ int xgmac_set_gmii_2500_speed(void *pdev)
 		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, USS, 0);
 
 	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, SS) != 0x2) {
-		mac_printf("XGMAC %d: Setting SPEED to GMII 2.5G\n",
-			   pdata->mac_idx);
+		mac_dbg("XGMAC %d: Setting SPEED to GMII 2.5G\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, SS, 0x2);
 	}
 
@@ -351,8 +361,8 @@ int xgmac_set_xgmii_2500_speed(void *pdev)
 		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, USS, 1);
 
 	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, SS) != 0x2) {
-		mac_printf("XGMAC %d: Setting SPEED to XGMII 2.5G\n",
-			   pdata->mac_idx);
+		mac_dbg("XGMAC %d: Setting SPEED to XGMII 2.5G\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, SS, 0x2);
 	}
 
@@ -374,8 +384,8 @@ int xgmac_set_xgmii_speed(void *pdev)
 		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, USS, 0);
 
 	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, SS) != 0) {
-		mac_printf("XGMAC %d: Setting SPEED to XGMII 10G\n",
-			   pdata->mac_idx);
+		mac_dbg("XGMAC %d: Setting SPEED to XGMII 10G\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, SS, 0);
 	}
 
@@ -392,15 +402,15 @@ int xgmac_pause_frame_filtering(void *pdev, u32 val)
 	u32 mac_pfr = XGMAC_RGRD(pdata, MAC_PKT_FR);
 
 	if (MAC_GET_VAL(mac_pfr, MAC_PKT_FR, PCF) != val) {
-		mac_printf("XGMAC %d: Pause filtering %s\n",
-			   pdata->mac_idx, val ? "Enabled" : "Disabled");
+		mac_dbg("XGMAC %d: Pause filtering %s\n",
+			pdata->mac_idx, val ? "Enabled" : "Disabled");
 		/* Pause filtering */
 		MAC_SET_VAL(mac_pfr, MAC_PKT_FR, PCF, val);
 	}
 
 	if (MAC_GET_VAL(mac_pfr, MAC_PKT_FR, RA) == 1) {
-		mac_printf("XGMAC %d: MAC Filter Receive All: DISABLED\n",
-			   pdata->mac_idx);
+		mac_dbg("XGMAC %d: MAC Filter Receive All: DISABLED\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_pfr, MAC_PKT_FR, RA, 0);
 	}
 
@@ -428,8 +438,8 @@ int xgmac_set_promiscuous_mode(void *pdev, u32 val)
 	u32 reg_val = XGMAC_RGRD(pdata, MAC_PKT_FR);
 
 	if (MAC_GET_VAL(reg_val, MAC_PKT_FR, PR) != val) {
-		mac_printf("XGMAC %d: %s promiscuous mode\n",
-			   pdata->mac_idx,  val ? "Entering" : "Leaving");
+		mac_dbg("XGMAC %d: %s promiscuous mode\n",
+			pdata->mac_idx,  val ? "Entering" : "Leaving");
 		MAC_SET_VAL(reg_val, MAC_PKT_FR, PR, val);
 
 		XGMAC_RGWR(pdata, MAC_PKT_FR, reg_val);
@@ -451,8 +461,8 @@ int xgmac_set_all_multicast_mode(void *pdev, u32 val)
 
 	if (MAC_GET_VAL(reg_val, MAC_PKT_FR, PM) != val) {
 		MAC_SET_VAL(reg_val, MAC_PKT_FR, PM, val);
-		mac_printf("XGMAC %d: %s allmulti mode\n",
-			   pdata->mac_idx,  val ? "Entering" : "Leaving");
+		mac_dbg("XGMAC %d: %s allmulti mode\n",
+			pdata->mac_idx,  val ? "Entering" : "Leaving");
 		XGMAC_RGWR(pdata, MAC_PKT_FR, reg_val);
 	}
 
@@ -482,9 +492,9 @@ int xgmac_set_mac_address(void *pdev, u8 *mac_addr)
 	XGMAC_RGWR(pdata, MAC_MACA0HR, mac_addr_hi);
 
 	if (XGMAC_RGRD(pdata, MAC_MACA0LR) != mac_addr_lo) {
-		mac_printf("XGMAC %d: Setting mac_addr as %08x%04x\n",
-			   pdata->mac_idx,  mac_addr_lo,
-			   (mac_addr_hi & 0x0000FFFF));
+		mac_dbg("XGMAC %d: Setting mac_addr as %08x%04x\n",
+			pdata->mac_idx,  mac_addr_lo,
+			(mac_addr_hi & 0x0000FFFF));
 		XGMAC_RGWR(pdata, MAC_MACA0LR, mac_addr_lo);
 	}
 
@@ -512,8 +522,8 @@ int xgmac_set_checksum_offload(void *pdev, u32 val)
 	u32 reg_val = XGMAC_RGRD(pdata, MAC_RX_CFG);
 
 	if (MAC_GET_VAL(reg_val, MAC_RX_CFG, IPC) != val) {
-		mac_printf("XGMAC %d: Setting rx_checksum_offload as %s\n",
-			   pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: Setting rx_checksum_offload as %s\n",
+			pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(reg_val, MAC_RX_CFG, IPC, val);
 		XGMAC_RGWR(pdata, MAC_RX_CFG, reg_val);
 	}
@@ -610,8 +620,8 @@ int xgmac_set_rxcrc(void *pdev, u32 val)
 	mac_rcr = XGMAC_RGRD(pdata, MAC_RX_CFG);
 	MAC_SET_VAL(mac_rcr, MAC_RX_CFG, DCRCC, val);
 
-	mac_printf("XGMAC %d: Rx CRC check: %s\n", pdata->mac_idx,
-		   val ? "DISABLED" : "ENABLED");
+	mac_dbg("XGMAC %d: Rx CRC check: %s\n", pdata->mac_idx,
+		val ? "DISABLED" : "ENABLED");
 
 	XGMAC_RGWR(pdata, MAC_RX_CFG, mac_rcr);
 
@@ -646,22 +656,22 @@ int xgmac_powerup(void *pdev)
 
 	/* Enable MAC Tx */
 	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, TE) != 1) {
-		mac_printf("XGMAC %d: MAC TX: ENABLED\n", pdata->mac_idx);
+		mac_dbg("XGMAC %d: MAC TX: ENABLED\n", pdata->mac_idx);
 		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, TE, 1);
 		XGMAC_RGWR(pdata, MAC_TX_CFG, mac_tcr);
 	}
 
 	/* Enable MAC Rx */
 	if (MAC_GET_VAL(mac_rcr, MAC_RX_CFG, RE) != 1) {
-		mac_printf("XGMAC %d: MAC RX: ENABLED\n", pdata->mac_idx);
+		mac_dbg("XGMAC %d: MAC RX: ENABLED\n", pdata->mac_idx);
 		MAC_SET_VAL(mac_rcr, MAC_RX_CFG, RE, 1);
 		XGMAC_RGWR(pdata, MAC_RX_CFG, mac_rcr);
 	}
 
 	/* Enable MAC Filter Rx All */
 	if (MAC_GET_VAL(mac_pfr, MAC_PKT_FR, RA) != 1) {
-		mac_printf("XGMAC %d: MAC Filter Receive All: ENABLED\n",
-			   pdata->mac_idx);
+		mac_dbg("XGMAC %d: MAC Filter Receive All: ENABLED\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_pfr, MAC_PKT_FR, RA, 1);
 		XGMAC_RGWR(pdata, MAC_PKT_FR, mac_pfr);
 	}
@@ -678,22 +688,22 @@ int xgmac_powerdown(void *pdev)
 
 	/* Disable MAC Tx */
 	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, TE) != 0) {
-		mac_printf("XGMAC %d: MAC TX: DISABLED\n", pdata->mac_idx);
+		mac_dbg("XGMAC %d: MAC TX: DISABLED\n", pdata->mac_idx);
 		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, TE, 0);
 		XGMAC_RGWR(pdata, MAC_TX_CFG, mac_tcr);
 	}
 
 	/* Disable MAC Rx */
 	if (MAC_GET_VAL(mac_rcr, MAC_RX_CFG, RE) != 0) {
-		mac_printf("XGMAC %d: MAC RX: DISABLED\n", pdata->mac_idx);
+		mac_dbg("XGMAC %d: MAC RX: DISABLED\n", pdata->mac_idx);
 		MAC_SET_VAL(mac_rcr, MAC_RX_CFG, RE, 0);
 		XGMAC_RGWR(pdata, MAC_RX_CFG, mac_rcr);
 	}
 
 	/* Disable MAC Filter Rx All */
 	if (MAC_GET_VAL(mac_pfr, MAC_PKT_FR, RA) != 0) {
-		mac_printf("XGMAC %d: MAC Filter Receive All: DISABLED\n",
-			   pdata->mac_idx);
+		mac_dbg("XGMAC %d: MAC Filter Receive All: DISABLED\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_pfr, MAC_PKT_FR, RA, 0);
 		XGMAC_RGWR(pdata, MAC_PKT_FR, mac_pfr);
 	}
@@ -729,8 +739,8 @@ int xgmac_set_eee_mode(void *pdev, u32 val)
 	u32 mac_lpiscr = XGMAC_RGRD(pdata, MAC_LPI_CSR);
 
 	if (MAC_GET_VAL(mac_lpiscr, MAC_LPI_CSR, LPITXEN) != val) {
-		mac_printf("XGMAC %d: LPI Transmit Enable: %s\n",
-			   pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: LPI Transmit Enable: %s\n",
+			pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(mac_lpiscr, MAC_LPI_CSR, LPITXA, val);
 		MAC_SET_VAL(mac_lpiscr, MAC_LPI_CSR, LPITXEN, val);
 	}
@@ -747,8 +757,8 @@ u32 xgmac_get_eee_mode(void *pdev)
 
 	lpitxen = XGMAC_RGRD_BITS(pdata, MAC_LPI_CSR, LPITXEN);
 
-	mac_printf("\tLPI Transmit Enable: %s\n",
-		   lpitxen ? "ENABLED" : "DISABLED");
+	mac_dbg("\tLPI Transmit Enable: %s\n",
+		lpitxen ? "ENABLED" : "DISABLED");
 
 	return lpitxen;
 }
@@ -769,8 +779,8 @@ int xgmac_set_eee_pls(void *pdev, u32 val)
 
 	/* Disable MAC Tx */
 	if (MAC_GET_VAL(reg_val, MAC_LPI_CSR, PLS) != val) {
-		mac_printf("XGMAC %d: Phy link Status: %s\n",
-			   pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: Phy link Status: %s\n",
+			pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(reg_val, MAC_LPI_CSR, PLS, val);
 		XGMAC_RGWR(pdata, MAC_LPI_CSR, reg_val);
 	}
@@ -825,8 +835,8 @@ int xgmac_set_crc_strip_type(void *pdev, u32 val)
 	reg_val = XGMAC_RGRD(pdata, MAC_RX_CFG);
 
 	if (MAC_GET_VAL(reg_val, MAC_RX_CFG, CST) != val) {
-		mac_printf("XGMAC %d: CRC stripping for Type packets: %s\n",
-			   pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: CRC stripping for Type packets: %s\n",
+			pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(reg_val, MAC_RX_CFG, CST, val);
 		XGMAC_RGWR(pdata, MAC_RX_CFG, reg_val);
 	}
@@ -850,8 +860,8 @@ int xgmac_set_acs(void *pdev, u32 val)
 	reg_val = XGMAC_RGRD(pdata, MAC_RX_CFG);
 
 	if (MAC_GET_VAL(reg_val, MAC_RX_CFG, ACS) != val) {
-		mac_printf("XGMAC %d: Automatic Pad or CRC Stripping: %s\n",
-			   pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: Automatic Pad or CRC Stripping: %s\n",
+			pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(reg_val, MAC_RX_CFG, ACS, val);
 		XGMAC_RGWR(pdata, MAC_RX_CFG, reg_val);
 	}
@@ -873,8 +883,8 @@ int xgmac_set_ipg(void *pdev, u32 ipg)
 	reg_val = XGMAC_RGRD(pdata, MAC_TX_CFG);
 
 	if (MAC_GET_VAL(reg_val, MAC_TX_CFG, IPG) != ipg) {
-		mac_printf("XGMAC %d: IPG set to %d bytes\n",
-			   pdata->mac_idx, ((96 + (ipg * 32)) / 8));
+		mac_dbg("XGMAC %d: IPG set to %d bytes\n",
+			pdata->mac_idx, ((96 + (ipg * 32)) / 8));
 		MAC_SET_VAL(reg_val, MAC_TX_CFG, IPG, ipg);
 		XGMAC_RGWR(pdata, MAC_TX_CFG, reg_val);
 	}
@@ -904,14 +914,14 @@ int xgmac_set_magic_pmt(void *pdev, u32 val)
 	mac_pmtcsr = XGMAC_RGRD(pdata, MAC_PMT_CSR);
 
 	if (MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, MGKPKTEN) != val) {
-		mac_printf("XGMAC %d: Magic Packet: %s\n",
-			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: Magic Packet: %s\n",
+			pdata->mac_idx, val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(mac_pmtcsr, MAC_PMT_CSR, MGKPKTEN, val);
 	}
 
 	if (MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, PWRDWN) != val) {
-		mac_printf("XGMAC %d: Power Down Mode: %s\n",
-			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: Power Down Mode: %s\n",
+			pdata->mac_idx, val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(mac_pmtcsr, MAC_PMT_CSR, PWRDWN, val);
 	}
 
@@ -929,14 +939,14 @@ int xgmac_pmt_int_clr(void *pdev)
 	mac_pmtcsr = XGMAC_RGRD(pdata, MAC_PMT_CSR);
 
 	if (MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, MGKPRCVD)) {
-		mac_printf("XGMAC %d: Clearing Magic packet "
-			   "Interrupt\n", pdata->mac_idx);
+		mac_dbg("XGMAC %d: Clearing Magic packet "
+			"Interrupt\n", pdata->mac_idx);
 		ret = 0;
 	}
 
 	if (MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, RWKPRCVD)) {
-		mac_printf("XGMAC %d: Clearing Remote wakeup packet "
-			   "Interrupt\n", pdata->mac_idx);
+		mac_dbg("XGMAC %d: Clearing Remote wakeup packet "
+			"Interrupt\n", pdata->mac_idx);
 		ret = 0;
 	}
 
@@ -953,13 +963,13 @@ int xgmac_lpi_int_clr(void *pdev)
 	varmac_lps = XGMAC_RGRD(pdata, MAC_LPI_CSR);
 
 	if (MAC_GET_VAL(varmac_lps, MAC_LPI_CSR, TLPIEN)) {
-		//mac_printf("XGMAC %d: Clearing LPI TX Interrupt Status\n",
+		//mac_dbg("XGMAC %d: Clearing LPI TX Interrupt Status\n",
 		//	   pdata->mac_idx);
 		ret = 0;
 	}
 
 	if (MAC_GET_VAL(varmac_lps, MAC_LPI_CSR, RLPIEN)) {
-		//mac_printf("XGMAC %d: Clearing LPI RX Interrupt Status\n",
+		//mac_dbg("XGMAC %d: Clearing LPI RX Interrupt Status\n",
 		//	   pdata->mac_idx);
 		ret = 0;
 	}
@@ -980,14 +990,14 @@ int xgmac_set_rwk_pmt(void *pdev, u32 val)
 	mac_pmtcsr = XGMAC_RGRD(pdata, MAC_PMT_CSR);
 
 	if (MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, RWKPKTEN) != val) {
-		mac_printf("XGMAC %d: Remote Wakeup Packet: %s\n",
-			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: Remote Wakeup Packet: %s\n",
+			pdata->mac_idx, val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(mac_pmtcsr, MAC_PMT_CSR, RWKPKTEN, val);
 	}
 
 	if (MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, PWRDWN) != val) {
-		mac_printf("XGMAC %d: Power Down Mode: %s\n",
-			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: Power Down Mode: %s\n",
+			pdata->mac_idx, val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(mac_pmtcsr, MAC_PMT_CSR, PWRDWN, val);
 	}
 
@@ -1019,8 +1029,8 @@ int xgmac_set_pmt_gucast(void *pdev, u32 val)
 	mac_pmtcsr = XGMAC_RGRD(pdata, MAC_PMT_CSR);
 
 	if (MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, GLBLUCAST) != val) {
-		mac_printf("XGMAC %d: PMT Global Unicast: %s\n",
-			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: PMT Global Unicast: %s\n",
+			pdata->mac_idx, val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(mac_pmtcsr, MAC_PMT_CSR, GLBLUCAST, val);
 	}
 
@@ -1037,8 +1047,8 @@ int xgmac_set_extcfg(void *pdev, u32 val)
 	mac_extcfg = XGMAC_RGRD(pdata, MAC_EXTCFG);
 
 	if (MAC_GET_VAL(mac_extcfg, MAC_EXTCFG, SBDIOEN) != val) {
-		mac_printf("XGMAC %d: MAC Extended CFG SBDIOEN: %s\n",
-			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: MAC Extended CFG SBDIOEN: %s\n",
+			pdata->mac_idx, val ? "ENABLED" : "DISABLED");
 
 		MAC_SET_VAL(mac_extcfg, MAC_EXTCFG, SBDIOEN, val);
 
@@ -1048,7 +1058,7 @@ int xgmac_set_extcfg(void *pdev, u32 val)
 	return 0;
 }
 
-void xgmac_set_mac_rxtx(void *pdev, u32 wd, u32 jd)
+int xgmac_set_mac_rxtx(void *pdev, u32 wd, u32 jd)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 reg_val;
@@ -1056,8 +1066,8 @@ void xgmac_set_mac_rxtx(void *pdev, u32 wd, u32 jd)
 	reg_val = XGMAC_RGRD(pdata, MAC_RX_CFG);
 
 	if (MAC_GET_VAL(reg_val, MAC_RX_CFG, WD) != wd) {
-		mac_printf("XGMAC %d: WD: %s\n",
-			   pdata->mac_idx, wd ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: WD: %s\n",
+			pdata->mac_idx, wd ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(reg_val, MAC_RX_CFG, WD, wd);
 		XGMAC_RGWR(pdata, MAC_RX_CFG, reg_val);
 	}
@@ -1065,11 +1075,13 @@ void xgmac_set_mac_rxtx(void *pdev, u32 wd, u32 jd)
 	reg_val = XGMAC_RGRD(pdata, MAC_TX_CFG);
 
 	if (MAC_GET_VAL(reg_val, MAC_TX_CFG, JD) != jd) {
-		mac_printf("XGMAC %d: JD: %s\n",
-			   pdata->mac_idx, jd ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: JD: %s\n",
+			pdata->mac_idx, jd ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(reg_val, MAC_TX_CFG, JD, jd);
 		XGMAC_RGWR(pdata, MAC_TX_CFG, reg_val);
 	}
+
+	return 0;
 }
 
 /* LPIATE: LPI Auto Timer Enable
@@ -1109,14 +1121,14 @@ int xgmac_set_mac_lpitx(void *pdev, u32 val)
 	lpiate = XGMAC_RGRD(pdata, MAC_LPI_CSR);
 
 	if (MAC_GET_VAL(lpiate, MAC_LPI_CSR, LPIATE) != val) {
-		mac_printf("XGMAC %d: LPIATE: %s\n",
-			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: LPIATE: %s\n",
+			pdata->mac_idx, val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(lpiate, MAC_LPI_CSR, LPIATE, val);
 	}
 
 	if (MAC_GET_VAL(lpiate, MAC_LPI_CSR, LPITXA) != val) {
-		mac_printf("XGMAC %d: LPITXA: %s\n",
-			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: LPITXA: %s\n",
+			pdata->mac_idx, val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(lpiate, MAC_LPI_CSR, LPITXA, val);
 	}
 
@@ -1279,12 +1291,12 @@ int xgmac_get_txtstamp_cnt(void *pdev)
 	tx_sts = XGMAC_RGRD(pdata, MAC_TSTAMP_STSR);
 
 	ttsns = MAC_GET_VAL(tx_sts, MAC_TSTAMP_STSR, TTSNS);
-	mac_printf("\tTx Timestamp Fifo: %d\n", ttsns);
+	mac_dbg("\tTx Timestamp Fifo: %d\n", ttsns);
 
 	/* Max Fifo Value*/
 	if (ttsns == 16)
-		mac_printf("XGMAC %d: Tx Timestamp Fifo is Full\n",
-			   pdata->mac_idx);
+		mac_dbg("XGMAC %d: Tx Timestamp Fifo is Full\n",
+			pdata->mac_idx);
 
 	return ttsns;
 }
@@ -1300,7 +1312,7 @@ int xgmac_get_txtstamp_pktid(void *pdev)
 	tx_sts = XGMAC_RGRD(pdata, MAC_TXTSTAMP_STS);
 
 	pktid = MAC_GET_VAL(tx_sts, MAC_TXTSTAMP_STS, PKTID);
-	mac_printf("\tTx Timestamp PacketID: %d\n", pktid);
+	mac_dbg("\tTx Timestamp PacketID: %d\n", pktid);
 
 	return pktid;
 }
@@ -1476,10 +1488,10 @@ int xgmac_set_hwtstamp_settings(void *pdev,
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 mac_tscr = 0;
-	struct ptp_flags ptp_flgs;
+	struct ptp_flags ptp_flgs = {0};
 
-	mac_printf("Mac Idx %d\n", pdata->mac_idx);
-	mac_printf("tx_type = %d, rx_filter = %d\n", tx_type, rx_filter);
+	mac_dbg("Mac Idx %d\n", pdata->mac_idx);
+	mac_dbg("tx_type = %d, rx_filter = %d\n", tx_type, rx_filter);
 
 	switch (tx_type) {
 	case HWTSTAMP_TX_OFF:
@@ -1649,7 +1661,7 @@ int xgmac_set_hwtstamp_settings(void *pdev,
 	return 0;
 }
 
-void xgmac_set_exttime_source(void *pdev, u32 val)
+int xgmac_set_exttime_source(void *pdev, u32 val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 reg_val;
@@ -1657,17 +1669,19 @@ void xgmac_set_exttime_source(void *pdev, u32 val)
 	reg_val = XGMAC_RGRD(pdata, MAC_TSTAMP_CR);
 
 	if (MAC_GET_VAL(reg_val, MAC_TSTAMP_CR, ESTI) != val) {
-		mac_printf("XGMAC %d: External Ref Time: %s\n",
-			   pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: External Ref Time: %s\n",
+			pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(reg_val, MAC_TSTAMP_CR, ESTI, val);
 		XGMAC_RGWR(pdata, MAC_TSTAMP_CR, reg_val);
 	}
+
+	return 0;
 }
 
-void xgmac_ptp_txtstamp_mode(void *pdev,
-			     u32 snaptypesel,
-			     u32 tsmstrena,
-			     u32 tsevntena)
+int xgmac_ptp_txtstamp_mode(void *pdev,
+			    u32 snaptypesel,
+			    u32 tsmstrena,
+			    u32 tsevntena)
 {
 	u32 mac_tscr = 0;
 
@@ -1681,6 +1695,8 @@ void xgmac_ptp_txtstamp_mode(void *pdev,
 	MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSENA, 1);
 
 	xgmac_config_tstamp(pdev, mac_tscr);
+
+	return 0;
 }
 
 int xgmac_set_gint(void *pdev, u32 val)
@@ -1690,8 +1706,8 @@ int xgmac_set_gint(void *pdev, u32 val)
 
 	/* Enable/Disable MAC G9991EN */
 	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, G9991EN) != val) {
-		mac_printf("XGMAC %d: G9991EN: %s\n", pdata->mac_idx,
-			   val ? "ENABLED" : "DISABLED");
+		mac_dbg("XGMAC %d: G9991EN: %s\n", pdata->mac_idx,
+			val ? "ENABLED" : "DISABLED");
 		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, G9991EN, val);
 		XGMAC_RGWR(pdata, MAC_TX_CFG, mac_tcr);
 	}
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_main.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_main.c
index 17f1c5b31ba4..9d0df45e63fd 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_main.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_main.c
@@ -39,522 +39,13 @@
  * DAMAGE.
  * =========================================================================
  */
-
 #include <xgmac.h>
 #include <gswss_mac_api.h>
 #include <xgmac_mdio.h>
 #include <mac_cfg.h>
 #include <lmac_api.h>
 
-static void xgmac_menu(void);
-static void set_data(u8 *argv[], int i, u32 *start_arg, u32 idx);
-static void set_pdata(u8 *arg, u32 idx, u32 *data, u32 *start_arg);
-static void set_all_pdata(u8 *arg, u32 *data, u32 *start_arg);
-
-struct _xgmac_cfg {
-	char name[256];
-	void (*set_func)(void *);
-	int (*get_func)(void *);
-	u32 args;
-	u32 *data1;
-	u32 *data2;
-	u32 *data3;
-	u32 *data4;
-	char help[1024];
-};
-
 struct mac_prv_data prv_data[10];
-struct mac_prv_data pdata;
-
-struct _xgmac_cfg xgmac_cfg_table[] = {
-	/* Name  WritePtr ReadPtr  Args,Data1,Data2,Data3,Data4	Help	*/
-	{
-		"init            ",
-		cli_init,
-		0,
-		0, &pdata.init_val, 0, 0, 0,
-		"<Initialize the module based on the Index Set>"
-	},
-	{
-		"reset           ",
-		cli_reset,
-		0,
-		0, 0, 0, 0, 0,
-		"<XGMAC Reset 1/0 Reset/No reset>"
-	},
-	{
-		"regtest         ",
-		cli_test_all_reg,
-		0,
-		0, 0, 0, 0, 0,
-		"<Test all registers>"
-	},
-	/* MTL REGISTER SETTINGS */
-	{
-		"mtl_tx          ",
-		cli_set_mtl_tx,
-		xgmac_get_mtl_tx,
-		0, &pdata.tx_sf_mode, &pdata.tx_threshold, 0, 0,
-		"<args 2: 1/0: store_forward/threshold arg 2 0:64, 1:res, 2:96, 3:128, 4:192, 5:256, 6:384, 7:512>"
-	},
-	{
-		"mtl_rx          ",
-		cli_set_mtl_rx,
-		xgmac_get_mtl_rx,
-		0, &pdata.rx_sf_mode, &pdata.rx_threshold, 0, 0,
-		"<args 2: 1/0: store_forward/threshold args 2: 0:64, 1:res, 2:96, 3:128>"
-	},
-	{
-		"flow_ctrl_thresh",
-		cli_flow_ctrl_thresh,
-		xgmac_get_mtl_rx_flow_ctl,
-		0, &pdata.rfa, &pdata.rfd, 0, 0,
-		"<args 2: Thresh to act Flow Ctrl, Thresh to de-act Flow Ctrl>"
-	},
-	{
-		"ts_addend       ",
-		cli_set_tstamp_addend,
-		0,
-		0, &pdata.tstamp_addend, 0, 0, 0,
-		"<args 1: Timestamd addend val>"
-	},
-	{
-		"systime         ",
-		0,
-		xgmac_print_system_time,
-		0, 0, 0, 0, 0,
-		"Print System time"
-	},
-	{
-		"ts_enable       ",
-		cli_set_tstamp_enable,
-		0,
-		0, 0, 0, 0, 0,
-		"Tx Timestamp Enable"
-	},
-	{
-		"ts_disable      ",
-		cli_set_tstamp_disable,
-		0,
-		0, 0, 0, 0, 0,
-		"Disable TX and RX timestamp"
-	},
-	{
-		"ptp_tx_mode     ",
-		cli_set_txtstamp_mode,
-		xgmac_get_txtstamp_mode,
-		0, &pdata.snaptype, &pdata.tsmstrena, &pdata.tsevntena, 0,
-		"<1/0: SnaptypeSel, 1/0: tsmstrena, 1/0: tseventena>"
-	},
-	{
-		"hwtstamp        ",
-		cli_set_hwtstamp_settings,
-		xgmac_get_tstamp_settings,
-		0, &pdata.tstamp_config.tx_type, &pdata.tstamp_config.rx_filter, 0, 0,
-		"<args 2: 1/0 TX timestamp ON/OFF, FILTER_TYPE: 0-14/ None/ALL/Some/V1L4EVENT/V1L4SYNC/V1L4DELAY_REQ/V2L4EVENT/V2L4SYNC/V2L4DELAYREQ/V2L2EVENT/V2L2SYNC/V2L2DELAYREQ/V2EVENT/V2SYNC/V2DELAYREQ>"
-	},
-	{
-		"flush_tx_q      ",
-		cli_flush_tx_queues,
-		0,
-		0, 0, 0, 0, 0,
-		"flush MTL transmit Q>"
-	},
-	{
-		"debug_en        ",
-		cli_set_debug_ctl,
-		xgmac_get_debug_sts,
-		0, &pdata.dbg_en, &pdata.dbg_mode, 0, 0,
-		"<args 2: 1/0 DBG_EN 1/0 DBGMODE/SLAVE MODE>"
-	},
-	{
-		"debug_tx        ",
-		cli_set_tx_debug_data,
-		0,
-		0, &pdata.dbg_pktstate, 0, 0, 0,
-		"<Pktstate 0/1/2/3 PKT_DATA/Ctrl_Word/SOP/EOP"
-	},
-	{
-		"debug_rx        ",
-		cli_set_rx_debug_data,
-		0,
-		0, 0, 0, 0, 0,
-		"<Pktstate 0/1/2/3 PKT_DATA/Normal Sts/Last Sts/EOP>"
-	},
-	{
-		"debug_data      ",
-		cli_set_debug_data,
-		0,
-		0, &pdata.dbg_data, 0, 0, 0,
-		"<args 1: debug_data pointer>"
-	},
-	{
-		"debug_int_en    ",
-		cli_set_rx_debugctrl_int,
-		0,
-		0, &pdata.dbg_pktie, 0, 0, 0,
-		"<args 1: 1/0 PKT INT EN>"
-	},
-	{
-		"debug_reset     ",
-		cli_set_fifo_reset,
-		0,
-		0, &pdata.dbg_rst_sel, &pdata.dbg_rst_all, 0, 0,
-		"<args 2: 1/0 RESET SEL FIFO, 1/0 RESET ALL FIFO>"
-	},
-	{
-		"dbg_rx          ",
-		cli_rx_packet_dbgmode,
-		0,
-		0, 0, 0, 0, 0,
-		"<Rx Packet in DBGMODE>"
-	},
-	{
-		"dbg_rx_slave    ",
-		cli_rx_packet_slavemode,
-		0,
-		0, 0, 0, 0, 0,
-		"<Rx Packet in SLAVEMODE>"
-	},
-	{
-		"error_pkt_fwd   ",
-		cli_set_fup_fep_pkt,
-		xgmac_get_fup_fep_setting,
-		0, &pdata.fup, &pdata.fef, 0, 0,
-		"<args 2: <1/0 enable/disable FUP, 1/0 enable/disable FEF>"
-	},
-	{
-		"int_en          ",
-		cli_set_int,
-		xgmac_dbg_int_sts,
-		0, &pdata.enable_mtl_int, &pdata.enable_mac_int, 0, 0,
-		"<MTL and MAC Interrupt Enable and get status>"
-	},
-	/* MAC REGISTER SETTINGS */
-	{
-		"mac_enable      ",
-		cli_set_mac_enable,
-		xgmac_get_mac_settings,
-		0, &pdata.mac_en, 0, 0, 0,
-		"<args 1: 1/0: MAC enable/disable>"
-	},
-	{
-		"mac_addr        ",
-		cli_set_mac_address,
-		xgmac_get_mac_addr,
-		0, (u32 *) &pdata.mac_addr, 0, 0, 0,
-		"<args 1: mac_addr>"
-	},
-	{
-		"mac_rx_mode     ",
-		cli_set_mac_rx_mode,
-		xgmac_get_mac_rx_mode,
-		0, &pdata.promisc_mode, &pdata.all_mcast_mode, 0, 0,
-		"<args 2: <1/0 enable/disable promisc, 1/0 accept/deny allmcast>"
-	},
-	{
-		"mtu             ",
-		cli_set_mtu,
-		mac_get_mtu,
-		0, &pdata.mtu, 0, 0, 0,
-		"<args 1: MTU value>"
-	},
-	{
-		"pause_time      ",
-		0,
-		0,
-		0, &pdata.pause_time, 0, 0, 0,
-		"<args 1: pause_time>"
-	},
-	{
-		"pause_frame_ctrl",
-		cli_set_pause_frame_ctrl,
-		xgmac_get_pause_frame_ctl,
-		0, &pdata.pause_frm_enable, &pdata.pause_time, 0, 0,
-		"<args 1: 1/0: enable pause frame/disable pause frame>"
-	},
-	{
-		"pause_filter    ",
-		cli_set_pause_frame_filter,
-		0,
-		0, &pdata.pause_filter, 0, 0, 0,
-		"<args 1: 1/0: enable pause frame filter/disable pause frame filter>"
-	},
-	{
-		"pause_tx        ",
-		cli_initiate_pause_tx,
-		0,
-		0, 0, 0, 0, 0,
-		"<Initiate PAUSE packet transmit>"
-	},
-	{
-		"speed           ",
-		cli_set_mac_speed,
-		mac_get_speed,
-		0, &pdata.phy_speed, 0, 0, 0,
-		"<args 1: 0/1/2/3:LMAC 10/100/200/1G  4/5/6/7/8/9:XGMAC 10/100/1G/2G5/5G/10G 10: 2G5-GMII>"
-	},
-	{
-		"duplex          ",
-		cli_set_duplex_mode,
-		0,
-		0, &pdata.duplex_mode, 0, 0, 0,
-		"<args 1: 0/1/2:Full/Half/Auto>"
-	},
-	{
-		"rx_csum_offload ",
-		cli_set_csum_offload,
-		xgmac_get_checksum_offload,
-		0, &pdata.rx_checksum_offload, 0, 0, 0,
-		"<args 1: 1/0: enable/disable rx checksum offload>"
-	},
-	{
-		"loopback        ",
-		cli_set_loopback,
-		xgmac_get_mac_loopback_mode,
-		0, &pdata.loopback, 0, 0, 0,
-		"<args 1: 1/0: loopback enable/disable>"
-	},
-	{
-		"eee             ",
-		cli_set_eee_mode,
-		xgmac_get_eee_settings,
-		0, &pdata.eee_enable, 0, 0, 0,
-		"<args 1: 1/0: enable/disable eee mode>"
-	},
-	{
-		"crc_strip_type  ",
-		cli_set_crc_strip_type,
-		xgmac_get_crc_settings,
-		0, &pdata.crc_strip_type, 0, 0, 0,
-		"<args 1: 1/0: enable/disable crc strip>"
-	},
-	{
-		"crc_strip_acs   ",
-		cli_set_crc_strip_acs,
-		xgmac_get_crc_settings,
-		0, &pdata.padcrc_strip, 0, 0, 0,
-		"<args 1: 1/0: enable/disable crc strip>"
-	},
-	{
-		"ipg             ",
-		cli_set_ipg,
-		xgmac_get_ipg,
-		0, &pdata.ipg, 0, 0, 0,
-		"<args 1 IPG val 0 - 4, default val 0>"
-	},
-	{
-		"magic_pmt       ",
-		cli_set_pmt_magic,
-		xgmac_dbg_pmt,
-		0, &pdata.magic_pkt_en, 0, 0, 0,
-		"<args 1: 1/0 MAGIC packet enable/disable for PMT>"
-	},
-	{
-		"rwk_pmt         ",
-		cli_set_pmt_rwk,
-		xgmac_dbg_pmt,
-		0, &pdata.rwk_pkt_en, 0, 0, 0,
-		"<args 1: 1/0 Remote Wake Up packet enable/disable for PMT>"
-	},
-	{
-		"gucast_pmt      ",
-		cli_set_pmt_gucast,
-		xgmac_dbg_pmt,
-		0, &pdata.gucast, 0, 0, 0,
-		"<args 1: 1/0 PMT Global Unicast ENABLE/DISABLE>"
-	},
-	{
-		"extcfg          ",
-		cli_set_extcfg,
-		xgmac_get_extcfg,
-		0, &pdata.extcfg, 0, 0, 0,
-		"<args 1: 1/0 ExtCfg SBDIOEN>"
-	},
-	{
-		"rxtx            ",
-		cli_set_macrxtxcfg,
-		xgmac_get_mac_rxtx_sts,
-		0, &pdata.jd, &pdata.wd, 0, 0,
-		"<args 2: 1/0 Jabber Disable 1/0 Watchdog Disable>"
-	},
-	{
-		"miss_ovf_pkt_cnt",
-		0,
-		xgmac_get_mtl_missed_pkt_cnt,
-		0, 0, 0, 0, 0,
-		"<Missed Overflow packet count>"
-	},
-	{
-		"uflow_pkt_cnt   ",
-		0,
-		xgmac_get_mtl_underflow_pkt_cnt,
-		0, 0, 0, 0, 0,
-		"<Underflow packet count>"
-	},
-	{
-		"tstamp_sts      ",
-		0,
-		xgmac_get_tstamp_status,
-		0, 0, 0, 0, 0,
-		"<Get timestamp status>"
-	},
-	{
-		"txtstamp_cnt      ",
-		0,
-		xgmac_get_txtstamp_cnt,
-		0, 0, 0, 0, 0,
-		"<Get txtstamp count>"
-	},
-	{
-		"txtstamp_pktid      ",
-		0,
-		xgmac_get_txtstamp_pktid,
-		0, 0, 0, 0, 0,
-		"<Get txtstamp pktid>"
-	},
-	{
-		"linksts         ",
-		cli_set_linksts,
-		0,
-		0, &pdata.linksts, 0, 0, 0,
-		"<0/1/2 UP/DOWN/AUTO>"
-	},
-	{
-		"lpitx           ",
-		cli_set_lpitx,
-		0,
-		0, &pdata.lpitxa, 0, 0, 0,
-		"<args 1: 1/0: enable/disable>"
-	},
-	{
-		"mdio_cl         ",
-		cli_set_mdio_cl,
-		0,
-		0, &pdata.mdio_cl, &pdata.phy_id, 0, 0,
-		"<args 2: 1/0: CL22/CL45, phy_id>"
-	},
-	{
-		"mdio_rd         ",
-		cli_mdio_rd,
-		0,
-		0, &pdata.dev_adr, &pdata.phy_id, &pdata.phy_reg, 0,
-		"<args 3: dev_adr, phy_id, phy_reg>"
-	},
-	{
-		"mdio_rd_cont    ",
-		cli_mdio_rd_cont,
-		0,
-		0, &pdata.dev_adr, &pdata.phy_id, &pdata.phy_reg_st, &pdata.phy_reg_end,
-		"<args 4: dev_adr, phy_id, phy_reg_st, phy_reg_end>"
-	},
-	{
-		"mdio_wr         ",
-		cli_mdio_wr,
-		0,
-		0, &pdata.dev_adr, &pdata.phy_id, &pdata.phy_reg, &pdata.phy_data,
-		"<args 4: dev_adr, phy_id, phy_reg, phy_data>"
-	},
-	{
-		"mdio_int        ",
-		cli_set_mdio_int,
-		xgmac_mdio_get_int_sts,
-		0, &pdata.mdio_int, 0, 0, 0,
-		"<args 1: <mdio_int>"
-	},
-	{
-		"fcs_gen         ",
-		cli_set_fcsgen,
-		0,
-		0, &pdata.fcsgen, 0, 0, 0,
-		"<args 1: 0/1/2 CRC_PAD_ENA/CRC_EN_PAD_DIS/CRC_PAD_DIS>"
-	},
-	{
-		"gint             ",
-		cli_set_gint,
-		0,
-		0, &pdata.val, 0, 0, 0,
-		"<args 1: 1/0 G.INT ENABLE/DISABLE>"
-	},
-	{
-		"rx_crc             ",
-		cli_set_rxcrc,
-		0,
-		0, &pdata.val, 0, 0, 0,
-		"<args 1: 1/0 Rx Crc check DISABLE/ENABLE>"
-	},
-	{
-		"fifo             ",
-		0,
-		cli_get_fifo,
-		0, 0, 0, 0, 0,
-		"<Get Tx Fifo>"
-	},
-	{
-		"fifo_add             ",
-		cli_add_fifo,
-		0,
-		0, 0, 0, 0, 0,
-		"<Add Tx Fifo>"
-	},
-	{
-		"fifo_del             ",
-		cli_del_fifo,
-		0,
-		0, &pdata.rec_id, 0, 0, 0,
-		"<Del Tx Fifo>"
-	},
-	{
-		"ts_src_sel             ",
-		cli_set_extsrc,
-		0,
-		0, &pdata.val, 0, 0, 0,
-		"<REF: 0/1 - Internal/External>"
-	},
-	/* OTHERS */
-	{
-		"rmon            ",
-		0,
-		cli_get_rmon,
-		0, 0, 0, 0, 0,
-		"<args 1: 1: reset 0: no reset>"
-	},
-	{
-		"clear_rmon      ",
-		cli_clear_rmon_all,
-		0,
-		0, 0, 0, 0, 0,
-		"<clear rmon>"
-	},
-	{
-		"rmon_cfg        ",
-		0,
-		xgmac_get_counters_cfg,
-		0, 0, 0, 0, 0,
-		"<RMON config>"
-	},
-	{
-		"priv_data       ",
-		0,
-		xgmac_get_priv_data,
-		0, 0, 0, 0, 0,
-		"<read private data>"
-	},
-	{
-		"hw_feat         ",
-		0,
-		xgmac_print_hw_cap,
-		0, 0, 0, 0, 0,
-		"<get all hw features>"
-	},
-	{
-		"all             ",
-		0,
-		xgmac_get_all_hw_settings,
-		0, 0, 0, 0, 0,
-		"<Get all HW settings>"
-	},
-};
 
 u32 wakeup_filter_config[] = {
 	/* for filter 0 CRC is computed on 0 - 7 bytes from offset */
@@ -593,76 +84,41 @@ int populate_filter_frames(void *pdev)
 	return 0;
 }
 
-void removeSpace(char *str)
-{
-	char *p1 = str, *p2 = str;
-
-	do
-		while (*p2 == ' ')
-			p2++;
-
-	while ((*p1++ = *p2++));
-}
-
-void xgmac_menu(void)
-{
-	int i = 0;
-
-	int num_of_elem = (sizeof(xgmac_cfg_table) / sizeof(struct _xgmac_cfg));
-
-	mac_printf("\n MAC SET API's\n\n");
-
-	for (i = 0; i < num_of_elem; i++) {
-		if (xgmac_cfg_table[i].set_func)
-			mac_printf("switch_cli xgmac <0/1/2/* MacIdx> %15s \t %s \n",
-				   xgmac_cfg_table[i].name,
-				   xgmac_cfg_table[i].help);
-	}
-
-	mac_printf("\n MAC GET API's\n\n");
-
-	for (i = 0; i < num_of_elem; i++) {
-		if (xgmac_cfg_table[i].get_func)
-			mac_printf("switch_cli xgmac <0/1/2/ MacIdx> get %s\n",
-				   xgmac_cfg_table[i].name);
-	}
-}
-
-void xgmac_wr_reg(void *pdev, u16 reg_off, u32 reg_val)
+int xgmac_wr_reg(void *pdev, u32 reg_off, u32 reg_val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 
-	mac_printf("\tREG offset: 0x%04x\n\tData: %08X\n", reg_off,
-		   reg_val);
-
 	XGMAC_RGWR(pdata, reg_off, reg_val);
+
+	return 0;
 }
 
-u32 xgmac_rd_reg(void *pdev, u16 reg_off)
+int xgmac_rd_reg(void *pdev, u32 reg_off)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 
-	pdata->reg_val = XGMAC_RGRD(pdata, reg_off);
-
-	mac_printf("\tREG offset: 0x%04x\n\tData: %08X\n", reg_off,
-		   pdata->reg_val);
+	pdata->mac_cli->val[0] = XGMAC_RGRD(pdata, reg_off);
 
-	return pdata->reg_val;
+	return pdata->mac_cli->val[0];
 }
 
+
 u8 mac_addr[6] = {0x00, 0x00, 0x94, 0x00, 0x00, 0x08};
 
 void xgmac_init_pdata(struct mac_prv_data *pdata, int idx)
 {
 #ifdef __KERNEL__
 	memset(pdata, 0, sizeof(struct mac_prv_data));
-#endif
+	pdata->mac_idx = idx;
+#else
 
 	if (idx == -1)
 		pdata->mac_idx = (pdata - &prv_data[0]);
 	else
 		pdata->mac_idx = idx;
 
+#endif
+
 	pdata->xgmac_ctrl_reg = XGMAC_CTRL_REG(pdata->mac_idx);
 	pdata->xgmac_data1_reg = XGMAC_DATA1_REG(pdata->mac_idx);
 	pdata->xgmac_data0_reg = XGMAC_DATA0_REG(pdata->mac_idx);
@@ -714,331 +170,14 @@ void xgmac_init_pdata(struct mac_prv_data *pdata, int idx)
 	pdata->nsec			= 0;
 	pdata->ptp_clk			= PTP_CLK;
 	pdata->one_nsec_accuracy	= 1;
-	pdata->ss_addr_base		= adap_priv_data.ss_addr_base;
-	pdata->lmac_addr_base		= LEGACY_MAC_BASE;
 #if defined(PC_UTILITY) || defined(CHIPTEST)
+	pdata->lmac_addr_base		= LEGACY_MAC_BASE;
+	pdata->ss_addr_base		= adap_priv_data.ss_addr_base;
 	pdata->max_mac			= MAX_MAC;
-#endif
-}
-
-int xgmac_main(u32 argc, u8 *argv[])
-{
-	u32 i = 0, found = 0;
-	u32 start_arg = 0;
-	int idx = 0;
-	u32 max_mac;
-	u32 nanosec;
-	u32 sec, min, hr, days;
-
-	int num_of_elem =
-		(sizeof(xgmac_cfg_table) / sizeof(struct _xgmac_cfg));
-	struct mac_ops *ops = NULL;
-	struct mac_prv_data *prv_data_k = NULL;
-
-	prv_data[0].set_all = 0;
-	prv_data[1].set_all = 0;
-	prv_data[2].set_all = 0;
-
-	start_arg++;
-	start_arg++;
-
-	if(!argv[start_arg]) {
-		xgmac_menu();
-		goto end;
-	}
-	
-	if (!strcmp(argv[start_arg], "-help")) {
-		found = 1;
-		xgmac_menu();
-
-		goto end;
-	}
-
-	if (found)
-		goto end;
-
-	if (!strcmp(argv[start_arg], "*")) {
-		start_arg++;
-		max_mac = gsw_get_mac_subifcnt(0);
-
-		for (i = 0; i < max_mac; i++) {
-			prv_data[i].set_all = 1;
-			ops = gsw_get_mac_ops(0, i);
-			prv_data_k = GET_MAC_PDATA(ops);
-			prv_data_k->set_all = 1;
-		}
-
-	} else {
-		idx = mac_nstrtoul(argv[start_arg],
-				   mac_nstrlen(argv[start_arg]), &start_arg);
-
-		max_mac = gsw_get_mac_subifcnt(0);
-
-		if ((idx > (max_mac - 1)) || (idx < 0)) {
-			mac_printf("Give valid xgmac index 0/1/2/*\n");
-			return -1;
-		}
-
-		ops = gsw_get_mac_ops(0, idx);
-
-		if (!ops)
-			return -1;
-
-		prv_data_k = GET_MAC_PDATA(ops);
-
-		if (!prv_data_k)
-			return -1;
-
-		prv_data_k->set_all = 0;
-	}
-
-	if (!strcmp(argv[start_arg], "uptime")) {
-		found = 1;
-
-		sec = XGMAC_RGRD(prv_data_k, MAC_SYS_TIME_SEC);
-		nanosec = XGMAC_RGRD(prv_data_k, MAC_SYS_TIME_NSEC);
-
-		if (sec >= 60) {
-			min = sec / 60;
-			sec = sec - (min * 60);
-		} else {
-			min = 0;
-		}
-
-		if (min >= 60) {
-			hr = min / 60;
-			min = min - (hr * 60);
-		} else {
-			hr = 0;
-		}
-
-		if (hr >= 24) {
-			days = hr / 24;
-			hr = hr - (days * 24);
-		} else {
-			days = 0;
-		}
-
-		mac_printf("Uptime(d:h:m:s): %02d:%02d:%02d:%02d\n",
-			   days, hr, min, sec);
-
-		goto end;
-	}
-
-	if (!strcmp(argv[start_arg], "r")) {
-		start_arg++;
-		found = 1;
-#if defined(PC_UTILITY) || defined(__KERNEL__)
-
-		if ((strstr(argv[start_arg], "0x")) ||
-		    (strstr(argv[start_arg], "0X")))
-			mac_dbg("matches with 0x\n");
-		else
-			mac_printf("Please give the address with "
-				   "0x firmat\n");
-
-#endif
-
-		if (prv_data_k) {
-			prv_data_k->reg_off = mac_nstrtoul(argv[start_arg],
-							   mac_nstrlen(argv[start_arg]),
-							   &start_arg);
-			xgmac_rd_reg(ops, prv_data_k->reg_off);
-		}
-
-		goto end;
-	}
-
-	if (!strcmp(argv[start_arg], "w")) {
-		start_arg++;
-		found = 1;
-
-#if defined(PC_UTILITY) || defined(__KERNEL__)
-
-		if ((strstr(argv[start_arg], "0x")) ||
-		    (strstr(argv[start_arg], "0X")))
-			mac_dbg("matches with 0x\n");
-		else
-			mac_printf("Please give the address with "
-				   "0x format\n");
+	//Needed for continuous run of PMAC Time stamp and OAM time stamp tests in SWAT
+	memset(&pdata->ptp_flgs, 0, sizeof(struct ptp_flags));
 
 #endif
-
-		if (prv_data_k) {
-			prv_data_k->reg_off = mac_nstrtoul(argv[start_arg],
-							   mac_nstrlen(argv[start_arg]),
-							   &start_arg);
-			prv_data_k->reg_val = mac_nstrtoul(argv[start_arg],
-							   mac_nstrlen(argv[start_arg]),
-							   &start_arg);
-			xgmac_wr_reg(ops,
-				     prv_data_k->reg_off,
-				     prv_data_k->reg_val);
-		}
-
-		goto end;
-	}
-
-	if (!strcmp(argv[start_arg], "get")) {
-		start_arg++;
-
-		if(!argv[start_arg]) {
-			xgmac_menu();
-			goto end;
-		}
-		for (i = 0; i < num_of_elem; i++) {
-			removeSpace(xgmac_cfg_table[i].name);
-
-			if (!strcmp(xgmac_cfg_table[i].name,
-				    argv[start_arg])) {
-				if (xgmac_cfg_table[i].get_func)
-					xgmac_cfg_table[i].get_func(ops);
-
-				found = 1;
-				break;
-			}
-		}
-	}
-
-	if (found)
-		goto end;
-
-	for (i = 0; i < num_of_elem; i++) {
-		removeSpace(argv[start_arg]);
-
-		if (!strcmp(xgmac_cfg_table[i].name, argv[start_arg])) {
-			start_arg++;
-
-			if (argc != xgmac_cfg_table[i].args) {
-				mac_printf("[USAGE:]\n");
-				mac_printf("xgmac <idx> %s %s\n",
-					   xgmac_cfg_table[i].name,
-					   xgmac_cfg_table[i].help);
-				return 0;
-			}
-
-			set_data(argv, i, &start_arg, idx);
-
-			if (xgmac_cfg_table[i].set_func)
-				xgmac_cfg_table[i].set_func(ops);
-
-			found = 1;
-			break;
-		}
-	}
-
-end:
-
-	if (found == 0)
-		mac_printf("command entered is invalid, use -help to display"
-		"cmds\n");
-
-	return 0;
-}
-
-void set_data(u8 *argv[], int i, u32 *start_arg, u32 idx)
-{
-	if (prv_data[0].set_all == 1) {
-		set_all_pdata(argv[*start_arg],
-			      xgmac_cfg_table[i].data1, start_arg);
-		set_all_pdata(argv[*start_arg],
-			      xgmac_cfg_table[i].data2, start_arg);
-		set_all_pdata(argv[*start_arg],
-			      xgmac_cfg_table[i].data3, start_arg);
-		set_all_pdata(argv[*start_arg],
-			      xgmac_cfg_table[i].data4, start_arg);
-	} else {
-		set_pdata(argv[*start_arg], idx,
-			  xgmac_cfg_table[i].data1, start_arg);
-		set_pdata(argv[*start_arg], idx,
-			  xgmac_cfg_table[i].data2, start_arg);
-		set_pdata(argv[*start_arg], idx,
-			  xgmac_cfg_table[i].data3, start_arg);
-		set_pdata(argv[*start_arg], idx,
-			  xgmac_cfg_table[i].data4, start_arg);
-	}
-}
-
-void set_all_pdata(u8 *arg, u32 *data, u32 *start_arg)
-{
-	int j = 0, offset;
-	u32 val;
-	struct mac_ops *ops;
-	struct mac_prv_data *mac_priv_data;
-	u32 max_mac = gsw_get_mac_subifcnt(0);
-
-	if (data) {
-		offset = (u8 *)(data) - (u8 *)&pdata;
-		val = mac_nstrtoul(arg, mac_nstrlen(arg), start_arg);
-
-		*data = val;
-
-		for (j = 0; j < max_mac; j++) {
-#ifdef __KERNEL__
-			ops  = gsw_get_mac_ops(0, j);
-
-			if (ops) {
-				mac_priv_data = GET_MAC_PDATA(ops);
-				*(u32 *)(((u8 *)mac_priv_data + offset)) =
-					val;
-			}
-
-#else
-			*((u32 *)(((u8 *)&prv_data[j]) + offset)) = val;
-#endif
-		}
-	}
-}
-
-void set_pdata(u8 *arg, u32 idx, u32 *data, u32 *start_arg)
-{
-	int offset;
-	u32 val;
-	struct mac_ops *ops;
-	struct mac_prv_data *mac_priv_data;
-
-	if (data) {
-		offset = (u8 *)(data) - (u8 *)&pdata;
-		val =  mac_nstrtoul(arg, mac_nstrlen(arg), start_arg);
-
-		*data = val;
-
-#ifdef __KERNEL__
-		ops  = gsw_get_mac_ops(0, idx);
-
-		if (ops) {
-			mac_priv_data = GET_MAC_PDATA(ops);
-			*(u32 *)(((u8 *)mac_priv_data + offset)) = val;
-		}
-
-#else
-		*((u32 *)(((u8 *)&prv_data[idx]) + offset)) = val;
-#endif
-	}
-}
-
-void xgmac_cli_init(void)
-{
-	int i = 0;
-	int num_of_elem = (sizeof(xgmac_cfg_table) / sizeof(struct _xgmac_cfg));
-
-	for (i = 0; i < num_of_elem; i++) {
-		removeSpace(xgmac_cfg_table[i].name);
-
-		xgmac_cfg_table[i].args = 4;
-
-		if (xgmac_cfg_table[i].data1)
-			xgmac_cfg_table[i].args += 1;
-
-		if (xgmac_cfg_table[i].data2)
-			xgmac_cfg_table[i].args += 1;
-
-		if (xgmac_cfg_table[i].data3)
-			xgmac_cfg_table[i].args += 1;
-
-		if (xgmac_cfg_table[i].data4)
-			xgmac_cfg_table[i].args += 1;
-	}
 }
 
 #if defined(PC_UTILITY) || defined(CHIPTEST)
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mdio.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mdio.c
index 449dbf7eabe7..7a94595eb434 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mdio.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mdio.c
@@ -46,7 +46,6 @@
 #include <linux/of_mdio.h>
 #endif
 
-static void dump_phy_registers(void *pdev);
 
 /* SCAR:
  * DA
@@ -73,13 +72,12 @@ static void dump_phy_registers(void *pdev);
 int xgmac_mdio_single_rd(void *pdev,
 			 u32 dev_adr,
 			 u32 phy_id,
-			 u32 phy_reg,
-			 u32 *phy_reg_data)
+			 u32 phy_reg)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 mdio_sccdr = 0;
 	u32 mdio_scar = 0;
-
+	int phy_reg_data = 0;
 	/* wait for any previous MDIO read/write operation to complete */
 
 	/*Poll*/
@@ -123,9 +121,9 @@ int xgmac_mdio_single_rd(void *pdev,
 
 	/* read the data */
 	mdio_sccdr = XGMAC_RGRD(pdata, MDIO_SCCDR);
-	*phy_reg_data = MAC_GET_VAL(mdio_sccdr, MDIO_SCCDR, SDATA);
+	phy_reg_data = MAC_GET_VAL(mdio_sccdr, MDIO_SCCDR, SDATA);
 
-	return 0;
+	return phy_reg_data;
 }
 
 void print_mdio_rd_cnt(void *pdev,
@@ -137,15 +135,17 @@ void print_mdio_rd_cnt(void *pdev,
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	int clause;
-	u32 i, phy_reg_data;
+	int i, phy_reg_data;
 
-	clause = mdio_get_clause(pdata, pdata->mac_idx);
+	clause = mdio_get_clause(pdev, pdata->mac_idx);
 	mac_printf("OP    \tCL    \tDEVADR\tPHYID \tPHYREG\tDATA\n");
 	mac_printf("============================================\n");
 
 	for (i = 0; i <= (phy_reg_end - phy_reg_st); i++) {
-		xgmac_mdio_single_rd(pdev, dev_adr, phy_id, phy_reg_st + i,
-				     &phy_reg_data);
+		phy_reg_data = xgmac_mdio_single_rd(pdev,
+						    dev_adr,
+						    phy_id,
+						    phy_reg_st + i);
 
 		mac_printf("%s\t", "RD");
 		mac_printf("%4s\t", clause ? "CL22" : "CL45");
@@ -454,8 +454,8 @@ static int xgmac_mdio_read(struct mii_bus *bus, int phyadr, int phyreg)
 	if (clause != mdio_get_clause(pdev, phyadr))
 		mdio_set_clause(pdev, clause, phyadr);
 
-	xgmac_mdio_single_rd(pdev, (phyreg >> 16) & 0x1F, phyadr,
-			     phyreg & 0xFFFF, &phydata);
+	phydata = xgmac_mdio_single_rd(pdev, (phyreg >> 16) & 0x1F, phyadr,
+			     phyreg & 0xFFFF);
 
 	mac_dbg("XGMAC %d: MDIO Read phydata = %#x\n",
 		pdata->mac_idx, phydata);
@@ -501,39 +501,6 @@ static int xgmac_mdio_write(struct mii_bus *bus, int phyadr, int phyreg,
 	return ret;
 }
 
-/* API to reset PHY
- */
-static int xgmac_mdio_reset(struct mii_bus *bus)
-{
-	struct mac_ops *pdev = bus->priv;
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	int phydata;
-
-	mac_printf("XGMAC %d: MDIO Reset phyadr : %d\n", pdata->mac_idx,
-		   pdata->phyadr);
-
-	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_BMCR,
-			     &phydata);
-
-	if (phydata < 0)
-		return 0;
-
-	/* issue soft reset to PHY */
-	phydata |= BMCR_RESET;
-	xgmac_mdio_single_wr(pdev, 0, pdata->phyadr, MII_BMCR, phydata);
-
-	/* wait until software reset completes */
-	do {
-		xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_BMCR,
-				     &phydata);
-	} while ((phydata >= 0) && (phydata & BMCR_RESET));
-
-	mac_printf("XGMAC %d: MDIO Reset Completed\n",
-		   pdata->mac_idx);
-
-	return 0;
-}
-
 /* API to register mdio.
  */
 int xgmac_mdio_register(void *pdev)
@@ -543,9 +510,10 @@ int xgmac_mdio_register(void *pdev)
 	int ret = 0;
 	struct device_node *mdio_np;
 
-	mac_printf("XGMAC %d: mdio register\n", pdata->mac_idx);
+	mac_dbg("XGMAC %d: mdio register\n", pdata->mac_idx);
 
 	mdio_np = of_get_child_by_name(pdata->dev->of_node, "mdio");
+
 	if (!mdio_np) {
 		dev_dbg(pdata->dev, "XGMAC %d: mdio node not found\n",
 			pdata->mac_idx);
@@ -562,7 +530,7 @@ int xgmac_mdio_register(void *pdev)
 	new_bus->name = "xgmac_phy";
 	new_bus->read = xgmac_mdio_read;
 	new_bus->write = xgmac_mdio_write;
-	new_bus->reset = xgmac_mdio_reset;
+	new_bus->reset = NULL;
 	snprintf(new_bus->id, MII_BUS_ID_SIZE, "%s-%x", new_bus->name,
 		 pdata->mac_idx);
 	new_bus->priv = pdev;
@@ -574,6 +542,7 @@ int xgmac_mdio_register(void *pdev)
 	new_bus->phy_mask = 0xFFFFFFFF;
 
 	ret = of_mdiobus_register(new_bus, mdio_np);
+
 	if (ret != 0) {
 		pr_err("%s: Cannot register as MDIO bus\n",
 		       new_bus->name);
@@ -583,7 +552,7 @@ int xgmac_mdio_register(void *pdev)
 
 	pdata->mii = new_bus;
 
-	mac_printf("XGMAC %d: MDIO register Successful\n", pdata->mac_idx);
+	mac_dbg("XGMAC %d: MDIO register Successful\n", pdata->mac_idx);
 
 	return ret;
 }
@@ -610,62 +579,5 @@ void xgmac_mdio_unregister(void *pdev)
 	mac_printf("XGMAC %d: mdio_unregister Successful\n", pdata->mac_idx);
 }
 
-static void dump_phy_registers(void *pdev)
-{
-	u32 phydata = 0;
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 
-	mac_printf(
-		"\n************* PHY Reg dump *************************\n");
-	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_BMCR, &phydata);
-	mac_printf(
-		"Phy Control Reg(Basic Mode Control Reg) (%#x) = %#x\n",
-		MII_BMCR, phydata);
-
-	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_BMSR, &phydata);
-	mac_printf("Phy Status Reg(Basic Mode Status Reg) (%#x) = %#x\n",
-		   MII_BMSR, phydata);
-
-	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_PHYSID1, &phydata);
-	mac_printf("Phy Id (PHYS ID 1) (%#x)= %#x\n", MII_PHYSID1,
-		   phydata);
-
-	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_PHYSID2,
-			     &phydata);
-	mac_printf("Phy Id (PHYS ID 2) (%#x)= %#x\n", MII_PHYSID2,
-		   phydata);
-
-	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_ADVERTISE,
-			     &phydata);
-	mac_printf("Auto-nego Adv (Advertisement Control Reg)"
-		   " (%#x) = %#x\n", MII_ADVERTISE, phydata);
-
-	/* read Phy Control Reg */
-	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_LPA,
-			     &phydata);
-	mac_printf("Auto-nego Lap (Link Partner Ability Reg)"
-		   " (%#x)= %#x\n", MII_LPA, phydata);
-
-	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_EXPANSION,
-			     &phydata);
-	mac_printf("Auto-nego Exp (Extension Reg)"
-		   "(%#x) = %#x\n", MII_EXPANSION, phydata);
-
-	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_ESTATUS,
-			     &phydata);
-	mac_printf("Extended Status Reg (%#x) = %#x\n", MII_ESTATUS,
-		   phydata);
-
-	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_CTRL1000,
-			     &phydata);
-	mac_printf("1000 Ctl Reg (1000BASE-T Control Reg)"
-		   "(%#x) = %#x\n", MII_CTRL1000, phydata);
-
-	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_STAT1000, &phydata);
-	mac_printf("1000 Sts Reg (1000BASE-T Status)(%#x) = %#x\n",
-		   MII_STAT1000, phydata);
-
-	mac_printf(
-		"\n****************************************************\n");
-}
 #endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mdio.h b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mdio.h
index 3b82a22ce986..fc61a7334c90 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mdio.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mdio.h
@@ -232,8 +232,7 @@ int xgmac_mdio_single_wr(void *pdev,
 			 u32 phy_id,
 			 u32 phy_reg,
 			 u32 phy_reg_data);
-int xgmac_mdio_single_rd(void *pdev, u32 dev_adr, u32 phy_id,
-			 u32 phy_reg, u32 *phy_reg_data);
+int xgmac_mdio_single_rd(void *pdev, u32 dev_adr, u32 phy_id, u32 phy_reg);
 int mdio_set_clause(void *pdev, u32 clause, u32 phy_id);
 int mdio_get_clause(void *pdev,  u32 phy_id);
 int mdio_set_interrupt(void *pdev, u32 val);
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mtl_api.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mtl_api.c
index a95423bbbd5d..461a7e9a8a8f 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mtl_api.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mtl_api.c
@@ -55,9 +55,9 @@ int xgmac_set_mtl_rx_mode(void *pdev, u32 rx_mode)
 	u32 reg_val = XGMAC_RGRD(pdata, MTL_Q_RQOMR);
 
 	if (MAC_GET_VAL(reg_val, MTL_Q_RQOMR, RSF) != rx_mode) {
-		mac_printf("XGMAC %d: Setting MTL RX mode to: %s\n",
-			   pdata->mac_idx,
-			   rx_mode ? "Store and Forward" : "Threshold");
+		mac_dbg("XGMAC %d: Setting MTL RX mode to: %s\n",
+			pdata->mac_idx,
+			rx_mode ? "Store and Forward" : "Threshold");
 		MAC_SET_VAL(reg_val, MTL_Q_RQOMR, RSF, rx_mode);
 		XGMAC_RGWR(pdata, MTL_Q_RQOMR, reg_val);
 	}
@@ -71,8 +71,8 @@ int xgmac_set_mtl_rx_thresh(void *pdev, u32 rx_thresh)
 	u32 reg_val = XGMAC_RGRD(pdata, MTL_Q_RQOMR);
 
 	if (MAC_GET_VAL(reg_val, MTL_Q_RQOMR, RTC) != rx_thresh) {
-		mac_printf("XGMAC %d: Setting MTL RX threshold to: %d\n",
-			   pdata->mac_idx,  rx_thresh);
+		mac_dbg("XGMAC %d: Setting MTL RX threshold to: %d\n",
+			pdata->mac_idx,  rx_thresh);
 		MAC_SET_VAL(reg_val, MTL_Q_RQOMR, RTC, rx_thresh);
 		XGMAC_RGWR(pdata, MTL_Q_RQOMR, reg_val);
 	}
@@ -93,9 +93,9 @@ int xgmac_set_mtl_tx_mode(void *pdev, u32 tx_mode)
 	u32 reg_val = XGMAC_RGRD(pdata, MTL_Q_TQOMR);
 
 	if (MAC_GET_VAL(reg_val, MTL_Q_TQOMR, TSF) != tx_mode) {
-		mac_printf("XGMAC %d: Setting MTL TX mode to: %s\n",
-			   pdata->mac_idx,
-			   tx_mode ? "Store and Forward" : "Threshold");
+		mac_dbg("XGMAC %d: Setting MTL TX mode to: %s\n",
+			pdata->mac_idx,
+			tx_mode ? "Store and Forward" : "Threshold");
 		MAC_SET_VAL(reg_val, MTL_Q_TQOMR, TSF, tx_mode);
 		XGMAC_RGWR(pdata, MTL_Q_TQOMR, reg_val);
 	}
@@ -109,8 +109,8 @@ int xgmac_set_mtl_tx_thresh(void *pdev, u32 tx_thresh)
 	u32 reg_val = XGMAC_RGRD(pdata, MTL_Q_TQOMR);
 
 	if (MAC_GET_VAL(reg_val, MTL_Q_TQOMR, TTC) != tx_thresh) {
-		mac_printf("XGMAC %d: Setting MTL TX threshold to: %d\n",
-			   pdata->mac_idx,  tx_thresh);
+		mac_dbg("XGMAC %d: Setting MTL TX threshold to: %d\n",
+			pdata->mac_idx,  tx_thresh);
 		MAC_SET_VAL(reg_val, MTL_Q_TQOMR, TTC, tx_thresh);
 		XGMAC_RGWR(pdata, MTL_Q_TQOMR, reg_val);
 	}
@@ -126,22 +126,22 @@ int xgmac_clear_mtl_int(void *pdev, u32 event)
 
 	if ((event & XGMAC_TXQ_OVFW_EVNT) &&
 	    (MAC_GET_VAL(mtl_q_isr, MTL_Q_ISR, TXUNFIS))) {
-		mac_printf("XGMAC: %d Clearing MTL Q TXUNFIS"
-			   "Interrupt Status\n", pdata->mac_idx);
+		mac_dbg("XGMAC: %d Clearing MTL Q TXUNFIS"
+			"Interrupt Status\n", pdata->mac_idx);
 		MAC_SET_VAL(mtl_q_isr, MTL_Q_ISR, TXUNFIS, 1);
 	}
 
 	if ((event & XGMAC_RXQ_OVFW_EVNT) &&
 	    (MAC_GET_VAL(mtl_q_isr, MTL_Q_ISR, ABPSIS))) {
-		mac_printf("XGMAC: %d Clearing MTL Q ABPSIS"
-			   "Interrupt Status\n", pdata->mac_idx);
+		mac_dbg("XGMAC: %d Clearing MTL Q ABPSIS"
+			"Interrupt Status\n", pdata->mac_idx);
 		MAC_SET_VAL(mtl_q_isr, MTL_Q_ISR, ABPSIS, 1);
 	}
 
 	if ((event & XGMAC_AVG_BPS_EVNT) &&
 	    (MAC_GET_VAL(mtl_q_isr, MTL_Q_ISR, RXOVFIS))) {
-		mac_printf("XGMAC: %d Clearing MTL Q RXOVFIS"
-			   "Interrupt Status\n", pdata->mac_idx);
+		mac_dbg("XGMAC: %d Clearing MTL Q RXOVFIS"
+			"Interrupt Status\n", pdata->mac_idx);
 		MAC_SET_VAL(mtl_q_isr, MTL_Q_ISR, RXOVFIS, 1);
 	}
 
@@ -186,19 +186,31 @@ int xgmac_set_mtl_int(void *pdev, u32 val)
  *	Note: The flush operation is complete only when the Tx queue is empty.
  *	To complete this flush operation, the PHY Tx clock must be active.
  */
-
 int xgmac_flush_tx_queues(void *pdev)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 ftq = 0;
+	int idx = 0;
 
-	mac_printf("XGMAC %d: Flushing TX Q\n", pdata->mac_idx);
+	mac_dbg("XGMAC %d: Flushing TX Q\n", pdata->mac_idx);
 
 	XGMAC_RGWR_BITS(pdata, MTL_Q_TQOMR, FTQ, 1);
 
-	while (1) {
-		if (XGMAC_RGRD_BITS(pdata, MTL_Q_TQOMR, FTQ) == 0)
+	do {
+		ftq = XGMAC_RGRD_BITS(pdata, MTL_Q_TQOMR, FTQ);
+
+		if (ftq == 0)
 			break;
-	}
+
+		idx++;
+
+#ifdef __KERNEL__
+		/* To put a small delay and make sure previous operations
+		 * are complete
+		 */
+		usleep_range(100, 200);
+#endif
+	} while (idx <= MAX_RETRY);
 
 	return 0;
 }
@@ -221,15 +233,15 @@ int xgmac_set_flow_control_threshold(void *pdev, u32 rfa, u32 rfd)
 
 	/* Activate flow control when less than 4k left in fifo */
 	if (MAC_GET_VAL(reg_val, MTL_Q_RQFCR, RFA) != rfa) {
-		mac_printf("XGMAC %d: Set Thresh for activate Flow Ctrl %d\n",
-			   pdata->mac_idx, rfa);
+		mac_dbg("XGMAC %d: Set Thresh for activate Flow Ctrl %d\n",
+			pdata->mac_idx, rfa);
 		MAC_SET_VAL(reg_val, MTL_Q_RQFCR, RFA, rfa);
 	}
 
 	/* De-activate flow control when more than 6k left in fifo */
 	if (MAC_GET_VAL(reg_val, MTL_Q_RQFCR, RFD) != rfd) {
-		mac_printf("XGMAC %d: Set Thresh for deact Flow Ctrl as %d\n",
-			   pdata->mac_idx, rfd);
+		mac_dbg("XGMAC %d: Set Thresh for deact Flow Ctrl as %d\n",
+			pdata->mac_idx, rfd);
 		MAC_SET_VAL(reg_val, MTL_Q_RQFCR, RFD, rfd);
 	}
 
@@ -259,8 +271,8 @@ int xgmac_set_mmc(void *pdev)
 
 	/* Set counters to reset on read */
 	if (MAC_GET_VAL(reg_val, MMC_CR, ROR) != 0) {
-		mac_printf("XGMAC %d: reset on read %s\n",
-			   pdata->mac_idx, "DISABLED");
+		mac_dbg("XGMAC %d: reset on read %s\n",
+			pdata->mac_idx, "DISABLED");
 		MAC_SET_VAL(reg_val, MMC_CR, ROR, 0);
 		XGMAC_RGWR(pdata, MMC_CR, reg_val);
 	}
@@ -268,22 +280,20 @@ int xgmac_set_mmc(void *pdev)
 	return 0;
 }
 
-int xgmac_clear_rmon(void *pdev, u32 rmon_reset)
+int xgmac_clear_rmon(void *pdev)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 
 	/* Reset the counters */
-	if (rmon_reset) {
-		mac_printf("XGMAC %d: Resetting the counters\n",
-			   pdata->mac_idx);
-		XGMAC_RGWR_BITS(pdata, MMC_CR, CR, 1);
-		memset(&prv_data[pdata->mac_idx].mmc_stats, 0,
-		       sizeof(struct xgmac_mmc_stats));
-
-		while (1) {
-			if (XGMAC_RGRD_BITS(pdata, MMC_CR, CR) == 0)
-				break;
-		}
+	mac_printf("XGMAC %d: Resetting the counters\n",
+		   pdata->mac_idx);
+	XGMAC_RGWR_BITS(pdata, MMC_CR, CR, 1);
+	memset(&prv_data[pdata->mac_idx].mmc_stats, 0,
+	       sizeof(struct xgmac_mmc_stats));
+
+	while (1) {
+		if (XGMAC_RGRD_BITS(pdata, MMC_CR, CR) == 0)
+			break;
 	}
 
 	return 0;
@@ -566,14 +576,14 @@ int xgmac_forward_fup_fep_pkt(void *pdev, u32 fup, u32 fef)
 	u32 reg_val = XGMAC_RGRD(pdata, MTL_Q_RQOMR);
 
 	if (MAC_GET_VAL(reg_val, MTL_Q_RQOMR, FUP) != fup) {
-		mac_printf("XGMAC %d: Set Forward Undersized Good Packets\n",
-			   pdata->mac_idx);
+		mac_dbg("XGMAC %d: Set Forward Undersized Good Packets\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(reg_val, MTL_Q_RQOMR, FUP, fup);
 	}
 
 	if (MAC_GET_VAL(reg_val, MTL_Q_RQOMR, FEF) != fef) {
-		mac_printf("XGMAC %d: Set Forward Error Packets\n",
-			   pdata->mac_idx);
+		mac_dbg("XGMAC %d: Set Forward Error Packets\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(reg_val, MTL_Q_RQOMR, FEF, fef);
 	}
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c
index 834a72cccb85..cd26d23dfaf7 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c
@@ -601,6 +601,7 @@ static int xgmac_extts_enable(struct ptp_clock_info *ptp,
 	return -EOPNOTSUPP;
 }
 
+#ifdef CONFIG_PTP_1588_CLOCK
 static u64 xgmac_get_auxtimestamp(struct mac_prv_data *pdata)
 {
 	u64 nsec;
@@ -614,6 +615,7 @@ static u64 xgmac_get_auxtimestamp(struct mac_prv_data *pdata)
 
 	return nsec;
 }
+#endif
 
 static void xgmac_extts_isr_handler(struct mac_prv_data *pdata,
 				    u32 tstamp_sts)
@@ -694,7 +696,9 @@ int xgmac_ptp_init(void *pdev)
 int xgmac_get_ts_info(void *pdev,
 		      struct ethtool_ts_info *ts_info)
 {
+#ifdef CONFIG_PTP_1588_CLOCK
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+#endif
 
 	ts_info->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |
 				   SOF_TIMESTAMPING_RX_SOFTWARE |
@@ -759,7 +763,7 @@ static int xgmac_ptp_register(void *pdev)
 		return -1;
 	}
 
-	pr_info("Added PTP HW clock successfully\n");
+	mac_dbg("Added PTP HW clock successfully\n");
 
 	/* Disable all timestamping to start */
 	pdata->tstamp_config.tx_type = HWTSTAMP_TX_OFF;
diff --git a/include/net/switch_api/adap_ops.h b/include/net/switch_api/adap_ops.h
index 47947650e190..fbdd074e4c57 100644
--- a/include/net/switch_api/adap_ops.h
+++ b/include/net/switch_api/adap_ops.h
@@ -11,6 +11,31 @@
 #define _ADAP_OPS_H_
 
 #include "gsw_types.h"
+#include "lantiq_gsw.h"
+
+
+typedef enum {
+	GSWSS_REG_WR = 0,
+	GSWSS_REG_RD,
+	GSWSS_MAC_RESET,
+	GSWSS_MAC_EN,
+	GSWSS_MAC_IF,
+	GSWSS_MAC_OP,
+	GSWSS_MAC_MTU,
+	GSWSS_MAC_TXTSTAMP_FIFO,
+	GSWSS_MAC_PHY2MODE,
+	GSWSS_MAX_MAC,
+	GSWSS_ADAP_INT,
+	GSWSS_ADAP_CFG_1588,
+	GSWSS_ADAP_NCO,
+	GSWSS_ADAP_MACSEC_RST,
+	GSWSS_ADAP_SS_RST,
+	GSWSS_ADAP_MACSEC_TO_MAC,
+	GSWSS_ADAP_CORESE,
+	GSWSS_ADAP_CLK_MD,
+	GSWSS_ADAP_1588_CFG1,
+	GSWSS_MAX_ADAP,
+} GSWSS_CLI_CMDS;
 
 struct adap_ops {
 	/* This function does the whole GSWIP Subsystem Reset.
@@ -81,7 +106,7 @@ struct adap_ops {
 	 *  2 - Auto Mode (666/450) Mhz, 3 - Auto Mode (666/450) Mhz
 	 * return		OUT  -1:	Error in Getting Clock Mode
 	 */
-	u32(*ss_get_clkmode)(void *);
+	int(*ss_get_clkmode)(void *);
 	/* This function does the Switch Core Enable/Disable.
 	 * param[in/out]	IN:	ops Adaption ops Struct registered.
 	 * param[in/out]	IN:	Core Enable	Selects the Core Enable
@@ -96,7 +121,7 @@ struct adap_ops {
 	 *  			0:	Switch Core Disable,
 	 *  			1:	Switch Core Enable
 	 */
-	u32(*ss_get_core_en)(void *);
+	int(*ss_get_core_en)(void *);
 	/* This function Sets MACSEC to a Mac Module Attachment.
 	 *  param[in/out]IN:	ops Adaption ops Struct registered.
 	 * param[in/out]IN:	Mac Index	0 - MAC2 is attached to MACSEC,
@@ -140,7 +165,7 @@ struct adap_ops {
 	 * return		OUT  0:	NCO value Configured
 	 * return		OUT  -1:NCO value Get Error
 	 */
-	u32(*ss_get_nco)(void *, u32);
+	int(*ss_get_nco)(void *, u32);
 	/* This function Enables/Disbales Interrupt Enable Register.
 	 * param[in/out]	IN:	ops Adaption ops Struct registered.
 	 * param[in/out]	IN:	module	0 - XGMAC
@@ -169,19 +194,19 @@ struct adap_ops {
 	 * param[in/out]IN:	off	Adap Register offset.
 	 * return	OUT	reg_val:Register value will be returned
 	 */
-	u32(*ss_rg_rd)(void *, u32);
+	int(*ss_rg_rd)(void *, u32);
 	/* This sequence is Write Adaption register
 	 * param[in/out]IN:	ops	Adap ops Struct registered.
 	 * param[in/out]IN:	off	Adap Register offset.
 	 * param[in/out]IN:	val	Adap Register Value to be written.
 	 */
-	void(*ss_rg_wr)(void *, u32, u32);
+	int(*ss_rg_wr)(void *, u32, u32);
 	/* This sequence is used for GSWSS Cli implementation
 	 * param[in/out]IN:	argc - Number of args.
 	 * param[in/out]IN:	argv - Argument value.
 	 * return	OUT	-1: 	Exit GSWSS Error
 	 */
-	int(*ss_cli)(u32, u8 **);
+	int(*ss_cli)(GSW_MAC_Cli_t *);
 };
 
 #endif
diff --git a/include/net/switch_api/gsw_flow_ops.h b/include/net/switch_api/gsw_flow_ops.h
index 1b75fbca5dca..769a143819e2 100644
--- a/include/net/switch_api/gsw_flow_ops.h
+++ b/include/net/switch_api/gsw_flow_ops.h
@@ -564,11 +564,11 @@ struct debug_ops {
 	/* Command: GSW_DEBUG_CTP_STATISTICS ; Index: 0x0F */
 	GSW_return_t (*DEBUG_GetCtpStatistics)(void *, GSW_debug_t *);
 	/* Command: GSW_XGMAC_CFG ; Index: 0x10 */
-	GSW_return_t (*Xgmac)(void *, GSW_MAC_cfg_t *);
+	GSW_return_t (*Xgmac)(void *, GSW_MAC_Cli_t *);
 	/* Command: GSW_GSWSS_CFG ; Index: 0x11 */
-	GSW_return_t (*Gswss)(void *, GSW_MAC_cfg_t *);
+	GSW_return_t (*Gswss)(void *, GSW_MAC_Cli_t *);
 	/* Command: GSW_LMAC_CFG ; Index: 0x12 */
-	GSW_return_t (*Lmac)(void *, GSW_MAC_cfg_t *);
+	GSW_return_t (*Lmac)(void *, GSW_MAC_Cli_t *);
 	/* Command: GSW_MACSEC_CFG ; Index: 0x13 */
 	GSW_return_t (*Macsec)(void *, GSW_MAC_cfg_t *);
 	/* Command: GSW_DUMP_MEM ; Index: 0x14 */
diff --git a/include/net/switch_api/gsw_types.h b/include/net/switch_api/gsw_types.h
index 713562f7f3f0..3ef71aba4687 100644
--- a/include/net/switch_api/gsw_types.h
+++ b/include/net/switch_api/gsw_types.h
@@ -19,6 +19,10 @@
 /** \brief Instantiated tables entries name  string length.
     The user can supply a name and get in return an id from Switch API. */
 #define GSW_NAME_LEN	32
+
+/** \brief Maximum mac cli argument. */
+#define MAX_MAC_CLI_ARG 10
+
 /** \brief This is the unsigned 64-bit datatype. */
 typedef unsigned long long    u64;
 /** \brief This is the unsigned 32-bit datatype. */
diff --git a/include/net/switch_api/lantiq_gsw.h b/include/net/switch_api/lantiq_gsw.h
index 7c95549d36da..5ab1c02ad9b5 100644
--- a/include/net/switch_api/lantiq_gsw.h
+++ b/include/net/switch_api/lantiq_gsw.h
@@ -22,7 +22,7 @@
 /* Local Macros & Definitions    */
 /* ============================= */
 #include "gsw_types.h"
-
+#include "mac_ops.h"
 
 /** \defgroup GSW_GROUP GSWIP Functional APIs
     \brief This chapter describes the entire interface for accessing and configuring the different services of the Ethernet Switch module. The prefix GSW (Gigabit Switch) is used for all data structures and APIs pertaining to GSWIP.
@@ -1587,7 +1587,7 @@ typedef enum {
 	    Only supported for IGMPv3. */
 	GSW_IGMP_MEMBER_INCLUDE	= 0,
 	/** Exclude source IP address membership mode.
-	    Only supported for IGMPv3. */
+	    Only supported for IGMPv2. */
 	GSW_IGMP_MEMBER_EXCLUDE	= 1,
 	/** Group source IP address is 'don't care'. This means all source IP
 	    addresses (*) are included for the multicast group membership.
@@ -7418,7 +7418,7 @@ typedef struct {
    - GSW_statusOk: if successful
    - An error code in case an error occurs
 */
-#define GSW_XGMAC_CFG	_IOWR(GSW_DEBUG_MAGIC, 0x10, GSW_MAC_cfg_t)
+#define GSW_XGMAC_CFG	_IOWR(GSW_DEBUG_MAGIC, 0x10, GSW_MAC_Cli_t)
 
 /**
    \brief GSWSS Cfg Commands to Read and write operation
@@ -7429,7 +7429,7 @@ typedef struct {
    - GSW_statusOk: if successful
    - An error code in case an error occurs
 */
-#define GSW_GSWSS_CFG	_IOWR(GSW_DEBUG_MAGIC, 0x11, GSW_MAC_cfg_t)
+#define GSW_GSWSS_CFG	_IOWR(GSW_DEBUG_MAGIC, 0x11, GSW_MAC_Cli_t)
 
 /**
    \brief LMAC Cfg Commands to Read and write operation
@@ -7440,7 +7440,7 @@ typedef struct {
    - GSW_statusOk: if successful
    - An error code in case an error occurs
 */
-#define GSW_LMAC_CFG	_IOWR(GSW_DEBUG_MAGIC, 0x12, GSW_MAC_cfg_t)
+#define GSW_LMAC_CFG	_IOWR(GSW_DEBUG_MAGIC, 0x12, GSW_MAC_Cli_t)
 
 /**
    \brief MACSEC Cfg Commands to Read and write operation
diff --git a/include/net/switch_api/mac_ops.h b/include/net/switch_api/mac_ops.h
index 30450a35b658..06005128aaf5 100644
--- a/include/net/switch_api/mac_ops.h
+++ b/include/net/switch_api/mac_ops.h
@@ -12,10 +12,282 @@
 
 #include "gsw_irq.h"
 #include "gsw_types.h"
+#include "lantiq_gsw.h"
 #ifdef __KERNEL__
 #include <linux/netdevice.h>
 #endif
 
+enum {
+	MODE0 = 0,
+	MODE1,
+	MODE2,
+	MODE3
+};
+
+struct lmac_rmon_cnt {
+	u32 sing_coln_cnt;
+	u32 mple_coln_cnt;
+	u32 late_coln_cnt;
+	u32 excs_coln_cnt;
+	u32 rx_pause_cnt;
+	u32 tx_pause_cnt;
+};
+
+struct xgmac_mmc_stats {
+	/* Tx Stats */
+	u64 txoctetcount_gb;
+	u64 txframecount_gb;
+	u64 txbroadcastframes_g;
+	u64 txmulticastframes_g;
+	u64 txunicastframes_gb;
+	u64 txmulticastframes_gb;
+	u64 txbroadcastframes_gb;
+	u64 txunderflowerror;
+	u64 txoctetcount_g;
+	u64 txframecount_g;
+	u64 txpauseframes;
+	u64 txvlanframes_g;
+
+	/* Rx Stats */
+	u64 rxframecount_gb;
+	u64 rxoctetcount_gb;
+	u64 rxoctetcount_g;
+	u64 rxbroadcastframes_g;
+	u64 rxmulticastframes_g;
+	u64 rxcrcerror;
+	u64 rxundersize_g;
+	u64 rxoversize_g;
+	u64 rxunicastframes_g;
+	u64 rxlengtherror;
+	u64 rxoutofrangetype;
+	u64 rxpauseframes;
+	u64 rxfifooverflow;
+};
+
+/* This structure contains flags that indicate what hardware features
+ * or configurations are present in the device.
+ */
+struct xgmac_hw_features {
+	/* HW Version */
+	u32 version;
+
+	/* HW Feature Register0 */
+	u32 gmii;              /* 1000 Mbps support */
+	u32 vlhash;            /* VLAN Hash Filter */
+	u32 sma;               /* SMA(MDIO) Interface */
+	u32 rwk;               /* PMT remote wake-up packet */
+	u32 mgk;               /* PMT magic packet */
+	u32 mmc;               /* RMON module */
+	u32 aoe;               /* ARP Offload */
+	u32 ts;                /* IEEE 1588-2008 Advanced Timestamp */
+	u32 eee;               /* Energy Efficient Ethernet */
+	u32 tx_coe;            /* Tx Checksum Offload */
+	u32 rx_coe;            /* Rx Checksum Offload */
+	u32 addn_mac;          /* Additional MAC Addresses */
+	u32 ts_src;            /* Timestamp Source */
+	u32 sa_vlan_ins;       /* Source Address or VLAN Insertion */
+	u32 vxn;				/* VxLAN/NVGRE Support */
+	u32 ediffc;			/* Different Descriptor Cache */
+	u32 edma;				/* Enhanced DMA */
+
+	/* HW Feature Register1 */
+	u32 rx_fifo_size;       /* MTL Receive FIFO Size */
+	u32 tx_fifo_size;       /* MTL Transmit FIFO Size */
+	u32 osten;              /* One-Step Timestamping Enable */
+	u32 ptoen;              /* PTP Offload Enable */
+	u32 adv_ts_hi;          /* Advance Timestamping High Word */
+	u32 dma_width;          /* DMA width */
+	u32 dcb;                /* DCB Feature */
+	u32 sph;                /* Split Header Feature */
+	u32 tso;                /* TCP Segmentation Offload */
+	u32 dma_debug;          /* DMA Debug Registers */
+	u32 rss;                /* Receive Side Scaling */
+	u32 tc_cnt;             /* Number of Traffic Classes */
+	u32 hash_table_size;    /* Hash Table Size */
+	u32 l3l4_filter_num;    /* Number of L3-L4 Filters */
+
+	/* HW Feature Register2 */
+	u32 rx_q_cnt;           /* Number of MTL Receive Queues */
+	u32 tx_q_cnt;           /* Number of MTL Transmit Queues */
+	u32 rx_ch_cnt;          /* Number of DMA Receive Channels */
+	u32 tx_ch_cnt;          /* Number of DMA Transmit Channels */
+	u32 pps_out_num;        /* Number of PPS outputs */
+	u32 aux_snap_num;       /* Number of Aux snapshot inputs */
+};
+
+/* GSWIP Tx Fifo to send signal from GSWIP to Xgmac
+ * to do the action on the packet
+ * Actions include
+ * 1) Store Tx Timestamp
+ * 2) One Step TImestamp update for Sync packets
+ * 3) Packet ID update for the stored timestamp
+ * 4) Timestamp correction needed
+ * Entry will be cleared by the HW when packet is sent out
+ */
+struct mac_fifo_entry {
+	u32 is_used;
+	/* RecordID, denotes index to the 64 entry Fifo */
+	u32 rec_id;
+	/* Transmit Timestamp Store Enable */
+	u8 ttse;
+	/* One Step Timestamp Capture Enable */
+	u8 ostc;
+	/* One Step Timestamp Available/PacketID Available */
+	u8 ostpa;
+	/* Checksum Insertion or Update information */
+	u8 cic;
+	/* Lower 32 byte of time correction */
+	u32 ttsl;
+	/* Upper 32 byte of time correction */
+	u32 ttsh;
+	/* Timeout for this Fifo Entry */
+	u32 timeout;
+	u32 jiffies;
+#ifdef __KERNEL__
+	struct timer_list timer;
+#endif
+};
+
+
+/** \brief MAC Cli struct.
+     MAC Cli struct for passing args and argument values. */
+typedef struct {
+	/** Command Type */
+	u32 cmdType;
+	/** Number of args */
+	u32 argc;
+	/** Set/Get Api */
+	u32 get;
+	/** Set All using "*" */
+	u32 set_all;
+	/** Mac Index going to set/get */
+	u32 mac_idx;
+	/** Mac Adddress string */
+	u8 mac_addr[6];
+	/** Argument values */
+	u32 val[MAX_MAC_CLI_ARG];
+	/** Reading Xgmac RMON Counters */
+	struct xgmac_mmc_stats pstats;
+	/** Reading Xgmac Capability */
+	struct xgmac_hw_features hw_feat;
+	/** 64 bit system time */
+	u64 time;
+
+	struct mac_fifo_entry f_entry;
+
+	struct lmac_rmon_cnt lpstats;
+} GSW_MAC_Cli_t;
+
+/* RX THRESHOLD operations */
+#define MTL_RX_THRESHOLD_32		0x01
+#define MTL_RX_THRESHOLD_64		0x00
+#define MTL_RX_THRESHOLD_96		0x02
+#define MTL_RX_THRESHOLD_128	0x03
+#define MTL_TX_THRESHOLD_32		0x01
+#define MTL_TX_THRESHOLD_64		0x00
+#define MTL_TX_THRESHOLD_96		0x02
+#define MTL_TX_THRESHOLD_128	0x03
+#define MTL_TX_THRESHOLD_192	0x04
+#define MTL_TX_THRESHOLD_256	0x05
+#define MTL_TX_THRESHOLD_384	0x06
+#define MTL_TX_THRESHOLD_512	0x07
+
+#define MTL_ETSALG_WRR			0x00
+#define MTL_ETSALG_WFQ			0x01
+#define MTL_ETSALG_DWRR			0x02
+#define MTL_RAA_SP				0x00
+#define MTL_RAA_WSP				0x01
+
+typedef enum {
+	MAC_CLI_INIT = 0,
+	MAC_CLI_RESET,
+	MAC_CLI_MTL_TX,
+	MAC_CLI_MTL_RX,
+	MAC_CLI_FCTHR,
+	MAC_CLI_SET_TS_ADDEND,
+	MAC_CLI_GET_SYSTEM_TIME,
+	MAC_CLI_GET_TX_TSTAMP,
+	MAC_CLI_SET_TSTAMP_EN,
+	MAC_CLI_SET_TSTAMP_DIS,
+	MAC_CLI_TXTSTAMP_MODE,
+	MAC_CLI_HW_TSTAMP, /* 10 */
+	MAC_CLI_FLUSH_TX_Q,
+	MAC_CLI_ERR_PKT_FWD,
+	MAC_CLI_SET_INT,
+	MAC_CLI_EN,
+	MAC_CLI_SET_MAC_ADDR,
+	MAC_CLI_SET_RX_MODE,
+	MAC_CLI_SET_MTU,
+	MAC_CLI_PFCTRL,
+	MAC_CLI_SET_PF_FILTER,
+	MAC_CLI_PAUSE_TX, /* 20 */
+	MAC_CLI_SPEED,
+	MAC_CLI_SET_DPX_MODE,
+	MAC_CLI_CSUM_OFFLOAD,
+	MAC_CLI_LB,
+	MAC_CLI_EEE,
+	MAC_CLI_CRC_STRIP,
+	MAC_CLI_CRC_STRIP_ACS,
+	MAC_CLI_IPG,
+	MAC_CLI_MAGIC_PMT,
+	MAC_CLI_MAGIC_RWK, /* 30 */
+	MAC_CLI_PMT_GUCAST,
+	MAC_CLI_EXTCFG,
+	MAC_CLI_SET_RXTXCFG,
+	MAC_CLI_GET_MISS_PKT_CNT,
+	MAC_CLI_GET_UFLOW_PKT_CNT,
+	MAC_CLI_GET_TSTAMP_STS,
+	MAC_CLI_GET_TXTSTAMP_CNT,
+	MAC_CLI_GET_TXTSTAMP_PKTID,
+	MAC_CLI_SET_LINKSTS,
+	MAC_CLI_SET_LPITX, /* 40 */
+	MAC_CLI_SET_MDIO_CL,
+	MAC_CLI_SET_MDIO_RD,
+	MAC_CLI_SET_MDIO_RD_CNT,
+	MAC_CLI_SET_MDIO_WR,
+	MAC_CLI_SET_MDIO_INT,
+	MAC_CLI_SET_FCSGEN,
+	MAC_CLI_SET_PCH,
+	MAC_CLI_SET_GINT,
+	MAC_CLI_SET_PFC,
+	MAC_CLI_SET_RXCRC, /* 50 */
+	MAC_CLI_GET_FIFO,
+	MAC_CLI_ADD_FIFO,
+	MAC_CLI_DEL_FIFO,
+	MAC_CLI_SET_EXT_TS_SRC,
+	MAC_CLI_GET_RMON,
+	MAC_CLI_GET_PCH_CRC_CNT,
+	MAC_CLI_CLEAR_RMON,
+	MAC_CLI_GET_CNTR_CFG,
+	MAC_CLI_GET_PRIV_DATA,
+	MAC_CLI_GET_HW_FEAT, /* 60 */
+	MAC_CLI_GET_ALL,
+	MAC_CLI_GET_MDIO_CL,
+	MAC_CLI_REG_RD,
+	MAC_CLI_REG_WR,
+} MAC_CLI_CMDS;
+
+typedef enum {
+	LMAC_REG_WR,
+	LMAC_REG_RD,
+	LMAC_RMON,
+	LMAC_CLR_RMON,
+	LMAC_IF_MODE,
+	LMAC_DPX,
+	LMAC_XFCS,
+	LMAC_FLOWCON,
+	LMAC_IPG,
+	LMAC_PREAMBLE,
+	LMAC_DEFERMODE,
+	LMAC_JPS,
+	LMAC_LB,
+	LMAC_TXER,
+	LMAC_LPIMONIT,
+	LMAC_PSTAT,
+	LMAC_PISR,
+	LMAC_PAUSE_SA_MODE,
+} LMAC_CLI_CMDS;
+
 typedef enum  {
 	/* Adaption layer does not insert FCS */
 	TX_FCS_NO_INSERT = 0,
@@ -78,19 +350,19 @@ struct mac_ops {
 	 * return	OUT  0:Flow Ctrl operation Set Successfully
 	 * return	OUT  !0:Flow Ctrl operation Set Error
 	 */
-	int(*set_flow_ctl)(void *, u32);
+	int (*set_flow_ctl)(void *, u32);
 	/* This function Sets the Mac Adress in xgmac.
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	*mac_addr MAC source address to Set
 	 * return	OUT	-1:	Source Address Set Error
 	 */
-	int(*set_macaddr)(void *, u8 *);
+	int (*set_macaddr)(void *, u8 *);
 	/* This function Enables/Disables Rx CRC check.
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	disable	Disable=1, Enable=0
 	 * return	OUT	-1:	Set Failed
 	 */
-	int(*set_rx_crccheck)(void *, u8);
+	int (*set_rx_crccheck)(void *, u8);
 	/* This function configure treatment of special tag
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	mode	0 - packet does not have special tag
@@ -103,7 +375,7 @@ struct mac_ops {
 #define SPTAG_MODE_REPLACE	1
 #define SPTAG_MODE_KEEP		2
 #define SPTAG_MODE_REMOVE	3
-	int(*set_sptag)(void *, u8);
+	int (*set_sptag)(void *, u8);
 	/* This function Gets the Flow Ctrl operation in Both XGMAC and LMAC.
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * return	OUT:	mode	0 - Auto Mode based on GPHY/XPCS link.
@@ -113,152 +385,153 @@ struct mac_ops {
 	 *				4 - Flow Ctrl disabled both in RX & TX
 	 * return	OUT  -1:	Flow Ctrl operation Get Error
 	 */
-	int(*get_flow_ctl)(void *);
+	int (*get_flow_ctl)(void *);
 	/* This function Resets the MAC module.
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	reset	1 - Reset ON, 0 - Reset Off
 	 * return	OUT  0:	Reset of MAC module Done Successfully
 	 * return	OUT  -1:	Reset of MAC module Error
 	 */
-	int(*mac_reset)(void *);
+	int (*mac_reset)(void *, u32);
 	/* This function Configures MAC Loopback.
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	val	1 - Loopback Enable, 0 - Loopback Dis
 	 * return	OUT  -1:	Loopback Set Error
 	 */
-	int(*mac_config_loopback)(void *, u32);
+	int (*mac_config_loopback)(void *, u32);
 	/* This function Configures MAC IPG.
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	IPG val	Value is from 0 - 7,
 	 *			where 0 denotes the default 96 bits
-	 * 			000: 96 bit
-	 *			001: 128 bit
-	 *			010: 160 bit
-	 *			011: 192 bit
-	 *			100: 224 bit
+	 * 			000:	96 bit
+	 *			001:	128 bit
+	 *			010:	160 bit
+	 *			011:	192 bit
+	 *			100:	224 bit
 	 *			101  111: Reserved
 	 * return	OUT  -1:	IPG Set Error
 	 */
-	int(*mac_config_ipg)(void *, u32);
+	int (*mac_config_ipg)(void *, u32);
 	/* This function Configures the Speed
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	speed(Mbps)
-	 *			10  	- 10Mbps
-	 *			100 	- 100Mbps
-	 *			1000  	- 1Gbps
-	 *			25000  	- 2.5Gbps
-	 *			100000  - 10Gbps
+	 *			10		- 10Mbps
+	 *			100		- 100Mbps
+	 *			1000	- 1Gbps
+	 *			25000	- 2.5Gbps
+	 *			100000	- 10Gbps
 	 * return	OUT  -1:	Speed Set Error
 	 */
 
-	int(*set_speed)(void *, u32);
+	int (*set_speed)(void *, u32);
 	/* This function Gets the Speed
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * return	OUT:	speed(Mbps)
-	 *			10  	- 10Mbps
-	 *			100 	- 100Mbps
-	 *			1000  	- 1Gbps
-	 *			25000  	- 2.5Gbps
-	 *			100000  - 10Gbps
+	 *			10		- 10Mbps
+	 *			100		- 100Mbps
+	 *			1000	- 1Gbps
+	 *			25000	- 2.5Gbps
+	 *			100000	- 10Gbps
 	 * return	OUT  -1:	Speed Get Error
 	 */
-	int(*get_speed)(void *);
+	int (*get_speed)(void *);
 	/* This function Configures the Duplex
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	duplex
-	 *			0  	- Full Duplex
-	 *			1 	- Half Duplex
-	 *			2 	- Auto
+	 *			0	- Full Duplex
+	 *			1	- Half Duplex
+	 *			2	- Auto
 	 * return	OUT  -1:	Duplex Set Error
 	 */
-	int(*set_duplex)(void *, u32);
+	int (*set_duplex)(void *, u32);
 	/* This function Gets the Duplex value
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * return	OUT:	duplex
-	 *			0  	- Full Duplex
-	 *			1 	- Half Duplex
-	 *			2 	- Auto
+	 *			0	- Full Duplex
+	 *			1	- Half Duplex
+	 *			2	- Auto
 	 * return	OUT  -1:	Duplex Get Error
 	 */
-	int(*get_duplex)(void *);
+	int (*get_duplex)(void *);
 	/* This function Configures the LPI
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	LPI EN
-	 * 			0  	- Disable
-	 *			1 	- Enable
+	 * 			0	-	Disable
+	 *			1	-	Enable
 	 * param[in/out]IN:	LPI Wait time for 100M in usec
 	 * param[in/out]IN:	LPI Wait time for 1G in usec
 	 * return	OUT	-1:	LPI Set Error
 	 */
-	int(*set_lpi)(void *, u32, u32, u32);
+	int (*set_lpi)(void *, u32, u32, u32);
 	/* This function Gets the LPI Enable/Disable
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * return	OUT:	LPI EN
-	 *			0  	- Disable
-	 *			1 	- Enable
+	 *			0	- Disable
+	 *			1	- Enable
 	 * return	OUT  -1:	LPI Get Error
 	 */
-	int(*get_lpi)(void *);
+	int (*get_lpi)(void *);
 	/* This function Configures the MII Interface
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	MII Mode
-	 *			0  	- MII
-	 *			2 	- GMII
-	 *			4 	- XGMII
-	 *			5 	- LMAC GMII
+	 *			0	- MII
+	 *			2	- GMII
+	 *			4	- XGMII
+	 *			5	- LMAC GMII
 	 * return	OUT  -1:	MII Interface Set Error
 	 */
-	int(*set_mii_if)(void *, u32);
+	int (*set_mii_if)(void *, u32);
 	/* This function Gets the MII Interface
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * return	OUT:	MII Mode
-	 *			0  	- MII
-	 *			2 	- GMII
-	 *			4 	- XGMII
-	 *			5 	- LMAC GMII
+	 *			0	- MII
+	 *			2	- GMII
+	 *			4	- XGMII
+	 *			5	- LMAC GMII
 	 * return	OUT  -1:	MII Interface Get Error
 	 */
-	int(*get_mii_if)(void *);
+	int (*get_mii_if)(void *);
 	/* This function Sets the Link Status
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	Link
-	 *			0  	- LINK Force UP
-	 *			1  	- LINK Force DOWN
-	 *			Any - AUTO Mode
+	 *	0	- LINK Force UP
+	 *	1	- LINK Force DOWN
+	 *	Any	- AUTO Mode
 	 * return	OUT  -1:	Link Status Set Error
 	 */
-	int(*set_link_sts)(void *, u8);
+	int (*set_link_sts)(void *, u32);
 	/* This function Gets the Link Status
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * return	OUT:	Link
-	 *			0  	- LINK Force UP
-	 *			1  	- LINK Force DOWN
-	 *			Any - AUTO Mode
+	 *	0	- LINK Force UP
+	 *	1	- LINK Force DOWN
+	 *	Any	- AUTO Mode
 	 * return	OUT  -1:	Link Status Get Error
 	 */
-	int(*get_link_sts)(void *);
+	int (*get_link_sts)(void *);
 	/* This function Sets the MTU Configuration
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	MTU
 	 *			Max MTU that can be set is 10000 for Falcon-Mx
-	 * return	OUT	-1: 	MTU set exceed the Max limit
+	 * return	OUT	-1:	MTU set exceed the Max limit
 	 */
-	int(*set_mtu)(void *, u32);
+	int (*set_mtu)(void *, u32);
 	/* This function Gets the MTU Configuration
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * return	OUT:	MTU
-	 * 			MTU configured
+	 *			MTU configured
 	 * return	OUT  -1:	MTU Get Error
 	 */
-	int(*get_mtu)(void *);
+	int (*get_mtu)(void *);
 	/* This function Sets the Pause frame Source Address
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	*mac_addr MAC source address to Set
 	 * param[in/out]IN:	mode
 	 *			1 - PORT specific MAC source address
 	 *			0 - COMMON MAC source address
-	 * return	OUT	-1: 	Pause frame Source Address Set Error
+	 * return	OUT	-1: Pause frame Source Address Set Error
 	 */
-	int(*set_pfsa)(void *, u8 *, u32);
+	int (*set_pfsa)(void *, u8 *, u32);
 	/* This function Gets the Pause frame Source Address
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * return	OUT:	*mac_addr	MAC source address which is set
@@ -267,7 +540,7 @@ struct mac_ops {
 	 *			0 - COMMON MAC source address
 	 * return	OUT	-1:	Pause frame Source Address Get Error
 	 */
-	int(*get_pfsa)(void *, u8 *, u32 *);
+	int (*get_pfsa)(void *, u8 *, u32 *);
 	/* This function Sets the FCS generation Configuration
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	val	FCS generation Configuration
@@ -276,7 +549,7 @@ struct mac_ops {
 	 *			2 - CRC and PAD are not insert and not replaced.
 	 * return	OUT	-1:	FCS generation Set Error
 	 */
-	int(*set_fcsgen)(void *, u32);
+	int (*set_fcsgen)(void *, u32);
 	/* This function Gets the FCS generation Configuration
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * return	OUT:	val	FCS generation Configuration
@@ -285,27 +558,27 @@ struct mac_ops {
 	 *			2 - CRC and PAD are not insert and not replaced.
 	 * return	OUT	-1:	FCS generation Get Error
 	 */
-	int(*get_fcsgen)(void *);
+	int (*get_fcsgen)(void *);
 	/* This function Clears MAC Interrupt Status
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	event	Difffernt events to clear
-	 * return	OUT	: 	Cleared return status
+	 * return	OUT	: Cleared return status
 	 */
-	int(*clr_int_sts)(void *, u32);
+	int (*clr_int_sts)(void *, u32);
 	/* This function Gets MAC Interrupt Status
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
-	 * return	OUT	: 	Interrupts Pending
+	 * return	OUT	:	Interrupts Pending
 	 */
-	int(*get_int_sts)(void *);
+	int (*get_int_sts)(void *);
 	/* This function Initializes System time Configuration
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	sec	Initial seconds value to be configured
 	 *				in register
 	 * param[in/out]IN:	nsec	Initial nano-seconds value to be
 	 *				configured in register
-	 * return	OUT	-1: 	System time Configuration Set Error
+	 * return	OUT	-1: System time Configuration Set Error
 	 */
-	int(*init_systime)(void *, u32, u32);
+	int (*init_systime)(void *, u32, u32);
 	/* This function Configures addend value
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	addend
@@ -319,9 +592,9 @@ struct mac_ops {
 	 * system time is updated whenever the accumulator overflows.
 	 * This field indicates the 32-bit time value to be added to the
 	 * Accumulator register to achieve time synchronization.
-	 * return	OUT	-1: 	Addend Configuration Set Error
+	 * return	OUT	-1: Addend Configuration Set Error
 	 */
-	int(*config_addend)(void *, u32);
+	int (*config_addend)(void *, u32);
 	/* This function Adjust System Time for PTP
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	sec	New seconds value to be configured
@@ -336,24 +609,24 @@ struct mac_ops {
 	 *	programmed with,
 	 *	(10^9 - <new_nsec_value>) if MAC_TX_CFG.TSCTRLSSR is set or
 	 *	(2^31 - <new_nsec_value> if MAC_TX_CFG.TSCTRLSSR is reset)
-	 * return	OUT	-1: 		Adjust System Time for PTP Error
+	 * return   OUT -1:     Adjust System Time for PTP Error
 	 */
-	int(*adjust_systime)(void *, u32, u32, u32, u32);
+	int (*adjust_systime)(void *, u32, u32, u32, u32);
 	/* This sequence is used get 64-bit system time in nano sec
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
-	 * return	OUT	u64: 	64-bit system time in nano sec
+	 * return	OUT	u64: 64-bit system time in nano sec
 	 */
-	u64(*get_systime)(void *);
+	u64 (*get_systime)(void *);
 	/* This sequence is used get Transmitted 64-bit system time in nano sec
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
-	 * return	OUT	u64: 	Tx 64-bit system time in nano sec
+	 * return	OUT	u64: Tx 64-bit system time in nano sec
 	 */
-	u64(*get_tx_tstamp)(void *);
+	u64 (*get_tx_tstamp)(void *);
 	/* This sequence is used get Tx Transmitted capture count
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
-	 * return	OUT	u32: 	Tx Timestamp capture count
+	 * return	OUT	u32: Tx Timestamp capture count
 	 */
-	int(*get_txtstamp_cap_cnt)(void *);
+	int (*get_txtstamp_cap_cnt)(void *);
 	/* This sequence is used Configure HW TimeStamping TX/RX filter Cfg
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	tx_type: 1/0 - ON/OFF
@@ -361,7 +634,7 @@ struct mac_ops {
 	 *			Receive side timestamp Capture scenarios
 	 * return	OUT	-1:	Configure HW TimeStamping Set Error
 	 */
-	int(*config_hw_time_stamping)(void *, u32, u32);
+	int (*config_hw_time_stamping)(void *, u32, u32);
 	/* This sequence is used ConfigureSub Second Increment
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	ptp_clk: PTP Clock Value in Hz
@@ -375,85 +648,85 @@ struct mac_ops {
 	 *	resolution of ~0.465 ns. In this case, you
 	 *	should program a value of 43 (0x2B)
 	 *	which is derived by 20 ns/0.465.
-	 * return	OUT	-1: 	Configure Sub Second Inccrement Error
+	 * return	OUT	-1: Configure Sub Second Inccrement Error
 	 */
-	int(*config_subsec_inc)(void *, u32);
+	int (*config_subsec_inc)(void *, u32);
 #ifdef __KERNEL__
 	/* This sequence is used set Hardware timestamp
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 */
-	int(*set_hwts)(void *, struct ifreq *);
+	int (*set_hwts)(void *, struct ifreq *);
 	/* This sequence is used get Hardware timestamp
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 */
-	int(*get_hwts)(void *, struct ifreq *);
+	int (*get_hwts)(void *, struct ifreq *);
 	/* This sequence is used for Rx Hardware timestamp operations
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
-	 * return	OUT	-1: 	Initialize MAC Error
+	 * return	OUT	-1: Initialize MAC Error
 	 */
-	int(*do_rx_hwts)(void *, struct sk_buff *);
+	int (*do_rx_hwts)(void *, struct sk_buff *);
 	/* This sequence is used for Tx Hardware timestamp operations
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
-	 * return	OUT	-1: 	Initialize MAC Error
+	 * return	OUT	-1: Initialize MAC Error
 	 */
-	int(*do_tx_hwts)(void *, struct sk_buff *);
+	int (*do_tx_hwts)(void *, struct sk_buff *);
 	/* This sequence is get Timestamp info
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
-	 * return	OUT	-1: 	Initialize MAC Error
+	 * return	OUT	-1: Initialize MAC Error
 	 */
-	int(*mac_get_ts_info)(void *, struct ethtool_ts_info *);
+	int (*mac_get_ts_info)(void *, struct ethtool_ts_info *);
 	/* This sequence is to do soft restart of Xgmac
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * return	OUT	-1:	Initialize MAC Error
 	 */
-	void(*soft_restart)(void *);
+	void (*soft_restart)(void *);
 #endif
 	/* This sequence is used Initialize MAC
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
-	 * return	OUT	-1: 	Initialize MAC Error
+	 * return	OUT	-1: Initialize MAC Error
 	 */
-	int(*init)(void *);
+	int (*init)(void *);
 	/* This sequence is used Exit MAC
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
-	 * return	OUT	-1: 		Exit MAC Error
+	 * return	OUT	-1:	Exit MAC Error
 	 */
-	int(*exit)(void *);
+	int (*exit)(void *);
 	/* This sequence is used for Xgmac Cli implementation
 	 * param[in/out]IN:	argc - Number of args.
 	 * param[in/out]IN:	argv - Argument value.
-	 * return	OUT	-1: 		Exit MAC Error
+	 * return	OUT	-1: Exit MAC Error
 	 */
-	int(*xgmac_cli)(u32, u8 **);
+	int (*xgmac_cli)(GSW_MAC_Cli_t *);
 	/* This sequence is used for Lmac Cli implementation
 	 * param[in/out]IN:	argc - Number of args.
 	 * param[in/out]IN:	argv - Argument value.
-	 * return	OUT	-1: 		Exit MAC Error
+	 * return	OUT	-1: Exit MAC Error
 	 */
-	int(*lmac_cli)(u32, u8 **);
+	int (*lmac_cli)(GSW_MAC_Cli_t *);
 	/* This sequence is used for Reading XGMAC register
 	 * param[in/out]IN:	ops -	MAC ops Struct registered for MAC 0/1/2.
-	 * param[in/out]IN:	u16 -   Register Offset.
+	 * param[in/out]IN:	u32 -   Register Offset.
 	 * return	OUT	u32 -	Register Value
 	 */
-	u32(*xgmac_reg_rd)(void *, u16);
+	int (*xgmac_reg_rd)(void *, u32);
 	/* This sequence is used for Writing XGMAC register
 	 * param[in/out]IN:	ops -	MAC ops Struct registered for MAC 0/1/2.
-	 * param[in/out]IN:	u16 -   Register Offset.
+	 * param[in/out]IN:	u32 -   Register Offset.
 	 * param[in/out]IN:	u32 -   Register Value.
 	 */
-	void(*xgmac_reg_wr)(void *, u16, u32);
+	int (*xgmac_reg_wr)(void *, u32, u32);
 	/* This sequence is used for Reading LMAC register
 	 * param[in/out]IN:	ops -	MAC ops Struct registered for MAC 0/1/2.
-	 * param[in/out]IN:	u16 -   Register Offset.
+	 * param[in/out]IN:	u32 -   Register Offset.
 	 * return	OUT	u32 -	Register Value
 	 */
-	u32(*lmac_reg_rd)(void *, u32);
+	int (*lmac_reg_rd)(void *, u32);
 	/* This sequence is used for Writing LMAC register
 	 * param[in/out]IN:	ops -	MAC ops Struct registered for MAC 0/1/2.
-	 * param[in/out]IN:	u16 -   Register Offset.
+	 * param[in/out]IN:	u32 -   Register Offset.
 	 * param[in/out]IN:	u32 -   Register Value.
 	 */
-	void(*lmac_reg_wr)(void *, u32, u32);
+	int (*lmac_reg_wr)(void *, u32, u32);
 	/* This sequence is used for Registering IRQ Callback for a event
 	 * param[in/out]IN:	ops -	MAC ops Struct registered for MAC 0/1/2.
 	 * param[in/out]IN:	GSW_Irq_Op_t -   IRQ event info.
