From acdd21739868bb7e6d89fb2f5ad0214210b7d579 Mon Sep 17 00:00:00 2001
From: Rekha Eswaran <rekha.eswaran@intel.com>
Date: Thu, 20 Jun 2019 17:31:00 +0800
Subject: [PATCH] DRVLIB_SW-2420 - if applied, This patch fixes CQEM->PPv4 port
 map setting for threshold verification

---
 .../net/datapath/dpm/gswip31/datapath_ppv4_api.c   | 62 ++++++++++++++++++++++
 1 file changed, 62 insertions(+)

diff --git a/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c b/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
index de2655ffefca..f97106e295e4 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
@@ -2217,6 +2217,63 @@ int dp_node_link_get_31(struct dp_node_link *info, int flag)
 	return DP_FAILURE;
 }
 
+static int dp_map_qid_to_cqmdeq(struct dp_node_link *info, int flag)
+{
+	struct dp_qos_link q_link = {0};
+	struct dp_node_child node = {0};
+	struct dp_node_link node_info = {0};
+	int idx;
+
+	if (info->node_type == DP_NODE_QUEUE) {
+		q_link.q_id = info->node_id.q_id;
+		dp_link_get_31(&q_link, 0);
+		DP_DEBUG(DP_DBG_FLAG_QOS, "Parent PORT[%d]\n",
+			 q_link.cqm_deq_port);
+		q_link.cqm_deq_port =
+			get_cqm_deq_port_by_node(info->inst,
+						 q_link.cqm_deq_port,
+						 flag);
+		cqm_qid2ep_map_set(q_link.q_id, q_link.cqm_deq_port);
+		DP_DEBUG(DP_DBG_FLAG_QOS, "%s qid:%d, dq_port:%d\n",
+			 "cqm_qid2ep_map_set", q_link.q_id,
+			 q_link.cqm_deq_port);
+	} else if (info->node_type == DP_NODE_SCH) {
+		node.type = info->node_type;
+		node.id.sch_id = info->node_id.sch_id;
+		if (dp_children_get_31(&node, flag)) {
+			DP_DEBUG(DP_DBG_FLAG_QOS,
+				 "dp_children_get fail (qid->cqmdq map)\n");
+		}
+		DP_DEBUG(DP_DBG_FLAG_QOS, "Node[%d]has %d Children!!\n",
+			 node.id.q_id, node.num);
+		for (idx = 0; idx < node.num; idx++) {
+			if (node.child[idx].type == DP_NODE_QUEUE) {
+				q_link.q_id = node.child[idx].id.q_id;
+				dp_link_get_31(&q_link, 0);
+				DP_DEBUG(DP_DBG_FLAG_QOS, "Parent PORT[%d]\n",
+					 q_link.cqm_deq_port);
+				q_link.cqm_deq_port =
+				get_cqm_deq_port_by_node(info->inst,
+							 q_link.cqm_deq_port,
+							 flag);
+				cqm_qid2ep_map_set(q_link.q_id,
+						   q_link.cqm_deq_port);
+				DP_DEBUG(DP_DBG_FLAG_QOS,
+					 "%s qid:%d, dq_port:%d %s:%d->%s:%d\n",
+					 "cqm_qid2ep_map_set", q_link.q_id,
+					 q_link.cqm_deq_port, "child", idx, "Q",
+					 node.child[idx].id.q_id);
+				break;
+			} else {
+				node_info.node_type = node.child[idx].type;
+				node_info.node_id = node.child[idx].id;
+				dp_map_qid_to_cqmdeq(&node_info, flag);
+			}
+		}
+	}
+	return DP_SUCCESS;
+}
+
 /* dp_link_set API
  * upon success links node to parent and returns DP_SUCCESS
  * else return DP_FAILURE
@@ -2308,6 +2365,7 @@ static int dp_link_set(struct dp_node_link *info, int parent_node, int flag)
 	node_stat_update(info->inst, parent_node, DP_NODE_INC | C_FLAG);
 	DP_DEBUG(DP_DBG_FLAG_QOS,
 		 "node_stat_update after dp_link_set end\n");
+	dp_map_qid_to_cqmdeq(info, flag);
 ERROR_EXIT:
 
 	kfree(queue_cfg);
@@ -2734,6 +2792,10 @@ int dp_node_unlink_31(struct dp_node_link *info, int flag)
 				info->node_id.q_id,
 				priv->qos_queue_stat[info->node_id.q_id].flag);
 		}
+		cqm_qid2ep_map_set(info->node_id.q_id, priv->ppv4_drop_p);
+		DP_DEBUG(DP_DBG_FLAG_QOS, "%s qid:%d, dq_port:%d\n",
+			 "cqm_qid2ep_map_set to drop port", info->node_id.q_id,
+			 priv->ppv4_drop_p);
 		if (qos_queue_conf_get(priv->qdev, node_id, &queue_cfg) == 0)
 			queue_flush_31(info->inst, node_id, 0);
 	} else if (info->node_type == DP_NODE_SCH) {
