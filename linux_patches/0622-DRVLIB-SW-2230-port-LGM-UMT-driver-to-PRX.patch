From d16a916623691761aeee3c0a2fb218da3dd006da Mon Sep 17 00:00:00 2001
From: Wu Zhixian <zhixianx.wu@intel.com>
Date: Thu, 2 May 2019 16:37:22 +0800
Subject: [PATCH] DRVLIB_SW-2230: port LGM UMT driver to PRX

change compatible string

remove unused file

include dma macro

add missing head file

DMA Controller macros change to a common place for CQM/DP and UMT to access
---
 drivers/net/datapath/dpm/datapath.h              |   27 -
 drivers/net/ethernet/lantiq/Makefile             |    2 +-
 drivers/net/ethernet/lantiq/umt/intel_umt_cqem.c |  776 -----------
 drivers/net/ethernet/lantiq/umt/umt.c            | 1572 ++++++++++++++++++++++
 include/net/datapath_api.h                       |   23 +
 include/net/intel_datapath_umt.h                 |  134 ++
 6 files changed, 1730 insertions(+), 804 deletions(-)

diff --git a/drivers/net/datapath/dpm/datapath.h b/drivers/net/datapath/dpm/datapath.h
index b4e8b5b605f3..1816c5e906a6 100644
--- a/drivers/net/datapath/dpm/datapath.h
+++ b/drivers/net/datapath/dpm/datapath.h
@@ -18,33 +18,6 @@
 #include <linux/version.h>
 #include <net/ppa/qos_mgr_tc_hook.h>
 
-/* Note: In LGM kernel (4.19) branch,
- * DMA driver already adapted to linux kernel
- * DMA framework and some DMA macro (like
- * _DMA_CONTROLLER/_DMA_PORT/_DMA_CHANNEL)
- * was removed. In order to keep the interface between DP and CQM/UMT driver
- * same, DP has defined DMA macro accordingly
- */
-#if !defined(CONFIG_LGM_CQM)
-#define _DMA_CHANBITS   16
-#define _DMA_PORTBITS   8
-#define _DMA_CTRLBITS   8
-
-#define _DMA_CHANMASK   ((1 << _DMA_CHANBITS) - 1)
-#define _DMA_PORTMASK   ((1 << _DMA_PORTBITS) - 1)
-#define _DMA_CTRLMASK   ((1 << _DMA_CTRLBITS) - 1)
-
-#define _DMA_CHANSHIFT  0
-#define _DMA_PORTSHIFT  (_DMA_CHANSHIFT + _DMA_CHANBITS)
-#define _DMA_CTRLSHIFT  (_DMA_PORTSHIFT + _DMA_PORTBITS)
-
-#define _DMA_CONTROLLER(nr)     (((nr) >> _DMA_CTRLSHIFT) & _DMA_CTRLMASK)
-#define _DMA_PORT(nr)           (((nr) >> _DMA_PORTSHIFT) & _DMA_PORTMASK)
-#define _DMA_CHANNEL(nr)        (((nr) >> _DMA_CHANSHIFT) & _DMA_CHANMASK)
-#else
-#include "../cqm/cqm_common.h"
-#endif
-
 #if IS_ENABLED(CONFIG_PRX300_CQM) || \
 	IS_ENABLED(CONFIG_GRX500_CBM)
 	#include <net/lantiq_cbm_api.h>
diff --git a/drivers/net/ethernet/lantiq/Makefile b/drivers/net/ethernet/lantiq/Makefile
index 5b71302e20d2..e0f7dbed2b43 100644
--- a/drivers/net/ethernet/lantiq/Makefile
+++ b/drivers/net/ethernet/lantiq/Makefile
@@ -10,5 +10,5 @@ obj-$(CONFIG_LTQ_ETH_XRX500) += ltq_eth_drv_xrx500.o
 obj-$(CONFIG_INTEL_GINT_ETH) += intel_gint_eth_drv.o
 obj-$(CONFIG_XRX500_PHY_FW) += xrx500_phy_fw.o
 obj-$(CONFIG_PPA) += ppa/
-obj-$(CONFIG_INTEL_UMT_CQEM_MODE) += umt/intel_umt_cqem.o
+obj-$(CONFIG_INTEL_UMT_CQEM_MODE) += umt/umt.o
 obj-$(CONFIG_LTQ_TOE_DRIVER) += ltq_toe_drv.o
diff --git a/drivers/net/ethernet/lantiq/umt/intel_umt_cqem.c b/drivers/net/ethernet/lantiq/umt/intel_umt_cqem.c
deleted file mode 100644
index e9b221f8f2ee..000000000000
--- a/drivers/net/ethernet/lantiq/umt/intel_umt_cqem.c
+++ /dev/null
@@ -1,776 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/* Copyright (C) 2015 Zhu YiXin <yixin.zhu@lantiq.com>
- * Copyright (C) 2016~2018 Intel Corporation.
- */
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/clk.h>
-#include <linux/errno.h>
-#include <linux/debugfs.h>
-#include <linux/interrupt.h>
-#include <linux/of.h>
-#include <linux/seq_file.h>
-#include <linux/dma/lantiq_dmax.h>
-#include <linux/intel_umt_cqem.h>
-#include "intel_umt_cqem_reg.h"
-
-static const u32 g_dma_ctrl = DMA1TX;
-static void __iomem *g_umt_addr_base;
-
-/* 0x17AC == 20us default translation according to register document*/
-#define UMT_US_TO_CNT_DEFAULT_VALUE (0x17AC / 20)
-
-#define umt_r32(x)	readl(g_umt_addr_base + (x))
-#define umt_w32(x, y)	writel((x), g_umt_addr_base + (y))
-#define umt_w32_mask(x, y, z) \
-		do { \
-			void __iomem *z_ = g_umt_addr_base + (z); \
-			writel((readl(z_) & ~(x)) | (y), z_); \
-		} while (0)
-
-#define UMT_MSG(x)		(UMT_MSG0 + (x) * 4)
-
-#define UMT_X_SW_MODE		(UMT_SW_MODE_CH1 - UMT_MSG1_0)
-#define UMT_X_PERIOD		(UMT_PERIOD_CH1 - UMT_MSG1_0)
-#define UMT_X_DEST		(UMT_DEST_1 - UMT_MSG1_0)
-#define UMT_X_MSG(x)		((x) * 4)
-
-#define UMT_X_ADDR(x, off)	(UMT_MSG1_0 + \
-				((x) - 1) * (UMT_MSG2_0 - UMT_MSG1_0) + (off))
-
-#define UMT_PORTS_NUM		3
-#define MIN_UMT_PRD		20
-#define UMT_DEF_DMACID		13
-
-struct umt_port {
-	u32 umt_pid;
-	u32 ep_id;
-	enum umt_mode umt_mode;
-	enum umt_msg_mode msg_mode;
-	enum umt_status status;
-	u32 umt_period;
-	u32 umt_dst;
-	u32 cbm_pid; /* CBM WLAN ID (0 - 3) */
-	u32 dma_cid; /* DMA Chan ID */
-	enum umt_status suspend;
-	spinlock_t umt_port_lock; /* protect the umt per port resource */
-};
-
-struct umt_info {
-	struct umt_port ports[UMT_PORTS_NUM];
-	u32 dma_ctrlid;
-	enum umt_status status;
-	struct dentry *debugfs;
-	spinlock_t umt_lock; /* protect the umt global resource */
-	struct clk *clk;
-};
-
-static struct umt_info sg_umt;
-
-static inline void umt_set_mode(u32 umt_id, enum umt_mode umt_mode)
-{
-	u32 val, off;
-
-	if (!umt_id) {
-		umt_w32_mask(0x2, ((u32)umt_mode) << 1, UMT_GCTRL);
-	} else {
-		off = 16 + (umt_id - 1) * 3;
-		val = umt_r32(UMT_GCTRL) & ~(BIT(off));
-		umt_w32(val | (((u32)umt_mode) << off), UMT_GCTRL);
-	}
-}
-
-static inline void umt_set_msgmode(u32 umt_id, enum umt_msg_mode msg_mode)
-{
-	if (!umt_id)
-		umt_w32((u32)msg_mode, UMT_SW_MODE);
-	else
-		umt_w32((u32)msg_mode, UMT_X_ADDR(umt_id, UMT_X_SW_MODE));
-}
-
-/* input in term of microseconds */
-static inline u32 umt_us_to_cnt(u32 usec)
-{
-	unsigned long cpuclk;
-	struct clk *clk;
-	unsigned long long usec_tmp;
-
-	clk = sg_umt.clk;
-	if (!clk)
-		return usec * UMT_US_TO_CNT_DEFAULT_VALUE;
-
-	cpuclk = clk_get_rate(clk);
-
-	pr_debug("umt_us_to_cnt the cpuclk is %lu.\n", cpuclk);
-
-	usec_tmp = (unsigned long long)usec *
-			((unsigned long)cpuclk / 1000000ULL);
-	if (usec_tmp > 0xFFFFFFFFULL) {
-		pr_info("UMT period exceeds max value! set to 0xFFFFFFFF.\n");
-		return 0xFFFFFFFF;
-	}
-	return (u32)usec_tmp;
-}
-
-static inline void umt_set_period(u32 umt_id, u32 umt_period)
-{
-	umt_period = umt_us_to_cnt(umt_period);
-
-	if (!umt_id)
-		umt_w32(umt_period, UMT_PERD);
-	else
-		umt_w32(umt_period, UMT_X_ADDR(umt_id, UMT_X_PERIOD));
-}
-
-static inline void umt_set_dst(u32 umt_id, u32 umt_dst)
-{
-	if (!umt_id)
-		umt_w32(umt_dst, UMT_DEST);
-	else
-		umt_w32(umt_dst, UMT_X_ADDR(umt_id, UMT_X_DEST));
-}
-
-static inline void umt_set_mux(u32 umt_id, u32 cbm_pid, u32 dma_cid)
-{
-	u32 mux_sel;
-
-	cbm_pid = cbm_pid & 0xF;
-	dma_cid = dma_cid & 0xF;
-	mux_sel = umt_r32(UMT_TRG_MUX) &
-			(~((0xF000F) << (umt_id * 4)));
-	mux_sel |= (dma_cid << (umt_id * 4)) |
-			(cbm_pid << (16 + (umt_id * 4)));
-	umt_w32(mux_sel, UMT_TRG_MUX);
-}
-
-static inline void umt_set_endian(int dw_swp, int byte_swp)
-{
-	u32 val;
-
-	val = umt_r32(UMT_GCTRL);
-	if (byte_swp)
-		val |= UMT_GCTRL_OCP_UMT_ENDI_B_MASK;
-	else
-		val &= ~(UMT_GCTRL_OCP_UMT_ENDI_B_MASK);
-
-	if (dw_swp)
-		val |= UMT_GCTRL_OCP_UMT_ENDI_W_MASK;
-	else
-		val &= ~(UMT_GCTRL_OCP_UMT_ENDI_W_MASK);
-
-	umt_w32(val, UMT_GCTRL);
-}
-
-static inline void umt_en_endian_mode(void)
-{
-	if (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))
-		umt_set_endian(1, 0);
-	else
-		umt_set_endian(1, 1);
-}
-
-static inline void umt_enable(u32 umt_id, enum umt_status status)
-{
-	u32 val, off;
-
-	if (!umt_id) {
-		umt_w32_mask(0x4, ((u32)status) << 2, UMT_GCTRL);
-	} else {
-		off = 17 + (umt_id - 1) * 3;
-		val = (umt_r32(UMT_GCTRL) & ~BIT(off))
-				| (((u32)status) << off);
-		umt_w32(val, UMT_GCTRL);
-	}
-}
-
-static inline void umt_suspend(u32 umt_id, enum umt_status status)
-{
-	u32 val;
-
-	if (status)
-		val = umt_r32(UMT_COUNTER_CTRL) | BIT(umt_id);
-	else
-		val = umt_r32(UMT_COUNTER_CTRL) & (~(BIT(umt_id)));
-
-	umt_w32(val, UMT_COUNTER_CTRL);
-}
-
-/*This function will disable umt */
-static inline void umt_reset_umt(u32 umt_id)
-{
-	u32 mode;
-
-	umt_enable(umt_id, UMT_DISABLE);
-
-	/* Bit 1 for UMT0
-	 * Bit 16 for UMT1
-	 * Bit 19 for UMT2
-	 */
-	if (!umt_id)
-		mode = (umt_r32(UMT_GCTRL) & BIT(1));
-	else
-		mode = (umt_r32(UMT_GCTRL) & BIT(16 + 3 * (umt_id - 1)));
-
-	umt_set_mode(umt_id, !mode);
-	umt_set_mode(umt_id, mode);
-}
-
-/**
- * intput:
- * @umt_id: UMT port id, (0 - 3)
- * @ep_id:  Aligned with datapath lib ep_id
- * @period: measured in microseconds.
- * ret:  Fail < 0 / Success: 0
- */
-int intel_umt_cqem_set_period(u32 umt_id, u32 ep_id, u32 period)
-{
-	struct umt_port *port;
-
-	if (period < MIN_UMT_PRD) {
-		pr_err("Period (%d) is below min requirement!\n", period);
-		return -EINVAL;
-	}
-
-	if (umt_id >= UMT_PORTS_NUM) {
-		pr_err("umit id (%d) is out of range !\n", umt_id);
-		return -EINVAL;
-	}
-
-	if (sg_umt.status != UMT_ENABLE) {
-		pr_err("UMT is not initialized!\n");
-		return -EINVAL;
-	}
-
-	port = &sg_umt.ports[umt_id];
-
-	spin_lock_bh(&port->umt_port_lock);
-	if (port->ep_id != ep_id) {
-		spin_unlock_bh(&port->umt_port_lock);
-		pr_err("umt_id: %d, ep_id: %d, period: %d\n",
-		       umt_id, ep_id, period);
-		return -EINVAL;
-	}
-
-	if (port->umt_period != period) {
-		port->umt_period = period;
-		umt_set_period(umt_id, port->umt_period);
-	}
-	spin_unlock_bh(&port->umt_port_lock);
-
-	return 0;
-}
-EXPORT_SYMBOL(intel_umt_cqem_set_period);
-
-/**
- * API to configure the UMT port.
- * input:
- * @umt_id: (0 - 3)
- * @ep_id: aligned with datapath lib EP
- * @umt_mode:  0-self-counting mode, 1-user mode.
- * @msg_mode:  0-No MSG, 1-MSG0 Only, 2-MSG1 Only, 3-MSG0 & MSG1.
- * @dst:  Destination PHY address.
- * @period(ms): only applicable when set to self-counting mode.
- *              self-counting interval time. if 0, use the original setting.
- * @enable: 1-Enable/0-Disable
- * @ret:  Fail < 0 , SUCCESS:0
- */
-int intel_umt_cqem_set_mode(u32 umt_id, u32 ep_id,
-			    struct umt_set_mode *p_umt_mode)
-{
-	struct umt_port *port;
-	u32 msg_mode;
-	u32 umt_mode;
-	u32 phy_dst;
-	u32 period;
-	u32 enable;
-	u32 umt_ep_dst;
-
-	if (!p_umt_mode) {
-		pr_err("UMT mode is NULL!\n");
-		return -EINVAL;
-	}
-
-	if (sg_umt.status != UMT_ENABLE) {
-		pr_err("UMT is not initialized!!\n");
-		return -ENODEV;
-	}
-
-	umt_mode = p_umt_mode->umt_mode;
-	msg_mode = p_umt_mode->msg_mode;
-	phy_dst = p_umt_mode->phy_dst;
-	period = p_umt_mode->period;
-	enable = p_umt_mode->enable;
-	umt_ep_dst = p_umt_mode->umt_ep_dst;
-
-	if ((umt_mode >= (u32)UMT_MODE_MAX) || (msg_mode >= (u32)UMT_MSG_MAX) ||
-	    (enable >= (u32)UMT_STATUS_MAX) || (umt_ep_dst == 0) ||
-	    (phy_dst == 0) || (period == 0) || (umt_id >= UMT_PORTS_NUM)) {
-		pr_err("umt_id: %d, umt_mode: %d, msg_mode: %d.\n",
-		       umt_id, umt_mode, msg_mode);
-		pr_err("enable: %d, phy_dst: %d, umt_ep_dst: %d.\n",
-		       enable, phy_dst, umt_ep_dst);
-		return -EINVAL;
-	}
-
-	port = &sg_umt.ports[umt_id];
-
-	spin_lock_bh(&port->umt_port_lock);
-	if (port->ep_id != ep_id) {
-		spin_unlock_bh(&port->umt_port_lock);
-		pr_err("input ep_id: %d, port ep_id: %d\n", ep_id, port->ep_id);
-		return -EINVAL;
-	}
-
-	umt_reset_umt(umt_id);
-
-	port->umt_mode = (enum umt_mode)umt_mode;
-	port->msg_mode = (enum umt_msg_mode)msg_mode;
-	port->umt_dst = phy_dst;
-	port->umt_period = period;
-	port->status = (enum umt_status)enable;
-
-	umt_set_mode(umt_id, port->umt_mode);
-	umt_set_msgmode(umt_id, port->msg_mode);
-	umt_set_dst(umt_id, port->umt_dst);
-	umt_set_period(umt_id, port->umt_period);
-	umt_enable(umt_id, port->status);
-	/* setup the CBM/DMA mapping */
-	spin_unlock_bh(&port->umt_port_lock);
-
-	return 0;
-}
-EXPORT_SYMBOL(intel_umt_cqem_set_mode);
-
-/**
- * API to enable/disable umt port
- * input:
- * @umt_id (0 - 3)
- * @ep_id: aligned with datapath lib EP
- * @enable: Enable: 1 / Disable: 0
- * ret:  Fail < 0, Success: 0
- */
-int intel_umt_cqem_enable(u32 umt_id, u32 ep_id, u32 enable)
-{
-	struct umt_port *port;
-
-	if (umt_id >= UMT_PORTS_NUM)
-		return -EINVAL;
-	if (enable >= (u32)UMT_STATUS_MAX || sg_umt.status != UMT_ENABLE)
-		return -ENODEV;
-
-	port = &sg_umt.ports[umt_id];
-
-	spin_lock_bh(&port->umt_port_lock);
-	if (port->ep_id != ep_id || port->umt_dst == 0 || port->ep_id == 0) {
-		spin_unlock_bh(&port->umt_port_lock);
-		pr_err("input ep_id: %d, umt port ep_id: %d, umt_dst: 0x%x\n",
-		       ep_id, port->ep_id, port->umt_dst);
-		return -EINVAL;
-	}
-
-	if (port->status != enable) {
-		port->status = (enum umt_status)enable;
-		umt_enable(umt_id, port->status);
-	}
-	spin_unlock_bh(&port->umt_port_lock);
-
-	return 0;
-}
-EXPORT_SYMBOL(intel_umt_cqem_enable);
-
-/**
- * API to suspend/resume umt US/DS counter
- * input:
- * @umt_id (0 - 3)
- * @ep_id: aligned with datapath lib EP
- * @enable: suspend: 1 / resume: 0
- * ret:  Fail < 0, Success: 0
- */
-int intel_umt_cqem_suspend(u32 umt_id, u32 ep_id, u32 enable)
-{
-	struct umt_port *port;
-
-	if (umt_id >= UMT_PORTS_NUM)
-		return -EINVAL;
-	if (enable >= (u32)UMT_STATUS_MAX || sg_umt.status != UMT_ENABLE)
-		return -ENODEV;
-
-	port = &sg_umt.ports[umt_id];
-
-	spin_lock_bh(&port->umt_port_lock);
-	if (port->ep_id != ep_id || port->umt_dst == 0 || port->ep_id == 0) {
-		spin_unlock_bh(&port->umt_port_lock);
-		pr_err("input ep_id: %d, umt port ep_id: %d, umt_dst: 0x%x\n",
-		       ep_id, port->ep_id, port->umt_dst);
-		return -EINVAL;
-	}
-
-	if (port->suspend != enable) {
-		port->suspend = (enum umt_status)enable;
-		umt_enable(umt_id, port->status);
-		umt_suspend(umt_id, port->suspend);
-	}
-	spin_unlock_bh(&port->umt_port_lock);
-
-	return 0;
-}
-EXPORT_SYMBOL(intel_umt_cqem_suspend);
-
-/**
- * API to request and allocate UMT port
- * input:
- * @ep_id: aligned with datapath lib EP.
- * @cbm_pid: CBM Port ID(0-3), 0 - CBM port 4, 1 - CBM port 5,
- * 2 - CBM port 6
- * output:
- * @dma_ctrlid: DMA controller ID. aligned with DMA driver DMA controller ID
- * @dma_cid: DMA channel ID.
- * @umt_id: (0 - 3)
- * ret: Fail: < 0,  Success: 0
- */
-int intel_umt_cqem_request(u32 ep_id, u32 cbm_pid,
-			   u32 *dma_ctrlid, u32 *dma_cid, u32 *umt_id)
-{
-	int i, pid;
-	struct umt_port *port;
-
-	if (!dma_ctrlid || !dma_cid || !umt_id) {
-		pr_err("Output pointer is NULL!\n");
-		return -EINVAL;
-	}
-
-	if (sg_umt.status != UMT_ENABLE) {
-		pr_err("UMT not initialized!\n");
-		return -EINVAL;
-	}
-	if (!ep_id) {
-		pr_err("%s: ep_id cannot be zero!\n", __func__);
-		return -EINVAL;
-	}
-
-	if (cbm_pid >= UMT_PORTS_NUM) {
-		pr_err("%s: cbm pid must be in ranage(0 - %d)\n",
-		       __func__, UMT_PORTS_NUM);
-		return -EINVAL;
-	}
-
-	pid = -1;
-	spin_lock_bh(&sg_umt.umt_lock);
-	for (i = 0; i < UMT_PORTS_NUM; i++) {
-		port = &sg_umt.ports[i];
-		spin_lock_bh(&port->umt_port_lock);
-		if (port->ep_id == ep_id && port->cbm_pid == cbm_pid) {
-			pid = i;
-			spin_unlock_bh(&port->umt_port_lock);
-			break;
-		} else if (port->ep_id == 0 && pid == -1) {
-			pid = i;
-		}
-		spin_unlock_bh(&port->umt_port_lock);
-	}
-	spin_unlock_bh(&sg_umt.umt_lock);
-
-	if (pid < 0) {
-		pr_err("No free UMT port!\n");
-		return -ENODEV;
-	}
-
-	port = &sg_umt.ports[pid];
-	spin_lock_bh(&port->umt_port_lock);
-	port->ep_id = ep_id;
-	port->cbm_pid = cbm_pid;
-	umt_set_mux(port->umt_pid, port->cbm_pid, port->dma_cid);
-	*dma_ctrlid = sg_umt.dma_ctrlid;
-	*dma_cid = port->dma_cid;
-	*umt_id = port->umt_pid;
-	spin_unlock_bh(&port->umt_port_lock);
-
-	return 0;
-}
-EXPORT_SYMBOL(intel_umt_cqem_request);
-
-/**
- * API to release umt port
- * input:
- * @umt_id (0 - 3)
- * @ep_id: aligned with datapath lib EP
- *
- * ret:  Fail < 0, Success: 0
- */
-int intel_umt_cqem_release(u32 umt_id, u32 ep_id)
-{
-	struct umt_port *port;
-
-	if (umt_id >= UMT_PORTS_NUM)
-		return -ENODEV;
-
-	if (sg_umt.status != UMT_ENABLE) {
-		pr_err("UMT is not initialized!\n");
-		return -ENODEV;
-	}
-
-	port = &sg_umt.ports[umt_id];
-
-	spin_lock_bh(&port->umt_port_lock);
-	if (port->ep_id != ep_id) {
-		spin_unlock_bh(&port->umt_port_lock);
-		pr_err("input ep_id: %d, UMT port ep_id: %d\n",
-		       ep_id, port->ep_id);
-		return -ENODEV;
-	}
-
-	port->ep_id = 0;
-	port->cbm_pid = 0;
-	port->umt_dst = 0;
-	port->umt_period = 0;
-	port->status = UMT_DISABLE;
-	umt_enable(port->umt_pid, UMT_DISABLE);
-
-	spin_unlock_bh(&port->umt_port_lock);
-
-	return 0;
-}
-EXPORT_SYMBOL(intel_umt_cqem_release);
-
-static void umt_port_init(struct device_node *node, int pid)
-{
-	char res_cid[32];
-	int cid;
-	struct umt_port *port;
-
-	port = &sg_umt.ports[pid];
-	snprintf(res_cid, sizeof(res_cid), "lantiq,umt%d-dmacid", pid);
-	if (of_property_read_u32(node, res_cid, &cid) < 0) {
-		cid = UMT_DEF_DMACID + pid;
-		pr_info("umt dma channel id not found in device tree!\n");
-		pr_info("umt dma channel id set to default %d!\n", cid);
-	}
-
-	port->umt_pid = pid;
-	port->dma_cid = cid;
-	port->ep_id = 0;
-	port->status = UMT_DISABLE;
-	spin_lock_init(&port->umt_port_lock);
-}
-
-#ifdef CONFIG_DEBUG_FS
-static void *umt_port_seq_start(struct seq_file *s, loff_t *pos)
-{
-	if (*pos >= UMT_PORTS_NUM)
-		return NULL;
-	return &sg_umt.ports[*pos];
-}
-
-static void *umt_port_seq_next(struct seq_file *s, void *v, loff_t *pos)
-{
-	if (++*pos >= UMT_PORTS_NUM)
-		return NULL;
-	return &sg_umt.ports[*pos];
-}
-
-static void umt_port_seq_stop(struct seq_file *s, void *v)
-{
-}
-
-static int umt_port_seq_show(struct seq_file *s, void *v)
-{
-	struct umt_port *port = v;
-	int pid = port->umt_pid;
-	u32 val;
-
-	seq_printf(s, "\nUMT port %d configuration\n", pid);
-	seq_puts(s, "-----------------------------------------\n");
-	seq_printf(s, "UMT port ep_id: %d\n", port->ep_id);
-	seq_printf(s, "UMT Mode: \t%s\n",
-		   port->umt_mode == UMT_SELFCNT_MODE ?
-		   "UMT SelfCounting Mode" : "UMT User Mode");
-	switch (port->msg_mode) {
-	case UMT_NO_MSG:
-		seq_puts(s, "UMT MSG Mode: \tUMT NO MSG\n");
-		break;
-	case UMT_MSG0_ONLY:
-		seq_puts(s, "UMT MSG Mode: \tUMT MSG0 Only\n");
-		break;
-	case UMT_MSG1_ONLY:
-		seq_puts(s, "UMT MSG Mode: \tUMT MSG1 Only\n");
-		break;
-	case UMT_MSG0_MSG1:
-		seq_puts(s, "UMT MSG Mode: \tUMT_MSG0_And_MSG1\n");
-		break;
-	default:
-		seq_printf(s, "UMT MSG Mode Error! Msg_mode: %d\n",
-			   port->msg_mode);
-	}
-	seq_printf(s, "UMT DST: \t0x%x\n", port->umt_dst);
-	if (port->umt_mode == UMT_SELFCNT_MODE)
-		seq_printf(s, "UMT Period: \t%d(us)\n", port->umt_period);
-	seq_printf(s, "UMT Status: \t%s\n",
-		   port->status == UMT_ENABLE ? "Enable" :
-		   port->status == UMT_DISABLE ? "Disable" : "Init Fail");
-	seq_printf(s, "UMT DMA CID: \t%d\n", port->dma_cid);
-	seq_printf(s, "UMT CBM PID: \t%d\n", port->cbm_pid);
-
-	seq_printf(s, "++++Register dump of umt port: %d++++\n", pid);
-	if (pid == 0) {
-		seq_printf(s, "UMT Status: \t%s\n",
-			   (umt_r32(UMT_GCTRL) & BIT(2)) != 0 ?
-			   "Enable" : "Disable");
-		seq_printf(s, "UMT Mode: \t%s\n",
-			   (umt_r32(UMT_GCTRL) & BIT(1)) != 0 ?
-			   "UMT User MSG mode" : "UMT SelfCounting mode");
-		seq_printf(s, "UMT MSG Mode: \t%d\n",
-			   umt_r32(UMT_SW_MODE));
-		seq_printf(s, "UMT Dst: \t0x%x\n",
-			   umt_r32(UMT_DEST));
-		seq_printf(s, "UMT Period: \t0x%x\n",
-			   umt_r32(UMT_PERD));
-		seq_printf(s, "UMT MSG0: \t0x%x\n",
-			   umt_r32(UMT_MSG(0)));
-		seq_printf(s, "UMT MSG1: \t0x%x\n",
-			   umt_r32(UMT_MSG(1)));
-	} else {
-		seq_printf(s, "UMT Status: \t%s\n",
-			   (umt_r32(UMT_GCTRL) &
-			   BIT(17 + 3 * (pid - 1))) != 0 ?
-			   "Enable" : "Disable");
-		seq_printf(s, "UMT Mode: \t%s\n",
-			   (umt_r32(UMT_GCTRL) &
-			   BIT(16 + 3 * (pid - 1))) != 0 ?
-			   "UMT User MSG mode" : "UMT SelfCounting mode");
-		seq_printf(s, "UMT MSG Mode: \t%d\n",
-			   umt_r32(UMT_X_ADDR(pid, UMT_X_SW_MODE)));
-		seq_printf(s, "UMT Dst: \t0x%x\n",
-			   umt_r32(UMT_X_ADDR(pid, UMT_X_DEST)));
-		seq_printf(s, "UMT Period: \t0x%x\n",
-			   umt_r32(UMT_X_ADDR(pid, UMT_X_PERIOD)));
-		seq_printf(s, "UMT MSG0: \t0x%x\n",
-			   umt_r32(UMT_X_ADDR(pid, UMT_X_MSG(0))));
-		seq_printf(s, "UMT MSG1: \t0x%x\n",
-			   umt_r32(UMT_X_ADDR(pid, UMT_X_MSG(1))));
-	}
-
-	val = umt_r32(UMT_TRG_MUX);
-	seq_printf(s, "DMA CID: \t%d\n",
-		   (val & ((0xF) << (pid * 4))) >> (pid * 4));
-	seq_printf(s, "CBM PID: \t%d\n",
-		   (val & ((0xF) << (16 + pid * 4))) >> (16 + pid * 4));
-
-	return 0;
-}
-
-static const struct seq_operations umt_port_seq_ops = {
-	.start = umt_port_seq_start,
-	.next = umt_port_seq_next,
-	.stop = umt_port_seq_stop,
-	.show = umt_port_seq_show,
-};
-
-static int umt_cfg_read_debugfs_open(struct inode *inode, struct file *file)
-{
-	return seq_open(file, &umt_port_seq_ops);
-}
-
-static const struct file_operations umt_debugfs_fops = {
-	.open		= umt_cfg_read_debugfs_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= seq_release,
-};
-
-static int umt_debugfs_init(void)
-{
-	struct dentry *entry;
-
-	sg_umt.debugfs = debugfs_create_dir("umt", NULL);
-	if (!sg_umt.debugfs)
-		return -ENOMEM;
-
-	entry = debugfs_create_file("umt_info", 0644, sg_umt.debugfs,
-				    NULL, &umt_debugfs_fops);
-	if (!entry)
-		goto err1;
-
-	return 0;
-err1:
-	debugfs_remove_recursive(sg_umt.debugfs);
-	sg_umt.debugfs = NULL;
-	pr_err("UMT debugfs create fail!\n");
-	return -ENOMEM;
-}
-#endif
-
-static int intel_umt_drv_probe(struct platform_device *pdev)
-{
-	struct device_node *node = pdev->dev.of_node;
-	int i;
-	struct resource *res;
-
-	sg_umt.dma_ctrlid = g_dma_ctrl;
-	sg_umt.clk = of_clk_get_by_name(node, "freq");
-
-	if (IS_ERR_VALUE(sg_umt.clk)) {
-		pr_err("the clock for umt is missing, error no %d.\n",
-		       (int)sg_umt.clk);
-		sg_umt.clk = NULL;
-	}
-
-	spin_lock_init(&sg_umt.umt_lock);
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		pr_err("failed to get the umt resource!\n");
-		return -ENODEV;
-	}
-
-	g_umt_addr_base = devm_ioremap_resource(&pdev->dev, res);
-	if (!g_umt_addr_base) {
-		pr_err("failed to request amd map the umt io range!\n");
-		return -ENODEV;
-	}
-	pr_debug("the base addr of UMT is 0x%p\n", g_umt_addr_base);
-
-	umt_en_endian_mode();
-
-	for (i = 0; i < UMT_PORTS_NUM; i++)
-		umt_port_init(node, i);
-#ifdef CONFIG_DEBUG_FS
-	umt_debugfs_init();
-#endif
-	sg_umt.status = UMT_ENABLE;
-
-	pr_info("UMT initialize success on processor: %d!\n",
-		smp_processor_id());
-
-	return 0;
-}
-
-static int intel_umt_drv_remove(struct platform_device *pdev)
-{
-#ifdef CONFIG_DEBUG_FS
-	debugfs_remove_recursive(sg_umt.debugfs);
-	sg_umt.debugfs = NULL;
-#endif
-	sg_umt.status = UMT_DISABLE;
-	pr_info("Intel UMT CQEM driver remove!\n");
-	return 0;
-}
-
-static const struct of_device_id intel_umt_drv_match[] = {
-	{ .compatible = "intel,umt-cqem" },
-	{},
-};
-MODULE_DEVICE_TABLE(of, intel_umt__drv_match);
-
-static struct platform_driver intel_umt_driver = {
-	.probe = intel_umt_drv_probe,
-	.remove = intel_umt_drv_remove,
-	.driver = {
-		.name = "intel,umt-cqem",
-		.of_match_table = intel_umt_drv_match,
-		.owner = THIS_MODULE,
-	},
-};
-
-module_platform_driver(intel_umt_driver);
-
-MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/ethernet/lantiq/umt/umt.c b/drivers/net/ethernet/lantiq/umt/umt.c
new file mode 100644
index 000000000000..8a0a36014735
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/umt/umt.c
@@ -0,0 +1,1572 @@
+// SPDX-License-Identifier: GPL-2.0
+/*  Copyright (C) 2018 Intel Corporation.
+ *  Wu ZhiXian <zhixian.wu@intel.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <net/intel_datapath_umt.h>
+
+#define UMT_PERD 0xDC
+
+#define UMT_TRG_MUX_0 0xE0
+#define UMT_TRG_MUX_0_UMT_RX0_SEL_POS 0
+#define UMT_TRG_MUX_0_UMT_RX0_SEL_MASK 0xFu
+#define UMT_TRG_MUX_0_UMT_RX1_SEL_POS 4
+#define UMT_TRG_MUX_0_UMT_RX1_SEL_MASK 0xF0u
+#define UMT_TRG_MUX_0_UMT_RX2_SEL_POS 8
+#define UMT_TRG_MUX_0_UMT_RX2_SEL_MASK 0xF00u
+#define UMT_TRG_MUX_0_UMT_RX3_SEL_POS 12
+#define UMT_TRG_MUX_0_UMT_RX3_SEL_MASK 0xF000u
+#define UMT_TRG_MUX_0_UMT_TX0_SEL_POS 16
+#define UMT_TRG_MUX_0_UMT_TX0_SEL_MASK 0xF0000u
+#define UMT_TRG_MUX_0_UMT_TX1_SEL_POS 20
+#define UMT_TRG_MUX_0_UMT_TX1_SEL_MASK 0xF00000u
+#define UMT_TRG_MUX_0_UMT_TX2_SEL_POS 24
+#define UMT_TRG_MUX_0_UMT_TX2_SEL_MASK 0xF000000u
+#define UMT_TRG_MUX_0_UMT_TX3_SEL_POS 28
+#define UMT_TRG_MUX_0_UMT_TX3_SEL_MASK 0xF0000000u
+
+#define UMT_COUNTER_CTRL 0xE4
+
+#define UMT_TRG_MUX_1 0xF0
+#define UMT_TRG_MUX_1_UMT_RX0_SEL_POS 0
+#define UMT_TRG_MUX_1_UMT_RX0_SEL_MASK 0xFu
+#define UMT_TRG_MUX_1_UMT_RX1_SEL_POS 4
+#define UMT_TRG_MUX_1_UMT_RX1_SEL_MASK 0xF0u
+#define UMT_TRG_MUX_1_UMT_RX2_SEL_POS 8
+#define UMT_TRG_MUX_1_UMT_RX2_SEL_MASK 0xF00u
+#define UMT_TRG_MUX_1_UMT_RX3_SEL_POS 12
+#define UMT_TRG_MUX_1_UMT_RX3_SEL_MASK 0xF000u
+#define UMT_TRG_MUX_1_UMT_TX0_SEL_POS 16
+#define UMT_TRG_MUX_1_UMT_TX0_SEL_MASK 0xF0000u
+#define UMT_TRG_MUX_1_UMT_TX1_SEL_POS 20
+#define UMT_TRG_MUX_1_UMT_TX1_SEL_MASK 0xF00000u
+#define UMT_TRG_MUX_1_UMT_TX2_SEL_POS 24
+#define UMT_TRG_MUX_1_UMT_TX2_SEL_MASK 0xF000000u
+#define UMT_TRG_MUX_1_UMT_TX3_SEL_POS 28
+#define UMT_TRG_MUX_1_UMT_TX3_SEL_MASK 0xF0000000u
+
+#define UMT_RX0_MUX 0xF4
+#define UMT_RX0_MUX_UMT_RX0_SEL0_POS 0
+#define UMT_RX0_MUX_UMT_RX0_SEL0_MASK 0xFu
+#define UMT_RX0_MUX_UMT_RX0_SEL1_POS 4
+#define UMT_RX0_MUX_UMT_RX0_SEL1_MASK 0xF0u
+#define UMT_RX0_MUX_UMT_RX0_SEL2_POS 8
+#define UMT_RX0_MUX_UMT_RX0_SEL2_MASK 0xF00u
+#define UMT_RX0_MUX_UMT_RX0_SEL3_POS 16
+#define UMT_RX0_MUX_UMT_RX0_SEL3_MASK 0xF0000u
+#define UMT_RX0_MUX_UMT_RX0_SEL4_POS 20
+#define UMT_RX0_MUX_UMT_RX0_SEL4_MASK 0xF00000u
+#define UMT_RX0_MUX_UMT_RX0_SEL5_POS 24
+#define UMT_RX0_MUX_UMT_RX0_SEL5_MASK 0xF000000u
+#define UMT_RX0_MUX_UMT_RX0_SEL6_POS 12
+#define UMT_RX0_MUX_UMT_RX0_SEL6_MASK 0xF000u
+#define UMT_RX0_MUX_UMT_RX0_SEL7_POS 28
+#define UMT_RX0_MUX_UMT_RX0_SEL7_MASK 0xF0000000u
+
+#define UMT_MODE_REG 0x100
+#define UMT_MODE_REG_UMT_MD_MASK 0x2u
+#define UMT_MODE_REG_UMT_CNT_MOD_MASK 0x8u
+
+#define UMT_SW_MODE 0x114
+#define UMT_SW_MODE_SW_MSG_MD_MASK 0x3u
+
+#define UMT_GCTRL 0x200
+
+#define UMT_MSG0 0x220
+
+#define UMT_DEST_0 0x280
+
+#define UMT_DEST_1 0x380
+
+#define UMT_MSG0_1 0x390
+
+#define UMT_MSG1_1 0x394
+
+#define UMT_PERIOD_CH1 0x3A0
+
+#define UMT_SW_MODE_CH1 0x3B0
+
+#define UMT_DEST_2 0x480
+
+#define umt_r32(addr_base, x)  readl((addr_base) + (x))
+#define umt_w32(addr_base, x, y) writel((x), (addr_base) + (y))
+#define umt_w32_mask(addr_base, x, y, z) \
+		do { \
+			void __iomem *z_ = (addr_base) + (z); \
+			writel((readl(z_) & ~(x)) | (y), z_); \
+		} while (0)
+
+#define UMT_MSG(x)			(UMT_MSG0 + (x) * 4)
+
+#define UMT_X_SW_MODE		(UMT_SW_MODE_CH1 - UMT_DEST_1)
+#define UMT_X_PERIOD		(UMT_PERIOD_CH1 - UMT_DEST_1)
+#define UMT_X_DEST			(0)
+#define UMT_X_MSG(x)		((x) * 4)
+
+#define UMT_X_ADDR(x, off)	(UMT_DEST_1 + \
+				((x) - 1) * (UMT_DEST_2 - UMT_DEST_1) + (off))
+
+/* PRX300 register address */
+#define UMT_SW_MODE_PRX			0x218
+#define UMT_DEST_PRX			0x230
+#define UMT_MSG1_0_PRX			0x400
+#define UMT_PERIOD_CH1_PRX		0x420
+#define UMT_DEST_1_PRX			0x430
+#define UMT_SW_MODE_CH1_PRX		0x434
+#define UMT_MSG2_0_PRX			0x500
+
+/* PRX GCTRL */
+#define UMT_GCTRL_OCP_UMT_ENDI_B_MASK 0x10000000u
+#define UMT_GCTRL_OCP_UMT_ENDI_W_MASK 0x20000000u
+
+#define UMT_X_SW_MODE_PRX		(UMT_SW_MODE_CH1_PRX - UMT_MSG1_0_PRX)
+#define UMT_X_PERIOD_PRX		(UMT_PERIOD_CH1_PRX - UMT_MSG1_0_PRX)
+#define UMT_X_DEST_PRX		(UMT_DEST_1_PRX - UMT_MSG1_0_PRX)
+
+#define UMT_X_ADDR_PRX(x, off)	(UMT_MSG1_0_PRX + \
+				((x) - 1) * (UMT_MSG2_0_PRX - UMT_MSG1_0_PRX) + (off))
+
+#define UMT_PORTS_NUM		3
+#define MIN_UMT_PRD		20
+#define UMT_DEF_DMACID		13
+
+/* UMT port 0~7 */
+#define DP_UMT_ENTRY_NUM_LGM	8
+#define DP_UMT_ENTRY_NUM_PRX	3
+/* if request port id = 0xFF, automatically allocate id */
+#define UMT_PORT_AUTO_ALLOCATE		0xFF
+#define MIN_UMT_PRD		20
+#define DP_UMT_RX0_MAX_DMA_NUM	8
+
+#if IS_ENABLED(CONFIG_CPU_BIG_ENDIAN)
+	#define UMT_DEF_DW_SWAP		1
+	#define UMT_DEF_BYTE_SWAP	0
+#else
+	#define UMT_DEF_DW_SWAP		1
+	#define UMT_DEF_BYTE_SWAP	1
+#endif
+
+#define DEFAULT_CLK (0x17AC * 50000ULL)
+
+#define REG_LGM		1
+#define REG_PRX		0
+
+/* Add for DMA macro */
+#define _DMA_CHANBITS	16
+#define _DMA_PORTBITS	8
+#define _DMA_CTRLBITS	8
+
+#define _DMA_CHANMASK	((1 << _DMA_CHANBITS) - 1)
+#define _DMA_PORTMASK	((1 << _DMA_PORTBITS) - 1)
+#define _DMA_CTRLMASK	((1 << _DMA_CTRLBITS) - 1)
+
+#define _DMA_CHANSHIFT	0
+#define _DMA_PORTSHIFT	(_DMA_CHANSHIFT + _DMA_CHANBITS)
+#define _DMA_CTRLSHIFT	(_DMA_PORTSHIFT + _DMA_PORTBITS)
+
+#define _DMA_CONTROLLER(nr) (((nr) >> _DMA_CTRLSHIFT) & _DMA_CTRLMASK)
+#define _DMA_PORT(nr)		(((nr) >> _DMA_PORTSHIFT) & _DMA_PORTMASK)
+#define _DMA_CHANNEL(nr)	(((nr) >> _DMA_CHANSHIFT) & _DMA_CHANMASK)
+
+static struct dp_umt_priv *g_dp_umt_priv;
+static struct dp_umt_entry g_dp_umt_entry[DP_UMT_ENTRY_NUM_LGM];
+static int g_max_umt_port;
+
+struct intel_match_data {
+	u32 reg_type;
+};
+
+static void umt_set_mode(struct dp_umt_param *umt)
+{
+	int pos;
+	u8 mode;
+	u32 val;
+	struct dp_umt_priv *priv;
+
+	priv = g_dp_umt_priv;
+
+	if (!umt)
+		return;
+	if (umt->id >= g_max_umt_port || umt->msg_mode >= DP_UMT_MODE_MAX)
+		return;
+
+	if (priv->reg_type == REG_LGM) {
+		pos = (umt->id * 4) + 1;
+		mode = (u8)umt->msg_mode;
+		umt_w32_mask(priv->membase, (1 << pos), mode << pos, UMT_MODE_REG);
+	} else {
+		mode = (u8)umt->msg_mode;
+		if (!umt->id) {
+			umt_w32_mask(priv->membase, 0x2, ((u32)mode) << 1, UMT_GCTRL);
+		} else {
+			pos = 16 + (umt->id - 1) * 3;
+			val = umt_r32(priv->membase, UMT_GCTRL) & ~(BIT(pos));
+			umt_w32(priv->membase, val | (((u32)mode) << pos), UMT_GCTRL);
+		}
+	}
+
+}
+
+static void umt_set_msgmode(struct dp_umt_param *umt)
+{
+	u32 reg_addr;
+	struct dp_umt_priv *priv;
+
+	priv = g_dp_umt_priv;
+
+	if (!umt)
+		return;
+	if (umt->id >= g_max_umt_port || umt->sw_msg >= DP_UMT_MSG_MAX)
+		return;
+
+	if (priv->reg_type == REG_LGM) {
+		if (umt->id)
+			reg_addr = UMT_X_ADDR(umt->id, UMT_X_SW_MODE);
+		else
+			reg_addr = UMT_SW_MODE;
+	} else {
+		if (umt->id)
+			reg_addr = UMT_X_ADDR_PRX(umt->id, UMT_X_SW_MODE_PRX);
+		else
+			reg_addr = UMT_SW_MODE_PRX;
+	}
+
+	umt_w32(priv->membase, (u32)umt->sw_msg, reg_addr);
+}
+
+/* input in term of microseconds */
+static u32 umt_us_to_cnt(u32 usec)
+{
+	unsigned long cpuclk;
+	struct clk *clk;
+	unsigned long long usec_tmp;
+	struct dp_umt_priv *priv;
+	struct device *dev;
+
+	priv = g_dp_umt_priv;
+	dev = &priv->dev->dev;
+
+	clk = priv->clk;
+	if (!clk)
+		cpuclk = DEFAULT_CLK;
+	else
+		cpuclk = clk_get_rate(clk);
+
+	usec_tmp = (unsigned long long)usec *
+			((unsigned long)cpuclk / 1000000ULL);
+	if (usec_tmp > 0xFFFFFFFFULL) {
+		dev_err(dev, "UMT period exceeds max value! set to 0xFFFFFFFF.\n");
+		return 0xFFFFFFFF;
+	}
+	return (u32)usec_tmp;
+}
+
+static void umt_set_period(struct dp_umt_param *umt)
+{
+	u32 period, reg_addr;
+	struct dp_umt_priv *priv;
+
+	priv = g_dp_umt_priv;
+
+	if (!umt)
+		return;
+	if (umt->id >= g_max_umt_port)
+		return;
+
+	period = umt_us_to_cnt(umt->period);
+	if (umt->id)
+		if (priv->reg_type == REG_LGM)
+			reg_addr = UMT_X_ADDR(umt->id, UMT_X_PERIOD);
+		else
+			reg_addr = UMT_X_ADDR_PRX(umt->id, UMT_X_PERIOD_PRX);
+	else
+		reg_addr = UMT_PERD;
+
+	umt_w32(priv->membase, period, reg_addr);
+}
+
+static void umt_set_dst(struct dp_umt_param *umt)
+{
+	u32 reg_addr;
+	struct dp_umt_priv *priv;
+
+	priv = g_dp_umt_priv;
+
+	if (!umt)
+		return;
+	if (umt->id >= g_max_umt_port)
+		return;
+
+	if (priv->reg_type == REG_LGM) {
+		if (umt->id)
+			reg_addr = UMT_X_ADDR(umt->id, UMT_X_DEST);
+		else
+			reg_addr = UMT_DEST_0;
+	} else {
+		if (umt->id)
+			reg_addr = UMT_X_ADDR_PRX(umt->id, UMT_X_DEST_PRX);
+		else
+			reg_addr = UMT_DEST_PRX;
+	}
+
+	umt_w32(priv->membase, umt->daddr, reg_addr);
+}
+
+static int umt_allocate(struct dp_umt_param *umt, u32 *mode)
+{
+	u32 dma_cid, dma_pid, dma_ch;
+	int i, pid;
+	struct dp_umt_priv *priv;
+	struct dp_umt_entry *entry;
+	struct device *dev;
+
+	priv = g_dp_umt_priv;
+	dev = &priv->dev->dev;
+
+/* DP_UMT_RX_FROM_CQEM:
+ * UMT_TRG_MUX_0/UMT_TRG_MUX_1:
+ * UMT RX Counter:
+ * CQM enqueue port from 16--->UMT trigger value from 0
+ * UMT TX Counter:
+ * CQM DQ PORT 19----> UMT 0
+ *
+ * DP_UMT_RX_FROM_DMA:
+ * UMT PORT 0 (DOCSIS mode, set at UMT_MODE_REG UMT_CNT_MOD):
+ * UMT_RX0_MUX:
+ * DMATX0 CH0-7 ---> UMT 8-0xf
+ * UMT_TRG_MUX_0/UMT_TRG_MUX_1:
+ * UMT Rx Counter (DMA only to RX Counter):
+ * DMATX2 CH2-5 ---> UMT 0-3
+ * DMATX1 CH2-5 ---> UMT 4-7
+ */
+	if (!umt)
+		return -EINVAL;
+	if (umt->id < g_max_umt_port) {
+		if (priv->umts[umt->id].flag_bit.flag_bit.alloced == 0)
+			pid = umt->id;
+		else
+			return -EINVAL;
+	} else if (umt->id == UMT_PORT_AUTO_ALLOCATE) {
+		pid = -1;
+		spin_lock_bh(&priv->umt_lock);
+		for (i = g_max_umt_port - 1; i >= 0; i--) {
+			entry = &priv->umts[i];
+			if (entry->flag_bit.flag_bit.alloced == 0) {
+				pid = i;
+				break;
+			}
+		}
+		spin_unlock_bh(&priv->umt_lock);
+
+		if (pid < 0 || pid >= g_max_umt_port) {
+			dev_err(dev, "No free UMT port! umt id = %d\n", umt->id);
+			return -ENODEV;
+		}
+	} else {
+		dev_err(dev, "No free UMT port! umt id = %d\n", umt->id);
+		return -ENODEV;
+	}
+	if (umt->rx_src == DP_UMT_RX_FROM_CQEM) {
+		if (umt->cqm_enq_pid < 16 || umt->cqm_enq_pid > 23 ||
+			umt->cqm_dq_pid < 19 || umt->cqm_dq_pid > 26)
+			return -EINVAL;
+		entry = &priv->umts[pid];
+		*mode = DP_UMT_MUX_CQEM;
+	} else if (umt->rx_src == DP_UMT_RX_FROM_DMA) {
+		dma_cid = _DMA_CONTROLLER(umt->dma_id);
+		dma_pid = _DMA_PORT(umt->dma_id);
+		dma_ch = _DMA_CHANNEL(umt->dma_id);
+		if (umt->dma_ch_num == 8) {
+			if (priv->umts[0].flag_bit.flag_bit.alloced != 0) {
+				dev_err(dev, "%s: umt dma ch num %d but UMT PORT 0 is not available.\n",
+					__func__, umt->dma_ch_num);
+				return -ENODEV;
+			}
+			/* only UMT PORT 0 support multiple DMA CH so allocate it */
+			if (dma_cid == 0 && dma_ch >= 0 && dma_ch <= 7) {
+				pid = 0;
+				umt->id = 0;
+				*mode = DP_UMT_MUX_RX0;
+			} else {
+				return -EINVAL;
+			}
+		} else {
+			if (priv->reg_type == REG_LGM) {
+				if ((dma_cid == 2 || dma_cid == 1) && dma_ch >= 2 && dma_ch <= 5) {
+					entry = &priv->umts[pid];
+					*mode = DP_UMT_MUX_DMA;
+				} else {
+					return -EINVAL;
+				}
+			} else {
+				if (dma_ch <= 15) {
+					entry = &priv->umts[pid];
+					*mode = DP_UMT_MUX_DMA;
+				} else {
+					return -EINVAL;
+				}
+			if ((umt->cqm_dq_pid < 4) || (umt->cqm_dq_pid > 6)) {
+					return -EINVAL;
+				}
+			}
+		}
+	}
+
+	umt->id = pid;
+	return 0;
+}
+
+static void umt_set_mux(struct dp_umt_param *umt, enum dp_umt_mux_mode mode)
+{
+	u32 mux_sel, reg_addr;
+	u8 umt_rx_counter, umt_tx_counter, dma_cid, dma_ch, temp_id, i;
+	struct dp_umt_priv *priv;
+	struct dp_umt_entry *entry;
+	struct device *dev;
+
+	if (umt->id >= g_max_umt_port || mode >= DP_UMT_MUX_MODE_MAX)
+		return;
+
+	priv = g_dp_umt_priv;
+	entry = &priv->umts[umt->id];
+	dev = &priv->dev->dev;
+
+	if (mode == DP_UMT_MUX_CQEM) {
+		if (priv->reg_type == REG_LGM) {
+			if (umt->id >= 4) {
+				temp_id = umt->id - 4;
+				reg_addr = UMT_TRG_MUX_1;
+			} else {
+				temp_id = umt->id;
+				reg_addr = UMT_TRG_MUX_0;
+			}
+		} else {
+			if (umt->id >= 3) {
+				dev_err(dev, "%s: umt->id=%d is error.\n", __func__, umt->id);
+				return;
+			} else {
+				temp_id = umt->id;
+				reg_addr = UMT_TRG_MUX_0;
+			}
+		}
+		umt_rx_counter = umt->cqm_enq_pid - 16;
+		umt_tx_counter = umt->cqm_dq_pid - 19;
+		/* set UMT Multiple Counter Mode to 0 to support one UMT-Rx counters */
+		umt_w32_mask(priv->membase, BIT(3), ~BIT(3), UMT_MODE_REG);
+		mux_sel = umt_r32(priv->membase, reg_addr) &
+				(~((0xF000F) << (temp_id * 4)));
+		mux_sel |= ((umt_rx_counter << (temp_id * 4)) |
+				(umt_tx_counter << (16 + (temp_id * 4))));
+		umt_w32(priv->membase, mux_sel, reg_addr);
+	} else if (mode == DP_UMT_MUX_RX0) {
+		/* UMT PORT 0 RX Only */
+		dma_ch = _DMA_CHANNEL(umt->dma_id);
+		if (priv->reg_type != REG_LGM) {
+			dev_err(dev, "%s: mode=%d is error.\n", __func__, mode);
+			return;
+		}
+		reg_addr = UMT_RX0_MUX;
+		/* set UMT Multiple Counter Mode to 1 to support eight UMT-Rx counters */
+		umt_w32_mask(priv->membase, BIT(3), BIT(3), UMT_MODE_REG);
+		for (i = 0; i < umt->dma_ch_num; i++) {
+			umt_rx_counter = dma_ch + 8 + i;
+			mux_sel = umt_r32(priv->membase, reg_addr) &
+				(~((0x0F) << (i * 4)));
+			mux_sel |= (umt_rx_counter << (i * 4));
+			umt_w32(priv->membase, mux_sel, reg_addr);
+		}
+	} else {
+		dma_cid = _DMA_CONTROLLER(umt->dma_id);
+		dma_ch = _DMA_CHANNEL(umt->dma_id);
+		if (priv->reg_type == REG_LGM) {
+			if (umt->id >= 4) {
+				temp_id = umt->id - 4;
+				reg_addr = UMT_TRG_MUX_1;
+			} else {
+				temp_id = umt->id;
+				reg_addr = UMT_TRG_MUX_0;
+			}
+			if (dma_cid == 2)
+				umt_rx_counter = dma_ch - 2;
+			else if (dma_cid == 1)
+				umt_rx_counter = dma_ch + 2;
+			else
+				return;
+			umt_tx_counter = umt->cqm_dq_pid - 19;
+		} else {
+			if (umt->id >= 3) {
+				dev_err(dev, "%s: umt->id=%d is error.\n", __func__, umt->id);
+				return;
+			} else {
+				temp_id = umt->id;
+				reg_addr = UMT_TRG_MUX_0;
+			}
+			umt_rx_counter = dma_ch;
+			if ((umt->cqm_dq_pid >= 4) && (umt->cqm_dq_pid <= 6))
+				umt_tx_counter = umt->cqm_dq_pid - 4;
+			else
+				return;
+		}
+
+		/* set UMT Multiple Counter Mode to 0 to support one UMT-Rx counters */
+		umt_w32_mask(priv->membase, BIT(3), ~BIT(3), UMT_MODE_REG);
+		mux_sel = umt_r32(priv->membase, reg_addr) &
+				(~((0xF000F) << (temp_id * 4)));
+		mux_sel |= ((umt_rx_counter << (temp_id * 4)) |
+				(umt_tx_counter << (16 + (temp_id * 4))));
+		umt_w32(priv->membase, mux_sel, reg_addr);
+	}
+}
+
+static inline void umt_set_endian(int dw_swp, int byte_swp)
+{
+	u32 val;
+	struct dp_umt_priv *priv;
+
+	priv = g_dp_umt_priv;
+	val = umt_r32(priv->membase, UMT_GCTRL);
+	if (byte_swp)
+		val |= UMT_GCTRL_OCP_UMT_ENDI_B_MASK;
+	else
+		val &= ~(UMT_GCTRL_OCP_UMT_ENDI_B_MASK);
+
+	if (dw_swp)
+		val |= UMT_GCTRL_OCP_UMT_ENDI_W_MASK;
+	else
+		val &= ~(UMT_GCTRL_OCP_UMT_ENDI_W_MASK);
+
+	umt_w32(priv->membase, val, UMT_GCTRL);
+}
+
+static inline void umt_en_endian_mode(void)
+{
+	if (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))
+		umt_set_endian(1, 0);
+	else
+		umt_set_endian(1, 1);
+}
+
+static void umt_enable(struct dp_umt_param *umt)
+{
+	u32 val, pos;
+	struct dp_umt_priv *priv;
+	struct dp_umt_entry *entry;
+
+	priv = g_dp_umt_priv;
+
+	if (!umt)
+		return;
+	if (umt->id >= g_max_umt_port)
+		return;
+
+	if (priv->reg_type == REG_LGM) {
+		entry = &priv->umts[umt->id];
+		pos = umt->id * 4;
+		if ((umt->flag & DP_UMT_ENABLE_FLAG) == 0) {
+			entry->flag_bit.flag_bit.enabled = 0;
+			entry->param.flag &= ~DP_UMT_ENABLE_FLAG;
+			umt_w32_mask(priv->membase, (1 << pos), (0) << pos, UMT_MODE_REG);
+		} else {
+			entry->flag_bit.flag_bit.enabled = 1;
+			entry->param.flag |= DP_UMT_ENABLE_FLAG;
+			umt_w32_mask(priv->membase, (1 << pos), (1) << pos, UMT_MODE_REG);
+		}
+	} else {
+		entry = &priv->umts[umt->id];
+		if ((umt->flag & DP_UMT_ENABLE_FLAG) == 0) {
+			entry->flag_bit.flag_bit.enabled = 0;
+			entry->param.flag &= ~DP_UMT_ENABLE_FLAG;
+		} else {
+			entry->flag_bit.flag_bit.enabled = 1;
+			entry->param.flag |= DP_UMT_ENABLE_FLAG;
+		}
+		if (!umt->id) {
+			umt_w32_mask(priv->membase, 0x4, ((u32)entry->flag_bit.flag_bit.enabled) << 2, UMT_GCTRL);
+		} else {
+			pos = 17 + (umt->id - 1) * 3;
+			val = (umt_r32(priv->membase, UMT_GCTRL) & ~BIT(pos))
+					| (((u32)entry->flag_bit.flag_bit.enabled) << pos);
+			umt_w32(priv->membase, val, UMT_GCTRL);
+		}
+	}
+}
+
+static void umt_suspend(struct dp_umt_param *umt)
+{
+	u32 pos;
+	u8 halted;
+	struct dp_umt_priv *priv;
+	struct dp_umt_entry *entry;
+
+	priv = g_dp_umt_priv;
+
+	if (!umt)
+		return;
+	if (umt->id >= g_max_umt_port)
+		return;
+
+	entry = &priv->umts[umt->id];
+	if ((umt->flag & DP_UMT_SUSPEND_SENDING_COUNT) == 0) {
+		entry->flag_bit.flag_bit.halted = 0;
+		entry->param.flag &= ~DP_UMT_SUSPEND_SENDING_COUNT;
+	} else {
+		entry->flag_bit.flag_bit.halted = 1;
+		entry->param.flag |= DP_UMT_SUSPEND_SENDING_COUNT;
+	}
+
+	if (priv->reg_type == REG_LGM) {
+		if (umt->id > 3)
+			pos = umt->id + 12;
+		else
+			pos = umt->id;
+	} else {
+		if (umt->id > 2)
+			return;
+		else
+			pos = umt->id;
+	}
+
+	halted = entry->flag_bit.flag_bit.halted;
+	umt_w32_mask(priv->membase, (1 << pos), halted << pos, UMT_COUNTER_CTRL);
+}
+
+static void umt_counter_clear(struct dp_umt_param *umt, u32 status)
+{
+	u32 pos;
+	struct dp_umt_priv *priv;
+	struct dp_umt_entry *entry;
+
+	priv = g_dp_umt_priv;
+
+	if (!umt)
+		return;
+	if (umt->id >= g_max_umt_port)
+		return;
+
+	entry = &priv->umts[umt->id];
+
+	if (priv->reg_type == REG_LGM) {
+		if (umt->id > 3)
+			pos = umt->id + 16;
+		else
+			pos = umt->id + 4;
+	} else {
+		if (umt->id > 2)
+			return;
+		else
+			pos = umt->id + 4;
+	}
+
+	umt_w32_mask(priv->membase, (1 << pos), status << pos, UMT_COUNTER_CTRL);
+}
+
+static void umt_zero_send_disable(struct dp_umt_param *umt)
+{
+	u32 pos;
+	u8 val;
+	struct dp_umt_priv *priv;
+	struct dp_umt_entry *entry;
+
+	priv = g_dp_umt_priv;
+	if (priv->reg_type != REG_LGM)
+		return;
+
+	if (!umt)
+		return;
+	if (umt->id >= g_max_umt_port)
+		return;
+
+	entry = &priv->umts[umt->id];
+	if ((umt->flag & DP_UMT_NOT_SENDING_ZERO_COUNT) == 0) {
+		entry->flag_bit.flag_bit.not_snd_zero_cnt = 0;
+		entry->param.flag &= ~DP_UMT_NOT_SENDING_ZERO_COUNT;
+	} else {
+		entry->flag_bit.flag_bit.not_snd_zero_cnt = 1;
+		entry->param.flag |= DP_UMT_NOT_SENDING_ZERO_COUNT;
+	}
+
+	if (umt->id > 3)
+		pos = umt->id + 20;
+	else
+		pos = umt->id + 8;
+
+	val = (u8)entry->flag_bit.flag_bit.not_snd_zero_cnt;
+	umt_w32_mask(priv->membase, (1 << pos), val << pos, UMT_COUNTER_CTRL);
+}
+
+static void umt_rx_only_send(struct dp_umt_param *umt)
+{
+	u32 pos;
+	u8 val;
+	struct dp_umt_priv *priv;
+	struct dp_umt_entry *entry;
+
+	priv = g_dp_umt_priv;
+	if (priv->reg_type != REG_LGM)
+		return;
+
+	if (!umt)
+		return;
+	if (umt->id >= g_max_umt_port)
+		return;
+
+	entry = &priv->umts[umt->id];
+	if ((umt->flag & DP_UMT_SENDING_RX_COUNT_ONLY) == 0) {
+		entry->flag_bit.flag_bit.snd_rx_only = 0;
+		entry->param.flag &= ~DP_UMT_SENDING_RX_COUNT_ONLY;
+	} else {
+		entry->flag_bit.flag_bit.snd_rx_only = 1;
+		entry->param.flag |= DP_UMT_SENDING_RX_COUNT_ONLY;
+	}
+
+	if (umt->id > 3)
+		pos = umt->id + 24;
+	else
+		pos = umt->id + 12;
+
+	val = (u8)entry->flag_bit.flag_bit.snd_rx_only;
+	umt_w32_mask(priv->membase, (1 << pos), val << pos, UMT_COUNTER_CTRL);
+}
+
+/*This function will disable umt */
+static void umt_reset_umt(struct dp_umt_param *umt)
+{
+	u32 mode, pos, flag, mode1;
+	struct dp_umt_priv *priv;
+
+	priv = g_dp_umt_priv;
+
+	if (!umt)
+		return;
+	if (umt->id >= g_max_umt_port)
+		return;
+	flag = umt->flag;
+	mode1 = umt->msg_mode;
+
+	if (priv->reg_type == REG_LGM) {
+		/* disable umt */
+		umt->flag &= ~DP_UMT_ENABLE_FLAG;
+		umt_enable(umt);
+
+		pos = (umt->id * 4) + 1;
+		mode = (umt_r32(priv->membase, UMT_MODE_REG) & BIT(pos)) >> pos;
+
+		umt_set_mode(umt);
+		umt_set_mode(umt);
+
+		umt_w32_mask(priv->membase, BIT(4), BIT(4), UMT_GCTRL);
+		umt_w32_mask(priv->membase, BIT(4), ~BIT(4), UMT_GCTRL);
+	} else {
+		umt->flag &= ~DP_UMT_ENABLE_FLAG;
+		umt_enable(umt);
+
+		/* Bit 1 for UMT0
+		 * Bit 16 for UMT1
+		 * Bit 19 for UMT2
+		 */
+		if (!umt->id)
+			mode = (umt_r32(priv->membase, UMT_GCTRL) & BIT(1)) >> 1;
+		else
+			mode = (umt_r32(priv->membase, UMT_GCTRL) & BIT(16 + 3 * (umt->id - 1))) >> (16 + 3 * (umt->id - 1));
+
+		umt->msg_mode = !mode;
+		umt_set_mode(umt);
+		umt->msg_mode = mode;
+		umt_set_mode(umt);
+	}
+	umt->flag = flag;
+	umt->msg_mode = mode1;
+}
+
+/* read parameters from device tree node */
+static void umt_entry_init(struct device_node *node, int pid)
+{
+	struct dp_umt_entry *entry;
+
+	if (pid < g_dp_umt_priv->umt_num)
+		entry = &g_dp_umt_priv->umts[pid];
+	else
+		return;
+
+	entry->param.id = pid;
+
+	entry->param.flag |= DP_UMT_ENABLE_FLAG;
+	entry->param.msg_mode = DP_UMT_USER_MSG_MODE;
+	entry->flag_bit.flag_bit.enabled = 1;
+	entry->flag_bit.flag_bit.alloced = 0;
+	entry->param.period = 200;
+	if (pid == 0)
+		entry->max_dma_ch_num = 8;
+	else
+		entry->max_dma_ch_num = 1;
+
+	umt_set_mode(&entry->param);
+	umt_set_msgmode(&entry->param);
+	umt_set_dst(&entry->param);
+	umt_set_period(&entry->param);
+	umt_enable(&entry->param);
+	umt_suspend(&entry->param);
+	umt_zero_send_disable(&entry->param);
+	umt_rx_only_send(&entry->param);
+	umt_counter_clear(&entry->param, 1);
+	umt_counter_clear(&entry->param, 0);
+}
+
+/**
+ * debug proc should support:
+ * 1. register content dump
+ * 2. RX/TX trigger
+ * 3. UMT status
+ */
+
+/**
+ * intput:
+ * @umt
+ * @period: measured in microseconds.
+ * ret:  Fail < 0 / Success: 0
+ */
+int dp_umt_set_period(struct dp_umt_param *umt, unsigned long flag)
+{
+	struct dp_umt_priv *priv;
+	struct dp_umt_entry *entry;
+	struct device *dev;
+
+	priv = g_dp_umt_priv;
+	dev = &priv->dev->dev;
+
+	if (!umt) {
+		dev_err(dev, "UMT param is NULL!\n");
+		return -EINVAL;
+	}
+	if (umt->period < MIN_UMT_PRD) {
+		dev_err(dev, "Period (%d) is below min requirement!\n", umt->period);
+		return -EINVAL;
+	}
+
+	if (umt->id >= g_max_umt_port) {
+		dev_err(dev, "umit id (%d) is out of range !\n", umt->id);
+		return -EINVAL;
+	}
+
+	entry = &priv->umts[umt->id];
+
+	if (((entry->param.flag & DP_UMT_ENABLE_FLAG) == 0) || entry->flag_bit.flag_bit.enabled == 0) {
+		dev_err(dev, "UMT is not initialized!\n");
+		return -EINVAL;
+	}
+
+	if (entry->param.period != umt->period) {
+		entry->param.period = umt->period;
+		umt_set_period(umt);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(dp_umt_set_period);
+
+/**
+ * API to configure the UMT port.
+ * input:
+ * @umt
+ * @umt_mode:  0-self-counting mode, 1-user mode.
+ * @msg_mode:  0-No MSG, 1-MSG0 Only, 2-MSG1 Only, 3-MSG0 & MSG1.
+ * @dst:  Destination PHY address.
+ * @period(ms): only applicable when set to self-counting mode.
+ *              self-counting interval time. if 0, use the original setting.
+ * @enable: 1-Enable/0-Disable
+ * @ret:  Fail < 0 , SUCCESS:0
+ */
+int dp_umt_set(struct dp_umt_param *umt, unsigned long flag)
+{
+	u32 sw_msg;
+	u32 umt_mode;
+	u32 phy_dst;
+	u32 period;
+	struct dp_umt_priv *priv;
+	struct dp_umt_entry *entry;
+	struct device *dev;
+
+	priv = g_dp_umt_priv;
+	dev = &priv->dev->dev;
+
+	if (!umt) {
+		dev_err(dev, "UMT param is NULL!\n");
+		return -EINVAL;
+	}
+
+	umt_mode = umt->msg_mode;
+	sw_msg = umt->sw_msg;
+	phy_dst = umt->daddr;
+	period = umt->period;
+
+	if (umt_mode >= (u32)DP_UMT_MODE_MAX || sw_msg >= (u32)DP_UMT_MSG_MAX ||
+		phy_dst == 0 || period == 0 || umt->id >= g_max_umt_port) {
+		dev_err(dev, "umt_id: %d, umt_mode: %d, sw_msg: %d.\n",
+			umt->id, umt_mode, sw_msg);
+		dev_err(dev, "flag: %lu phy_dst: 0x%x period: %d\n",
+			umt->flag, phy_dst, period);
+		return -EINVAL;
+	}
+
+	entry = &priv->umts[umt->id];
+	if (entry->flag_bit.flag_bit.enabled == 0) {
+		dev_err(dev, "UMT is not initialized!!\n");
+		return -ENODEV;
+	}
+
+	umt_reset_umt(umt);
+
+	entry->param.msg_mode = (enum dp_umt_msg_mode)umt_mode;
+	entry->param.sw_msg = (enum dp_umt_sw_msg)sw_msg;
+	entry->param.daddr = phy_dst;
+	entry->param.period = period;
+	entry->param.flag = umt->flag;
+	if ((entry->param.flag & DP_UMT_ENABLE_FLAG) == 0)
+		entry->flag_bit.flag_bit.enabled = DP_UMT_STATUS_DISABLE;
+	else
+		entry->flag_bit.flag_bit.enabled = DP_UMT_STATUS_ENABLE;
+
+	if ((entry->param.flag & DP_UMT_NOT_SENDING_ZERO_COUNT) == 0)
+		entry->flag_bit.flag_bit.not_snd_zero_cnt = 0;
+	else
+		entry->flag_bit.flag_bit.not_snd_zero_cnt = 1;
+
+	if ((entry->param.flag & DP_UMT_SENDING_RX_COUNT_ONLY) == 0)
+		entry->flag_bit.flag_bit.snd_rx_only = 0;
+	else
+		entry->flag_bit.flag_bit.snd_rx_only = 1;
+
+	if ((entry->param.flag & DP_UMT_SUSPEND_SENDING_COUNT) == 0)
+		entry->flag_bit.flag_bit.halted = 0;
+	else
+		entry->flag_bit.flag_bit.halted = 1;
+
+	umt_set_mode(umt);
+	umt_set_msgmode(umt);
+	umt_set_dst(umt);
+	umt_set_period(umt);
+	umt_enable(umt);
+	umt_suspend(umt);
+	umt_zero_send_disable(umt);
+	umt_rx_only_send(umt);
+	umt_counter_clear(umt, 1);
+	umt_counter_clear(umt, 0);
+
+	return 0;
+}
+EXPORT_SYMBOL(dp_umt_set);
+
+/**
+ * API to enable/disable umt port
+ * input:
+ * @umt
+ * @enable: Enable: 1 / Disable: 0
+ * ret:  Fail < 0, Success: 0
+ */
+int dp_umt_enable(struct dp_umt_param *umt, unsigned long flag, int enable)
+{
+	struct dp_umt_priv *priv;
+	struct dp_umt_entry *entry;
+	struct device *dev;
+
+	priv = g_dp_umt_priv;
+	dev = &priv->dev->dev;
+
+	if (!umt) {
+		dev_err(dev, "UMT param is NULL!\n");
+		return -EINVAL;
+	}
+
+	if (umt->id >= g_max_umt_port)
+		return -EINVAL;
+
+	entry = &priv->umts[umt->id];
+
+	if (umt->daddr == 0) {
+		dev_err(dev, "input daddr: 0x%x\n", entry->param.daddr);
+		return -EINVAL;
+	}
+
+	if (enable) {
+		entry->flag_bit.flag_bit.enabled = DP_UMT_STATUS_ENABLE;
+		entry->param.flag |= DP_UMT_ENABLE_FLAG;
+	} else {
+		entry->flag_bit.flag_bit.enabled = DP_UMT_STATUS_DISABLE;
+		entry->param.flag &= ~DP_UMT_ENABLE_FLAG;
+	}
+
+	umt_enable(umt);
+
+	return 0;
+}
+EXPORT_SYMBOL(dp_umt_enable);
+
+/**
+ * API to suspend/resume umt US/DS counter
+ * input:
+ * @umt
+ * @halt: suspend: 1 / resume: 0
+ * ret:  Fail < 0, Success: 0
+ */
+int dp_umt_suspend_sending(struct dp_umt_param *umt,
+			   unsigned long flag, int halt)
+{
+	struct dp_umt_priv *priv;
+	struct dp_umt_entry *entry;
+	struct device *dev;
+
+	priv = g_dp_umt_priv;
+	dev = &priv->dev->dev;
+
+	if (umt->id >= g_max_umt_port)
+		return -EINVAL;
+
+	entry = &priv->umts[umt->id];
+
+	if (halt >= (u32)DP_UMT_STATUS_MAX || entry->flag_bit.flag_bit.enabled == 0)
+		return -ENODEV;
+
+	if (umt->daddr == 0) {
+		dev_err(dev, "input umt_dst: 0x%x\n", umt->daddr);
+		return -EINVAL;
+	}
+
+	if (halt == 0) {
+		entry->flag_bit.flag_bit.halted = 0;
+		entry->param.flag &= ~DP_UMT_SUSPEND_SENDING_COUNT;
+		umt->flag &= ~DP_UMT_SUSPEND_SENDING_COUNT;
+	} else {
+		entry->flag_bit.flag_bit.halted = 1;
+		entry->param.flag |= DP_UMT_SUSPEND_SENDING_COUNT;
+		umt->flag |= DP_UMT_SUSPEND_SENDING_COUNT;
+	}
+	umt_enable(umt);
+	umt_suspend(umt);
+
+	return 0;
+}
+EXPORT_SYMBOL(dp_umt_suspend_sending);
+
+/**
+ * API to request and allocate UMT port
+ * input:
+ * @umt:
+ * @flag:
+ * output:
+ * ret: Fail: < 0,  Success: 0
+ */
+int dp_umt_request(struct dp_umt_param *umt, unsigned long flag)
+{
+	u32 mode = DP_UMT_MODE_MAX;
+	int ret;
+	struct dp_umt_priv *priv;
+	struct dp_umt_entry *entry;
+	struct device *dev;
+
+	priv = g_dp_umt_priv;
+	dev = &priv->dev->dev;
+
+	if (umt->daddr == 0) {
+		dev_err(dev, "input umt_dst: 0x%x\n", umt->daddr);
+		return -EINVAL;
+	}
+
+	if (umt->id >= g_max_umt_port &&
+		umt->id != UMT_PORT_AUTO_ALLOCATE) {
+		dev_err(dev, "%s: umt id %d must be in ranage(0 - %d) or auto allocate\n",
+				__func__, umt->id, g_max_umt_port);
+		return -EINVAL;
+	}
+	if (umt->dma_ch_num >= DP_UMT_RX0_MAX_DMA_NUM) {
+		dev_err(dev, "%s: umt dma ch num %d must be in ranage(0 - %d)\n",
+				__func__, umt->dma_ch_num, DP_UMT_RX0_MAX_DMA_NUM);
+		return -EINVAL;
+	}
+
+	ret = umt_allocate(umt, &mode);
+	if (ret < 0)
+		return ret;
+
+	entry = &priv->umts[umt->id];
+	entry->flag_bit.flag_bit.alloced = 1;
+	umt->flag |= DP_UMT_ENABLE_FLAG;
+	memcpy(&entry->param, umt, sizeof(*umt));
+	umt_enable(umt);
+	umt_set_mux(umt, mode);
+
+	return 0;
+}
+EXPORT_SYMBOL(dp_umt_request);
+
+/**
+ * API to release umt port
+ * input:
+ * @umt
+ *
+ * ret:  Fail < 0, Success: 0
+ */
+int dp_umt_release(struct dp_umt_param *umt, unsigned long flag)
+{
+	struct dp_umt_priv *priv;
+	struct dp_umt_entry *entry;
+	struct device *dev;
+
+	priv = g_dp_umt_priv;
+	dev = &priv->dev->dev;
+
+	if (umt->id >= g_max_umt_port)
+		return -ENODEV;
+
+	entry = &priv->umts[umt->id];
+	if ((entry->param.flag & DP_UMT_ENABLE_FLAG) == 0) {
+		dev_err(dev, "UMT is not initialized!!\n");
+		return -ENODEV;
+	}
+
+	memset(entry, 0, sizeof(*entry));
+	umt->flag &= ~DP_UMT_ENABLE_FLAG;
+	umt_enable(umt);
+
+	return 0;
+}
+EXPORT_SYMBOL(dp_umt_release);
+
+#ifdef CONFIG_DEBUG_FS
+static void *dp_umt_port_seq_start(struct seq_file *s, loff_t *pos)
+{
+	if (*pos >= g_max_umt_port)
+		return NULL;
+	return &g_dp_umt_priv->umts[*pos];
+}
+
+static void *dp_umt_port_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	if (++*pos >= g_max_umt_port)
+		return NULL;
+	return &g_dp_umt_priv->umts[*pos];
+}
+
+static void dp_umt_port_seq_stop(struct seq_file *s, void *v)
+{
+}
+
+static int dp_umt_port_seq_show(struct seq_file *s, void *v)
+{
+	struct dp_umt_entry *entry = v;
+	int pid = entry->param.id;
+	u32 val;
+	struct dp_umt_priv *priv;
+	struct device *dev;
+
+	priv = g_dp_umt_priv;
+	dev = &priv->dev->dev;
+
+	seq_printf(s, "\nUMT port %d configuration\n", pid);
+	seq_puts(s, "-----------------------------------------\n");
+	seq_printf(s, "UMT Mode: \t%s\n",
+			entry->param.msg_mode == DP_UMT_SELFCNT_MODE ?
+			"UMT SelfCounting Mode" : "UMT User Mode");
+	seq_printf(s, "UMT Allocated: \t%s\n", entry->flag_bit.flag_bit.alloced ?
+			"Allocated" : "Free");
+	switch (entry->param.sw_msg) {
+	case DP_UMT_NO_MSG:
+		seq_puts(s, "UMT MSG Mode: \tUMT NO MSG\n");
+		break;
+	case DP_UMT_MSG0_ONLY:
+		seq_puts(s, "UMT MSG Mode: \tUMT MSG0 Only\n");
+		break;
+	case DP_UMT_MSG1_ONLY:
+		seq_puts(s, "UMT MSG Mode: \tUMT MSG1 Only\n");
+		break;
+	case DP_UMT_MSG0_MSG1:
+		seq_puts(s, "UMT MSG Mode: \tUMT_MSG0_And_MSG1\n");
+		break;
+	default:
+		seq_printf(s, "UMT MSG Mode Error! Msg_mode: %d\n",
+			   entry->param.sw_msg);
+	}
+	seq_printf(s, "UMT DST: \t0x%x\n", entry->param.daddr);
+	if (entry->param.msg_mode == DP_UMT_SELFCNT_MODE)
+		seq_printf(s, "UMT Period: \t%d(us)\n", entry->param.period);
+	seq_printf(s, "UMT Status: \t%s\n",
+		(entry->flag_bit.flag_bit.enabled != 0) ? "Enable" :
+		"Disable");
+	seq_printf(s, "UMT DMA CID: \t0x%x\n", entry->param.dma_id);
+	seq_printf(s, "UMT DMA CH NUM: \t%d\n", entry->param.dma_ch_num);
+	seq_printf(s, "UMT CQM ENQ PID: \t%d\n", entry->param.cqm_enq_pid);
+	seq_printf(s, "UMT CQM DEQ PID: \t%d\n", entry->param.cqm_dq_pid);
+
+	seq_printf(s, "++++Register dump of umt port: %d++++\n", pid);
+	if (pid == 0) {
+		if (priv->reg_type == REG_LGM) {
+			val = umt_r32(priv->membase, UMT_MODE_REG);
+			seq_printf(s, "UMT Mode: \t0x%x \t%s\n", val,
+					((val & UMT_MODE_REG_UMT_MD_MASK) != 0) ? "UMT User Mode" :
+					"UMT SelfCounting Mode");
+			val = umt_r32(priv->membase, UMT_SW_MODE);
+			switch (val & UMT_SW_MODE_SW_MSG_MD_MASK) {
+			case DP_UMT_NO_MSG:
+				seq_printf(s, "UMT MSG Mode: UMT NO MSG \t0x%x\n", val);
+				break;
+			case DP_UMT_MSG0_ONLY:
+				seq_printf(s, "UMT MSG Mode: UMT MSG0 Only \t0x%x\n", val);
+				break;
+			case DP_UMT_MSG1_ONLY:
+				seq_printf(s, "UMT MSG Mode: UMT MSG1 Only \t0x%x\n", val);
+				break;
+			case DP_UMT_MSG0_MSG1:
+				seq_printf(s, "UMT MSG Mode: UMT_MSG0_And_MSG1 \t0x%x\n", val);
+				break;
+			default:
+				seq_printf(s, "UMT MSG Mode Error! Msg_mode: %d\n", val);
+			}
+			val = umt_r32(priv->membase, UMT_DEST_0);
+			seq_printf(s, "UMT Dst: \t0x%x\n", val);
+			val = umt_r32(priv->membase, UMT_PERD);
+			seq_printf(s, "UMT Period: \t0x%x\n", val);
+			val = umt_r32(priv->membase, UMT_MSG(0));
+			seq_printf(s, "UMT MSG0: \t0x%x\n", val);
+			val = umt_r32(priv->membase, UMT_MSG(1));
+			seq_printf(s, "UMT MSG1: \t0x%x\n", val);
+			if (umt_r32(priv->membase, UMT_MODE_REG) &
+				UMT_MODE_REG_UMT_CNT_MOD_MASK) {
+				val = umt_r32(priv->membase, UMT_RX0_MUX);
+				seq_printf(s, "UMT_RX0_MUX: \t0x%x\n", val);
+				seq_printf(s, "UMT_RX0_SEL0: \t%d UMT_RX0_SEL1: \t%d\n", (val & UMT_RX0_MUX_UMT_RX0_SEL0_MASK) >> UMT_RX0_MUX_UMT_RX0_SEL0_POS, (val & UMT_RX0_MUX_UMT_RX0_SEL1_MASK) >> UMT_RX0_MUX_UMT_RX0_SEL1_POS);
+				seq_printf(s, "UMT_RX0_SEL2: \t%d UMT_RX0_SEL3: \t%d\n", (val & UMT_RX0_MUX_UMT_RX0_SEL2_MASK) >> UMT_RX0_MUX_UMT_RX0_SEL2_POS, (val & UMT_RX0_MUX_UMT_RX0_SEL3_MASK) >> UMT_RX0_MUX_UMT_RX0_SEL3_POS);
+				seq_printf(s, "UMT_RX0_SEL4: \t%d UMT_RX0_SEL5: \t%d\n", (val & UMT_RX0_MUX_UMT_RX0_SEL4_MASK) >> UMT_RX0_MUX_UMT_RX0_SEL4_POS, (val & UMT_RX0_MUX_UMT_RX0_SEL5_MASK) >> UMT_RX0_MUX_UMT_RX0_SEL5_POS);
+				seq_printf(s, "UMT_RX0_SEL6: \t%d UMT_RX0_SEL7: \t%d\n", (val & UMT_RX0_MUX_UMT_RX0_SEL6_MASK) >> UMT_RX0_MUX_UMT_RX0_SEL6_POS, (val & UMT_RX0_MUX_UMT_RX0_SEL7_MASK) >> UMT_RX0_MUX_UMT_RX0_SEL7_POS);
+			} else {
+				val = umt_r32(priv->membase, UMT_TRG_MUX_0);
+				seq_printf(s, "UMT_TRG_MUX_0: \t0x%x\n", val);
+				seq_printf(s, "UMT_RX0_SEL: \t%d UMT_TX0_SEL: \t%d\n", (val & UMT_TRG_MUX_0_UMT_RX0_SEL_MASK) >> UMT_TRG_MUX_0_UMT_RX0_SEL_POS, (val & UMT_TRG_MUX_0_UMT_TX0_SEL_MASK) >> UMT_TRG_MUX_0_UMT_TX0_SEL_POS);
+			}
+		} else {
+			seq_printf(s, "UMT Status: \t%s\n",
+				   (umt_r32(priv->membase, UMT_GCTRL) & BIT(2)) != 0 ?
+				   "Enable" : "Disable");
+			seq_printf(s, "UMT Mode: \t%s\n",
+				   (umt_r32(priv->membase, UMT_GCTRL) & BIT(1)) != 0 ?
+				   "UMT User MSG mode" : "UMT SelfCounting mode");
+			val = umt_r32(priv->membase, UMT_SW_MODE_PRX);
+			switch (val & UMT_SW_MODE_SW_MSG_MD_MASK) {
+			case DP_UMT_NO_MSG:
+				seq_printf(s, "UMT MSG Mode: UMT NO MSG \t0x%x\n", val);
+				break;
+			case DP_UMT_MSG0_ONLY:
+				seq_printf(s, "UMT MSG Mode: UMT MSG0 Only \t0x%x\n", val);
+				break;
+			case DP_UMT_MSG1_ONLY:
+				seq_printf(s, "UMT MSG Mode: UMT MSG1 Only \t0x%x\n", val);
+				break;
+			case DP_UMT_MSG0_MSG1:
+				seq_printf(s, "UMT MSG Mode: UMT_MSG0_And_MSG1 \t0x%x\n", val);
+				break;
+			default:
+				seq_printf(s, "UMT MSG Mode Error! Msg_mode: %d\n", val);
+			}
+			val = umt_r32(priv->membase, UMT_DEST_PRX);
+			seq_printf(s, "UMT Dst: \t0x%x\n", val);
+			val = umt_r32(priv->membase, UMT_PERD);
+			seq_printf(s, "UMT Period: \t0x%x\n", val);
+			val = umt_r32(priv->membase, UMT_MSG(0));
+			seq_printf(s, "UMT MSG0: \t0x%x\n", val);
+			val = umt_r32(priv->membase, UMT_MSG(1));
+			seq_printf(s, "UMT MSG1: \t0x%x\n", val);
+			val = umt_r32(priv->membase, UMT_TRG_MUX_0);
+			seq_printf(s, "UMT_TRG_MUX_0: \t0x%x\n", val);
+			seq_printf(s, "UMT_RX0_SEL: \t%d UMT_TX0_SEL: \t%d\n", (val & UMT_TRG_MUX_0_UMT_RX0_SEL_MASK) >> UMT_TRG_MUX_0_UMT_RX0_SEL_POS, (val & UMT_TRG_MUX_0_UMT_TX0_SEL_MASK) >> UMT_TRG_MUX_0_UMT_TX0_SEL_POS);
+		}
+	} else {
+		if (priv->reg_type == REG_LGM) {
+			val = umt_r32(priv->membase, UMT_MODE_REG);
+			seq_printf(s, "UMT Mode: \t0x%x \t%s\n", val,
+				((val & (UMT_MODE_REG_UMT_MD_MASK << (pid * 4))) != 0) ? "UMT User Mode" :
+				"UMT SelfCounting Mode");
+			val = umt_r32(priv->membase, UMT_X_ADDR(pid, UMT_X_SW_MODE));
+			switch (val & UMT_SW_MODE_SW_MSG_MD_MASK) {
+			case DP_UMT_NO_MSG:
+				seq_printf(s, "UMT MSG Mode: UMT NO MSG \t0x%x\n", val);
+				break;
+			case DP_UMT_MSG0_ONLY:
+				seq_printf(s, "UMT MSG Mode: UMT MSG0 Only \t0x%x\n", val);
+				break;
+			case DP_UMT_MSG1_ONLY:
+				seq_printf(s, "UMT MSG Mode: UMT MSG1 Only \t0x%x\n", val);
+				break;
+			case DP_UMT_MSG0_MSG1:
+				seq_printf(s, "UMT MSG Mode: UMT_MSG0_And_MSG1 \t0x%x\n", val);
+				break;
+			default:
+				seq_printf(s, "UMT MSG Mode Error! Msg_mode: %d\n", val);
+			}
+			val = umt_r32(priv->membase, UMT_X_ADDR(pid, UMT_X_DEST));
+			seq_printf(s, "UMT Dst: \t0x%x\n", val);
+			val = umt_r32(priv->membase, UMT_X_ADDR(pid, UMT_X_PERIOD));
+			seq_printf(s, "UMT Period: \t0x%x\n", val);
+			val = umt_r32(priv->membase, UMT_X_ADDR(pid, UMT_X_MSG(0)));
+			seq_printf(s, "UMT MSG0: \t0x%x\n", val);
+			val = umt_r32(priv->membase, UMT_X_ADDR(pid, UMT_X_MSG(1)));
+			seq_printf(s, "UMT MSG1: \t0x%x\n", val);
+			switch (pid) {
+			case 1:
+				val = umt_r32(priv->membase, UMT_TRG_MUX_0);
+				seq_printf(s, "UMT_TRG_MUX_0: \t0x%x\n", val);
+				seq_printf(s, "UMT_RX1_SEL: \t%d UMT_TX1_SEL: \t%d\n", (val & UMT_TRG_MUX_0_UMT_RX1_SEL_MASK) >> UMT_TRG_MUX_0_UMT_RX1_SEL_POS, (val & UMT_TRG_MUX_0_UMT_TX1_SEL_MASK) >> UMT_TRG_MUX_0_UMT_TX1_SEL_POS);
+				break;
+			case 2:
+				val = umt_r32(priv->membase, UMT_TRG_MUX_0);
+				seq_printf(s, "UMT_TRG_MUX_0: \t0x%x\n", val);
+				seq_printf(s, "UMT_RX2_SEL: \t%d UMT_TX2_SEL: \t%d\n", (val & UMT_TRG_MUX_0_UMT_RX2_SEL_MASK) >> UMT_TRG_MUX_0_UMT_RX2_SEL_POS, (val & UMT_TRG_MUX_0_UMT_TX2_SEL_MASK) >> UMT_TRG_MUX_0_UMT_TX2_SEL_POS);
+				break;
+			case 3:
+				val = umt_r32(priv->membase, UMT_TRG_MUX_0);
+				seq_printf(s, "UMT_TRG_MUX_0: \t0x%x\n", val);
+				seq_printf(s, "UMT_RX3_SEL: \t%d UMT_TX3_SEL: \t%d\n", (val & UMT_TRG_MUX_0_UMT_RX3_SEL_MASK) >> UMT_TRG_MUX_0_UMT_RX3_SEL_POS, (val & UMT_TRG_MUX_0_UMT_TX3_SEL_MASK) >> UMT_TRG_MUX_0_UMT_TX3_SEL_POS);
+				break;
+			case 4:
+				val = umt_r32(priv->membase, UMT_TRG_MUX_1);
+				seq_printf(s, "UMT_TRG_MUX_1: \t0x%x\n", val);
+				seq_printf(s, "UMT_RX4_SEL: \t%d UMT_TX4_SEL: \t%d\n", (val & UMT_TRG_MUX_1_UMT_RX0_SEL_MASK) >> UMT_TRG_MUX_1_UMT_RX0_SEL_POS, (val & UMT_TRG_MUX_1_UMT_TX0_SEL_MASK) >> UMT_TRG_MUX_1_UMT_TX0_SEL_POS);
+				break;
+			case 5:
+				val = umt_r32(priv->membase, UMT_TRG_MUX_1);
+				seq_printf(s, "UMT_TRG_MUX_1: \t0x%x\n", val);
+				seq_printf(s, "UMT_RX5_SEL: \t%d UMT_TX5_SEL: \t%d\n", (val & UMT_TRG_MUX_1_UMT_RX1_SEL_MASK) >> UMT_TRG_MUX_1_UMT_RX1_SEL_POS, (val & UMT_TRG_MUX_1_UMT_TX1_SEL_MASK) >> UMT_TRG_MUX_1_UMT_TX1_SEL_POS);
+				break;
+			case 6:
+				val = umt_r32(priv->membase, UMT_TRG_MUX_1);
+				seq_printf(s, "UMT_TRG_MUX_1: \t0x%x\n", val);
+				seq_printf(s, "UMT_RX6_SEL: \t%d UMT_TX6_SEL: \t%d\n", (val & UMT_TRG_MUX_1_UMT_RX2_SEL_MASK) >> UMT_TRG_MUX_1_UMT_RX2_SEL_POS, (val & UMT_TRG_MUX_1_UMT_TX2_SEL_MASK) >> UMT_TRG_MUX_1_UMT_TX2_SEL_POS);
+				break;
+			case 7:
+				val = umt_r32(priv->membase, UMT_TRG_MUX_1);
+				seq_printf(s, "UMT_TRG_MUX_1: \t0x%x\n", val);
+				seq_printf(s, "UMT_RX7_SEL: \t%d UMT_TX7_SEL: \t%d\n", (val & UMT_TRG_MUX_1_UMT_RX3_SEL_MASK) >> UMT_TRG_MUX_1_UMT_RX3_SEL_POS, (val & UMT_TRG_MUX_1_UMT_TX3_SEL_MASK) >> UMT_TRG_MUX_1_UMT_TX3_SEL_POS);
+				break;
+			default:
+				break;
+			}
+		} else {
+			if (pid == 1) {
+				seq_printf(s, "UMT Status: \t%s\n",
+					   (umt_r32(priv->membase, UMT_GCTRL) & BIT(17)) != 0 ?
+					   "Enable" : "Disable");
+				seq_printf(s, "%s reg_addr=0x%08x val=0x%08x\n", __func__, UMT_GCTRL, umt_r32(priv->membase, UMT_GCTRL));
+				seq_printf(s, "UMT Mode: \t%s\n",
+					   (umt_r32(priv->membase, UMT_GCTRL) & BIT(16)) != 0 ?
+					   "UMT User MSG mode" : "UMT SelfCounting mode");
+			} else {
+				seq_printf(s, "UMT Status: \t%s\n",
+					   (umt_r32(priv->membase, UMT_GCTRL) & BIT(20)) != 0 ?
+					   "Enable" : "Disable");
+				seq_printf(s, "%s reg_addr=0x%08x val=0x%08x\n", __func__, UMT_GCTRL, umt_r32(priv->membase, UMT_GCTRL));
+				seq_printf(s, "UMT Mode: \t%s\n",
+					   (umt_r32(priv->membase, UMT_GCTRL) & BIT(19)) != 0 ?
+					   "UMT User MSG mode" : "UMT SelfCounting mode");
+			}
+			val = umt_r32(priv->membase, UMT_X_ADDR_PRX(pid, UMT_X_SW_MODE_PRX));
+			seq_printf(s, "UMT_SW_MODE_PRX=0x%08x: \t0x%08x\n", UMT_X_ADDR_PRX(pid, UMT_X_SW_MODE_PRX), val);
+			switch (val & UMT_SW_MODE_SW_MSG_MD_MASK) {
+			case DP_UMT_NO_MSG:
+				seq_printf(s, "UMT MSG Mode: UMT NO MSG \t0x%x\n", val);
+				break;
+			case DP_UMT_MSG0_ONLY:
+				seq_printf(s, "UMT MSG Mode: UMT MSG0 Only \t0x%x\n", val);
+				break;
+			case DP_UMT_MSG1_ONLY:
+				seq_printf(s, "UMT MSG Mode: UMT MSG1 Only \t0x%x\n", val);
+				break;
+			case DP_UMT_MSG0_MSG1:
+				seq_printf(s, "UMT MSG Mode: UMT_MSG0_And_MSG1 \t0x%x\n", val);
+				break;
+			default:
+				seq_printf(s, "UMT MSG Mode Error! Msg_mode: %d\n", val);
+			}
+			val = umt_r32(priv->membase, UMT_X_ADDR_PRX(pid, UMT_X_DEST_PRX));
+			seq_printf(s, "UMT Dst=0x%08x: \t0x%x\n", UMT_X_ADDR_PRX(pid, UMT_X_DEST_PRX), val);
+			val = umt_r32(priv->membase, UMT_X_ADDR_PRX(pid, UMT_X_PERIOD_PRX));
+			seq_printf(s, "UMT Period=0x%08x: \t0x%x\n", UMT_X_ADDR_PRX(pid, UMT_X_PERIOD_PRX), val);
+			val = umt_r32(priv->membase, UMT_X_ADDR_PRX(pid, UMT_X_MSG(0)));
+			seq_printf(s, "UMT MSG0=0x%08x: \t0x%x\n", UMT_X_ADDR_PRX(pid, UMT_X_MSG(0)), val);
+			val = umt_r32(priv->membase, UMT_X_ADDR_PRX(pid, UMT_X_MSG(1)));
+			seq_printf(s, "UMT MSG1=0x%08x: \t0x%x\n", UMT_X_ADDR_PRX(pid, UMT_X_MSG(1)), val);
+			val = umt_r32(priv->membase, UMT_TRG_MUX_0);
+			seq_printf(s, "UMT_TRG_MUX_0=0x%08x: \t0x%x\n", UMT_TRG_MUX_0, val);
+		}
+	}
+
+	return 0;
+}
+
+static const struct seq_operations dp_umt_port_seq_ops = {
+	.start = dp_umt_port_seq_start,
+	.next = dp_umt_port_seq_next,
+	.stop = dp_umt_port_seq_stop,
+	.show = dp_umt_port_seq_show,
+};
+
+static int dp_umt_cfg_read_debugfs_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &dp_umt_port_seq_ops);
+}
+
+static const struct file_operations dp_umt_debugfs_fops = {
+	.open		= dp_umt_cfg_read_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+static int dp_umt_debugfs_init(void)
+{
+	struct dentry *entry;
+	struct dp_umt_priv *priv;
+	struct device *dev;
+
+	priv = g_dp_umt_priv;
+	dev = &priv->dev->dev;
+
+	priv->debugfs = debugfs_create_dir("umt", NULL);
+	if (!priv->debugfs)
+		return -ENOMEM;
+
+	entry = debugfs_create_file("umt_info", 0644, priv->debugfs,
+				    NULL, &dp_umt_debugfs_fops);
+	if (!entry)
+		goto err1;
+
+	return 0;
+err1:
+	debugfs_remove_recursive(priv->debugfs);
+	priv->debugfs = NULL;
+	dev_err(dev, "UMT debugfs create fail!\n");
+	return -ENOMEM;
+}
+#endif
+
+static int dp_umt_drv_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	int i;
+	struct resource *res;
+	struct dp_umt_priv *priv;
+	void __iomem *addr_base;
+	struct device *dev;
+	const struct intel_match_data *data;
+
+	if (pdev == NULL) {
+		pr_err("Wrong pdev\n");
+		return -EINVAL;
+	}
+	dev = &pdev->dev;
+
+	data = of_device_get_match_data(dev);
+	if (!data) {
+		dev_err(&pdev->dev, "Error: No device match found\n");
+		return -ENODEV;
+	}
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(dev, "Alloc umt priv fail!\n");
+		return -ENOMEM;
+	}
+	g_dp_umt_priv = priv;
+	priv->dev = pdev;
+	priv->reg_type = data->reg_type;
+	if (priv->reg_type == REG_LGM)
+		g_max_umt_port = DP_UMT_ENTRY_NUM_LGM;
+	else
+		g_max_umt_port = DP_UMT_ENTRY_NUM_PRX;
+
+	priv->clk = of_clk_get_by_name(node, "freq");
+
+	if (IS_ERR_VALUE(priv->clk)) {
+		dev_err(dev, "umt clock is missing.\n");
+		priv->clk = NULL;
+	} else {
+		dev_dbg(dev, "UMT clock rate is %lu\n", clk_get_rate(priv->clk));
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "failed to get the umt resource!\n");
+		goto error_device;
+	}
+
+	addr_base = devm_ioremap_resource(&pdev->dev, res);
+	if (!addr_base) {
+		dev_err(dev, "failed to request amd map the umt io range!\n");
+		goto error_device;
+	}
+	priv->membase = addr_base;
+
+	umt_en_endian_mode();
+
+	priv->umt_num = g_max_umt_port;
+	priv->umts = &g_dp_umt_entry[0];
+	for (i = 0; i < g_max_umt_port; i++)
+		umt_entry_init(node, i);
+
+#ifdef CONFIG_DEBUG_FS
+	dp_umt_debugfs_init();
+#endif
+
+	dev_info(dev, "INTEL DATAPATH UMT driver initialize success on processor: %d!\n",
+		smp_processor_id());
+
+	spin_lock_init(&priv->umt_lock);
+
+	return 0;
+error_device:
+	kfree(priv);
+	return -ENODEV;
+}
+
+static int dp_umt_drv_remove(struct platform_device *pdev)
+{
+	struct dp_umt_priv *priv;
+
+	priv = g_dp_umt_priv;
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove_recursive(priv->debugfs);
+#endif
+	kfree(g_dp_umt_priv);
+	dev_info(&pdev->dev, "Intel DATAPATH UMT driver remove!\n");
+	return 0;
+}
+
+static struct intel_match_data lgm = { .reg_type = REG_LGM };
+static struct intel_match_data prx = { .reg_type = REG_PRX };
+
+static const struct of_device_id dp_umt_drv_match[] = {
+	{ .compatible = "intel,lgm-datapath-umt", .data = &lgm},
+	{ .compatible = "intel,prx300-datapath-umt", .data = &prx},
+	{},
+};
+MODULE_DEVICE_TABLE(of, dp_umt__drv_match);
+
+static struct platform_driver dp_umt_driver = {
+	.probe = dp_umt_drv_probe,
+	.remove = dp_umt_drv_remove,
+	.driver = {
+		.name = "intel,datapath-umt",
+		.of_match_table = dp_umt_drv_match,
+		.owner = THIS_MODULE,
+	},
+};
+
+module_platform_driver(dp_umt_driver);
+
+MODULE_LICENSE("GPL v2");
diff --git a/include/net/datapath_api.h b/include/net/datapath_api.h
index 79b7cbaaae48..46026f8cc68a 100644
--- a/include/net/datapath_api.h
+++ b/include/net/datapath_api.h
@@ -121,6 +121,29 @@
 				  */
 #define DP_TS_HDRLEN	10    /*!< Befault Timestamp Header Length to strip */
 #define DP_DFL_SESS_NUM 16    /*!< Maximum default egress session per subif */
+/* Note: In LGM kernel (4.19) branch,
+ * DMA driver already adapted to linux kernel
+ * DMA framework and some DMA macro (like
+ * _DMA_CONTROLLER/_DMA_PORT/_DMA_CHANNEL)
+ * was removed. In order to keep the interface between DP and CQM/UMT driver
+ * same, DP has defined DMA macro accordingly
+ */
+#define _DMA_CHANBITS   16
+#define _DMA_PORTBITS   8
+#define _DMA_CTRLBITS   8
+
+#define _DMA_CHANMASK   ((1 << _DMA_CHANBITS) - 1)
+#define _DMA_PORTMASK   ((1 << _DMA_PORTBITS) - 1)
+#define _DMA_CTRLMASK   ((1 << _DMA_CTRLBITS) - 1)
+
+#define _DMA_CHANSHIFT  0
+#define _DMA_PORTSHIFT  (_DMA_CHANSHIFT + _DMA_CHANBITS)
+#define _DMA_CTRLSHIFT  (_DMA_PORTSHIFT + _DMA_PORTBITS)
+
+#define _DMA_CONTROLLER(nr)     (((nr) >> _DMA_CTRLSHIFT) & _DMA_CTRLMASK)
+#define _DMA_PORT(nr)           (((nr) >> _DMA_PORTSHIFT) & _DMA_PORTMASK)
+#define _DMA_CHANNEL(nr)        (((nr) >> _DMA_CHANSHIFT) & _DMA_CHANMASK)
+
 /*! @addtogroup Datapath_Driver_Structures */
 /*! @brief  DP Sub-interface Data structure
  *@param port_id  Datapath Port Id corresponds to PMAC Port Id
diff --git a/include/net/intel_datapath_umt.h b/include/net/intel_datapath_umt.h
new file mode 100644
index 000000000000..c5c2aff3fc21
--- /dev/null
+++ b/include/net/intel_datapath_umt.h
@@ -0,0 +1,134 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *  Copyright (C) 2018 Intel Corporation.
+ *  Wu ZhiXian <zhixian.wu@intel.com>
+ */
+#ifndef _INTEL_DATAPATH_UMT_H
+#define _INTEL_DATAPATH_UMT_H
+
+#define DP_UMT_NOT_SENDING_ZERO_COUNT	BIT(0)
+#define DP_UMT_SENDING_RX_COUNT_ONLY	BIT(1)
+#define DP_UMT_SUSPEND_SENDING_COUNT	BIT(2)
+#define DP_UMT_ENABLE_FLAG 				BIT(3)
+
+enum dp_umt_rx_src {
+	DP_UMT_RX_FROM_CQEM = 0,
+	DP_UMT_RX_FROM_DMA  = 1,
+	DP_UMT_RX_SRC_MAX,
+};
+
+enum dp_umt_msg_mode {
+	DP_UMT_SELFCNT_MODE  = 0,
+	DP_UMT_USER_MSG_MODE = 1,
+	DP_UMT_MODE_MAX,
+};
+
+enum dp_umt_sw_msg {
+	DP_UMT_NO_MSG	 = 0,
+	DP_UMT_MSG0_ONLY = 1,
+	DP_UMT_MSG1_ONLY = 2,
+	DP_UMT_MSG0_MSG1 = 3,
+	DP_UMT_MSG_MAX,
+};
+
+enum dp_umt_status {
+	DP_UMT_STATUS_DISABLE = 0,
+	DP_UMT_STATUS_ENABLE  = 1,
+	DP_UMT_STATUS_MAX,
+};
+
+enum dp_umt_mux_mode {
+    DP_UMT_MUX_CQEM = 0,
+    DP_UMT_MUX_RX0  = 1,
+    DP_UMT_MUX_DMA  = 2,
+    DP_UMT_MUX_MODE_MAX,
+};
+
+/**
+ * struct dp_umt_param
+ * id: umt HW ID. (0 - 7)
+ * rx_src: indicate rx msg source.
+ * dma_id: it contains DMA controller ID, DMA port ID and base DMA channel ID.
+ * dma_ch_num: number of dma channels used by this UMT port.
+ * cqm_enq_pid: cqm enqueue port ID.
+ * cqm_dq_pid: cqm dequeue port ID.
+ * daddr: UMT message destination address.
+ * msg_mode: UMT message mode.
+ * period: UMT message interval period.
+ * sw_msg: software message mode.
+ * flag:  UMT message control flag.
+ */
+struct dp_umt_param {
+	u8			id;
+	enum dp_umt_rx_src	rx_src;
+	u32			dma_id;
+	u8			dma_ch_num;
+	u8			cqm_enq_pid;
+	u8			cqm_dq_pid;
+	u32			daddr;
+	enum dp_umt_msg_mode	msg_mode;
+	u32			period;
+	enum dp_umt_sw_msg	sw_msg;
+	unsigned long		flag;
+};
+
+/**
+ * struct dp_umt_priv
+ * dev: platform device.
+ * membase: UMT register base address.
+ * umt_num: number of UMT entries.
+ * umts: umt entry list.
+ * umt_lock: protect the umt global resource.
+ * clk: clock source.
+ * debugfs: debugfs proc.
+ * dw_swap: Control OCP SWAPPER WORD for UMT.
+ * byte_swap: Control OCP SWAPPER byte for UMT.
+ */
+struct dp_umt_priv {
+	struct platform_device *dev;
+	void __iomem		*membase;
+	u8			umt_num;
+	struct dp_umt_entry	*umts;
+	spinlock_t umt_lock;
+	struct clk *clk;
+	struct dentry	*debugfs;
+	u8	dw_swap;
+	u8	byte_swap;
+	u32 reg_type;
+};
+
+/**
+ * struct dp_umt_entry
+ * param: umt configure parameters.
+ * alloced: umt entry status.
+ * enabled: umt entry status.
+ * halted:  umt control status.
+ * not_snd_zero_cnt: umt control status.
+ * snd_rx_only: umt control status.
+ * max_dam_ch_num: support max DMA channel numbers.
+ */
+union Flag_Bit {
+	u8 flag;
+	struct {
+	u8			alloced:1;
+	u8			enabled:1;
+	u8			halted:1;
+	u8			not_snd_zero_cnt:1;
+	u8			snd_rx_only:1;
+	u8			reserve:3;
+	}flag_bit;
+};
+
+struct dp_umt_entry {
+	struct dp_umt_param	param;
+	union Flag_Bit flag_bit;
+	int			max_dma_ch_num;
+};
+
+int dp_umt_request(struct dp_umt_param *umt, unsigned long flag);
+int dp_umt_set(struct dp_umt_param *umt, unsigned long flag);
+int dp_umt_enable(struct dp_umt_param *umt, unsigned long flag, int enable);
+int dp_umt_suspend_sending(struct dp_umt_param *umt,
+			   unsigned long flag, int halt);
+
+#endif
\ No newline at end of file
