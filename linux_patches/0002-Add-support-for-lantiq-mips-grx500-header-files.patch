From b75f85d96261991b85e38a40781e425799dcb4a8 Mon Sep 17 00:00:00 2001
From: Hua Ma <hua.ma@linux.intel.com>
Date: Thu, 21 Jun 2018 17:37:39 +0800
Subject: [PATCH] Add support for lantiq mips grx500 header files

---
 arch/mips/include/asm/mach-lantiq/dma-coherence.h  |  88 ++++
 .../asm/mach-lantiq/grx500/cpu-feature-overrides.h |  71 +++
 .../asm/mach-lantiq/grx500/grx500_bootcore_chadr.h |  49 ++
 .../mach-lantiq/grx500/grx500_bootcore_chipreg.h   |   9 +
 .../asm/mach-lantiq/grx500/grx500_bootcore_cnfg.h  |  38 ++
 .../asm/mach-lantiq/grx500/grx500_bootcore_defs.h  |  13 +
 .../grx500/grx500_bootcore_emerald_env_regs.h      | 564 +++++++++++++++++++++
 .../mach-lantiq/grx500/grx500_bootcore_interrupt.h | 135 +++++
 .../asm/mach-lantiq/grx500/grx500_bootcore_time.h  |  87 ++++
 .../asm/mach-lantiq/grx500/grx500_bootcore_uart.h  | 329 ++++++++++++
 arch/mips/include/asm/mach-lantiq/grx500/irq.h     |  22 +
 .../include/asm/mach-lantiq/grx500/lantiq_soc.h    |  95 ++++
 .../include/asm/mach-lantiq/grx500/lantiq_ssc.h    | 286 +++++++++++
 13 files changed, 1786 insertions(+)

diff --git a/arch/mips/include/asm/mach-lantiq/dma-coherence.h b/arch/mips/include/asm/mach-lantiq/dma-coherence.h
new file mode 100755
index 000000000000..f7df1637b773
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/dma-coherence.h
@@ -0,0 +1,88 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2006, 07  Ralf Baechle <ralf@linux-mips.org>
+ * Copyright (C) 2014, 10  Chuanhua Lei <chuanhua.lei@lantiq.com>
+ *
+ */
+#ifndef __ASM_MACH_LANTIQ_DMA_COHERENCE_H
+#define __ASM_MACH_LANTIQ_DMA_COHERENCE_H
+
+#ifdef CONFIG_SOC_GRX500
+
+#define GRX500_IO_COHERENT_START	0xA0000000
+struct device;
+
+static inline dma_addr_t plat_map_dma_mem(struct device *dev, void *addr,
+					  size_t size)
+{
+#if defined(CONFIG_DMA_NONCOHERENT) || defined(CONFIG_DMA_MAYBE_COHERENT)
+	return virt_to_phys(addr);
+#else
+	return virt_to_phys(addr) + GRX500_IO_COHERENT_START;
+#endif /* CONFIG_DMA_NONCOHERENT || CONFIG_DMA_MAYBE_COHERENT */
+}
+
+static inline dma_addr_t plat_map_dma_mem_page(struct device *dev,
+					       struct page *page)
+{
+#if defined(CONFIG_DMA_NONCOHERENT) || defined(CONFIG_DMA_MAYBE_COHERENT)
+	return page_to_phys(page);
+#else
+	return page_to_phys(page) + GRX500_IO_COHERENT_START;
+#endif /* CONFIG_DMA_NONCOHERENT || CONFIG_DMA_MAYBE_COHERENT */
+}
+
+static inline unsigned long plat_dma_addr_to_phys(struct device *dev,
+						  dma_addr_t dma_addr)
+{
+	return dma_addr;
+}
+
+static inline void plat_unmap_dma_mem(struct device *dev, dma_addr_t dma_addr,
+				      size_t size,
+				      enum dma_data_direction direction)
+{
+}
+
+static inline int plat_dma_supported(struct device *dev, u64 mask)
+{
+	/*
+	 * we fall back to GFP_DMA when the mask isn't all 1s,
+	 * so we can't guarantee allocations that must be
+	 * within a tighter range than GFP_DMA..
+	 */
+	if (mask < DMA_BIT_MASK(24))
+		return 0;
+
+	return 1;
+}
+
+static inline int plat_device_is_coherent(const struct device *dev)
+{
+#ifdef CONFIG_DMA_COHERENT
+	return 1;
+#else
+	switch (coherentio) {
+	default:
+	case IO_COHERENCE_DEFAULT:
+		return hw_coherentio;
+	case IO_COHERENCE_ENABLED:
+		return 1;
+	case IO_COHERENCE_DISABLED:
+		return 0;
+	}
+#endif /* CONFIG_DMA_COHERENT */
+}
+
+static inline void plat_post_dma_flush(struct device *dev)
+{
+}
+#else
+#include <asm/mach-generic/dma-coherence.h>
+#endif /* CONFIG_SOC_GRX500 */
+
+#endif /* __ASM_MACH_LANTIQ_DMA_COHERENCE_H */
+
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/cpu-feature-overrides.h b/arch/mips/include/asm/mach-lantiq/grx500/cpu-feature-overrides.h
new file mode 100755
index 000000000000..988bd9bad1dd
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/cpu-feature-overrides.h
@@ -0,0 +1,71 @@
+/*
+ * Intel GRX500 specific CPU feature overrides
+ * Copyright(C) 2016 Intel Corporation.
+ * This file was derived from: include/asm-mips/cpu-features.h
+ *	Copyright (C) 2003, 2004 Ralf Baechle
+ *	Copyright (C) 2004 Maciej W. Rozycki
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __ASM_MACH_GRX500_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_GRX500_CPU_FEATURE_OVERRIDES_H
+
+#ifdef CONFIG_SOC_GRX500
+#define cpu_has_tlb		1
+#define cpu_has_4kex		1
+#define cpu_has_3k_cache	0
+#define cpu_has_4k_cache	1
+#define cpu_has_tx39_cache	0
+#define cpu_has_sb1_cache	0
+#define cpu_has_fpu		0
+#define cpu_has_32fpr		0
+#define cpu_has_counter		1
+#define cpu_has_watch		1
+#define cpu_has_divec		1
+
+#define cpu_has_prefetch	1
+#define cpu_has_ejtag		1
+#define cpu_has_llsc		1
+
+#define cpu_has_mips16		0
+#define cpu_has_mdmx		0
+#define cpu_has_mips3d		0
+#define cpu_has_smartmips	0
+#define cpu_has_mmips		0
+#define cpu_has_vz		0
+
+#define cpu_has_mips32r1	1
+#define cpu_has_mips32r2	1
+#define cpu_has_mips64r1	0
+#define cpu_has_mips64r2	0
+
+#define cpu_has_dsp		1
+#define cpu_has_dsp2		0
+#define cpu_has_mipsmt		1
+
+#define cpu_has_vint		1
+#define cpu_has_veic		0
+
+#define cpu_has_64bits		0
+#define cpu_has_64bit_zero_reg	0
+#define cpu_has_64bit_gp_regs	0
+#define cpu_has_64bit_addresses	0
+
+#define cpu_has_cm2		1
+#define cpu_has_cm2_l2sync	1
+#define cpu_has_eva		1
+#define cpu_has_tlbinv		1
+
+#define cpu_dcache_line_size()	32
+#define cpu_icache_line_size()	32
+#define cpu_scache_line_size()	32
+#endif /* CONFIG_SOC_GRX500 */
+#endif /* __ASM_MACH_GRX500_CPU_FEATURE_OVERRIDES_H */
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_chadr.h b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_chadr.h
new file mode 100644
index 000000000000..81298c7cee6e
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_chadr.h
@@ -0,0 +1,49 @@
+#ifndef __MT_CHADR_H__
+#define __MT_CHADR_H__
+
+#ifdef  MT_GLOBAL
+#define MT_EXTERN
+#define MT_I(x) x
+#else
+#define MT_EXTERN extern
+#define MT_I(x)
+#endif
+
+/* unit base addresses */
+#define MT_LOCAL_MIPS_BASE_ADDRESS           0xb4900000 //0xa7000000 //HUANX
+#define REG_CPU_SUB_CLK_GATE		0x0
+#define CPU_SUB_CLK_GATE_MASK_ALL	0x3F
+#define REG_CPU_SUB_RST			0x4
+#define CPU_SUB_RST_MASK_RST		0x3F
+
+/* for UART mux control for different platform*/
+#ifdef CONFIG_SOC_GRX500_BOOTCORE
+#define LTQ_CHIPTOP_BASE_ADDR		0x16080000
+#define LTQ_CHIPTOP			KSEG1ADDR(LTQ_CHIPTOP_BASE_ADDR)
+#define LTQ_IFMUX_CFG			((u32 *)(LTQ_CHIPTOP + 0x0120))
+//! Field BBTEPUART_EN - Enable Baseband TEP ASC1 UART
+#define IFMUX_CFG_BBTEPUART_EN_POS 10
+//! Field BBTEPUART_EN - Enable Baseband TEP ASC1 UART
+#define IFMUX_CFG_BBTEPUART_EN_MASK 0xC00u
+//! Constant ASC1_U - ASC1
+#define CONST_IFMUX_CFG_BBTEPUART_EN_ASC1_U 0x0
+//! Constant WLAN_U - Enabled
+#define CONST_IFMUX_CFG_BBTEPUART_EN_WLAN_U 0x1
+//! Constant TEP_U - UART inside TEP sub system
+#define CONST_IFMUX_CFG_BBTEPUART_EN_TEP_U 0x2
+#define LTQ_MUX_TEP			(CONST_IFMUX_CFG_BBTEPUART_EN_TEP_U<<IFMUX_CFG_BBTEPUART_EN_POS)
+#endif /* CONFIG_SOC_GRX500_BOOTCORE */
+
+#ifdef CONFIG_SOC_FALCONMX_BOOTCORE
+#define LTQ_GPIO_PAD_CTRL_BASE_ADDR	0x16310000
+#define LTQ_GPIO_PAD_CTRL		KSEG1ADDR(LTQ_GPIO_PAD_CTRL_BASE_ADDR)
+#define LTQ_PORTMUXC30			((u32 *)(LTQ_GPIO_PAD_CTRL + 0x0078))
+#define LTQ_PORTMUXC31			((u32 *)(LTQ_GPIO_PAD_CTRL + 0x007C))
+#define LTQ_MUX_TEP			0x4
+#endif /* CONFIG_SOC_FALCONMX_BOOTCORE  */
+
+
+#undef MT_EXTERN
+#undef MT_I
+
+#endif /* __MT_CHADR_H__ */ 
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_chipreg.h b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_chipreg.h
new file mode 100644
index 000000000000..ad4d208215ce
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_chipreg.h
@@ -0,0 +1,9 @@
+#ifndef __MT_CHIPREG_H__
+#define __MT_CHIPREG_H__
+
+extern MT_UINT32 MT_RdReg(MT_UINT32 unit, MT_UINT32 reg);
+extern void MT_WrReg(MT_UINT32 unit, MT_UINT32 reg, MT_UINT32 data);
+extern void MT_WrRegMask(MT_UINT32 unit, MT_UINT32 reg, MT_UINT32 mask,MT_UINT32 data);
+
+
+#endif /* __MT_CHIPREG_H__ */
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_cnfg.h b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_cnfg.h
new file mode 100644
index 000000000000..86b97fe10153
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_cnfg.h
@@ -0,0 +1,38 @@
+#ifndef __MT_CNFG_H__
+#define __MT_CNFG_H__
+
+#ifdef MT_GLOBAL
+#define MT_EXTERN
+#define MT_I(x) x
+#else
+#define MT_EXTERN extern
+#define MT_I(x)
+#endif
+
+#define MIPS_INITIAL_CLOCK_MHz 40
+
+#define HW_CREG_U32(I)		*((volatile MT_UINT32*)(I))
+#define HW_CREG_U32_NEW(I)	*((volatile MT_UINT32*)(I))
+
+#define HW_CREG_U16(I)   	*((volatile MT_UINT16*)(I))
+
+#define HW_CREG(I)		*((volatile MT_UINT32*)(I))
+#define HW_C_U16(I)   	        *((volatile MT_UINT16*)(I))
+
+#define HW_CREG_UNIT(UNIT, REG)  (((MT_UINT32)UNIT) | \
+				  (((MT_UINT32)REG) << REG_MIPS_ADD_OFFSET) | \
+				   ((MT_UINT32)0x2))
+
+#define NONE_TRUNK_REG(UNIT, REG)	(HW_CREG_U32((MT_UINT32)UNIT | (MT_UINT32)REG ))
+
+
+
+#define MT_UBYTE		unsigned char
+#define MT_BYTE			char
+#define MT_UINT16		unsigned short
+#define MT_INT16		short
+#define MT_UINT32		unsigned long
+#define MT_INT32		long
+
+#endif /* __MT_CNFG_H__ */
+
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_defs.h b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_defs.h
new file mode 100644
index 000000000000..6e3df2d9774b
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_defs.h
@@ -0,0 +1,13 @@
+#ifndef __MT_DEFS_H__
+#define __MT_DEFS_H__
+
+typedef unsigned char	   uint8;
+typedef unsigned short     uint16;
+typedef unsigned long      uint32;
+
+typedef char	           int8;
+typedef short              int16;
+typedef long               int32;
+
+
+#endif  /* __MT_DEFS_H__ */
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_emerald_env_regs.h b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_emerald_env_regs.h
new file mode 100644
index 000000000000..f37e987c7282
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_emerald_env_regs.h
@@ -0,0 +1,564 @@
+#ifndef __Emerald_Env_regs_H__
+#define __Emerald_Env_regs_H__
+
+/* UART_WRITE_DATA */
+#define REG_UART_WRITE_DATA          0xc
+#define REG_UART_WRITE_DATA_MASK     0x000000ff
+#define REG_UART_WRITE_DATA_SHIFT    0
+#define REG_UART_WRITE_DATA_WIDTH    8
+
+/* UART_READ_DATA */
+#define REG_UART_READ_DATA          0x10
+#define REG_UART_READ_DATA_MASK     0x000000ff
+#define REG_UART_READ_DATA_SHIFT    0
+#define REG_UART_READ_DATA_WIDTH    8
+
+/* UART_READ_PARITY_ERROR_BIT */
+#define REG_UART_READ_PARITY_ERROR_BIT          0x10
+#define REG_UART_READ_PARITY_ERROR_BIT_MASK     0x00000100
+#define REG_UART_READ_PARITY_ERROR_BIT_SHIFT    8
+#define REG_UART_READ_PARITY_ERROR_BIT_WIDTH    1
+
+/* UART_CLOCK_DIVISION_RATIO */
+#define REG_UART_CLOCK_DIVISION_RATIO          0x14
+#define REG_UART_CLOCK_DIVISION_RATIO_MASK     0x00003fff
+#define REG_UART_CLOCK_DIVISION_RATIO_SHIFT    0
+#define REG_UART_CLOCK_DIVISION_RATIO_WIDTH    14
+
+/* UART_RX_FIFO_WATER_LEVEL */
+#define REG_UART_RX_FIFO_WATER_LEVEL          0x18
+#define REG_UART_RX_FIFO_WATER_LEVEL_MASK     0x0000001f
+#define REG_UART_RX_FIFO_WATER_LEVEL_SHIFT    0
+#define REG_UART_RX_FIFO_WATER_LEVEL_WIDTH    5
+
+/* UART_TX_FIFO_WATER_LEVEL */
+#define REG_UART_TX_FIFO_WATER_LEVEL          0x18
+#define REG_UART_TX_FIFO_WATER_LEVEL_MASK     0x000003e0
+#define REG_UART_TX_FIFO_WATER_LEVEL_SHIFT    5
+#define REG_UART_TX_FIFO_WATER_LEVEL_WIDTH    5
+
+/* UART_INT */
+#define REG_UART_INT          0x1c
+#define REG_UART_INT_MASK     0x0
+#define REG_UART_INT_SHIFT    0
+#define REG_UART_INT_WIDTH    0
+
+/* UART_OVERRUN_IRQ_ENABLE */
+#define REG_UART_OVERRUN_IRQ_ENABLE          0x1c
+#define REG_UART_OVERRUN_IRQ_ENABLE_MASK     0x00000001
+#define REG_UART_OVERRUN_IRQ_ENABLE_SHIFT    0
+#define REG_UART_OVERRUN_IRQ_ENABLE_WIDTH    1
+
+/* UART_FRAMING_ERROR_IRQ_ENABLE */
+#define REG_UART_FRAMING_ERROR_IRQ_ENABLE          0x1c
+#define REG_UART_FRAMING_ERROR_IRQ_ENABLE_MASK     0x00000002
+#define REG_UART_FRAMING_ERROR_IRQ_ENABLE_SHIFT    1
+#define REG_UART_FRAMING_ERROR_IRQ_ENABLE_WIDTH    1
+
+/* UART_PARITY_ERROR_IRQ_ENABLE */
+#define REG_UART_PARITY_ERROR_IRQ_ENABLE          0x1c
+#define REG_UART_PARITY_ERROR_IRQ_ENABLE_MASK     0x00000004
+#define REG_UART_PARITY_ERROR_IRQ_ENABLE_SHIFT    2
+#define REG_UART_PARITY_ERROR_IRQ_ENABLE_WIDTH    1
+
+/* UART_READ_COLLAPSE_BUFFER_IRQ_ENABLE */
+#define REG_UART_READ_COLLAPSE_BUFFER_IRQ_ENABLE          0x1c
+#define REG_UART_READ_COLLAPSE_BUFFER_IRQ_ENABLE_MASK     0x00000008
+#define REG_UART_READ_COLLAPSE_BUFFER_IRQ_ENABLE_SHIFT    3
+#define REG_UART_READ_COLLAPSE_BUFFER_IRQ_ENABLE_WIDTH    1
+
+/* UART_WRITE_COLLAPSE_BUFFER_IRQ_ENABLE */
+#define REG_UART_WRITE_COLLAPSE_BUFFER_IRQ_ENABLE          0x1c
+#define REG_UART_WRITE_COLLAPSE_BUFFER_IRQ_ENABLE_MASK     0x00000010
+#define REG_UART_WRITE_COLLAPSE_BUFFER_IRQ_ENABLE_SHIFT    4
+#define REG_UART_WRITE_COLLAPSE_BUFFER_IRQ_ENABLE_WIDTH    1
+
+/* UART_READ_FIFO_WATER_LEVEL_IRQ_ENABLE */
+#define REG_UART_READ_FIFO_WATER_LEVEL_IRQ_ENABLE          0x1c
+#define REG_UART_READ_FIFO_WATER_LEVEL_IRQ_ENABLE_MASK     0x00000020
+#define REG_UART_READ_FIFO_WATER_LEVEL_IRQ_ENABLE_SHIFT    5
+#define REG_UART_READ_FIFO_WATER_LEVEL_IRQ_ENABLE_WIDTH    1
+
+/* UART_WRITE_FIFO_WATER_LEVEL_IRQ_ENABLE */
+#define REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ_ENABLE          0x1c
+#define REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ_ENABLE_MASK     0x00000040
+#define REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ_ENABLE_SHIFT    6
+#define REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ_ENABLE_WIDTH    1
+
+/* UART_IDLE_IRQ_ENABLE */
+#define REG_UART_IDLE_IRQ_ENABLE          0x1c
+#define REG_UART_IDLE_IRQ_ENABLE_MASK     0x00000080
+#define REG_UART_IDLE_IRQ_ENABLE_SHIFT    7
+#define REG_UART_IDLE_IRQ_ENABLE_WIDTH    1
+
+/* UART_OVERRUN_IRQ */
+/* Clear the IRQ by writing "1" to this bit. */
+#define REG_UART_OVERRUN_IRQ          0x1c
+#define REG_UART_OVERRUN_IRQ_MASK     0x00000100
+#define REG_UART_OVERRUN_IRQ_SHIFT    8
+#define REG_UART_OVERRUN_IRQ_WIDTH    1
+
+/* UART_FRAMING_ERROR_IRQ */
+/* Clear the IRQ by writing "1" to this bit. */
+#define REG_UART_FRAMING_ERROR_IRQ          0x1c
+#define REG_UART_FRAMING_ERROR_IRQ_MASK     0x00000200
+#define REG_UART_FRAMING_ERROR_IRQ_SHIFT    9
+#define REG_UART_FRAMING_ERROR_IRQ_WIDTH    1
+
+/* UART_PARITY_ERROR_IRQ */
+/* Clear the IRQ by writing "1" to this bit. */
+#define REG_UART_PARITY_ERROR_IRQ          0x1c
+#define REG_UART_PARITY_ERROR_IRQ_MASK     0x00000400
+#define REG_UART_PARITY_ERROR_IRQ_SHIFT    10
+#define REG_UART_PARITY_ERROR_IRQ_WIDTH    1
+
+/* UART_READ_COLLAPSE_BUFFER_IRQ */
+/* Clear the IRQ by writing "1" to this bit. */
+#define REG_UART_READ_COLLAPSE_BUFFER_IRQ          0x1c
+#define REG_UART_READ_COLLAPSE_BUFFER_IRQ_MASK     0x00000800
+#define REG_UART_READ_COLLAPSE_BUFFER_IRQ_SHIFT    11
+#define REG_UART_READ_COLLAPSE_BUFFER_IRQ_WIDTH    1
+
+/* UART_WRITE_COLLAPSE_BUFFER_IRQ */
+/* Clear the IRQ by writing "1" to this bit. */
+#define REG_UART_WRITE_COLLAPSE_BUFFER_IRQ          0x1c
+#define REG_UART_WRITE_COLLAPSE_BUFFER_IRQ_MASK     0x00001000
+#define REG_UART_WRITE_COLLAPSE_BUFFER_IRQ_SHIFT    12
+#define REG_UART_WRITE_COLLAPSE_BUFFER_IRQ_WIDTH    1
+
+/* UART_READ_FIFO_WATER_LEVEL_IRQ */
+/* Clear the IRQ by writing "1" to this bit. */
+#define REG_UART_READ_FIFO_WATER_LEVEL_IRQ          0x1c
+#define REG_UART_READ_FIFO_WATER_LEVEL_IRQ_MASK     0x00002000
+#define REG_UART_READ_FIFO_WATER_LEVEL_IRQ_SHIFT    13
+#define REG_UART_READ_FIFO_WATER_LEVEL_IRQ_WIDTH    1
+
+/* UART_WRITE_FIFO_WATER_LEVEL_IRQ */
+/* Clear the IRQ by writing "1" to this bit. */
+#define REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ          0x1c
+#define REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ_MASK     0x00004000
+#define REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ_SHIFT    14
+#define REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ_WIDTH    1
+
+/* UART_IDLE_IRQ */
+/* Clear the IRQ by writing "1" to this bit. */
+#define REG_UART_IDLE_IRQ          0x1c
+#define REG_UART_IDLE_IRQ_MASK     0x00008000
+#define REG_UART_IDLE_IRQ_SHIFT    15
+#define REG_UART_IDLE_IRQ_WIDTH    1
+
+/* UART_CONTROL */
+#define REG_UART_CONTROL          0x20
+#define REG_UART_CONTROL_MASK     0x0
+#define REG_UART_CONTROL_SHIFT    0
+#define REG_UART_CONTROL_WIDTH    0
+
+/* UART_TX_OUTPUT_ENABLE */
+#define REG_UART_TX_OUTPUT_ENABLE          0x20
+#define REG_UART_TX_OUTPUT_ENABLE_MASK     0x00000001
+#define REG_UART_TX_OUTPUT_ENABLE_SHIFT    0
+#define REG_UART_TX_OUTPUT_ENABLE_WIDTH    1
+
+/* UART_RX_PARITY_MODE */
+#define REG_UART_RX_PARITY_MODE          0x20
+#define REG_UART_RX_PARITY_MODE_MASK     0x00000006
+#define REG_UART_RX_PARITY_MODE_SHIFT    1
+#define REG_UART_RX_PARITY_MODE_WIDTH    2
+
+/* UART_TX_PARITY_MODE */
+#define REG_UART_TX_PARITY_MODE          0x20
+#define REG_UART_TX_PARITY_MODE_MASK     0x00000018
+#define REG_UART_TX_PARITY_MODE_SHIFT    3
+#define REG_UART_TX_PARITY_MODE_WIDTH    2
+
+/* UART_RX_STOP */
+#define REG_UART_RX_STOP          0x20
+#define REG_UART_RX_STOP_MASK     0x00000020
+#define REG_UART_RX_STOP_SHIFT    5
+#define REG_UART_RX_STOP_WIDTH    1
+
+/* UART_TX_STOP */
+#define REG_UART_TX_STOP          0x20
+#define REG_UART_TX_STOP_MASK     0x00000040
+#define REG_UART_TX_STOP_SHIFT    6
+#define REG_UART_TX_STOP_WIDTH    1
+
+/* UART_LOOPBACK_MODE */
+#define REG_UART_LOOPBACK_MODE          0x20
+#define REG_UART_LOOPBACK_MODE_MASK     0x00000080
+#define REG_UART_LOOPBACK_MODE_SHIFT    7
+#define REG_UART_LOOPBACK_MODE_WIDTH    1
+
+/* UART_NOISE_COUNTER */
+#define REG_UART_NOISE_COUNTER          0x24
+#define REG_UART_NOISE_COUNTER_MASK     0x10000000
+#define REG_UART_NOISE_COUNTER_SHIFT    28
+#define REG_UART_NOISE_COUNTER_WIDTH    1
+
+/* UART_RX_IDLE_COUNTER */
+#define REG_UART_RX_IDLE_COUNTER          0x28
+#define REG_UART_RX_IDLE_COUNTER_MASK     0x000000ff
+#define REG_UART_RX_IDLE_COUNTER_SHIFT    0
+#define REG_UART_RX_IDLE_COUNTER_WIDTH    8
+
+/* UART_BYTES_IN_RX_FIFO */
+#define REG_UART_BYTES_IN_RX_FIFO          0x2c
+#define REG_UART_BYTES_IN_RX_FIFO_MASK     0x0000001f
+#define REG_UART_BYTES_IN_RX_FIFO_SHIFT    0
+#define REG_UART_BYTES_IN_RX_FIFO_WIDTH    5
+
+/* UART_BYTES_IN_TX_FIFO */
+#define REG_UART_BYTES_IN_TX_FIFO          0x2c
+#define REG_UART_BYTES_IN_TX_FIFO_MASK     0x000003e0
+#define REG_UART_BYTES_IN_TX_FIFO_SHIFT    5
+#define REG_UART_BYTES_IN_TX_FIFO_WIDTH    5
+
+/* UART_TX_INTERRUPT_MODE */
+#define REG_UART_TX_INTERRUPT_MODE          0x30
+#define REG_UART_TX_INTERRUPT_MODE_MASK     0x00000001
+#define REG_UART_TX_INTERRUPT_MODE_SHIFT    0
+#define REG_UART_TX_INTERRUPT_MODE_WIDTH    1
+
+
+#define REG_IRQ_MASK                       0x140
+
+/* IRQ_SOURCE_01_MAPPING */
+#define REG_IRQ_SOURCE_01_MAPPING          0x148
+#define REG_IRQ_SOURCE_01_MAPPING_MASK     0x0000001f
+#define REG_IRQ_SOURCE_01_MAPPING_SHIFT    0
+#define REG_IRQ_SOURCE_01_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_02_MAPPING */
+#define REG_IRQ_SOURCE_02_MAPPING          0x148
+#define REG_IRQ_SOURCE_02_MAPPING_MASK     0x000003e0
+#define REG_IRQ_SOURCE_02_MAPPING_SHIFT    5
+#define REG_IRQ_SOURCE_02_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_03_MAPPING */
+#define REG_IRQ_SOURCE_03_MAPPING          0x148
+#define REG_IRQ_SOURCE_03_MAPPING_MASK     0x00007c00
+#define REG_IRQ_SOURCE_03_MAPPING_SHIFT    10
+#define REG_IRQ_SOURCE_03_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_04_MAPPING */
+#define REG_IRQ_SOURCE_04_MAPPING          0x148
+#define REG_IRQ_SOURCE_04_MAPPING_MASK     0x000f8000
+#define REG_IRQ_SOURCE_04_MAPPING_SHIFT    15
+#define REG_IRQ_SOURCE_04_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_05_MAPPING */
+#define REG_IRQ_SOURCE_05_MAPPING          0x148
+#define REG_IRQ_SOURCE_05_MAPPING_MASK     0x01f00000
+#define REG_IRQ_SOURCE_05_MAPPING_SHIFT    20
+#define REG_IRQ_SOURCE_05_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_06_MAPPING */
+#define REG_IRQ_SOURCE_06_MAPPING          0x148
+#define REG_IRQ_SOURCE_06_MAPPING_MASK     0x3e000000
+#define REG_IRQ_SOURCE_06_MAPPING_SHIFT    25
+#define REG_IRQ_SOURCE_06_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_07_MAPPING */
+#define REG_IRQ_SOURCE_07_MAPPING          0x14c
+#define REG_IRQ_SOURCE_07_MAPPING_MASK     0x0000001f
+#define REG_IRQ_SOURCE_07_MAPPING_SHIFT    0
+#define REG_IRQ_SOURCE_07_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_08_MAPPING */
+#define REG_IRQ_SOURCE_08_MAPPING          0x14c
+#define REG_IRQ_SOURCE_08_MAPPING_MASK     0x000003e0
+#define REG_IRQ_SOURCE_08_MAPPING_SHIFT    5
+#define REG_IRQ_SOURCE_08_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_09_MAPPING */
+#define REG_IRQ_SOURCE_09_MAPPING          0x14c
+#define REG_IRQ_SOURCE_09_MAPPING_MASK     0x00007c00
+#define REG_IRQ_SOURCE_09_MAPPING_SHIFT    10
+#define REG_IRQ_SOURCE_09_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_10_MAPPING */
+#define REG_IRQ_SOURCE_10_MAPPING          0x14c
+#define REG_IRQ_SOURCE_10_MAPPING_MASK     0x000f8000
+#define REG_IRQ_SOURCE_10_MAPPING_SHIFT    15
+#define REG_IRQ_SOURCE_10_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_11_MAPPING */
+#define REG_IRQ_SOURCE_11_MAPPING          0x14c
+#define REG_IRQ_SOURCE_11_MAPPING_MASK     0x01f00000
+#define REG_IRQ_SOURCE_11_MAPPING_SHIFT    20
+#define REG_IRQ_SOURCE_11_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_12_MAPPING */
+#define REG_IRQ_SOURCE_12_MAPPING          0x14c
+#define REG_IRQ_SOURCE_12_MAPPING_MASK     0x3e000000
+#define REG_IRQ_SOURCE_12_MAPPING_SHIFT    25
+#define REG_IRQ_SOURCE_12_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_13_MAPPING */
+#define REG_IRQ_SOURCE_13_MAPPING          0x150
+#define REG_IRQ_SOURCE_13_MAPPING_MASK     0x0000001f
+#define REG_IRQ_SOURCE_13_MAPPING_SHIFT    0
+#define REG_IRQ_SOURCE_13_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_14_MAPPING */
+#define REG_IRQ_SOURCE_14_MAPPING          0x150
+#define REG_IRQ_SOURCE_14_MAPPING_MASK     0x000003e0
+#define REG_IRQ_SOURCE_14_MAPPING_SHIFT    5
+#define REG_IRQ_SOURCE_14_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_15_MAPPING */
+#define REG_IRQ_SOURCE_15_MAPPING          0x150
+#define REG_IRQ_SOURCE_15_MAPPING_MASK     0x00007c00
+#define REG_IRQ_SOURCE_15_MAPPING_SHIFT    10
+#define REG_IRQ_SOURCE_15_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_16_MAPPING */
+#define REG_IRQ_SOURCE_16_MAPPING          0x150
+#define REG_IRQ_SOURCE_16_MAPPING_MASK     0x000f8000
+#define REG_IRQ_SOURCE_16_MAPPING_SHIFT    15
+#define REG_IRQ_SOURCE_16_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_17_MAPPING */
+#define REG_IRQ_SOURCE_17_MAPPING          0x150
+#define REG_IRQ_SOURCE_17_MAPPING_MASK     0x01f00000
+#define REG_IRQ_SOURCE_17_MAPPING_SHIFT    20
+#define REG_IRQ_SOURCE_17_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_18_MAPPING */
+#define REG_IRQ_SOURCE_18_MAPPING          0x150
+#define REG_IRQ_SOURCE_18_MAPPING_MASK     0x3e000000
+#define REG_IRQ_SOURCE_18_MAPPING_SHIFT    25
+#define REG_IRQ_SOURCE_18_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_19_MAPPING */
+#define REG_IRQ_SOURCE_19_MAPPING          0x154
+#define REG_IRQ_SOURCE_19_MAPPING_MASK     0x0000001f
+#define REG_IRQ_SOURCE_19_MAPPING_SHIFT    0
+#define REG_IRQ_SOURCE_19_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_20_MAPPING */
+#define REG_IRQ_SOURCE_20_MAPPING          0x154
+#define REG_IRQ_SOURCE_20_MAPPING_MASK     0x000003e0
+#define REG_IRQ_SOURCE_20_MAPPING_SHIFT    5
+#define REG_IRQ_SOURCE_20_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_21_MAPPING */
+#define REG_IRQ_SOURCE_21_MAPPING          0x154
+#define REG_IRQ_SOURCE_21_MAPPING_MASK     0x00007c00
+#define REG_IRQ_SOURCE_21_MAPPING_SHIFT    10
+#define REG_IRQ_SOURCE_21_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_22_MAPPING */
+#define REG_IRQ_SOURCE_22_MAPPING          0x154
+#define REG_IRQ_SOURCE_22_MAPPING_MASK     0x000f8000
+#define REG_IRQ_SOURCE_22_MAPPING_SHIFT    15
+#define REG_IRQ_SOURCE_22_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_23_MAPPING */
+#define REG_IRQ_SOURCE_23_MAPPING          0x154
+#define REG_IRQ_SOURCE_23_MAPPING_MASK     0x01f00000
+#define REG_IRQ_SOURCE_23_MAPPING_SHIFT    20
+#define REG_IRQ_SOURCE_23_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_24_MAPPING */
+#define REG_IRQ_SOURCE_24_MAPPING          0x154
+#define REG_IRQ_SOURCE_24_MAPPING_MASK     0x3e000000
+#define REG_IRQ_SOURCE_24_MAPPING_SHIFT    25
+#define REG_IRQ_SOURCE_24_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_25_MAPPING */
+#define REG_IRQ_SOURCE_25_MAPPING          0x158
+#define REG_IRQ_SOURCE_25_MAPPING_MASK     0x0000001f
+#define REG_IRQ_SOURCE_25_MAPPING_SHIFT    0
+#define REG_IRQ_SOURCE_25_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_26_MAPPING */
+#define REG_IRQ_SOURCE_26_MAPPING          0x158
+#define REG_IRQ_SOURCE_26_MAPPING_MASK     0x000003e0
+#define REG_IRQ_SOURCE_26_MAPPING_SHIFT    5
+#define REG_IRQ_SOURCE_26_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_27_MAPPING */
+#define REG_IRQ_SOURCE_27_MAPPING          0x158
+#define REG_IRQ_SOURCE_27_MAPPING_MASK     0x00007c00
+#define REG_IRQ_SOURCE_27_MAPPING_SHIFT    10
+#define REG_IRQ_SOURCE_27_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_28_MAPPING */
+#define REG_IRQ_SOURCE_28_MAPPING          0x158
+#define REG_IRQ_SOURCE_28_MAPPING_MASK     0x000f8000
+#define REG_IRQ_SOURCE_28_MAPPING_SHIFT    15
+#define REG_IRQ_SOURCE_28_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_29_MAPPING */
+#define REG_IRQ_SOURCE_29_MAPPING          0x158
+#define REG_IRQ_SOURCE_29_MAPPING_MASK     0x01f00000
+#define REG_IRQ_SOURCE_29_MAPPING_SHIFT    20
+#define REG_IRQ_SOURCE_29_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_30_MAPPING */
+#define REG_IRQ_SOURCE_30_MAPPING          0x158
+#define REG_IRQ_SOURCE_30_MAPPING_MASK     0x3e000000
+#define REG_IRQ_SOURCE_30_MAPPING_SHIFT    25
+#define REG_IRQ_SOURCE_30_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_31_MAPPING */
+#define REG_IRQ_SOURCE_31_MAPPING          0x15c
+#define REG_IRQ_SOURCE_31_MAPPING_MASK     0x0000001f
+#define REG_IRQ_SOURCE_31_MAPPING_SHIFT    0
+#define REG_IRQ_SOURCE_31_MAPPING_WIDTH    5
+
+/* MAPPED_IRQS_FROM_MAPPER */
+#define REG_MAPPED_IRQS_FROM_MAPPER          0x160
+#define REG_MAPPED_IRQS_FROM_MAPPER_MASK     0x7fffffff
+#define REG_MAPPED_IRQS_FROM_MAPPER_SHIFT    0
+#define REG_MAPPED_IRQS_FROM_MAPPER_WIDTH    31
+
+/* UNMAPPED_IRQS_TO_MAPPER */
+#define REG_UNMAPPED_IRQS_TO_MAPPER          0x164
+#define REG_UNMAPPED_IRQS_TO_MAPPER_MASK     0x7fffffff
+#define REG_UNMAPPED_IRQS_TO_MAPPER_SHIFT    0
+#define REG_UNMAPPED_IRQS_TO_MAPPER_WIDTH    31
+
+/* TIMER_0_MAX_COUNT */
+#define REG_TIMER_0_MAX_COUNT          0x180
+#define REG_TIMER_0_MAX_COUNT_MASK     0xffffffff
+#define REG_TIMER_0_MAX_COUNT_SHIFT    0
+#define REG_TIMER_0_MAX_COUNT_WIDTH    32
+
+/* TIMER_1_MAX_COUNT */
+#define REG_TIMER_1_MAX_COUNT          0x184
+#define REG_TIMER_1_MAX_COUNT_MASK     0xffffffff
+#define REG_TIMER_1_MAX_COUNT_SHIFT    0
+#define REG_TIMER_1_MAX_COUNT_WIDTH    32
+
+/* TIMER_2_MAX_COUNT */
+#define REG_TIMER_2_MAX_COUNT          0x188
+#define REG_TIMER_2_MAX_COUNT_MASK     0xffffffff
+#define REG_TIMER_2_MAX_COUNT_SHIFT    0
+#define REG_TIMER_2_MAX_COUNT_WIDTH    32
+
+/* TIMER_3_MAX_COUNT */
+#define REG_TIMER_3_MAX_COUNT          0x18c
+#define REG_TIMER_3_MAX_COUNT_MASK     0xffffffff
+#define REG_TIMER_3_MAX_COUNT_SHIFT    0
+#define REG_TIMER_3_MAX_COUNT_WIDTH    32
+
+/* TIMER_0_COUNT_VALUE */
+#define REG_TIMER_0_COUNT_VALUE          0x190
+#define REG_TIMER_0_COUNT_VALUE_MASK     0xffffffff
+#define REG_TIMER_0_COUNT_VALUE_SHIFT    0
+#define REG_TIMER_0_COUNT_VALUE_WIDTH    32
+
+/* TIMER_1_COUNT_VALUE */
+#define REG_TIMER_1_COUNT_VALUE          0x194
+#define REG_TIMER_1_COUNT_VALUE_MASK     0xffffffff
+#define REG_TIMER_1_COUNT_VALUE_SHIFT    0
+#define REG_TIMER_1_COUNT_VALUE_WIDTH    32
+
+/* TIMER_2_COUNT_VALUE */
+#define REG_TIMER_2_COUNT_VALUE          0x198
+#define REG_TIMER_2_COUNT_VALUE_MASK     0xffffffff
+#define REG_TIMER_2_COUNT_VALUE_SHIFT    0
+#define REG_TIMER_2_COUNT_VALUE_WIDTH    32
+
+/* TIMER_3_COUNT_VALUE */
+#define REG_TIMER_3_COUNT_VALUE          0x19c
+#define REG_TIMER_3_COUNT_VALUE_MASK     0xffffffff
+#define REG_TIMER_3_COUNT_VALUE_SHIFT    0
+#define REG_TIMER_3_COUNT_VALUE_WIDTH    32
+
+/* TIMER0_EXPIRED */
+#define REG_TIMER0_EXPIRED          0x1a0
+#define REG_TIMER0_EXPIRED_MASK     0x00000001
+#define REG_TIMER0_EXPIRED_SHIFT    0
+#define REG_TIMER0_EXPIRED_WIDTH    1
+
+/* TIMER1_EXPIRED */
+#define REG_TIMER1_EXPIRED          0x1a0
+#define REG_TIMER1_EXPIRED_MASK     0x00000002
+#define REG_TIMER1_EXPIRED_SHIFT    1
+#define REG_TIMER1_EXPIRED_WIDTH    1
+
+/* TIMER2_EXPIRED */
+#define REG_TIMER2_EXPIRED          0x1a0
+#define REG_TIMER2_EXPIRED_MASK     0x00000004
+#define REG_TIMER2_EXPIRED_SHIFT    2
+#define REG_TIMER2_EXPIRED_WIDTH    1
+
+/* TIMER3_EXPIRED */
+#define REG_TIMER3_EXPIRED          0x1a0
+#define REG_TIMER3_EXPIRED_MASK     0x00000008
+#define REG_TIMER3_EXPIRED_SHIFT    3
+#define REG_TIMER3_EXPIRED_WIDTH    1
+
+/* TIMER_0_ONESHOT_MODE */
+#define REG_TIMER_0_ONESHOT_MODE          0x1a4
+#define REG_TIMER_0_ONESHOT_MODE_MASK     0x00000001
+#define REG_TIMER_0_ONESHOT_MODE_SHIFT    0
+#define REG_TIMER_0_ONESHOT_MODE_WIDTH    1
+
+/* TIMER_1_ONESHOT_MODE */
+#define REG_TIMER_1_ONESHOT_MODE          0x1a4
+#define REG_TIMER_1_ONESHOT_MODE_MASK     0x00000002
+#define REG_TIMER_1_ONESHOT_MODE_SHIFT    1
+#define REG_TIMER_1_ONESHOT_MODE_WIDTH    1
+
+/* TIMER_2_ONESHOT_MODE */
+#define REG_TIMER_2_ONESHOT_MODE          0x1a4
+#define REG_TIMER_2_ONESHOT_MODE_MASK     0x00000004
+#define REG_TIMER_2_ONESHOT_MODE_SHIFT    2
+#define REG_TIMER_2_ONESHOT_MODE_WIDTH    1
+
+/* TIMER_3_ONESHOT_MODE */
+#define REG_TIMER_3_ONESHOT_MODE          0x1a4
+#define REG_TIMER_3_ONESHOT_MODE_MASK     0x00000008
+#define REG_TIMER_3_ONESHOT_MODE_SHIFT    3
+#define REG_TIMER_3_ONESHOT_MODE_WIDTH    1
+
+/* TIMER_0_ENABLE */
+#define REG_TIMER_0_ENABLE          0x1a4
+#define REG_TIMER_0_ENABLE_MASK     0x00000010
+#define REG_TIMER_0_ENABLE_SHIFT    4
+#define REG_TIMER_0_ENABLE_WIDTH    1
+
+/* TIMER_1_ENABLE */
+#define REG_TIMER_1_ENABLE          0x1a4
+#define REG_TIMER_1_ENABLE_MASK     0x00000020
+#define REG_TIMER_1_ENABLE_SHIFT    5
+#define REG_TIMER_1_ENABLE_WIDTH    1
+
+/* TIMER_2_ENABLE */
+#define REG_TIMER_2_ENABLE          0x1a4
+#define REG_TIMER_2_ENABLE_MASK     0x00000040
+#define REG_TIMER_2_ENABLE_SHIFT    6
+#define REG_TIMER_2_ENABLE_WIDTH    1
+
+/* TIMER_3_ENABLE */
+#define REG_TIMER_3_ENABLE          0x1a4
+#define REG_TIMER_3_ENABLE_MASK     0x00000080
+#define REG_TIMER_3_ENABLE_SHIFT    7
+#define REG_TIMER_3_ENABLE_WIDTH    1
+
+/*Prescale */
+#define REG_TIMER_PRESCALER_MIN     2
+#define REG_TIMER_PRESCALER_MAX     3
+
+/* TIMER_0_PRESCALER - N/A*/
+
+/* TIMER_1_PRESCALER - N/A*/
+
+/* TIMER_2_PRESCALER */
+#define REG_TIMER_2_PRESCALER       0x1a8
+#define REG_TIMER_2_PRESCALER_MASK  0x000000ff
+#define REG_TIMER_2_PRESCALER_SHIFT 0
+#define REG_TIMER_2_PRESCALER_WIDTH 8
+
+/* TIMER_3_PRESCALER */
+#define REG_TIMER_3_PRESCALER       0x1ac
+#define REG_TIMER_3_PRESCALER_MASK  0x000000ff
+#define REG_TIMER_3_PRESCALER_SHIFT 0
+#define REG_TIMER_3_PRESCALER_WIDTH 8
+
+
+#endif /* __Emerald_Env_regs_H__ */
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_interrupt.h b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_interrupt.h
new file mode 100644
index 000000000000..370f508b5a2b
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_interrupt.h
@@ -0,0 +1,135 @@
+#ifndef __GRX500_BOOTCORE_INTERRUPT_H__
+#define __GRX500_BOOTCORE_INTERRUPT_H__
+
+#ifdef  MT_GLOBAL
+#define MT_EXTERN
+#define MT_I(x) x
+#else
+#define MT_EXTERN extern
+#define MT_I(x)
+#endif
+
+extern void grx500_bootcore_enable_irq_all_mips(unsigned long val);
+
+extern void grx500_bootcore_init_irq(void);
+
+/**
+ *      grx500_bootcore_register_static_irq - register interrupt
+ *      @irq_in: Incoming IRQ number for interrupt router
+ *      @irq_out: Outgoing IRQ number for interrupt router
+ *      @action: IRQ action structure in memory provided by user
+ *      @addr: Vector interrupt handler
+ *
+ * Used to statically register interrupt during system startup.
+ */
+
+extern int grx500_bootcore_register_static_irq(unsigned int irq_in, unsigned int irq_out, 
+                                    struct irqaction *action, vi_handler_t addr);
+
+/**
+ *      grx500_bootcore_register_irq - register interrupt
+ *      @irq_in: Incoming IRQ number for interrupt router
+ *      @irq_out: Outgoing IRQ number for interrupt router
+ *      @handler: User's handler function
+ *      @flags: IRQ flags
+ *      @name: Device name
+ *      @dev_id: Owner device ID
+ *      @addr: Vector interrupt handler
+ *
+ * Used to dynamically register interrupt during system operation.
+ */
+
+extern int grx500_bootcore_register_irq(unsigned int irq_in, unsigned int irq_out,
+                             irq_handler_t handler, unsigned long flags,
+                             const char *name, void *dev_id, vi_handler_t addr);
+
+/**
+ *      grx500_bootcore_unregister_irq - unregister interrupt
+ *      @irq_in: Incoming IRQ number for interrupt router
+ *      @irq_out: Outgoing IRQ number for interrupt router
+ *      @dev_id: Owner device ID
+ *
+ * Used to dynamically unregister interrupt during system operation.
+ */
+extern void grx500_bootcore_unregister_irq(unsigned int irq_in, unsigned int irq_out, void* dev_id);
+
+extern /*static */irqreturn_t uart_interrupt(int irq, void *dev_id);
+extern /*static */void grx500_bootcore_uart_irq(void);
+extern /*static */void grx500_bootcore_net_irq(void);
+extern /*static */void grx500_bootcore_net_g2_irq(void);
+extern void grx500_bootcore_wls_irq(void);
+extern void grx500_bootcore_enable_irq(struct irq_data *d);
+extern void grx500_bootcore_disable_irq(struct irq_data *d);
+extern void grx500_bootcore_disable_irq_all(void);
+extern void grx500_bootcore_enable_irq_all(void);
+
+extern void grx500_bootcore_gptc2_timer2_irq(void);
+extern void grx500_bootcore_gptc2_timer1_irq(void);
+extern void grx500_bootcore_mps_irq(void);
+
+//Yan
+//#ifdef CONFIG_SYNOPGMACHOST_PCI
+//extern irqreturn_t synopGMAC_intr_handler(/*s32*/int intr_num, void * dev_id/*, struct pt_regs *regs*/);
+//#endif
+
+#define IRQ_01_NUM	   			0
+#define IRQ_02_NUM	   			1
+#define IRQ_03_NUM	   			2
+#define IRQ_04_NUM	   			3
+#define IRQ_05_NUM	   			4
+#define IRQ_06_NUM	   			5
+#define IRQ_07_NUM	   			0
+#define IRQ_08_NUM	   			1
+#define IRQ_09_NUM	   			2
+#define IRQ_10_NUM	   			3
+#define IRQ_11_NUM	   			4
+#define IRQ_12_NUM	   			5
+#define IRQ_13_NUM	   			0
+#define IRQ_14_NUM	   			1
+#define IRQ_15_NUM	   			2
+#define IRQ_16_NUM	   			3
+#define IRQ_17_NUM	   			4
+#define IRQ_18_NUM	   			5
+#define IRQ_19_NUM	   			0
+#define IRQ_20_NUM	   			1
+#define IRQ_21_NUM	   			2
+#define IRQ_22_NUM	   			3
+#define IRQ_23_NUM	   			4
+#define IRQ_24_NUM	   			5
+#define IRQ_25_NUM	   			0
+#define IRQ_26_NUM	   			1
+#define IRQ_27_NUM	   			2
+#define IRQ_28_NUM	   			3
+#define IRQ_29_NUM	   			4
+#define IRQ_30_NUM	   			5
+#define IRQ_31_NUM	   			0
+
+#define GRX500_BOOTCORE_SERIAL_IRQ_IN_INDEX       28
+#define GRX500_BOOTCORE_TIMER_IRQ_IN_INDEX        28
+#define GRX500_BOOTCORE_SYNOP_ETHER_IRQ_IN_INDEX  1
+#define GRX500_BOOTCORE_SYNOP_ETHER_IRQ_GMAC2_IN_INDEX  3
+#define GRX500_BOOTCORE_WIRELESS_IRQ_IN_INDEX     9
+#define GRX500_BOOTCORE_NGIERROR_IRQ_IN_INDEX     4
+
+#define GRX500_BOOTCORE_SERIAL_IRQ_OUT_INDEX      8
+#define GRX500_BOOTCORE_TIMER_IRQ_OUT_INDEX       2
+#define GRX500_BOOTCORE_SYNOP_ETHER_IRQ_OUT_INDEX 3
+#ifndef VBG400_NO_ETH_SHARED_IRQ
+#define GRX500_BOOTCORE_SYNOP_ETHER_IRQ_GMAC2_OUT_INDEX 3
+#else
+#define GRX500_BOOTCORE_SYNOP_ETHER_IRQ_GMAC2_OUT_INDEX 4
+#endif
+#define GRX500_BOOTCORE_WIRELESS_IRQ_OUT_INDEX    5
+
+#define GRX500_BOOTCORE_GPTC2_TIMER2_IN_INDEX	1
+#define GRX500_BOOTCORE_GPTC2_TIMER2_OUT_INDEX	9
+
+#define GRX500_BOOTCORE_GPTC2_TIMER1_IN_INDEX	3
+#define GRX500_BOOTCORE_GPTC2_TIMER1_OUT_INDEX	10
+#define GRX500_BOOTCORE_MPS2_OUT_INDEX  11
+#define GRX500_BOOTCORE_NGIERROR_IRQ_OUT_INDEX  4
+
+#undef MT_EXTERN
+#undef MT_I
+
+#endif /* __GRX500_BOOTCORE_INTERRUPT_H__ */ 
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_time.h b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_time.h
new file mode 100644
index 000000000000..15bc21158777
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_time.h
@@ -0,0 +1,87 @@
+#ifndef __GRX500_BOOTCORE_TIME_H__
+#define __GRX500_BOOTCORE_TIME_H__
+
+#ifdef  MT_GLOBAL
+#define MT_EXTERN
+#define MT_I(x) x
+#else
+#define MT_EXTERN extern
+#define MT_I(x)
+#endif
+
+extern void __init setup_grx500_bootcore_timer(void);
+
+enum {
+  MT_MIPS_TIMER_0,
+  MT_MIPS_TIMER_1,
+  MT_MIPS_TIMER_2,
+  MT_MIPS_TIMER_3
+};
+
+#define MT_MIPS_TIMER_DISABLE      0
+#define MT_MIPS_TIMER_ENABLE       1
+
+#define MT_MIPS_TIMER_ONE_SHOT     0
+#define MT_MIPS_TIMER_MULT_SHOT    1
+
+#ifdef DO_CPU_STAT
+extern void grx500_bootcore_set_time_mips_timer(unsigned long timerId, unsigned long maxCount);	
+extern void grx500_bootcore_set_mode_mips_timer(unsigned long timerId, unsigned long enableTimer, unsigned long shotMode);	
+extern void grx500_bootcore_set_time_mips_prescaler(unsigned long  timerId, unsigned long  prescale);	
+#endif
+
+#undef MT_EXTERN
+#undef MT_I
+
+/*for real system undefine GRX500_BOOTCORE_SCALE_DOWN*/
+extern unsigned int system_to_cpu_multiplier;
+#ifdef CONFIG_VBG400_CHIPIT
+#define GRX500_BOOTCORE_SCALE_DOWN
+#endif
+
+#ifdef GRX500_BOOTCORE_SCALE_DOWN
+#define GRX500_BOOTCORE_SCALE_VAL 10
+#else
+#define GRX500_BOOTCORE_SCALE_VAL 1
+#endif
+
+#if 1
+#ifdef CONFIG_USE_EMULATOR
+#ifdef CONFIG_SOC_FALCONMX_BOOTCORE
+#define GRX500_BOOTCORE_SYSTEM_CLK  15000000
+#define GRX500_BOOTCORE_CPU_CLK     15000000;
+#else /* CONFIG_SOC_FALCONMX_BOOTCORE */
+#define GRX500_BOOTCORE_SYSTEM_CLK  6000000
+#define GRX500_BOOTCORE_CPU_CLK     6000000; //480000000
+#endif /* CONFIG_SOC_FALCONMX_BOOTCORE */
+#else
+#ifdef CONFIG_SOC_FALCONMX_BOOTCORE
+#define CLOCK_500M  500000000
+#define GRX500_BOOTCORE_SYSTEM_CLK CLOCK_500M
+#define GRX500_BOOTCORE_CPU_CLK    CLOCK_500M
+#else /* CONFIG_SOC_FALCONMX_BOOTCORE */
+#define CLOCK_300M  300000000
+#define GRX500_BOOTCORE_SYSTEM_CLK CLOCK_300M
+#define GRX500_BOOTCORE_CPU_CLK    CLOCK_300M
+#endif /* CONFIG_SOC_FALCONMX_BOOTCORE */
+#endif
+#else
+#define GRX500_BOOTCORE_SYSTEM_CLK  (24000000*GRX500_BOOTCORE_SCALE_VAL)
+#ifdef CONFIG_VBG400_CHIPIT
+#define GRX500_BOOTCORE_CPU_CLK     (48000000*GRX500_BOOTCORE_SCALE_VAL)
+#else
+#define GRX500_BOOTCORE_CPU_CLK     (GRX500_BOOTCORE_SYSTEM_CLK *system_to_cpu_multiplier)
+#endif
+#endif
+
+#define REG_NPU_SYS_INFO		0x60
+#define CPU_FAST_MODE		0x00080000
+
+/* Note - the timer used is GRX500_BOOTCORE, run 24000000M
+* If we use the MIPS timer, change to  GRX500_BOOTCORE_CPU_CLK
+*/
+//#define TICK_DIV (GRX500_BOOTCORE_CPU_CLK/HZ)
+#define TICK_DIV (GRX500_BOOTCORE_SYSTEM_CLK/HZ)
+
+
+#endif /* __GRX500_BOOTCORE_TIME_H__ */ 
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_uart.h b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_uart.h
new file mode 100644
index 000000000000..72294d8fa2f4
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_uart.h
@@ -0,0 +1,329 @@
+#ifndef __MT_UART_H__
+#define __MT_UART_H__
+
+#include "grx500_bootcore_chadr.h"
+#include "grx500_bootcore_time.h"
+
+#ifdef MT_GLOBAL
+   #define MT_EXTERN
+   #define MT_I(x) x
+#else
+   #define MT_EXTERN extern
+   #define MT_I(x)
+#endif
+
+#define PORT_GRX500_BOOTCORE	82
+
+struct uart_port;
+extern void grx500_bootcore_uart_tx_isr(struct uart_port *port);
+extern void grx500_bootcore_uart_rx_isr(struct uart_port *port);
+
+#define UART_BASE	 			MT_LOCAL_MIPS_BASE_ADDRESS
+
+/***********************************/
+/*       UART  register MASK       */
+/***********************************/
+
+#define WR_ADDR					0x0c
+#define GCLK_ADDR				0 
+
+#define UART_WR_MASK                 			0x000000FF
+#define UART_RD_DATA_MASK	 					0x000000FF
+#define UART_RD_PERR_MASK	 					0x00000100
+#define	UART_DIVR_MASK		 					0x00003FFF
+#define	UART_FWL_RX_MASK	 					0x0000001F
+#define	UART_FWL_TX_MASK	 					0x000003E0
+
+/*	 UART	interrupts enable    */
+#define	UART_INT_OVERRUN_IRQ_ENABLE		 		    	0x00000001
+#define	UART_INT_FRAMING_ERROR_IRQ_ENABLE 	 			0x00000002
+#define UART_INT_PARITY_ERROR_IRQ_ENABLE         		        0x00000004
+#define UART_INT_READ_COLLAPSE_BUFFER_IRQ_ENABLE 	                0x00000008
+#define UART_INT_WRITE_COLLAPSE_BUFFER_IRQ_ENABLE     	                0x00000010
+#define UART_INT_READ_FIFO_WATER_LEVEL_IRQ_ENABLE 		        0x00000020
+#define UART_INT_WRITE_FIFO_WATER_LEVEL_IRQ_ENABLE		        0x00000040
+#define UART_INT_IDLE_IRQ_ENABLE		                        0x00000080
+/*	 UART	interrupts event    */
+#define	UART_INT_OVERRUN_IRQ		 		    		0x00000100
+#define	UART_INT_FRAMING_ERROR_IRQ 	 				0x00000200
+#define UART_INT_PARITY_ERROR_IRQ	 		    		0x00000400
+#define UART_INT_READ_COLLAPSE_BUFFER_IRQ 	    		        0x00000800
+#define UART_INT_WRITE_COLLAPSE_BUFFER_IRQ     			        0x00001000
+#define UART_INT_READ_FIFO_WATER_LEVEL_IRQ 				0x00002000
+#define UART_INT_WRITE_FIFO_WATER_LEVEL_IRQ				0x00004000
+#define UART_INT_IDLE_IRQ       		        		0x00008000
+#define UART_INT_IRQ_MASK_ALL						0x0000FF00
+
+#define UART_CONTROL_TX_OUTPUT_ENABLE_MASK				0x00000001
+#define UART_CONTROL_RX_PARITY_MODE_MASK				0x00000006	
+#define UART_CONTROL_TX_PARITY_MODE_MASK				0x00000018
+#define UART_CONTROL_RX_STOP_MASK					0x00000020
+#define UART_CONTROL_TX_STOP_MASK					0x00000040
+#define UART_CONTROL_LOOPBACK_MODE_MASK			    	        0x00000080
+
+#define UART_NOISE_COUNT_MASK						0x10000000
+
+#define UART_IDLE_CNT_MAX_MASK						0x000000FF
+
+#define UART_COUNT_FIF_RX_MASK                  		        0x0000001F
+#define UART_COUNT_FIF_TX_MASK  					0x000003E0
+#define UART_INT_MODE_MASK						0x00000001
+
+/**************************************************************************************/
+
+#define UART_ENABLE_INTRPT   1
+#define UART_DISABLE_INTRPT  0
+
+#define UART_TX_OUT_ENABLE_NO      1 
+#define UART_TX_OUT_ENABLE_YES     0
+#define UART_TX_OUT_ENABLE_SHIFT   0
+
+/*=============== Baud rate ====================*/
+#define UART_RATE_9600             9600UL
+#define UART_RATE_19200            19200UL
+#define UART_RATE_38400            38400UL
+#define UART_RATE_57600            57600UL
+#define UART_RATE_115200           115200UL
+#define UART_RATE_MAX              UART_RATE_115200
+#define UART_RATE_DEFAULT          UART_RATE_9600
+
+#define UART_BAUD_RATIO_DIV     16
+
+typedef enum  _UART_BAUD{
+   UART_BAUD115200,
+   UART_BAUD38400,
+   UART_BAUD19200,
+   UART_BAUD9600
+} _UART_BAUD;
+
+/* Standard COM flags (except for COM4, because of the 8514 problem) */
+#ifdef CONFIG_SERIAL_DETECT_IRQ
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ)
+#else
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST)
+#endif
+
+#define GRX500_BOOTCORE_BASE_BAUD (GRX500_BOOTCORE_SYSTEM_CLK / UART_BAUD_RATIO_DIV)
+#define GRX500_BOOTCORE_UART_IRQ	1
+//GRX500_BOOTCORE_SERIAL_IRQ_OUT_INDEX
+#define SERIAL_PORT_DFNS			\
+	/* UART CLK   PORT IRQ     FLAGS        */			\
+	{ 0, GRX500_BOOTCORE_BASE_BAUD, UART_BASE, GRX500_BOOTCORE_UART_IRQ, STD_COM_FLAGS },	/* ttyS0 */	
+#define MT_UARTRXIDLE ()
+
+
+/*=============== Parity =======================*/
+#define UART_PARITY_NONE           0           
+#define UART_PARITY_ODD            1
+#define UART_PARITY_EVEN	   3
+#define UART_PARITY_DEFAULT        UART_PARITY_NONE
+#define UART_PARITY_RX_SHIFT	   1 
+#define UART_PARITY_TX_SHIFT	   3
+	   
+/*=============== Num of stop bits ==============*/
+#define UART_STOP_ONEBIT           0
+#define UART_STOP_TWOBIT           1
+#define UART_STOP_DEFAULT          UART_STOP_ONEBIT
+#define	UART_STOP_BIT_RX_SHIFT	   9
+#define	UART_STOP_BIT_TX_SHIFT	   10
+/*=============== Invert output siganl============*/
+#define UART_SIGNAL_NO_INVERT      0
+#define UART_SIGNAL_INVERT         1
+#define UART_SIGNAL_DEFAULT        UART_SIGNAL_NO_INVERT
+
+/*=============== Loop back on off ============*/
+#define UART_LOOPBACK_ON           1
+#define UART_LOOPBACK_OFF          0
+#define UART_LOOPBACK_SHIFT	   11
+/*=============== Reset uart ==================*/
+#define UART_RESET_YES             1
+#define UART_RESET_NO              0
+
+/*=============== Enable disable uart cloocking */
+#define UART_CLOCK_ON              1
+#define UART_CLOCK_OFF             0
+
+/*=============== Enable/Disable host interrupts from uart */
+#define UART_HOST_INTRPT_ENABLE    0
+#define UART_HOST_INTRPT_DISABLE   1
+
+
+/*****************************************************************************
+*
+*       Module's Global Variables
+*
+*****************************************************************************/
+
+
+
+/**********************************************************************
+*			   MCOR	 of UART
+***********************************************************************/
+
+#define MCOR_UART_RX_NUM_MASK 0x1F
+#define UART_MCOR_RD_RX_BYTES ((MT_UBYTE)((MT_RdReg(MT_LOCAL_MIPS_BASE_ADDRESS, REG_UART_BYTES_IN_RX_FIFO) & MCOR_UART_RX_NUM_MASK)))
+
+
+
+
+
+/* Set which type of interrupts are masked */
+
+#define MT_UART_MCOR_IDLE            UART_INT_IDLE_IRQ
+#define MT_UART_MCOR_TX_WATER_LEVEL  UART_INT_WRITE_FIFO_WATER_LEVEL_IRQ
+#define MT_UART_MCOR_RX_WATER_LEVEL  UART_INT_READ_FIFO_WATER_LEVEL_IRQ
+#define MT_UART_MCOR_TX_COLLAPS_ERR  UART_INT_WRITE_COLLAPSE_BUFFER_IRQ
+#define MT_UART_MCOR_RX_COLLAPS_ERR  UART_INT_READ_COLLAPSE_BUFFER_IRQ
+#define MT_UART_MCOR_PARITY_ERR      UART_INT_PARITY_ERROR_IRQ
+#define MT_UART_MCOR_FRAMING_ERR     UART_INT_FRAMING_ERROR_IRQ
+#define MT_UART_MCOR_OVERRUN_ERR     UART_INT_OVERRUN_IRQ
+
+
+/* Find out if UART interrupt */
+#define UART_MCRO_INTRPT_ALL_EVENTS\
+ ( MT_UART_MCOR_IDLE |\
+   MT_UART_MCOR_TX_WATER_LEVEL |\
+   MT_UART_MCOR_RX_WATER_LEVEL |\
+   MT_UART_MCOR_TX_COLLAPS_ERR |\
+   MT_UART_MCOR_RX_COLLAPS_ERR| \
+   MT_UART_MCOR_PARITY_ERR |\
+   MT_UART_MCOR_FRAMING_ERR |\
+   MT_UART_MCOR_OVERRUN_ERR )
+
+
+
+/* Define for global error in uart */
+#define MT_UART_MCOR_ALL_RX_ERR\
+  ( MT_UART_MCOR_PARITY_ERR | MT_UART_MCOR_FRAMING_ERR \
+    | MT_UART_MCOR_OVERRUN_ERR |MT_UART_MCOR_RX_COLLAPS_ERR\
+    | MT_UART_MCOR_TX_COLLAPS_ERR)
+
+#define MT_UART_MCOR_RX_DATA_READY(STATUS) \
+          (STATUS&(MT_UART_MCOR_IDLE|MT_UART_MCOR_RX_WATER_LEVEL))
+
+#define MT_UART_MCOR_IS_TX_INTRPT(STATUS)\
+          (STATUS&MT_UART_MCOR_TX_WATER_LEVEL)
+
+#define MT_UART_MCOR_IS_RX_ERR(STATUS)\
+          (STATUS&MT_UART_MCOR_ALL_RX_ERR)
+
+#define MT_UART_MCOR_IS_RX_PARITY_ERR(STATUS)\
+           (STATUS&MT_UART_MCOR_PARITY_ERR)
+
+#define MT_UART_MCOR_IS_RX_OVERRUN_ERR(STATUS)\
+           (STATUS&MT_UART_MCOR_OVERRUN_ERR)
+
+#define MT_UART_MCOR_IS_RX_FRAMING_ERR(STATUS)\
+           (STATUS&MT_UART_MCOR_FRAMING_ERR )
+
+#define MT_UART_MCOR_IS_TX_COLLAPSE_ERR(STATUS)\
+           (STATUS&MT_UART_MCOR_TX_COLLAPS_ERR)
+
+#define MT_UART_MCOR_IS_RX_COLLAPSE_ERR(STATUS)\
+           (STATUS&MT_UART_MCOR_RX_COLLAPS_ERR)
+
+
+
+#define  MT_RX_INTERRUPT   0x01
+#define  MT_TX_INTERRUPT   0x02
+#define  MT_BSY_EVENT      0x04
+/*
+*  Communications status bit flags
+* ---------------------------------
+*/
+#define UART_INBUF_EMPTY_MASK       0x01 /* Set when the input buffer is empty        */
+#define UART_INBUF_FULL_MASK        0x02 /* Set when the input buffer is full         */
+/* #define MT_INBUF_ALMOST_FULL_MASK 0x04 */ /* deleted ....                              */
+#define UART_OUTBUF_EMPTY_MASK      0x08 /* Set when the output buffer is empty       */
+#define UART_OUTBUF_FULL_MASK       0x10 /* Set when the output buffer is full        */
+#define UART_ADDRESSED_MASK         0x20 /* Set when the modem is addressed           */
+/*#define UART_GLOBAL_ADDRESSED_MASK  0x40 *//* Set when the modem is globally addressed  */
+
+#define UART_COMMS_ERROR_MASK       0x80 /* Set when a comms error is detected.       */
+
+/*
+* Communications Debugging options bit flags
+* ----------------------------------------------
+*/
+#define UART_TRANSMIT_STOPPED    0x01 /* Set when there is no more Data in Output Buffer */
+#define UART_XON_IS_ACTIVE       0x02
+#define UART_XOFF_TRIGGER        0x04
+#define UART_XOFF_IS_ACTIVE      0x08
+#define UART_FIRST_XON           0x10
+#define UART_XON_TRIGGER         0x20
+/*#define UART_NOT_USED_6          0x40*/
+/*#define UART_ALMOST_FULL_FLAG    0x80*/
+
+/*
+*  Communications error flags
+* -----------------------------
+*/
+#define MT_UART_COM_ERR_OVERRUN_MASK      0x01
+#define MT_UART_COM_ERR_BUSY_MASK         0x02
+#define MT_UART_COM_ERR_FRAMING_MASK      0x04
+#define MT_UART_COM_ERR_PARITY_MASK       0x08
+#define MT_UART_COM_ERR_READ_EMPTY_MASK   0x10
+#define MT_UART_COM_ERR_WRITE_FULL_MASK   0x20
+#define MT_UART_COM_MIPS_BUF_OVERRUN_MASK 0x40
+
+
+
+
+
+
+#define MT_COMMS_BUFFER_SIZE  20   //80  ttpcom used 16 
+#define UART_MAX_TXFIFO		  14   /*The buffer tx 16 byte*/
+
+typedef struct {
+
+           unsigned UartOverRunIntrpt:1;
+           unsigned UartFramingIntrpt:1;
+           unsigned UartParityIntrpt:1;
+           unsigned UartRXFIFOCollapseIntrpt:1;
+           unsigned UartTxFIFOCollapseIntrpt:1;
+           unsigned UartRxWaterLevelIntrpt:1;
+           unsigned UartTxWaterLevelIntrpt:1;
+           unsigned UartIdleIntrpt:1;
+
+}MT_UART_STATUS;
+
+
+typedef struct {
+           unsigned UartTxOutEnable:1;
+           unsigned UartRxParity:2;
+           unsigned UartTxParity:2;
+           unsigned UartTxStopBits:1;
+           unsigned UartRxStopBits:1;
+           unsigned UartTxLogic:1;
+           unsigned UartRxLogic:1;
+           unsigned UartLoopBack: 1;
+
+           unsigned char UartRxIdle;
+
+           unsigned UartTxWaterLevel:4;
+           unsigned UartRxWaterLevel:4;
+
+
+           MT_UART_STATUS Status;
+
+           unsigned long UartRate;
+
+           unsigned UartReset:1;
+           unsigned UartClockOnOff:1;
+           unsigned UartEnableHostIntrpt:1;
+
+           unsigned reserve1:5;
+
+           unsigned reserve2:8;        /* Align to word boundry */
+} MT_UART_CNFG;
+
+/*****************************************************************************
+*
+*   Module's Global Function Prototypes
+*
+*****************************************************************************/
+
+#undef MT_EXTERN
+#undef MT_I
+#endif /* __MT_UART_H__ */
+
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/irq.h b/arch/mips/include/asm/mach-lantiq/grx500/irq.h
new file mode 100755
index 000000000000..a2d728916f06
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/irq.h
@@ -0,0 +1,22 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2014 Lei Chuanhua <Chuanhua.lei@lantiq.com>
+ */
+
+#ifndef __LANTIQ_IRQ_H
+#define __LANTIQ_IRQ_H
+
+#define MIPS_CPU_IRQ_BASE	0
+#define MIPS_GIC_IRQ_BASE	(MIPS_CPU_IRQ_BASE + 8)
+
+#define GPIO0_IRQ_BASE		271
+#define GPIO1_IRQ_BASE		303
+
+#define NR_IRQS 527
+
+#include_next <irq.h>
+
+#endif
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/lantiq_soc.h b/arch/mips/include/asm/mach-lantiq/grx500/lantiq_soc.h
new file mode 100755
index 000000000000..a1f4da6de3ac
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/lantiq_soc.h
@@ -0,0 +1,95 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ *  Copyright (C) 2014 Lei Chuanhua <Chuanhua.lei@lantiq.com>
+ *  Copyright (C) 2017 Intel Corporation.
+ */
+
+#ifndef _LTQ_SOC_H
+#define _LTQ_SOC_H
+
+#include <lantiq.h>
+
+/* GRX500 family chipid */
+#define SOC_ID_GRX5838		0x020
+#define SOC_ID_GRX5828		0x021
+#define SOC_ID_GRX5628		0x022
+#define SOC_ID_GRX5821		0x023
+#define SOC_ID_GRX5831		0x024
+#define SOC_ID_GRX58312		0x025
+#define SOC_ID_GRX3506		0x026
+#define SOC_ID_GRX3508		0x028
+#define SOC_ID_IRX200		0x02F
+
+/* FalconMX family chipid */
+#define SOC_ID_FMX_FIBERPHY	0x002 /* HGU */
+#define SOC_ID_FMX_SFU		0x003
+#define SOC_ID_FMX_SFP		0x004
+#define SOC_ID_FMX_DPU		0x005
+
+/* SoC Types */
+#define SOC_TYPE_GRX500		0x09
+#define SOC_TYPE_FALCONMX	0x0a
+
+static inline int ltq_is_grx500(void)
+{
+	return (ltq_get_soc_type() == SOC_TYPE_GRX500);
+}
+
+static inline int ltq_is_falconmx(void)
+{
+	return (ltq_get_soc_type() == SOC_TYPE_FALCONMX);
+}
+
+/* BOOT_SEL - find what boot media we have */
+#define BS_EXT_ROM		0x0
+#define BS_FLASH		0x1
+#define BS_MII0			0x2
+#define BS_PCI			0x3
+#define BS_UART1		0x4
+#define BS_SPI			0x5
+#define BS_NAND			0x6
+#define BS_RMII0		0x7
+
+/*
+ * during early_printk no ioremap is possible
+ * lets use KSEG1 instead
+ */
+#define LTQ_ASC0_BASE_ADDR	0x16600000
+#define LTQ_EARLY_ASC		KSEG1ADDR(LTQ_ASC0_BASE_ADDR)
+
+/* register access macros for EBU and CGU */
+#define ltq_ebu_w32(x, y)	ltq_w32((x), ltq_ebu_membase + (y))
+#define ltq_ebu_r32(x)		ltq_r32(ltq_ebu_membase + (x))
+#define ltq_ebu_w32_mask(x, y, z) \
+	ltq_w32_mask(x, y, ltq_ebu_membase + (z))
+
+	/* helpers used to access the cgu and xbar register */
+#define ltq_cgu_w32(x, y)	ltq_w32((x), ltq_cgu_membase + (y))
+#define ltq_cgu_r32(x)		ltq_r32(ltq_cgu_membase + (x))
+extern __iomem void *ltq_cgu_membase;
+
+/* EBU - external bus unit */
+#define LTQ_EBU_BUSCON0		0x0060
+#define LTQ_EBU_PCC_CON		0x0090
+#define LTQ_EBU_PCC_IEN		0x00A4
+#define LTQ_EBU_PCC_ISTAT	0x00A0
+#define LTQ_EBU_BUSCON1		0x0064
+#define LTQ_EBU_ADDRSEL1	0x0024
+#define EBU_WRDIS		0x80000000
+
+/* WDT */
+#define LTQ_RST_CAUSE_WDTRST	0x20
+
+/* MPS - multi processor unit (voice) */
+#define LTQ_MPS_BASE_ADDR	(KSEG1 + 0x1F107000)
+#define LTQ_MPS_CHIPID		((u32 __iomem *)(LTQ_MPS_BASE_ADDR + 0x0344))
+#define LTQ_FUSE_ID_CFG		((u32 __iomem *)(LTQ_MPS_BASE_ADDR + 0x0350))
+
+/* allow the ethernet driver to load a flash mapped mac addr */
+const u8 *ltq_get_eth_mac(void);
+
+#endif /* _LTQ_SOC_H */
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/lantiq_ssc.h b/arch/mips/include/asm/mach-lantiq/grx500/lantiq_ssc.h
new file mode 100755
index 000000000000..6a9b4806c61f
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/lantiq_ssc.h
@@ -0,0 +1,286 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2009~2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+
+#ifndef LANTIQ_SSC_H
+#define LANTIQ_SSC_H
+
+/*!
+ * \defgroup IFX_SSC SSC bus driver module
+ * \brief UEIP Project - SSC bus driver module, support all CPEs.
+ */
+
+/*!
+ * \defgroup IFX_SSC_DEFINITIONS Definition and structions
+ * \ingroup IFX_SSC
+ * \brief definitions for ifx ssc driver
+ */
+
+/*!
+ * \defgroup IFX_SSC_FUNCTIONS external APIs
+ * \ingroup IFX_SSC
+ * \brief IFX ssc external driver functions
+ */
+
+/*!
+ * \defgroup IFX_SSC_INTERNAL Internal functions
+ * \ingroup IFX_SSC
+ * \brief IFX ssc internal driver functions
+ */
+
+/*!
+ * \file ifx_ssc.h
+ * \ingroup IFX_SSC
+ * \brief header file for SSC bus driver external interface
+ */
+
+/*!
+ * \addtogroup IFX_SSC_DEFINITIONS
+ */
+/* @{ */
+/*! \enum  IFX_SSC_PRIO_t
+ *   \brief Set communication priority of SSC connection
+ *
+ *   Three priority levels are defined. Low-level priority queue used for
+ *   applications like FLASH driver (ifx_ssc_prio_low). normal priority
+ *   queue used for applications like display (ifx_ssc_prio_mid).
+ *   High priority queue used for applications like RTP packet transfer
+ *   (ifx_ssc_prio_high).
+ */
+typedef enum {
+	IFX_SSC_PRIO_LOW = 0,  /*!< Low Priority queue.
+				*  For FLASH driver, etc.
+				*/
+	IFX_SSC_PRIO_MID,      /*!< Normal Priority queue.
+				*  For LCD, display data, etc.
+				*/
+	IFX_SSC_PRIO_HIGH,     /*!< High priority queue.
+				*  Ror RTP voice, etc.
+				*/
+	IFX_SSC_PRIO_ASYNC,    /*!< Tasklet priority (This is the highest
+				*  supported priority) For this priority
+				*  level only the asynchronous API set of
+				*  the SSC driver can be called. These
+				*  functions stay unblocked and a callback
+				*  function is called when the request is
+				*  processed. This allows that the APIs are
+				*  called from tasklet level. The callback
+				*  function is always called on tasklet
+				*  level
+				*/
+} IFX_SSC_PRIO_t;
+
+#define IFX_SSC_PRIO_MAX IFX_SSC_PRIO_ASYNC
+
+/*! \enum  IFX_SSC_MODE_t
+ *  \brief Defines the Ssc hardware mode settings supported
+ *
+ *  Because there is no official specification, what exactly SPI is and what
+ *  not, it is necessary to consult the data sheets of the components one
+ *  wants to use. Important are the permitted clock frequencies and the type
+ *  of valid transitions. There are no general rules for transitions where
+ *  data should be latched. Although not specified by Motorola, in practice
+ *  four modes are used. These four modes are the combinations of CPOL and
+ *  CPHA. In table 1, the four modes are listed.If the phase of the clock
+ *  is zero, i.e. CPHA = 0, data is latched at the rising edge of the clock
+ *  with CPOL = 0, and at the falling edge of the clock with CPOL = 1. If
+ *  CPHA = 1, the polarities are reversed. CPOL = 0 means falling edge,
+ *  CPOL = 1 rising edge.The micro controllers from Motorola allow the
+ *  polarity and the phase of the clock to be adjusted. A positive polarity
+ *  results in latching data at the rising edge of the clock. However data
+ *  is put on the data line already at the falling edge in order to stabilize.
+ *  Most peripherals which can only be slaves, work with this configuration.
+ *  If it should become necessary to use the other polarity, transitions are
+ *  reversed.
+ */
+typedef enum {
+	IFX_SSC_MODE_0 = 0, /*!< CPOL=0,CPHA=0 */
+	IFX_SSC_MODE_1, /*!< CPOL=0,CPHA=1 */
+	IFX_SSC_MODE_2, /*!< CPOL=1,CPHA=0 */
+	IFX_SSC_MODE_3, /*!< CPOL=1,CPHA=1 */
+	IFX_SSC_MODE_UNKNOWN, /*!< Unknown SPI mode */
+} IFX_SSC_MODE_t;
+
+/*! \enum  IFX_SSC_HANDL_TYPE_t
+ *  \brief Defines the SPI handler type supported
+ */
+typedef enum {
+	IFX_SSC_HANDL_TYPE_SYNC = 0,   /*!< Only SYNC handler which be used
+					* by sync application
+					*/
+	IFX_SSC_HANDL_TYPE_ASYNC,      /*!< Only ASYNC handler which be used
+					* by async application
+					*/
+} IFX_SSC_HANDL_TYPE_t;
+
+/*! \enum  IFX_SSC_DLX_t
+ *  \brief Set communication duplex mode of SSC connection
+ *
+ *  The duplex mode is used to notify SSC bus driver by SSC device driver
+ *  about what kind of communication mode should be used. Which duplex mode
+ *  will be used depends on the SSC device driver instead of SSC bus driver.
+ */
+typedef enum {
+	IFX_SSC_HALF_DUPLEX = 0,/*!< Half Duplex. Interface is used in half
+				 *   duplex when calling \ref ifx_sscTxRx or
+				 *   \ref ifx_sscAsyncTxRx. The TX path is
+				 *   servered before the RX path.
+				 */
+	IFX_SSC_FULL_DUPLEX,	/*!< Full Duplex. Interface is used in full
+				 *   duplex when calling \ref ifx_sscTxRx or
+				 *   \ref ifx_sscAsyncTxRx. The TX-and RX-
+				 *   path is servered simultaneously.
+				 */
+} IFX_SSC_DLX_t;
+
+/*!< \typedef IFX_CS_DATA
+ *   \brief Definition of device specific data for chip select
+ */
+typedef int IFX_CS_DATA;
+enum {
+	IFX_SSC_CS_ON = 0,	IFX_SSC_CS_OFF,
+};
+
+#define IFX_SSC_WHBGPOSTAT_OUT0_POS  0
+#define IFX_SSC_WHBGPOSTAT_OUT1_POS  1
+#define IFX_SSC_WHBGPOSTAT_OUT2_POS  2
+#define IFX_SSC_WHBGPOSTAT_OUT3_POS  3
+#define IFX_SSC_WHBGPOSTAT_OUT4_POS  4
+#define IFX_SSC_WHBGPOSTAT_OUT5_POS  5
+#define IFX_SSC_WHBGPOSTAT_OUT6_POS  6
+#define IFX_SSC_WHBGPOSTAT_OUT7_POS  7
+
+/*! \typedef IFX_SSC_CS_CB_t
+ *  \brief Chip Select Callback function type declaration
+ *
+ *   csq csq=0, i.e. CS low (active). csq=1, i.e.CS high (idle).
+ *   cs_data This is the device number in case if more than one device is using
+ *   the same registered driver. e.g. two VINETICs, each with it's own CS.
+ */
+typedef int (*IFX_SSC_CS_CB_t) (u32 csq, IFX_CS_DATA cs_data);
+
+/*! typedef ifx_ssc_async_fkt_cb_t
+ *  \brief Callback definition for asynchronous SSC API calls. This callback is
+ *  called by the SSC driver on tasklet level after the request is completed or
+ *  exit with an error.
+ *
+ *  \param handle Funktion handle that provided for callback registration
+ *  during the SSC asynchronous API call.
+ *  \param retvalue This return value describe if the asynchronous request
+ *  identified an error and worked successfully.
+ */
+typedef void (*ifx_ssc_async_fkt_cb_t) (int handle, int retvalue);
+
+/*! typedef IFX_SSC_ASYNC_CALLBACK_t
+ *  \brief Parameter to specify the asynchronous callback. It is called
+ *  by the SSC tasklet after the requested transmission or locking is done.
+ */
+typedef struct {
+	ifx_ssc_async_fkt_cb_t pFunction;/*!< Callback function pointer,
+					  * called in the SSC tasklet when
+					  *the requested command is executed
+					  */
+	int functionHandle;	/*!< Callback function handle. This parameter
+				 *   is transparently given to the callback
+				 *   function without any modification by the
+				 *   SSC driver
+				 */
+} IFX_SSC_ASYNC_CALLBACK_t;
+
+/*! \brief Parameter structure used to configure an SSC connection "ConnId". */
+typedef struct {
+	IFX_SSC_MODE_t ssc_mode; /*!< Defines the hardware setup mode of
+				  *   the SSC
+				  */
+	IFX_SSC_PRIO_t ssc_prio; /*!< The communication priority of SSC
+				  *   connection. Three priority levels
+				  *   are defined. Low-level priority
+				  *   queue used for applications like
+				  *   FLASH driver (ifx_ssc_prio_low).
+				  *   Normal priority queue used for
+				  *   applications like display
+				  *   (ifx_ssc_prio_mid). High priority
+				  *   queue used for applications like RTP
+				  *   packet transfer (ifx_ssc_prio_high).
+				  *   The here defined SSC priority
+				  *   corresponds to the priority the SSC
+				  *   driver application and should be set
+				  *   just for information when the driver
+				  *   is registered by the application.
+				  */
+	int baudrate;		/*!< Baudrate used for the ConnId.
+				 * This parameter can be later be modified
+				 * by a call of ifx_sscSetBaud
+				 */
+	int fragSize;		/*!< All transmitted and received packets
+				 *   should be fragmented in this fragment
+				 *   size. Size given in Bytes. A maximum
+				 *   of 1024 Bytes is allowed. If the client
+				 *   uses a bigger values here, SSC returns
+				 *   with error. The client has to take care
+				 *   of the fragmentation
+				 */
+	int maxFIFOSize;	/*!< Maximum packet size in FIFO mode.
+				 * All transmitted and received packets are
+				 * transmitted in DMA mode if the packet
+				 * size is greater than this value. A value
+				 * of 148 is recommended at first.Size given
+				 * in Bytes
+				 */
+	IFX_SSC_CS_CB_t csset_cb;	/*!< Function Callback called by SSC
+					 *   driver when it starts/stops to
+					 *   receive or transmit
+					 */
+	IFX_CS_DATA cs_data;	/*!< Parameter used for the function
+				 *   call of "csSet_cb".
+				 */
+	IFX_SSC_DLX_t duplex_mode;	/*!< Duplex Mode Selector. Connection
+					 * used the SSC interface either in
+					 * half- or full- duplex mode.
+					 */
+} IFX_SSC_CONFIGURE_t;
+
+/*! \typedef IFX_SSC_HANDLE
+ *  \brief Definition of the connection handle
+ *
+ *   as it is used by the client kernel module that use the SSC driver
+ *   Inside of the SSC driver, this handle is mapped to an internal
+ *   structure that contains the connection specific parameter
+ *   (e.g. Baudrate, Chipselect Callbacks, etc.).
+ */
+typedef void *IFX_SSC_HANDLE;
+
+/* @} */
+int ifx_ssc_cs_low(u32 pin);
+int ifx_ssc_cs_high(u32 pin);
+int ifx_ssc_cs_low_port1(u32 pin);
+int ifx_ssc_cs_high_port1(u32 pin);
+int ifx_sscLock(IFX_SSC_HANDLE handler);
+int ifx_sscUnlock(IFX_SSC_HANDLE handler);
+int ifx_sscSetBaud(IFX_SSC_HANDLE handler, unsigned int baud);
+int ifx_sscTxRx(IFX_SSC_HANDLE handler, char *tx_buf, u32 tx_len,
+		char *rx_buf, u32 rx_len);
+int ifx_sscRx(IFX_SSC_HANDLE handler, char *rx_buf, u32 rx_len);
+int ifx_sscTx(IFX_SSC_HANDLE handler, char *tx_buf, u32 tx_len);
+IFX_SSC_HANDLE ifx_sscAllocConnection(char *dev_name,
+				      IFX_SSC_CONFIGURE_t *connid);
+int ifx_sscFreeConnection(IFX_SSC_HANDLE handler);
+int ifx_sscAsyncTxRx(IFX_SSC_HANDLE handler,
+		     IFX_SSC_ASYNC_CALLBACK_t *pCallback,
+		     char *txbuf, int txsize, char *rxbuf, int rxsize);
+int ifx_sscAsyncTx(IFX_SSC_HANDLE handler,
+		   IFX_SSC_ASYNC_CALLBACK_t *pCallback,
+		   char *txbuf, int txsize);
+int ifx_sscAsyncRx(IFX_SSC_HANDLE handler,
+		   IFX_SSC_ASYNC_CALLBACK_t *pCallback,
+		   char *rxbuf, int rxsize);
+int ifx_sscAsyncLock(IFX_SSC_HANDLE handler,
+		     IFX_SSC_ASYNC_CALLBACK_t *pCallback);
+int ifx_sscAsyncUnLock(IFX_SSC_HANDLE handler);
+
+#endif /* LANTIQ_SSC_H */
+
