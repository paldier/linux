From 9acad23a77887d559bfed50af3e195fae8b7137b Mon Sep 17 00:00:00 2001
From: Peter Harliman Liem <peter.harliman.liem@intel.com>
Date: Wed, 26 Sep 2018 19:51:25 +0800
Subject: [PATCH] DRVLIB_SW-846 - Add prx300 specific phy_connect function in
 ltq_eth_drv

PRX300 MDIO bus is owned by xgmac. Therefore what we need to
do is simply get the phy_device (via DT) and connect,
without the need to scan MDIO bus.
---
 drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c | 54 +++++++++++++++++++-----
 drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.h |  1 +
 2 files changed, 45 insertions(+), 10 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
index 07f3fc17d116..e86c6e503294 100644
--- a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
+++ b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
@@ -637,8 +637,8 @@ static int ltq_eth_init(struct net_device *dev)
 	for (i = 0; i < priv->num_port; i++) {
 		if (of_phy_is_fixed_link(priv->port[i].phy_node))
 			pr_debug("phy is fixed-link\n");
-		else if (xrx500_mdio_probe(dev, &priv->port[i]))
-			pr_warn("xrx500-mdio: probing phy of port %d failed\n",
+		else if (g_soc_data.phy_connect_func(dev, &priv->port[i]))
+			pr_warn("connect phy of port %d failed\n",
 				priv->port[i].num);
 		dev->ethtool_ops = &ethtool_ops;
 	}
@@ -1540,6 +1540,46 @@ static void xrx500_mdio_link(struct net_device *dev)
 	}
 }
 
+/* PRX300 MDIO bus interface is owned by xgmac. The PHY device therefore do not
+ * need to be probed here, as it is done by xgmac. What we need to do is simply
+ * connect the PHY.
+ */
+static int prx300_phy_connect(struct net_device *dev, struct xrx500_port *port)
+{
+	struct phy_device *phydev = NULL;
+	struct ltq_eth_priv *priv = NULL;
+
+	priv = netdev_priv(dev);
+
+	phydev = of_phy_connect(dev, port->phy_node, &xrx500_mdio_link,
+				0, port->phy_if);
+	if (!phydev) {
+		netdev_err(dev, "Unable to find phydev\n");
+		return -ENODEV;
+	}
+
+	phydev->supported &= (SUPPORTED_10baseT_Half
+			      | SUPPORTED_10baseT_Full
+			      | SUPPORTED_100baseT_Half
+			      | SUPPORTED_100baseT_Full
+			      | SUPPORTED_1000baseT_Half
+			      | SUPPORTED_1000baseT_Full
+			      | SUPPORTED_Autoneg
+			      | SUPPORTED_MII
+			      | SUPPORTED_TP);
+	phydev->advertising = phydev->supported;
+	port->phydev = phydev;
+
+	pr_info("%s: attached PHY [%s] (phy_addr=%s, irq=%d)\n",
+		dev->name, phydev->drv->name,
+		phydev_name(phydev), phydev->irq);
+
+	phy_read_status(phydev);
+	phy_start_aneg(phydev);
+
+	return 0;
+}
+
 static int xrx500_mdio_probe(struct net_device *dev, struct xrx500_port *port)
 {
 	struct phy_device *phydev = NULL;
@@ -1929,14 +1969,6 @@ static int ltq_eth_drv_init(struct platform_device *pdev)
 			if (xrx500_of_mdio_pae(&xrx500_hw, mdio_np))
 				dev_err(&pdev->dev, "mdio probe of PAE failed\n");
 
-	} else {
-		mdio_np = of_find_compatible_node(node, NULL,
-						  "intel,falconmx-mdio");
-
-		if (mdio_np)
-			pr_debug("The mdio bus intel,falconmx-mdio found.\n");
-		else
-			pr_err("No MDIO bus defined!\n");
 	}
 
 	bus = xrx500_hw.mii_bus;
@@ -2125,12 +2157,14 @@ static const struct ltq_net_soc_data xrx500_net_data = {
 	.need_defer = true,
 	.hw_checksum = true,
 	.queue_num = 1,
+	.phy_connect_func = &xrx500_mdio_probe,
 };
 
 static const struct ltq_net_soc_data falconmx_net_data = {
 	.need_defer = false,
 	.hw_checksum = false,
 	.queue_num = 8,
+	.phy_connect_func = &prx300_phy_connect,
 };
 
 static const struct of_device_id ltq_eth_drv_match[] = {
diff --git a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.h b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.h
index 87101d873df8..518693c9edf2 100644
--- a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.h
+++ b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.h
@@ -122,5 +122,6 @@ struct ltq_net_soc_data {
 	bool need_defer;
 	bool hw_checksum;
 	unsigned int queue_num;
+	int (*phy_connect_func)(struct net_device *, struct xrx500_port *);
 };
 #endif /* _LANTIQ_ETH_DRV_H_ */
