From cccd3f461679b8ccb431df3525237df1c770e345 Mon Sep 17 00:00:00 2001
From: CI Assistant <chdauto@intel.com>
Date: Wed, 12 Feb 2020 12:33:22 +0200
Subject: [PATCH] Merge pull request #1651 in SW_UGW/linux from
 feature/UGW_SW-46634-clone-feature-request-speedtest-downstream-46mbps-is-70-lower-than-the
 to 8.4.1

* commit '22d8f0d4c5a0b935c5a09671dfdac713abc6de28':
  UGW_SW-46634: umt port remaining time check
---
 drivers/dma/ltq_hwmcpy.h     |  3 ++-
 drivers/dma/ltq_umt_expand.c | 39 ++++++++++++++++++++++++---------------
 2 files changed, 26 insertions(+), 16 deletions(-)

diff --git a/drivers/dma/ltq_hwmcpy.h b/drivers/dma/ltq_hwmcpy.h
index 83d1ab5718a7..421285f9761f 100644
--- a/drivers/dma/ltq_hwmcpy.h
+++ b/drivers/dma/ltq_hwmcpy.h
@@ -109,10 +109,11 @@ struct umt_port {
 	u32 dma_cid; /* DMA Chan ID */
 	enum umt_status suspend;
 	spinlock_t umt_port_lock;
-#ifdef CONFIG_LTQ_UMT_SW_MODE
+#if IS_ENABLED(CONFIG_LTQ_UMT_SW_MODE)
 	u32 dq_idx;
 	u32 umt_ep_dst;
 	u32 umtid_map_cbmid;
+	u32 umt_remaining_time;
 #endif
 };
 
diff --git a/drivers/dma/ltq_umt_expand.c b/drivers/dma/ltq_umt_expand.c
index f668c424d315..92cac25deb7b 100644
--- a/drivers/dma/ltq_umt_expand.c
+++ b/drivers/dma/ltq_umt_expand.c
@@ -37,7 +37,7 @@
 #include <linux/ltq_hwmcpy.h>
 #include "ltq_hwmcpy.h"
 
-#ifdef CONFIG_LTQ_UMT_SW_MODE
+#if IS_ENABLED(CONFIG_LTQ_UMT_SW_MODE)
 #include <clocksource/intel-gptc-timer.h>
 #include "net/lantiq_cbm_api.h"
 
@@ -233,6 +233,9 @@ int ltq_umt_set_period(u32 umt_id, u32 ep_id, u32 period)
 
 	if (port->umt_period != period) {
 		port->umt_period = period;
+		#if IS_ENABLED(CONFIG_LTQ_UMT_SW_MODE)
+		port->umt_remaining_time = period;
+		#endif
 		umt_set_period(umt_id, port->umt_period);
 	}
 	spin_unlock_bh(&port->umt_port_lock);
@@ -315,9 +318,9 @@ int ltq_umt_set_mode(u32 umt_id, u32 ep_id, struct umt_set_mode *p_umt_mode)
 	port->umt_period = period;
 	port->status = (enum umt_status)enable;
 
-#ifdef CONFIG_LTQ_UMT_SW_MODE
-	if (IS_ENABLED(CONFIG_LTQ_UMT_SW_MODE))
-		port->umt_ep_dst = umt_ep_dst;
+#if IS_ENABLED(CONFIG_LTQ_UMT_SW_MODE)
+	port->umt_ep_dst = umt_ep_dst;
+	port->umt_remaining_time = port->umt_period;
 #endif
 	umt_set_mode(umt_id, port->umt_mode);
 	umt_set_msgmode(umt_id, port->msg_mode);
@@ -484,7 +487,7 @@ int ltq_umt_request(u32 ep_id, u32 cbm_pid,
 	*umt_id = port->umt_pid;
 	spin_unlock_bh(&port->umt_port_lock);
 
-#ifdef CONFIG_LTQ_UMT_SW_MODE
+#if IS_ENABLED(CONFIG_LTQ_UMT_SW_MODE)
 	{
 	u32 flag = 0, cbm_pid_l = 0;
 	int ret = 0;
@@ -571,7 +574,8 @@ int ltq_umt_release(u32 umt_id, u32 ep_id)
 	port->umt_dst = 0;
 	port->umt_period = 0;
 	port->status = UMT_DISABLE;
-#ifdef CONFIG_LTQ_UMT_SW_MODE
+#if IS_ENABLED(CONFIG_LTQ_UMT_SW_MODE)
+	port->umt_remaining_time = 0;
 	port->umt_ep_dst = 0;
 	port->umtid_map_cbmid = 0;
 #endif
@@ -601,7 +605,7 @@ static void umt_port_init(struct mcpy_umt *pumt,
 	port->ep_id = 0;
 	port->status = UMT_DISABLE;
 	spin_lock_init(&port->umt_port_lock);
-#ifdef CONFIG_LTQ_UMT_SW_MODE
+#if IS_ENABLED(CONFIG_LTQ_UMT_SW_MODE)
 	port->dq_idx = 0;
 	port->umt_ep_dst = 0;
 	port->umtid_map_cbmid = 0;
@@ -748,7 +752,7 @@ static const struct file_operations mcpy_umt_proc_fops = {
 	.release        = seq_release,
 };
 
-#ifdef CONFIG_LTQ_UMT_SW_MODE
+#if IS_ENABLED(CONFIG_LTQ_UMT_SW_MODE)
 #define MICROSEC_TO_SEC(x) (1000000 / (x))
 static u32 jiffies1;
 
@@ -790,8 +794,8 @@ static int umt_tc_info_read_proc(struct seq_file *s, void *v)
 		port = &pumt->ports[i];
 		seq_printf(s, "Packets to be dequeued: %d  cbm id %d\n",
 			   g_tot_dq_cnt[i], port->umtid_map_cbmid);
-		seq_printf(s, "thread info: umt dst: 0x%x, interval: 0x%x, en: %d, dq_idx: %u, ep_dst:0x%x\n",
-			   port->umt_dst, g_umt_interval, port->status,
+		seq_printf(s, "thread info: umt dst: 0x%x, remaining_time: 0x%x, en: %d, dq_idx: %u, ep_dst:0x%x\n",
+			   port->umt_dst, port->umt_remaining_time, port->status,
 			   port->dq_idx, port->umt_ep_dst);
 	}
 	return 0;
@@ -876,7 +880,7 @@ static int umt_proc_init(struct mcpy_umt *pumt)
 	if (!entry)
 		goto err1;
 
-#ifdef CONFIG_LTQ_UMT_SW_MODE
+#if IS_ENABLED(CONFIG_LTQ_UMT_SW_MODE)
 	entry = proc_create_data("umt_tc_info", 0x0, pumt->proc,
 				 &umt_tc_info_proc_fops, pumt);
 	if (!entry)
@@ -888,7 +892,7 @@ static int umt_proc_init(struct mcpy_umt *pumt)
 #endif
 	return 0;
 
-#ifdef CONFIG_LTQ_UMT_SW_MODE
+#if IS_ENABLED(CONFIG_LTQ_UMT_SW_MODE)
 err3:
 	remove_proc_entry("umt_tc_info", pumt->ctrl->proc);
 err2:
@@ -900,7 +904,7 @@ static int umt_proc_init(struct mcpy_umt *pumt)
 	return -1;
 }
 
-#ifdef CONFIG_LTQ_UMT_SW_MODE
+#if IS_ENABLED(CONFIG_LTQ_UMT_SW_MODE)
 void umt_callback_fn(void *param)
 {
 	u32 dq_cnt, dq_ptr;
@@ -927,6 +931,11 @@ void umt_callback_fn(void *param)
 		umt_ep_dst_local = port->umt_ep_dst;
 		if (port->status == UMT_ENABLE &&
 		    umt_ep_dst_local && port->umtid_map_cbmid) {
+			if (port->umt_remaining_time > g_umt_interval) {
+				port->umt_remaining_time -= g_umt_interval;
+				continue;
+			}
+			port->umt_remaining_time = port->umt_period;
 			ret = cbm_dequeue_dma_port_stats_get(port->umtid_map_cbmid, &dq_ptr, 0);
 			if (ret != 0)
 				continue;
@@ -975,7 +984,7 @@ int umt_init(struct mcpy_ctrl *pctrl)
 	struct device_node *node = pctrl->dev->of_node;
 	struct mcpy_umt *pumt;
 	int i;
-#ifdef CONFIG_LTQ_UMT_SW_MODE
+#if IS_ENABLED(CONFIG_LTQ_UMT_SW_MODE)
 	struct gptc_ht_yield param;
 #endif
 
@@ -1000,7 +1009,7 @@ int umt_init(struct mcpy_ctrl *pctrl)
 	umt_proc_init(pumt);
 	pumt->status = UMT_ENABLE;
 
-#ifdef CONFIG_LTQ_UMT_SW_MODE
+#if IS_ENABLED(CONFIG_LTQ_UMT_SW_MODE)
 	param.yield_pin = LTQ_UMT_SW_YIELD_PIN;
 	param.interval = g_umt_interval;
 #ifdef CONFIG_LTQ_UMT_518_FW_SG
