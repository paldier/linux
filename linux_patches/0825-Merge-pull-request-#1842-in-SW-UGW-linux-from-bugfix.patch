From 699563aeed92fe5ddc7f9c2f27b3598c8c74bd66 Mon Sep 17 00:00:00 2001
From: CI Assistant <chdauto@intel.com>
Date: Mon, 9 Mar 2020 21:52:52 +0200
Subject: [PATCH] Merge pull request #1842 in SW_UGW/linux from
 bugfix/UGW_SW-43310-route-meter-alloc-fix-8.4.1 to 8.4.1

* commit '89818490b5c1689f7de9cf355934faf33acbd41d':
  UGW_SW-48150: GSWAPI: Fix for read meter rmon counters
---
 .../net/ethernet/lantiq/switch-api/gsw_flow_core.c | 120 +++++++++++++--------
 include/net/switch_api/lantiq_gsw.h                |   3 +
 2 files changed, 79 insertions(+), 44 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
index dbdf80988311..cbc6bda131f5 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
@@ -2374,6 +2374,53 @@ static void get_vlan_sw_table(void *cdev, u8 pcindex,
 }
 #endif /* CONFIG_LTQ_VLAN */
 
+static GSW_return_t gsw_rmon_table_config(void *cdev, GSW_RMON_mode_t *parm)
+{
+	u32  bm_ram_ctrl = 0;
+	int ret;
+
+	switch (parm->eRmonType) {
+	case GSW_RMON_METER_TYPE:
+			FILL_CTRL_REG(bm_ram_ctrl, BM_RAM_CTRL_ADDR_SHIFT,
+				      GSW_RMON_METER);
+		break;
+	case GSW_RMON_IF_TYPE:
+			FILL_CTRL_REG(bm_ram_ctrl, BM_RAM_CTRL_ADDR_SHIFT,
+				      GSW_RMON_IF);
+		break;
+	case GSW_RMON_ROUTE_TYPE:
+			FILL_CTRL_REG(bm_ram_ctrl, BM_RAM_CTRL_ADDR_SHIFT,
+				      GSW_RMON_ROUTE);
+		break;
+	case GSW_RMON_PMAC_TYPE:
+			FILL_CTRL_REG(bm_ram_ctrl, BM_RAM_CTRL_ADDR_SHIFT,
+				      GSW_RMON_PMACIG);
+		break;
+	default:
+		return GSW_statusErr;
+	}
+	/* Set RAM access busy */
+	FILL_CTRL_REG(bm_ram_ctrl,
+		      BM_RAM_CTRL_BAS_SHIFT, 1);
+	gsw_w32_raw(cdev, BM_RAM_CTRL_REG_OFFSET,
+		    bm_ram_ctrl);
+	/* Set initiate a RAM access */
+	FILL_CTRL_REG(bm_ram_ctrl,
+		      BM_RAM_CTRL_BAS_SHIFT, 0);
+	asm("SYNC");
+	/* Set RAM access busy */
+	FILL_CTRL_REG(bm_ram_ctrl,
+		      BM_RAM_CTRL_BAS_SHIFT, 1);
+	gsw_w32_raw(cdev, BM_RAM_CTRL_REG_OFFSET,
+		    bm_ram_ctrl);
+	/* Wait until RAM is ready to Read */
+	ret = CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET,
+			 BM_RAM_CTRL_BAS_SHIFT,
+			 BM_RAM_CTRL_BAS_SIZE,
+			 RETURN_FROM_FUNCTION);
+
+	return ret;
+}
 
 static void get_gsw_hw_cap(void *cdev)
 {
@@ -14880,12 +14927,17 @@ GSW_return_t GSW_RMON_Mode_Set(void *cdev, GSW_RMON_mode_t *parm)
 static GSW_return_t GSW_RMON_Meter_Get_Legacy(void *cdev, GSW_RMON_Meter_cnt_t *parm)
 {
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	GSW_RMON_mode_t param;
+	int ret;
 
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return GSW_statusErr;
 	}
 
+	memset(&param, 0, sizeof(GSW_RMON_mode_t));
+	param.eRmonType = GSW_RMON_METER_TYPE;
+
 	if ((gswdev->gipver == LTQ_GSWIP_3_0) && (gswdev->sdev == LTQ_FLOW_DEV_INT_R)) {
 		u8 index, addr;
 		u32 data, data0, data1;
@@ -14913,16 +14965,9 @@ static GSW_return_t GSW_RMON_Meter_Get_Legacy(void *cdev, GSW_RMON_Meter_cnt_t *
 			loc = 0;
 
 			for (j = 0; j < MAX_READ; j++) {
-#ifndef CONFIG_X86_INTEL_CE2700
-				/*suresh*/
-//				ltq_w32(0x8019, gswr_bm_addr);
-//				ltq_w32(0x0019, gswr_bm_addr);
-				//			asm("SYNC");
-//				ltq_w32(0x8019, gswr_bm_addr);
-#endif
-				CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET, BM_RAM_CTRL_BAS_SHIFT,
-					   BM_RAM_CTRL_BAS_SIZE, RETURN_FROM_FUNCTION);
-
+				ret = gsw_rmon_table_config(cdev, &param);
+				if (ret == GSW_statusErr)
+					continue;
 				for (i = 0; i < 4; i++) {
 					gsw_r32(cdev, BM_RAM_VAL_0_VAL0_OFFSET,
 						BM_RAM_VAL_0_VAL0_SHIFT,
@@ -15382,13 +15427,17 @@ GSW_return_t GSW_RMON_Redirect_Get(void *cdev, GSW_RMON_Redirect_cnt_t *parm)
 GSW_return_t GSW_RMON_If_Get(void *cdev, GSW_RMON_If_cnt_t *parm)
 {
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
-	u32 ret;
+	int ret = GSW_statusOk;
+	GSW_RMON_mode_t param;
 
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return GSW_statusErr;
 	}
 
+	memset(&param, 0, sizeof(GSW_RMON_mode_t));
+	param.eRmonType = GSW_RMON_IF;
+
 #ifdef __KERNEL__
 	spin_lock_bh(&gswdev->lock_bm);
 #endif
@@ -15429,18 +15478,9 @@ GSW_return_t GSW_RMON_If_Get(void *cdev, GSW_RMON_If_cnt_t *parm)
 			loc = 0;
 
 			for (j = 0; j < MAX_READ; j++) {
-#ifndef CONFIG_X86_INTEL_CE2700
-				/*suresh*/
-				//			ltq_w32(0x801A, gswr_bm_addr);
-				//			ltq_w32(0x001A, gswr_bm_addr);
-				//			asm("SYNC");
-				//			ltq_w32(0x801A, gswr_bm_addr);
-#endif
-
-				if (GSW_statusErr == CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET,
-								BM_RAM_CTRL_BAS_SHIFT, BM_RAM_CTRL_BAS_SIZE, RETURN_ERROR_CODE))
+				ret = gsw_rmon_table_config(cdev, &param);
+				if (ret == GSW_statusErr)
 					continue;
-
 				for (i = 0; i < 4; i++) {
 					gsw_r32(cdev, BM_RAM_VAL_0_VAL0_OFFSET,
 						BM_RAM_VAL_0_VAL0_SHIFT,
@@ -15570,13 +15610,17 @@ GSW_return_t GSW_RMON_If_Get(void *cdev, GSW_RMON_If_cnt_t *parm)
 GSW_return_t GSW_RMON_Route_Get(void *cdev, GSW_RMON_Route_cnt_t *parm)
 {
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
-	u32 ret;
+	int ret = GSW_statusOk;
+	GSW_RMON_mode_t param;
 
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return  GSW_statusErr;
 	}
 
+	memset(&param, 0, sizeof(GSW_RMON_mode_t));
+	param.eRmonType = GSW_RMON_ROUTE;
+
 #ifdef __KERNEL__
 	spin_lock_bh(&gswdev->lock_bm);
 #endif
@@ -15609,18 +15653,9 @@ GSW_return_t GSW_RMON_Route_Get(void *cdev, GSW_RMON_Route_cnt_t *parm)
 			loc = 0;
 
 			for (j = 0; j < MAX_READ; j++) {
-#ifndef CONFIG_X86_INTEL_CE2700
-				/*suresh*/
-//				ltq_w32(0x801B, gswr_bm_addr);
-//				ltq_w32(0x001B, gswr_bm_addr);
-				//			asm("SYNC");
-//				ltq_w32(0x801B, gswr_bm_addr);
-#endif
-
-				if (GSW_statusErr == CHECK_BUSY(BM_RAM_CTRL_BAS_SIZE,
-								BM_RAM_CTRL_BAS_SHIFT, BM_RAM_CTRL_BAS_SIZE, RETURN_ERROR_CODE))
+				ret = gsw_rmon_table_config(cdev, &param);
+				if (ret == GSW_statusErr)
 					continue;
-
 				for (i = 0; i < 4; i++) {
 					gsw_r32(cdev, BM_RAM_VAL_0_VAL0_OFFSET,
 						BM_RAM_VAL_0_VAL0_SHIFT,
@@ -15985,13 +16020,17 @@ static GSW_return_t GSW_PMAC_CountGet_v31(void *cdev, GSW_PMAC_Cnt_t *parm)
 int GSW_PMAC_CountGet(void *cdev, GSW_PMAC_Cnt_t *parm)
 {
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
-	u32 ret;
+	int ret = GSW_statusOk;
+	GSW_RMON_mode_t param;
 
 	if (gswdev == NULL) {
 		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
 		return GSW_statusErr;
 	}
 
+	memset(&param, 0, sizeof(GSW_RMON_mode_t));
+	param.eRmonType = GSW_RMON_PMACIG;
+
 #ifdef __KERNEL__
 	spin_lock_bh(&gswdev->lock_bm);
 #endif
@@ -16023,15 +16062,8 @@ int GSW_PMAC_CountGet(void *cdev, GSW_PMAC_Cnt_t *parm)
 			loc = 0;
 
 			for (j = 0; j < MAX_READ; j++) {
-#ifndef CONFIG_X86_INTEL_CE2700
-				//ltq_w32(0x801C, gswr_bm_addr);
-				//ltq_w32(0x001C, gswr_bm_addr);
-//				asm("SYNC");
-				//ltq_w32(0x801C, gswr_bm_addr);
-#endif
-
-				if (GSW_statusErr == CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET,
-								BM_RAM_CTRL_BAS_SHIFT, BM_RAM_CTRL_BAS_SIZE, RETURN_ERROR_CODE))
+				ret = gsw_rmon_table_config(cdev, &param);
+				if (ret == GSW_statusErr)
 					continue;
 
 				for (i = 0; i < 4; i++) {
diff --git a/include/net/switch_api/lantiq_gsw.h b/include/net/switch_api/lantiq_gsw.h
index 8d0c85510613..ff06ea1deb6b 100644
--- a/include/net/switch_api/lantiq_gsw.h
+++ b/include/net/switch_api/lantiq_gsw.h
@@ -2910,6 +2910,9 @@ typedef struct {
  */
 typedef enum {
 	GSW_RMON_REDIRECTION = 0X18,
+	GSW_RMON_IF = 0x1A,
+	GSW_RMON_ROUTE = 0x1B,
+	GSW_RMON_PMACIG = 0x1C,
 } GSW_RMON_Port_t;
 
 /*@}*/ /* GSW_IOCTL_RMON */
