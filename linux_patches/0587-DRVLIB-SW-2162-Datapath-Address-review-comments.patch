From 2eb1580bcec3b719541ef24da41c10f0c9127fb0 Mon Sep 17 00:00:00 2001
From: Rekha Eswaran <rekha.eswaran@intel.com>
Date: Thu, 25 Apr 2019 11:57:27 +0800
Subject: [PATCH] DRVLIB_SW-2162 - Datapath Address review comments

---
 drivers/net/ethernet/lantiq/datapath/Kconfig       | 30 ++++---------------
 drivers/net/ethernet/lantiq/datapath/datapath.h    | 35 +++++++++++++++++++++-
 .../net/ethernet/lantiq/datapath/datapath_api.c    |  2 +-
 .../ethernet/lantiq/datapath/datapath_notifier.c   |  8 ++---
 .../net/ethernet/lantiq/datapath/datapath_proc.c   | 15 ++++++++--
 .../net/ethernet/lantiq/datapath/datapath_soc.c    |  2 +-
 .../net/ethernet/lantiq/datapath/gswip31/Kconfig   |  2 --
 .../lantiq/datapath/gswip31/datapath_gswip.c       |  2 +-
 .../lantiq/datapath/gswip31/datapath_misc.c        |  2 +-
 .../lantiq/datapath/gswip31/datapath_ppv4_api.c    |  7 +++--
 .../ethernet/lantiq/datapath/gswip31/datapath_tx.c |  6 ++--
 include/net/datapath_api.h                         |  7 -----
 include/net/datapath_api_qos.h                     |  1 +
 13 files changed, 66 insertions(+), 53 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/datapath/Kconfig b/drivers/net/ethernet/lantiq/datapath/Kconfig
index 372f74ab3010..ceb6e5c57168 100644
--- a/drivers/net/ethernet/lantiq/datapath/Kconfig
+++ b/drivers/net/ethernet/lantiq/datapath/Kconfig
@@ -2,9 +2,9 @@
 # Datapath Lib
 #
 menuconfig INTEL_DATAPATH
-	bool "Datapath LIB"
+	bool "Datapath Manager/Core/LIB"
 	default y
-	depends on LTQ_CBM
+	depends on LTQ_CBM || INTEL_CBM
 	---help---
 	  Datapath Lib is to provide common rx/tx wrapper Lib without taking
 	  care of much HW knowledge and also provide common interface for legacy
@@ -89,17 +89,6 @@ config INTEL_DATAPATH_SKB
 	  For Ethernet OAM and MPE FW purpose testing purpose,
 	  It needs to hack SKB
 
-config INTEL_DATAPATH_MPE_FASTHOOK_TEST
-	bool "MPE Fast Hook Test"
-	default n
-	depends on  INTEL_DATAPATH_SKB
-	---help---
-	  MPE FW Fast Hook is used to quick verify MPE FW Functionality without
-	  full PPA support. Once it is enabled, it will add some fields in skb structure
-	  in order to support MPE FAST HOOK. The reason is that some network driver is
-	  pre-build out of this build system.
-	  The testing code by default is not checked in.
-
 config INTEL_DATAPATH_ETH_OAM
 	bool "ETH OAM SUPPORT"
 	default n
@@ -150,28 +139,19 @@ config INTEL_DATAPATH_CPUFREQ
 #
 config LTQ_DATAPATH
 	bool
-	default y
-	depends on INTEL_DATAPATH
+	default INTEL_DATAPATH
 
 config LTQ_DATAPATH_ACA_CSUM_WORKAROUND
 	bool
-	default n
 	default INTEL_DATAPATH_ACA_CSUM_WORKAROUND
 
-config LTQ_DATAPATH_MANUAL_PARSE
-	bool
-	default y
-	depends on INTEL_DATAPATH_MANUAL_PARSE
-
 config LTQ_DATAPATH_SKB
 	bool
-	default n
-	depends on INTEL_DATAPATH_SKB
+	default INTEL_DATAPATH_SKB
 
 config LTQ_DATAPATH_CPUFREQ
 	bool
-	default n
-	depends on INTEL_DATAPATH_CPUFREQ
+	default INTEL_DATAPATH_CPUFREQ
 
 source "drivers/net/ethernet/lantiq/datapath/gswip31/Kconfig"
 source "drivers/net/ethernet/lantiq/datapath/gswip30/Kconfig"
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath.h b/drivers/net/ethernet/lantiq/datapath/datapath.h
index 38a3b276b08c..9442eeb4dd7e 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath.h
+++ b/drivers/net/ethernet/lantiq/datapath/datapath.h
@@ -17,7 +17,40 @@
 #include <linux/atomic.h>
 #include <linux/version.h>
 #include <net/ppa/qos_mgr_tc_hook.h>
-//#include "../cqm/cqm_common.h"
+
+/* Note: In LGM kernel (4.19) branch,
+ * DMA driver already adapted to linux kernel
+ * DMA framework and some DMA macro (like
+ * _DMA_CONTROLLER/_DMA_PORT/_DMA_CHANNEL)
+ * was removed. In order to keep the interface between DP and CQM/UMT driver
+ * same, DP has defined DMA macro accordingly
+ */
+#if !defined(CONFIG_LGM_CQM)
+#define _DMA_CHANBITS   16
+#define _DMA_PORTBITS   8
+#define _DMA_CTRLBITS   8
+
+#define _DMA_CHANMASK   ((1 << _DMA_CHANBITS) - 1)
+#define _DMA_PORTMASK   ((1 << _DMA_PORTBITS) - 1)
+#define _DMA_CTRLMASK   ((1 << _DMA_CTRLBITS) - 1)
+
+#define _DMA_CHANSHIFT  0
+#define _DMA_PORTSHIFT  (_DMA_CHANSHIFT + _DMA_CHANBITS)
+#define _DMA_CTRLSHIFT  (_DMA_PORTSHIFT + _DMA_PORTBITS)
+
+#define _DMA_CONTROLLER(nr)     (((nr) >> _DMA_CTRLSHIFT) & _DMA_CTRLMASK)
+#define _DMA_PORT(nr)           (((nr) >> _DMA_PORTSHIFT) & _DMA_PORTMASK)
+#define _DMA_CHANNEL(nr)        (((nr) >> _DMA_CHANSHIFT) & _DMA_CHANMASK)
+#else
+#include "../cqm/cqm_common.h"
+#endif
+
+#if IS_ENABLED(CONFIG_PRX300_CQM) || \
+	IS_ENABLED(CONFIG_GRX500_CBM)
+	#include <net/lantiq_cbm_api.h>
+#else
+	#include <net/intel_cbm_api.h>
+#endif
 
 #define dp_vlan_dev_priv vlan_dev_priv
 #ifdef DUMMY_PPV4_QOS_API_OLD
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_api.c b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
index d31ee9ba01ab..ea0bb8dc21bb 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_api.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
@@ -495,7 +495,7 @@ static int32_t dp_alloc_port_private(int inst,
 	/*only 1st dp instance support real CPU path traffic */
 	if (!inst && dp_port_prop[inst].info.init_dma_pmac_template)
 		dp_port_prop[inst].info.init_dma_pmac_template(port_id, flags);
-	for (i = 0; i < MAX_SUBIFS; i++)
+	for (i = 0; i < dp_port_prop[inst].info.cap.max_num_subif_per_port; i++)
 		INIT_LIST_HEAD(&dp_port_info[inst][port_id].
 			subif_info[i].logic_dev);
 	dp_inst_insert_mod(owner, port_id, inst, 0);
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_notifier.c b/drivers/net/ethernet/lantiq/datapath/datapath_notifier.c
index 909933c221f0..9e4ef9918df2 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_notifier.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_notifier.c
@@ -70,6 +70,7 @@ int dp_event(struct notifier_block *this, unsigned long event, void *ptr)
 	}
 	inst = dp_dev->inst;
 	port = &dp_port_info[inst][dp_dev->ep];
+	prop = &dp_port_prop[inst];
 	switch (event) {
 	case NETDEV_GOING_DOWN:
 		DP_DEBUG(DP_DBG_FLAG_NOTIFY,
@@ -79,8 +80,7 @@ int dp_event(struct notifier_block *this, unsigned long event, void *ptr)
 			 "dev:", dev ? dev->name : "NULL",
 			 "MAC:", addr[0], addr[1], addr[2],
 			 addr[3], addr[4], addr[5]);
-		prop = &dp_port_prop[inst];
-		for (i = 0; i < MAX_SUBIFS; i++) {
+		for (i = 0; i < prop->info.cap.max_num_subif_per_port; i++) {
 			if (port->subif_info[i].netif == dev) {
 				vap = i;
 				DP_DEBUG(DP_DBG_FLAG_NOTIFY, "vap:%d\n", vap);
@@ -140,7 +140,7 @@ int dp_event(struct notifier_block *this, unsigned long event, void *ptr)
 				dp_dev->fid = 0;
 			}
 		}
-		for (i = 0; i < MAX_SUBIFS; i++) {
+		for (i = 0; i < prop->info.cap.max_num_subif_per_port; i++) {
 			if (port->subif_info[i].netif == dev) {
 				vap = i;
 				DP_DEBUG(DP_DBG_FLAG_NOTIFY, "vap:%d\n", vap);
@@ -157,7 +157,6 @@ int dp_event(struct notifier_block *this, unsigned long event, void *ptr)
 				 "dev:", dev ? dev->name : "NULL",
 				 "MAC:", addr[0], addr[1], addr[2],
 				 addr[3], addr[4], addr[5]);
-			prop = &dp_port_prop[inst];
 			/* Note: For Linux network device's mac address,
 			 *       its bridge port should be CPU port, not its
 			 *       mapped bridge port in GSWIP
@@ -180,7 +179,6 @@ int dp_event(struct notifier_block *this, unsigned long event, void *ptr)
 			 "dev:", dev ? dev->name : "NULL",
 			 "MAC:", addr[0], addr[1], addr[2],
 			 addr[3], addr[4], addr[5]);
-		prop = &dp_port_prop[inst];
 		prop->info.dp_mac_set(0,
 				      dp_dev->fid,
 				      dp_dev->inst, addr);
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_proc.c b/drivers/net/ethernet/lantiq/datapath/datapath_proc.c
index 5efa9fb6e0ea..4a2f5532580a 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_proc.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_proc.c
@@ -63,6 +63,7 @@ int proc_port_dump(struct seq_file *s, int pos)
 			    int subif_index, u32 flag);
 	struct pmac_port_info *port = get_port_info(tmp_inst, pos);
 	u16 start = 0;
+	u32 cid, pid, nid;
 	int loop;
 	struct inst_info *info = NULL;
 
@@ -218,12 +219,18 @@ int proc_port_dump(struct seq_file *s, int pos)
 			   dp_deq_port_tbl[tmp_inst][cqm_p].ref_cnt);
 		seq_printf(s, "          : mac_learn_dis:    %d\n",
 			   port->subif_info[i].mac_learn_dis);
+		cid = _DMA_CONTROLLER(dp_deq_port_tbl[tmp_inst][cqm_p].dma_chan);
+		pid = _DMA_PORT(dp_deq_port_tbl[tmp_inst][cqm_p].dma_chan);
+		nid = _DMA_CHANNEL(dp_deq_port_tbl[tmp_inst][cqm_p].dma_chan);
 		dma_ch_offset = dp_deq_port_tbl[tmp_inst][cqm_p].dma_ch_offset;
-		if (port->num_dma_chan && dp_dma_chan_tbl[tmp_inst])
+		if (port->num_dma_chan && dp_dma_chan_tbl[tmp_inst]) {
 			seq_printf(s, "          : tx_dma_ch:    0x%x(ref=%d)\n",
 			   dp_deq_port_tbl[tmp_inst][cqm_p].dma_chan,
 			   atomic_read(&(dp_dma_chan_tbl[tmp_inst] +
 				       dma_ch_offset)->ref_cnt));
+			seq_printf(s, "          : dma-ctrl/port/channel:%d/%d/%d\n",
+				cid, pid, nid);
+		}
 		seq_printf(s, "          : gpid:           %d\n",
 			   port->subif_info[i].gpid);
 		if (port->subif_info[i].ctp_dev &&
@@ -365,10 +372,12 @@ ssize_t proc_port_write(struct file *file, const char *buf, size_t count,
 	int len;
 	char str[64];
 	int num, i;
+	/*later need to put real inst value */
+	struct inst_info *info = &dp_port_prop[0].info;
 	u8 index_start = 0;
 	u8 index_end = MAX_DP_PORTS;
 	int vap_start = 0;
-	int vap_end = MAX_SUBIFS;
+	int vap_end = info->cap.max_num_subif_per_port;
 	char *param_list[10];
 	int inst;
 
@@ -396,7 +405,7 @@ ssize_t proc_port_write(struct file *file, const char *buf, size_t count,
 		return count;
 	}
 
-	if (vap_start >= MAX_SUBIFS) {
+	if (vap_start >= info->cap.max_num_subif_per_port) {
 		PR_ERR("wrong VAP: 0 ~ 15\n");
 		return count;
 	}
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_soc.c b/drivers/net/ethernet/lantiq/datapath/datapath_soc.c
index bde647ba4908..25fef9a26913 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_soc.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_soc.c
@@ -29,7 +29,7 @@ int request_dp(u32 flag)
 	u32 mac_ifcnt = gsw_get_mac_subifcnt(0);
 
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_SIMULATE_GSWIP32) || \
-	defined(DP_SKB_HACK)
+	IS_ENABLED(CONFIG_LGM_CQM)
 	info.type = GSWIP32_TYPE;
 	info.ver = GSWIP32_VER;
 	info.ops[0] = gsw_get_swcore_ops(0);
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/Kconfig b/drivers/net/ethernet/lantiq/datapath/gswip31/Kconfig
index 1b6cc558a908..5efb5e9abb73 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/Kconfig
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/Kconfig
@@ -27,12 +27,10 @@ config INTEL_DATAPATH_DDR_SIMULATE_GSWIP31
 
 config INTEL_DATAPATH_DUMMY_QOS
 	bool "datapath dummy QOS based on slim QOS driver or real QOS API with PRX300_test API"
-	default n
 	depends on LTQ_PPV4_QOS_SLIM || (LTQ_PPV4_QOS || LTQ_PPV4)
 
 config INTEL_DATAPATH_DUMMY_QOS_VIA_PRX300_TEST
 	bool "datapath dummy QOS via ppv4 qos driver's PRX300_test api, like slim driver"
-	default n
 	depends on (LTQ_PPV4_QOS || LTQ_PPV4) && !LTQ_PPV4_QOS_SLIM && INTEL_DATAPATH_DUMMY_QOS
 
 config INTEL_DATAPATH_QOS_HAL
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_gswip.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_gswip.c
index 249ffc7e9afa..7bf82fe30406 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_gswip.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_gswip.c
@@ -46,6 +46,7 @@ struct ctp_assign {
 
 static struct ctp_assign ctp_assign_info[] = {
 	/*note: multiple flags must put first */
+	{DP_F_CPU, GSW_LOGICAL_PORT_8BIT_WLAN, 16, 8, 0xF, CQE_LU_MODE0, 8},
 	{DP_F_GPON, GSW_LOGICAL_PORT_GPON, 256, 0, 0xFF, CQE_LU_MODE1, 1},
 	{DP_F_EPON, GSW_LOGICAL_PORT_EPON, 256, 0, 0xFF, CQE_LU_MODE1, 1},
 	{DP_F_GINT, GSW_LOGICAL_PORT_GINT, 16, 0, 0xFF, CQE_LU_MODE1, 1},
@@ -616,7 +617,6 @@ struct gsw_itf *ctp_port_assign(int inst, u8 ep, int bp_default,
 		num = data->max_ctp;
 	else
 		num = assign->num;
-
 	ctp_assign.nLogicalPortId = ep;
 	ctp_assign.eMode = assign->emode;
 	ctp_assign.nBridgePortId = bp_default;
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
index ec1b7c08e3a5..6ed9d0f6c568 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
@@ -1066,7 +1066,7 @@ int dp_platform_queue_set(int inst, u32 flag)
 	struct hal_priv *priv = (struct hal_priv *)dp_port_prop[inst].priv_hal;
 	struct pmac_port_info *port_info;
 
-	port_info = &dp_port_info[inst][0]; /*CPU*/
+	port_info = &dp_port_info[inst][CPU_PORT];
 	if ((flag & DP_PLATFORM_DE_INIT) == DP_PLATFORM_DE_INIT) {
 		PR_ERR("Need to free resoruce in the future\n");
 		return 0;
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_ppv4_api.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_ppv4_api.c
index 4a160663f249..96cdf8711c6e 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_ppv4_api.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_ppv4_api.c
@@ -3918,7 +3918,8 @@ int dp_queue_map_get_31(struct dp_queue_map_get *cfg, int flag)
 		PR_ERR("Invalid Queue ID:%d\n", cfg->q_id);
 		return DP_FAILURE;
 	}
-	if (priv->qos_queue_stat[cfg->q_id].flag == PP_NODE_FREE) {
+	if ((priv->qos_queue_stat[cfg->q_id].flag == PP_NODE_FREE) &&
+			(cfg->q_id != priv->ppv4_drop_q)) {
 		PR_ERR("Invalid Queue flag:%d\n",
 		       priv->qos_queue_stat[cfg->q_id].flag);
 		return DP_FAILURE;
@@ -4494,8 +4495,8 @@ int dp_node_reserve(int inst, int ep, struct dp_port_data *data, int flags)
 	return res;
 }
 
-/* dp_children_get_31 API
- * Get direct chldren and type of given node and return DP_SUCCESS
+/* dp_qos_global_info_get_31 API
+ * Get global qos config information return DP_SUCCESS
  * else return DP_FAILURE
  */
 int dp_qos_global_info_get_31(struct dp_qos_cfg_info *info, int flag)
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_tx.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_tx.c
index 25517ca88b5a..f9fc791d951b 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_tx.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_tx.c
@@ -27,7 +27,7 @@ void dp_xmit_dbg(
 	int gso,
 	int checksum)
 {
-#ifdef DP_SKB_HACK
+#if defined(DP_SKB_HACK)
 	DP_DEBUG(DP_DBG_FLAG_DUMP_TX,
 		 "%s: dp_xmit:skb->data/len=0x%p/%d data_ptr=%x from port=%d and subitf=%d\n",
 		 title,	skb->data, len,
@@ -73,7 +73,7 @@ void dp_xmit_dbg(
 			 skb_network_header(skb)));
 
 	if (dp_dbg_flag & DP_DBG_FLAG_DUMP_TX_DESCRIPTOR)
-#ifdef DP_SKB_HACK
+#if defined(DP_SKB_HACK)
 		dp_port_prop[0].info.dump_tx_dma_desc(
 				(struct dma_tx_desc_0 *)&skb->DW0,
 				(struct dma_tx_desc_1 *)&skb->DW1,
@@ -176,7 +176,7 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 		 *Must put these 4 lines after INSERT_PMAC
 		 *since INSERT_PMAC will change skb if needed
 		 *********************************************/
-#ifdef DP_SKB_HACK
+#if defined(DP_SKB_HACK)
 		desc_0 = (struct dma_tx_desc_0 *)&skb->DW0;
 		desc_1 = (struct dma_tx_desc_1 *)&skb->DW1;
 		desc_2 = (struct dma_tx_desc_2 *)&skb->DW2;
diff --git a/include/net/datapath_api.h b/include/net/datapath_api.h
index db8bf461f208..89fc451629c7 100644
--- a/include/net/datapath_api.h
+++ b/include/net/datapath_api.h
@@ -14,13 +14,6 @@
 #include <linux/etherdevice.h>
 #include <linux/atmdev.h>
 
-#if IS_ENABLED(CONFIG_PRX300_CQM) || \
-	IS_ENABLED(CONFIG_GRX500_CBM)
-	#include <net/lantiq_cbm_api.h>
-#else
-	#include <net/intel_cbm_api.h>
-#endif
-
 #ifndef DATAPATH_HAL_LAYER
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_SIMULATE_GSWIP32) || \
 	IS_ENABLED(CONFIG_SOC_LGM) || \
diff --git a/include/net/datapath_api_qos.h b/include/net/datapath_api_qos.h
index 4670b99944b4..fa41c68dd20c 100644
--- a/include/net/datapath_api_qos.h
+++ b/include/net/datapath_api_qos.h
@@ -980,6 +980,7 @@ struct dp_q_map {
 	u32	dec; /*!< VPN Decrypt flag: 1 bit*/
 	u32	enc; /*!< VPN Encrypt flag: 1 bit*/
 	u32	class; /*!< Traffic Class: 4 bits*/
+	u32	egflag; /*!< egflag: 1 bits */
 };
 
 /*! @brief dp_q_map_mask*/
