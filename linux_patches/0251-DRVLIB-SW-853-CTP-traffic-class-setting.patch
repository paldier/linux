From 833bd849afd512f20f9137bf1894eea10d9caa32 Mon Sep 17 00:00:00 2001
From: Rekha Eswaran <rekha.eswaran@intel.com>
Date: Thu, 26 Jul 2018 11:32:45 +0800
Subject: [PATCH] DRVLIB_SW-853: CTP traffic class setting

---
 .../net/ethernet/lantiq/datapath/datapath_api.c    |  4 ++
 .../ethernet/lantiq/datapath/datapath_instance.c   |  1 -
 .../lantiq/datapath/gswip31/datapath_misc.c        | 46 ++++++++++++++++++++++
 .../lantiq/datapath/gswip31/datapath_proc.c        | 26 ++++++++++++
 include/net/datapath_api.h                         |  3 ++
 include/net/datapath_inst.h                        |  1 +
 6 files changed, 80 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_api.c b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
index 0ce8fa21f935..2872bfa819d2 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_api.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
@@ -1093,6 +1093,7 @@ int32_t dp_get_netif_subifid(struct net_device *netif, struct sk_buff *skb,
 		end = start + 1;
 	}
 #endif
+	subif->flag_pmapper = 0;
 	DP_LIB_LOCK(&dp_lock);
 	for (k = start; k < end; k++) {
 		if (dp_port_info[inst][k].status != PORT_SUBIF_REGISTERED)
@@ -1153,6 +1154,9 @@ int32_t dp_get_netif_subifid(struct net_device *netif, struct sk_buff *skb,
 								 subif);
 					subif_flag[num] = PORT_SUBIF(inst, k, i,
 								subif_flag);
+					if (dp_port_info[inst][k].subif_info[i].
+						ctp_dev)
+						subif->flag_pmapper = 1;
 					bport = PORT_SUBIF(inst, k, i, bp);
 					if (num &&
 					    (bport != dp_port_info[inst][k].
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_instance.c b/drivers/net/ethernet/lantiq/datapath/datapath_instance.c
index f320c3370cbc..1e898c84d481 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_instance.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_instance.c
@@ -247,7 +247,6 @@ int dp_inst_add_dev(struct net_device *dev, char *subif_name, int inst,
 			dp_dev->count = 0;
 			dp_dev->subif_name[0] = 0;
 			dp_dev->fid = 0;
-			//dp_port_info[inst][0].subif_info[0].fid = dp_dev->fid;
 			INIT_LIST_HEAD(&dp_dev->ctp_list);
 			new_f = 1;
 		}
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
index 13c6134f4805..7233da841036 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
@@ -36,6 +36,7 @@
 #include <net/datapath_api.h>
 #include <net/datapath_api_gswip31.h>
 #include "../datapath.h"
+#include "../datapath_instance.h"
 #include "datapath_proc.h"
 #include "datapath_ppv4.h"
 #include "datapath_misc.h"
@@ -1324,6 +1325,50 @@ static int subif_platform_set_unexplicit(int inst, int port_id,
 	return 0;
 }
 
+static int ctp_tc_map_set(struct dp_tc_cfg *tc, int flag)
+{
+	struct dp_dev *dp_dev;
+	struct core_ops *gsw_handle;
+	GSW_CTP_portConfig_t ctp_tc_cfg;
+	dp_subif_t subif = {0};
+
+	memset(&ctp_tc_cfg, 0, sizeof(ctp_tc_cfg));
+
+	if (dp_get_netif_subifid(tc->dev, NULL, NULL, NULL, &subif, 0)) {
+		DP_DEBUG(DP_DBG_FLAG_DBG, "get subifid fail(%s)\n",
+			 tc->dev ? tc->dev->name : "NULL");
+	} else {
+	if (subif.flag_pmapper) {
+		PR_ERR("Cannot support ctp tc set for pmmapper dev(%s)\n",
+		       tc->dev ? tc->dev->name : "NULL");
+		return -1;
+	}
+	gsw_handle = dp_port_prop[subif.inst].ops[GSWIP_L];
+	ctp_tc_cfg.nLogicalPortId = subif.port_id;
+	ctp_tc_cfg.nSubIfIdGroup = subif.subif;
+	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_ctp_ops.CTP_PortConfigGet,
+			 gsw_handle, &ctp_tc_cfg) != 0) {
+		PR_ERR("Failed to get CTP info for ep=%d subif=%d\n",
+		       dp_dev->ep, dp_dev->ctp);
+		return -1;
+	}
+	ctp_tc_cfg.eMask = GSW_CTP_PORT_CONFIG_MASK_FORCE_TRAFFIC_CLASS;
+	ctp_tc_cfg.nDefaultTrafficClass = tc->tc;
+	if (tc->force)
+		ctp_tc_cfg.bForcedTrafficClass = tc->force;
+	else
+		ctp_tc_cfg.bForcedTrafficClass = 0;
+
+	if (gsw_core_api((dp_gsw_cb)gsw_handle->gsw_ctp_ops.CTP_PortConfigSet,
+			 gsw_handle, &ctp_tc_cfg) != 0) {
+		PR_ERR("CTP tc set fail for ep=%d subif=%d tc=%d force=%d\n",
+		       dp_dev->ep, dp_dev->ctp, tc->tc, tc->force);
+		return -1;
+	}
+	}
+	return 0;
+}
+
 static int not_valid_rx_ep(int ep)
 {
 	return (((ep >= 3) && (ep <= 6)) || (ep == 2) || (ep > 15));
@@ -1421,6 +1466,7 @@ int register_dp_cap_gswip31(int flag)
 	cap.info.dp_qos_platform_set = qos_platform_set;
 	cap.info.dp_set_gsw_pmapper = dp_set_gsw_pmapper_31;
 	cap.info.dp_get_gsw_pmapper = dp_get_gsw_pmapper_31;
+	cap.info.dp_ctp_tc_map_set = ctp_tc_map_set;
 #ifdef CONFIG_LTQ_DATAPATH_HAL_GSWIP31_MIB
 	cap.info.dp_get_port_vap_mib = dp_get_port_vap_mib_31;
 	cap.info.dp_clear_netif_mib = dp_clear_netif_mib_31;
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_proc.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_proc.c
index 5a95f029d164..92ea689c32aa 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_proc.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_proc.c
@@ -2301,6 +2301,8 @@ static ssize_t ep_port_write(struct file *file, const char *buf, size_t count,
 	char *param_list[10];
 	dp_pmac_cfg_t pmac_cfg;
 	int inst = 0;
+	int flag1 = 0;
+	struct dp_tc_cfg *tc;
 
 	memset(&pmac_cfg, 0, sizeof(dp_pmac_cfg_t));
 	len = (sizeof(str) > count) ? count : sizeof(str) - 1;
@@ -2346,12 +2348,35 @@ static ssize_t ep_port_write(struct file *file, const char *buf, size_t count,
 			PR_INFO("pmac set configuration failed\n");
 			return -1;
 		}
+	} else if (dp_strncmpi(param_list[0], "ctp_tc",
+		   strlen("ctp_tc")) == 0) {
+		tc = kzalloc(sizeof(*tc), GFP_KERNEL);
+		if (!tc) {
+			PR_ERR("failed to alloc ctp tc %d bytes\n",
+			       sizeof(*tc));
+			return 0;
+		}
+		tc->dev = dev_get_by_name(&init_net, param_list[1]);
+		tc->tc = dp_atoi(param_list[2]);
+		if (tc->tc > 15) {
+			PR_ERR("traffic class value range 0-15 only\n");
+			goto exit;
+		}
+		tc->force = 0;
+		if (dp_port_prop[inst].info.dp_ctp_tc_map_set(tc, flag1))
+			PR_ERR("ctp_tc_set fail\n");
+		else
+			PR_ERR("ctp_tc_set success\n");
+		kfree(tc);
 	} else {
 		PR_INFO("wrong command\n");
 		goto help;
 	}
 
 	return count;
+ exit:
+	kfree(tc);
+	return count;
  help:
 	PR_INFO("echo %s > /proc/dp/ep\n",
 		"ingress/egress [ep_port] ['ingress/egress fields'] [value]");
@@ -2366,6 +2391,7 @@ static ssize_t ep_port_write(struct file *file, const char *buf, size_t count,
 		"egress [ep_port]",
 		"['rx_dmachan/fcs/pmac/res_dw1/res1_dw0/res2_dw0] [value]");
 	PR_INFO("echo egress [ep_port] ['rm_l2hdr'] [value] > /proc/dp/ep\n");
+	PR_INFO("echo ctp_tc [dev] [val] > /proc/dp/ep\n");
 	return count;
 }
 
diff --git a/include/net/datapath_api.h b/include/net/datapath_api.h
index c80397a747a2..b94d798b9314 100644
--- a/include/net/datapath_api.h
+++ b/include/net/datapath_api.h
@@ -289,6 +289,9 @@ typedef struct dp_subif {
 			  *   in case need call API dp_vlan_set to apply VLAN
 			  *   rule to CTP or bridge port
 			  */
+	u32 flag_pmapper : 1; /*!< output: flag to indicate whether this
+			       *   device is pmapper device
+			       */
 } dp_subif_t;
 
 typedef dp_subif_t PPA_SUBIF; /*!< @brief structure type dp_subif PPA_SUBIF*/
diff --git a/include/net/datapath_inst.h b/include/net/datapath_inst.h
index 5bd0975863d3..d67274f3929f 100644
--- a/include/net/datapath_inst.h
+++ b/include/net/datapath_inst.h
@@ -108,6 +108,7 @@ struct inst_info {
 				  struct dp_pmapper *mapper, u32 flag);
 	int (*dp_get_gsw_pmapper)(int inst, int bport, int lport,
 				  struct dp_pmapper *mapper, u32 flag);
+	int (*dp_ctp_tc_map_set)(struct dp_tc_cfg *tc, int flag);
 #if IS_ENABLED(CONFIG_LTQ_DATAPATH_SWITCHDEV)
 	int swdev_flag;
 	int (*swdev_alloc_bridge_id)(int inst);
