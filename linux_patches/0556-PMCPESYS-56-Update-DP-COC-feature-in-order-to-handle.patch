From 90bdb40bba74a6f8f22a1c0aa3cbd087c709534c Mon Sep 17 00:00:00 2001
From: Rekha Eswaran <rekha.eswaran@intel.com>
Date: Mon, 22 Apr 2019 17:48:59 +0800
Subject: [PATCH] PMCPESYS-56 - Update DP COC feature in order to handle
 CPUFREQ notifier out of interrupt context & enable previous rmon polling for
 DP downscale trigger

---
 drivers/net/ethernet/lantiq/datapath/datapath.h    |  12 +-
 .../net/ethernet/lantiq/datapath/datapath_api.c    |   2 +-
 .../ethernet/lantiq/datapath/datapath_instance.c   |   7 +-
 .../net/ethernet/lantiq/datapath/datapath_misc.c   |  35 +-
 .../lantiq/datapath/gswip30/datapath_coc.c         | 359 ++++++++++++++++++---
 .../lantiq/datapath/gswip30/datapath_misc.c        |   6 +-
 6 files changed, 349 insertions(+), 72 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/datapath/datapath.h b/drivers/net/ethernet/lantiq/datapath/datapath.h
index fdbf821a9cc7..e5f61fe1f7ee 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath.h
+++ b/drivers/net/ethernet/lantiq/datapath/datapath.h
@@ -703,18 +703,21 @@ void dp_mib_exit(void);
 void print_parser_status(struct seq_file *s);
 void proc_mib_timer_read(struct seq_file *s);
 int mpe_fh_netfiler_install(void);
+#ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
 int dp_coc_cpufreq_exit(void);
 int dp_coc_cpufreq_init(void);
 int dp_cpufreq_notify_init(int inst);
-int qos_dump_start(void);
-int qos_dump(struct seq_file *s, int pos);
-ssize_t proc_qos_write(struct file *file, const char *buf,
-		       size_t count, loff_t *ppos);
+int dp_cpufreq_notify_exit(void);
 int update_coc_up_sub_module(int new_state,
 			     int old_state, uint32_t flag);
 void proc_coc_read(struct seq_file *s);
 ssize_t proc_coc_write(struct file *file, const char *buf, size_t count,
 		       loff_t *ppos);
+#endif
+int qos_dump_start(void);
+int qos_dump(struct seq_file *s, int pos);
+ssize_t proc_qos_write(struct file *file, const char *buf,
+		       size_t count, loff_t *ppos);
 void dump_parser_flag(char *buf);
 
 //int dp_reset_sys_mib(u32 flag);
@@ -777,7 +780,6 @@ void dp_dump_raw_data(char *buf, int len, char *prefix_str);
 int ltq_tso_xmit(struct sk_buff *skb, void *hdr, int len, int flags);
 #endif
 
-//int dp_set_meter_rate(enum ltq_cpufreq_state stat, unsigned int rate);
 char *dp_skb_csum_str(struct sk_buff *skb);
 extern struct dentry *dp_proc_node;
 int get_dp_dbg_flag_str_size(void);
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_api.c b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
index 109d12f5cb20..b2350d201bed 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_api.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
@@ -2912,7 +2912,7 @@ int dp_basic_proc(void)
 		dp_loop_eth_dev_exit();
 #endif
 #ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
-		dp_coc_cpufreq_exit();
+	dp_cpufreq_notify_exit();
 #endif
 		unregister_notifier(0);
 	}
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_instance.c b/drivers/net/ethernet/lantiq/datapath/datapath_instance.c
index cf65738636ec..9ae2324b2431 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_instance.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_instance.c
@@ -137,6 +137,10 @@ int dp_request_inst(struct dp_inst_info *info, u32 flag)
 	dp_port_prop[i].cbm_inst = info->cbm_inst;
 	dp_port_prop[i].qos_inst = info->qos_inst;
 	dp_port_prop[i].valid = 1;
+#ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
+	dp_cpufreq_notify_init(i);
+	DP_DEBUG(DP_DBG_FLAG_COC, "DP registered CPUFREQ notifier\n");
+#endif
 	if (dp_port_prop[i].info.dp_platform_set(i, DP_PLATFORM_INIT) < 0) {
 		dp_port_prop[i].valid = 0;
 		PR_ERR("dp_platform_init failed for inst=%d\n", i);
@@ -147,9 +151,6 @@ int dp_request_inst(struct dp_inst_info *info, u32 flag)
 	DP_DEBUG(DP_DBG_FLAG_INST,
 		 "dp_request_inst ok: inst=%d, dp_inst_num=%d\n",
 		 i, dp_inst_num);
-#ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
-	dp_cpufreq_notify_init(i);
-#endif
 	return 0;
 }
 EXPORT_SYMBOL(dp_request_inst);
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_misc.c b/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
index c137bf52e2a8..9bddd5fde1f1 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
@@ -1390,10 +1390,9 @@ static int dp_coc_cpufreq_policy_notifier(struct notifier_block *nb,
 			 policy->min, policy->max, policy->cur);
 		return NOTIFY_DONE;
 	}
-	if (!dp_port_prop[dp_coc_inst].info.dp_handle_cpufreq_event)
-		return NOTIFY_OK;
 	return
-	dp_port_prop[dp_coc_inst].info.dp_handle_cpufreq_event(POLICY_NOTIFY, policy);
+	dp_port_prop[dp_coc_inst].info.
+		dp_handle_cpufreq_event(POLICY_NOTIFY, policy);
 }
 
 /* keep track of frequency transitions */
@@ -1402,15 +1401,11 @@ static int dp_coc_cpufreq_transition_notifier(struct notifier_block *nb,
 {
 	struct cpufreq_freqs *freq = data;
 	if (event == CPUFREQ_PRECHANGE) {
-		if (!dp_port_prop[dp_coc_inst].info.dp_handle_cpufreq_event)
-			return NOTIFY_STOP_MASK;
 		return dp_port_prop[dp_coc_inst].info.
-					dp_handle_cpufreq_event(PRE_CHANGE, freq);
+				dp_handle_cpufreq_event(PRE_CHANGE, freq);
 	} else if (event == CPUFREQ_POSTCHANGE) {
-		if (!dp_port_prop[dp_coc_inst].info.dp_handle_cpufreq_event)
-			return NOTIFY_STOP_MASK;
 		return dp_port_prop[dp_coc_inst].info.
-					dp_handle_cpufreq_event(POST_CHANGE, freq);
+				dp_handle_cpufreq_event(POST_CHANGE, freq);
 	}
 	return NOTIFY_OK;
 }
@@ -1425,18 +1420,34 @@ static struct notifier_block dp_coc_cpufreq_policy_notifier_block = {
 
 int dp_cpufreq_notify_init(int inst)
 {
-	
 	dp_coc_inst = inst;
 	if (cpufreq_register_notifier
 	    (&dp_coc_cpufreq_transition_notifier_block,
 	    CPUFREQ_TRANSITION_NOTIFIER)) {
-		PR_ERR("cpufreq_register_notifier failed?\n");
+		PR_ERR("cpufreq transiiton register_notifier failed?\n");
 		return -1;
 	}
 	if (cpufreq_register_notifier
 	    (&dp_coc_cpufreq_policy_notifier_block,
 	    CPUFREQ_POLICY_NOTIFIER)) {
-		PR_ERR("cpufreq_register_notifier failed?\n");
+		PR_ERR("cpufreq policy register_notifier failed?\n");
+		return -1;
+	}
+	return 0;
+}
+
+int dp_cpufreq_notify_exit(void)
+{
+	if (cpufreq_unregister_notifier
+	    (&dp_coc_cpufreq_transition_notifier_block,
+	    CPUFREQ_TRANSITION_NOTIFIER)) {
+		PR_ERR("cpufreq transition unregister_notifier failed?\n");
+		return -1;
+	}
+	if (cpufreq_unregister_notifier
+	    (&dp_coc_cpufreq_policy_notifier_block,
+	    CPUFREQ_POLICY_NOTIFIER)) {
+		PR_ERR("cpufreq policy unregister_notifier failed?\n");
 		return -1;
 	}
 	return 0;
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_coc.c b/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_coc.c
index a2fe55210a1a..5a3722c20d1c 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_coc.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_coc.c
@@ -12,6 +12,7 @@
 #include <linux/types.h>	/* size_t */
 #include <linux/timer.h>
 #include <linux/cpufreq.h>
+#include <linux/workqueue.h>
 #include <net/datapath_api.h>
 #include <net/datapath_proc_api.h>
 #include "../datapath.h"
@@ -20,14 +21,29 @@
 #define DP_MODULE  LTQ_CPUFREQ_MODULE_DP
 #define DP_ID 0	 /* this ID should represent the Datapath interface No. */
 #define LTQ_CPUFREQ_PS_D0 0
+#define LTQ_CPUFREQ_PS_D1 1
+#define LTQ_CPUFREQ_PS_D2 2
 #define LTQ_CPUFREQ_PS_D3 3
+static struct timer_list dp_coc_timer;
+static u32 polling_period;	/*seconds */
+static int rmon_timer_en;
 static spinlock_t dp_coc_lock;
 
+/* threshold data for D0:D3 */
+unsigned int rmon_threshold[4] = { 0, 30, 20, 10 }; /*packets */
 /* driver is busy and needs highest performance */
 static int dp_coc_init_stat;	/*DP COC is Initialized or not */
 static int dp_coc_ena;		/*DP COC is enabled or not */
 int dp_coc_ps_curr = -1;/*current state*/
-
+/*new statue wanted to switch to */
+int dp_coc_ps_new = -1;
+struct work_struct coc_work_q;
+static GSW_RMON_Port_cnt_t rmon_last[PMAC_MAX_NUM];
+static u64 last_rmon_rx;
+int dp_coc_ps_max = 0;/*system maximum*/
+int dp_coc_ps_min = 0;/*system minimum*/
+
+int intr = -1;
 int inst = 0;
 /*meter */
 #define PCE_OVERHD 20
@@ -37,14 +53,17 @@ static u32 meter_ncbs = 0x8000 + (1514 + PCE_OVERHD) * 3 + 200;
 /*1 ~ 2 packet size */
 static u32 meter_nebs = 0x8000 + (1514 + PCE_OVERHD) * 1 + 200;
 /*k bits */
-static u32 meter_nrate[2] = { 0/*D0 */, 500/*D3*/};
-
+static u32 meter_nrate[4] = { 0/*D0 */, 700/*D1*/, 600/*D2*/, 500/*D3*/};
 static int apply_meter_rate(u32 rate, unsigned int new_state);
 
 int dp_set_meter_rate(int stat, unsigned int rate)
 {/*set the rate for upscaling to D0 from specified stat */
-	if (stat == LTQ_CPUFREQ_PS_D3)
+	if (stat == LTQ_CPUFREQ_PS_D1)
 		meter_nrate[1] = rate;
+	else if (stat == LTQ_CPUFREQ_PS_D2)
+		meter_nrate[2] = rate;
+	else if (stat == LTQ_CPUFREQ_PS_D3)
+		meter_nrate[3] = rate;
 	else
 		return -1;
 	//if (dp_coc_ps_curr == stat)
@@ -52,6 +71,16 @@ int dp_set_meter_rate(int stat, unsigned int rate)
 	return 0;
 }
 
+int dp_set_rmon_threshold(uint32_t *threshold)
+{
+	if (!threshold)
+		return -1;
+	memcpy((void *)&rmon_threshold,	(void *)threshold,
+			sizeof(rmon_threshold));
+	return	0;
+}
+EXPORT_SYMBOL(dp_set_rmon_threshold);
+
 static inline void coc_lock(void)
 {
 	if (unlikely(in_irq())) {
@@ -70,6 +99,10 @@ static char *get_coc_stat_string(int stat)
 {
 	if (stat == LTQ_CPUFREQ_PS_D0)
 		return "D0";
+	else if (stat == LTQ_CPUFREQ_PS_D1)
+		return "D1";
+	else if (stat == LTQ_CPUFREQ_PS_D2)
+		return "D2";
 	else if (stat == LTQ_CPUFREQ_PS_D3)
 		return "D3";
 	else
@@ -88,11 +121,19 @@ void proc_coc_read(struct seq_file *s)
 	seq_puts(s, "  Basic DP COC Info:\n");
 	seq_printf(s, "    dp_coc_ena=%d @ 0x%p (DP %s)\n", dp_coc_ena,
 		   &dp_coc_ena, dp_coc_ena ? "COC Enabled" : "COC Disabled");
+	seq_printf(s, "    Rmon timer interval: %u sec (Timer %s)\n",
+		   (unsigned int)polling_period,
+		   rmon_timer_en ? "enabled" : "disabled");
+	seq_printf(s, "    RMON D1 Threshold: %d\n", rmon_threshold[1]);
+	seq_printf(s, "    RMON D2 Threshold: %d\n", rmon_threshold[2]);
+	seq_printf(s, "    RMON D3 Threshold: %d\n", rmon_threshold[3]);
 	seq_printf(s, "    dp_coc_init_stat=%d @ %p (%s)\n", dp_coc_init_stat,
 		   &dp_coc_init_stat,
 		   dp_coc_init_stat ? "initialized ok" : "Not initialized");
 	seq_printf(s, "    dp_coc_ps_curr=%d (%s) @ 0x%p\n", dp_coc_ps_curr,
 		   get_coc_stat_string(dp_coc_ps_curr), &dp_coc_ps_curr);
+	seq_printf(s, "    last_rmon_rx=%llu pkts@ 0x%p (%s)\n", last_rmon_rx,
+		   &last_rmon_rx, rmon_timer_en ? "Valid" : "Not valid");
 
 	seq_puts(s, "    Metering Info:\n");
 	/*PCE_OVERHD */
@@ -112,7 +153,9 @@ void proc_coc_read(struct seq_file *s)
 	seq_printf(s, "    meter nRate=%u\n", meter_cfg.nRate);
 	seq_printf(s, "    meter nPiRate=%u\n", meter_cfg.nPiRate);
 	seq_printf(s, "    meter eMtrType=%u\n", (int)meter_cfg.eMtrType);
-	seq_printf(s, "    D3 nRate=%u\n", meter_nrate[1]);
+	seq_printf(s, "    D1 nRate=%u\n", meter_nrate[1]);
+	seq_printf(s, "    D2 nRate=%u\n", meter_nrate[2]);
+	seq_printf(s, "    D3 nRate=%u\n", meter_nrate[3]);
 
 	memset(&reg, 0, sizeof(reg));
 	reg.nRegAddr = 0x489 + meter_id * 10;
@@ -130,6 +173,7 @@ ssize_t proc_coc_write(struct file *file, const char *buf, size_t count,
 	int len, num;
 	char str[64];
 	char *param_list[3];
+#define MIN_POLL_TIME 1
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
@@ -138,7 +182,59 @@ ssize_t proc_coc_write(struct file *file, const char *buf, size_t count,
 	str[len] = 0;
 
 	num = dp_split_buffer(str, param_list, ARRAY_SIZE(param_list));
-	if (dp_strncmpi(param_list[0], "rate", strlen("rate") + 1) == 0) {
+	if (dp_strncmpi(param_list[0], "timer", strlen("timer") + 1) == 0) {
+		polling_period = dp_atoi(param_list[1]);
+
+		if (polling_period < MIN_POLL_TIME)
+			polling_period = MIN_POLL_TIME;
+
+		coc_lock();
+
+		if (rmon_timer_en) {
+			mod_timer(&dp_coc_timer,
+				  jiffies +
+				  msecs_to_jiffies(polling_period * 1000));
+		}
+
+		coc_unlock();
+	} else if (dp_strncmpi(param_list[0], "threshold0",
+					strlen("threshold0") + 1) == 0) {
+		coc_lock();
+		rmon_threshold[0] = dp_atoi(param_list[1]);
+
+		if (!rmon_threshold[0])
+			rmon_threshold[0] = 1;
+
+		coc_unlock();
+	} else if (dp_strncmpi(param_list[0], "threshold1",
+					strlen("threshold1") + 1) == 0) {
+		coc_lock();
+		rmon_threshold[1] = dp_atoi(param_list[1]);
+
+		if (!rmon_threshold[1])
+			rmon_threshold[1] = 1;
+
+		coc_unlock();
+	} else if (dp_strncmpi(param_list[0], "threshold2",
+					strlen("threshold2") + 1) == 0) {
+		coc_lock();
+		rmon_threshold[2] = dp_atoi(param_list[1]);
+
+		if (!rmon_threshold[2])
+			rmon_threshold[2] = 1;
+
+		coc_unlock();
+	} else if (dp_strncmpi(param_list[0], "threshold3",
+					strlen("threshold3") + 1) == 0) {
+		coc_lock();
+		rmon_threshold[3] = dp_atoi(param_list[1]);
+
+		if (!rmon_threshold[3])
+			rmon_threshold[3] = 1;
+
+		coc_unlock();
+	} else if (dp_strncmpi(param_list[0], "rate",
+					strlen("rate") + 1) == 0) {
 		/*meter rate */
 		u32 rate = dp_atoi(param_list[1]);
 
@@ -146,13 +242,19 @@ ssize_t proc_coc_write(struct file *file, const char *buf, size_t count,
 			PR_INFO("rate should not be zero\n");
 			return count;
 		}
-		if (dp_strncmpi(param_list[0], "rate3", strlen("rate3") + 1) 
-									== 0) {
+		if (dp_strncmpi(param_list[0], "rate1",
+				strlen("rate1") + 1) == 0) {
+			dp_set_meter_rate(LTQ_CPUFREQ_PS_D1, rate);
+
+		} else if (dp_strncmpi(param_list[0], "rate2",
+					strlen("rate2") + 1) == 0) {
+			dp_set_meter_rate(LTQ_CPUFREQ_PS_D2, rate);
+		} else if (dp_strncmpi(param_list[0], "rate3",
+				strlen("rate3") + 1) == 0) {
 			dp_set_meter_rate(LTQ_CPUFREQ_PS_D3, rate);
-
 		} else {
 			PR_INFO
-			    ("Wrong COC state, it should be D3 only\n");
+			    ("Wrong COC state, it should be D1/D2/D3 only\n");
 		}
 	} else {
 		goto help;
@@ -160,8 +262,17 @@ ssize_t proc_coc_write(struct file *file, const char *buf, size_t count,
 	return count;
  help:
 	PR_INFO("Datapath COC Proc Usage:\n");
-	PR_INFO("  echo <ratex> <meter_rate_in_knps> /proc/dp/coc\n");
-	PR_INFO("       Note:Valid x of range: 3\n");
+	PR_INFO("  echo timer polling_interval_in_seconds > /sys/kernel/debug/dp/coc\n");
+	PR_INFO("  echo <thresholdx> its_threshold_value > /sys/kernel/debug/dp/coc\n");
+	PR_INFO("       Note:Valid x of ranage: 1 2 3\n");
+	PR_INFO
+	    ("            For downscale to D<x> if rmon<threshold<x>'s cfg\n");
+	PR_INFO("            threshold1's >= threshold'2 > threshold'3\n");
+	PR_INFO("  echo <ratex> <meter_rate_in_knps> /sys/kernel/debug/dp/coc\n");
+	PR_INFO("       Note:Valid x of range: 1 2 3\n");
+	PR_INFO
+	  ("            For upscale to D0 from D<x> if rmon>=rate<x>'s cfg\n");
+	PR_INFO("            Rate1's >= Rate2's > D3's threshold\n");
 	return count;
 }
 
@@ -242,8 +353,12 @@ int apply_meter_rate(u32 rate, unsigned int new_state)
 	} else if (rate == -1) {
 		meter_cfg.bEnable = 1;
 		/*set PAE metering */
-		if (new_state == LTQ_CPUFREQ_PS_D3) {
+		if (new_state == LTQ_CPUFREQ_PS_D1) {
 			meter_cfg.nRate = meter_nrate[1];
+		} else if (new_state == LTQ_CPUFREQ_PS_D2) {
+			meter_cfg.nRate = meter_nrate[2];
+		} else if (new_state == LTQ_CPUFREQ_PS_D3) {
+			meter_cfg.nRate = meter_nrate[3];
 		} else {
 			meter_cfg.nRate = new_state;
 		}
@@ -298,7 +413,7 @@ int meter_set_default(void)
 	meter_cfg.nMeterId = meter_id;
 	meter_cfg.nCbs = meter_ncbs;
 	meter_cfg.nEbs = meter_nebs;
-	meter_cfg.nRate = meter_nrate[1];
+	meter_cfg.nRate = meter_nrate[3];
 	meter_cfg.nPiRate = 0xFFFFFF; /* try to set maximum */
 	meter_cfg.eMtrType = GSW_QOS_Meter_trTCM;
 	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_MeterCfgSet,
@@ -382,55 +497,182 @@ int meter_set_default(void)
 	return 0;
 }
 
-static int dp_coc_prechange(struct cpufreq_freqs *freq)
+static int dp_coc_policy_notify(struct cpufreq_policy *policy)
+{
+	DP_DEBUG(DP_DBG_FLAG_COC, "policy (min, max, cur):%u, %u, %u\n",
+		 policy->min, policy->max, policy->cur);
+	if (dp_coc_ps_curr == -1) {
+		dp_coc_ps_curr = policy->max;
+		dp_coc_ps_max = policy->max;
+		dp_coc_ps_min = policy->min;
+	} else if (intr == 1) {
+		DP_DEBUG(DP_DBG_FLAG_COC, "dp new freq=%d\n", dp_coc_ps_new);
+		DP_DEBUG(DP_DBG_FLAG_COC, "no down scaling limit to freq=%d\n",
+			 dp_coc_ps_max);
+		dp_coc_ps_new = dp_coc_ps_max;
+		intr = 0;
+		/*No down scaling allowed, limit the frequency to max */
+		cpufreq_verify_within_limits(policy, policy->max, policy->max);
+	}
+	DP_DEBUG(DP_DBG_FLAG_COC, "dp curr freq=%d\n", dp_coc_ps_curr);
+	return NOTIFY_OK;
+}
+
+static void dp_rmon_polling(unsigned long data)
 {
-	int res = -1;
+        GSW_RMON_Port_cnt_t curr;
+        int i;
+        u64 rx = 0;
+	struct core_ops *gsw_handle;
+
+	/*read gswip-r rmon counter */
+	gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
+        for (i = 0; i < PMAC_MAX_NUM; i++) {
+                memset(&curr, 0, sizeof(curr));
+		gsw_core_api((dp_gsw_cb)gsw_handle
+			     ->gsw_rmon_ops.RMON_Port_Get,
+			     gsw_handle, &curr);
+
+                coc_lock();
+                /*wrapround handling */
+                if (curr.nRxGoodPkts >= rmon_last[i].nRxGoodPkts)
+                        rx += curr.nRxGoodPkts - rmon_last[i].nRxGoodPkts;
+                else
+                        rx +=
+                            (u64)0xFFFFFFFF + (u64)curr.nRxGoodPkts -
+                            rmon_last[i].nRxGoodPkts;
+
+                if (curr.nRxDroppedPkts >= rmon_last[i].nRxDroppedPkts)
+                        rx +=
+                            curr.nRxDroppedPkts - rmon_last[i].nRxDroppedPkts;
+                else
+                        rx +=
+                            (u64)0xFFFFFFFF + (u64)curr.nRxDroppedPkts -
+                            rmon_last[i].nRxDroppedPkts;
+
+                memcpy(&rmon_last[i], &curr, sizeof(curr));
+                coc_unlock();
+        }
+        last_rmon_rx = rx;
+        if (dp_coc_ps_curr != -1) {
+                if (rx < rmon_threshold[3]) {
+				schedule_work(&coc_work_q); 
+                                coc_lock();
+                                rmon_timer_en = 0;
+                                coc_unlock();
+				DP_DEBUG(DP_DBG_FLAG_COC,
+                                         "Request to D3:rx (%u) < th_d3 %d\n",
+                                         (unsigned int)rx,
+                                         rmon_threshold[3]);
+                } else if (rx < rmon_threshold[2]) {
+				schedule_work(&coc_work_q); 
+				DP_DEBUG(DP_DBG_FLAG_COC,
+                                        "req to D2: rx (%u) < th_d2 %d\n",
+                                         (unsigned int)rx,
+                                         rmon_threshold[2]);
+                } else if (rx < rmon_threshold[1]) {
+				schedule_work(&coc_work_q); 
+                                DP_DEBUG(DP_DBG_FLAG_COC,
+                                         "req to D1 since rx (%u) < th_d1 %d\n",
+                                         (unsigned int)rx,
+                                         rmon_threshold[1]);
+                } 
+        } else
+                DP_DEBUG(DP_DBG_FLAG_COC,
+                         "DP COC not get its initial power state yet\n");
 
+	coc_lock();
+	if (rmon_timer_en)
+		mod_timer(&dp_coc_timer,
+                          jiffies + msecs_to_jiffies(polling_period * 1000));
+        else
+		last_rmon_rx = 0;
+
+        coc_unlock();
+}
+void update_rmon_last(void)
+{
+        int i;
+	struct core_ops *gsw_handle;
+
+	gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
+	memset(rmon_last, 0, sizeof(rmon_last));
+	for (i = 0; i < PMAC_MAX_NUM; i++)
+		gsw_core_api((dp_gsw_cb)gsw_handle
+			     ->gsw_rmon_ops.RMON_Port_Get,
+			     gsw_handle, &rmon_last[i]);
+}
+
+int update_coc_rmon_timer(uint32_t new_state)
+{
+	if (new_state == dp_coc_ps_max) {
+		/*enable rmon timer */
+		if (!rmon_timer_en)
+			update_rmon_last();
+		mod_timer(&dp_coc_timer,
+			  jiffies + msecs_to_jiffies(polling_period * 1000));
+		rmon_timer_en = 1;
+
+		/*disable meter */
+		apply_meter_rate(0, 0);
+	} else if (new_state < dp_coc_ps_max ||
+		   new_state > dp_coc_ps_min) {
+		/*enable rmon timer */
+		if (!rmon_timer_en)
+			update_rmon_last();
+		mod_timer(&dp_coc_timer,
+			  jiffies + msecs_to_jiffies(polling_period * 1000));
+		rmon_timer_en = 1;
+
+		/*enable meter, but first disable to fix red color issue
+		 * if last already triggered
+		 */
+		apply_meter_rate(0, 0);
+		apply_meter_rate(-1, new_state);	/*enable again */
+	} else if (new_state == dp_coc_ps_min) {
+		/*disable rmon timer */
+		del_timer(&dp_coc_timer);
+		rmon_timer_en = 0;
+		last_rmon_rx = 0;
+
+		/*enable meter */
+		/*enable meter, but first disable to fix red color issue
+		 * if last already triggered
+		 */
+		apply_meter_rate(0, 0);
+		apply_meter_rate(-1, new_state);	/*enable again */
+	}
+
+	return 0;
+}
+
+static int dp_coc_prechange(struct cpufreq_freqs *freq)
+{
 	/*check whether can be switched or not
 	 * and accept the request 
 	 */
 	if (!dp_coc_init_stat || !dp_coc_ena) {
-		res = 0;
+		return NOTIFY_OK;
 	}
 	DP_DEBUG(DP_DBG_FLAG_COC,
 	         "dp_coc_prechange:to switch from %d to %d\n",
 		 freq->old, freq->new);
 
-	return res;
+	return NOTIFY_OK;
 }
 
 static int dp_coc_postchange(struct cpufreq_freqs *freq)
 {
 	if (!dp_coc_init_stat || !dp_coc_ena)
-		return 0;
-
+		return NOTIFY_OK;
 	coc_lock();
-	if (dp_coc_ps_curr > freq->new) {/*changing to low freq, enable meter*/
-		DP_DEBUG(DP_DBG_FLAG_COC, "enable meter new_freq=%d\n",
-			 freq->new);
-		apply_meter_rate(-1, freq->new);
-	} else if (dp_coc_ps_curr < freq->new) { /*changing to high freq, disable meter*/
-		DP_DEBUG(DP_DBG_FLAG_COC, "disable meter new_freq=%d\n",
-			 freq->new);
-		apply_meter_rate(0, 0);
-	} 
 	dp_coc_ps_curr = freq->new;
+	dp_coc_ps_new = -1;
+	update_coc_rmon_timer(freq->new);
 	coc_unlock();
-
-	return 0;
-}
-
-static int dp_coc_policy_notify(struct cpufreq_policy *policy)
-{
-	if (dp_coc_ps_curr == -1) {
-		dp_coc_ps_curr = policy->max;
-	} else if (dp_coc_ps_curr <= policy->min) {
-		/*No down scaling allowed, limit the frequency to max */
-		cpufreq_verify_within_limits(policy, policy->max, policy->max);
-	} else {
-		return NOTIFY_OK;
-	}
-
+	DP_DEBUG(DP_DBG_FLAG_COC,
+	         "dp_coc_postchange:to switch from %d to %d\n",
+		 freq->old, freq->new);
 	return NOTIFY_OK;
 }
 
@@ -457,12 +699,21 @@ int dp_handle_cpufreq_event_30(int event_id, void *cfg)
 	}
 	return res;
 }
+/* Create Work Q to call CPUFREQ policy notifier
+ *in order to run out of interrupt context
+ */
+static int coc_work_task(struct work_struct *work)
+{
+	cpufreq_update_policy(0);
+	return 1;
+}
 
 void dp_meter_interrupt_cb(void *param)
 {
 	DP_DEBUG(DP_DBG_FLAG_COC, "triggered meter intr\n");
-
-	cpufreq_update_policy(0);
+	DP_DEBUG(DP_DBG_FLAG_COC, "dp curr freq=%d\n", dp_coc_ps_curr);
+	intr = 1;
+	schedule_work(&coc_work_q); /* schedule work queue */
 	return;
 }
 
@@ -470,13 +721,16 @@ int dp_coc_cpufreq_init(void)
 {
 	GSW_Irq_Op_t irq;
 	struct core_ops *gsw_handle;
-	pr_debug("enter dp_coc_cpufreq_init\n");
+	PR_INFO("enter dp_coc_cpufreq_init\n");
 
 	spin_lock_init(&dp_coc_lock);
 	dp_coc_init_stat = 0;
 	dp_coc_ena = 0;
         gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
 	cpufreq_update_policy(0);
+
+	if (!polling_period)
+		polling_period = 2;
 	meter_set_default();
 	irq.blk = PCE;
 	irq.event = PCE_METER_EVENT;
@@ -488,17 +742,24 @@ int dp_coc_cpufreq_init(void)
 	gsw_core_api((dp_gsw_cb)gsw_handle->gsw_irq_ops.IRQ_Enable,
 		     gsw_handle, &irq);
 
+	INIT_WORK(&coc_work_q, (work_func_t)coc_work_task);/*initialize work Q*/
+	init_timer_on_stack(&dp_coc_timer);
+	dp_coc_timer.data = 0;
+	dp_coc_timer.function = dp_rmon_polling;
 	dp_coc_init_stat = 1;
 	dp_coc_ena = 1;
-	pr_debug("Register DP to CPUFREQ successfully.\n");
+	PR_INFO("Register DP to CPUFREQ successfully.\n");
 	return 0;
 }
 
 int dp_coc_cpufreq_exit(void)
 {
 	if (dp_coc_init_stat) {
-
+		int ret;
 		coc_lock();
+		ret = del_timer(&dp_coc_timer);
+		if (ret)
+			PR_ERR("The timer is still in use...\n");
 		dp_coc_init_stat = 0;
 		dp_coc_ena = 0;
 		coc_unlock();
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_misc.c b/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_misc.c
index 650b9f037927..5dcd309d3ad9 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_misc.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_misc.c
@@ -452,8 +452,11 @@ static int dp_platform_set(int inst, u32 flag)
 		mib_init(0);
 	dp_get_gsw_parser_30(NULL, NULL, NULL, NULL);
 #ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
-	if (!inst)
+	if (!inst) {
 		dp_coc_cpufreq_init();
+		if (flag == DP_PLATFORM_DE_INIT)
+			dp_coc_cpufreq_exit();
+	}
 #endif
 
 	return 0;
@@ -579,7 +582,6 @@ static int subif_hw_reset(int inst, int portid, int subif_ix,
 		       dp_deq_port_tbl[inst][cqe_deq].ref_cnt);
 		return -1;
 	}
-	DP_DEBUG(DP_DBG_FLAG_DBG, "cid=%d pid=%d nid=%d\n", cid, pid, nid);
 	dp_deq_port_tbl[inst][cqe_deq].ref_cnt--;
 	if (port_info->num_dma_chan)
 		atomic_dec(&(dp_dma_chan_tbl[inst] + dma_ch_offset)->ref_cnt);
