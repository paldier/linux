From f66d896491dab60b7c052ff0e8b98a6e5c5deb2f Mon Sep 17 00:00:00 2001
From: Xu Liang <liang.xu@intel.com>
Date: Tue, 3 Sep 2019 19:47:50 +0800
Subject: [PATCH] DRVLIB_SW-2908: GSW API - use lock_pce_tbl to prevent
 concurrent PCE Table and PAE Table access which use same set of registers

---
 .../net/ethernet/lantiq/switch-api/gsw_flow_core.c | 73 ++++++++++---------
 .../net/ethernet/lantiq/switch-api/gsw_flow_core.h | 82 +++++++++++-----------
 .../net/ethernet/lantiq/switch-api/gsw_tbl_rw.c    | 73 +++++++++++++++----
 3 files changed, 143 insertions(+), 85 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
index a4210e74a5d9..2716ea696b7b 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
@@ -3225,11 +3225,11 @@ void *ethsw_api_core_init(ethsw_core_init_t *ethcinit)
 	spin_lock_init(&PrvData->lock_misc);
 	spin_lock_init(&PrvData->lock_pmac);
 	spin_lock_init(&PrvData->lock_pae);
+	spin_lock_init(&PrvData->lock_ctp_map);
 	spin_lock_init(&PrvData->lock_irq);
-	spin_lock_init(&PrvData->lock_alloc);
-	spin_lock_init(&PrvData->lock_free);
 	spin_lock_init(&PrvData->lock_mdio);
 	spin_lock_init(&PrvData->lock_mmd);
+	spin_lock_init(&PrvData->lock_pce_tbl);
 
 	/* KERNEL_MODE*/
 #else
@@ -4608,7 +4608,7 @@ GSW_return_t GSW_STP_BPDU_RuleGet(void *cdev,
 	}
 
 #ifdef __KERNEL__
-	spin_lock_bh(&gswdev->lock_misc);
+	spin_lock_bh(&gswdev->lock_pce);
 #endif
 
 	scfg = &gswdev->stpconfig;
@@ -4617,7 +4617,7 @@ GSW_return_t GSW_STP_BPDU_RuleGet(void *cdev,
 	ret = GSW_statusOk;
 
 #ifdef __KERNEL__
-	spin_unlock_bh(&gswdev->lock_misc);
+	spin_unlock_bh(&gswdev->lock_pce);
 #endif
 	return ret;
 }
@@ -4693,7 +4693,7 @@ GSW_return_t GSW_STP_PortCfgGet(void *cdev, GSW_STP_portCfg_t *parm)
 	}
 
 #ifdef __KERNEL__
-	spin_lock_bh(&gswdev->lock_misc);
+	spin_lock_bh(&gswdev->lock_pce);
 #endif
 
 	if (IS_VRSN_NOT_31(gswdev->gipver)) {
@@ -4726,7 +4726,7 @@ GSW_return_t GSW_STP_PortCfgGet(void *cdev, GSW_STP_portCfg_t *parm)
 UNLOCK_AND_RETURN:
 
 #ifdef __KERNEL__
-	spin_unlock_bh(&gswdev->lock_misc);
+	spin_unlock_bh(&gswdev->lock_pce);
 #endif
 	return ret;
 }
@@ -10398,7 +10398,7 @@ GSW_return_t GSW_MulticastRouterPortRead(void *cdev,
 	}
 
 #ifdef __KERNEL__
-	spin_lock_bh(&gswdev->lock_misc);
+	spin_lock_bh(&gswdev->lock_pce);
 #endif
 
 	if ((IS_VRSN_31(gswdev->gipver)) && (gswdev->mcsthw_snoop == MCAST_HWSNOOP_DIS)) {
@@ -10448,7 +10448,7 @@ GSW_return_t GSW_MulticastRouterPortRead(void *cdev,
 UNLOCK_AND_RETURN:
 
 #ifdef __KERNEL__
-	spin_unlock_bh(&gswdev->lock_misc);
+	spin_unlock_bh(&gswdev->lock_pce);
 #endif
 	return ret;
 
@@ -10626,7 +10626,7 @@ GSW_return_t GSW_MulticastSnoopCfgGet(void *cdev,
 	}
 
 #ifdef __KERNEL__
-	spin_lock_bh(&gswdev->lock_misc);
+	spin_lock_bh(&gswdev->lock_pce);
 #endif
 
 	if ((IS_VRSN_31(gswdev->gipver)) && (gswdev->mcsthw_snoop == MCAST_HWSNOOP_DIS)) {
@@ -10700,7 +10700,7 @@ GSW_return_t GSW_MulticastSnoopCfgGet(void *cdev,
 UNLOCK_AND_RETURN:
 
 #ifdef __KERNEL__
-	spin_unlock_bh(&gswdev->lock_misc);
+	spin_unlock_bh(&gswdev->lock_pce);
 #endif
 	return ret;
 
@@ -17007,14 +17007,14 @@ GSW_return_t GSW_8021X_EAPOL_RuleGet(void *cdev, GSW_8021X_EAPOL_Rule_t *parm)
 	}
 
 #ifdef __KERNEL__
-	spin_lock_bh(&gswdev->lock_misc);
+	spin_lock_bh(&gswdev->lock_pce);
 #endif
 	parm->eForwardPort = scfg->sfport;
 	parm->nForwardPortId = scfg->fpid8021x;
 	ret = GSW_statusOk;
 
 #ifdef __KERNEL__
-	spin_unlock_bh(&gswdev->lock_misc);
+	spin_unlock_bh(&gswdev->lock_pce);
 #endif
 	return ret;
 }
@@ -17091,7 +17091,7 @@ GSW_return_t GSW_8021X_PortCfgGet(void *cdev, GSW_8021X_portCfg_t *parm)
 	}
 
 #ifdef __KERNEL__
-	spin_lock_bh(&gswdev->lock_misc);
+	spin_lock_bh(&gswdev->lock_pce);
 #endif
 
 	if (IS_VRSN_NOT_31(gswdev->gipver)) {
@@ -17126,7 +17126,7 @@ GSW_return_t GSW_8021X_PortCfgGet(void *cdev, GSW_8021X_portCfg_t *parm)
 UNLOCK_AND_RETURN:
 
 #ifdef __KERNEL__
-	spin_unlock_bh(&gswdev->lock_misc);
+	spin_unlock_bh(&gswdev->lock_pce);
 #endif
 	return ret;
 
@@ -18288,7 +18288,7 @@ GSW_return_t GSW_CTP_PortAssignmentAlloc(void *cdev, GSW_CTP_portAssignment_t *p
 	}
 
 #ifdef __KERNEL__
-	spin_lock_bh(&gswdev->lock_alloc);
+	spin_lock_bh(&gswdev->lock_ctp_map);
 #endif
 
 	if (!(gswdev->brdgeportconfig_idx[parm->nBridgePortId].IndexInUse)) {
@@ -18372,7 +18372,7 @@ GSW_return_t GSW_CTP_PortAssignmentAlloc(void *cdev, GSW_CTP_portAssignment_t *p
 UNLOCK_AND_RETURN:
 
 #ifdef __KERNEL__
-	spin_unlock_bh(&gswdev->lock_alloc);
+	spin_unlock_bh(&gswdev->lock_ctp_map);
 #endif
 	return ret;
 }
@@ -18388,7 +18388,7 @@ GSW_return_t GSW_CTP_PortAssignmentFree(void *cdev, GSW_CTP_portAssignment_t *pa
 	}
 
 #ifdef __KERNEL__
-	spin_lock_bh(&gswdev->lock_free);
+	spin_lock_bh(&gswdev->lock_ctp_map);
 #endif
 
 	ret = GSW_CTP_PortAssignmentGet(cdev, parm);
@@ -18403,15 +18403,24 @@ GSW_return_t GSW_CTP_PortAssignmentFree(void *cdev, GSW_CTP_portAssignment_t *pa
 	for (i = parm->nFirstCtpPortId; i < (parm->nFirstCtpPortId + parm->nNumberOfCtpPort); i++)
 		gswdev->ctpportconfig_idx[i].IndexInUse = 0;
 
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
 	/*Disable the SDMA for this logical port*/
 	gsw_w32(cdev, (SDMA_PCTRL_PEN_OFFSET + (parm->nLogicalPortId * 0x6)),
 		SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE, 0);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+
 	ret = GSW_statusOk;
 
 UNLOCK_AND_RETURN:
 
 #ifdef __KERNEL__
-	spin_unlock_bh(&gswdev->lock_free);
+	spin_unlock_bh(&gswdev->lock_ctp_map);
 #endif
 	return ret;
 }
@@ -19294,7 +19303,7 @@ GSW_return_t GSW_ExtendedVlanAlloc(void *cdev, GSW_EXTENDEDVLAN_alloc_t *parm)
 	}
 
 #ifdef __KERNEL__
-	spin_lock_bh(&gswdev->lock_alloc);
+	spin_lock_bh(&gswdev->lock_pce);
 #endif
 
 	/*
@@ -19340,7 +19349,7 @@ GSW_return_t GSW_ExtendedVlanAlloc(void *cdev, GSW_EXTENDEDVLAN_alloc_t *parm)
 UNLOCK_AND_RETURN:
 
 #ifdef __KERNEL__
-	spin_unlock_bh(&gswdev->lock_alloc);
+	spin_unlock_bh(&gswdev->lock_pce);
 #endif
 	return ret;
 }
@@ -20783,7 +20792,7 @@ GSW_return_t GSW_VlanFilterAlloc(void *cdev, GSW_VLANFILTER_alloc_t *param)
 	}
 
 #ifdef __KERNEL__
-	spin_lock_bh(&gswdev->lock_alloc);
+	spin_lock_bh(&gswdev->lock_pce);
 #endif
 
 	if (param->nNumberOfEntries > (gswdev->num_of_vlanfilter - gswdev->vlanfilter_idx.nUsedEntry)) {
@@ -20831,7 +20840,7 @@ GSW_return_t GSW_VlanFilterAlloc(void *cdev, GSW_VLANFILTER_alloc_t *param)
 UNLOCK_AND_RETURN:
 
 #ifdef __KERNEL__
-	spin_unlock_bh(&gswdev->lock_alloc);
+	spin_unlock_bh(&gswdev->lock_pce);
 #endif
 	return ret;
 
@@ -21102,7 +21111,7 @@ GSW_return_t GSW_BridgeAlloc(void *cdev, GSW_BRIDGE_alloc_t *param)
 	}
 
 #ifdef __KERNEL__
-	spin_lock_bh(&gswdev->lock_alloc);
+	spin_lock_bh(&gswdev->lock_pce);
 #endif
 
 	/*find a free Bridge configuration table index and allocate
@@ -21127,7 +21136,7 @@ GSW_return_t GSW_BridgeAlloc(void *cdev, GSW_BRIDGE_alloc_t *param)
 UNLOCK_AND_RETURN:
 
 #ifdef __KERNEL__
-	spin_unlock_bh(&gswdev->lock_alloc);
+	spin_unlock_bh(&gswdev->lock_pce);
 #endif
 	return ret;
 }
@@ -21920,7 +21929,7 @@ GSW_return_t GSW_BridgePortAlloc(void *cdev, GSW_BRIDGE_portAlloc_t *param)
 	}
 
 #ifdef __KERNEL__
-	spin_lock_bh(&gswdev->lock_alloc);
+	spin_lock_bh(&gswdev->lock_pce);
 #endif
 
 	/*Find a free Bridge port configuration table index
@@ -21986,7 +21995,7 @@ GSW_return_t GSW_BridgePortAlloc(void *cdev, GSW_BRIDGE_portAlloc_t *param)
 UNLOCK_AND_RETURN:
 
 #ifdef __KERNEL__
-	spin_unlock_bh(&gswdev->lock_alloc);
+	spin_unlock_bh(&gswdev->lock_pce);
 #endif
 	return ret;
 }
@@ -25793,7 +25802,7 @@ GSW_return_t GSW_QOS_MeterAlloc(void *cdev, GSW_QoS_meterCfg_t *param)
 	}
 
 #ifdef __KERNEL__
-	spin_lock_bh(&gswdev->lock_alloc);
+	spin_lock_bh(&gswdev->lock_misc);
 #endif
 
 	/*Find free meter indexand allocate*/
@@ -25827,7 +25836,7 @@ GSW_return_t GSW_QOS_MeterAlloc(void *cdev, GSW_QoS_meterCfg_t *param)
 UNLOCK_AND_RETURN:
 
 #ifdef __KERNEL__
-	spin_unlock_bh(&gswdev->lock_alloc);
+	spin_unlock_bh(&gswdev->lock_misc);
 #endif
 	return ret;
 }
@@ -25843,7 +25852,7 @@ GSW_return_t GSW_QOS_MeterFree(void *cdev, GSW_QoS_meterCfg_t *param)
 	}
 
 #ifdef __KERNEL__
-	spin_lock_bh(&gswdev->lock_free);
+	spin_lock_bh(&gswdev->lock_misc);
 #endif
 
 	if (param->nMeterId >= gswdev->num_of_meters) {
@@ -25877,7 +25886,7 @@ GSW_return_t GSW_QOS_MeterFree(void *cdev, GSW_QoS_meterCfg_t *param)
 UNLOCK_AND_RETURN:
 
 #ifdef __KERNEL__
-	spin_unlock_bh(&gswdev->lock_free);
+	spin_unlock_bh(&gswdev->lock_misc);
 #endif
 	return ret;
 }
@@ -26693,7 +26702,7 @@ GSW_return_t gsw_tflow_alloc(void *cdev, gsw_tflow_alloc_t *parm)
 	}
 
 #ifdef __KERNEL__
-	spin_lock_bh(&gswdev->lock_alloc);
+	spin_lock_bh(&gswdev->lock_pce);
 #endif
 
 	parm->num_of_pcerules = (parm->num_of_pcerules + 3) & ~0x03;
@@ -26748,7 +26757,7 @@ GSW_return_t gsw_tflow_alloc(void *cdev, gsw_tflow_alloc_t *parm)
 UNLOCK_AND_RETURN:
 
 #ifdef __KERNEL__
-	spin_unlock_bh(&gswdev->lock_alloc);
+	spin_unlock_bh(&gswdev->lock_pce);
 #endif
 	return ret;
 }
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
index 6618585596fe..85ca32bd90e9 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
@@ -937,13 +937,13 @@ typedef struct {
 	/*platform device struct*/
 	void *pdev;
 	u16 pnum;
-	u16 tpnum;					/* Total number of ports including vitual ports*/
-	u16 mpnum; 					/* ManagementPortNumber */
+	u16 tpnum;			/* Total number of ports including vitual ports*/
+	u16 mpnum; 			/* ManagementPortNumber */
 	u32 matimer;
 	ltq_bool_t rst;
 	ltq_bool_t hwinit;
-	u16 vlan_rd_index; 			/* read VLAN table index */
-	u16 mac_rd_index; 			/* read mac table index */
+	u16 vlan_rd_index; 		/* read VLAN table index */
+	u16 mac_rd_index; 		/* read mac table index */
 	u16 mhw_rinx;
 	u16 msw_rinx;
 	u8 cport;
@@ -953,55 +953,55 @@ typedef struct {
 	u32 ext_devid;
 	u32 ext_phyid;
 
-	u16 mrtpcnt;			 	/* multicast router port count */
+	u16 mrtpcnt;			/* multicast router port count */
 	u16 meter_cnt;
-	u16 num_of_queues; 			/* Number of priority queues . */
+	u16 num_of_queues; 		/* Number of priority queues . */
 	u16 num_of_meters;  		/* Number of traffic meters */
 	u16 num_of_shapers; 		/* Number of traffic shapers */
-	u16 num_of_pppoe;			/* PPPoE table size  */
-	u16 avlantsz; 				/* Active VLAN table size */
+	u16 num_of_pppoe;		/* PPPoE table size  */
+	u16 avlantsz; 			/* Active VLAN table size */
 	u16 ip_pkt_lnt_size;	 	/* IP packet length table size */
 	u16 prot_table_size;	 	/* Protocol table size */
 	u16 mac_dasa_table_size; 	/* MAC DA/SA table size */
-	u16 app_table_size;			/* Application table size */
-	u16 idsmtblsize;			/* IP DA/SA MSB table size */
-	u16 idsltblsize;			/* IP DA/SA LSB table size*/
-	u16 mctblsize;				/* Multicast table size */
-	u16 tftblsize;				/* Flow Aggregation table size */
-	u16 mactblsize;				/* MAC bridging table size */
-	u16 num_of_pmac;			/* Number of PMAC */
-	u16 pdtblsize;				/* Payload Table Size  */
-	u16 num_of_ifrmon;			/* Interface RMON Counter Table Size */
-	u16 num_of_egvlan;			/* Egress VLAN Treatment Table Size */
-	u16 num_of_rt_smac;			/* Routing MAC Table Size for Source MAC */
-	u16 num_of_rt_dmac;			/* Routing MAC Table Size for Destination MAC */
-	u16 num_of_rt_ppoe;			/* Routing PPPoE Table Size  */
-	u16 num_of_rt_nat;			/* Routing Session Table Size */
-	u16 num_of_rt_mtu;			/* Routing MTU Table Size */
+	u16 app_table_size;		/* Application table size */
+	u16 idsmtblsize;		/* IP DA/SA MSB table size */
+	u16 idsltblsize;		/* IP DA/SA LSB table size*/
+	u16 mctblsize;			/* Multicast table size */
+	u16 tftblsize;			/* Flow Aggregation table size */
+	u16 mactblsize;			/* MAC bridging table size */
+	u16 num_of_pmac;		/* Number of PMAC */
+	u16 pdtblsize;			/* Payload Table Size  */
+	u16 num_of_ifrmon;		/* Interface RMON Counter Table Size */
+	u16 num_of_egvlan;		/* Egress VLAN Treatment Table Size */
+	u16 num_of_rt_smac;		/* Routing MAC Table Size for Source MAC */
+	u16 num_of_rt_dmac;		/* Routing MAC Table Size for Destination MAC */
+	u16 num_of_rt_ppoe;		/* Routing PPPoE Table Size  */
+	u16 num_of_rt_nat;		/* Routing Session Table Size */
+	u16 num_of_rt_mtu;		/* Routing MTU Table Size */
 	u16 num_of_rt_tunnel;		/* Routing Tunnel Table Size  */
-	u16 num_of_rt_rtp;			/* Routing RTP Table Size */
+	u16 num_of_rt_rtp;		/* Routing RTP Table Size */
 
-	u16 num_of_bridge;			/*Number of Bridge - Applicable for 3.1*/
+	u16 num_of_bridge;		/*Number of Bridge - Applicable for 3.1*/
 	u16 num_of_bridge_port;		/*Number of Bridge Port - Applicable for 3.1*/
-	u16 num_of_ctp;				/*Number of CTP port - Applicable for 3.1 */
+	u16 num_of_ctp;			/*Number of CTP port - Applicable for 3.1 */
 	u16 num_of_extendvlan;		/*Number of extended VLAN tagging operation index in table  - Applicable for 3.1 */
 	u16 num_of_vlanfilter;		/*Number of VLAN Filter index in table  - Applicable for 3.1 */
-	u16 num_of_pmapper;			/*Number of pmapper index in table  - Applicable for 3.1
-								  p-mapper total entry 2336/73=32 number of index (i.e) each pmapper idx
-								  has 73 entries*/
-	u16 mcsthw_snoop;			/*Multicast HW snooping feature */
+	u16 num_of_pmapper;		/*Number of pmapper index in table  - Applicable for 3.1
+					  p-mapper total entry 2336/73=32 number of index (i.e) each pmapper idx
+					  has 73 entries*/
+	u16 mcsthw_snoop;		/*Multicast HW snooping feature */
 
 
 	u16 gipver;
-	void *gswl_base;			/*Base address GSWIP-L */
-	void *gswr_base; 		 	/*Base address GSWIP-R */
-	u32 gswex_base; 		 	/*Base address GSWIP External switch */
-	u32	gswex_sgmiibase; 		/*Base address GSWIP External switch-SGMII */
-
-	void *gsw_base;  			/*Base address GSWITCH */
-	u32 gsw_mode;				/* GSWIP Mode 0 "short_cut", 1 "full_qos" */
-	u32 dpu;			        /* DPU = 1, pmac G.INT config, DPU = 0, Non-G.INT config */
-	u32 num_of_global_rules;    /* Number of Global(Common) TFLOW Rules */
+	void *gswl_base;		/*Base address GSWIP-L */
+	void *gswr_base;		/*Base address GSWIP-R */
+	u32 gswex_base;			/*Base address GSWIP External switch */
+	u32 gswex_sgmiibase;		/*Base address GSWIP External switch-SGMII */
+
+	void *gsw_base;			/*Base address GSWITCH */
+	u32 gsw_mode;			/* GSWIP Mode 0 "short_cut", 1 "full_qos" */
+	u32 dpu;			/* DPU = 1, pmac G.INT config, DPU = 0, Non-G.INT config */
+	u32 num_of_global_rules;	/* Number of Global(Common) TFLOW Rules */
 	u16 hitstatus_idx;
 	u16 hitstatus_mask;
 
@@ -1011,11 +1011,11 @@ typedef struct {
 	spinlock_t lock_pmac;
 	spinlock_t lock_misc;
 	spinlock_t lock_pae;
-	spinlock_t lock_alloc;
-	spinlock_t lock_free;
+	spinlock_t lock_ctp_map;
 	spinlock_t lock_irq;
 	spinlock_t lock_mdio;
 	spinlock_t lock_mmd;
+	spinlock_t lock_pce_tbl;	/* lock of PCE Table register */
 	struct tasklet_struct gswip_tasklet;
 #endif
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_tbl_rw.c b/drivers/net/ethernet/lantiq/switch-api/gsw_tbl_rw.c
index ee24cc9363d1..5d742828fc18 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_tbl_rw.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_tbl_rw.c
@@ -153,6 +153,7 @@ int xwayflow_pmac_table_write(void *cdev, pmtbl_prog_t *ptdata)
 
 int route_table_read(void *cdev, pctbl_prog_t *rdata)
 {
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
 	u32 value;
 
 	do {
@@ -161,6 +162,10 @@ int route_table_read(void *cdev, pctbl_prog_t *rdata)
 			PCE_RTBL_CTRL_BAS_SIZE, &value);
 	} while (value != 0);
 
+#ifdef __KERNEL__
+	spin_lock(&gswdev->lock_pce_tbl);
+#endif
+
 	gsw_w32(cdev, PCE_TBL_ADDR_ADDR_OFFSET,
 		PCE_TBL_ADDR_ADDR_SHIFT,
 		PCE_TBL_ADDR_ADDR_SIZE, rdata->pcindex);
@@ -318,11 +323,17 @@ int route_table_read(void *cdev, pctbl_prog_t *rdata)
 		PCE_RTBL_CTRL_VLD_SIZE, &value);
 	rdata->valid = value;
 	gsw_w32(cdev, PCE_TBL_CTRL_ADDR_OFFSET, 0, 16, 0);
+
+#ifdef __KERNEL__
+	spin_unlock(&gswdev->lock_pce_tbl);
+#endif
+
 	return GSW_statusOk;
 }
 
 int route_table_write(void *cdev, pctbl_prog_t *rdata)
 {
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
 	u32 value;
 	u16 udata;
 
@@ -332,6 +343,10 @@ int route_table_write(void *cdev, pctbl_prog_t *rdata)
 			PCE_RTBL_CTRL_BAS_SIZE, &value);
 	} while (value);
 
+#ifdef __KERNEL__
+	spin_lock(&gswdev->lock_pce_tbl);
+#endif
+
 	gsw_w32(cdev, PCE_TBL_ADDR_ADDR_OFFSET,
 		PCE_TBL_ADDR_ADDR_SHIFT, PCE_TBL_ADDR_ADDR_SIZE,
 		rdata->pcindex);
@@ -460,6 +475,11 @@ int route_table_write(void *cdev, pctbl_prog_t *rdata)
 	} while (value != 0);
 
 	gsw_w32(cdev, PCE_TBL_CTRL_ADDR_OFFSET, 0, 16, 0);
+
+#ifdef __KERNEL__
+	spin_unlock(&gswdev->lock_pce_tbl);
+#endif
+
 	return GSW_statusOk;
 }
 
@@ -467,7 +487,6 @@ int gsw_pce_table_write(void *cdev, pctbl_prog_t *ptdata)
 {
 	u32 ctrlval;
 	u16 i, j;
-	//pr_err("Enter table write\n");
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
 
 	if (gswdev == NULL) {
@@ -480,8 +499,13 @@ int gsw_pce_table_write(void *cdev, pctbl_prog_t *ptdata)
 	} while (gsw_field_r32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
 			       PCE_TBL_CTRL_BAS_SIZE));
 
+#ifdef __KERNEL__
+	spin_lock(&gswdev->lock_pce_tbl);
+#endif
+
 	gsw_w32_raw(cdev, PCE_TBL_ADDR_ADDR_OFFSET, ptdata->pcindex);
 	/*TABLE ADDRESS*/
+	ctrlval = 0;
 	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_ADDR_SHIFT,
 				PCE_TBL_CTRL_ADDR_SIZE, ptdata->table);
 	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_OPMOD_SHIFT,
@@ -529,7 +553,10 @@ int gsw_pce_table_write(void *cdev, pctbl_prog_t *ptdata)
 			       PCE_TBL_CTRL_BAS_SIZE));
 
 	gsw_w32_raw(cdev, PCE_TBL_CTRL_ADDR_OFFSET, 0);
-	//pr_err("Exit table write\n");
+
+#ifdef __KERNEL__
+	spin_unlock(&gswdev->lock_pce_tbl);
+#endif
 
 	return GSW_statusOk;
 }
@@ -538,7 +565,6 @@ int gsw_pce_table_read(void *cdev, pctbl_prog_t *ptdata)
 {
 	u32 ctrlval, value;
 	u16 i, j;
-	//pr_err("Enter table read\n");
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
 
 	if (gswdev == NULL) {
@@ -551,8 +577,13 @@ int gsw_pce_table_read(void *cdev, pctbl_prog_t *ptdata)
 	} while (gsw_field_r32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
 			       PCE_TBL_CTRL_BAS_SIZE));
 
+#ifdef __KERNEL__
+	spin_lock(&gswdev->lock_pce_tbl);
+#endif
+
 	gsw_w32_raw(cdev, PCE_TBL_ADDR_ADDR_OFFSET, ptdata->pcindex);
 	/*TABLE ADDRESS*/
+	ctrlval = 0;
 	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_ADDR_SHIFT,
 				PCE_TBL_CTRL_ADDR_SIZE, ptdata->table);
 	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_OPMOD_SHIFT,
@@ -602,7 +633,10 @@ int gsw_pce_table_read(void *cdev, pctbl_prog_t *ptdata)
 	ptdata->group = gsw_field_r32(ctrlval, PCE_TBL_CTRL_GMAP_SHIFT,
 				      PCE_TBL_CTRL_GMAP_SIZE);
 	gsw_w32_raw(cdev, PCE_TBL_CTRL_ADDR_OFFSET, 0);
-	//pr_err("Exit table read\n");
+
+#ifdef __KERNEL__
+	spin_unlock(&gswdev->lock_pce_tbl);
+#endif
 
 	return GSW_statusOk;
 }
@@ -611,7 +645,6 @@ int gsw_pce_table_key_read(void *cdev, pctbl_prog_t *ptdata)
 {
 	u32 ctrlval, value;
 	u16 i, j;
-	//pr_err("Enter table key read\n");
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
 
 	if (gswdev == NULL) {
@@ -624,8 +657,9 @@ int gsw_pce_table_key_read(void *cdev, pctbl_prog_t *ptdata)
 	} while (gsw_field_r32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
 			       PCE_TBL_CTRL_BAS_SIZE));
 
-	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_ADDR_SHIFT,
-				PCE_TBL_CTRL_ADDR_SIZE, ptdata->table);
+#ifdef __KERNEL__
+	spin_lock(&gswdev->lock_pce_tbl);
+#endif
 
 	/*KEY REG*/
 	j = gswdev->pce_tbl_info[ptdata->table].num_key;
@@ -634,6 +668,9 @@ int gsw_pce_table_key_read(void *cdev, pctbl_prog_t *ptdata)
 		gsw_w32_raw(cdev, gswdev->pce_tbl_reg.key[i], ptdata->key[i]);
 	}
 
+	ctrlval = 0;
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_ADDR_SHIFT,
+				PCE_TBL_CTRL_ADDR_SIZE, ptdata->table);
 	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_OPMOD_SHIFT,
 				PCE_TBL_CTRL_OPMOD_SIZE, PCE_OP_MODE_KSRD);
 	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_KEYFORM_SHIFT,
@@ -664,7 +701,10 @@ int gsw_pce_table_key_read(void *cdev, pctbl_prog_t *ptdata)
 	gsw_r32_raw(cdev, PCE_TBL_ADDR_ADDR_OFFSET, &value);
 	ptdata->pcindex = value;
 	gsw_w32_raw(cdev, PCE_TBL_CTRL_ADDR_OFFSET, 0);
-	//pr_err("Exit table key read\n");
+
+#ifdef __KERNEL__
+	spin_unlock(&gswdev->lock_pce_tbl);
+#endif
 
 	return GSW_statusOk;
 }
@@ -673,7 +713,6 @@ int gsw_pce_table_key_write(void *cdev, pctbl_prog_t *ptdata)
 {
 	u32 ctrlval;
 	u16 i, j;
-	//pr_err("Enter table key write\n");
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
 
 	if (gswdev == NULL) {
@@ -681,11 +720,18 @@ int gsw_pce_table_key_write(void *cdev, pctbl_prog_t *ptdata)
 		return GSW_statusErr;
 	}
 
+	
 	do {
 		gsw_r32_raw(cdev, PCE_TBL_CTRL_BAS_OFFSET, &ctrlval);
 	} while (gsw_field_r32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
 			       PCE_TBL_CTRL_BAS_SIZE));
 
+#ifdef __KERNEL__
+	spin_lock(&gswdev->lock_pce_tbl);
+#endif
+
+	ctrlval = 0;
+
 	/*TABLE ADDRESS*/
 	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_ADDR_SHIFT,
 				PCE_TBL_CTRL_ADDR_SIZE, ptdata->table);
@@ -731,7 +777,10 @@ int gsw_pce_table_key_write(void *cdev, pctbl_prog_t *ptdata)
 			       PCE_TBL_CTRL_BAS_SIZE));
 
 	gsw_w32_raw(cdev, PCE_TBL_CTRL_ADDR_OFFSET, 0);
-	//pr_err("Exit table key write\n");
+
+#ifdef __KERNEL__
+	spin_unlock(&gswdev->lock_pce_tbl);
+#endif
 
 	return GSW_statusOk;
 }
@@ -768,12 +817,12 @@ GSW_return_t GSW_DumpTable(void *cdev, GSW_table_t *parm)
 		parm->ptdata.table = parm->tbl_addr;
 
 #ifdef __KERNEL__
-		spin_lock_bh(&gswdev->lock_pce);
+		spin_lock_bh(&gswdev->lock_pae);
 #endif
 		route_table_read(gsw_ops, &parm->ptdata);
 
 #ifdef __KERNEL__
-		spin_unlock_bh(&gswdev->lock_pce);
+		spin_unlock_bh(&gswdev->lock_pae);
 #endif
 
 	}
