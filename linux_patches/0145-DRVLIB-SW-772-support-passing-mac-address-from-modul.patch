From 8c3505eef7bbfcdfaeaf885b9f8ad78f5d3c9b68 Mon Sep 17 00:00:00 2001
From: "Ma, Hua" <hua.ma@intel.com>
Date: Thu, 5 Jul 2018 14:07:12 +0800
Subject: [PATCH] DRVLIB_SW-772: support passing mac address from module
 parameter

- support passing mac address from module parameter
- use random mac address when nothing is provided
---
 drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c | 71 +++++++++++++-----------
 1 file changed, 38 insertions(+), 33 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
index e5bf79901d49..e85777758efc 100644
--- a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
+++ b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
@@ -44,8 +44,6 @@
  * and dev->eth_tx_timeout() should be called to fix the problem
  */
 #define LTQ_TX_TIMEOUT		(10 * HZ)
-#define MY_ETH0_ADDR g_my_ethaddr
-#define LTQ_ETHWAN_PORT 6
 #define MDIO_PHY_ADDR_MASK	0x001f
 #define MDIO_PHY_LINK_DOWN	0x4000
 #define MDIO_PHY_LINK_UP	0x2000
@@ -108,7 +106,9 @@ static enum ltq_cpufreq_state g_ltq_eth_drv_coc_state = LTQ_CPUFREQ_PS_D0;
 static struct xrx500_hw xrx500_hw;
 
 static char wan_iface[IFNAMSIZ] = "eth1";
-static u8 g_my_ethaddr[MAX_ADDR_LEN * 2] = {0};
+static char *macaddr0;
+static char *macaddr1;
+static int multimac = 1;
 
 static struct module g_ltq_eth_module[NUM_ETH_INF];
 static u32 g_rx_csum_offload;
@@ -407,6 +407,7 @@ static int ltq_set_mac_address(struct net_device *dev, void *p)
 {
 	struct sockaddr *addr = p;
 
+	pr_debug("set_mac_addr called\n");
 	if (netif_running(dev))
 		return -EBUSY;
 
@@ -962,39 +963,36 @@ static int ltq_gsw_pmac_init(void)
 	return 0;
 }
 
-static void ltq_eth_drv_eth_addr_setup(struct net_device *dev, int port)
+static void
+ltq_eth_drv_eth_addr_setup(struct net_device *dev, int port, int wan)
 {
-	u8 *ethaddr;
-	u32 val;
-	int i;
+	int i = 0;
+	u8 *macaddr_param = NULL;
+	u8 values[ETH_ALEN] = {0};
 
-	if (port == LTQ_ETHWAN_PORT)
-		ethaddr = MY_ETH0_ADDR + MAX_ADDR_LEN;
+	if (is_valid_ether_addr(dev->dev_addr))
+		return;
+
+	if (wan)
+		macaddr_param = macaddr1;
 	else
-		ethaddr = MY_ETH0_ADDR;
-
-	/*  read MAC address from the MAC table and put them into device */
-	for (i = 0, val = 0; i < 6; i++)
-		val += dev->dev_addr[i];
-
-	if (val == 0) {
-		for (i = 0, val = 0; i < 6; i++)
-			val += ethaddr[i];
-
-		if (val == 0) {
-			/*  ethaddr not set in u-boot   */
-			dev->dev_addr[0] = 0x00;
-			dev->dev_addr[1] = 0x20;
-			dev->dev_addr[2] = 0xda;
-			dev->dev_addr[3] = 0x86;
-			dev->dev_addr[4] = 0x23;
-			dev->dev_addr[5] = 0x74 + port;
-		} else {
-			for (i = 0; i < 5; i++)
-				dev->dev_addr[i] = ethaddr[i];
+		macaddr_param = macaddr0;
 
-			dev->dev_addr[5] = ethaddr[i] + port;
-		}
+	if (macaddr_param) {
+		mac_pton(macaddr_param, values);
+		pr_debug("mac addr %s\n", macaddr_param);
+	}
+
+	/* read MAC address from the MAC table and put them into device */
+	if (is_valid_ether_addr(values)) {
+		pr_debug("using module param for port %d.\n", port);
+		for (i = 0; i < ETH_ALEN; i++)
+			dev->dev_addr[i] = values[i];
+		if (multimac)
+			dev->dev_addr[ETH_ALEN - 1] += port;
+	} else {
+		eth_hw_addr_random(dev);
+		pr_debug("using random mac for port %d.\n", port);
 	}
 }
 
@@ -1347,7 +1345,7 @@ static int xrx500_of_iface(struct xrx500_hw *hw, struct device_node *iface,
 	} else {
 		pr_info("%s: rx csum offload is disabled !\n", __func__);
 	}
-	ltq_eth_drv_eth_addr_setup(hw->devs[hw->num_devs], priv->id);
+	ltq_eth_drv_eth_addr_setup(hw->devs[hw->num_devs], priv->id, priv->wan);
 
 	/* register the actual device */
 	if (!register_netdev(hw->devs[hw->num_devs]))
@@ -2157,6 +2155,13 @@ static struct platform_driver ltq_eth_driver = {
 
 module_platform_driver(ltq_eth_driver);
 
+module_param(macaddr0, charp, 0644);
+module_param(macaddr1, charp, 0644);
+module_param(multimac, int, 0644);
+MODULE_PARM_DESC(macaddr0, "eth0 MAC address");
+MODULE_PARM_DESC(macaddr1, "eth1 MAC address");
+MODULE_PARM_DESC(multimac, "Multi MAC address for ports");
+
 MODULE_DESCRIPTION("Intel ethernet driver");
 MODULE_LICENSE("GPL v2");
 MODULE_VERSION(DRV_MODULE_VERSION);
