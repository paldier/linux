From 0e02d179d7b194024496ce31e64e21a5647ccf7b Mon Sep 17 00:00:00 2001
From: Hua Ma <hua.ma@linux.intel.com>
Date: Thu, 21 Jun 2018 17:37:50 +0800
Subject: [PATCH] Add support for lantiq switch api common

---
 drivers/net/ethernet/lantiq/switch-api/Kconfig     |    68 +
 drivers/net/ethernet/lantiq/switch-api/LICENSE     |   368 +
 drivers/net/ethernet/lantiq/switch-api/Makefile    |    48 +
 .../net/ethernet/lantiq/switch-api/gsw30_reg_top.h |   991 +
 drivers/net/ethernet/lantiq/switch-api/gsw_debug.c |  1205 +
 .../net/ethernet/lantiq/switch-api/gsw_defconf.c   |   702 +
 .../net/ethernet/lantiq/switch-api/gsw_defconf.h   |    66 +
 .../net/ethernet/lantiq/switch-api/gsw_flow_core.c | 26730 +++++++++++++++++++
 .../net/ethernet/lantiq/switch-api/gsw_flow_core.h |  1009 +
 .../net/ethernet/lantiq/switch-api/gsw_flow_pce.c  |  4661 ++++
 .../net/ethernet/lantiq/switch-api/gsw_gphy_fw.c   |  1377 +
 drivers/net/ethernet/lantiq/switch-api/gsw_init.c  |  1258 +
 drivers/net/ethernet/lantiq/switch-api/gsw_init.h  |   269 +
 .../ethernet/lantiq/switch-api/gsw_ioctl_wrapper.c |   473 +
 .../ethernet/lantiq/switch-api/gsw_ioctl_wrapper.h |   103 +
 drivers/net/ethernet/lantiq/switch-api/gsw_irq.c   |   746 +
 .../net/ethernet/lantiq/switch-api/gsw_ll_func.h   |  3452 +++
 .../net/ethernet/lantiq/switch-api/gsw_ll_table.c  |   545 +
 drivers/net/ethernet/lantiq/switch-api/gsw_pae.c   |  2290 ++
 drivers/net/ethernet/lantiq/switch-api/gsw_pae.h   |   148 +
 drivers/net/ethernet/lantiq/switch-api/gsw_reg.h   |  4410 +++
 .../net/ethernet/lantiq/switch-api/gsw_reg_top.h   |   859 +
 .../net/ethernet/lantiq/switch-api/gsw_swmcast.c   |   877 +
 .../net/ethernet/lantiq/switch-api/gsw_swmcast.h   |    73 +
 .../net/ethernet/lantiq/switch-api/gsw_tbl_rw.c    |   820 +
 .../ethernet/lantiq/switch-api/gswip_dev/Makefile  |     6 +
 .../ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c |   769 +
 include/net/switch_api/adap_ops.h                  |   187 +
 include/net/switch_api/gsw_dev.h                   |   109 +
 include/net/switch_api/gsw_flow_ops.h              |   708 +
 include/net/switch_api/gsw_ioctlcmd_type.h         |    66 +
 include/net/switch_api/gsw_irq.h                   |    80 +
 include/net/switch_api/gsw_tbl_rw.h                |   164 +
 include/net/switch_api/gsw_types.h                 |    68 +
 include/net/switch_api/lantiq_gsw.h                |  7467 ++++++
 include/net/switch_api/lantiq_gsw_api.h            |    91 +
 include/net/switch_api/lantiq_gsw_flow.h           |  1344 +
 include/net/switch_api/lantiq_gsw_routing.h        |   395 +
 38 files changed, 65002 insertions(+)

diff --git a/drivers/net/ethernet/lantiq/switch-api/Kconfig b/drivers/net/ethernet/lantiq/switch-api/Kconfig
new file mode 100644
index 000000000000..45ca09d98050
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/Kconfig
@@ -0,0 +1,68 @@
+#
+# switch api configuration
+#
+config LTQ_ETHSW_API
+    tristate "Lantiq Ethernet Switch API"
+    default y
+    help
+    Support for Lantiq Ethernet Switch API.
+
+menu LTQ_GSW_API_OPTIONS
+ 
+config LTQ_8021X
+	depends on (LTQ_ETHSW_API && ((SOC_XWAY) || (SOC_GRX500) || (X86_INTEL_CE2700)))
+	default y
+	bool "Support LTQ ETHSW 802.1X Switch API's"
+    help
+    Supported Lantiq Switch API for 802.1X features.
+
+config LTQ_MULTICAST
+	depends on (LTQ_ETHSW_API && ((SOC_XWAY) || (SOC_GRX500) || (X86_INTEL_CE2700)))
+	default y
+	bool "Support LTQ ETHSW MULTICAST Switch API's"
+    help
+    Supported Lantiq Switch API for multicast features.
+    
+config LTQ_QOS
+	depends on (LTQ_ETHSW_API && ((SOC_XWAY) || (SOC_GRX500) || (X86_INTEL_CE2700)))
+	default y
+	bool "Support LTQ ETHSW QOS Switch API's"
+    help
+    Supported Lantiq Switch API for  Quality of Service (QoS) features.
+    
+config LTQ_STP
+	depends on (LTQ_ETHSW_API && ((SOC_XWAY) || (SOC_GRX500) || (X86_INTEL_CE2700)))
+	default y
+	bool "Support LTQ ETHSW STP Switch API's"
+    help
+    Supported Lantiq Switch API for Spanning  Tree  Protocol(STP) features.
+    
+config LTQ_VLAN
+	depends on (LTQ_ETHSW_API && ((SOC_XWAY) || (SOC_GRX500) || (X86_INTEL_CE2700)))
+	default y
+	bool "Support LTQ ETHSW VLAN Switch API's"
+    help
+    Supported Lantiq Switch API for VLAN features.
+
+config LTQ_WOL
+	depends on (LTQ_ETHSW_API && ((SOC_XWAY) || (SOC_GRX500) || (X86_INTEL_CE2700)))
+	default y
+	bool "Support LTQ ETHSW WOL Switch API's"
+    help
+    Supported Lantiq Switch API for Wake-On-Lan(WOL) features.
+
+config LTQ_PMAC
+	depends on (LTQ_ETHSW_API && ((SOC_XWAY) || (SOC_GRX500) || (X86_INTEL_CE2700)))
+	default y
+	bool "Support LTQ ETHSW PMAC Switch API's"
+    help
+    Supported Lantiq Switch API for PMAC Configuration features.
+
+config LTQ_RMON
+	depends on (LTQ_ETHSW_API && ((SOC_XWAY) || (SOC_GRX500) || (X86_INTEL_CE2700)))
+	default y
+	bool "Support LTQ ETHSW RMON Switch API's"
+    help
+    Supported Lantiq Switch API for RMON counter features.
+
+endmenu
diff --git a/drivers/net/ethernet/lantiq/switch-api/LICENSE b/drivers/net/ethernet/lantiq/switch-api/LICENSE
new file mode 100644
index 000000000000..180f3f1fb935
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/LICENSE
@@ -0,0 +1,368 @@
+This source code is distributed under a dual license of GPL and BSD (2-clause).
+Please choose the appropriate license for your intended usage.
+
+1. BSD license (2-clause BSD license)
+
+Copyright (c) 2009-2015, LANTIQ BETEILIGUNGS-GMBH & CO. KG
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  * Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+  * Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions and the following disclaimer in the documentation
+	and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+2.		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --git a/drivers/net/ethernet/lantiq/switch-api/Makefile b/drivers/net/ethernet/lantiq/switch-api/Makefile
new file mode 100644
index 000000000000..7fe13eb446ab
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/Makefile
@@ -0,0 +1,48 @@
+#
+# Makefile for the Switch API
+#
+#EXTRA_CFLAGS := -I./arch/mips/include/asm/mach-lantiq/switch-api
+obj-$(CONFIG_LTQ_ETHSW_API)	+= mac/
+obj-$(CONFIG_LTQ_ETHSW_API)	+= gswip_dev/
+obj-$(CONFIG_LTQ_ETHSW_API)	+= drv_switch_api.o
+
+
+ifeq ($(CONFIG_SOC_XWAY),y)
+	drv_switch_api-objs	:= ltq_ethsw_ioctl_wrapper.o
+	drv_switch_api-objs	+= ltq_ethsw_init.o
+	drv_switch_api-objs += ltq_gphy_fw.o
+
+  drv_switch_api-objs   += ltq_flow_core.o
+  drv_switch_api-objs   += ltq_flow_core_ll_table.o
+  drv_switch_api-objs   += ltq_flow_pce.o
+  drv_switch_api-objs   += ltq_flow_ral.o
+endif
+
+ifeq ($(CONFIG_SOC_GRX500),y)
+EXTRA_CFLAGS += -I$(src)/ -I$(src)/mac/
+	drv_switch_api-objs	:= gsw_ioctl_wrapper.o
+	drv_switch_api-objs	+= gsw_init.o
+	#drv_switch_api-objs += gsw_gphy_fw.o
+	
+  drv_switch_api-objs   += gsw_flow_core.o
+  drv_switch_api-objs   += gsw_ll_table.o
+  drv_switch_api-objs   += gsw_flow_pce.o
+  drv_switch_api-objs   += gsw_pae.o
+  drv_switch_api-objs   += gsw_swmcast.o
+  drv_switch_api-objs   += gsw_debug.o
+  drv_switch_api-objs   += gsw_defconf.o
+  drv_switch_api-objs   += gsw_irq.o
+  drv_switch_api-objs   += gsw_tbl_rw.o
+endif
+
+ifeq ($(CONFIG_X86_INTEL_CE2700),y)
+EXTRA_CFLAGS := -I./arch/mips/include/asm/mach-lantiq/
+
+	drv_switch_api-objs	:= gsw_ioctl_wrapper.o
+	drv_switch_api-objs	+= gsw_init.o
+
+  drv_switch_api-objs   += gsw_flow_core.o
+  drv_switch_api-objs   += gsw_ll_table.o
+  drv_switch_api-objs   += gsw_flow_pce.o
+  drv_switch_api-objs   += gsw_pae.o
+endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw30_reg_top.h b/drivers/net/ethernet/lantiq/switch-api/gsw30_reg_top.h
new file mode 100644
index 000000000000..5b907cfe3800
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw30_reg_top.h
@@ -0,0 +1,991 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+
+#ifndef _LTQ_GSW30_SOC_TOP_H_
+#define _LTQ_GSW30_SOC_TOP_H_
+
+/* ----------------------------------------------- */
+#define GSW30_TOP_OFFSET	0xF00	/* 0x3C00 */
+/* ----------------------------------------------- */
+/* Register: 'Global Control Register0' */
+/* Bit: 'SE' */
+/* Description: 'Global Switch Macro Enable' */
+#define GSWT_GCTRL_SE_OFFSET	0x000
+#define GSWT_GCTRL_SE_SHIFT	15
+#define GSWT_GCTRL_SE_SIZE	1
+/* Bit: 'HWRES' */
+/* Description: 'Global Hardware Reset' */
+#define GSWT_GCTRL_HWRES_OFFSET	0x000
+#define GSWT_GCTRL_HWRES_SHIFT	1
+#define GSWT_GCTRL_HWRES_SIZE		1
+/* Bit: 'SWRES' */
+/* Description: 'Global Software Reset' */
+#define GSWT_GCTRL_SWRES_OFFSET	0x000
+#define GSWT_GCTRL_SWRES_SHIFT	0
+#define GSWT_GCTRL_SWRES_SIZE		1
+/* ----------------------------------------------- */
+/* Register: 'MDIO Control Register' */
+/* Bit: 'MBUSY' */
+/* Description: 'MDIO Busy' */
+#define GSWT_MDCTRL_MBUSY_OFFSET	0x004
+#define GSWT_MDCTRL_MBUSY_SHIFT		12
+#define GSWT_MDCTRL_MBUSY_SIZE		1
+/* Bit: 'OP' */
+/* Description: 'Operation Code' */
+#define GSWT_MDCTRL_OP_OFFSET		0x004
+#define GSWT_MDCTRL_OP_SHIFT		10
+#define GSWT_MDCTRL_OP_SIZE			2
+/* Bit: 'PHYAD' */
+/* Description: 'PHY Address' */
+#define GSWT_MDCTRL_PHYAD_OFFSET	0x004
+#define GSWT_MDCTRL_PHYAD_SHIFT		5
+#define GSWT_MDCTRL_PHYAD_SIZE		5
+/* Bit: 'REGAD' */
+/* Description: 'Register Address' */
+#define GSWT_MDCTRL_REGAD_OFFSET	0x004
+#define GSWT_MDCTRL_REGAD_SHIFT		0
+#define GSWT_MDCTRL_REGAD_SIZE		5
+/* ----------------------------------------------- */
+/* Register: 'MDIO Read Data Register' */
+/* Bit: 'RDATA' */
+/* Description: 'Read Data' */
+#define GSWT_MDREAD_RDATA_OFFSET	0x005
+#define GSWT_MDREAD_RDATA_SHIFT		0
+#define GSWT_MDREAD_RDATA_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'MDIO Write Data Register' */
+/* Bit: 'WDATA' */
+/* Description: 'Write Data' */
+#define GSWT_MDWRITE_WDATA_OFFSET	0x006
+#define GSWT_MDWRITE_WDATA_SHIFT	0
+#define GSWT_MDWRITE_WDATA_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'MDC Clock ConfigurationRegister 0' */
+/* Bit: 'PEN_6' */
+/* Description: 'Polling State Machine Enable' */
+#define GSWT_MDCCFG_0_PEN_6_OFFSET	0x007
+#define GSWT_MDCCFG_0_PEN_6_SHIFT		6
+#define GSWT_MDCCFG_0_PEN_6_SIZE		1
+/* Bit: 'PEN_5' */
+/* Description: 'Polling State Machine Enable' */
+#define GSWT_MDCCFG_0_PEN_5_OFFSET	0x007
+#define GSWT_MDCCFG_0_PEN_5_SHIFT		5
+#define GSWT_MDCCFG_0_PEN_5_SIZE		1
+/* Bit: 'PEN_4' */
+/* Description: 'Polling State Machine Enable' */
+#define GSWT_MDCCFG_0_PEN_4_OFFSET	0x007
+#define GSWT_MDCCFG_0_PEN_4_SHIFT		4
+#define GSWT_MDCCFG_0_PEN_4_SIZE		1
+/* Bit: 'PEN_3' */
+/* Description: 'Polling State Machine Enable' */
+#define GSWT_MDCCFG_0_PEN_3_OFFSET	0x007
+#define GSWT_MDCCFG_0_PEN_3_SHIFT		3
+#define GSWT_MDCCFG_0_PEN_3_SIZE		1
+/* Bit: 'PEN_2' */
+/* Description: 'Polling State Machine Enable' */
+#define GSWT_MDCCFG_0_PEN_2_OFFSET	0x007
+#define GSWT_MDCCFG_0_PEN_2_SHIFT		2
+#define GSWT_MDCCFG_0_PEN_2_SIZE		1
+/* Bit: 'PEN_1' */
+/* Description: 'Polling State Machine Enable' */
+#define GSWT_MDCCFG_0_PEN_1_OFFSET	0x007
+#define GSWT_MDCCFG_0_PEN_1_SHIFT		1
+#define GSWT_MDCCFG_0_PEN_1_SIZE		1
+/* Bit: 'PEN_0' */
+/* Description: 'Polling State Machine Enable' */
+#define GSWT_MDCCFG_0_PEN_0_OFFSET	0x007
+#define GSWT_MDCCFG_0_PEN_0_SHIFT		0
+#define GSWT_MDCCFG_0_PEN_0_SIZE		1
+/* Bit: 'PEN_0~PEN_5' */
+/* Description: 'Polling State Machine Enable' */
+#define GSWT_MDCCFG_0_PEN_ALL_OFFSET	0x007
+#define GSWT_MDCCFG_0_PEN_ALL_SHIFT		1
+#define GSWT_MDCCFG_0_PEN_ALL_SIZE		6
+/* ----------------------------------------------- */
+/* Register: 'MDC Clock ConfigurationRegister 1' */
+/* Bit: 'RES' */
+/* Description: 'MDIO Hardware Reset' */
+#define GSWT_MDCCFG_1_RES_OFFSET	0x008
+#define GSWT_MDCCFG_1_RES_SHIFT		15
+#define GSWT_MDCCFG_1_RES_SIZE		1
+/* Bit: 'GAP' */
+/* Description: 'Autopolling Gap' */
+#define GSWT_MDCCFG_1_GAP_OFFSET	0x008
+#define GSWT_MDCCFG_1_GAP_SHIFT		9
+#define GSWT_MDCCFG_1_GAP_SIZE		6
+/* Bit: 'MCEN' */
+/* Description: 'Management Clock Enable' */
+#define GSWT_MDCCFG_1_MCEN_OFFSET	0x008
+#define GSWT_MDCCFG_1_MCEN_SHIFT	8
+#define GSWT_MDCCFG_1_MCEN_SIZE		1
+/* Bit: 'FREQ' */
+/* Description: 'MDIO Interface Clock Rate' */
+#define GSWT_MDCCFG_1_FREQ_OFFSET	0x008
+#define GSWT_MDCCFG_1_FREQ_SHIFT	0
+#define GSWT_MDCCFG_1_FREQ_SIZE		8
+/* ----------------------------------------------- */
+/* Register: 'xMII Port 1 ConfigurationRegister' */
+/* Bit: 'RES' */
+/* Description: 'Hardware Reset' */
+#define GSWT_MII_CFG_1_RES_OFFSET	0x09
+#define GSWT_MII_CFG_1_RES_SHIFT	15
+#define GSWT_MII_CFG_1_RES_SIZE		1
+/* Bit: 'EN' */
+/* Description: 'xMII Interface Enable' */
+#define GSWT_MII_CFG_1_EN_OFFSET		0x09
+#define GSWT_MII_CFG_1_EN_SHIFT	14
+#define GSWT_MII_CFG_1_EN_SIZE	1
+/* Bit: 'ISOL' */
+/* Description: 'ISOLATE xMII Interface' */
+#define GSWT_MII_CFG_1_ISOL_OFFSET		0x09
+#define GSWT_MII_CFG_1_ISOL_SHIFT	13
+#define GSWT_MII_CFG_1_ISOL_SIZE	1
+/* Bit: 'LDCLKDIS' */
+/* Description: 'Link Down Clock Disable' */
+#define GSWT_MII_CFG_1_LDCLKDIS_OFFSET	0x09
+#define GSWT_MII_CFG_1_LDCLKDIS_SHIFT	12
+#define GSWT_MII_CFG_1_LDCLKDIS_SIZE	1
+/* Bit: 'CRS' */
+/* Description: 'CRS Sensitivity Configuration' */
+#define GSWT_MII_CFG_1_CRS_OFFSET	0x09
+#define GSWT_MII_CFG_1_CRS_SHIFT	9
+#define GSWT_MII_CFG_1_CRS_SIZE		2
+/* Bit: 'RGMII_IBS' */
+/* Description: 'RGMII In Band Status' */
+#define GSWT_MII_CFG_1_RGMII_IBS_OFFSET	0x09
+#define GSWT_MII_CFG_1_RGMII_IBS_SHIFT	8
+#define GSWT_MII_CFG_1_RGMII_IBS_SIZE		1
+/* Bit: 'RMII' */
+/* Description: 'RMII Reference Clock Direction of the Port' */
+#define GSWT_MII_CFG_1_RMII_OFFSET	0x09
+#define GSWT_MII_CFG_1_RMII_SHIFT	7
+#define GSWT_MII_CFG_1_RMII_SIZE	1
+/* Bit: 'MIIRATE' */
+/* Description: 'xMII Port Interface Clock Rate' */
+#define GSWT_MII_CFG_1_MIIRATE_OFFSET	0x09
+#define GSWT_MII_CFG_1_MIIRATE_SHIFT	4
+#define GSWT_MII_CFG_1_MIIRATE_SIZE		3
+/* Bit: 'MIIMODE' */
+/* Description: 'xMII Interface Mode' */
+#define GSWT_MII_CFG_1_MIIMODE_OFFSET	0x09
+#define GSWT_MII_CFG_1_MIIMODE_SHIFT	0
+#define GSWT_MII_CFG_1_MIIMODE_SIZE		4
+/* ----------------------------------------------- */
+/* Register: 'Configuration of ClockDelay for Port 1' */
+/* Bit: 'RXLOCK' */
+/* Description: 'Lock Status MDL of Receive PCDU' */
+#define GSWT_PCDU_1_RXLOCK_OFFSET	0x0A
+#define GSWT_PCDU_1_RXLOCK_SHIFT	15
+#define GSWT_PCDU_1_RXLOCK_SIZE		1
+/* Bit: 'TXLOCK' */
+/* Description: 'Lock Status of MDL of Transmit PCDU' */
+#define GSWT_PCDU_1_TXLOCK_OFFSET	0x0A
+#define GSWT_PCDU_1_TXLOCK_SHIFT	14
+#define GSWT_PCDU_1_TXLOCK_SIZE		1
+/* Bit: 'DELMD' */
+/* Description: 'PCDU Setting Mode' */
+#define GSWT_PCDU_1_DELMD_OFFSET	0x0A
+#define GSWT_PCDU_1_DELMD_SHIFT	10
+#define GSWT_PCDU_1_DELMD_SIZE	1
+/* Bit: 'RXDLY' */
+/* Description: 'Configure Receive Clock Delay' */
+#define GSWT_PCDU_1_RXDLY_OFFSET	0x0A
+#define GSWT_PCDU_1_RXDLY_SHIFT	7
+#define GSWT_PCDU_1_RXDLY_SIZE	3
+/* Bit: 'TXDLY' */
+/* Description: 'Configure Transmit PCDU' */
+#define GSWT_PCDU_1_TXDLY_OFFSET	0x0A
+#define GSWT_PCDU_1_TXDLY_SHIFT	0
+#define GSWT_PCDU_1_TXDLY_SIZE	3
+/* ----------------------------------------------- */
+/* Register: 'Receive Buffer ControlRegister for Port 1' */
+/* Bit: 'RBUF_UFL' */
+/* Description: 'Receive Buffer Underflow Indicator' */
+#define GSWT_RXB_CTL_1_RBUF_UFL_OFFSET	0x0B
+#define GSWT_RXB_CTL_1_RBUF_UFL_SHIFT	15
+#define GSWT_RXB_CTL_1_RBUF_UFL_SIZE	1
+/* Bit: 'RBUF_OFL' */
+/* Description: 'Receive Buffer Overflow Indicator' */
+#define GSWT_RXB_CTL_1_RBUF_OFL_OFFSET	0x0B
+#define GSWT_RXB_CTL_1_RBUF_OFL_SHIFT	14
+#define GSWT_RXB_CTL_1_RBUF_OFL_SIZE	1
+/* Bit: 'RBUF_DLY_WP' */
+/* Description: 'Delay' */
+#define GSWT_RXB_CTL_1_RBUF_DLY_WP_OFFSET	0x0B
+#define GSWT_RXB_CTL_1_RBUF_DLY_WP_SHIFT		0
+#define GSWT_RXB_CTL_1_RBUF_DLY_WP_SIZE		3
+/* ----------------------------------------------- */
+/* Register: 'Configure TX K value' */
+/* Bit: 'KVAL' */
+/* Description: 'K Value for TX Delay Path' */
+#define GSWT_PCDU1_TX_KVAL_KVAL_OFFSET	0x0C
+#define GSWT_PCDU1_TX_KVAL_KVAL_SHIFT	0
+#define GSWT_PCDU1_TX_KVAL_KVAL_SIZE	16
+/* ----------------------------------------------- */
+/* Register: 'Configure TX M Blank' */
+/* Bit: 'MBLK' */
+/* Description: 'M Required for TX Delay Path' */
+#define GSWT_PCDU1_TX_MBLK_MBLK_OFFSET	0x0D
+#define GSWT_PCDU1_TX_MBLK_MBLK_SHIFT	0
+#define GSWT_PCDU1_TX_MBLK_MBLK_SIZE	16
+/* ----------------------------------------------- */
+/* Register: 'Configure TX M Required' */
+/* Bit: 'MREQ' */
+/* Description: 'M Required for TX Delay Path' */
+#define GSWT_PCDU1_TX_MREQ_MREQ_OFFSET	0x0E
+#define GSWT_PCDU1_TX_MREQ_MREQ_SHIFT	0
+#define GSWT_PCDU1_TX_MREQ_MREQ_SIZE	16
+/* ----------------------------------------------- */
+/* Register: 'Configure TX Delay Length' */
+/* Bit: 'DEL_LEN' */
+/* Description: 'Delay Length for TX Delay Path ' */
+#define GSWT_PCDU1_TX_DELLEN_DEL_LEN_OFFSET	0x0F
+#define GSWT_PCDU1_TX_DELLEN_DEL_LEN_SHIFT	0
+#define GSWT_PCDU1_TX_DELLEN_DEL_LEN_SIZE	16
+/* ----------------------------------------------- */
+/* Register: 'Configure RX K value' */
+/* Bit: 'KVAL' */
+/* Description: 'K Value for RX Delay Path' */
+#define GSWT_PCDU1_RX_KVAL_KVAL_OFFSET	0x10
+#define GSWT_PCDU1_RX_KVAL_KVAL_SHIFT	0
+#define GSWT_PCDU1_RX_KVAL_KVAL_SIZE	16
+/* ----------------------------------------------- */
+/* Register: 'Configure RX M Required' */
+/* Bit: 'MREQ' */
+/* Description: 'M Required for RX Delay Path' */
+#define GSWT_PCDU1_RX_MREQ_MREQ_OFFSET	0x011
+#define GSWT_PCDU1_RX_MREQ_MREQ_SHIFT	0
+#define GSWT_PCDU1_RX_MREQ_MREQ_SIZE	16
+/* ----------------------------------------------- */
+/* Register: 'Configure RX M Blank' */
+/* Bit: 'MBLK' */
+/* Description: 'M Required for RX Delay Path' */
+#define GSWT_PCDU1_RX_MBLK_MBLK_OFFSET	0x012
+#define GSWT_PCDU1_RX_MBLK_MBLK_SHIFT	0
+#define GSWT_PCDU1_RX_MBLK_MBLK_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'Configure RX Delay Length' */
+/* Bit: 'DEL_LEN' */
+/* Description: 'Delay Length for RX Delay Path ' */
+#define GSWT_PCDU1_RX_DELLEN_DEL_LEN_OFFSET	0x013
+#define GSWT_PCDU1_RX_DELLEN_DEL_LEN_SHIFT		0
+#define GSWT_PCDU1_RX_DELLEN_DEL_LEN_SIZE		16
+/* ----------------------------------------------- */
+/* Bits: FSLSB	*/
+/* Description: Timer Fractional Nano Second LSB Value */
+#define GSWT_TIMER_FS_LSB_FSLSB_OFFSET	0x020
+#define GSWT_TIMER_FS_LSB_FSLSB_SHIFT	0
+#define GSWT_TIMER_FS_LSB_FSLSB_SIZE		16
+/* --------------------------------------------------- */
+/* Bits: FSMSB	*/
+/* Description: Timer Fractional Nano Second MSB Value  */
+#define GSWT_TIMER_FS_MSB_FSMSB_OFFSET	0x021
+#define GSWT_TIMER_FS_MSB_FSMSB_SHIFT	0
+#define GSWT_TIMER_FS_MSB_FSMSB_SIZE		16
+/* --------------------------------------------------- */
+/* Bits: NSLSB	*/
+/* Description: Timer Nano Second LSB Register  */
+#define GSWT_TIMER_NS_LSB_NSLSB_OFFSET	0x022
+#define GSWT_TIMER_NS_LSB_NSLSB_SHIFT	0
+#define GSWT_TIMER_NS_LSB_NSLSB_SIZE		16
+/* --------------------------------------------------- */
+/* Bits: NSMSB	*/
+/* Description: Timer Nano Second MSB Register  */
+#define GSWT_TIMER_NS_MSB_NSMSB_OFFSET	0x023
+#define GSWT_TIMER_NS_MSB_NSMSB_SHIFT	0
+#define GSWT_TIMER_NS_MSB_NSMSB_SIZE		16
+/* --------------------------------------------------- */
+/* Bits: SECLSB	*/
+/* Description: Timer Second LSB Register  */
+#define GSWT_TIMER_SEC_LSB_SECLSB_OFFSET	0x024
+#define GSWT_TIMER_SEC_LSB_SECLSB_SHIFT	0
+#define GSWT_TIMER_SEC_LSB_SECLSB_SIZE		16
+/* --------------------------------------------------- */
+/* Bits: SECMSB	*/
+/* Description: Timer Second MSB Register  */
+#define GSWT_TIMER_SEC_MSB_SECMSB_OFFSET	0x025
+#define GSWT_TIMER_SEC_MSB_SECMSB_SHIFT	0
+#define GSWT_TIMER_SEC_MSB_SECMSB_SIZE		16
+/* --------------------------------------------------- */
+/* Bit: WR	*/
+/* Description: Write to Timer Command  (LTQ_GSWIP_2_2) */
+#define GSWT_TIMER_CTRL_WR_OFFSET	0x026
+#define GSWT_TIMER_CTRL_WR_SHIFT		15
+#define GSWT_TIMER_CTRL_WR_SIZE		1
+/* Bit: RD	*/
+/* Description: Read from Timer Command  */
+#define GSWT_TIMER_CTRL_RD_OFFSET	0x026
+#define GSWT_TIMER_CTRL_RD_SHIFT		14
+#define GSWT_TIMER_CTRL_RD_SIZE		1
+/* Bit: ADJ	*/
+/* Description: Adjust Timer Command  */
+#define GSWT_TIMER_CTRL_ADJ_OFFSET	0x026
+#define GSWT_TIMER_CTRL_ADJ_SHIFT	13
+#define GSWT_TIMER_CTRL_ADJ_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'PHY Address RegisterPORT 1' */
+/* Bit: 'LNKST' */
+/* Description: 'Link Status Control' */
+#define GSWT_PHY_ADDR_1_LNKST_OFFSET	0x044
+#define GSWT_PHY_ADDR_1_LNKST_SHIFT	13
+#define GSWT_PHY_ADDR_1_LNKST_SIZE		2
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define GSWT_PHY_ADDR_1_SPEED_OFFSET	0x044
+#define GSWT_PHY_ADDR_1_SPEED_SHIFT	11
+#define GSWT_PHY_ADDR_1_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Control' */
+#define GSWT_PHY_ADDR_1_FDUP_OFFSET	0x044
+#define GSWT_PHY_ADDR_1_FDUP_SHIFT		9
+#define GSWT_PHY_ADDR_1_FDUP_SIZE		2
+/* Bit: 'FCONTX' */
+/* Description: 'Flow Control Mode TX' */
+#define GSWT_PHY_ADDR_1_FCONTX_OFFSET	0x044
+#define GSWT_PHY_ADDR_1_FCONTX_SHIFT		7
+#define GSWT_PHY_ADDR_1_FCONTX_SIZE		2
+/* Bit: 'FCONRX' */
+/* Description: 'Flow Control Mode RX' */
+#define GSWT_PHY_ADDR_1_FCONRX_OFFSET	0x044
+#define GSWT_PHY_ADDR_1_FCONRX_SHIFT		5
+#define GSWT_PHY_ADDR_1_FCONRX_SIZE		2
+/* Bit: 'ADDR' */
+/* Description: 'PHY Address' */
+#define GSWT_PHY_ADDR_1_ADDR_OFFSET	0x044
+#define GSWT_PHY_ADDR_1_ADDR_SHIFT		0
+#define GSWT_PHY_ADDR_1_ADDR_SIZE		5
+/* ----------------------------------------------- */
+/* Register: 'PHY MDIO PollingStatus per PORT' */
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'PHY supports MAC turning of TX clk' */
+#define GSWT_MDIO_STAT_1_CLK_STOP_CAPABLE_OFFSET	0x045
+#define GSWT_MDIO_STAT_1_CLK_STOP_CAPABLE_SHIFT	8
+#define GSWT_MDIO_STAT_1_CLK_STOP_CAPABLE_SIZE		1
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'PHY and link partner support EEE for current speed' */
+#define GSWT_MDIO_STAT_1_EEE_CAPABLE_OFFSET	0x045
+#define GSWT_MDIO_STAT_1_EEE_CAPABLE_SHIFT		7
+#define GSWT_MDIO_STAT_1_EEE_CAPABLE_SIZE		1
+/* Bit: 'PACT' */
+/* Description: 'PHY Active Status' */
+#define GSWT_MDIO_STAT_1_PACT_OFFSET	0x045
+#define GSWT_MDIO_STAT_1_PACT_SHIFT	6
+#define GSWT_MDIO_STAT_1_PACT_SIZE		1
+/* Bit: 'LSTAT' */
+/* Description: 'Link Status' */
+#define GSWT_MDIO_STAT_1_LSTAT_OFFSET	0x045
+#define GSWT_MDIO_STAT_1_LSTAT_SHIFT		5
+#define GSWT_MDIO_STAT_1_LSTAT_SIZE		1
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define GSWT_MDIO_STAT_1_SPEED_OFFSET	0x045
+#define GSWT_MDIO_STAT_1_SPEED_SHIFT		3
+#define GSWT_MDIO_STAT_1_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Status' */
+#define GSWT_MDIO_STAT_1_FDUP_OFFSET	0x045
+#define GSWT_MDIO_STAT_1_FDUP_SHIFT	2
+#define GSWT_MDIO_STAT_1_FDUP_SIZE		1
+/* Bit: 'RXPAUEN' */
+/* Description: 'Receive Pause Enable Status' */
+#define GSWT_MDIO_STAT_1_RXPAUEN_OFFSET	0x045
+#define GSWT_MDIO_STAT_1_RXPAUEN_SHIFT		1
+#define GSWT_MDIO_STAT_1_RXPAUEN_SIZE		1
+/* Bit: 'TXPAUEN' */
+/* Description: 'Transmit Pause Enable Status' */
+#define GSWT_MDIO_STAT_1_TXPAUEN_OFFSET	0x045
+#define GSWT_MDIO_STAT_1_TXPAUEN_SHIFT		0
+#define GSWT_MDIO_STAT_1_TXPAUEN_SIZE		1
+/* ----------------------------------------------- */
+/* Register: 'EEE auto negotiationoverides' for PORT 1*/
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'clk stop capable' */
+#define GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_OFFSET	0x046
+#define GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_SHIFT		2
+#define GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_SIZE		2
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'EEE capable' */
+#define GSWT_ANEG_EEE_1_EEE_CAPABLE_OFFSET	0x046
+#define GSWT_ANEG_EEE_1_EEE_CAPABLE_SHIFT	0
+#define GSWT_ANEG_EEE_1_EEE_CAPABLE_SIZE		2
+/* ----------------------------------------------- */
+/* Register: 'PHY Address RegisterPORT 1' */
+/* Bit: 'LNKST' */
+/* Description: 'Link Status Control' */
+#define GSWT_PHY_ADDR_2_LNKST_OFFSET	0x048
+#define GSWT_PHY_ADDR_2_LNKST_SHIFT	13
+#define GSWT_PHY_ADDR_2_LNKST_SIZE		2
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define GSWT_PHY_ADDR_2_SPEED_OFFSET	0x048
+#define GSWT_PHY_ADDR_2_SPEED_SHIFT	11
+#define GSWT_PHY_ADDR_2_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Control' */
+#define GSWT_PHY_ADDR_2_FDUP_OFFSET	0x048
+#define GSWT_PHY_ADDR_2_FDUP_SHIFT		9
+#define GSWT_PHY_ADDR_2_FDUP_SIZE		2
+/* Bit: 'FCONTX' */
+/* Description: 'Flow Control Mode TX' */
+#define GSWT_PHY_ADDR_2_FCONTX_OFFSET	0x048
+#define GSWT_PHY_ADDR_2_FCONTX_SHIFT		7
+#define GSWT_PHY_ADDR_2_FCONTX_SIZE		2
+/* Bit: 'FCONRX' */
+/* Description: 'Flow Control Mode RX' */
+#define GSWT_PHY_ADDR_2_FCONRX_OFFSET	0x048
+#define GSWT_PHY_ADDR_2_FCONRX_SHIFT		5
+#define GSWT_PHY_ADDR_2_FCONRX_SIZE		2
+/* Bit: 'ADDR' */
+/* Description: 'PHY Address' */
+#define GSWT_PHY_ADDR_2_ADDR_OFFSET	0x048
+#define GSWT_PHY_ADDR_2_ADDR_SHIFT		0
+#define GSWT_PHY_ADDR_2_ADDR_SIZE		5
+/* ----------------------------------------------- */
+/* Register: 'PHY MDIO PollingStatus per PORT' */
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'PHY supports MAC turning of TX clk' */
+#define GSWT_MDIO_STAT_2_CLK_STOP_CAPABLE_OFFSET	0x049
+#define GSWT_MDIO_STAT_2_CLK_STOP_CAPABLE_SHIFT	8
+#define GSWT_MDIO_STAT_2_CLK_STOP_CAPABLE_SIZE		1
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'PHY and link partner support EEE for current speed' */
+#define GSWT_MDIO_STAT_2_EEE_CAPABLE_OFFSET	0x049
+#define GSWT_MDIO_STAT_2_EEE_CAPABLE_SHIFT		7
+#define GSWT_MDIO_STAT_2_EEE_CAPABLE_SIZE		1
+/* Bit: 'PACT' */
+/* Description: 'PHY Active Status' */
+#define GSWT_MDIO_STAT_2_PACT_OFFSET	0x049
+#define GSWT_MDIO_STAT_2_PACT_SHIFT	6
+#define GSWT_MDIO_STAT_2_PACT_SIZE		1
+/* Bit: 'LSTAT' */
+/* Description: 'Link Status' */
+#define GSWT_MDIO_STAT_2_LSTAT_OFFSET	0x049
+#define GSWT_MDIO_STAT_2_LSTAT_SHIFT		5
+#define GSWT_MDIO_STAT_2_LSTAT_SIZE		1
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define GSWT_MDIO_STAT_2_SPEED_OFFSET	0x049
+#define GSWT_MDIO_STAT_2_SPEED_SHIFT		3
+#define GSWT_MDIO_STAT_2_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Status' */
+#define GSWT_MDIO_STAT_2_FDUP_OFFSET	0x049
+#define GSWT_MDIO_STAT_2_FDUP_SHIFT	2
+#define GSWT_MDIO_STAT_2_FDUP_SIZE		1
+/* Bit: 'RXPAUEN' */
+/* Description: 'Receive Pause Enable Status' */
+#define GSWT_MDIO_STAT_2_RXPAUEN_OFFSET	0x049
+#define GSWT_MDIO_STAT_2_RXPAUEN_SHIFT		1
+#define GSWT_MDIO_STAT_2_RXPAUEN_SIZE		1
+/* Bit: 'TXPAUEN' */
+/* Description: 'Transmit Pause Enable Status' */
+#define GSWT_MDIO_STAT_2_TXPAUEN_OFFSET	0x049
+#define GSWT_MDIO_STAT_2_TXPAUEN_SHIFT		0
+#define GSWT_MDIO_STAT_2_TXPAUEN_SIZE		1
+/* ----------------------------------------------- */
+/* Register: 'EEE auto negotiationoverides' for PORT 2*/
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'clk stop capable' */
+#define GSWT_ANEG_EEE_2_CLK_STOP_CAPABLE_OFFSET	0x04A
+#define GSWT_ANEG_EEE_2_CLK_STOP_CAPABLE_SHIFT		2
+#define GSWT_ANEG_EEE_2_CLK_STOP_CAPABLE_SIZE		2
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'EEE capable' */
+#define GSWT_ANEG_EEE_2_EEE_CAPABLE_OFFSET	0x04A
+#define GSWT_ANEG_EEE_2_EEE_CAPABLE_SHIFT	0
+#define GSWT_ANEG_EEE_2_EEE_CAPABLE_SIZE		2
+/* ----------------------------------------------- */
+/* Register: 'PHY Address RegisterPORT 1' */
+/* Bit: 'LNKST' */
+/* Description: 'Link Status Control' */
+#define GSWT_PHY_ADDR_3_LNKST_OFFSET	0x04C
+#define GSWT_PHY_ADDR_3_LNKST_SHIFT	13
+#define GSWT_PHY_ADDR_3_LNKST_SIZE		2
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define GSWT_PHY_ADDR_3_SPEED_OFFSET	0x04C
+#define GSWT_PHY_ADDR_3_SPEED_SHIFT	11
+#define GSWT_PHY_ADDR_3_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Control' */
+#define GSWT_PHY_ADDR_3_FDUP_OFFSET	0x04C
+#define GSWT_PHY_ADDR_3_FDUP_SHIFT		9
+#define GSWT_PHY_ADDR_3_FDUP_SIZE		2
+/* Bit: 'FCONTX' */
+/* Description: 'Flow Control Mode TX' */
+#define GSWT_PHY_ADDR_3_FCONTX_OFFSET	0x04C
+#define GSWT_PHY_ADDR_3_FCONTX_SHIFT		7
+#define GSWT_PHY_ADDR_3_FCONTX_SIZE		2
+/* Bit: 'FCONRX' */
+/* Description: 'Flow Control Mode RX' */
+#define GSWT_PHY_ADDR_3_FCONRX_OFFSET	0x04C
+#define GSWT_PHY_ADDR_3_FCONRX_SHIFT		5
+#define GSWT_PHY_ADDR_3_FCONRX_SIZE		2
+/* Bit: 'ADDR' */
+/* Description: 'PHY Address' */
+#define GSWT_PHY_ADDR_3_ADDR_OFFSET	0x04C
+#define GSWT_PHY_ADDR_3_ADDR_SHIFT		0
+#define GSWT_PHY_ADDR_3_ADDR_SIZE		5
+/* ----------------------------------------------- */
+/* Register: 'PHY MDIO PollingStatus per PORT' */
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'PHY supports MAC turning of TX clk' */
+#define GSWT_MDIO_STAT_3_CLK_STOP_CAPABLE_OFFSET	0x04D
+#define GSWT_MDIO_STAT_3_CLK_STOP_CAPABLE_SHIFT	8
+#define GSWT_MDIO_STAT_3_CLK_STOP_CAPABLE_SIZE		1
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'PHY and link partner support EEE for current speed' */
+#define GSWT_MDIO_STAT_3_EEE_CAPABLE_OFFSET	0x04D
+#define GSWT_MDIO_STAT_3_EEE_CAPABLE_SHIFT		7
+#define GSWT_MDIO_STAT_3_EEE_CAPABLE_SIZE		1
+/* Bit: 'PACT' */
+/* Description: 'PHY Active Status' */
+#define GSWT_MDIO_STAT_3_PACT_OFFSET	0x04D
+#define GSWT_MDIO_STAT_3_PACT_SHIFT	6
+#define GSWT_MDIO_STAT_3_PACT_SIZE		1
+/* Bit: 'LSTAT' */
+/* Description: 'Link Status' */
+#define GSWT_MDIO_STAT_3_LSTAT_OFFSET	0x04D
+#define GSWT_MDIO_STAT_3_LSTAT_SHIFT		5
+#define GSWT_MDIO_STAT_3_LSTAT_SIZE		1
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define GSWT_MDIO_STAT_3_SPEED_OFFSET	0x04D
+#define GSWT_MDIO_STAT_3_SPEED_SHIFT		3
+#define GSWT_MDIO_STAT_3_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Status' */
+#define GSWT_MDIO_STAT_3_FDUP_OFFSET	0x04D
+#define GSWT_MDIO_STAT_3_FDUP_SHIFT	2
+#define GSWT_MDIO_STAT_3_FDUP_SIZE		1
+/* Bit: 'RXPAUEN' */
+/* Description: 'Receive Pause Enable Status' */
+#define GSWT_MDIO_STAT_3_RXPAUEN_OFFSET	0x04D
+#define GSWT_MDIO_STAT_3_RXPAUEN_SHIFT		1
+#define GSWT_MDIO_STAT_3_RXPAUEN_SIZE		1
+/* Bit: 'TXPAUEN' */
+/* Description: 'Transmit Pause Enable Status' */
+#define GSWT_MDIO_STAT_3_TXPAUEN_OFFSET	0x04D
+#define GSWT_MDIO_STAT_3_TXPAUEN_SHIFT		0
+#define GSWT_MDIO_STAT_3_TXPAUEN_SIZE		1
+/* ----------------------------------------------- */
+/* Register: 'EEE auto negotiationoverides' for PORT 3*/
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'clk stop capable' */
+#define GSWT_ANEG_EEE_3_CLK_STOP_CAPABLE_OFFSET	0x04E
+#define GSWT_ANEG_EEE_3_CLK_STOP_CAPABLE_SHIFT		2
+#define GSWT_ANEG_EEE_3_CLK_STOP_CAPABLE_SIZE		2
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'EEE capable' */
+#define GSWT_ANEG_EEE_3_EEE_CAPABLE_OFFSET	0x04E
+#define GSWT_ANEG_EEE_3_EEE_CAPABLE_SHIFT	0
+#define GSWT_ANEG_EEE_3_EEE_CAPABLE_SIZE		2
+/* ----------------------------------------------- */
+/* Register: 'PHY Address RegisterPORT 1' */
+/* Bit: 'LNKST' */
+/* Description: 'Link Status Control' */
+#define GSWT_PHY_ADDR_4_LNKST_OFFSET	0x050
+#define GSWT_PHY_ADDR_4_LNKST_SHIFT	13
+#define GSWT_PHY_ADDR_4_LNKST_SIZE		2
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define GSWT_PHY_ADDR_4_SPEED_OFFSET	0x050
+#define GSWT_PHY_ADDR_4_SPEED_SHIFT	11
+#define GSWT_PHY_ADDR_4_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Control' */
+#define GSWT_PHY_ADDR_4_FDUP_OFFSET	0x050
+#define GSWT_PHY_ADDR_4_FDUP_SHIFT		9
+#define GSWT_PHY_ADDR_4_FDUP_SIZE		2
+/* Bit: 'FCONTX' */
+/* Description: 'Flow Control Mode TX' */
+#define GSWT_PHY_ADDR_4_FCONTX_OFFSET	0x050
+#define GSWT_PHY_ADDR_4_FCONTX_SHIFT		7
+#define GSWT_PHY_ADDR_4_FCONTX_SIZE		2
+/* Bit: 'FCONRX' */
+/* Description: 'Flow Control Mode RX' */
+#define GSWT_PHY_ADDR_4_FCONRX_OFFSET	0x050
+#define GSWT_PHY_ADDR_4_FCONRX_SHIFT		5
+#define GSWT_PHY_ADDR_4_FCONRX_SIZE		2
+/* Bit: 'ADDR' */
+/* Description: 'PHY Address' */
+#define GSWT_PHY_ADDR_4_ADDR_OFFSET	0x050
+#define GSWT_PHY_ADDR_4_ADDR_SHIFT		0
+#define GSWT_PHY_ADDR_4_ADDR_SIZE		5
+/* ----------------------------------------------- */
+/* Register: 'PHY MDIO PollingStatus per PORT' */
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'PHY supports MAC turning of TX clk' */
+#define GSWT_MDIO_STAT_4_CLK_STOP_CAPABLE_OFFSET	0x051
+#define GSWT_MDIO_STAT_4_CLK_STOP_CAPABLE_SHIFT	8
+#define GSWT_MDIO_STAT_4_CLK_STOP_CAPABLE_SIZE		1
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'PHY and link partner support EEE for current speed' */
+#define GSWT_MDIO_STAT_4_EEE_CAPABLE_OFFSET	0x051
+#define GSWT_MDIO_STAT_4_EEE_CAPABLE_SHIFT		7
+#define GSWT_MDIO_STAT_4_EEE_CAPABLE_SIZE		1
+/* Bit: 'PACT' */
+/* Description: 'PHY Active Status' */
+#define GSWT_MDIO_STAT_4_PACT_OFFSET	0x051
+#define GSWT_MDIO_STAT_4_PACT_SHIFT	6
+#define GSWT_MDIO_STAT_4_PACT_SIZE		1
+/* Bit: 'LSTAT' */
+/* Description: 'Link Status' */
+#define GSWT_MDIO_STAT_4_LSTAT_OFFSET	0x051
+#define GSWT_MDIO_STAT_4_LSTAT_SHIFT		5
+#define GSWT_MDIO_STAT_4_LSTAT_SIZE		1
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define GSWT_MDIO_STAT_4_SPEED_OFFSET	0x051
+#define GSWT_MDIO_STAT_4_SPEED_SHIFT		3
+#define GSWT_MDIO_STAT_4_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Status' */
+#define GSWT_MDIO_STAT_4_FDUP_OFFSET	0x051
+#define GSWT_MDIO_STAT_4_FDUP_SHIFT	2
+#define GSWT_MDIO_STAT_4_FDUP_SIZE		1
+/* Bit: 'RXPAUEN' */
+/* Description: 'Receive Pause Enable Status' */
+#define GSWT_MDIO_STAT_4_RXPAUEN_OFFSET	0x051
+#define GSWT_MDIO_STAT_4_RXPAUEN_SHIFT		1
+#define GSWT_MDIO_STAT_4_RXPAUEN_SIZE		1
+/* Bit: 'TXPAUEN' */
+/* Description: 'Transmit Pause Enable Status' */
+#define GSWT_MDIO_STAT_4_TXPAUEN_OFFSET	0x051
+#define GSWT_MDIO_STAT_4_TXPAUEN_SHIFT		0
+#define GSWT_MDIO_STAT_4_TXPAUEN_SIZE		1
+/* ----------------------------------------------- */
+/* Register: 'EEE auto negotiationoverides' for PORT 4*/
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'clk stop capable' */
+#define GSWT_ANEG_EEE_4_CLK_STOP_CAPABLE_OFFSET	0x052
+#define GSWT_ANEG_EEE_4_CLK_STOP_CAPABLE_SHIFT		2
+#define GSWT_ANEG_EEE_4_CLK_STOP_CAPABLE_SIZE		2
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'EEE capable' */
+#define GSWT_ANEG_EEE_4_EEE_CAPABLE_OFFSET	0x052
+#define GSWT_ANEG_EEE_4_EEE_CAPABLE_SHIFT	0
+#define GSWT_ANEG_EEE_4_EEE_CAPABLE_SIZE		2
+/* ----------------------------------------------- */
+/* Register: 'PHY Address RegisterPORT 1' */
+/* Bit: 'LNKST' */
+/* Description: 'Link Status Control' */
+#define GSWT_PHY_ADDR_5_LNKST_OFFSET	0x054
+#define GSWT_PHY_ADDR_5_LNKST_SHIFT	13
+#define GSWT_PHY_ADDR_5_LNKST_SIZE		2
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define GSWT_PHY_ADDR_5_SPEED_OFFSET	0x054
+#define GSWT_PHY_ADDR_5_SPEED_SHIFT	11
+#define GSWT_PHY_ADDR_5_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Control' */
+#define GSWT_PHY_ADDR_5_FDUP_OFFSET	0x054
+#define GSWT_PHY_ADDR_5_FDUP_SHIFT		9
+#define GSWT_PHY_ADDR_5_FDUP_SIZE		2
+/* Bit: 'FCONTX' */
+/* Description: 'Flow Control Mode TX' */
+#define GSWT_PHY_ADDR_5_FCONTX_OFFSET	0x054
+#define GSWT_PHY_ADDR_5_FCONTX_SHIFT		7
+#define GSWT_PHY_ADDR_5_FCONTX_SIZE		2
+/* Bit: 'FCONRX' */
+/* Description: 'Flow Control Mode RX' */
+#define GSWT_PHY_ADDR_5_FCONRX_OFFSET	0x054
+#define GSWT_PHY_ADDR_5_FCONRX_SHIFT		5
+#define GSWT_PHY_ADDR_5_FCONRX_SIZE		2
+/* Bit: 'ADDR' */
+/* Description: 'PHY Address' */
+#define GSWT_PHY_ADDR_5_ADDR_OFFSET	0x054
+#define GSWT_PHY_ADDR_5_ADDR_SHIFT		0
+#define GSWT_PHY_ADDR_5_ADDR_SIZE		5
+/* ----------------------------------------------- */
+/* Register: 'PHY MDIO PollingStatus per PORT' */
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'PHY supports MAC turning of TX clk' */
+#define GSWT_MDIO_STAT_5_CLK_STOP_CAPABLE_OFFSET	0x055
+#define GSWT_MDIO_STAT_5_CLK_STOP_CAPABLE_SHIFT	8
+#define GSWT_MDIO_STAT_5_CLK_STOP_CAPABLE_SIZE		1
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'PHY and link partner support EEE for current speed' */
+#define GSWT_MDIO_STAT_5_EEE_CAPABLE_OFFSET	0x055
+#define GSWT_MDIO_STAT_5_EEE_CAPABLE_SHIFT		7
+#define GSWT_MDIO_STAT_5_EEE_CAPABLE_SIZE		1
+/* Bit: 'PACT' */
+/* Description: 'PHY Active Status' */
+#define GSWT_MDIO_STAT_5_PACT_OFFSET	0x055
+#define GSWT_MDIO_STAT_5_PACT_SHIFT	6
+#define GSWT_MDIO_STAT_5_PACT_SIZE		1
+/* Bit: 'LSTAT' */
+/* Description: 'Link Status' */
+#define GSWT_MDIO_STAT_5_LSTAT_OFFSET	0x055
+#define GSWT_MDIO_STAT_5_LSTAT_SHIFT		5
+#define GSWT_MDIO_STAT_5_LSTAT_SIZE		1
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define GSWT_MDIO_STAT_5_SPEED_OFFSET	0x055
+#define GSWT_MDIO_STAT_5_SPEED_SHIFT		3
+#define GSWT_MDIO_STAT_5_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Status' */
+#define GSWT_MDIO_STAT_5_FDUP_OFFSET	0x055
+#define GSWT_MDIO_STAT_5_FDUP_SHIFT	2
+#define GSWT_MDIO_STAT_5_FDUP_SIZE		1
+/* Bit: 'RXPAUEN' */
+/* Description: 'Receive Pause Enable Status' */
+#define GSWT_MDIO_STAT_5_RXPAUEN_OFFSET	0x055
+#define GSWT_MDIO_STAT_5_RXPAUEN_SHIFT		1
+#define GSWT_MDIO_STAT_5_RXPAUEN_SIZE		1
+/* Bit: 'TXPAUEN' */
+/* Description: 'Transmit Pause Enable Status' */
+#define GSWT_MDIO_STAT_5_TXPAUEN_OFFSET	0x055
+#define GSWT_MDIO_STAT_5_TXPAUEN_SHIFT		0
+#define GSWT_MDIO_STAT_5_TXPAUEN_SIZE		1
+/* ----------------------------------------------- */
+/* Register: 'EEE auto negotiationoverides' for PORT 5*/
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'clk stop capable' */
+#define GSWT_ANEG_EEE_5_CLK_STOP_CAPABLE_OFFSET	0x056
+#define GSWT_ANEG_EEE_5_CLK_STOP_CAPABLE_SHIFT		2
+#define GSWT_ANEG_EEE_5_CLK_STOP_CAPABLE_SIZE		2
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'EEE capable' */
+#define GSWT_ANEG_EEE_5_EEE_CAPABLE_OFFSET	0x056
+#define GSWT_ANEG_EEE_5_EEE_CAPABLE_SHIFT	0
+#define GSWT_ANEG_EEE_5_EEE_CAPABLE_SIZE		2
+/* ----------------------------------------------- */
+/* Register: 'PHY Address RegisterPORT 1' */
+/* Bit: 'LNKST' */
+/* Description: 'Link Status Control' */
+#define GSWT_PHY_ADDR_6_LNKST_OFFSET	0x058
+#define GSWT_PHY_ADDR_6_LNKST_SHIFT	13
+#define GSWT_PHY_ADDR_6_LNKST_SIZE		2
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define GSWT_PHY_ADDR_6_SPEED_OFFSET	0x058
+#define GSWT_PHY_ADDR_6_SPEED_SHIFT	11
+#define GSWT_PHY_ADDR_6_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Control' */
+#define GSWT_PHY_ADDR_6_FDUP_OFFSET	0x058
+#define GSWT_PHY_ADDR_6_FDUP_SHIFT		9
+#define GSWT_PHY_ADDR_6_FDUP_SIZE		2
+/* Bit: 'FCONTX' */
+/* Description: 'Flow Control Mode TX' */
+#define GSWT_PHY_ADDR_6_FCONTX_OFFSET	0x058
+#define GSWT_PHY_ADDR_6_FCONTX_SHIFT		7
+#define GSWT_PHY_ADDR_6_FCONTX_SIZE		2
+/* Bit: 'FCONRX' */
+/* Description: 'Flow Control Mode RX' */
+#define GSWT_PHY_ADDR_6_FCONRX_OFFSET	0x058
+#define GSWT_PHY_ADDR_6_FCONRX_SHIFT		5
+#define GSWT_PHY_ADDR_6_FCONRX_SIZE		2
+/* Bit: 'ADDR' */
+/* Description: 'PHY Address' */
+#define GSWT_PHY_ADDR_6_ADDR_OFFSET	0x058
+#define GSWT_PHY_ADDR_6_ADDR_SHIFT		0
+#define GSWT_PHY_ADDR_6_ADDR_SIZE		5
+/* ----------------------------------------------- */
+/* Register: 'PHY MDIO PollingStatus per PORT' */
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'PHY supports MAC turning of TX clk' */
+#define GSWT_MDIO_STAT_6_CLK_STOP_CAPABLE_OFFSET	0x059
+#define GSWT_MDIO_STAT_6_CLK_STOP_CAPABLE_SHIFT	8
+#define GSWT_MDIO_STAT_6_CLK_STOP_CAPABLE_SIZE		1
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'PHY and link partner support EEE for current speed' */
+#define GSWT_MDIO_STAT_6_EEE_CAPABLE_OFFSET	0x059
+#define GSWT_MDIO_STAT_6_EEE_CAPABLE_SHIFT		7
+#define GSWT_MDIO_STAT_6_EEE_CAPABLE_SIZE		1
+/* Bit: 'PACT' */
+/* Description: 'PHY Active Status' */
+#define GSWT_MDIO_STAT_6_PACT_OFFSET	0x059
+#define GSWT_MDIO_STAT_6_PACT_SHIFT	6
+#define GSWT_MDIO_STAT_6_PACT_SIZE		1
+/* Bit: 'LSTAT' */
+/* Description: 'Link Status' */
+#define GSWT_MDIO_STAT_6_LSTAT_OFFSET	0x059
+#define GSWT_MDIO_STAT_6_LSTAT_SHIFT		5
+#define GSWT_MDIO_STAT_6_LSTAT_SIZE		1
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define GSWT_MDIO_STAT_6_SPEED_OFFSET	0x059
+#define GSWT_MDIO_STAT_6_SPEED_SHIFT		3
+#define GSWT_MDIO_STAT_6_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Status' */
+#define GSWT_MDIO_STAT_6_FDUP_OFFSET	0x059
+#define GSWT_MDIO_STAT_6_FDUP_SHIFT	2
+#define GSWT_MDIO_STAT_6_FDUP_SIZE		1
+/* Bit: 'RXPAUEN' */
+/* Description: 'Receive Pause Enable Status' */
+#define GSWT_MDIO_STAT_6_RXPAUEN_OFFSET	0x059
+#define GSWT_MDIO_STAT_6_RXPAUEN_SHIFT		1
+#define GSWT_MDIO_STAT_6_RXPAUEN_SIZE		1
+/* Bit: 'TXPAUEN' */
+/* Description: 'Transmit Pause Enable Status' */
+#define GSWT_MDIO_STAT_6_TXPAUEN_OFFSET	0x059
+#define GSWT_MDIO_STAT_6_TXPAUEN_SHIFT		0
+#define GSWT_MDIO_STAT_6_TXPAUEN_SIZE		1
+/* ----------------------------------------------- */
+/* Register: 'EEE auto negotiationoverides' for PORT 6*/
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'clk stop capable' */
+#define GSWT_ANEG_EEE_6_CLK_STOP_CAPABLE_OFFSET	0x05A
+#define GSWT_ANEG_EEE_6_CLK_STOP_CAPABLE_SHIFT	2
+#define GSWT_ANEG_EEE_6_CLK_STOP_CAPABLE_SIZE		2
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'EEE capable' */
+#define GSWT_ANEG_EEE_6_EEE_CAPABLE_OFFSET	0x05A
+#define GSWT_ANEG_EEE_6_EEE_CAPABLE_SHIFT	0
+#define GSWT_ANEG_EEE_6_EEE_CAPABLE_SIZE	2
+/* ----------------------------------------------- */
+/* Register: 'GPHY2 General Pin Strapping Configuration Register*/
+/* Bit: 'CFG' */
+/* Description: 'GPHY General Pin Strapping Configuration' */
+#define GSWT_GPHY2_CFG_CFG_OFFSET	0x088
+#define GSWT_GPHY2_CFG_CFG_SHIFT	0
+#define GSWT_GPHY2_CFG_CFG_SIZE		8
+/* ----------------------------------------------- */
+/* Register: 'GPHY2 Base Frequency Deviation Configuration Register*/
+/* Bit: 'BFDEV' */
+/* Description: 'Base Frequency Deviation' */
+#define GSWT_GPHY2_BFDEV_BFDEV_OFFSET	0x089
+#define GSWT_GPHY2_BFDEV_BFDEV_SHIFT	0
+#define GSWT_GPHY2_BFDEV_BFDEV_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'GPHY2 Firmware Base Address LSB Register */
+/* Bit: 'BASELSB' */
+/* Description: 'GPHY Firmware Base Address LSB (bit 15 to 0) ' */
+#define GSWT_GPHY2_LBADR_BASELSB_OFFSET	0x08A
+#define GSWT_GPHY2_LBADR_BASELSB_SHIFT	0
+#define GSWT_GPHY2_LBADR_BASELSB_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'GPHY2 Firmware Base Address MSB Register */
+/* Bit: 'BASEMSB' */
+/* Description: 'GPHY Firmware Base Address MSB (bit 31 to 16) ' */
+#define GSWT_GPHY2_MBADR_BASEMSB_OFFSET	0x08B
+#define GSWT_GPHY2_MBADR_BASEMSB_SHIFT	0
+#define GSWT_GPHY2_MBADR_BASEMSB_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'GPHY3 General Pin Strapping Configuration Register*/
+/* Bit: 'CFG' */
+/* Description: 'GPHY General Pin Strapping Configuration' */
+#define GSWT_GPHY3_CFG_CFG_OFFSET	0x08C
+#define GSWT_GPHY3_CFG_CFG_SHIFT	0
+#define GSWT_GPHY3_CFG_CFG_SIZE		8
+/* ----------------------------------------------- */
+/* Register: 'GPHY3 Base Frequency Deviation Configuration Register*/
+/* Bit: 'BFDEV' */
+/* Description: 'Base Frequency Deviation' */
+#define GSWT_GPHY3_BFDEV_BFDEV_OFFSET	0x08D
+#define GSWT_GPHY3_BFDEV_BFDEV_SHIFT	0
+#define GSWT_GPHY3_BFDEV_BFDEV_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'GPHY3 Firmware Base Address LSB Register */
+/* Bit: 'BASELSB' */
+/* Description: 'GPHY Firmware Base Address LSB (bit 15 to 0) ' */
+#define GSWT_GPHY3_LBADR_BASELSB_OFFSET	0x08E
+#define GSWT_GPHY3_LBADR_BASELSB_SHIFT	0
+#define GSWT_GPHY3_LBADR_BASELSB_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'GPHY3 Firmware Base Address MSB Register */
+/* Bit: 'BASEMSB' */
+/* Description: 'GPHY Firmware Base Address MSB (bit 31 to 16) ' */
+#define GSWT_GPHY3_MBADR_BASEMSB_OFFSET	0x08F
+#define GSWT_GPHY3_MBADR_BASEMSB_SHIFT	0
+#define GSWT_GPHY3_MBADR_BASEMSB_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'GPHY4 General Pin Strapping Configuration Register*/
+/* Bit: 'CFG' */
+/* Description: 'GPHY General Pin Strapping Configuration' */
+#define GSWT_GPHY4_CFG_CFG_OFFSET	0x090
+#define GSWT_GPHY4_CFG_CFG_SHIFT	0
+#define GSWT_GPHY4_CFG_CFG_SIZE		8
+/* ----------------------------------------------- */
+/* Register: 'GPHY4 Base Frequency Deviation Configuration Register*/
+/* Bit: 'BFDEV' */
+/* Description: 'Base Frequency Deviation' */
+#define GSWT_GPHY4_BFDEV_BFDEV_OFFSET	0x091
+#define GSWT_GPHY4_BFDEV_BFDEV_SHIFT	0
+#define GSWT_GPHY4_BFDEV_BFDEV_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'GPHY4 Firmware Base Address LSB Register */
+/* Bit: 'BASELSB' */
+/* Description: 'GPHY Firmware Base Address LSB (bit 15 to 0) ' */
+#define GSWT_GPHY4_LBADR_BASELSB_OFFSET	0x092
+#define GSWT_GPHY4_LBADR_BASELSB_SHIFT	0
+#define GSWT_GPHY4_LBADR_BASELSB_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'GPHY4 Firmware Base Address MSB Register */
+/* Bit: 'BASEMSB' */
+/* Description: 'GPHY Firmware Base Address MSB (bit 31 to 16) ' */
+#define GSWT_GPHY4_MBADR_BASEMSB_OFFSET	0x093
+#define GSWT_GPHY4_MBADR_BASEMSB_SHIFT	0
+#define GSWT_GPHY4_MBADR_BASEMSB_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'GPHY5 General Pin Strapping Configuration Register*/
+/* Bit: 'CFG' */
+/* Description: 'GPHY General Pin Strapping Configuration' */
+#define GSWT_GPHY5_CFG_CFG_OFFSET	0x094
+#define GSWT_GPHY5_CFG_CFG_SHIFT	0
+#define GSWT_GPHY5_CFG_CFG_SIZE		8
+/* ----------------------------------------------- */
+/* Register: 'GPHY5 Base Frequency Deviation Configuration Register*/
+/* Bit: 'BFDEV' */
+/* Description: 'Base Frequency Deviation' */
+#define GSWT_GPHY5_BFDEV_BFDEV_OFFSET	0x095
+#define GSWT_GPHY5_BFDEV_BFDEV_SHIFT	0
+#define GSWT_GPHY5_BFDEV_BFDEV_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'GPHY5 Firmware Base Address LSB Register */
+/* Bit: 'BASELSB' */
+/* Description: 'GPHY Firmware Base Address LSB (bit 15 to 0) ' */
+#define GSWT_GPHY5_LBADR_BASELSB_OFFSET	0x096
+#define GSWT_GPHY5_LBADR_BASELSB_SHIFT	0
+#define GSWT_GPHY5_LBADR_BASELSB_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'GPHY5 Firmware Base Address MSB Register */
+/* Bit: 'BASEMSB' */
+/* Description: 'GPHY Firmware Base Address MSB (bit 31 to 16) ' */
+#define GSWT_GPHY5_MBADR_BASEMSB_OFFSET	0x097
+#define GSWT_GPHY5_MBADR_BASEMSB_SHIFT	0
+#define GSWT_GPHY5_MBADR_BASEMSB_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'GPHY6F General Pin Strapping Configuration Register*/
+/* Bit: 'CFG' */
+/* Description: 'GPHY General Pin Strapping Configuration' */
+#define GSWT_GPHY6F_CFG_CFG_OFFSET	0x098
+#define GSWT_GPHY6F_CFG_CFG_SHIFT		0
+#define GSWT_GPHY6F_CFG_CFG_SIZE		8
+/* ----------------------------------------------- */
+/* Register: 'GPHY6F Base Frequency Deviation Configuration Register*/
+/* Bit: 'BFDEV' */
+/* Description: 'Base Frequency Deviation' */
+#define GSWT_GPHY6F_BFDEV_BFDEV_OFFSET	0x099
+#define GSWT_GPHY6F_BFDEV_BFDEV_SHIFT		0
+#define GSWT_GPHY6F_BFDEV_BFDEV_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'GPHY6F Firmware Base Address LSB Register */
+/* Bit: 'BASELSB' */
+/* Description: 'GPHY Firmware Base Address LSB (bit 15 to 0) ' */
+#define GSWT_GPHY6F_LBADR_BASELSB_OFFSET	0x09A
+#define GSWT_GPHY6F_LBADR_BASELSB_SHIFT		0
+#define GSWT_GPHY6F_LBADR_BASELSB_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'GPHY6F Firmware Base Address MSB Register */
+/* Bit: 'BASEMSB' */
+/* Description: 'GPHY Firmware Base Address MSB (bit 31 to 16) ' */
+#define GSWT_GPHY6F_MBADR_BASEMSB_OFFSET	0x09B
+#define GSWT_GPHY6F_MBADR_BASEMSB_SHIFT		0
+#define GSWT_GPHY6F_MBADR_BASEMSB_SIZE		16
+/* ----------------------------------------------- */
+#endif /*  _LTQ_GSW30_SOC_TOP_H_ */
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_debug.c b/drivers/net/ethernet/lantiq/switch-api/gsw_debug.c
new file mode 100644
index 000000000000..e0c45b717d77
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_debug.c
@@ -0,0 +1,1205 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+For licensing information, see the file 'LICENSE' in the root folder of
+this software module.
+******************************************************************************/
+
+#include <gsw_init.h>
+#include <gsw_defconf.h>
+#include <xgmac_common.h>
+
+
+
+static GSW_Debug_RMON_Port_cnt_t Rmon_get;
+static GSW_CTP_portAssignment_t Assign_get;
+static GSW_CTP_portConfig_t CTP_get;
+static GSW_BRIDGE_portConfig_t BP_get;
+static GSW_BRIDGE_portConfig_t Temp_BP_get;
+static GSW_BRIDGE_config_t Brdg_get;
+static GSW_QoS_queuePort_t q_map;
+static GSW_PMAC_Cnt_t Pmac_Count;
+
+GSW_return_t GSW_Debug_RMON_Port_Get(void *cdev, GSW_Debug_RMON_Port_cnt_t *parm)
+{
+	u8 RmonCntOffset = 0;
+	u32 data = 0, data1 = 0;
+	u32 r_frame = 0, r_unicast = 0, r_multicast = 0,
+	    t_frame = 0, t_unicast = 0, t_multicast = 0;
+	u32 rgbcl = 0, rbbcl = 0, tgbcl = 0;
+	u64 rgbch = 0, rbbch = 0, tgbch = 0;
+	u32 Portmode = 0, PortId = 0;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 count = 0;
+	bmtbl_prog_t bmtable = {0};
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	Portmode = parm->ePortType;
+	PortId = parm->nPortId;
+	/*Clear the structure before using*/
+	memset(parm, 0, sizeof(GSW_Debug_RMON_Port_cnt_t));
+
+	switch (Portmode) {
+	case GSW_RMON_CTP_PORT_RX:
+	case GSW_RMON_CTP_PORT_TX:
+	case GSW_RMON_CTP_PORT_PCE_BYPASS:
+		if (PortId >= gswdev->num_of_ctp) {
+			pr_err("PortId %d >= gswdev->num_of_ctp %d\n", PortId, gswdev->num_of_ctp);
+			return GSW_statusErr;
+		}
+
+		break;
+
+	case GSW_RMON_BRIDGE_PORT_RX:
+	case GSW_RMON_BRIDGE_PORT_TX:
+		if (PortId >= gswdev->num_of_bridge_port) {
+			pr_err("PortId %d >= gswdev->num_of_ctp %d\n", PortId, gswdev->num_of_bridge_port);
+			return GSW_statusErr;
+		}
+
+		break;
+
+	default:
+		pr_err("ePortType Not Supported :ERROR (ePortType=%d)\n", Portmode);
+		return GSW_statusErr;
+	}
+
+	/*GSW_ENABLE should be called before calling RMON_GET
+	  In GSW_ENABLE RMON Counter for 0- 15 logical port are enabled*/
+
+	if (Portmode == GSW_RMON_CTP_PORT_RX || Portmode == GSW_RMON_BRIDGE_PORT_RX)
+		count = RMON_COUNTER_OFFSET_GSWIP3_1;
+	else
+		count = 14;
+
+	//One-time populate.
+	bmtable.adr.rmon.portOffset = PortId;
+	bmtable.tableID = (BM_Table_ID)Portmode;
+	bmtable.b64bitMode = 1;
+	bmtable.numValues = 4;
+
+	for (RmonCntOffset = 0; RmonCntOffset < count; RmonCntOffset++) {
+		bmtable.adr.rmon.counterOffset = RmonCntOffset;
+		gsw_bm_table_read(cdev, &bmtable);
+		data = (bmtable.value[1] << 16) | (bmtable.value[0] & 0xFFFF);
+		data1 = (bmtable.value[3] << 16) | (bmtable.value[2] & 0xFFFF);
+
+		/*Only for RX, As per SAS counter offset 0 - 21 is
+		  shared between RX and TX.
+		  Depends upon ePortType selection*/
+		if (Portmode == GSW_RMON_CTP_PORT_RX ||
+		    Portmode == GSW_RMON_BRIDGE_PORT_RX) {
+			switch (RmonCntOffset) {
+			case 0x00: /*RX Size 64 frame count*/
+				parm->nRx64BytePkts = data;
+				parm->nRx127BytePkts = data1; /* Receive Size 65-127 Frame Count */
+				break;
+
+			case 0x02: /* Receive Size 128-255 Frame Count */
+				parm->nRx255BytePkts = data;
+				parm->nRx511BytePkts = data1; /* Receive Size 256-511 Frame Count */
+				break;
+
+			case 0x04: /* Receive Size 512-1023 Frame Count */
+				parm->nRx1023BytePkts = data;
+				parm->nRxMaxBytePkts = data1; /* Receive Size 1024 - 1518 Frame Count */
+				break;
+
+			case 0x06: /* Receive Unicast Frame Count */
+				parm->nRxUnicastPkts = r_unicast = data;
+				parm->nRxMulticastPkts = r_multicast = data1; /* Receive Multicast Frame Count1 */
+				break;
+
+			case 0x08: /* Receive Undersize Good Count */
+				parm->nRxUnderSizeGoodPkts = data; /* Less than 64 byes. */
+				parm->nRxOversizeGoodPkts = data1; /* Receive Oversize (> 1518) Good Count */
+				break;
+
+			case 0x0A: /* Receive Good Byte Count (Low) */
+				rgbcl = data;
+				rgbch = data1; /* Receive Good Byte Count (High) */
+				break;
+
+			case 0x0C: /* Receive Frme Count */
+				parm->nRxBroadcastPkts = r_frame = data;
+				parm->nRxFilteredPkts = data1; /* Receive Drop (Filter) Frame Count */
+				break;
+
+			case 0x0E: /* Receive Extended Vlan Discard Frame Count */
+				parm->nRxExtendedVlanDiscardPkts = data;
+
+				/*only applicable for CTP RX*/
+				if (Portmode == GSW_RMON_CTP_PORT_RX)
+					parm->nRxFCSErrorPkts = data1; /* Receive MAC/FCS Error frame Count */
+
+				break;
+
+			case 0x10: /* Receive Undersize Bad Count */
+
+				/*only applicable for CTP RX*/
+				if (Portmode == GSW_RMON_CTP_PORT_RX)
+					parm->nRxUnderSizeErrorPkts = data;
+
+				/*only applicable for CTP RX*/
+				if (Portmode == GSW_RMON_CTP_PORT_RX)
+					parm->nRxOversizeErrorPkts = data1; /* Receive Oversize Bad Count */
+
+				break;
+
+			case 0x12: /* MTU Exceed Discard Count */
+
+				/*only applicable for CTP RX*/
+				if (Portmode == GSW_RMON_CTP_PORT_RX)
+					parm->nMtuExceedDiscardPkts = data;
+
+				/*only applicable for CTP RX*/
+				if (Portmode == GSW_RMON_CTP_PORT_RX)
+					parm->nRxDroppedPkts = data1; /* Receive Discard (Tail-Drop) Frame Count */
+
+				break;
+
+			case 0x14: /* Receive Bad Byte Count (Low) */
+
+				/*only applicable for CTP RX*/
+				if (Portmode == GSW_RMON_CTP_PORT_RX)
+					rbbcl = data;
+
+				/*only applicable for CTP RX*/
+				if (Portmode == GSW_RMON_CTP_PORT_RX)
+					rbbch = data1; /* Receive Bad Byte Count (High) */
+
+				break;
+			}
+		}
+
+		/*Only for TX, As per SAS counter offset 0 - 21 is
+		  shared between RX and TX.
+		  Depends upon ePortType selection*/
+		if (Portmode == GSW_RMON_CTP_PORT_TX ||
+		    Portmode == GSW_RMON_CTP_PORT_PCE_BYPASS ||
+		    Portmode == GSW_RMON_BRIDGE_PORT_TX) {
+			switch (RmonCntOffset) {
+			case 0x00: /* Transmit Size 64 Frame Count */
+				parm->nTx64BytePkts = data;
+				parm->nTx127BytePkts = data1; /* Transmit Size 65-127 Frame Count */
+				break;
+
+			case 0x02: /* Transmit Size 128-255 Frame Count */
+				parm->nTx255BytePkts = data;
+				parm->nTx511BytePkts = data1; /* Transmit Size 256-511 Frame Count */
+				break;
+
+			case 0x04: /* Transmit Size 512-1023 Frame Count */
+				parm->nTx1023BytePkts = data;
+				parm->nTxMaxBytePkts = data1; /* Transmit Size 1024 - 1518 Frame Count */
+				break;
+
+			case 0x06:  /* Transmit Unicast Frame Count */
+				parm->nTxUnicastPkts = t_unicast = data;
+				parm->nTxMulticastPkts = t_multicast = data1; /* Transmit Multicast Frame Count1 */
+				break;
+
+			case 0x08: /* Transmit Undersize Good Count */
+				parm->nTxUnderSizeGoodPkts = data; /* Less than 64 byes */
+				parm->nTxOversizeGoodPkts = data1; /* Transmit Oversize (> 1518) Good Count */
+				break;
+
+			case 0x0A: /* Transmit Good Byte Count (Low) */
+				tgbcl = data;
+				tgbch = data1; /* Transmit Good Byte Count (High) */
+				break;
+
+			case 0x0C: /* Transmit BroadCast Count */
+				parm->nTxBroadcastPkts = t_frame = data;
+				parm->nTxAcmDroppedPkts = data1; /* Egress Queue Discard,(Active Congestion Management) frame count.*/
+				break;
+			}
+		}
+
+		RmonCntOffset = RmonCntOffset + 1;
+	}
+
+	if (Portmode == GSW_RMON_CTP_PORT_RX ||
+	    Portmode == GSW_RMON_BRIDGE_PORT_RX) {
+		/* Receive Good Byte Count */
+		parm->nRxGoodBytes = (u64)(((rgbch & 0xFFFFFFFF) << 32) | (rgbcl & 0xFFFFFFFF));
+
+		if (Portmode == GSW_RMON_CTP_PORT_RX) {
+			/* Receive Bad Byte Count */
+			parm->nRxBadBytes = (u64)(((rbbch & 0xFFFFFFFF) << 32) | (rbbcl & 0xFFFFFFFF));
+		}
+
+		parm->nRxGoodPkts = r_frame + r_unicast + r_multicast;
+	}
+
+	if (Portmode == GSW_RMON_CTP_PORT_TX ||
+	    Portmode == GSW_RMON_CTP_PORT_PCE_BYPASS ||
+	    Portmode == GSW_RMON_BRIDGE_PORT_TX) {
+		parm->nTxGoodPkts = t_frame + t_unicast + t_multicast;
+		/* Transmit Good Byte Count */
+		parm->nTxGoodBytes = (u64)(((tgbch & 0xFFFFFFFF) << 32) | (tgbcl & 0xFFFFFFFF));
+	}
+
+	parm->ePortType = Portmode;
+	parm->nPortId = PortId;
+
+	return GSW_statusOk;
+}
+
+
+GSW_return_t GSW_Debug_GetLpStatistics(void *cdev, GSW_debug_t *parm)
+{
+	u32 i = 0, j = 0, k = 0, ret = 0;
+	u32 first_port = 0, no_port = 0;
+	GSW_CTP_portAssignment_t Assign_get;
+	static GSW_CTP_portConfig_t CTP_get;
+	static GSW_BRIDGE_portConfig_t BP_get;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	printk("\n\n");
+	printk("\t\t----------------------------------------\n");
+	printk("\t\t\t LOGICAL PORT Statistics\n");
+	printk("\t\t----------------------------------------\n");
+
+	for (j = 0; j < gswdev->tpnum; j++) {
+
+		memset(&Assign_get, 0x00, sizeof(Assign_get));
+		Assign_get.nLogicalPortId = j;
+		ret = GSW_CTP_PortAssignmentGet(cdev, &Assign_get);
+
+		if (ret == GSW_statusErr) {
+			pr_err("GSW_CTP_PortAssignmentGet returns ERROR\n");
+			return GSW_statusErr;
+		}
+
+		printk("\n");
+		printk("\n------ Logical Port %u Configuration ------\n", j);
+		printk("\n\t nLogicalPortId         = %u", Assign_get.nLogicalPortId);
+		printk("\n\t nFirstCtpPortId        = %u", Assign_get.nFirstCtpPortId);
+		printk("\n\t nNumberOfCtpPort       = %u", Assign_get.nNumberOfCtpPort);
+		printk("\n\t eMode                  = %u", Assign_get.eMode);
+		printk("\n\n\t The Following CTP Ports are associated with Logical port %u :", j);
+
+		memset(&CTP_get, 0x00, sizeof(CTP_get));
+		memset(&BP_get, 0x00, sizeof(BP_get));
+		first_port = Assign_get.nFirstCtpPortId;
+		no_port = Assign_get.nNumberOfCtpPort;
+
+		for (i = first_port, k = 0; i < (first_port + no_port); i++, k++) {
+			CTP_get.nLogicalPortId = j;
+			CTP_get.nSubIfIdGroup = k;
+			CTP_get.eMask = 0xffffffff;
+
+			if (!gswdev->ctpportconfig_idx[(first_port + k)].IndexInUse) {
+				continue;
+			}
+
+			ret = GSW_CtpPortConfigGet(cdev, &CTP_get);
+
+			if (ret == GSW_statusErr) {
+				pr_err("GSW_CtpPortConfigGet returns ERROR\n");
+				return GSW_statusErr;
+			}
+
+			BP_get.nBridgePortId = CTP_get.nBridgePortId;
+			BP_get.eMask = 0xffffffff;
+			ret = GSW_BridgePortConfigGet(cdev, &BP_get);
+
+			if (ret == GSW_statusErr) {
+				pr_err("GSW_BridgePortConfigGet returns ERROR\n");
+				return GSW_statusErr;
+			}
+
+			if (i == 287)
+				printk("\n\t\t %u. CTP Ports %u is Default Port--Dummy port (connected to)--> Bridge port %u (Bridge/Fid = %u)\n",
+				       (k + 1), i, CTP_get.nBridgePortId, BP_get.nBridgeId);
+			else
+				printk("\n\t\t %u. CTP Ports %u (connected to)--> Bridge port %u (Bridge/Fid = %u)\n",
+				       (k + 1), i, CTP_get.nBridgePortId, BP_get.nBridgeId);
+
+		}
+
+	}
+
+
+	printk("\n\n");
+	printk("To Get individual CTP port's statistics, Please use following command :\n");
+	printk("switch_cli GSW_DEBUG_CTP_STATISTICS Index=CTP_PORT_INDEX --> example: 0 to 287\n");
+	return GSW_statusOk;
+}
+
+
+GSW_return_t GSW_Debug_GetCtpStatistics(void *cdev, GSW_debug_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 i = 0, j = 0, k = 0, f = 0, match = 0, ctpidx = 0, lp = 0, ret = 0;
+	u32 first_port = 0, no_port = 0, count = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	memset(&Assign_get, 0x00, sizeof(Assign_get));
+	memset(&CTP_get, 0x00, sizeof(CTP_get));
+	memset(&BP_get, 0x00, sizeof(BP_get));
+	memset(&Brdg_get, 0x00, sizeof(Brdg_get));
+	memset(&Pmac_Count, 0x00, sizeof(Pmac_Count));
+	memset(&Rmon_get, 0x00, sizeof(Rmon_get));
+
+
+	printk("\n");
+	ctpidx = parm->nTableIndex;
+	lp = gswdev->ctpportconfig_idx[ctpidx].AssociatedLogicalPort;
+
+	if (!gswdev->ctpportconfig_idx[ctpidx].IndexInUse) {
+		printk("ERROR :CTP Port %u = NotInUse (CTP port not Allocated) and ", ctpidx);
+
+		if (lp == 0xFF)
+			printk("Associated to Logical port = None\n");
+		else
+			printk("Associated to Logical port = %d\n\n", lp);
+
+		printk("\n");
+		printk("Please check CTP to Logical port assignment using following command :\n");
+		printk("switch_cli GSW_DEBUG_LP_STATISTICS\n");
+		return GSW_statusErr;
+	} else {
+		if (lp == 0xFF) {
+			printk("ERROR :CTP Port %d = InUse and ", ctpidx);
+			printk("Associated to Logical port = None\n\n");
+			printk("\n");
+			printk("Please check CTP to Logical port assignment using following command :\n");
+			printk("switch_cli GSW_DEBUG_LP_STATISTICS\n");
+			return GSW_statusErr;
+		} else {
+			memset(&Assign_get, 0x00, sizeof(Assign_get));
+			Assign_get.nLogicalPortId = lp;
+			ret = GSW_CTP_PortAssignmentGet(cdev, &Assign_get);
+
+			if (ret == GSW_statusErr) {
+				pr_err("GSW_CTP_PortAssignmentGet returns ERROR\n");
+				return GSW_statusErr;
+			}
+
+			first_port = Assign_get.nFirstCtpPortId;
+			no_port = Assign_get.nNumberOfCtpPort;
+			CTP_get.nSubIfIdGroup = 0;
+			CTP_get.nLogicalPortId = lp;
+			CTP_get.eMask = 0xFFFFFFFF;
+
+			for (i = first_port; ((i < (first_port + no_port)) && !match); i++) {
+				if ((first_port + CTP_get.nSubIfIdGroup) == ctpidx)
+					match = 1;
+				else
+					CTP_get.nSubIfIdGroup++;
+			}
+
+			if (!match) {
+				printk("ERROR : CTP index %d is not with in the Logical port %d assigned CTP range\n", ctpidx, lp);
+				printk("\n\t nLogicalPortId 		= %u", Assign_get.nLogicalPortId);
+				printk("\n\t nFirstCtpPortId		= %u", Assign_get.nFirstCtpPortId);
+				printk("\n\t nNumberOfCtpPort		= %u", Assign_get.nNumberOfCtpPort);
+				printk("\n\t eMode					= %u", Assign_get.eMode);
+				printk("\n");
+				printk("Please check CTP to Logical port assignment using following command :\n");
+				printk("switch_cli GSW_DEBUG_LP_STATISTICS\n");
+				return GSW_statusErr;
+			}
+
+			ret = GSW_CtpPortConfigGet(cdev, &CTP_get);
+
+			if (ret == GSW_statusErr) {
+				pr_err("GSW_CtpPortConfigGet returns ERROR\n");
+				return GSW_statusErr;
+			}
+
+			BP_get.nBridgePortId = CTP_get.nBridgePortId;
+			BP_get.eMask = 0xffffffff;
+
+			ret = GSW_BridgePortConfigGet(cdev, &BP_get);
+
+			if (ret == GSW_statusErr) {
+				pr_err("GSW_BridgePortConfigGet returns ERROR\n");
+				return GSW_statusErr;
+			}
+
+			Brdg_get.nBridgeId = BP_get.nBridgeId;
+			Brdg_get.eMask = 0xffffffff;
+
+			ret = GSW_BridgeConfigGet(cdev, &Brdg_get);
+
+			if (ret == GSW_statusErr) {
+				pr_err("GSW_BridgeConfigGet returns ERROR\n");
+				return GSW_statusErr;
+			}
+
+		}
+
+		printk("\n\n");
+		printk("\t\t----------------------------------------\n");
+		printk("\t\t\t CTP PORT %d Statistics\n", ctpidx);
+		printk("\t\t----------------------------------------\n");
+		printk("\n\n");
+
+		printk("CTP PORT %u is associated with Logical port %u and Configured with Bridge port %u\n\n", ctpidx, lp, CTP_get.nBridgePortId);
+		printk("Logical Port %d Configuration :\n", lp);
+		printk("\n\t nLogicalPortId         = %u", Assign_get.nLogicalPortId);
+		printk("\n\t nFirstCtpPortId        = %u", Assign_get.nFirstCtpPortId);
+		printk("\n\t nNumberOfCtpPort       = %u", Assign_get.nNumberOfCtpPort);
+		printk("\n\t eMode                  = %u", Assign_get.eMode);
+		printk("\n");
+
+		printk("\nCTP PORT %u Configuration (CTP PORT %u Connected to Bridge Port %u) :", ctpidx, ctpidx, CTP_get.nBridgePortId);
+		printk("\n\t nLogicalPortId 					= %u", CTP_get.nLogicalPortId);
+		printk("\n\t nSubIfIdGroup						= %u", CTP_get.nSubIfIdGroup);
+		memset(&Rmon_get, 0x00, sizeof(GSW_Debug_RMON_Port_cnt_t));
+		Rmon_get.nPortId = Assign_get.nFirstCtpPortId + CTP_get.nSubIfIdGroup;
+		/*bridge port RX rmon*/
+		Rmon_get.ePortType = 0;
+		GSW_Debug_RMON_Port_Get(cdev, &Rmon_get);
+		printk("\n\t\t --Ingress CTP Port  %u RX RMON Counter :", Rmon_get.nPortId);
+		printk("\n\t\t\t nRxGoodPkts             = %u", Rmon_get.nRxGoodPkts);
+		printk("\n\t\t\t nRxUnicastPkts          = %u", Rmon_get.nRxUnicastPkts);
+		printk("\n\t\t\t nRxBroadcastPkts        = %u", Rmon_get.nRxBroadcastPkts);
+		printk("\n\t\t\t nRxMulticastPkts        = %u", Rmon_get.nRxMulticastPkts);
+		printk("\n\t\t\t nRxFCSErrorPkts         = %u", Rmon_get.nRxFCSErrorPkts);
+		printk("\n\t\t\t nRxUnderSizeGoodPkts    = %u", Rmon_get.nRxUnderSizeGoodPkts);
+		printk("\n\t\t\t nRxOversizeGoodPkts     = %u", Rmon_get.nRxOversizeGoodPkts);
+		printk("\n\t\t\t nRxUnderSizeErrorPkts   = %u", Rmon_get.nRxUnderSizeErrorPkts);
+		printk("\n\t\t\t nRxOversizeErrorPkts    = %u", Rmon_get.nRxOversizeErrorPkts);
+		printk("\n\t\t\t nRxFilteredPkts         = %u", Rmon_get.nRxFilteredPkts);
+		printk("\n\t\t\t nRxDroppedPkts          = %u", Rmon_get.nRxDroppedPkts);
+		printk("\n\t nBridgePortId                      = %u", CTP_get.nBridgePortId);
+		printk("\n\t bForcedTrafficClass                = %u", CTP_get.bForcedTrafficClass);
+		printk("\n\t nDefaultTrafficClass               = %u", CTP_get.nDefaultTrafficClass);
+		printk("\n\t bIngressExtendedVlanEnable         = %u", CTP_get.bIngressExtendedVlanEnable);
+		printk("\n\t bIngressExtendedVlanIgmpEnable     = %u", CTP_get.bIngressExtendedVlanIgmpEnable);
+		printk("\n\t bEgressExtendedVlanEnable          = %u", CTP_get.bEgressExtendedVlanEnable);
+		printk("\n\t bEgressExtendedVlanIgmpEnable      = %u", CTP_get.bEgressExtendedVlanIgmpEnable);
+		printk("\n\t bIngressNto1VlanEnable             = %u", CTP_get.bIngressNto1VlanEnable);
+		printk("\n\t bEgressNto1VlanEnable              = %u", CTP_get.bEgressNto1VlanEnable);
+		printk("\n\t bIngressMeteringEnable             = %u", CTP_get.bIngressMeteringEnable);
+		printk("\n\t bEgressMeteringEnable              = %u", CTP_get.bEgressMeteringEnable);
+		printk("\n\t bBridgingBypassEnable              = %u", CTP_get.bBridgingBypass);
+
+		if (CTP_get.bBridgingBypass) {
+			printk("\n\tCTP PORT %u Egress Configuration (Bridge ByPass Enabled) :", ctpidx);
+			printk("\n\t nDestLogicalPortId 				= %u", CTP_get.nDestLogicalPortId);
+			printk("\n\t nDestSubIfIdGroup					= %u", CTP_get.nDestSubIfIdGroup);
+			printk("\n\t bPmapperEnable 					= %u", CTP_get.bPmapperEnable);
+
+			if (CTP_get.bPmapperEnable) {
+				printk("\n\t ePmapperMappingMode				= %u", CTP_get.ePmapperMappingMode);
+				printk("\n\t nPmapperId 						= %u", BP_get.sPmapper.nPmapperId);
+			}
+		}
+
+		printk("\n");
+
+		printk("\nBridge PORT %u Configuration (Bridge PORT %u Connected to Bridge/Fid %u) :",
+		       CTP_get.nBridgePortId, CTP_get.nBridgePortId, BP_get.nBridgeId);
+		printk("\n\t nBridgePortId                                      = %u", BP_get.nBridgePortId);
+		memset(&Rmon_get, 0x00, sizeof(GSW_Debug_RMON_Port_cnt_t));
+		Rmon_get.nPortId = BP_get.nBridgePortId;
+		/*bridge port RX rmon*/
+		Rmon_get.ePortType = 2;
+		GSW_Debug_RMON_Port_Get(cdev, &Rmon_get);
+		printk("\n\t\t --Ingress Bridge Port  %u RX RMON Counter :", BP_get.nBridgePortId);
+		printk("\n\t\t\t nRxGoodPkts             = %u", Rmon_get.nRxGoodPkts);
+		printk("\n\t\t\t nRxUnicastPkts          = %u", Rmon_get.nRxUnicastPkts);
+		printk("\n\t\t\t nRxBroadcastPkts        = %u", Rmon_get.nRxBroadcastPkts);
+		printk("\n\t\t\t nRxMulticastPkts        = %u", Rmon_get.nRxMulticastPkts);
+		printk("\n\t\t\t nRxFCSErrorPkts         = %u", Rmon_get.nRxFCSErrorPkts);
+		printk("\n\t\t\t nRxUnderSizeGoodPkts    = %u", Rmon_get.nRxUnderSizeGoodPkts);
+		printk("\n\t\t\t nRxOversizeGoodPkts     = %u", Rmon_get.nRxOversizeGoodPkts);
+		printk("\n\t\t\t nRxUnderSizeErrorPkts   = %u", Rmon_get.nRxUnderSizeErrorPkts);
+		printk("\n\t\t\t nRxOversizeErrorPkts    = %u", Rmon_get.nRxOversizeErrorPkts);
+		printk("\n\t\t\t nRxFilteredPkts         = %u", Rmon_get.nRxFilteredPkts);
+		printk("\n\t\t\t nRxDroppedPkts          = %u", Rmon_get.nRxDroppedPkts);
+		printk("\n\t nBridgeId                                          = %u", BP_get.nBridgeId);
+		printk("\n\t\t --nBridgeId/FID %u's Configuration :", BP_get.nBridgeId);
+		printk("\n\t\t\t nMacLearningLimit                  = %u", Brdg_get.nMacLearningLimit);
+		printk("\n\t\t\t nMacLearningCount                  = %u", Brdg_get.nMacLearningCount);
+		printk("\n\t\t\t nLearningDiscardEvent              = %u", Brdg_get.nLearningDiscardEvent);
+		printk("\n\t\t\t bBroadcastMeterEnable              = %u", Brdg_get.bSubMeteringEnable[0]);
+		printk("\n\t\t\t bMulticastMeterEnable              = %u", Brdg_get.bSubMeteringEnable[1]);
+		printk("\n\t\t\t bUnknownMulticastIpMeterEnable     = %u", Brdg_get.bSubMeteringEnable[2]);
+		printk("\n\t\t\t bUnknownMulticastNonIpMeterEnable  = %u", Brdg_get.bSubMeteringEnable[3]);
+		printk("\n\t\t\t bUnknownUniCastMeterEnable         = %u", Brdg_get.bSubMeteringEnable[4]);
+		printk("\n\t bIngressExtendedVlanEnable                         = %u", BP_get.bIngressExtendedVlanEnable);
+		printk("\n\t bEgressExtendedVlanEnable                          = %u", BP_get.bEgressExtendedVlanEnable);
+		printk("\n\t bIngressMeteringEnable                             = %u", BP_get.bIngressMeteringEnable);
+		printk("\n\t bEgressMeteringEnable                              = %u", BP_get.bEgressSubMeteringEnable[5]);
+		printk("\n\t bEgressBroadcastSubMeteringEnable                  = %u", BP_get.bEgressSubMeteringEnable[0]);
+		printk("\n\t bEgressMulticastSubMeteringEnable                  = %u", BP_get.bEgressSubMeteringEnable[1]);
+		printk("\n\t bEgressUnknownMulticastIPSubMeteringEnable         = %u", BP_get.bEgressSubMeteringEnable[2]);
+		printk("\n\t bEgressUnknownMulticastNonIPSubMeteringEnable      = %u", BP_get.bEgressSubMeteringEnable[3]);
+		printk("\n\t bEgressUnknownUnicastSubMeteringEnable             = %u", BP_get.bEgressSubMeteringEnable[4]);
+		printk("\n\t bPmapperEnable                                     = %u", BP_get.bPmapperEnable);
+		printk("\n\t nMacLearningLimit                                  = %u", BP_get.nMacLearningLimit);
+		printk("\n\t nMacLearningCount                                  = %u", BP_get.nMacLearningCount);
+		printk("\n\t bIngressVlanFilterEnable                           = %u", BP_get.bIngressVlanFilterEnable);
+		printk("\n\t bBypassEgressVlanFilter1Enable                     = %u", BP_get.bBypassEgressVlanFilter1);
+		printk("\n\t bEgressVlanFilter1Enable                           = %u", BP_get.bEgressVlanFilter1Enable);
+		printk("\n\t bEgressVlanFilter2Enable                           = %u", BP_get.bEgressVlanFilter2Enable);
+
+		for (j = 0; j < 8; j++)
+			printk("\n\t nBridgePortMapIndex[%u]                             = 0x%x", j, BP_get.nBridgePortMap[j]);
+
+		printk("\n");
+		printk("\nBridge PORT %u's Egress Configuration :", BP_get.nBridgePortId);
+		printk("\n\t nDestLogicalPortId           = %u", BP_get.nDestLogicalPortId);
+		printk("\n\t nDestSubIfIdGroup            = %u", BP_get.nDestSubIfIdGroup);
+
+		if (BP_get.bPmapperEnable) {
+			printk("\n\t ePmapperMappingMode                                = %u", BP_get.ePmapperMappingMode);
+			printk("\n\t nPmapperId 										= %u", BP_get.sPmapper.nPmapperId);
+		}
+
+		printk("\n\n");
+		printk("\nBridge PORT %u (Ingress) is Mapped to Following Egress Bridge Ports :", BP_get.nBridgePortId);
+		count = 0;
+
+		for (j = 0, k = 0; j < 8; j++) {
+			for (i = 0; i < 16; i++, k++) {
+				if (BP_get.nBridgePortMap[j] & (1 << i)) {
+					memset(&Temp_BP_get, 0x00, sizeof(Temp_BP_get));
+					Temp_BP_get.nBridgePortId = k;
+					Temp_BP_get.eMask = 0xffffffff;
+					ret = GSW_BridgePortConfigGet(cdev, &Temp_BP_get);
+
+					if (ret == GSW_statusErr) {
+						pr_err("GSW_BridgePortConfigGet(EGBP) returns ERROR\n");
+						return GSW_statusErr;
+					}
+
+					count++;
+					printk("\n\t Egress BP ---------------------------------------- = %u", k);
+					memset(&Rmon_get, 0x00, sizeof(Rmon_get));
+					Rmon_get.nPortId = k;
+					/*bridge port TX rmon*/
+					Rmon_get.ePortType = 3;
+					GSW_Debug_RMON_Port_Get(cdev, &Rmon_get);
+					printk("\n\t\t --Egress Bridge Port  %u TX RMON Counter :", k);
+					printk("\n\t\t\t nTxGoodPkts       = %u", Rmon_get.nTxGoodPkts);
+					printk("\n\t\t\t nTxUnicastPkt     = %u", Rmon_get.nTxUnicastPkts);
+					printk("\n\t\t\t nTxBroadcastPkts  = %u", Rmon_get.nTxBroadcastPkts);
+					printk("\n\t\t\t nTxMulticastPkts  = %u", Rmon_get.nTxMulticastPkts);
+					printk("\n\t\t\t nTxDroppedPkts    = %u", Rmon_get.nTxDroppedPkts);
+					printk("\n\t\t nDestLogicalPortId 								    = %u", Temp_BP_get.nDestLogicalPortId);
+					printk("\n\t\t nDestSubIfIdGroup									= %u", Temp_BP_get.nDestSubIfIdGroup);
+
+					if (Temp_BP_get.bPmapperEnable) {
+						printk("\n\t\t ePmapperMappingMode								= %u", Temp_BP_get.ePmapperMappingMode);
+						printk("\n\t\t nPmapperId 										= %u", Temp_BP_get.sPmapper.nPmapperId);
+					} else {
+						memset(&Assign_get, 0x00, sizeof(Assign_get));
+						Assign_get.nLogicalPortId = Temp_BP_get.nDestLogicalPortId;
+						ret = GSW_CTP_PortAssignmentGet(cdev, &Assign_get);
+
+						if (ret == GSW_statusErr) {
+							pr_err("GSW_CTP_PortAssignmentGet (EGBP) returns ERROR\n");
+							return GSW_statusErr;
+						}
+
+						printk("\n\t\t\t --Destination Logical Port %d's Configuration :", Temp_BP_get.nDestLogicalPortId);
+						printk("\n\t\t\t\t nLogicalPortId       = %u", Assign_get.nLogicalPortId);
+						printk("\n\t\t\t\t nFirstCtpPortId      = %u", Assign_get.nFirstCtpPortId);
+						printk("\n\t\t\t\t nNumberOfCtpPort     = %u", Assign_get.nNumberOfCtpPort);
+						printk("\n\t\t\t\t eMode                = %u", Assign_get.eMode);
+						memset(&Rmon_get, 0x00, sizeof(Rmon_get));
+						Rmon_get.nPortId = Assign_get.nFirstCtpPortId + Temp_BP_get.nDestSubIfIdGroup;
+						/*ctp port TX rmon*/
+						Rmon_get.ePortType = 1;
+						GSW_Debug_RMON_Port_Get(cdev, &Rmon_get);
+						printk("\n\n\t\t\t --NOTE : FirstCtp(%u) of (Dst LP %u) + DstSubId(%u) of (EGBP %u)",
+						       Assign_get.nFirstCtpPortId, Assign_get.nLogicalPortId, Temp_BP_get.nDestSubIfIdGroup,
+						       k);
+						printk("\n\t\t\t Egress CTP Port %u TX RMON Counter :", k);
+						printk("\n\t\t\t\t nTxGoodPkts       = %u", Rmon_get.nTxGoodPkts);
+						printk("\n\t\t\t\t nTxUnicastPkt     = %u", Rmon_get.nTxUnicastPkts);
+						printk("\n\t\t\t\t nTxBroadcastPkts  = %u", Rmon_get.nTxBroadcastPkts);
+						printk("\n\t\t\t\t nTxMulticastPkts  = %u", Rmon_get.nTxMulticastPkts);
+						printk("\n\t\t\t\t nTxDroppedPkts    = %u", Rmon_get.nTxDroppedPkts);
+					}
+
+					printk("\n");
+					printk("\n\t\t nDestLogicalPortId %u's PCE queue mapping Configuration as per Traffic Class :", Temp_BP_get.nDestLogicalPortId);
+
+					/*Traffic Class from 0 to 15*/
+					for (f = 0; f < 16; f++) {
+						memset(&q_map, 0, sizeof(GSW_QoS_queuePort_t));
+						q_map.nTrafficClassId = i;
+						q_map.nPortId = Temp_BP_get.nDestLogicalPortId;
+						GSW_QoS_QueuePortGet(cdev, &q_map);
+						printk("\n\t\t\t TC = %u, QId = %u, QMapMode = %u, ExEna = %u, RedirectPortId = %u\n",
+						       q_map.nTrafficClassId, q_map.nQueueId, q_map.eQMapMode, q_map.bExtrationEnable, q_map.nRedirectPortId);
+
+						if (q_map.nRedirectPortId == 0 || q_map.nRedirectPortId == 1) {
+							memset(&Pmac_Count, 0x00, sizeof(Pmac_Count));
+							Pmac_Count.nPmacId = q_map.nRedirectPortId;
+							Pmac_Count.nTxDmaChanId = lp;
+							GSW_PMAC_CountGet(cdev, &Pmac_Count);
+							printk("\t\t\t\t nPmacId                            = %u\n", Pmac_Count.nPmacId);
+							printk("\t\t\t\t nTxDmaChanId                       = %u\n", Pmac_Count.nTxDmaChanId);
+							printk("\t\t\t\t Ingress Discard Packet Count       = %u\n", Pmac_Count.nDiscPktsCount);
+							printk("\t\t\t\t Ingress Discard Byte Count         = %u\n", Pmac_Count.nDiscBytesCount);
+							printk("\t\t\t\t Egress Checksum Error Packet Count = %u\n", Pmac_Count.nChkSumErrPktsCount);
+							printk("\t\t\t\t Egress Checksum Error Byte Count   = %u\n", Pmac_Count.nChkSumErrBytesCount);
+							printk("\t\t\t\t Ingress Total Packet Count         = %u\n", Pmac_Count.nIngressPktsCount);
+							printk("\t\t\t\t Ingress Total Byte Count           = %u\n", Pmac_Count.nIngressBytesCount);
+							printk("\t\t\t\t Egress Total Packet Count          = %u\n", Pmac_Count.nEgressPktsCount);
+							printk("\t\t\t\t Egress Total Byte Count            = %u\n", Pmac_Count.nEgressBytesCount);
+						}
+					}
+				}
+			}
+		}
+
+		if (!count)
+			printk("\nIs Mapped to None !!!\n");
+	}
+
+	printk("\n");
+	printk("NOTE:\n");
+	printk("To Get PCE BYPASS Qmapping info,Please use the following command :\n");
+	printk("switch_cli GSW_DEBUG_DEF_BYP_QMAP\n");
+
+	printk("\n");
+	printk("NOTE:\n");
+	printk("To Get CTP to Logical port assignment statistics (for all logical ports) using following command :\n");
+	printk("switch_cli GSW_DEBUG_LP_STATISTICS\n");
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_Debug_CtpTableStatus(void *cdev, GSW_debug_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 j, lp = 0, bp = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	printk("\n");
+
+	if (parm->nCheckIndexInUse) {
+		for (j = 0; j < gswdev->num_of_ctp; j++) {
+			if (gswdev->ctpportconfig_idx[j].IndexInUse) {
+				lp = gswdev->ctpportconfig_idx[j].AssociatedLogicalPort;
+				bp = gswdev->ctpportconfig_idx[j].BrdgPortId;
+
+				if (lp == 0xFF)
+					printk("CTP Port %d	= InUse, Associated to Logical port = None and Configured with BrdgPort Id %d.\n", j, bp);
+				else
+					printk("CTP Port %d	= InUse, Associated to Logical port = %d and Configured with BrdgPort Id %d.\n", j, lp, bp);
+			}
+		}
+
+		return GSW_statusOk;
+	}
+
+	if (parm->nForceSet) {
+		gswdev->ctpportconfig_idx[parm->nTableIndex].IndexInUse = 1;
+		printk("\nCTP Port Table Index %d is Forced to InUSe\n", parm->nTableIndex);
+	} else {
+		printk("\nCTP Port Table Index %d:\n\n", parm->nTableIndex);
+		printk("IndexInUse							 = %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].IndexInUse);
+		printk("IndexInUsageCnt						 = %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].IndexInUsageCnt);
+
+		lp = gswdev->ctpportconfig_idx[parm->nTableIndex].AssociatedLogicalPort;
+
+		if (lp == 0xFF)
+			printk("AssociatedLogicalPort				 = None\n");
+		else
+			printk("AssociatedLogicalPort				 = %d\n", lp);
+
+		printk("BrdgIdPortAssigned						= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].BrdgIdPortAssigned);
+		printk("BrdgPortId								= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].BrdgPortId);
+		printk("IngressExVlanNonIgmpBlkAssigned			= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].IngressExVlanNonIgmpBlkAssigned);
+		printk("IngressExVlanIgmpBlkId					= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].IngressExVlanIgmpBlkId);
+		printk("IngressExVlanIgmpBlkAssigned			= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].IngressExVlanIgmpBlkAssigned);
+		printk("IngressMeteringAssigned					= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].IngressMeteringAssigned);
+		printk("IngressTrafficMeterId					= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].IngressTrafficMeterId);
+		printk("IngressBridgeBypassPmapperAssigned		= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].IngressBridgeBypassPmapperAssigned);
+		printk("IngressBridgeBypassPmappperId			= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].IngressBridgeBypassPmappperIdx);
+		printk("EgressExVlanNonIgmpBlkAssigned			= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].EgressExVlanNonIgmpBlkAssigned);
+		printk("EgressExVlanNonIgmpBlkId				= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].EgressExVlanNonIgmpBlkId);
+		printk("EgressExVlanIgmpBlkAssigned				= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].EgressExVlanIgmpBlkAssigned);
+		printk("EgressExVlanIgmpBlkId					= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].EgressExVlanIgmpBlkId);
+		printk("EgressMeteringAssigned					= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].EgressMeteringAssigned);
+		printk("EgressTrafficMeterId					= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].EgressTrafficMeterId);
+		printk("IngressTflowAssigned					= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].IngressTflowAssigned);
+		printk("IngressTflowFirstIdx					= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].IngressTflowFirstIdx);
+		printk("IngressTflowNumberOfEntrys				= %d\n", gswdev->ctpportconfig_idx[parm->nTableIndex].IngressTflowNumberOfEntrys);
+	}
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_Debug_BrgPortTableStatus(void *cdev, GSW_debug_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 j, b = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	printk("\n");
+
+	if (parm->nCheckIndexInUse) {
+		for (j = 0; j < gswdev->num_of_bridge_port; j++) {
+			if (gswdev->brdgeportconfig_idx[j].IndexInUse) {
+				b = gswdev->brdgeportconfig_idx[j].BrdgId;
+				printk("Bridge Port %d	= InUse, Configured with Brdg Id/Fid %d.\n", j, b);
+			}
+		}
+
+		return GSW_statusOk;
+	}
+
+	if (parm->nForceSet) {
+		gswdev->brdgeportconfig_idx[parm->nTableIndex].IndexInUse = 1;
+		printk("\nBridge Port table Index %d is Forced to InUSe\n", parm->nTableIndex);
+
+	} else {
+
+		printk("\n");
+		printk("BridgePort Table Index %d:\n\n", parm->nTableIndex);
+		printk("IndexInUse							 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].IndexInUse);
+		printk("IndexInUsageCnt						 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].IndexInUsageCnt);
+		printk("BrdgIdAssigned						 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].BrdgIdAssigned);
+		printk("BrdgId								 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].BrdgId);
+		printk("IngressExVlanBlkAssigned 			 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].IngressExVlanBlkAssigned);
+		printk("IngressExVlanBlkId					 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].IngressExVlanBlkId);
+		printk("EgressExVlanBlkAssigned				 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].EgressExVlanBlkAssigned);
+		printk("EgressExVlanBlkId					 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].EgressExVlanBlkId);
+		printk("IngressMeteringAssigned				 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].IngressMeteringAssigned);
+		printk("IngressTrafficMeterId				 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].IngressTrafficMeterId);
+		printk("EgressMeteringAssigned				 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].EgressMeteringAssigned);
+		printk("EgressTrafficMeterId 				 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].EgressTrafficMeterId);
+		printk("BroadcastMeteringAssigned			 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].BroadcastMeteringAssigned);
+		printk("BroadcastMeteringId					 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].BroadcastMeteringId);
+		printk("MulticastMeteringAssigned			 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].MulticastMeteringAssigned);
+		printk("MulticastMeteringId					 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].MulticastMeteringId);
+		printk("UnknownUniCastMeteringAssigned		 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].UnknownUniCastMeteringAssigned);
+		printk("UnknownUniCastMeteringId 			 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].UnknownUniCastMeteringId);
+		printk("UnknownMultiIpMeteringAssigned		 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].UnknownMultiIpMeteringAssigned);
+		printk("UnknownMultiIpMeteringId 			 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].UnknownMultiIpMeteringId);
+		printk("UnknownMultiNonIpMeteringAssigned	 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].UnknownMultiNonIpMeteringAssigned);
+		printk("UnknownMultiNonIpMeteringId			 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].UnknownMultiNonIpMeteringId);
+		printk("PmapperAssigned						 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].PmapperAssigned);
+		printk("PmappperIdx							 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].PmappperIdx);
+		printk("IngressVlanFilterAssigned			 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].IngressVlanFilterBlkId);
+		printk("IngressVlanFilterBlkId				 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].UnknownMultiNonIpMeteringId);
+		printk("EgressVlanFilter1Assigned			 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].EgressVlanFilter1Assigned);
+		printk("EgressVlanFilter1BlkId				 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].EgressVlanFilter1BlkId);
+		printk("EgressVlanFilter2Assigned			 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].EgressVlanFilter2Assigned);
+		printk("EgressVlanFilter2BlkId				 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].EgressVlanFilter2BlkId);
+		printk("StpState 							 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].StpState);
+		printk("P8021xState							 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].P8021xState);
+		printk("LearningLimit						 = %d\n", gswdev->brdgeportconfig_idx[parm->nTableIndex].LearningLimit);
+	}
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_Debug_BrgTableStatus(void *cdev, GSW_debug_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 j;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	printk("\n");
+
+	if (parm->nCheckIndexInUse) {
+		for (j = 0; j < gswdev->num_of_bridge_port; j++) {
+			if (gswdev->brdgeconfig_idx[j].IndexInUse) {
+				printk("Bridge  %d	= InUse.\n", j);
+			}
+		}
+
+		return GSW_statusOk;
+	}
+
+	if (parm->nForceSet) {
+		gswdev->brdgeconfig_idx[parm->nTableIndex].IndexInUse = 1;
+		printk("Bridge Table Index %d is Forced to InUSe\n", parm->nTableIndex);
+	} else {
+		printk("Brdg Table Index %d:\n\n", parm->nTableIndex);
+		printk("IndexInUse							 = %d\n", gswdev->brdgeconfig_idx[parm->nTableIndex].IndexInUse);
+		printk("IndexInUsageCnt						 = %d\n", gswdev->brdgeconfig_idx[parm->nTableIndex].IndexInUsageCnt);
+		printk("BroadcastMeteringAssigned			 = %d\n", gswdev->brdgeconfig_idx[parm->nTableIndex].BroadcastMeteringAssigned);
+		printk("BroadcastMeteringId					 = %d\n", gswdev->brdgeconfig_idx[parm->nTableIndex].BroadcastMeteringId);
+		printk("MulticastMeteringAssigned			 = %d\n", gswdev->brdgeconfig_idx[parm->nTableIndex].MulticastMeteringAssigned);
+		printk("MulticastMeteringId					 = %d\n", gswdev->brdgeconfig_idx[parm->nTableIndex].MulticastMeteringId);
+		printk("UnknownUniCastMeteringAssigned		 = %d\n", gswdev->brdgeconfig_idx[parm->nTableIndex].UnknownUniCastMeteringAssigned);
+		printk("UnknownUniCastMeteringId 			 = %d\n", gswdev->brdgeconfig_idx[parm->nTableIndex].UnknownUniCastMeteringId);
+		printk("UnknownMultiIpMeteringAssigned		 = %d\n", gswdev->brdgeconfig_idx[parm->nTableIndex].UnknownMultiIpMeteringAssigned);
+		printk("UnknownMultiIpMeteringId 			 = %d\n", gswdev->brdgeconfig_idx[parm->nTableIndex].UnknownMultiIpMeteringId);
+		printk("UnknownMultiNonIpMeteringAssigned	 = %d\n", gswdev->brdgeconfig_idx[parm->nTableIndex].UnknownMultiNonIpMeteringAssigned);
+		printk("UnknownMultiNonIpMeteringId			 = %d\n", gswdev->brdgeconfig_idx[parm->nTableIndex].UnknownMultiNonIpMeteringId);
+	}
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_Debug_ExvlanTableStatus(void *cdev, GSW_debug_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 j, blockid = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	printk("\n");
+
+	if (parm->nCheckIndexInUse) {
+		for (j = 0; j < gswdev->num_of_extendvlan; j++) {
+			if (gswdev->extendvlan_idx.vlan_idx[j].IndexInUse) {
+				blockid = gswdev->extendvlan_idx.vlan_idx[j].VlanBlockId;
+				printk("ExVlan Table Index  %d = InUse, Associated to ExVlan Block Id %d.\n", j, blockid);
+			}
+		}
+
+		return GSW_statusOk;
+	}
+
+	if (parm->nForceSet) {
+		gswdev->extendvlan_idx.vlan_idx[parm->nTableIndex].IndexInUse = 1;
+		gswdev->extendvlan_idx.vlan_idx[parm->nTableIndex].VlanBlockId = parm->nblockid;
+		gswdev->extendvlan_idx.nUsedEntry++;
+		printk("Exvlan Table Index  %d is Forced to InUSe\n", parm->nTableIndex);
+	} else {
+		printk("Exvlan Table Index %d:\n\n", parm->nTableIndex);
+		printk("BlockId						= %d\n", gswdev->extendvlan_idx.vlan_idx[parm->nTableIndex].VlanBlockId);
+		printk("IndexInUse					= %d\n", gswdev->extendvlan_idx.vlan_idx[parm->nTableIndex].IndexInUse);
+		printk("IndexInUsageCnt				= %d\n", gswdev->extendvlan_idx.vlan_idx[parm->nTableIndex].IndexInUsageCnt);
+		printk("Dscp2PcpPointerAssigned		= %d\n", gswdev->extendvlan_idx.vlan_idx[parm->nTableIndex].Dscp2PcpPointerAssigned);
+		printk("Dscp2PcpPointer				= %d\n", gswdev->extendvlan_idx.vlan_idx[parm->nTableIndex].Dscp2PcpPointer);
+		printk("MeterAssigned				= %d\n", gswdev->extendvlan_idx.vlan_idx[parm->nTableIndex].MeterAssigned);
+		printk("MeterId						= %d\n", gswdev->extendvlan_idx.vlan_idx[parm->nTableIndex].MeterId);
+		printk("Number Exvlan table entry used	= %d\n", gswdev->extendvlan_idx.nUsedEntry);
+	}
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_Debug_VlanFilterTableStatus(void *cdev, GSW_debug_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 j, blockid = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	printk("\n");
+
+	if (parm->nCheckIndexInUse) {
+		for (j = 0; j < gswdev->num_of_vlanfilter; j++) {
+			if (gswdev->vlanfilter_idx.filter_idx[j].IndexInUse) {
+				blockid = gswdev->vlanfilter_idx.filter_idx[j].FilterBlockId;
+				printk("Vlan Filter Table Index  %d = InUse, Associated to Vlan Filetr Block Id %d.\n", j, blockid);
+			}
+		}
+
+		return GSW_statusOk;
+	}
+
+	if (parm->nForceSet) {
+		gswdev->vlanfilter_idx.filter_idx[parm->nTableIndex].IndexInUse = 1;
+		gswdev->vlanfilter_idx.filter_idx[parm->nTableIndex].FilterBlockId = parm->nblockid;
+		gswdev->vlanfilter_idx.filter_idx[parm->nTableIndex].DiscardUntagged = parm->nDiscardUntagged;
+		gswdev->vlanfilter_idx.filter_idx[parm->nTableIndex].DiscardUnMatchedTagged = parm->nDiscardUnMatchedTagged;
+		gswdev->vlanfilter_idx.nUsedEntry++;
+		printk("Vlan Filter Table Index  %d is Forced to InUSe\n", parm->nTableIndex);
+	} else {
+		printk("Vlan Filter Table Index %d:\n\n", parm->nTableIndex);
+		printk("FilterBlockId			= %d\n", gswdev->vlanfilter_idx.filter_idx[parm->nTableIndex].FilterBlockId);
+		printk("IndexInUse				= %d\n", gswdev->vlanfilter_idx.filter_idx[parm->nTableIndex].IndexInUse);
+		printk("IndexInUsageCnt			= %d\n", gswdev->vlanfilter_idx.filter_idx[parm->nTableIndex].IndexInUsageCnt);
+		printk("DiscardUntagged			= %d\n", gswdev->vlanfilter_idx.filter_idx[parm->nTableIndex].DiscardUntagged);
+		printk("DiscardUnMatchedTagged  = %d\n", gswdev->vlanfilter_idx.filter_idx[parm->nTableIndex].DiscardUnMatchedTagged);
+		printk("FilterMask				= %d\n", gswdev->vlanfilter_idx.filter_idx[parm->nTableIndex].FilterMask);
+		printk("Number Vlan Filter table entry used = %d\n", gswdev->vlanfilter_idx.nUsedEntry);
+	}
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_Debug_MeterTableStatus(void *cdev, GSW_debug_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 j;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	printk("\n");
+
+	if (parm->nCheckIndexInUse) {
+		for (j = 0; j < gswdev->num_of_meters; j++) {
+			if (gswdev->meter_idx[parm->nTableIndex].IndexInUse) {
+				printk("Meter Table Index  %d = InUse.\n", j);
+			}
+		}
+
+		return GSW_statusOk;
+	}
+
+	if (parm->nForceSet) {
+		gswdev->meter_idx[parm->nTableIndex].IndexInUse = 1;
+		printk("Meter Table Index  %d is Forced to InUSe\n", parm->nTableIndex);
+
+	} else {
+		printk("Meter Table Index %d:\n\n", parm->nTableIndex);
+		printk("IndexInUse			   = %d\n", gswdev->meter_idx[parm->nTableIndex].IndexInUse);
+		printk("IndexInUsageCnt		   = %d\n", gswdev->meter_idx[parm->nTableIndex].IndexInUsageCnt);
+	}
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_Debug_Dscp2PcpTableStatus(void *cdev, GSW_debug_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	printk("\n");
+
+	if (parm->nForceSet) {
+		gswdev->dscp2pcp_idx[parm->nTableIndex].IndexInUse = 1;
+		printk("Dscp2Pcp Table Index  %d is Forced to InUSe\n", parm->nTableIndex);
+	} else {
+		printk("Dscp2Pcp Table Index %d:\n\n", parm->nTableIndex);
+		printk("IndexInUse							 = %d\n", gswdev->dscp2pcp_idx[parm->nTableIndex].IndexInUse);
+		printk("IndexInUsageCnt						 = %d\n", gswdev->dscp2pcp_idx[parm->nTableIndex].IndexInUsageCnt);
+	}
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_Debug_PmapperTableStatus(void *cdev, GSW_debug_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 j;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	printk("\n");
+
+	if (parm->nCheckIndexInUse) {
+		for (j = 0; j < gswdev->num_of_pmapper; j++) {
+			if (gswdev->pmapper_idx[j].IndexInUse) {
+				printk("P-Mapper Table Index  %d = InUse.\n", j);
+			}
+		}
+
+		return GSW_statusOk;
+	}
+
+	if (parm->nForceSet) {
+		gswdev->pmapper_idx[parm->nTableIndex].IndexInUse = 1;
+		printk("P-Mapper Table Index  %d is Forced to InUSe\n", parm->nTableIndex);
+	} else {
+		printk("P-Mapper Table Index %d:\n\n", parm->nTableIndex);
+		printk("IndexInUse			   = %d\n", gswdev->pmapper_idx[parm->nTableIndex].IndexInUse);
+		printk("IndexInUsageCnt		   = %d\n", gswdev->pmapper_idx[parm->nTableIndex].IndexInUsageCnt);
+	}
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_Debug_PmacBpTable(void *cdev, GSW_debug_t *parm)
+{
+	pmac_get_bp_cfg(cdev, parm->nPmacId);
+	return GSW_statusOk;
+}
+GSW_return_t GSW_Debug_PmacEgTable(void *cdev, GSW_debug_t *parm)
+{
+	pmac_get_eg_cfg(cdev, parm->nPmacId, parm->nDestPort);
+	return GSW_statusOk;
+}
+GSW_return_t GSW_Debug_PmacIgTable(void *cdev, GSW_debug_t *parm)
+{
+	pmac_get_ig_cfg(cdev, parm->nPmacId);
+	return GSW_statusOk;
+}
+GSW_return_t GSW_Debug_PceBypassTable(void *cdev, GSW_debug_t *parm)
+{
+	gsw_get_def_bypass_qmap(cdev);
+	return GSW_statusOk;
+}
+GSW_return_t GSW_Debug_PceQTable(void *cdev, GSW_debug_t *parm)
+{
+	gsw_get_def_pce_qmap(cdev);
+	return GSW_statusOk;
+
+}
+
+GSW_return_t GSW_XgmacCfg(void *cdev, GSW_MAC_cfg_t *mac_cfg)
+{
+	struct mac_ops *ops = NULL;
+	u8 *argv[10];
+	int i = 0;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		pr_err("XGMAC Cfg Supported only in GSWIP3.1 and above\n");
+		return GSW_statusErr;
+	}
+
+
+	ops = gsw_get_mac_ops(0, 0);
+
+	if (!ops) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	for (i = 0; i < mac_cfg->argc; i++)
+		argv[i] = mac_cfg->argv[i];
+
+
+	ops->xgmac_cli(mac_cfg->argc, argv);
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_GswssCfg(void *cdev, GSW_MAC_cfg_t *adap_cfg)
+{
+	struct adap_ops *ops = NULL;
+	u8 *argv[10];
+	int i = 0;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		pr_err("GSWSS Cfg Supported only in GSWIP3.1 and above\n");
+		return GSW_statusErr;
+	}
+
+
+	ops = gsw_get_adap_ops(0);
+
+	if (!ops) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	for (i = 0; i < adap_cfg->argc; i++)
+		argv[i] = adap_cfg->argv[i];
+
+	ops->ss_cli(adap_cfg->argc, argv);
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_LmacCfg(void *cdev, GSW_MAC_cfg_t *lmac_cfg)
+{
+	struct mac_ops *ops = NULL;
+	u8 *argv[10];
+	int i = 0;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		pr_err("LMAC Cfg Supported only in GSWIP3.1 and above\n");
+		return GSW_statusErr;
+	}
+
+	ops = gsw_get_mac_ops(0, 0);
+
+	if (!ops) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	for (i = 0; i < lmac_cfg->argc; i++)
+		argv[i] = lmac_cfg->argv[i];
+
+	ops->lmac_cli(lmac_cfg->argc, argv);
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_MacsecCfg(void *cdev, GSW_MAC_cfg_t *macsec_cfg)
+{
+
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+#if 0	
+	u8 *argv[10];
+	int i = 0;
+	struct macsec_ops *ops = NULL;
+#endif
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		pr_err("Macsec Cfg Supported only in GSWIP3.1 and above\n");
+		return GSW_statusErr;
+	}
+#if 0
+	ops = gsw_get_macsec_ops(0, 0);
+
+	if (!ops) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	for (i = 0; i < macsec_cfg->argc; i++)
+		argv[i] = macsec_cfg->argv[i];
+
+
+	ops->macsec_cli(macsec_cfg->argc, argv);
+#endif
+	return GSW_statusOk;
+}
+
+
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c b/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c
new file mode 100644
index 000000000000..b3bb09e6a7ea
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.c
@@ -0,0 +1,702 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#include <gsw_init.h>
+#include <gsw_defconf.h>
+
+#define PMAC0_TX_DMACHID_START	0
+#define PMAC0_TX_DMACHID_END	16
+#define PMAC1_TX_DMACHID_START	0
+#define PMAC1_TX_DMACHID_END	0
+
+#define PMAC0_DST_PRT_START	0
+#define PMAC0_DST_PRT_END	11
+#define PMAC1_DST_PRT_START	2
+#define PMAC1_DST_PRT_END	2
+
+/* Default GSWIP PCE Path Q-Map */
+static struct _gsw_pce_path gsw_pce_path[] = {
+	/*EG_LPID	EXT	TC_FR	TC_TO   QID	RDR_LPID */
+	{ LOG_2,	X,	0,	0,	28,	PMAC_1},
+	{ LOG_2,	X,	1,	1,	29,	PMAC_1},
+	{ LOG_2,	X,	2,	2,	30,	PMAC_1},
+	{ LOG_2,	X,	3,	15,	31,	PMAC_1},
+	/* QID 24 */
+	{ LOG_3,	X,	0,	0,	24,	PMAC_0},
+	{ LOG_4,	X,	0,	0,	24,	PMAC_0},
+	{ LOG_5,	X,	0,	0,	24,	PMAC_0},
+	{ LOG_6,	X,	0,	0,	24,	PMAC_0},
+	{ LOG_7,	X,	0,	0,	24,	PMAC_0},
+	{ LOG_8,	X,	0,	0,	24,	PMAC_0},
+	{ LOG_9,	X,	0,	0,	24,	PMAC_0},
+	{ LOG_10,	X,	0,	0,	24,	PMAC_0},
+	{ LOG_11,	X,	0,	0,	24,	PMAC_0},
+	{ LOG_0,	X,	0,	0,	24,	PMAC_0},
+	/* QID 25 */
+	{ LOG_3,	X,	1,	1,	25,	PMAC_0},
+	{ LOG_4,	X,	1,	1,	25,	PMAC_0},
+	{ LOG_5,	X,	1,	1,	25,	PMAC_0},
+	{ LOG_6,	X,	1,	1,	25,	PMAC_0},
+	{ LOG_7,	X,	1,	1,	25,	PMAC_0},
+	{ LOG_8,	X,	1,	1,	25,	PMAC_0},
+	{ LOG_9,	X,	1,	1,	25,	PMAC_0},
+	{ LOG_10,	X,	1,	1,	25,	PMAC_0},
+	{ LOG_11,	X,	1,	1,	25,	PMAC_0},
+	{ LOG_0,	X,	1,	1,	25,	PMAC_0},
+	/* QID 26 */
+	{ LOG_3,	X,	2,	2,	26,	PMAC_0},
+	{ LOG_4,	X,	2,	2,	26,	PMAC_0},
+	{ LOG_5,	X,	2,	2,	26,	PMAC_0},
+	{ LOG_6,	X,	2,	2,	26,	PMAC_0},
+	{ LOG_7,	X,	2,	2,	26,	PMAC_0},
+	{ LOG_8,	X,	2,	2,	26,	PMAC_0},
+	{ LOG_9,	X,	2,	2,	26,	PMAC_0},
+	{ LOG_10,	X,	2,	2,	26,	PMAC_0},
+	{ LOG_11,	X,	2,	2,	26,	PMAC_0},
+	{ LOG_0,	X,	2,	2,	26,	PMAC_0},
+	/* QID 27 */
+	{ LOG_3,	X,	3,	15,	27,	PMAC_0},
+	{ LOG_4,	X,	3,	15,	27,	PMAC_0},
+	{ LOG_5,	X,	3,	15,	27,	PMAC_0},
+	{ LOG_6,	X,	3,	15,	27,	PMAC_0},
+	{ LOG_7,	X,	3,	15,	27,	PMAC_0},
+	{ LOG_8,	X,	3,	15,	27,	PMAC_0},
+	{ LOG_9,	X,	3,	15,	27,	PMAC_0},
+	{ LOG_10,	X,	3,	15,	27,	PMAC_0},
+	{ LOG_11,	X,	3,	15,	27,	PMAC_0},
+	{ LOG_0,	X,	3,	15,	27,	PMAC_0},
+};
+
+/* Do the GSWIP PCE Q-MAP configuration */
+int gsw_set_def_pce_qmap(struct core_ops *ops)
+{
+	int i = 0, j = 0;
+	GSW_QoS_queuePort_t q_map;
+	int num_of_elem =
+		(sizeof(gsw_pce_path) / sizeof(struct _gsw_pce_path));
+
+	for (j = 0; j < num_of_elem; j++) {
+		for (i = gsw_pce_path[j].tc_from;
+		     i <= gsw_pce_path[j].tc_to; i++) {
+			memset(&q_map, 0, sizeof(GSW_QoS_queuePort_t));
+			q_map.nPortId = gsw_pce_path[j].eg_lpid;
+
+			if (gsw_pce_path[j].ext != X)
+				q_map.bExtrationEnable = gsw_pce_path[j].ext;
+
+			q_map.nTrafficClassId = i;
+			q_map.nQueueId = gsw_pce_path[j].qid;
+			q_map.nRedirectPortId = gsw_pce_path[j].redir_lpid;
+
+			ops->gsw_qos_ops.QoS_QueuePortSet(ops, &q_map);
+		}
+	}
+
+	return 0;
+}
+
+int gsw_get_def_pce_qmap(struct core_ops *ops)
+{
+	int i = 0, j = 0;
+	GSW_QoS_queuePort_t q_map;
+	int num_of_elem =
+		(sizeof(gsw_pce_path) / sizeof(struct _gsw_pce_path));
+
+	if (!ops) {
+		pr_err("%s: Open SWAPI device FAILED!\n", __func__);
+		return -EIO;
+	}
+
+	printk("\nGSWIP Default PCE-Q-MAP\n");
+	printk("%15s %15s %15s %15s %15s %15s\n",
+	       "EgLpid", "Ext", "Traf_Cls", "Q_Map_Mode", "Qid", "Redir_Lpid");
+
+	for (j = 0; j < num_of_elem; j++) {
+		for (i = gsw_pce_path[j].tc_from;
+		     i <= gsw_pce_path[j].tc_to; i++) {
+			memset(&q_map, 0, sizeof(GSW_QoS_queuePort_t));
+			q_map.nTrafficClassId = i;
+			q_map.nPortId = gsw_pce_path[j].eg_lpid;
+			ops->gsw_qos_ops.QoS_QueuePortGet(ops, &q_map);
+			printk("%15d %15d %15d %15d %15d %15d ",
+			       q_map.nPortId, q_map.bExtrationEnable,
+			       q_map.nTrafficClassId, q_map.eQMapMode,
+			       q_map.nQueueId, q_map.nRedirectPortId);
+			printk("\n");
+
+		}
+	}
+
+	return 0;
+}
+
+/* Default GSWIP PCE-Bypass Path Q-Map */
+static struct _gsw_bypass_path gsw_bypass_path[] = {
+	/*EG_MPID	EXT	SUBIF	QID	RDR_LPID */
+	{ MAC_2,	0,	X,	16,	MAC_2},
+	{ MAC_2,	1,	X,	27,	PMAC_0},
+	{ MAC_3,	0,	0,	0,	MAC_3},
+	{ MAC_4,	0,	8,	8,	MAC_4},
+	{ MAC_3,	1,	X,	27,	PMAC_0},
+	{ MAC_4,	1,	X,	27,	PMAC_0},
+};
+
+/* Do the GSWIP Bypass Q-MAP configuration */
+int gsw_set_def_bypass_qmap(struct core_ops *ops,
+			    GSW_QoS_qMapMode_t q_map_mode)
+{
+	int j = 0;
+	GSW_QoS_queuePort_t q_map;
+	int num_of_elem =
+		(sizeof(gsw_bypass_path) / sizeof(struct _gsw_bypass_path));
+
+	for (j = 0; j < num_of_elem; j++) {
+		memset(&q_map, 0, sizeof(GSW_QoS_queuePort_t));
+		q_map.nPortId = gsw_bypass_path[j].eg_pid;
+
+		if (gsw_bypass_path[j].ext != X)
+			q_map.bExtrationEnable = gsw_bypass_path[j].ext;
+
+		q_map.bRedirectionBypass = 1;
+
+		q_map.eQMapMode = q_map_mode;
+		q_map.nQueueId = gsw_bypass_path[j].qid;
+		q_map.nRedirectPortId = gsw_bypass_path[j].redir_pid;
+
+		ops->gsw_qos_ops.QoS_QueuePortSet(ops, &q_map);
+	}
+
+	return 0;
+}
+
+int gsw_get_def_bypass_qmap(struct core_ops *ops)
+{
+	int j = 0;
+	GSW_QoS_queuePort_t q_map;
+	int num_of_elem =
+		(sizeof(gsw_bypass_path) / sizeof(struct _gsw_bypass_path));
+
+	if (!ops) {
+		pr_err("%s: Open SWAPI device FAILED!\n", __func__);
+		return -EIO;
+	}
+
+	printk("\nGSWIP Default PCE Bypass Q-MAP\n");
+	printk("%15s %15s %15s %15s %15s %15s\n",
+	       "EgMpid", "Ext", "Traf_Cls", "Q_Map_Mode", "Qid", "Redir_Lpid");
+
+	for (j = 0; j < num_of_elem; j++) {
+		memset(&q_map, 0, sizeof(GSW_QoS_queuePort_t));
+		q_map.nPortId = gsw_bypass_path[j].eg_pid;
+		q_map.bRedirectionBypass = 1;
+		q_map.bExtrationEnable = gsw_bypass_path[j].ext;
+		ops->gsw_qos_ops.QoS_QueuePortGet(ops, &q_map);
+		printk("%15d %15d %15d %15d %15d %15d ",
+		       q_map.nPortId, q_map.bExtrationEnable,
+		       q_map.nTrafficClassId, q_map.eQMapMode,
+		       q_map.nQueueId, q_map.nRedirectPortId);
+		printk("\n");
+	}
+
+	return 0;
+}
+
+/* Default Qos WRED Config in switch */
+int gsw_qos_def_config(struct core_ops *ops)
+{
+	GSW_QoS_WRED_PortCfg_t sVar;
+	GSW_QoS_WRED_QueueCfg_t qcfg;
+	int j = 0;
+
+	for (j = 0; j < 5; j++) {
+		memset(&sVar, 0x00, sizeof(sVar));
+
+		sVar.nPortId = j;
+		sVar.nGreen_Min = 240;
+		sVar.nGreen_Max = 256;
+
+		ops->gsw_qos_ops.QoS_WredPortCfgSet(ops, &sVar);
+	}
+
+	for (j = 0; j < 31; j++) {
+		memset(&qcfg, 0x00, sizeof(qcfg));
+
+		qcfg.nQueueId = j;
+		qcfg.nGreen_Min = 240;
+		qcfg.nGreen_Max = 256;
+
+		ops->gsw_qos_ops.QoS_WredQueueCfgSet(ops, &qcfg);
+	}
+
+	return 0;
+}
+
+/* Pmac Ingress table has 17 entries,
+ * 17 channels
+ * Non - DPU
+ * Pmac 0
+ * Address: (i = 0 and i = 8), PCE Bypass traffic to P3 and P4
+ * Address: (i = 16), Traffic from CPU and Voice
+ * Address: (i = others), Traffic from HGU, WiFi, 5G
+ * Pmac 1
+ * Address: (i = 0), PCE bypass traffic  to MAC2
+ * DPU:
+ * Pmac 0
+ * Address: (i from 0 to 15), PCE bypass traffic to MAC3 and MAC4
+ * Address: (i = 16), Traffic from CPU
+ */
+static int pmac_ig_cfg(struct core_ops *ops, u8 pmacid, u8 dpu)
+{
+	int i = 0;
+	u8 addr_from = 0, addr_to = 0;
+	GSW_PMAC_Ig_Cfg_t ig_cfg;
+
+	/* Do the GSWIP PMAC IG configuration */
+
+	if (pmacid == 0) {
+		addr_from = PMAC0_TX_DMACHID_START;
+		addr_to   = PMAC0_TX_DMACHID_END;
+	} else if (pmacid == 1) {
+		addr_from = PMAC1_TX_DMACHID_START;
+		addr_to   = PMAC1_TX_DMACHID_END;
+	}
+
+	for (i = addr_from; i <= addr_to; i++) {
+		memset((void *)&ig_cfg, 0x00, sizeof(ig_cfg));
+
+		ig_cfg.nPmacId		= pmacid;
+		ig_cfg.nTxDmaChanId	= i;
+		/* Discard Packet with Error Flag Set */
+		ig_cfg.bErrPktsDisc	= 1;
+
+		/* CLASS_EN from default PMAC header,
+		 * TC (Class) enable is fixed to 0.
+		 */
+		ig_cfg.bClassEna	= 1;
+
+		if (dpu == NON_DPU) {
+			if (i == 0 || i == 8) {
+				/* CLASS from default PMAC header,
+				 * TC (class) is fixed to 0.
+				 */
+				ig_cfg.bClassDefault	= 1;
+				/* Source SUBID is from PMAC header. */
+				ig_cfg.eSubId		= 1;
+				/* SPPID from default PMAC header */
+				ig_cfg.bSpIdDefault	= 1;
+			}
+
+			/* The packets has PMAC header for 0, 8 & 16 */
+			if ((i % 8) == 0)
+				ig_cfg.bPmacPresent  = 1;
+		} else if (dpu == DPU) {
+			/* The packets has PMAC header for all channels */
+			ig_cfg.bPmacPresent  	= 1;
+
+			if (i != 16) {
+				/* CLASS from default PMAC header,
+				 * TC (class) is fixed to 0.
+				 */
+				ig_cfg.bClassDefault	= 1;
+				/* Source SUBID is from PMAC header. */
+				ig_cfg.eSubId		= 1;
+				/* SPPID from default PMAC header */
+				ig_cfg.bSpIdDefault	= 1;
+			}
+		}
+
+		/* Set IGP = 1 for PMAC 1 */
+		if (pmacid == 1)
+			ig_cfg.defPmacHdr[2] = 0x10;
+
+		ops->gsw_pmac_ops.Pmac_Ig_CfgSet(ops, &ig_cfg);
+	}
+
+	pr_info("PMAC_IG_CFG_SET for PMAC %d %s\n", pmacid,
+		(dpu == NON_DPU) ? "Non-DPU" : "DPU");
+	return 0;
+}
+
+int pmac_get_ig_cfg(struct core_ops *ops, u8 pmacid)
+{
+	int i = 0;
+	GSW_PMAC_Ig_Cfg_t ig_cfg;
+
+	/* Do the GSWIP PMAC IG configuration */
+
+	if (!ops) {
+		pr_err("%s: Open SWAPI device FAILED!\n", __func__);
+		return -EIO;
+	}
+
+	printk("\nGSWIP PMAC IG CFG\n");
+	printk("%10s %10s %10s %10s %10s %10s %10s %10s %10s\n",
+	       "PmacId", "TxDmaChId", "ErrPktDisc", "ClassEn",
+	       "ClassDef", "eSubId", "bSpIdDef", "bPmacPr", "DefPmacHdr");
+
+	for (i = PMAC0_TX_DMACHID_START; i <= PMAC0_TX_DMACHID_END; i++) {
+		memset((void *)&ig_cfg, 0x00, sizeof(ig_cfg));
+
+		ig_cfg.nPmacId		= pmacid;
+		ig_cfg.nTxDmaChanId	= i;
+
+		ops->gsw_pmac_ops.Pmac_Ig_CfgGet(ops, &ig_cfg);
+		printk("%10d %10d %10d %10d %10d %10d %10d %10d %10x:%x:%x:%x:%x:%x:%x:%x",
+		       ig_cfg.nPmacId, ig_cfg.nTxDmaChanId,
+		       ig_cfg.bErrPktsDisc, ig_cfg.bClassEna,
+		       ig_cfg.bClassDefault, ig_cfg.eSubId,
+		       ig_cfg.bSpIdDefault, ig_cfg.bPmacPresent,
+		       ig_cfg.defPmacHdr[0], ig_cfg.defPmacHdr[1],
+		       ig_cfg.defPmacHdr[2], ig_cfg.defPmacHdr[3],
+		       ig_cfg.defPmacHdr[4], ig_cfg.defPmacHdr[5],
+		       ig_cfg.defPmacHdr[6], ig_cfg.defPmacHdr[7]);
+		printk("\n");
+	}
+
+	return 0;
+}
+
+/* Pmac Egress table has 1024 entries,
+ * i * j * k * 16 channels
+ */
+static int pmac_eg_cfg(struct core_ops *ops, u8 pmacid, u8 dpu)
+{
+	GSW_PMAC_Eg_Cfg_t eg_cfg;
+	int i = 0, j = 0, k = 0, m = 0;
+	u8 dst_start = 0, dst_end = 0;
+
+	/* Do the GSWIP PMAC configuration */
+
+	if (pmacid == 0) {
+		dst_start = PMAC0_DST_PRT_START;
+		dst_end   = PMAC0_DST_PRT_END;
+	} else if (pmacid == 1) {
+		dst_start = PMAC1_DST_PRT_START;
+		dst_end   = PMAC1_DST_PRT_END;
+	}
+
+	/* m = Dest port
+	 * k = flow_id
+	 * i = traffic class
+	 * j = mpe flag
+	 */
+	for (m = dst_start; m <= dst_end; m++) {
+		for (k = 0; k <= 3; k++) {
+			for (i = 0; i <= 3; i++) {
+				for (j = 0; j <= 3; j++) {
+					memset((void *)&eg_cfg, 0x00,
+					       sizeof(eg_cfg));
+
+					/* Select Pmac ID */
+					eg_cfg.nPmacId		= pmacid;
+					/* Egress ch for Pmac0/1 is always 0 */
+					eg_cfg.nRxDmaChanId = 0;
+					/* Packet traffic class */
+					eg_cfg.nBslTrafficClass = i;
+
+					/* Traffic to CPU and voice */
+					if (m == 0 || m == 11) {
+						/* Every Pkt has Pmac header */
+						eg_cfg.bPmacEna = 1;
+						/* Pkt cannot be segmented. */
+						eg_cfg.bBslSegmentDisable = 1;
+					}
+					/* Traffic to HGU, WiFi and LTE */
+					else if (m >= 5 && m <= 10) {
+						/* Every pkt has NO PMAC hdr. */
+						eg_cfg.bPmacEna = 0;
+						/* Pkt cannot be segmented. */
+						eg_cfg.bBslSegmentDisable = 1;
+					}
+					/* PCE-Bypass Traf to MAC3 & MAC4 DPU */
+					else if ((dpu == DPU) &&
+						 (m >= 3 && m <= 4)) {
+						/* Every Pkt has Pmac header */
+						eg_cfg.bPmacEna = 1;
+						/* Packet can be segmented. */
+						eg_cfg.bBslSegmentDisable = 0;
+						/* Pkt to GSWIP PCE bypass. */
+						eg_cfg.bRedirEnable = 1;
+					}
+					/* Pmac1, PCE bypass traffic to MAC2*/
+					/* Pmac0, PCE-Bypass Traf to MAC3-MAC4*/
+					else {
+						/* Every Pkt has Pmac header */
+						eg_cfg.bPmacEna = 1;
+						/* Pkt can be segmented. */
+						eg_cfg.bBslSegmentDisable = 0;
+						/* Pkt to GSWIP PCE-Bypass. */
+						eg_cfg.bRedirEnable = 1;
+					}
+
+					eg_cfg.bProcFlagsSelect = 1;
+					eg_cfg.nDestPortId	= m;
+					eg_cfg.nTrafficClass	= i;
+					eg_cfg.bMpe2Flag	= ((j & 3) >> 1);
+					eg_cfg.bMpe1Flag	= (j & 1);
+					eg_cfg.nFlowIDMsb	= k;
+
+					/* All other fields set to 0. */
+					ops->gsw_pmac_ops.Pmac_Eg_CfgSet(ops,
+									 &eg_cfg);
+				}
+			}
+		}
+	}
+
+	pr_info("PMAC_EG_CFG_SET for PMAC %d %s\n", pmacid,
+		(dpu == NON_DPU) ? "Non-DPU" : "DPU");
+
+	return 0;
+}
+
+int pmac_get_eg_cfg(struct core_ops *ops, u8 pmacid, u8 dst_port)
+{
+	int i = 0, k = 0, j = 0;
+	GSW_PMAC_Eg_Cfg_t eg_cfg;
+
+	/* Do the GSWIP PMAC IG configuration */
+
+	if (!ops) {
+		pr_err("%s: Open SWAPI device FAILED!\n", __func__);
+		return -EIO;
+	}
+
+	printk("\nGSWIP PMAC EG CFG\n");
+
+	printk("\n\nDestination portId = %d\n\n", dst_port);
+	printk("%10s %10s %10s %10s %10s %10s %10s %10s %10s %10s %10s\n",
+	       "PmacId", "RxDmaChId", "BslTrafCls", "BslSegDis",
+	       "PmacEna", "RedirEna", "DestPortId", "TrafCls", "Mpe1",
+	       "Mpe2", "FlowId");
+
+	for (k = 0; k <= 3; k++) {
+		for (i = 0; i <= 3; i++) {
+			for (j = 0; j <= 3; j++) {
+
+				memset((void *)&eg_cfg, 0x00,
+				       sizeof(eg_cfg));
+
+				eg_cfg.nPmacId		= pmacid;
+				eg_cfg.nDestPortId	= dst_port;
+
+				eg_cfg.bProcFlagsSelect = 1;
+				eg_cfg.nTrafficClass	= i;
+				eg_cfg.bMpe2Flag	= ((j & 3) >> 1);
+				eg_cfg.bMpe1Flag	= (j & 1);
+				eg_cfg.nFlowIDMsb	= k;
+
+				ops->gsw_pmac_ops.Pmac_Eg_CfgGet(ops,
+								 &eg_cfg);
+				printk("%10d %10d %10d %10d %10d %10d %10d %10d %10d %10d %10d",
+				       eg_cfg.nPmacId,
+				       eg_cfg.nRxDmaChanId,
+				       eg_cfg.nBslTrafficClass,
+				       eg_cfg.bBslSegmentDisable,
+				       eg_cfg.bPmacEna,
+				       eg_cfg.bRedirEnable,
+				       eg_cfg.nDestPortId,
+				       eg_cfg.nTrafficClass,
+				       eg_cfg.bMpe1Flag,
+				       eg_cfg.bMpe2Flag,
+				       eg_cfg.nFlowIDMsb);
+				printk("\n");
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int pmac_glbl_cfg(struct core_ops *ops, u8 pmacid)
+{
+	GSW_PMAC_Glbl_Cfg_t glbl_cfg;
+
+	/* Do the GSWIP PMAC configuration */
+
+	memset((void *)&glbl_cfg, 0x00, sizeof(glbl_cfg));
+
+	glbl_cfg.nPmacId = pmacid;
+	glbl_cfg.bJumboEna = 1;
+	glbl_cfg.nMaxJumboLen = 10000;
+	glbl_cfg.bTxFCSDis = 1;
+	glbl_cfg.bRxFCSDis = 1;
+	glbl_cfg.eShortFrmChkType = GSW_PMAC_SHORT_LEN_ENA_UNTAG;
+	glbl_cfg.bLongFrmChkDis = 1;
+	glbl_cfg.bProcFlagsEgCfgEna = 1;
+	glbl_cfg.eProcFlagsEgCfg = GSW_PMAC_PROC_FLAGS_FLAG;
+
+	ops->gsw_pmac_ops.Pmac_Gbl_CfgSet(ops, &glbl_cfg);
+
+	pr_info("PMAC_GLBL_CFG_SET for PMAC %d\n", pmacid);
+
+	return 0;
+}
+
+/* Pmac Backpressure table has 17 entries,
+ * 17 channels
+ * TxQMask - Which Q backpressure is enabled 32 bit denotes 32 Q
+ * RxPortMask - Which ingress port flow control is enabled
+ * (Configurable upto 16 ports)
+ */
+GSW_PMAC_BM_Cfg_t bm_cfg_nondpu[] = {
+	/*	PmacId	TxDmaChId TxQMask	RxPortMask */
+	{0, 	0,	  1,		0},/* PCE Bypass traf to MAC3+MAC4 */
+	{0, 	1,	  0,		0},
+	{0, 	2,	  0,		0},
+	{0, 	3,	  0,		0},
+	{0, 	4,	  0,		0},
+	{0, 	5,	  0,		0x20},/* Traffic from HGU and LTE */
+	{0, 	6,	  0,		0x40},/* Traffic from HGU and LTE */
+	{0, 	7,	  0,		0x180},/* Traffic from Wifi */
+	{0, 	8,	  0x100,	0},/* PCE Bypass traf to MAC3+MAC4 */
+	{0, 	9,	  0,		0x600},/* Traffic from Wifi */
+	{0, 	10,	  0,		0},
+	{0, 	11,	  0,		0},
+	{0, 	12,	  0,		0},
+	{0, 	13,	  0,		0},
+	{0, 	14,	  0,		0},
+	{0, 	15,	  0,		0},
+	{0, 	16,	  0,		0x801},/* Traffic from CPU or voice */
+	{1, 	0,	  0x10000,	0},/* PCE bypass traffic to MAC2 */
+};
+
+GSW_PMAC_BM_Cfg_t bm_cfg_dpu[] = {
+	/*	PmacId	TxDmaChId TxQMask	RxPortMask */
+	{0, 	0,	  1,		0},
+	{0, 	1,	  2,		0},
+	{0, 	2,	  4,		0},
+	{0, 	3,	  8,		0},
+	{0, 	4,	  0x10,		0},
+	{0, 	5,	  0x20,		0},
+	{0, 	6,	  0x40,		0},
+	{0, 	7,	  0x80,		0},
+	{0, 	8,	  0x100,	0},
+	{0, 	9,	  0x200,	0},
+	{0, 	10,	  0x400,	0},
+	{0, 	11,	  0x800,	0},
+	{0, 	12,	  0x1000,	0},
+	{0, 	13,	  0x2000,	0},
+	{0, 	14,	  0x4000,	0},
+	{0, 	15,	  0x8000,	0},
+	/* Port 0 flow control is enabled.DMA channel for traffic from CPU.*/
+	{0, 	16,	  0x10000,	0x0001},
+	{1, 	0,	  0x10000,	0},
+};
+
+static int pmac_bp_cfg(struct core_ops *ops, u8 dpu)
+{
+	GSW_PMAC_BM_Cfg_t bm_cfg;
+	int m = 0;
+	int num_of_elem;
+
+	/* Do the GSWIP PMAC BM table configuration */
+
+	if (dpu == NON_DPU) {
+		num_of_elem =
+			(sizeof(bm_cfg_nondpu) / sizeof(GSW_PMAC_BM_Cfg_t));
+	} else if (dpu == DPU) {
+		num_of_elem =
+			(sizeof(bm_cfg_dpu) / sizeof(GSW_PMAC_BM_Cfg_t));
+	}
+
+	for (m = 0; m < num_of_elem; m++) {
+		memset((void *)&bm_cfg, 0x00, sizeof(bm_cfg));
+
+		if (dpu == NON_DPU) {
+			bm_cfg.nPmacId 		= bm_cfg_nondpu[m].nPmacId;
+			bm_cfg.nTxDmaChanId 	= bm_cfg_nondpu[m].nTxDmaChanId;
+			bm_cfg.txQMask 		= bm_cfg_nondpu[m].txQMask;
+			bm_cfg.rxPortMask	= bm_cfg_nondpu[m].rxPortMask;
+		} else if (dpu == DPU) {
+			bm_cfg.nPmacId 		= bm_cfg_dpu[m].nPmacId;
+			bm_cfg.nTxDmaChanId 	= bm_cfg_dpu[m].nTxDmaChanId;
+			bm_cfg.txQMask 		= bm_cfg_dpu[m].txQMask;
+			bm_cfg.rxPortMask	= bm_cfg_dpu[m].rxPortMask;
+		}
+
+		ops->gsw_pmac_ops.Pmac_Bm_CfgSet(ops, &bm_cfg);
+	}
+
+	return 0;
+}
+
+int pmac_get_bp_cfg(struct core_ops *ops, u8 pmacid)
+{
+	GSW_PMAC_BM_Cfg_t bm_cfg;
+	int m = 0;
+
+	if (!ops) {
+		pr_err("%s: Open SWAPI device FAILED!\n", __func__);
+		return -EIO;
+	}
+
+	/* Do the GSWIP PMAC BM table configuration */
+	printk("\nGSWIP PMAC BP CFG\n");
+	printk("%10s %10s %10s %10s\n",
+	       "PmacId", "TxDmaChId", "TxQMask", "RxPortMask");
+
+	for (m = PMAC0_TX_DMACHID_START; m <= PMAC0_TX_DMACHID_END; m++) {
+		memset((void *)&bm_cfg, 0x00, sizeof(bm_cfg));
+		bm_cfg.nPmacId		= pmacid;
+		bm_cfg.nTxDmaChanId	= m;
+
+		ops->gsw_pmac_ops.Pmac_Bm_CfgGet(ops, &bm_cfg);
+
+		printk("%10d %10d %10x %10x",
+		       bm_cfg.nPmacId, bm_cfg.nTxDmaChanId,
+		       bm_cfg.txQMask, bm_cfg.rxPortMask);
+		printk("\n");
+	}
+
+	return 0;
+}
+
+int gsw_pmac_init_nondpu(void)
+{
+	struct core_ops *ops = gsw_get_swcore_ops(0);
+
+	if (!ops) {
+		pr_err("%s: Open SWAPI device FAILED!\n", __func__);
+		return -EIO;
+	}
+
+	pmac_glbl_cfg(ops, 0);
+	pmac_glbl_cfg(ops, 1);
+	pmac_ig_cfg(ops, 0, NON_DPU);
+	pmac_ig_cfg(ops, 1, NON_DPU);
+	pmac_eg_cfg(ops, 0, NON_DPU);
+	pmac_eg_cfg(ops, 1, NON_DPU);
+	pmac_bp_cfg(ops, NON_DPU);
+
+	pr_info("\n\t GSW PMAC Init Done!!!\n");
+	return 0;
+}
+
+int gsw_pmac_init_dpu(void)
+{
+	struct core_ops *ops = gsw_get_swcore_ops(0);
+
+	if (!ops) {
+		pr_err("%s: Open SWAPI device FAILED!\n", __func__);
+		return -EIO;
+	}
+
+	pmac_glbl_cfg(ops, 0);
+	pmac_glbl_cfg(ops, 1);
+	pmac_ig_cfg(ops, 0, DPU);
+	pmac_ig_cfg(ops, 1, NON_DPU);
+	pmac_eg_cfg(ops, 0, DPU);
+	pmac_eg_cfg(ops, 1, NON_DPU);
+	pmac_bp_cfg(ops, DPU);
+
+	pr_info("\n\t GSW PMAC Init Done!!!\n");
+	return 0;
+}
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.h b/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.h
new file mode 100644
index 000000000000..84e91922743f
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_defconf.h
@@ -0,0 +1,66 @@
+#ifndef _GSW_DEFCONF_
+#define _GSW_DEFCONF_
+
+#define NOT_USED -1
+#define X NOT_USED
+
+enum _mac_pid {
+	PMAC_0 = 0,
+	PMAC_1,
+	MAC_2,
+	MAC_3,
+	MAC_4
+};
+
+enum _logical_pid {
+	LOG_0 = 0,
+	LOG_1,
+	LOG_2,
+	LOG_3,
+	LOG_4,
+	LOG_5,
+	LOG_6,
+	LOG_7,
+	LOG_8,
+	LOG_9,
+	LOG_10,
+	LOG_11
+};
+
+enum _dpu {
+	DPU = 0,
+	NON_DPU = 1,
+};
+
+struct _gsw_pce_path {
+	u32 eg_lpid;	/* Egress Logical PID after Bridge */
+	int ext;	/* Extraction */
+	u32 tc_from;	/* Traffic Class From */
+	u32 tc_to;	/* Traffic Class to */
+	u32 qid;	/* Egress QID From */
+	u32 redir_lpid;	/* Redirect Logical PID */
+};
+
+struct _gsw_bypass_path {
+	u32 eg_pid;	/* Egress MAC PID */
+	int ext;	/* Extraction */
+	u32 dst_subifid;/* Dest subifid */
+	u32 qid;	/* QID */
+	u32 redir_pid;	/* Redirect Logical PID */
+};
+
+int gsw_set_def_pce_qmap(struct core_ops *ops);
+int gsw_get_def_pce_qmap(struct core_ops *ops);
+int gsw_set_def_bypass_qmap(struct core_ops *ops, GSW_QoS_qMapMode_t q_map_mode);
+int gsw_get_def_bypass_qmap(struct core_ops *ops);
+int gsw_qos_def_config(struct core_ops *ops);
+
+int gsw_pmac_init_nondpu(void);
+int gsw_pmac_init_dpu(void);
+int pmac_get_ig_cfg(struct core_ops *ops, u8 pmacid);
+int pmac_get_bp_cfg(struct core_ops *ops, u8 pmacid);
+int pmac_get_eg_cfg(struct core_ops *ops, u8 pmacid, u8 dst_port);
+
+
+#endif
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
new file mode 100644
index 000000000000..e66789dc77ec
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
@@ -0,0 +1,26730 @@
+/******************************************************************************
+				Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+				Copyright (c) 2012, 2014, 2015
+					Lantiq Deutschland GmbH
+	For licensing information, see the file 'LICENSE' in the root folder of
+	this software module.
+******************************************************************************/
+
+#ifdef __KERNEL__
+//#include <linux/sched.h>
+#include <linux/jiffies.h>
+#include <linux/timer.h>
+
+#ifndef CONFIG_X86_INTEL_CE2700
+#include <lantiq_soc.h>
+#endif
+#endif
+
+#include <gsw_init.h>
+#include <gsw_swmcast.h>
+#include <gsw_defconf.h>
+
+#if defined(CONFIG_MAC) && CONFIG_MAC
+#include <gswss_api.h>
+#endif
+#if defined(WIN_PC_MODE) && WIN_PC_MODE
+#include <eip160_common.h>
+#endif
+
+//#define CONFIG_USE_EMULATOR 1
+/* Global Variables */
+ethsw_api_dev_t *ecoredev[LTQ_FLOW_DEV_MAX];
+u8 VERSION_NAME[] = GSW_API_MODULE_NAME " for GSWITCH Platform";
+u8 VERSION_NUMBER[] = GSW_API_DRV_VERSION;
+u8 MICRO_CODE_VERSION_NAME[] = " GSWIP macro revision ID";
+u8 MICRO_CODE_VERSION_NUMBER[] = "0x"MICRO_CODE_VERSION;
+/* Port redirect flag */
+static u8 prdflag;
+static void get_gsw_hw_cap(void *cdev);
+static GSW_return_t gsw_init_fn_ptrs(struct core_ops *ops);
+
+static const u32 gsw_pce_tbl_reg_key[] = {
+	PCE_TBL_KEY_0_KEY0_OFFSET, PCE_TBL_KEY_1_KEY1_OFFSET,
+	PCE_TBL_KEY_2_KEY2_OFFSET, PCE_TBL_KEY_3_KEY3_OFFSET,
+	PCE_TBL_KEY_4_KEY4_OFFSET, PCE_TBL_KEY_5_KEY5_OFFSET,
+	PCE_TBL_KEY_6_KEY6_OFFSET, PCE_TBL_KEY_7_KEY7_OFFSET,
+	PCE_TBL_KEY_8_KEY8_OFFSET, PCE_TBL_KEY_9_KEY9_OFFSET,
+	PCE_TBL_KEY_10_KEY10_OFFSET, PCE_TBL_KEY_11_KEY11_OFFSET,
+	PCE_TBL_KEY_12_KEY12_OFFSET, PCE_TBL_KEY_13_KEY13_OFFSET,
+	PCE_TBL_KEY_14_KEY14_OFFSET, PCE_TBL_KEY_15_KEY15_OFFSET,
+	PCE_TBL_KEY_16_KEY16_OFFSET, PCE_TBL_KEY_17_KEY17_OFFSET,
+	PCE_TBL_KEY_18_KEY18_OFFSET, PCE_TBL_KEY_19_KEY19_OFFSET,
+	PCE_TBL_KEY_20_KEY20_OFFSET, PCE_TBL_KEY_21_KEY21_OFFSET
+};
+static const u32 gsw_pce_tbl_reg_mask[] = {
+	PCE_TBL_MASK_0_MASK0_OFFSET, PCE_TBL_MASK_1_MASK1_OFFSET,
+	PCE_TBL_MASK_2_MASK2_OFFSET, PCE_TBL_MASK_3_MASK3_OFFSET
+};
+static const u32 gsw_pce_tbl_reg_value[] = {
+	PCE_TBL_VAL_0_VAL0_OFFSET, PCE_TBL_VAL_1_VAL1_OFFSET,
+	PCE_TBL_VAL_2_VAL2_OFFSET, PCE_TBL_VAL_3_VAL3_OFFSET,
+	PCE_TBL_VAL_4_VAL4_OFFSET, PCE_TBL_VAL_5_VAL5_OFFSET,
+	PCE_TBL_VAL_6_VAL6_OFFSET, PCE_TBL_VAL_7_VAL7_OFFSET,
+	PCE_TBL_VAL_8_VAL8_OFFSET, PCE_TBL_VAL_9_VAL9_OFFSET,
+	PCE_TBL_VAL_10_VAL10_OFFSET, PCE_TBL_VAL_11_VAL11_OFFSET,
+	PCE_TBL_VAL_12_VAL12_OFFSET, PCE_TBL_VAL_13_VAL13_OFFSET,
+	PCE_TBL_VAL_14_VAL14_OFFSET, PCE_TBL_VAL_15_VAL15_OFFSET,
+	PCE_TBL_VAL_16_VAL16_OFFSET, PCE_TBL_VAL_17_VAL17_OFFSET,
+	PCE_TBL_VAL_18_VAL18_OFFSET, PCE_TBL_VAL_19_VAL19_OFFSET,
+	PCE_TBL_VAL_20_VAL20_OFFSET, PCE_TBL_VAL_21_VAL21_OFFSET,
+	PCE_TBL_VAL_22_VAL22_OFFSET, PCE_TBL_VAL_23_VAL23_OFFSET,
+	PCE_TBL_VAL_24_VAL24_OFFSET, PCE_TBL_VAL_25_VAL25_OFFSET
+};
+static const gsw_pce_tbl_info_t gsw_pce_tbl_info_22[] = {
+	{0, 0, 4}, {1, 1, 1}, {0, 0, 3}, {1, 0, 0}, {1, 1, 0}, {1, 1, 0}, {4, 1, 0}, {4, 1, 0},
+	{1, 1, 0}, {0, 0, 1}, {0, 0, 1}, {4, 0, 2}, {3, 1, 0}, {2, 0, 1}, {2, 0, 5}, {9, 0, 7},
+	{0, 0, 1}, {0, 0, 1}, {1, 1, 1}, {1, 1, 1}, {4, 1, 0}, {4, 1, 0}, {3, 1, 0}, {3, 1, 0},
+	{0, 0, 0}, {0, 0, 4}, {0, 0, 1}, {0, 0, 1}, {0, 0, 2}
+};
+static const gsw_pce_tbl_info_t gsw_pce_tbl_info_30[] = {
+	{0, 0, 4}, {1, 1, 0}, {0, 0, 3}, {1, 0, 0}, {1, 1, 0}, {1, 1, 0}, {4, 4, 0}, {4, 4, 0},
+	{1, 1, 0}, {0, 0, 1}, {0, 0, 1}, {4, 0, 2}, {0, 0, 0}, {3, 0, 2}, {2, 0, 5}, {16, 0, 10},
+	{0, 0, 0}, {0, 0, 1}, {1, 1, 1}, {1, 1, 1}, {0, 0, 0}, {0, 0, 0}, {3, 1, 0}, {3, 1, 0},
+	{1, 1, 0}, {0, 0, 0}, {0, 0, 1}, {0, 0, 1}, {0, 0, 2}, {1, 1, 0}, {0, 0, 2}
+};
+static const gsw_pce_tbl_info_t gsw_pce_tbl_info_31[] = {
+	{0, 0, 4}, {0, 0, 0}, {1, 0, 1}, {1, 0, 0}, {1, 1, 0}, {1, 1, 0}, {4, 4, 0}, {4, 4, 0},
+	{1, 1, 0}, {0, 0, 1}, {0, 0, 1}, {4, 0, 10}, {0, 0, 2}, {19, 0, 10}, {2, 0, 5}, {22, 0, 18},
+	{0, 0, 0}, {0, 0, 1}, {0, 0, 9}, {0, 0, 7}, {0, 0, 18}, {0, 0, 14}, {3, 1, 0}, {3, 1, 0},
+	{1, 1, 0}, {0, 0, 10}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {1, 1, 0}, {4, 0, 6}, {0, 0, 1}
+};
+
+/* Local Macros & Definitions */
+static pstpstate_t pstpstate[] = {
+	{
+		GSW_STP_PORT_STATE_FORWARD, GSW_8021X_PORT_STATE_AUTHORIZED,
+		1, PORT_STATE_FORWARDING, 1
+	},
+	{
+		GSW_STP_PORT_STATE_FORWARD, GSW_8021X_PORT_STATE_UNAUTHORIZED,
+		1, PORT_STATE_LISTENING, 0
+	}, /* Govind - set 'lrnlim' to 0. Double check for legacy code. */
+	{
+		GSW_STP_PORT_STATE_FORWARD, GSW_8021X_PORT_STATE_RX_AUTHORIZED,
+		1, PS_RENABLE_TDISABLE, 1
+	},
+	{
+		GSW_STP_PORT_STATE_FORWARD, GSW_8021X_PORT_STATE_TX_AUTHORIZED,
+		1, PS_RDISABLE_TENABLE, 0
+	}, /* Govind - set 'lrnlim' to 0. Double check for legacy code. */
+	{
+		GSW_STP_PORT_STATE_DISABLE, GSW_8021X_PORT_STATE_AUTHORIZED,
+		0, PORT_STATE_LISTENING, 0
+	},
+	{
+		GSW_STP_PORT_STATE_DISABLE, GSW_8021X_PORT_STATE_UNAUTHORIZED,
+		0, PORT_STATE_LISTENING, 0
+	},
+	{
+		GSW_STP_PORT_STATE_DISABLE, GSW_8021X_PORT_STATE_RX_AUTHORIZED,
+		0, PORT_STATE_LISTENING, 0
+	},
+	{
+		GSW_STP_PORT_STATE_DISABLE, GSW_8021X_PORT_STATE_TX_AUTHORIZED,
+		0, PORT_STATE_LISTENING, 0
+	},
+	{
+		GSW_STP_PORT_STATE_LEARNING, GSW_8021X_PORT_STATE_AUTHORIZED,
+		1, PORT_STATE_LEARNING, 1
+	},
+	{
+		GSW_STP_PORT_STATE_LEARNING, GSW_8021X_PORT_STATE_UNAUTHORIZED,
+		1, PORT_STATE_LEARNING, 1
+	},
+	{
+		GSW_STP_PORT_STATE_LEARNING, GSW_8021X_PORT_STATE_RX_AUTHORIZED,
+		1, PORT_STATE_LEARNING, 1
+	},
+	{
+		GSW_STP_PORT_STATE_LEARNING, GSW_8021X_PORT_STATE_TX_AUTHORIZED,
+		1, PORT_STATE_LEARNING, 1
+	},
+	{
+		GSW_STP_PORT_STATE_BLOCKING, GSW_8021X_PORT_STATE_AUTHORIZED,
+		1, PORT_STATE_LISTENING, 0
+	},
+	{
+		GSW_STP_PORT_STATE_BLOCKING, GSW_8021X_PORT_STATE_UNAUTHORIZED,
+		1, PORT_STATE_LISTENING, 0
+	},
+	{
+		GSW_STP_PORT_STATE_BLOCKING, GSW_8021X_PORT_STATE_RX_AUTHORIZED,
+		1, PORT_STATE_LISTENING, 0
+	},
+	{
+		GSW_STP_PORT_STATE_BLOCKING, GSW_8021X_PORT_STATE_TX_AUTHORIZED,
+		1, PORT_STATE_LISTENING, 0
+	}
+};
+
+static gsw_capdesc_t capdes[] = {
+	{ GSW_CAP_TYPE_PORT, "Number of Ethernet ports"},
+	{ GSW_CAP_TYPE_VIRTUAL_PORT, "Number of virtual ports"},
+	{ GSW_CAP_TYPE_BUFFER_SIZE, "Pcket buffer size[in Bytes]:"},
+	{ GSW_CAP_TYPE_SEGMENT_SIZE, "Buffer Segment size:"},
+	{ GSW_CAP_TYPE_PRIORITY_QUEUE, "Number of queues:"},
+	{ GSW_CAP_TYPE_METER, "Number of traffic meters:"},
+	{ GSW_CAP_TYPE_RATE_SHAPER, "Number of rate shapers:"},
+	{ GSW_CAP_TYPE_VLAN_GROUP, "Number of VLAN groups:"},
+	{ GSW_CAP_TYPE_FID, "Number of FIDs:"},
+	{ GSW_CAP_TYPE_MAC_TABLE_SIZE, "Number of MAC entries:"},
+	{ GSW_CAP_TYPE_MULTICAST_TABLE_SIZE, "Number of multicast entries"},
+	{ GSW_CAP_TYPE_PPPOE_SESSION, "Number of PPPoE sessions:"},
+	{ GSW_CAP_TYPE_SVLAN_GROUP, "Number of STAG VLAN groups:"},
+	{ GSW_CAP_TYPE_PMAC, "Number of PMACs:"},
+	{ GSW_CAP_TYPE_PAYLOAD, "Number of entries in Payload Table size:"},
+	{ GSW_CAP_TYPE_IF_RMON, "Number of IF RMON Counters:"},
+	{ GSW_CAP_TYPE_EGRESS_VLAN, "Number of Egress VLAN Entries:"},
+	{ GSW_CAP_TYPE_RT_SMAC, "Number of Routing Source-MAC Entries:"},
+	{ GSW_CAP_TYPE_RT_DMAC, "Number of Routing Dest-MAC Entries:"},
+	{ GSW_CAP_TYPE_RT_PPPoE, "Number of Routing-PPPoE Entries:"},
+	{ GSW_CAP_TYPE_RT_NAT, "Number of Routing-NAT Entries:"},
+	{ GSW_CAP_TYPE_RT_MTU, "Number of MTU Entries:"},
+	{ GSW_CAP_TYPE_RT_TUNNEL, "Number of Tunnel Entries:"},
+	{ GSW_CAP_TYPE_RT_RTP, "Number of RTP Entries:"},
+	{ GSW_CAP_TYPE_LAST, "Last Capability Index"}
+};
+
+/*****************/
+/* Function Body */
+/*****************/
+#ifndef CONFIG_X86_INTEL_CE2700
+//static void 		*gswr_bm_addr = (void  *) (KSEG1 | 0x1a000114);;
+#endif
+#define GAP_MAX	50
+#define GAP_MAX1	1000
+#define MAX_READ 20
+#define REPEAT_L 10
+#define REPEAT_M 10
+#define NOT_ASSIGNED	   0xFF
+
+
+struct mac_ops *get_mac_ops(ethsw_api_dev_t *gswdev, int idx)
+{
+#ifdef __KERNEL__
+	u32 dev_id = (((struct platform_device *)(gswdev->pdev))->dev.parent->id);
+#else
+	u32 dev_id = 0;
+#endif
+	u32 max_mac = gsw_get_mac_subifcnt(dev_id);
+
+	if (idx < 2 || idx > max_mac + 1) {
+		printk("Invalid MAC Idx %d, Only MAC idx > 2 is Allowed\n", idx);
+		return NULL;
+	}
+
+	/* For mac Idx is from 0, 1, 2 */
+	idx -= 2;
+
+	return gsw_get_mac_ops(dev_id, idx);
+}
+
+struct adap_ops *get_adap_ops(ethsw_api_dev_t *gswdev)
+{
+#ifdef __KERNEL__
+	u32 dev_id = (((struct platform_device *)(gswdev->pdev))->dev.parent->id);
+#else
+	u32 dev_id = 0;
+#endif
+	return gsw_get_adap_ops(dev_id);
+}
+
+static int calc_credit_value(u32 *rxcnt, u8 *mv, u8 *locv)
+{
+	u8 s, c, i, m, loc = 0, crd[MAX_READ] = {0};
+
+	for (s = 0; s < MAX_READ - 1; s++) {
+		for (c = s + 1; c < MAX_READ; c++) {
+			if ((rxcnt[s] <= rxcnt[c]) && (rxcnt[c] <= (rxcnt[s] + (c - s) * GAP_MAX))) {
+				crd[s]++;
+				crd[c]++;
+			}
+		}
+	}
+
+	m = crd[0];
+
+	for (i = 1; i < MAX_READ; i++) {
+		if (crd[i] > m) {
+			m = crd[i];
+			loc = i;
+		}
+	}
+
+	*mv = m;
+	*locv = loc;
+	return 0;
+}
+
+static int calc_credit_byte_value(u32 *rxcnt, u8 *mv, u8 *locv)
+{
+	u8 s, c, i, m, loc = 0, crd[MAX_READ] = {0};
+
+	for (s = 0; s < MAX_READ - 1; s++) {
+		for (c = s + 1; c < MAX_READ; c++) {
+			if ((rxcnt[s] <= rxcnt[c]) && (rxcnt[c] <= (rxcnt[s] + (c - s) * GAP_MAX1))) {
+				crd[s]++;
+				crd[c]++;
+			}
+		}
+	}
+
+	m = crd[0];
+
+	for (i = 1; i < MAX_READ; i++) {
+		if (crd[i] > m) {
+			m = crd[i];
+			loc = i;
+		}
+	}
+
+	*mv = m;
+	*locv = loc;
+	return 0;
+}
+
+#ifdef CONFIG_X86_INTEL_CE2700
+static void cport_sgmii_config(void *cdev)
+{
+	gsw_w32(cdev, 0xfa01, 0, 16, 0x0030);
+	gsw_w32(cdev, 0xfa01, 0, 14, 0x0010);
+	gsw_w32(cdev, 0xD009, 0, 16, 0x0009);
+	gsw_w32(cdev, 0xD004, 0, 16, 0x053A);
+	/*Reset of TBI FSM's*/
+	gsw_w32(cdev, 0xD305, 0, 16, 0x0033);
+	/*Release  TBI FSM's*/
+	gsw_w32(cdev, 0xD305, 0, 16, 0x0032);
+	/*  TX Buffer and pointers are initialized */
+	gsw_w32(cdev, 0xD404, 0, 16, 0x0003);
+	/* TX Buffer and pointers are normally operating */
+	gsw_w32(cdev, 0xD404, 0, 16, 0x0001);
+	/*  RX Buffer and pointers are initialized */
+	gsw_w32(cdev, 0xD401, 0, 16, 0x0003);
+	/*  RX Buffer and pointers are normally operating */
+	gsw_w32(cdev, 0xD401, 0, 16, 0x0001);
+	gsw_w32(cdev, 0xD300, 0, 16, 0x0018);
+	gsw_w32(cdev, 0xD301, 0, 16, 0x0001);
+	/*  Restart Autonegotiation */
+	gsw_w32(cdev, 0xD304, 0, 16, 0x803c);
+	/*SGMII_PHY SGMII PHY mode */
+	gsw_w32(cdev, 0xD304, 0, 16, 0x80b4);
+}
+#endif
+
+static void ltq_ethsw_port_cfg_init(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 i, value;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return;
+	}
+
+
+	gsw_r32(cdev, ETHSW_CAP_1_PPORTS_OFFSET,
+		ETHSW_CAP_1_PPORTS_SHIFT,
+		ETHSW_CAP_1_PPORTS_SIZE, &value);
+	gswdev->pnum = value;
+
+	for (i = 0; i < gswdev->pnum; i++) {
+		memset(&gswdev->pconfig[i], 0, sizeof(port_config_t));
+		gswdev->pconfig[i].llimit = 0xFF;
+		gswdev->pconfig[i].penable = 1;
+	}
+
+	gswdev->stpconfig.sfport = GSW_PORT_FORWARD_DEFAULT;
+	gswdev->stpconfig.fpid8021x = gswdev->cport;
+	gsw_r32(cdev, ETHSW_CAP_1_VPORTS_OFFSET, ETHSW_CAP_1_VPORTS_SHIFT,
+		ETHSW_CAP_1_VPORTS_SIZE, &value);
+	gswdev->tpnum = value + gswdev->pnum;
+}
+#if defined(CONFIG_LTQ_MULTICAST) && CONFIG_LTQ_MULTICAST
+static void reset_multicast_sw_table(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 i;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return;
+	}
+	if (IS_VRSN_31(gswdev->gipver)) {
+		gsw_init_hash_table(cdev);
+	}
+
+	memset(&gswdev->iflag, 0, sizeof(gsw_igmp_t));
+	gswdev->iflag.itblsize = gswdev->mctblsize;
+
+	for (i = 0; i < gswdev->iflag.itblsize; i++) {
+		gswdev->iflag.mctable[i].slsbindex = 0x7F;
+		gswdev->iflag.mctable[i].dlsbindex = 0x7F;
+		gswdev->iflag.mctable[i].smsbindex = 0x1F;
+		gswdev->iflag.mctable[i].dmsbindex = 0x1F;
+	}
+}
+
+/* Multicast Software Table Include/Exclude Add function */
+static int gsw2x_msw_table_wr(void *cdev, GSW_multicastTable_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	int	i, j, exclude_rule = 0;
+	int	dlix = 0, dmix = 0;
+	int slix = 0, smix = 0;
+	int dlflag = 0, dmflag = 0, slflag = 0, smflag = 0;
+	ltq_bool_t new_entry = 0;
+	pctbl_prog_t ptdata;
+	pce_dasa_lsb_t	ltbl;
+	pce_dasa_msb_t	mtbl;
+	ltq_pce_table_t *hpctbl = NULL;
+	gsw_igmp_t *hitbl = NULL;
+	
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+
+	hpctbl = &gswdev->phandler;
+	hitbl = &gswdev->iflag;
+
+
+	memset(&ptdata, 0, sizeof(pctbl_prog_t));
+	memset(&ltbl, 0, sizeof(pce_dasa_lsb_t));
+	memset(&mtbl, 0, sizeof(pce_dasa_msb_t));
+
+	if ((parm->eModeMember == GSW_IGMP_MEMBER_INCLUDE)
+	    || (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE)) {
+		if (gswdev->iflag.igv3 != 1) {
+			pr_err("%s:%s:%d(bIGMPv3 need to be enable)\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+	}
+
+	if ((parm->eIPVersion != GSW_IP_SELECT_IPV4)
+	    && (parm->eIPVersion != GSW_IP_SELECT_IPV6)) {
+		pr_err("%s:%s:%d (IPv4/IPV6 need to enable)\n",
+		       __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
+		for (i = 0; i < 4; i++)
+			ltbl.ilsb[i] =
+				((parm->uIP_Gda.nIPv4 >> (i * 8)) & 0xFF);
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			ltbl.mask[0] = 0;
+			ltbl.mask[1] = 0;
+			ltbl.mask[2] = 0xFFFF;
+			ltbl.mask[3] = 0xFFFF;
+		} else {
+			ltbl.mask[0] = 0xFF00;
+		}
+	}
+
+	if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+		for (i = 0, j = 7; i < 4; i++, j -= 2) {
+			mtbl.imsb[j - 1] = (parm->uIP_Gda.nIPv6[i] & 0xFF);
+			mtbl.imsb[j] = ((parm->uIP_Gda.nIPv6[i] >> 8) & 0xFF);
+		}
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			mtbl.mask[0] = 0;
+			mtbl.mask[1] = 0;
+			mtbl.mask[2] = 0;
+			mtbl.mask[3] = 0;
+		} else {
+			mtbl.mask[0] = 0;
+		}
+
+		dmix = find_msb_tbl_entry(&hpctbl->pce_sub_tbl, &mtbl);
+
+		if (dmix == 0xFF) {
+			dmix = pce_dasa_msb_tbl_write(cdev,
+						      &hpctbl->pce_sub_tbl, &mtbl);
+			dmflag = 1;
+		}
+
+		if (dmix < 0) {
+			pr_err("%s:%s:%d (IGMP Table full)\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+		/* First, search for DIP in the DA/SA table (DIP LSB) */
+		for (i = 0, j = 7; i < 4; i++, j -= 2) {
+			ltbl.ilsb[j - 1] = (parm->uIP_Gda.nIPv6[i + 4] & 0xFF);
+			ltbl.ilsb[j] = ((parm->uIP_Gda.nIPv6[i + 4] >> 8) & 0xFF);
+		}
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			ltbl.mask[0] = 0;
+			ltbl.mask[1] = 0;
+			ltbl.mask[2] = 0;
+			ltbl.mask[3] = 0;
+		} else {
+			ltbl.mask[0] = 0;/* DIP LSB Nibble Mask */
+		}
+	}
+
+	dlix = find_dasa_tbl_entry(&hpctbl->pce_sub_tbl, &ltbl);
+
+	if (dlix == 0xFF) {
+		dlix = pce_dasa_lsb_tbl_write(cdev,
+					      &hpctbl->pce_sub_tbl, &ltbl);
+		dlflag = 1;
+	}
+
+	if (dlix < 0) {
+		pr_err("%s:%s:%d (IGMP Table full)\n",
+		       __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if ((parm->eModeMember == GSW_IGMP_MEMBER_INCLUDE)
+	    || (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE)) {
+		if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
+			for (i = 0; i < 4; i++)
+				ltbl.ilsb[i] =
+					((parm->uIP_Gsa.nIPv4 >> (i * 8)) & 0xFF);
+
+			if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				ltbl.mask[0] = 0x0;
+				ltbl.mask[1] = 0x0;
+				ltbl.mask[2] = 0xFFFF;
+				ltbl.mask[3] = 0xFFFF;
+			} else {
+				/* DIP LSB Nibble Mask */
+				ltbl.mask[0] = 0xFF00;
+			}
+
+			if (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE) {
+				if ((ltbl.ilsb[3] == 0) &&
+				    (ltbl.ilsb[2] == 0) &&
+				    (ltbl.ilsb[1] == 0) &&
+				    (ltbl.ilsb[0] == 0)) {
+					pr_err("%s:%s:%d (Exclude Rule Source IP is Wildcard)\n",
+					       __FILE__, __func__, __LINE__);
+					return GSW_statusErr;
+				}
+			}
+		}
+
+		if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+			int src_zero = 0;
+
+			/*First, search for DIP in the DA/SA table (DIP MSB)*/
+			for (i = 0, j = 7; i < 4; i++, j -= 2) {
+				mtbl.imsb[j - 1] =
+					(parm->uIP_Gsa.nIPv6[i] & 0xFF);
+				mtbl.imsb[j] =
+					((parm->uIP_Gsa.nIPv6[i] >> 8) & 0xFF);
+			}
+
+			if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				mtbl.mask[0] = 0;
+				mtbl.mask[1] = 0;
+				mtbl.mask[2] = 0;
+				mtbl.mask[3] = 0;
+			} else {
+				mtbl.mask[0] = 0;/* DIP MSB Nibble Mask */
+			}
+
+			if (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE) {
+				if ((mtbl.imsb[0] == 0) &&
+				    (mtbl.imsb[1] == 0) &&
+				    (mtbl.imsb[2] == 0) &&
+				    (mtbl.imsb[3] == 0) &&
+				    (mtbl.imsb[4] == 0) &&
+				    (mtbl.imsb[5] == 0) &&
+				    (mtbl.imsb[6] == 0) &&
+				    (mtbl.imsb[7] == 0)) {
+					src_zero = 1;
+				}
+			}
+
+			/* First, search for DIP in the DA/SA table (DIP LSB) */
+			for (i = 0, j = 7; i < 4; i++, j -= 2) {
+				ltbl.ilsb[j - 1] =
+					(parm->uIP_Gsa.nIPv6[i + 4] & 0xFF);
+				ltbl.ilsb[j] =
+					((parm->uIP_Gsa.nIPv6[i + 4] >> 8) & 0xFF);
+			}
+
+			if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				ltbl.mask[0] = 0;
+				ltbl.mask[1] = 0;
+				ltbl.mask[2] = 0;
+				ltbl.mask[3] = 0;
+			} else {
+				ltbl.mask[0] = 0;/* DIP LSB Nibble Mask */
+			}
+
+			if (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE) {
+				if ((ltbl.ilsb[0] == 0) &&
+				    (ltbl.ilsb[1] == 0) &&
+				    (ltbl.ilsb[2] == 0) &&
+				    (ltbl.ilsb[3] == 0) &&
+				    (ltbl.ilsb[4] == 0) &&
+				    (ltbl.ilsb[5] == 0) &&
+				    (ltbl.ilsb[6] == 0) &&
+				    (ltbl.ilsb[7] == 0)) {
+					if (src_zero) {
+						pr_err("%s:%s:%d (Exclude Rule Source IP is Wildcard)\n",
+						       __FILE__, __func__, __LINE__);
+						return GSW_statusErr;
+					}
+				}
+			}
+
+			smix = find_msb_tbl_entry(&hpctbl->pce_sub_tbl, &mtbl);
+
+			if (smix == 0xFF) {
+				smix = pce_dasa_msb_tbl_write(cdev,
+							      &hpctbl->pce_sub_tbl, &mtbl);
+				smflag = 1;
+			}
+
+			if (smix < 0) {
+				pr_err("%s:%s:%d (IGMP Table full)\n",
+				       __FILE__, __func__, __LINE__);
+				return GSW_statusErr;
+			}
+		}
+
+		slix = find_dasa_tbl_entry(&hpctbl->pce_sub_tbl, &ltbl);
+
+		if (slix == 0xFF) {
+			slix = pce_dasa_lsb_tbl_write(cdev,
+						      &hpctbl->pce_sub_tbl, &ltbl);
+			slflag = 1;
+		}
+
+		if (slix < 0) {
+			pr_err("%s:%s:%d (IGMP Table full)\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+	}
+
+	/* update the entry for another port number if already exists*/
+	for (i = 0; i < gswdev->iflag.itblsize; i++) {
+		/* Check if port was already exist */
+		if ((hitbl->mctable[i].dlsbindex == dlix) &&
+		    (hitbl->mctable[i].dmsbindex == dmix) &&
+		    (hitbl->mctable[i].slsbindex == slix) &&
+		    (hitbl->mctable[i].smsbindex == smix) &&
+		    (hitbl->mctable[i].valid == 1)) {
+			if (((hitbl->mctable[i].pmap >> parm->nPortId)
+			     & 0x1) == 1)
+				return GSW_statusOk;
+
+			switch (hitbl->mctable[i].mcmode) {
+			case GSW_IGMP_MEMBER_DONT_CARE:
+				hpctbl->pce_sub_tbl.iplsbtcnt[dlix]++;
+
+				if (parm->eIPVersion == GSW_IP_SELECT_IPV6)
+					hpctbl->pce_sub_tbl.ipmsbtcnt[dmix]++;
+
+				/* Add the port */
+				hitbl->mctable[i].pmap |= (1 << parm->nPortId);
+				break;
+
+			case GSW_IGMP_MEMBER_EXCLUDE:
+				if (gswdev->gipver == LTQ_GSWIP_3_0)
+					exclude_rule = 0;
+				else
+					exclude_rule = 1;
+
+			case GSW_IGMP_MEMBER_INCLUDE:
+				/* Add the port */
+				hitbl->mctable[i].pmap |= (1 << parm->nPortId);
+				hpctbl->pce_sub_tbl.iplsbtcnt[dlix]++;
+				hpctbl->pce_sub_tbl.iplsbtcnt[slix]++;
+
+				if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+					hpctbl->pce_sub_tbl.ipmsbtcnt[dmix]++;
+					hpctbl->pce_sub_tbl.ipmsbtcnt[smix]++;
+				}
+
+				break;
+			} /* end switch */
+
+			/* Now, we write into Multicast SW Table */
+			memset(&ptdata, 0, sizeof(pctbl_prog_t));
+			ptdata.table = PCE_MULTICAST_SW_INDEX;
+			ptdata.pcindex = i;
+			ptdata.key[1] = (hitbl->mctable[i].smsbindex << 8)
+					| hitbl->mctable[i].slsbindex;
+			ptdata.key[0] = (hitbl->mctable[i].dmsbindex << 8)
+					| hitbl->mctable[i].dlsbindex;
+
+			if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				ptdata.val[0] = hitbl->mctable[i].pmap;
+				ptdata.val[1] =
+					(parm->nSubIfId & 0xFFFF)	<< 3;
+				ptdata.key[2] = parm->nFID & 0x3F;
+
+				if (parm->eModeMember ==
+				    GSW_IGMP_MEMBER_EXCLUDE) {
+					ptdata.key[2] |= (1 << 15);
+					/*ptdata.key[2] |= (parm->bExclSrcIP & 1) << 15; */
+				} else {
+					ptdata.key[2] &= ~(1 << 15);
+				}
+			} else {
+				if (parm->eModeMember ==
+				    GSW_IGMP_MEMBER_EXCLUDE)
+					ptdata.val[0] = (0 << parm->nPortId);
+				else
+					ptdata.val[0] = hitbl->mctable[i].pmap;
+			}
+
+			ptdata.valid = hitbl->mctable[i].valid;
+			gsw_pce_table_write(cdev, &ptdata);
+			new_entry = 1;
+
+			if (exclude_rule == 0)
+				return GSW_statusOk;
+		}
+	}
+
+	/* wildcard entry for EXCLUDE rule for  port number if already exists*/
+	/*if (gswdev->gipver != LTQ_GSWIP_3_0) {*/
+	if ((exclude_rule == 1) && (new_entry == 1)) {
+		for (i = 0; i < gswdev->iflag.itblsize; i++) {
+			/* Check if port was already exist */
+			if ((hitbl->mctable[i].dlsbindex == dlix) &&
+			    (hitbl->mctable[i].dmsbindex == dmix) &&
+			    (hitbl->mctable[i].slsbindex == 0x7F) &&
+			    (hitbl->mctable[i].smsbindex == 0x7F) &&
+			    (hitbl->mctable[i].valid == 1)) {
+				if (((hitbl->mctable[i].pmap >>
+				      parm->nPortId) & 0x1) == 1) {
+					return GSW_statusOk;
+				} else {
+					hpctbl->pce_sub_tbl.iplsbtcnt[dlix]++;
+
+					if (parm->eIPVersion ==
+					    GSW_IP_SELECT_IPV6)
+						hpctbl->pce_sub_tbl.ipmsbtcnt[dmix]++;
+
+					/* Add the port */
+					hitbl->mctable[i].pmap |=
+						(1 << parm->nPortId);
+				}
+
+				hitbl->mctable[i].mcmode =
+					GSW_IGMP_MEMBER_DONT_CARE;
+				memset(&ptdata, 0, sizeof(pctbl_prog_t));
+				ptdata.table = PCE_MULTICAST_SW_INDEX;
+				ptdata.pcindex = i;
+				ptdata.key[1] =
+					((hitbl->mctable[i].smsbindex << 8)
+					 | (hitbl->mctable[i].slsbindex));
+				ptdata.key[0] =
+					((hitbl->mctable[i].dmsbindex << 8)
+					 | (hitbl->mctable[i].dlsbindex));
+				ptdata.val[0] = hitbl->mctable[i].pmap;
+				ptdata.valid = hitbl->mctable[i].valid;
+
+				if (gswdev->gipver == LTQ_GSWIP_3_0) {
+					ptdata.val[1] =
+						(parm->nSubIfId & 0xFFFF)	<< 3;
+					ptdata.key[2] = parm->nFID & 0x3F;
+					ptdata.key[2] |=
+						(parm->bExclSrcIP & 1) << 15;
+				}
+
+				gsw_pce_table_write(cdev, &ptdata);
+				return GSW_statusOk;
+			}
+		}
+	}
+
+	/*	}*/
+	/* Create the new DstIP & SrcIP entry */
+	if (new_entry == 0) {
+		if ((parm->eModeMember == GSW_IGMP_MEMBER_INCLUDE)
+		    || (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE)) {
+			i = 0;
+
+			while (i < gswdev->iflag.itblsize) {
+				/* Find a new empty entry to add */
+				if (hitbl->mctable[i].valid == 0)
+					break;
+
+				i++;
+			}
+		} else if (parm->eModeMember == GSW_IGMP_MEMBER_DONT_CARE) {
+			i = 63;
+
+			while (i > 0) {
+				/* Find a new empty entry to add */
+				if (hitbl->mctable[i].valid == 0)
+					break;
+
+				i--;
+			}
+		}
+
+		if (i >= 0 && i < gswdev->iflag.itblsize) {
+			hitbl->mctable[i].dlsbindex = dlix;
+			hitbl->mctable[i].dmsbindex = dmix;
+			hitbl->mctable[i].pmap |= (1 << parm->nPortId);
+
+			if (dlflag)
+				hpctbl->pce_sub_tbl.iplsbtcnt[dlix] = 1;
+			else
+				hpctbl->pce_sub_tbl.iplsbtcnt[dlix]++;
+
+			if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+				if (dmflag)
+					hpctbl->pce_sub_tbl.ipmsbtcnt[dmix] = 1;
+				else
+					hpctbl->pce_sub_tbl.ipmsbtcnt[dmix]++;
+			}
+
+			hitbl->mctable[i].valid = 1;
+			hitbl->mctable[i].mcmode = parm->eModeMember;
+
+			if ((parm->eModeMember == GSW_IGMP_MEMBER_INCLUDE)
+			    || (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE)) {
+				hitbl->mctable[i].slsbindex = slix;
+				hitbl->mctable[i].smsbindex = smix;
+
+				if (slflag)
+					hpctbl->pce_sub_tbl.iplsbtcnt[slix] = 1;
+				else
+					hpctbl->pce_sub_tbl.iplsbtcnt[slix]++;
+
+				if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+					if (smflag)
+						hpctbl->pce_sub_tbl.ipmsbtcnt[smix] = 1;
+					else
+						hpctbl->pce_sub_tbl.ipmsbtcnt[smix]++;
+				}
+			} else if (parm->eModeMember ==
+				   GSW_IGMP_MEMBER_DONT_CARE) {
+				hitbl->mctable[i].slsbindex = 0x7F;
+				hitbl->mctable[i].smsbindex = 0x7F;
+			}
+		}
+
+		memset(&ptdata, 0, sizeof(pctbl_prog_t));
+		/* Now, we write into Multicast SW Table */
+		ptdata.table = PCE_MULTICAST_SW_INDEX;
+		ptdata.pcindex = i;
+		ptdata.key[1] = ((hitbl->mctable[i].smsbindex << 8)
+				 | hitbl->mctable[i].slsbindex);
+		ptdata.key[0] = ((hitbl->mctable[i].dmsbindex << 8)
+				 | hitbl->mctable[i].dlsbindex);
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			ptdata.val[0] = hitbl->mctable[i].pmap;
+		} else {
+			if ((parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE))
+				ptdata.val[0] = (0 << parm->nPortId);
+			else
+				ptdata.val[0] = hitbl->mctable[i].pmap;
+		}
+
+		ptdata.valid = hitbl->mctable[i].valid;
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			ptdata.val[1] = (parm->nSubIfId & 0xFFFF)	<< 3;
+			ptdata.key[2] = parm->nFID & 0x3F;
+			ptdata.key[2] |= (parm->bExclSrcIP & 1) << 15;
+		}
+
+		gsw_pce_table_write(cdev, &ptdata);
+
+		if ((parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE)) {
+			for (i = 0; i < gswdev->iflag.itblsize; i++) {
+				/* Check if port was already exist */
+				if ((hitbl->mctable[i].dlsbindex == dlix) &&
+				    (hitbl->mctable[i].dmsbindex == dmix) &&
+				    (hitbl->mctable[i].slsbindex == 0x7F) &&
+				    (hitbl->mctable[i].smsbindex == 0x7F) &&
+				    (hitbl->mctable[i].valid == 1)) {
+					if (((hitbl->mctable[i].pmap >>
+					      parm->nPortId) & 0x1) == 1)
+						return GSW_statusOk;
+
+					hpctbl->pce_sub_tbl.iplsbtcnt[dlix]++;
+
+					if (parm->eIPVersion ==
+					    GSW_IP_SELECT_IPV6)
+						hpctbl->pce_sub_tbl.ipmsbtcnt[dmix]++;
+
+					hitbl->mctable[i].mcmode =
+						GSW_IGMP_MEMBER_DONT_CARE;
+					/* Add the port */
+					hitbl->mctable[i].pmap |=
+						(1 << parm->nPortId);
+					memset(&ptdata, 0, sizeof(pctbl_prog_t));
+					ptdata.table = PCE_MULTICAST_SW_INDEX;
+					ptdata.pcindex = i;
+					ptdata.key[1] =
+						((hitbl->mctable[i].smsbindex << 8)
+						 | (hitbl->mctable[i].slsbindex));
+					ptdata.key[0] =
+						((hitbl->mctable[i].dmsbindex << 8)
+						 | (hitbl->mctable[i].dlsbindex));
+					ptdata.val[0] = hitbl->mctable[i].pmap;
+					ptdata.valid = hitbl->mctable[i].valid;
+					gsw_pce_table_write(cdev, &ptdata);
+					return GSW_statusOk;
+				}
+			}
+
+			i = 63;
+
+			while (i > 0) {
+				/* Find a new empty entry to add */
+				if (hitbl->mctable[i].valid == 0)
+					break;
+
+				i--;
+			}
+
+			if (i >= 0 && i < gswdev->iflag.itblsize) {
+				/* Now, we write into Multicast SW Table */
+				hitbl->mctable[i].dlsbindex = dlix;
+				hitbl->mctable[i].dmsbindex = dmix;
+				hitbl->mctable[i].slsbindex = 0x7F;
+				hitbl->mctable[i].smsbindex = 0x7F;
+				hitbl->mctable[i].pmap |= (1 << parm->nPortId);
+				hitbl->mctable[i].mcmode = GSW_IGMP_MEMBER_DONT_CARE;
+				hitbl->mctable[i].valid = 1;
+				hpctbl->pce_sub_tbl.iplsbtcnt[dlix]++;
+
+				if (parm->eIPVersion == GSW_IP_SELECT_IPV6)
+					hpctbl->pce_sub_tbl.ipmsbtcnt[dmix]++;
+
+				memset(&ptdata, 0, sizeof(pctbl_prog_t));
+				ptdata.table = PCE_MULTICAST_SW_INDEX;
+				ptdata.pcindex = i;
+				ptdata.key[1] = ((hitbl->mctable[i].smsbindex << 8)
+						 | hitbl->mctable[i].slsbindex);
+				ptdata.key[0] = ((hitbl->mctable[i].dmsbindex << 8)
+						 | hitbl->mctable[i].dlsbindex);
+				ptdata.val[0] = hitbl->mctable[i].pmap;
+				ptdata.valid = hitbl->mctable[i].valid;
+
+				if (gswdev->gipver == LTQ_GSWIP_3_0) {
+					ptdata.val[1] =
+						(parm->nSubIfId & 0xFFFF)	<< 3;
+					ptdata.key[2] = parm->nFID & 0x3F;
+					ptdata.key[2] |= (parm->bExclSrcIP & 1) << 15;
+				}
+
+				gsw_pce_table_write(cdev, &ptdata);
+			} else {
+				pr_err("%s:%s:%d (IGMP Table full)\n",
+				       __FILE__, __func__, __LINE__);
+			}
+		}
+	}
+
+	/* Debug */
+	return GSW_statusOk;
+}
+
+/* Multicast Software Table Include/Exclude Add function */
+static int gsw3x_msw_table_wr(void *cdev, GSW_multicastTable_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	int	i, j, exclude_rule = 0;
+	int	dlix = 0, dmix = 0;
+	int slix = 0, smix = 0;
+	int dlflag = 0, dmflag = 0, slflag = 0, smflag = 0;
+	ltq_bool_t new_entry = 0;
+	pctbl_prog_t ptdata;
+	pce_dasa_lsb_t	ltbl;
+	pce_dasa_msb_t	mtbl;
+	ltq_pce_table_t *hpctbl = NULL;
+	gsw_igmp_t *hitbl = NULL;
+	
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	hpctbl = &gswdev->phandler;
+	hitbl = &gswdev->iflag;
+
+
+	memset(&ptdata, 0, sizeof(pctbl_prog_t));
+	memset(&ltbl, 0, sizeof(pce_dasa_lsb_t));
+	memset(&mtbl, 0, sizeof(pce_dasa_msb_t));
+
+	if ((parm->eModeMember == GSW_IGMP_MEMBER_INCLUDE)
+	    || (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE)) {
+		if (gswdev->iflag.igv3 != 1) {
+			pr_err("%s:%s:%d(bIGMPv3 need to be enable)\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+	}
+
+	if ((parm->eIPVersion != GSW_IP_SELECT_IPV4)
+	    && (parm->eIPVersion != GSW_IP_SELECT_IPV6)) {
+		pr_err("%s:%s:%d (IPv4/IPV6 need to enable)\n",
+		       __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
+		for (i = 0; i < 4; i++)
+			ltbl.ilsb[i] = ((parm->uIP_Gda.nIPv4 >> (i * 8))
+					& 0xFF);
+
+		ltbl.mask[0] = 0;
+		ltbl.mask[1] = 0;
+		ltbl.mask[2] = 0xFFFF;
+		ltbl.mask[3] = 0xFFFF;
+	}
+
+	if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+		for (i = 0, j = 7; i < 4; i++, j -= 2) {
+			mtbl.imsb[j - 1] = (parm->uIP_Gda.nIPv6[i] & 0xFF);
+			mtbl.imsb[j] = ((parm->uIP_Gda.nIPv6[i] >> 8) & 0xFF);
+		}
+
+		mtbl.mask[0] = 0;
+		mtbl.mask[1] = 0;
+		mtbl.mask[2] = 0;
+		mtbl.mask[3] = 0;
+		dmix = find_msb_tbl_entry(&hpctbl->pce_sub_tbl,
+					  &mtbl);
+
+		if (dmix == 0xFF) {
+			dmix = pce_dasa_msb_tbl_write(cdev,
+						      &hpctbl->pce_sub_tbl, &mtbl);
+			dmflag = 1;
+		}
+
+		if ((dmix < 0) || (dmix > (IP_DASA_PC_MSIZE - 1))) {
+			pr_err("%s:%s:%d (IGMP Table full)\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+		/* First, search for DIP in the DA/SA table (DIP LSB) */
+		for (i = 0, j = 7; i < 4; i++, j -= 2) {
+			ltbl.ilsb[j - 1] = (parm->uIP_Gda.nIPv6[i + 4] & 0xFF);
+			ltbl.ilsb[j] = ((parm->uIP_Gda.nIPv6[i + 4] >> 8) & 0xFF);
+		}
+
+		ltbl.mask[0] = 0;
+		ltbl.mask[1] = 0;
+		ltbl.mask[2] = 0;
+		ltbl.mask[3] = 0;
+	}
+
+	dlix = find_dasa_tbl_entry(&hpctbl->pce_sub_tbl,
+				   &ltbl);
+
+	if (dlix == 0xFF) {
+		dlix = pce_dasa_lsb_tbl_write(cdev,
+					      &hpctbl->pce_sub_tbl, &ltbl);
+		dlflag = 1;
+	}
+
+
+
+	if ((dlix < 0) || (dlix > (IP_DASA_PC_LSIZE - 1))) {
+		pr_err("%s:%s:%d (IGMP Table full)\n",
+		       __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if ((parm->eModeMember == GSW_IGMP_MEMBER_INCLUDE) ||
+	    (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE)) {
+		if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
+			for (i = 0; i < 4; i++)
+				ltbl.ilsb[i] = ((parm->uIP_Gsa.nIPv4 >> (i * 8))
+						& 0xFF);
+
+			ltbl.mask[0] = 0x0;
+			ltbl.mask[1] = 0x0;
+			ltbl.mask[2] = 0xFFFF;
+			ltbl.mask[3] = 0xFFFF;
+
+			if (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE) {
+				if ((ltbl.ilsb[3] == 0) &&
+				    (ltbl.ilsb[2] == 0) &&
+				    (ltbl.ilsb[1] == 0) &&
+				    (ltbl.ilsb[0] == 0)) {
+					pr_err("%s:%s:%d (Exclude Rule Source IP is Wildcard)\n",
+					       __FILE__, __func__, __LINE__);
+					return GSW_statusErr;
+				}
+			}
+		}
+
+		if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+			int src_zero = 0;
+
+			/* First, search for DIP in the DA/SA table (DIP MSB) */
+			for (i = 0, j = 7; i < 4; i++, j -= 2) {
+				mtbl.imsb[j - 1] = (parm->uIP_Gsa.nIPv6[i]
+						    & 0xFF);
+				mtbl.imsb[j] = ((parm->uIP_Gsa.nIPv6[i] >> 8)
+						& 0xFF);
+			}
+
+			mtbl.mask[0] = 0;
+			mtbl.mask[1] = 0;
+			mtbl.mask[2] = 0;
+			mtbl.mask[3] = 0;
+
+			if (parm->eModeMember ==
+			    GSW_IGMP_MEMBER_EXCLUDE) {
+				if (mtbl.imsb[0] == 0 &&
+				    mtbl.imsb[1] == 0 &&
+				    mtbl.imsb[2] == 0 &&
+				    mtbl.imsb[3] == 0 &&
+				    mtbl.imsb[4] == 0 &&
+				    mtbl.imsb[5] == 0 &&
+				    mtbl.imsb[6] == 0 &&
+				    mtbl.imsb[7] == 0) {
+					src_zero = 1;
+				}
+			}
+
+			/* First, search for DIP in the DA/SA table (DIP LSB) */
+			for (i = 0, j = 7; i < 4; i++, j -= 2) {
+				ltbl.ilsb[j - 1] = (parm->uIP_Gsa.nIPv6[i + 4]
+						    & 0xFF);
+				ltbl.ilsb[j] = ((parm->uIP_Gsa.nIPv6[i + 4] >> 8)
+						& 0xFF);
+			}
+
+			ltbl.mask[0] = 0;
+			ltbl.mask[1] = 0;
+			ltbl.mask[2] = 0;
+			ltbl.mask[3] = 0;
+
+			if (parm->eModeMember ==
+			    GSW_IGMP_MEMBER_EXCLUDE) {
+				if ((ltbl.ilsb[0] == 0) &&
+				    (ltbl.ilsb[1] == 0) &&
+				    (ltbl.ilsb[2] == 0) &&
+				    (ltbl.ilsb[3] == 0) &&
+				    (ltbl.ilsb[4] == 0) &&
+				    (ltbl.ilsb[5] == 0) &&
+				    (ltbl.ilsb[6] == 0) &&
+				    (ltbl.ilsb[7] == 0)) {
+					if (src_zero) {
+						pr_err("%s:%s:%d (Exclude rule SIP is Wildcard)\n",
+						       __FILE__, __func__, __LINE__);
+						return GSW_statusErr;
+					}
+				}
+			}
+
+			smix = find_msb_tbl_entry(&hpctbl->pce_sub_tbl,
+						  &mtbl);
+
+			if (smix == 0xFF) {
+				smix = pce_dasa_msb_tbl_write(cdev,
+							      &hpctbl->pce_sub_tbl, &mtbl);
+				smflag = 1;
+			}
+
+			if ((smix < 0) || (smix > (IP_DASA_PC_MSIZE - 1))) {
+				pr_err("%s:%s:%d (IGMP Table full)\n",
+				       __FILE__, __func__, __LINE__);
+				return GSW_statusErr;
+			}
+		}
+
+		slix = find_dasa_tbl_entry(&hpctbl->pce_sub_tbl,
+					   &ltbl);
+
+		if (slix == 0xFF) {
+			slix = pce_dasa_lsb_tbl_write(cdev,
+						      &hpctbl->pce_sub_tbl, &ltbl);
+			slflag = 1;
+		}
+
+		if ((slix < 0) || (slix > (IP_DASA_PC_LSIZE - 1))) {
+			pr_err("%s:%s:%d (IGMP Table full)\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+	}
+
+	/* update the entry for another port number if already exists*/
+	for (i = 0; i < gswdev->iflag.itblsize; i++) {
+		/* Check if port was already exist */
+		if ((hitbl->mctable[i].dlsbindex == dlix) &&
+		    (hitbl->mctable[i].dmsbindex == dmix) &&
+		    (hitbl->mctable[i].slsbindex == slix) &&
+		    (hitbl->mctable[i].smsbindex == smix) &&
+		    (hitbl->mctable[i].valid == 1) &&
+		    (hitbl->mctable[i].fid == parm->nFID)) {
+			if (((hitbl->mctable[i].pmap >> parm->nPortId)
+			     & 0x1) == 1)
+				return GSW_statusOk;
+
+			exclude_rule = 0;
+
+			switch (hitbl->mctable[i].mcmode) {
+			case GSW_IGMP_MEMBER_DONT_CARE:
+				hpctbl->pce_sub_tbl.iplsbtcnt[dlix]++;
+
+				if (parm->eIPVersion == GSW_IP_SELECT_IPV6)
+					hpctbl->pce_sub_tbl.ipmsbtcnt[dmix]++;
+
+				/* Add the port */
+				hitbl->mctable[i].pmap |= (1 << parm->nPortId);
+				break;
+
+			case GSW_IGMP_MEMBER_EXCLUDE:
+				exclude_rule = 1;
+
+			/*		hitbl->mctable[i].exclude = 1; */
+			/*		ptdata.key[2] |= (parm->bExclSrcIP & 1) << 15; */
+			case GSW_IGMP_MEMBER_INCLUDE:
+				/* Add the port */
+				hitbl->mctable[i].pmap |= (1 << parm->nPortId);
+				hpctbl->pce_sub_tbl.iplsbtcnt[dlix]++;
+				hpctbl->pce_sub_tbl.iplsbtcnt[slix]++;
+
+				if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+					hpctbl->pce_sub_tbl.ipmsbtcnt[dmix]++;
+					hpctbl->pce_sub_tbl.ipmsbtcnt[smix]++;
+				}
+
+				break;
+			} /* end switch */
+
+			/* Now, we write into Multicast SW Table */
+			memset(&ptdata, 0, sizeof(pctbl_prog_t));
+			ptdata.table = PCE_MULTICAST_SW_INDEX;
+			ptdata.pcindex = i;
+			ptdata.key[1] = ((hitbl->mctable[i].smsbindex << 8)
+					 | (hitbl->mctable[i].slsbindex));
+			ptdata.key[0] = ((hitbl->mctable[i].dmsbindex << 8)
+					 | (hitbl->mctable[i].dlsbindex));
+			ptdata.key[2] = ((hitbl->mctable[i].fid) & 0x3F);
+			ptdata.key[2] |= ((hitbl->mctable[i].exclude) << 15);
+			ptdata.val[0] = hitbl->mctable[i].pmap;
+			ptdata.val[1] = ((hitbl->mctable[i].subifid)	<< 3);
+			ptdata.valid = hitbl->mctable[i].valid;
+			gsw_pce_table_write(cdev, &ptdata);
+			new_entry = 1;
+		}
+	}
+
+	/* Create the new DstIP & SrcIP entry */
+	if (new_entry == 0) {
+		if ((parm->eModeMember == GSW_IGMP_MEMBER_INCLUDE) ||
+		    (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE)) {
+			i = 0;
+
+			while (i < gswdev->iflag.itblsize) {
+				/* Find a new empty entry to add */
+				if (hitbl->mctable[i].valid == 0)
+					break;
+
+				i++;
+			}
+		} else if (parm->eModeMember == GSW_IGMP_MEMBER_DONT_CARE) {
+			i = 63;
+
+			while (i > 0) {
+				/* Find a new empty entry to add */
+				if (hitbl->mctable[i].valid == 0)
+					break;
+
+				i--;
+			}
+		}
+
+		if (i >= 0 && i < gswdev->iflag.itblsize) {
+			hitbl->mctable[i].dlsbindex = dlix;
+			hitbl->mctable[i].dmsbindex = dmix;
+			hitbl->mctable[i].pmap |= (1 << parm->nPortId);
+
+			if (dlflag)
+				hpctbl->pce_sub_tbl.iplsbtcnt[dlix] = 1;
+			else
+				hpctbl->pce_sub_tbl.iplsbtcnt[dlix]++;
+
+			if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+				if (dmflag)
+					hpctbl->pce_sub_tbl.ipmsbtcnt[dmix] = 1;
+				else
+					hpctbl->pce_sub_tbl.ipmsbtcnt[dmix]++;
+			}
+
+			hitbl->mctable[i].valid = 1;
+			hitbl->mctable[i].mcmode = parm->eModeMember;
+
+			if ((parm->eModeMember == GSW_IGMP_MEMBER_INCLUDE)
+			    || (parm->eModeMember ==
+				GSW_IGMP_MEMBER_EXCLUDE)) {
+				hitbl->mctable[i].slsbindex = slix;
+				hitbl->mctable[i].smsbindex = smix;
+
+				if (slflag)
+					hpctbl->pce_sub_tbl.iplsbtcnt[slix] = 1;
+				else
+					hpctbl->pce_sub_tbl.iplsbtcnt[slix]++;
+
+				if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+					if (smflag)
+						hpctbl->pce_sub_tbl.ipmsbtcnt[smix] = 1;
+					else
+						hpctbl->pce_sub_tbl.ipmsbtcnt[smix]++;
+				}
+			} else if (parm->eModeMember ==
+				   GSW_IGMP_MEMBER_DONT_CARE) {
+				hitbl->mctable[i].slsbindex = 0x7F;
+				hitbl->mctable[i].smsbindex = 0x7F;
+			}
+		}
+
+		hitbl->mctable[i].fid = (parm->nFID & 0x3F);
+		hitbl->mctable[i].subifid = (parm->nSubIfId & 0xFFFF);
+		memset(&ptdata, 0, sizeof(pctbl_prog_t));
+		/* Now, we write into Multicast SW Table */
+		ptdata.table = PCE_MULTICAST_SW_INDEX;
+		ptdata.pcindex = i;
+		ptdata.key[1] = ((hitbl->mctable[i].smsbindex << 8)
+				 | (hitbl->mctable[i].slsbindex));
+		ptdata.key[0] = ((hitbl->mctable[i].dmsbindex << 8)
+				 | (hitbl->mctable[i].dlsbindex));
+
+		ptdata.val[0] = hitbl->mctable[i].pmap;
+		ptdata.valid = hitbl->mctable[i].valid;
+		ptdata.val[1] = (parm->nSubIfId & 0xFFFF)	<< 3;
+		ptdata.key[2] |= parm->nFID & 0x3F;
+
+		if (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE) {
+			/* ptdata.key[2] |= (parm->bExclSrcIP & 1) << 15; */
+			ptdata.key[2] |= (1 << 15);
+			hitbl->mctable[i].exclude = 1;
+		}
+
+		gsw_pce_table_write(cdev, &ptdata);
+	}
+
+	return GSW_statusOk;
+}
+
+/* Multicast Software Table Include/Exclude Remove function */
+static int gsw3x_msw_table_rm(void *cdev, GSW_multicastTable_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8	i, j;
+	ltq_bool_t MATCH = 0;
+	ltq_pce_table_t *hpctbl = NULL;
+	gsw_igmp_t *hitbl = NULL;
+	pctbl_prog_t ptdata;
+	pce_dasa_lsb_t ltbl;
+	pce_dasa_msb_t mtbl;
+	int dlix = 0, dmix = 0, slix = 0, smix = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	hpctbl = &gswdev->phandler;
+	hitbl = &gswdev->iflag;
+
+	memset(&ptdata, 0, sizeof(pctbl_prog_t));
+	memset(&ltbl, 0, sizeof(pce_dasa_lsb_t));
+	memset(&mtbl, 0, sizeof(pce_dasa_msb_t));
+
+	if ((parm->eIPVersion != GSW_IP_SELECT_IPV4)
+	    && (parm->eIPVersion != GSW_IP_SELECT_IPV6)) {
+		pr_err("%s:%s:%d (IPv4/IPV6 need to enable!!!)\n",
+		       __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if ((parm->eModeMember == GSW_IGMP_MEMBER_INCLUDE) &&
+	    (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE) &&
+	    (parm->eModeMember == GSW_IGMP_MEMBER_DONT_CARE)) {
+		pr_err("%s:%s:%d (!!!)\n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
+		/* First, search for DIP in the DA/SA table (DIP LSB) */
+		for (i = 0; i < 4; i++)
+			ltbl.ilsb[i] = ((parm->uIP_Gda.nIPv4 >> (i * 8))
+					& 0xFF);
+
+		ltbl.mask[0] = 0x0;
+		ltbl.mask[1] = 0x0;
+		ltbl.mask[2] = 0xFFFF;
+		ltbl.mask[3] = 0xFFFF;
+	}
+
+	if (parm->eIPVersion == GSW_IP_SELECT_IPV6 /* IPv6 */) {
+		/* First, search for DIP in the DA/SA table (DIP MSB) */
+		for (i = 0, j = 7; i < 4; i++, j -= 2) {
+			mtbl.imsb[j - 1] = (parm->uIP_Gda.nIPv6[i] & 0xFF);
+			mtbl.imsb[j] = ((parm->uIP_Gda.nIPv6[i] >> 8) & 0xFF);
+		}
+
+		mtbl.mask[0] = 0;
+		mtbl.mask[1] = 0;
+		mtbl.mask[2] = 0;
+		mtbl.mask[3] = 0;
+		dmix = find_msb_tbl_entry(&hpctbl->pce_sub_tbl,
+					  &mtbl);
+
+		if (dmix == 0xFF) {
+			pr_err("%s:%s:%d (IGMP Entry not found)\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+		if ((dmix < 0) || (dmix > (IP_DASA_PC_MSIZE - 1))) {
+			pr_err("%s:%s:%d (IGMP Table full)\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+		/* First, search for DIP in the DA/SA table (DIP LSB) */
+		for (i = 0, j = 7; i < 4; i++, j -= 2) {
+			ltbl.ilsb[j - 1] = (parm->uIP_Gda.nIPv6[i + 4] & 0xFF);
+			ltbl.ilsb[j] = ((parm->uIP_Gda.nIPv6[i + 4] >> 8) & 0xFF);
+		}
+
+		ltbl.mask[0] = 0;
+		ltbl.mask[1] = 0;
+		ltbl.mask[2] = 0;
+		ltbl.mask[3] = 0;
+	}
+
+	dlix = find_dasa_tbl_entry(&hpctbl->pce_sub_tbl,
+				   &ltbl);
+
+	if (dlix == 0xFF) {
+		pr_err("%s:%s:%d (IGMP Entry not found)\n",
+		       __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if ((dlix < 0) || (dlix > (IP_DASA_PC_LSIZE - 1))) {
+		pr_err("%s:%s:%d (IGMP Table full)\n",
+		       __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if ((parm->eModeMember == GSW_IGMP_MEMBER_INCLUDE)
+	    || (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE)) {
+		if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
+			/* First, search for DIP in the DA/SA table (DIP LSB) */
+			for (i = 0; i < 4; i++)
+				ltbl.ilsb[i] = ((parm->uIP_Gsa.nIPv4 >> (i * 8))
+						& 0xFF);
+
+			ltbl.mask[0] = 0x0;
+			ltbl.mask[1] = 0x0;
+			ltbl.mask[2] = 0xFFFF;
+			ltbl.mask[3] = 0xFFFF;
+
+			if (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE) {
+				if (ltbl.ilsb[3] == 0 &&
+				    (ltbl.ilsb[2] == 0) &&
+				    (ltbl.ilsb[1] == 0) &&
+				    (ltbl.ilsb[0] == 0)) {
+					pr_err("%s:%s:%d (Exclude SIP is Wildcard)\n",
+					       __FILE__, __func__, __LINE__);
+					return GSW_statusErr;
+				}
+			}
+		}
+
+		if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+			int src_zero = 0;
+
+			/* First, search for DIP in the DA/SA table (DIP MSB) */
+			for (i = 0, j = 7; i < 4; i++, j -= 2) {
+				mtbl.imsb[j - 1] = (parm->uIP_Gsa.nIPv6[i]
+						    & 0xFF);
+				mtbl.imsb[j] = ((parm->uIP_Gsa.nIPv6[i] >> 8)
+						& 0xFF);
+			}
+
+			mtbl.mask[0] = 0;
+			mtbl.mask[1] = 0;
+			mtbl.mask[2] = 0;
+			mtbl.mask[3] = 0;
+
+			if (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE) {
+				if ((mtbl.imsb[0] == 0) &&
+				    (mtbl.imsb[1] == 0) &&
+				    (mtbl.imsb[2] == 0) &&
+				    (mtbl.imsb[3] == 0) &&
+				    (mtbl.imsb[4] == 0) &&
+				    (mtbl.imsb[5] == 0) &&
+				    (mtbl.imsb[6] == 0) &&
+				    (mtbl.imsb[7] == 0))
+					src_zero = 1;
+			}
+
+			smix = find_msb_tbl_entry(&hpctbl->pce_sub_tbl,
+						  &mtbl);
+
+			if (smix == 0xFF) {
+				pr_err("%s:%s:%d (IGMP Entry not found)\n",
+				       __FILE__, __func__, __LINE__);
+				return GSW_statusErr;
+			}
+
+			if ((smix < 0) || (smix > (IP_DASA_PC_MSIZE - 1))) {
+				pr_err("%s:%s:%d (IGMP Table full)\n",
+				       __FILE__, __func__, __LINE__);
+				return GSW_statusErr;
+			}
+
+			/* First, search for DIP in the DA/SA table (DIP LSB) */
+			for (i = 0, j = 7; i < 4; i++, j -= 2) {
+				ltbl.ilsb[j - 1] = (parm->uIP_Gsa.nIPv6[i + 4]
+						    & 0xFF);
+				ltbl.ilsb[j] = ((parm->uIP_Gsa.nIPv6[i + 4] >> 8)
+						& 0xFF);
+			}
+
+			ltbl.mask[0] = 0;
+			ltbl.mask[1] = 0;
+			ltbl.mask[2] = 0;
+			ltbl.mask[3] = 0;
+
+			if (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE) {
+				if ((ltbl.ilsb[0] == 0) &&
+				    (ltbl.ilsb[1] == 0) &&
+				    (ltbl.ilsb[2] == 0) &&
+				    (ltbl.ilsb[3] == 0) &&
+				    (ltbl.ilsb[4] == 0) &&
+				    (ltbl.ilsb[5] == 0) &&
+				    (ltbl.ilsb[6] == 0) &&
+				    (ltbl.ilsb[7] == 0)) {
+					if (src_zero) {
+						pr_err("%s:%s:%d (Exclude SIP is Wildcard)\n",
+						       __FILE__, __func__, __LINE__);
+						return GSW_statusErr;
+					}
+				}
+			}
+		}
+
+		slix = find_dasa_tbl_entry(&hpctbl->pce_sub_tbl,
+					   &ltbl);
+
+		if (slix == 0xFF) {
+			pr_err("%s:%s:%d (IGMP Entry not found)\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+		if ((slix < 0) || (slix > (IP_DASA_PC_LSIZE - 1))) {
+			pr_err("%s:%s:%d (IGMP Table full)\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+	}
+
+	for (i = 0; i < gswdev->iflag.itblsize; i++) {
+		if ((hitbl->mctable[i].dlsbindex == dlix) &&
+		    (hitbl->mctable[i].slsbindex == slix) &&
+		    (hitbl->mctable[i].dmsbindex == dmix) &&
+		    (hitbl->mctable[i].smsbindex == smix) &&
+		    (hitbl->mctable[i].valid == 1) &&
+		    (hitbl->mctable[i].fid == parm->nFID)) {
+			switch (hitbl->mctable[i].mcmode) {
+			case GSW_IGMP_MEMBER_DONT_CARE:
+				if (((hitbl->mctable[i].pmap >> parm->nPortId) & 0x1) == 1) {
+					hitbl->mctable[i].pmap &= ~(1 << parm->nPortId);
+
+					if (hpctbl->pce_sub_tbl.iplsbtcnt[dlix] > 0) {
+						ipdslsb_tblidx_del(&hpctbl->pce_sub_tbl, dlix);
+
+						if (hpctbl->pce_sub_tbl.iplsbtcnt[dlix] == 0)
+							/* Delet the sub table */
+							ip_dasa_lsb_tbl_del(cdev,
+									    &hpctbl->pce_sub_tbl, dlix);
+					}
+
+					/* Delet the sub table */
+					if (hpctbl->pce_sub_tbl.ipmsbtcnt[dmix] > 0) {
+						ipdsmsb_tblidx_del(&hpctbl->pce_sub_tbl, dmix);
+
+						if (hpctbl->pce_sub_tbl.ipmsbtcnt[dmix] == 0) {
+							if (parm->eIPVersion == GSW_IP_SELECT_IPV6)
+								ip_dasa_msb_tbl_del(cdev,
+										    &hpctbl->pce_sub_tbl, dmix);
+						}
+					}
+
+					/* Check the port map status */
+					/* Delet the entry from Multicast sw Table */
+					if (hitbl->mctable[i].pmap == 0)
+						hitbl->mctable[i].valid = 0;
+
+					MATCH = 1;
+				}
+
+				break;
+
+			case GSW_IGMP_MEMBER_INCLUDE:
+			case GSW_IGMP_MEMBER_EXCLUDE:
+				if (((hitbl->mctable[i].pmap >> parm->nPortId) & 0x1) == 1) {
+					hitbl->mctable[i].pmap &= ~(1 << parm->nPortId);
+
+					if (hpctbl->pce_sub_tbl.iplsbtcnt[dlix] > 0) {
+						ipdslsb_tblidx_del(&hpctbl->pce_sub_tbl, dlix);
+
+						/* Delet the sub table */
+						if (hpctbl->pce_sub_tbl.iplsbtcnt[dlix] == 0) {
+							ip_dasa_lsb_tbl_del(cdev,
+									    &hpctbl->pce_sub_tbl, dlix);
+						}
+					}
+
+					if (hpctbl->pce_sub_tbl.ipmsbtcnt[dmix] > 0) {
+						ipdsmsb_tblidx_del(&hpctbl->pce_sub_tbl, dmix);
+
+						/* Delet the sub table */
+						if (hpctbl->pce_sub_tbl.ipmsbtcnt[dmix] == 0) {
+							ip_dasa_msb_tbl_del(cdev,
+									    &hpctbl->pce_sub_tbl, dmix);
+						}
+					}
+
+					if (hpctbl->pce_sub_tbl.iplsbtcnt[slix] > 0) {
+						ipdslsb_tblidx_del(&hpctbl->pce_sub_tbl, slix);
+
+						/* Delet the sub table */
+						if (hpctbl->pce_sub_tbl.iplsbtcnt[slix] == 0) {
+							ip_dasa_lsb_tbl_del(cdev,
+									    &hpctbl->pce_sub_tbl, slix);
+						}
+					}
+
+					if (hpctbl->pce_sub_tbl.ipmsbtcnt[smix] > 0) {
+						ipdsmsb_tblidx_del(&hpctbl->pce_sub_tbl, smix);
+
+						/* Delet the sub table */
+						if (hpctbl->pce_sub_tbl.ipmsbtcnt[smix] == 0) {
+							ip_dasa_msb_tbl_del(cdev,
+									    &hpctbl->pce_sub_tbl, smix);
+						}
+					}
+
+					/* Check the port map status */
+					if (hitbl->mctable[i].pmap == 0) {
+						/* Delet the entry from Multicast sw Table */
+						hitbl->mctable[i].valid = 0;
+					}
+
+					MATCH = 1;
+				}
+
+				break;
+			}
+
+			if (MATCH == 1) {
+				memset(&ptdata, 0, sizeof(pctbl_prog_t));
+				ptdata.table = PCE_MULTICAST_SW_INDEX;
+				ptdata.pcindex = i;
+				ptdata.key[1] = ((hitbl->mctable[i].smsbindex << 8)
+						 | (hitbl->mctable[i].slsbindex));
+				ptdata.key[0] = ((hitbl->mctable[i].dmsbindex << 8)
+						 | (hitbl->mctable[i].dlsbindex));
+				ptdata.key[2] = (hitbl->mctable[i].fid) & 0x3F;
+				ptdata.key[2] |= (hitbl->mctable[i].exclude) << 15;
+				ptdata.val[0] = hitbl->mctable[i].pmap;
+				ptdata.val[1] = (hitbl->mctable[i].subifid)	<< 3;
+				ptdata.valid = hitbl->mctable[i].valid;
+				gsw_pce_table_write(cdev, &ptdata);
+			}
+		}
+	}
+
+	if (MATCH == 0)
+		pr_err("The GIP/SIP not found\n");
+
+	return GSW_statusOk;
+}
+
+/* Multicast Software Table Include/Exclude Remove function */
+static int gsw2x_msw_table_rm(void *cdev, GSW_multicastTable_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8	i, j;
+	ltq_bool_t MATCH = 0;
+	ltq_pce_table_t *hpctbl = NULL;
+	gsw_igmp_t *hitbl = NULL;
+	pctbl_prog_t ptdata;
+	pce_dasa_lsb_t ltbl;
+	pce_dasa_msb_t mtbl;
+	int dlix = 0, dmix = 0, slix = 0, smix = 0;
+	
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	hitbl = &gswdev->iflag;
+	hpctbl = &gswdev->phandler;
+
+
+	memset(&ptdata, 0, sizeof(pctbl_prog_t));
+	memset(&ltbl, 0, sizeof(pce_dasa_lsb_t));
+	memset(&mtbl, 0, sizeof(pce_dasa_msb_t));
+
+	if ((parm->eIPVersion != GSW_IP_SELECT_IPV4)
+	    && (parm->eIPVersion != GSW_IP_SELECT_IPV6)) {
+		pr_err("%s:%s:%d (IPv4/IPV6 need to enable!!!)\n",
+		       __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if ((parm->eModeMember == GSW_IGMP_MEMBER_INCLUDE)
+	    && (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE)
+	    && (parm->eModeMember == GSW_IGMP_MEMBER_DONT_CARE)) {
+		pr_err("%s:%s:%d (!!!)\n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
+		/* First, search for DIP in the DA/SA table (DIP LSB) */
+		for (i = 0; i < 4; i++)
+			ltbl.ilsb[i] = ((parm->uIP_Gda.nIPv4 >> (i * 8)) & 0xFF);
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			ltbl.mask[0] = 0x0;
+			ltbl.mask[1] = 0x0;
+			ltbl.mask[2] = 0xFFFF;
+			ltbl.mask[3] = 0xFFFF;
+		} else {
+			/* DIP LSB Nibble Mask */
+			ltbl.mask[0] = 0xFF00;
+		}
+	}
+
+	if (parm->eIPVersion == GSW_IP_SELECT_IPV6 /* IPv6 */) {
+		/* First, search for DIP in the DA/SA table (DIP MSB) */
+		for (i = 0, j = 7; i < 4; i++, j -= 2) {
+			mtbl.imsb[j - 1] = (parm->uIP_Gda.nIPv6[i] & 0xFF);
+			mtbl.imsb[j] = ((parm->uIP_Gda.nIPv6[i] >> 8) & 0xFF);
+		}
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			mtbl.mask[0] = 0;
+			mtbl.mask[1] = 0;
+			mtbl.mask[2] = 0;
+			mtbl.mask[3] = 0;
+		} else {
+			mtbl.mask[0] = 0;/* DIP MSB Nibble Mask */
+		}
+
+		dmix = find_msb_tbl_entry(&hpctbl->pce_sub_tbl, &mtbl);
+
+		if (dmix == 0xFF) {
+			pr_err("%s:%s:%d (IGMP Entry not found)\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+		if ((dmix < 0) || (dmix > (IP_DASA_PC_MSIZE - 1))) {
+			pr_err("%s:%s:%d (IGMP Table full)\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+		/* First, search for DIP in the DA/SA table (DIP LSB) */
+		for (i = 0, j = 7; i < 4; i++, j -= 2) {
+			ltbl.ilsb[j - 1] = (parm->uIP_Gda.nIPv6[i + 4] & 0xFF);
+			ltbl.ilsb[j] = ((parm->uIP_Gda.nIPv6[i + 4] >> 8) & 0xFF);
+		}
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			ltbl.mask[0] = 0;
+			ltbl.mask[1] = 0;
+			ltbl.mask[2] = 0;
+			ltbl.mask[3] = 0;
+		} else {
+			ltbl.mask[0] = 0;/* DIP LSB Nibble Mask */
+		}
+	}
+
+	dlix = find_dasa_tbl_entry(&hpctbl->pce_sub_tbl, &ltbl);
+
+	if (dlix == 0xFF) {
+		pr_err("%s:%s:%d (IGMP Entry not found)\n",
+		       __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if ((dlix < 0) || (dlix > (IP_DASA_PC_LSIZE - 1))) {
+		pr_err("%s:%s:%d (IGMP Table full)\n",
+		       __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if ((parm->eModeMember == GSW_IGMP_MEMBER_INCLUDE)
+	    || (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE)) {
+		if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
+			/* First, search for DIP in the DA/SA table (DIP LSB) */
+			for (i = 0; i < 4; i++)
+				ltbl.ilsb[i] = ((parm->uIP_Gsa.nIPv4 >> (i * 8)) & 0xFF);
+
+			if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				ltbl.mask[0] = 0x0;
+				ltbl.mask[1] = 0x0;
+				ltbl.mask[2] = 0xFFFF;
+				ltbl.mask[3] = 0xFFFF;
+			} else {
+				/* DIP LSB Nibble Mask */
+				ltbl.mask[0] = 0xFF00;
+			}
+
+			if (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE) {
+				if (ltbl.ilsb[3] == 0 && ltbl.ilsb[2] == 0
+				    && ltbl.ilsb[1] == 0 && ltbl.ilsb[0] == 0) {
+					pr_err("%s:%s:%d (Exclude Rule Source IP is Wildcard)\n",
+					       __FILE__, __func__, __LINE__);
+					return GSW_statusErr;
+				}
+			}
+		}
+
+		if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+			int src_zero = 0;
+
+			/* First, search for DIP in the DA/SA table (DIP MSB) */
+			for (i = 0, j = 7; i < 4; i++, j -= 2) {
+				mtbl.imsb[j - 1] = (parm->uIP_Gsa.nIPv6[i] & 0xFF);
+				mtbl.imsb[j] = ((parm->uIP_Gsa.nIPv6[i] >> 8) & 0xFF);
+			}
+
+			if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				mtbl.mask[0] = 0;
+				mtbl.mask[1] = 0;
+				mtbl.mask[2] = 0;
+				mtbl.mask[3] = 0;
+			} else {
+				mtbl.mask[0] = 0;/* DIP MSB Nibble Mask */
+			}
+
+			if (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE) {
+				if ((mtbl.imsb[0] == 0) &&
+				    (mtbl.imsb[1] == 0) &&
+				    (mtbl.imsb[2] == 0) &&
+				    (mtbl.imsb[3] == 0) &&
+				    (mtbl.imsb[4] == 0) &&
+				    (mtbl.imsb[5] == 0) &&
+				    (mtbl.imsb[6] == 0) &&
+				    (mtbl.imsb[7] == 0))
+					src_zero = 1;
+			}
+
+			smix = find_msb_tbl_entry(&hpctbl->pce_sub_tbl,
+						  &mtbl);
+
+			if (smix == 0xFF) {
+				pr_err("%s:%s:%d (IGMP Entry not found)\n",
+				       __FILE__, __func__, __LINE__);
+				return GSW_statusErr;
+			}
+
+			if ((smix < 0) || (smix > (IP_DASA_PC_MSIZE - 1))) {
+				pr_err("%s:%s:%d (IGMP Table full)\n",
+				       __FILE__, __func__, __LINE__);
+				return GSW_statusErr;
+			}
+
+			/* First, search for DIP in the DA/SA table (DIP LSB) */
+			for (i = 0, j = 7; i < 4; i++, j -= 2) {
+				ltbl.ilsb[j - 1] = (parm->uIP_Gsa.nIPv6[i + 4] & 0xFF);
+				ltbl.ilsb[j] = ((parm->uIP_Gsa.nIPv6[i + 4] >> 8) & 0xFF);
+			}
+
+			if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				ltbl.mask[0] = 0;
+				ltbl.mask[1] = 0;
+				ltbl.mask[2] = 0;
+				ltbl.mask[3] = 0;
+			} else {
+				ltbl.mask[0] = 0;/* DIP LSB Nibble Mask */
+			}
+
+			if (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE) {
+				if ((ltbl.ilsb[0] == 0) &&
+				    (ltbl.ilsb[1] == 0) &&
+				    (ltbl.ilsb[2] == 0) &&
+				    (ltbl.ilsb[3] == 0) &&
+				    (ltbl.ilsb[4] == 0) &&
+				    (ltbl.ilsb[5] == 0) &&
+				    (ltbl.ilsb[6] == 0) &&
+				    (ltbl.ilsb[7] == 0)) {
+					if (src_zero) {
+						pr_err("%s:%s:%d (Exclude Rule Source IP is Wildcard)\n",
+						       __FILE__, __func__, __LINE__);
+						return GSW_statusErr;
+					}
+				}
+			}
+		}
+
+		slix = find_dasa_tbl_entry(&hpctbl->pce_sub_tbl,
+					   &ltbl);
+
+		if (slix == 0xFF) {
+			pr_err("%s:%s:%d (IGMP Entry not found)\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+		if ((slix < 0) || (slix > (IP_DASA_PC_LSIZE - 1))) {
+			pr_err("%s:%s:%d (IGMP Table full)\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+	}
+
+	for (i = 0; i < gswdev->iflag.itblsize; i++) {
+		if ((hitbl->mctable[i].dlsbindex == dlix) &&
+		    (hitbl->mctable[i].slsbindex == slix) &&
+		    (hitbl->mctable[i].dmsbindex == dmix) &&
+		    (hitbl->mctable[i].smsbindex == smix) &&
+		    (hitbl->mctable[i].valid == 1)) {
+
+			switch (hitbl->mctable[i].mcmode) {
+			case GSW_IGMP_MEMBER_DONT_CARE:
+				if (((hitbl->mctable[i].pmap >> parm->nPortId) & 0x1) == 1) {
+					hitbl->mctable[i].pmap &= ~(1 << parm->nPortId);
+
+					if (hpctbl->pce_sub_tbl.iplsbtcnt[dlix] > 0) {
+						ipdslsb_tblidx_del(&hpctbl->pce_sub_tbl, dlix);
+
+						if (hpctbl->pce_sub_tbl.iplsbtcnt[dlix] == 0) {
+							/* Delet the sub table */
+							ip_dasa_lsb_tbl_del(cdev,
+									    &hpctbl->pce_sub_tbl, dlix);
+						}
+					}
+
+					/* Delet the sub table */
+					if (hpctbl->pce_sub_tbl.ipmsbtcnt[dmix] > 0) {
+						ipdsmsb_tblidx_del(&hpctbl->pce_sub_tbl, dmix);
+
+						if (hpctbl->pce_sub_tbl.ipmsbtcnt[dmix] == 0) {
+							if (parm->eIPVersion == GSW_IP_SELECT_IPV6)
+								ip_dasa_msb_tbl_del(cdev,
+										    &hpctbl->pce_sub_tbl, dmix);
+						}
+					}
+
+					/* Check the port map status */
+					/* Delet the entry from Multicast sw Table */
+					if (hitbl->mctable[i].pmap == 0)
+						hitbl->mctable[i].valid = 0;
+
+					MATCH = 1;
+				}
+
+				break;
+
+			case GSW_IGMP_MEMBER_INCLUDE:
+			case GSW_IGMP_MEMBER_EXCLUDE:
+				if (((hitbl->mctable[i].pmap >> parm->nPortId) & 0x1) == 1) {
+					hitbl->mctable[i].pmap &= ~(1 << parm->nPortId);
+
+					if (hpctbl->pce_sub_tbl.iplsbtcnt[dlix] > 0) {
+						ipdslsb_tblidx_del(&hpctbl->pce_sub_tbl, dlix);
+
+						/* Delet the sub table */
+						if (hpctbl->pce_sub_tbl.iplsbtcnt[dlix] == 0) {
+							ip_dasa_lsb_tbl_del(cdev,
+									    &hpctbl->pce_sub_tbl, dlix);
+						}
+					}
+
+					if (hpctbl->pce_sub_tbl.ipmsbtcnt[dmix] > 0) {
+						ipdsmsb_tblidx_del(&hpctbl->pce_sub_tbl, dmix);
+
+						/* Delet the sub table */
+						if (hpctbl->pce_sub_tbl.ipmsbtcnt[dmix] == 0) {
+							ip_dasa_msb_tbl_del(cdev,
+									    &hpctbl->pce_sub_tbl, dmix);
+						}
+					}
+
+					if (hpctbl->pce_sub_tbl.iplsbtcnt[slix] > 0) {
+						ipdslsb_tblidx_del(&hpctbl->pce_sub_tbl, slix);
+
+						/* Delet the sub table */
+						if (hpctbl->pce_sub_tbl.iplsbtcnt[slix] == 0) {
+							ip_dasa_lsb_tbl_del(cdev,
+									    &hpctbl->pce_sub_tbl, slix);
+						}
+					}
+
+					if (hpctbl->pce_sub_tbl.ipmsbtcnt[smix] > 0) {
+						ipdsmsb_tblidx_del(&hpctbl->pce_sub_tbl, smix);
+
+						/* Delet the sub table */
+						if (hpctbl->pce_sub_tbl.ipmsbtcnt[smix] == 0) {
+							ip_dasa_msb_tbl_del(cdev,
+									    &hpctbl->pce_sub_tbl, smix);
+						}
+					}
+
+					/* Check the port map status */
+					/* Delet the entry from Multicast sw Table */
+					if (hitbl->mctable[i].pmap == 0)
+						hitbl->mctable[i].valid = 0;
+
+					MATCH = 1;
+
+					if (parm->eModeMember == GSW_IGMP_MEMBER_EXCLUDE) {
+						for (j = 0; j < gswdev->iflag.itblsize; j++) {
+							if ((hitbl->mctable[j].dlsbindex == dlix) &&
+							    (hitbl->mctable[j].slsbindex == 0x7F) &&
+							    (hitbl->mctable[j].dmsbindex == dmix) &&
+							    (hitbl->mctable[j].smsbindex == 0x7F) &&
+							    (hitbl->mctable[j].valid == 1)) {
+								if (((hitbl->mctable[j].pmap >> parm->nPortId) & 0x1) == 1) {
+									hitbl->mctable[j].pmap &= ~(1 << parm->nPortId);
+
+									if (hpctbl->pce_sub_tbl.iplsbtcnt[dlix] > 0) {
+										ipdslsb_tblidx_del(&hpctbl->pce_sub_tbl, dlix);
+
+										if (hpctbl->pce_sub_tbl.iplsbtcnt[dlix] == 0) {
+											/* Delet the sub table */
+											ip_dasa_lsb_tbl_del(cdev,
+													    &hpctbl->pce_sub_tbl, dlix);
+										}
+									}
+
+									if (hpctbl->pce_sub_tbl.ipmsbtcnt[dmix] > 0) {
+										ipdsmsb_tblidx_del(&hpctbl->pce_sub_tbl, dmix);
+
+										if (hpctbl->pce_sub_tbl.ipmsbtcnt[dmix] == 0) {
+											/* Delet the sub table */
+											ip_dasa_msb_tbl_del(cdev,
+													    &hpctbl->pce_sub_tbl, dmix);
+										}
+									}
+
+									/* Check the port map status */
+									if (hitbl->mctable[j].pmap == 0) {
+										/* Delet the entry from Multicast sw Table */
+										hitbl->mctable[j].valid = 0;
+										hitbl->mctable[i].valid = 0;
+									}
+
+									memset(&ptdata, 0, sizeof(pctbl_prog_t));
+									ptdata.table = PCE_MULTICAST_SW_INDEX;
+									ptdata.pcindex = j;
+									ptdata.key[1] = ((0x7F << 8) | 0x7F);
+									ptdata.key[0] = ((hitbl->mctable[j].dmsbindex << 8)
+											 | (hitbl->mctable[i].dlsbindex));
+									ptdata.val[0] = hitbl->mctable[j].pmap;
+									ptdata.valid = hitbl->mctable[j].valid;
+									gsw_pce_table_write(cdev, &ptdata);
+								}
+							}
+						}
+					}
+				}
+
+				break;
+			}
+
+			if (MATCH == 1) {
+				memset(&ptdata, 0, sizeof(pctbl_prog_t));
+				ptdata.table = PCE_MULTICAST_SW_INDEX;
+				ptdata.pcindex = i;
+				ptdata.key[1] = ((hitbl->mctable[i].smsbindex << 8)
+						 | (hitbl->mctable[i].slsbindex));
+				ptdata.key[0] = ((hitbl->mctable[i].dmsbindex << 8)
+						 | (hitbl->mctable[i].dlsbindex));
+				ptdata.val[0] = hitbl->mctable[i].pmap;
+				ptdata.valid = hitbl->mctable[i].valid;
+				gsw_pce_table_write(cdev, &ptdata);
+			}
+		}
+	}
+
+	if (MATCH == 0)
+		pr_err("The GIP/SIP not found\n");
+
+	return GSW_statusOk;
+}
+#endif /*CONFIG_LTQ_MULTICAST */
+#if	((defined(CONFIG_LTQ_STP) && CONFIG_LTQ_STP) ||  (defined(CONFIG_LTQ_8021X) && CONFIG_LTQ_8021X))
+
+/* Function: Internal function to program the registers */
+/* when 802.1x and STP API are called. */
+/* Description: Referene the matrix table to program the  */
+/* LRNLIM, PSTATE and PEN bit*/
+/* according to the Software architecture spec design.*/
+static void set_port_state(void *cdev, u32 pid, u32 stpstate, u32 st8021)
+{
+	pctbl_prog_t tbl_prog_brdgeport_ingress;
+	pctbl_prog_t tbl_prog_brdgeport_egress;
+	u16 State;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 i;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return;
+	}
+
+	for (i = 0; i < sizeof(pstpstate) / sizeof(pstpstate_t); i++) {
+		pstpstate_t *pststate = &pstpstate[i];
+
+		if ((pststate->psstate == stpstate) &&
+		    (pststate->ps8021x == st8021)) {
+			if (IS_VRSN_NOT_31(gswdev->gipver)) {
+				gswdev->pconfig[pid].penable = pststate->pen_reg;
+				gswdev->pconfig[pid].ptstate = pststate->pstate_reg;
+
+				/* Learning Limit */
+				if (pststate->lrnlim == 0) {
+					gsw_w32(cdev, (PCE_PCTRL_1_LRNLIM_OFFSET + (0xA * pid)),
+						PCE_PCTRL_1_LRNLIM_SHIFT, PCE_PCTRL_1_LRNLIM_SIZE, 0);
+				} else {
+					gsw_w32(cdev, (PCE_PCTRL_1_LRNLIM_OFFSET + (0xA * pid)),
+						PCE_PCTRL_1_LRNLIM_SHIFT, PCE_PCTRL_1_LRNLIM_SIZE,
+						gswdev->pconfig[pid].llimit);
+				}
+
+				/* Port State */
+				gsw_w32(cdev, (PCE_PCTRL_0_PSTATE_OFFSET + (0xA * pid)),
+					PCE_PCTRL_0_PSTATE_SHIFT, PCE_PCTRL_0_PSTATE_SIZE,
+					gswdev->pconfig[pid].ptstate);
+				/* Port Enable */
+				gsw_w32(cdev, (SDMA_PCTRL_PEN_OFFSET + (0xA * pid)),
+					SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE,
+					gswdev->pconfig[pid].penable);
+			}
+
+			if (IS_VRSN_31(gswdev->gipver)) {
+				/*Same bridge port idx for ingress and egress bridge port configuration*/
+				memset(&tbl_prog_brdgeport_ingress, 0, sizeof(pctbl_prog_t));
+				tbl_prog_brdgeport_ingress.table = PCE_IGBGP_INDEX;
+
+				CLEAR_U16(tbl_prog_brdgeport_ingress.pcindex);
+				/*Table Entry address (Bridge port ingress Table index) Bit 7:0 in PCE_TBL_ADDR*/
+				tbl_prog_brdgeport_ingress.pcindex |= (pid & 0x7F);
+
+				memset(&tbl_prog_brdgeport_egress, 0, sizeof(pctbl_prog_t));
+				tbl_prog_brdgeport_egress.table = PCE_EGBGP_INDEX;
+				CLEAR_U16(tbl_prog_brdgeport_egress.pcindex);
+				/*Table Entry address (Bridge port egress Table index) Bit 7:0 in PCE_TBL_ADDR*/
+				tbl_prog_brdgeport_egress.pcindex |= (pid & 0x7F);
+				/*Address-based read for ingress bridge port configuration*/
+				gsw_pce_table_read(cdev, &tbl_prog_brdgeport_ingress);
+
+				/*Address-based read for egress bridge port configuration*/
+				gsw_pce_table_read(cdev, &tbl_prog_brdgeport_egress);
+
+				/* Learning Limit */
+				if (pststate->lrnlim == 0) {
+					/*Disable learning and set learning limit to zero*/
+					tbl_prog_brdgeport_ingress.val[0] |= (1 << 15);
+				} else {
+					/*Enable learning and set learning limit to given value*/
+					tbl_prog_brdgeport_ingress.val[0] &= ~(1 << 15);
+				}
+
+				if (pststate->psstate == GSW_STP_PORT_STATE_DISABLE)
+					State = PORT_STATE_DISABLE;
+				else
+					State = pststate->pstate_reg;
+
+				/*VAL 0 Reg 2:0 STP state ingress/egress*/
+				tbl_prog_brdgeport_ingress.val[0] &= ~0x7;
+				tbl_prog_brdgeport_egress.val[0]  &= ~0x7;
+				tbl_prog_brdgeport_ingress.val[0] |= (State & 0x7);
+				tbl_prog_brdgeport_egress.val[0]  |= (State & 0x7);
+
+				tbl_prog_brdgeport_ingress.table = PCE_IGBGP_INDEX;
+				CLEAR_U16(tbl_prog_brdgeport_ingress.pcindex);
+				/*Table Entry address (Bridge port ingress Table index) Bit 7:0 in PCE_TBL_ADDR*/
+				tbl_prog_brdgeport_ingress.pcindex |= (pid & 0x7F);
+
+				tbl_prog_brdgeport_egress.table = PCE_EGBGP_INDEX;
+				CLEAR_U16(tbl_prog_brdgeport_egress.pcindex);
+				/*Table Entry address (Bridge port egress Table index) Bit 7:0 in PCE_TBL_ADDR*/
+				tbl_prog_brdgeport_egress.pcindex |= (pid & 0x7F);
+
+				/*Address-based write for ingress bridge port configuration*/
+				gsw_pce_table_write(cdev, &tbl_prog_brdgeport_ingress);
+				/*Address-based write for egress bridge port configuration*/
+				gsw_pce_table_write(cdev, &tbl_prog_brdgeport_egress);
+			}
+		}
+	}
+}
+#endif /* CONFIG_LTQ_STP / CONFIG_LTQ_8021X */
+#if defined(CONFIG_LTQ_QOS) && CONFIG_LTQ_QOS
+
+/* Function: Internal function to calculate the mrate when */
+/* Shaper and Meter API is called.*/
+/*  Description: Calculate the mrate by input Ibs, Exp and Mant.*/
+/* The algorithm designed based on software architecture spec.*/
+static u32 mratecalc(u32 ibsid, u32 expont, u32 mants)
+{
+	static const u16 ibs_table[] = {8 * 8, 32 * 8, 64 * 8, 96 * 8};
+	u16 ibs;
+	u32 mrate = 0;
+
+	if ((ibsid == 0) && (expont == 0) && (mants == 0))
+		return 0;
+
+	ibs = ibs_table[ibsid];
+
+	if (mants)
+		mrate = ((ibs * 25000) >> expont) / mants;
+
+	return mrate;
+}
+
+/* Function: Internal function to calculate the Token when */
+/* Shaper and Meter API is called.*/
+/*  Description: Calculate the Token by input mrate, Ibs, Exp and Mant.*/
+/* The algorithm designed based on software architecture spec. */
+static int calc_mtoken(u32 mrate, u32 *ibsid, u32 *expont, u32 *mants)
+{
+	static const u16 ibs_table[] = {8 * 8, 32 * 8, 64 * 8, 96 * 8};
+	u8 i;
+
+	for (i = 3; i >= 0; i--) {
+		u32 exp;
+		u16 ibs = ibs_table[i];
+
+		/* target is to get the biggest mantissa value */
+		/* that can be used for the 10-Bit register */
+		for (exp = 0; exp < 16; exp++) {
+			u32 mant = ((ibs * 25000) >> exp) / mrate;
+
+			if (mant < (1 << 10))  {
+				*ibsid = i;
+				*expont = exp;
+				*mants = mant;
+				return 0;
+			}
+		}
+	}
+}
+
+static u32 mratecalc_3_1(u32 ibsid, u32 expont, u32 mants)
+{
+	u32 mrate = 0;
+
+	if ((ibsid == 0) && (expont == 0) && (mants == 0))
+		return 0;
+
+	if (mants)
+		mrate = (ibsid * 200000) / ((mants + 1) << expont);
+
+	return mrate;
+}
+
+
+#if defined(WIN_PC_MODE) && WIN_PC_MODE
+static __inline int fls(int input)
+{
+	u32 pos, ifzero = ~0;
+	__asm__("bsr %1, %0\n\t"
+		"cmovz %2, %0"
+		: "=r"(pos)
+		: "rm"(input)
+		, "rm"(ifzero));
+	return (int)(pos + 1);
+}
+#endif
+
+static int calc_mtoken_3_1(u32 mrate, u32 *ibsid, u32 *expont, u32 *mants)
+{
+	u32 temp, exp_val, exp, mant, ibs;
+
+	temp = 100000000 / mrate;
+	exp_val = temp >> 9;
+	exp = (u32)fls((int)exp_val);
+	mant = exp ? 499 : (temp & 0x01FF);
+	ibs = ((mant + 1) << exp) * mrate / 200000;
+
+	*ibsid = ibs;
+	*expont = exp;
+	*mants = mant;
+
+	return 0;
+}
+
+#endif /*CONFIG_LTQ_QOS */
+#if defined(CONFIG_LTQ_VLAN) && CONFIG_LTQ_VLAN
+static void reset_vlan_sw_table(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u16 i;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return;
+	}
+
+	for (i = 0; i < gswdev->avlantsz /* VLAN_ACTIVE_TABLE_SIZE */; i++)
+		memset(&gswdev->avtable[i], 0, sizeof(avlan_tbl_t));
+}
+#endif /*CONFIG_LTQ_VLAN*/
+
+#if defined(CONFIG_LTQ_VLAN) && CONFIG_LTQ_VLAN
+u8 find_active_vlan_index(void *cdev, u16 vid)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 i, index = 0xFF;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	for (i = 0; i < gswdev->avlantsz; i++) {
+		if ((vid == gswdev->avtable[i].vid)
+		    && (gswdev->avtable[i].valid == 1)) {
+			index = i;
+			break;
+		}
+	}
+
+	return index;
+}
+
+u8 fempty_avlan_index_table(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 i, index = 0xFF;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	for (i = 1; i < gswdev->avlantsz; i += 1) {
+		if (gswdev->avtable[i].valid == 0) {
+			index = i;
+			break;
+		}
+	}
+
+	if ((index == 0xFF) &&
+	    (gswdev->avtable[0].valid == 0))
+		return 0;
+
+	return index;
+}
+
+static void vlan_entry_set(void *cdev, u8 index,
+			   avlan_tbl_t *avlan_entry)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return;
+	}
+
+	gswdev->avtable[index].valid = avlan_entry->valid;
+	gswdev->avtable[index].reserved	= avlan_entry->reserved;
+	gswdev->avtable[index].vid = avlan_entry->vid;
+	gswdev->avtable[index].fid = avlan_entry->fid;
+	gswdev->avtable[index].pm = avlan_entry->pm;
+	gswdev->avtable[index].tm = avlan_entry->tm;
+}
+
+static void get_vlan_sw_table(void *cdev, u8 pcindex,
+			      avlan_tbl_t *avlan_entry)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return;
+	}
+
+	avlan_entry->valid = gswdev->avtable[pcindex].valid;
+	avlan_entry->reserved = gswdev->avtable[pcindex].reserved;
+	avlan_entry->vid = gswdev->avtable[pcindex].vid;
+	avlan_entry->fid = gswdev->avtable[pcindex].fid;
+	avlan_entry->pm = gswdev->avtable[pcindex].pm;
+	avlan_entry->tm = gswdev->avtable[pcindex].tm;
+
+}
+#endif /* CONFIG_LTQ_VLAN */
+
+
+static void get_gsw_hw_cap(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 reg_val;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return;
+	}
+
+	gsw_r32(cdev, ETHSW_VERSION_REV_ID_OFFSET,
+		ETHSW_VERSION_REV_ID_SHIFT, 16, &reg_val);
+	/*GET GSWIP version*/
+	gswdev->gipver = reg_val;
+
+	/* Total number of ports*/
+	gsw_r32(cdev, ETHSW_CAP_1_PPORTS_OFFSET,
+		ETHSW_CAP_1_PPORTS_SHIFT,
+		ETHSW_CAP_1_PPORTS_SIZE, &reg_val);
+	gswdev->pnum = reg_val;
+
+	/* Total number of ports including vitual ports*/
+	gsw_r32(cdev, ETHSW_CAP_1_VPORTS_OFFSET,
+		ETHSW_CAP_1_VPORTS_SHIFT,
+		ETHSW_CAP_1_VPORTS_SIZE, &reg_val);
+	gswdev->tpnum = reg_val + gswdev->pnum;
+
+	gsw_r32(cdev, ETHSW_CAP_1_QUEUE_OFFSET,
+		ETHSW_CAP_1_QUEUE_SHIFT,
+		ETHSW_CAP_1_QUEUE_SIZE, &reg_val);
+	gswdev->num_of_queues = reg_val;
+
+	gsw_r32(cdev, ETHSW_CAP_3_METERS_OFFSET,
+		ETHSW_CAP_3_METERS_SHIFT,
+		ETHSW_CAP_3_METERS_SIZE, &reg_val);
+	gswdev->num_of_meters = reg_val;
+
+	gsw_r32(cdev, ETHSW_CAP_3_SHAPERS_OFFSET,
+		ETHSW_CAP_3_SHAPERS_SHIFT,
+		ETHSW_CAP_3_SHAPERS_SIZE, &reg_val);
+	gswdev->num_of_shapers = reg_val;
+
+	gsw_r32(cdev, ETHSW_CAP_4_PPPOE_OFFSET,
+		ETHSW_CAP_4_PPPOE_SHIFT,
+		ETHSW_CAP_4_PPPOE_SIZE, &reg_val);
+	gswdev->num_of_pppoe = reg_val;
+
+
+	gsw_r32(cdev, ETHSW_CAP_5_IPPLEN_OFFSET,
+		ETHSW_CAP_5_IPPLEN_SHIFT,
+		ETHSW_CAP_5_IPPLEN_SIZE, &reg_val);
+	gswdev->ip_pkt_lnt_size = reg_val;
+
+
+	gsw_r32(cdev, ETHSW_CAP_5_PROT_OFFSET,
+		ETHSW_CAP_5_PROT_SHIFT,
+		ETHSW_CAP_5_PROT_SIZE, &reg_val);
+	gswdev->prot_table_size = reg_val;
+
+	gsw_r32(cdev, ETHSW_CAP_6_MACDASA_OFFSET,
+		ETHSW_CAP_6_MACDASA_SHIFT,
+		ETHSW_CAP_6_MACDASA_SIZE, &reg_val);
+	gswdev->mac_dasa_table_size = reg_val;
+
+	gsw_r32(cdev, ETHSW_CAP_6_APPL_OFFSET,
+		ETHSW_CAP_6_APPL_SHIFT,
+		ETHSW_CAP_6_APPL_SIZE, &reg_val);
+	gswdev->app_table_size = reg_val;
+
+
+	gsw_r32(cdev, ETHSW_CAP_7_IPDASAM_OFFSET,
+		ETHSW_CAP_7_IPDASAM_SHIFT,
+		ETHSW_CAP_7_IPDASAM_SIZE, &reg_val);
+	gswdev->idsmtblsize = reg_val;
+
+
+	gsw_r32(cdev, ETHSW_CAP_7_IPDASAL_OFFSET,
+		ETHSW_CAP_7_IPDASAL_SHIFT,
+		ETHSW_CAP_7_IPDASAL_SIZE, &reg_val);
+	gswdev->idsltblsize = reg_val;
+
+
+	gsw_r32(cdev, ETHSW_CAP_8_MCAST_OFFSET,
+		ETHSW_CAP_8_MCAST_SHIFT,
+		ETHSW_CAP_8_MCAST_SIZE, &reg_val);
+	gswdev->mctblsize = reg_val;
+
+
+	gsw_r32(cdev, ETHSW_CAP_9_FLAGG_OFFSET,
+		ETHSW_CAP_9_FLAGG_SHIFT,
+		ETHSW_CAP_9_FLAGG_SIZE, &reg_val);
+	gswdev->tftblsize = reg_val;
+
+
+	gsw_r32(cdev, ETHSW_CAP_10_MACBT_OFFSET,
+		ETHSW_CAP_10_MACBT_SHIFT,
+		ETHSW_CAP_10_MACBT_SIZE, &reg_val);
+	gswdev->mactblsize = reg_val;
+
+
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		gsw_r32(cdev, ETHSW_CAP_4_VLAN_OFFSET,
+			ETHSW_CAP_4_VLAN_SHIFT,
+			ETHSW_CAP_4_VLAN_SIZE, &reg_val);
+		gswdev->avlantsz = reg_val;
+
+		gsw_r32(cdev, ETHSW_CAP_14_SMAC_OFFSET,
+			ETHSW_CAP_14_SMAC_SHIFT,
+			ETHSW_CAP_14_SMAC_SIZE, &reg_val);
+		gswdev->num_of_rt_smac = (1 << reg_val);
+		gsw_r32(cdev, ETHSW_CAP_14_DMAC_OFFSET,
+			ETHSW_CAP_14_DMAC_SHIFT,
+			ETHSW_CAP_14_DMAC_SIZE, &reg_val);
+		gswdev->num_of_rt_dmac = (1 << reg_val);
+		gsw_r32(cdev, ETHSW_CAP_14_PPPoE_OFFSET,
+			ETHSW_CAP_14_PPPoE_SHIFT,
+			ETHSW_CAP_14_PPPoE_SIZE, &reg_val);
+		gswdev->num_of_rt_ppoe = (1 << reg_val);
+		gsw_r32(cdev, ETHSW_CAP_14_NAT_OFFSET,
+			ETHSW_CAP_14_NAT_SHIFT,
+			ETHSW_CAP_14_NAT_SIZE, &reg_val);
+		gswdev->num_of_rt_nat = (1 << reg_val);
+		gsw_r32(cdev, ETHSW_CAP_15_MTU_OFFSET,
+			ETHSW_CAP_15_MTU_SHIFT,
+			ETHSW_CAP_15_MTU_SIZE, &reg_val);
+		gswdev->num_of_rt_mtu = (1 << reg_val);
+		gsw_r32(cdev, ETHSW_CAP_15_TUNNEL_OFFSET,
+			ETHSW_CAP_15_TUNNEL_SHIFT,
+			ETHSW_CAP_15_TUNNEL_SIZE, &reg_val);
+		gswdev->num_of_rt_tunnel = (1 << reg_val);
+		gsw_r32(cdev, ETHSW_CAP_15_RTP_OFFSET,
+			ETHSW_CAP_15_RTP_SHIFT,
+			ETHSW_CAP_15_RTP_SIZE, &reg_val);
+		gswdev->num_of_rt_rtp = (1 << reg_val);
+		gswdev->cport = GSW_3X_SOC_CPU_PORT;
+	}
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		gsw_r32(cdev, ETHSW_CAP_13_PMAC_OFFSET,
+			ETHSW_CAP_13_PMAC_SHIFT,
+			ETHSW_CAP_13_PMAC_SIZE, &reg_val);
+		gswdev->num_of_pmac = reg_val;
+
+		gsw_r32(cdev, ETHSW_CAP_13_PAYLOAD_OFFSET,
+			ETHSW_CAP_13_PAYLOAD_SHIFT,
+			ETHSW_CAP_13_PAYLOAD_SIZE, &reg_val);
+		gswdev->pdtblsize = (1 << reg_val);
+
+		gsw_r32(cdev, ETHSW_CAP_13_INTRMON_OFFSET,
+			ETHSW_CAP_13_INTRMON_SHIFT,
+			ETHSW_CAP_13_INTRMON_SIZE, &reg_val);
+		gswdev->num_of_ifrmon = (1 << reg_val);
+
+		gsw_r32(cdev, ETHSW_CAP_13_EVLAN_OFFSET,
+			ETHSW_CAP_13_EVLAN_SHIFT,
+			ETHSW_CAP_13_EVLAN_SIZE, &reg_val);
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0)
+			gswdev->num_of_egvlan = (1 << reg_val);
+
+		if (IS_VRSN_31(gswdev->gipver))
+			gswdev->num_of_extendvlan = (1 << reg_val);
+
+		gswdev->cport = GSW_3X_SOC_CPU_PORT;
+
+	} else {
+		gswdev->cport = GSW_2X_SOC_CPU_PORT;
+	}
+
+	/*Applicable only for 3.1*/
+	if (gswdev->gipver >= LTQ_GSWIP_3_1) {
+		gsw_r32(cdev, ETHSW_CAP_16_VLANMAP_OFFSET,
+			ETHSW_CAP_16_VLANMAP_SHIFT,
+			ETHSW_CAP_16_VLANMAP_SIZE, &reg_val);
+		gswdev->num_of_vlanfilter = 1 << reg_val;
+
+		gsw_r32(cdev, ETHSW_CAP_16_MCASTHW_OFFSET,
+			ETHSW_CAP_16_MCASTHW_SHIFT,
+			ETHSW_CAP_16_MCASTHW_SIZE, &reg_val);
+		gswdev->mcsthw_snoop = reg_val;
+
+		gsw_r32(cdev, ETHSW_CAP_17_BRG_OFFSET,
+			ETHSW_CAP_17_BRG_SHIFT,
+			ETHSW_CAP_17_BRG_SIZE, &reg_val);
+		gswdev->num_of_bridge = 1 << reg_val;
+
+
+		gsw_r32(cdev, ETHSW_CAP_17_BRGPT_OFFSET,
+			ETHSW_CAP_17_BRGPT_SHIFT,
+			ETHSW_CAP_17_BRGPT_SIZE, &reg_val);
+		gswdev->num_of_bridge_port = 1 << reg_val;
+
+
+		gsw_r32(cdev, ETHSW_CAP_17_PMAP_OFFSET,
+			ETHSW_CAP_17_PMAP_SHIFT,
+			ETHSW_CAP_17_PMAP_SIZE, &reg_val);
+		gswdev->num_of_pmapper = 1 << reg_val;
+
+		gsw_r32(cdev, ETHSW_CAP_18_CTP_OFFSET,
+			ETHSW_CAP_18_CTP_SHIFT,
+			ETHSW_CAP_18_CTP_SIZE, &reg_val);
+		gswdev->num_of_ctp = (reg_val & 0xFFFF);
+	}
+
+	/*load PCE parameters*/
+	gswdev->pce_tbl_reg.key = gsw_pce_tbl_reg_key;
+	gswdev->pce_tbl_reg.mask = gsw_pce_tbl_reg_mask;
+	gswdev->pce_tbl_reg.value = gsw_pce_tbl_reg_value;
+
+	if (gswdev->gipver == LTQ_GSWIP_3_1) {
+		gswdev->num_of_pce_tbl = ARRAY_SIZE(gsw_pce_tbl_info_31);
+		gswdev->pce_tbl_info = gsw_pce_tbl_info_31;
+	} else if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		gswdev->num_of_pce_tbl = ARRAY_SIZE(gsw_pce_tbl_info_30);
+		gswdev->pce_tbl_info = gsw_pce_tbl_info_30;
+	} else {
+		gswdev->num_of_pce_tbl = ARRAY_SIZE(gsw_pce_tbl_info_22);
+		gswdev->pce_tbl_info = gsw_pce_tbl_info_22;
+	}
+
+	if (1) {
+		if (gswdev->gipver == LTQ_GSWIP_3_0)
+			printk("\nGSWIP 3.0 HardWare Capability\n");
+		else if (gswdev->gipver == LTQ_GSWIP_3_1)
+			printk("\nGSWIP 3.1 HardWare Capability\n");
+		else
+			printk("\nGSWIP 2.2 HardWare Capability\n");
+
+		printk("-----------------------------\n\n");
+		printk("Switch Version ID                =  0x%x\n", gswdev->gipver);
+		printk("\n");
+		printk("Number of logical port           =  %d\n", gswdev->pnum);
+		printk("Number of CTP Port               =  %d\n", gswdev->num_of_ctp);
+		printk("Number of Bridge                 =  %d\n", gswdev->num_of_bridge);
+		printk("Number of Bridge Port            =  %d\n", gswdev->num_of_bridge_port);
+		printk("Number of P-Mapper               =  %d\n", gswdev->num_of_pmapper);
+		printk("Number of queues                 =  %d\n", gswdev->num_of_queues);
+		printk("Number of meter instance         =  %d\n", gswdev->num_of_meters);
+		printk("Number of shapers                =  %d\n", gswdev->num_of_shapers);
+		printk("Number of PMAC                   =  %d\n", gswdev->num_of_pmac);
+		printk("Number of CPU PORT               =  %d\n", gswdev->cport);
+		printk("\n");
+		printk("PPPOE table size                 =  %d\n", gswdev->num_of_pppoe);
+		printk("IP packet length table size      =  %d\n", gswdev->ip_pkt_lnt_size);
+		printk("Protocol table size              =  %d\n", gswdev->prot_table_size);
+		printk("MAC DA/SA table size             =  %d\n", gswdev->mac_dasa_table_size);
+		printk("Application table size           =  %d\n", gswdev->app_table_size);
+		printk("IP DA/SA MSB table size          =  %d\n", gswdev->idsmtblsize);
+		printk("IP DA/SA LSB table size          =  %d\n", gswdev->idsltblsize);
+		printk("Multicast table size             =  %d\n", gswdev->mctblsize);
+		printk("Multicast Hw Snoop               =  %d\n", gswdev->mcsthw_snoop);
+		printk("TFLOW table size                 =  %d\n", gswdev->tftblsize);
+		printk("MAC bridge table size            =  %d\n", gswdev->mactblsize);
+		printk("TFLOW RMON counter table Size    =  %d\n", gswdev->num_of_ifrmon);
+		printk("Payload Table Size               =  %d\n", gswdev->pdtblsize);
+		printk("Extend VLAN Table Size table     =  %d\n", gswdev->num_of_extendvlan);
+		printk("Number of VlanFilter table Size  =  %d\n\n", gswdev->num_of_vlanfilter);
+	}
+
+}
+
+#if defined(WIN_PC_MODE) && WIN_PC_MODE
+int gsw_r_init()
+{
+	return GSW_statusOk;
+}
+#endif
+
+#if defined(CONFIG_USE_EMULATOR) && CONFIG_USE_EMULATOR
+static GSW_return_t emulator_config_coreinit_gswip3_0(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 j = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (gswdev->sdev == LTQ_FLOW_DEV_INT_R)
+#ifdef __KERNEL__
+			gsw_r_init();
+
+#endif
+		/* Set Auto-Polling of connected PHYs - For all ports */
+		gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
+			GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x0);
+	} else {
+		/* Set Auto-Polling of connected PHYs - For all ports */
+		gsw_w32(cdev, (MDC_CFG_0_PEN_0_OFFSET
+			       + GSW_TREG_OFFSET),
+			MDC_CFG_0_PEN_0_SHIFT, 6, 0x0);
+	}
+
+	for (j = 0; j < gswdev->pnum - 1; j++) {
+		u32 reg_value;
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			gsw_w32(cdev,
+				(FDMA_PCTRL_EN_OFFSET + (j * 0x6)),
+				FDMA_PCTRL_EN_SHIFT,
+				FDMA_PCTRL_EN_SIZE, 1);
+			gsw_w32(cdev,
+				(SDMA_PCTRL_PEN_OFFSET + (j * 0x6)),
+				SDMA_PCTRL_PEN_SHIFT,
+				SDMA_PCTRL_PEN_SIZE, 1);
+			gsw_w32(cdev,
+				(BM_PCFG_CNTEN_OFFSET + (j * 2)),
+				BM_PCFG_CNTEN_SHIFT,
+				BM_PCFG_CNTEN_SIZE, 1);
+			gsw_w32(cdev,
+				(MAC_CTRL_0_FDUP_OFFSET + (0xC * j)),
+				MAC_CTRL_0_FDUP_SHIFT,
+				MAC_CTRL_0_FDUP_SIZE, 1);
+			gsw_w32(cdev,
+				(MAC_CTRL_0_GMII_OFFSET + (0xC * j)),
+				MAC_CTRL_0_GMII_SHIFT,
+				MAC_CTRL_0_GMII_SIZE, 2);
+
+			gsw_w32(cdev,
+				((GSWT_PHY_ADDR_1_SPEED_OFFSET + (j * 4))
+				 + GSW30_TOP_OFFSET),
+				GSWT_PHY_ADDR_1_SPEED_SHIFT,
+				GSWT_PHY_ADDR_1_SPEED_SIZE, 2);
+			gsw_w32(cdev,
+				((GSWT_PHY_ADDR_1_FDUP_OFFSET
+				  + (j * 4))
+				 + GSW30_TOP_OFFSET),
+				GSWT_PHY_ADDR_1_FDUP_SHIFT,
+				GSWT_PHY_ADDR_1_FDUP_SIZE, 1);
+			gsw_w32(cdev,
+				((GSWT_PHY_ADDR_1_LNKST_OFFSET
+				  + (j * 4))
+				 + GSW30_TOP_OFFSET),
+				GSWT_PHY_ADDR_1_LNKST_SHIFT,
+				GSWT_PHY_ADDR_1_LNKST_SIZE, 1);
+			gsw_r32(cdev,
+				((GSWT_PHY_ADDR_1_LNKST_OFFSET
+				  + (j * 4))
+				 + GSW30_TOP_OFFSET),
+				0, 16, &reg_value);
+		}
+	}
+
+	return GSW_statusOk;
+}
+#endif
+
+/*This API is used for GSWIP 3.0 and Lower*/
+static GSW_return_t set_srcmac_pauseframe(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	/* Set the the source MAC register of pause frame gswip 3.0 */
+	gsw_w32(cdev, MAC_PFSA_0_PFAD_OFFSET,
+		MAC_PFSA_0_PFAD_SHIFT,
+		MAC_PFSA_0_PFAD_SIZE, 0x0000);
+	gsw_w32(cdev, MAC_PFSA_1_PFAD_OFFSET,
+		MAC_PFSA_1_PFAD_SHIFT,
+		MAC_PFSA_1_PFAD_SIZE, 0x9600);
+	gsw_w32(cdev, MAC_PFSA_2_PFAD_OFFSET,
+		MAC_PFSA_2_PFAD_SHIFT,
+		MAC_PFSA_2_PFAD_SIZE, 0xAC9A);
+	return GSW_statusOk;
+}
+
+static GSW_return_t mdio_init_gswip3_0(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	/* Configure the MDIO Clock 97.6 Khz 3.0*/
+	gsw_w32(cdev, (GSWT_MDCCFG_1_FREQ_OFFSET + GSW30_TOP_OFFSET),
+		GSWT_MDCCFG_1_FREQ_SHIFT, GSWT_MDCCFG_1_FREQ_SIZE, 0xFF);
+	gsw_w32(cdev, (GSWT_MDCCFG_1_MCEN_OFFSET + GSW30_TOP_OFFSET),
+		GSWT_MDCCFG_1_MCEN_SHIFT, GSWT_MDCCFG_1_MCEN_SIZE, 1);
+	/* MDIO Hardware Reset */
+	gsw_w32(cdev, (GSWT_MDCCFG_1_RES_OFFSET + GSW30_TOP_OFFSET),
+		GSWT_MDCCFG_1_RES_SHIFT, GSWT_MDCCFG_1_RES_SIZE, 1);
+
+	return GSW_statusOk;
+}
+
+static GSW_return_t mdio_init_gswip2_2(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	/* Configure the MDIO Clock 97.6 Khz 2.2*/
+	gsw_w32(cdev, (MDC_CFG_1_FREQ_OFFSET
+		       + GSW_TREG_OFFSET),
+		MDC_CFG_1_FREQ_SHIFT,
+		MDC_CFG_1_FREQ_SIZE, 0xFF);
+	return GSW_statusOk;
+}
+
+static GSW_return_t legacy_switch_core_init(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 j = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#if defined(CONFIG_LTQ_VLAN) && CONFIG_LTQ_VLAN
+	/** Reset vlan software tableApplicable only for GSWIP 3.0 */
+	reset_vlan_sw_table(cdev);
+#endif /* CONFIG_LTQ_VLAN */
+	ltq_ethsw_port_cfg_init(cdev);
+	/* Set the the source MAC register of pause frame  */
+	set_srcmac_pauseframe(cdev);
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		/**Apllicable only for GSWIP 3.0**/
+#if defined(CONFIG_USE_EMULATOR) && CONFIG_USE_EMULATOR
+		emulator_config_coreinit_gswip3_0(cdev);
+#else
+		mdio_init_gswip3_0(cdev);
+
+		if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+
+#ifdef __KERNEL__
+			gsw_r_init();
+#endif
+			gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
+				GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x1);
+			/*			gsw_w32(cdev, (GSWT_PHY_ADDR_1_LNKST_OFFSET + GSW30_TOP_OFFSET),
+							GSWT_PHY_ADDR_1_LNKST_SHIFT, GSWT_PHY_ADDR_1_LNKST_SIZE, 1);*/
+		} else {
+			gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET
+				       + GSW30_TOP_OFFSET),
+				GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x1e);
+		}
+
+		/* SDMA/FDMA and RMON counter Enable*/
+		for (j = 0; j < gswdev->pnum - 1; j++) {
+			if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				gsw_w32(cdev,
+					(FDMA_PCTRL_EN_OFFSET + (j * 0x6)),
+					FDMA_PCTRL_EN_SHIFT,
+					FDMA_PCTRL_EN_SIZE, 1);
+				gsw_w32(cdev,
+					(SDMA_PCTRL_PEN_OFFSET + (j * 0x6)),
+					SDMA_PCTRL_PEN_SHIFT,
+					SDMA_PCTRL_PEN_SIZE, 1);
+				gsw_w32(cdev,
+					(BM_PCFG_CNTEN_OFFSET + (j * 2)),
+					BM_PCFG_CNTEN_SHIFT,
+					BM_PCFG_CNTEN_SIZE, 1);
+			}
+		}
+
+		for (j = 0; j < gswdev->pnum - 1; j++) {
+			gsw_w32(cdev,
+				((GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_OFFSET
+				  + (4 * j)) + GSW30_TOP_OFFSET),
+				GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_SHIFT,
+				GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_SIZE, 0x3);
+		}
+
+#endif
+	} else {
+		/* Switch Core 2.2 and lower*/
+		mdio_init_gswip2_2(cdev);
+
+		/* EEE auto negotiation overides:  */
+		/*clock disable (ANEG_EEE_0.CLK_STOP_CAPABLE)  */
+		for (j = 0; j < gswdev->pnum - 1; j++) {
+			gsw_w32(cdev,
+				((ANEG_EEE_0_CLK_STOP_CAPABLE_OFFSET + j)
+				 + GSW_TREG_OFFSET),
+				ANEG_EEE_0_CLK_STOP_CAPABLE_SHIFT,
+				ANEG_EEE_0_CLK_STOP_CAPABLE_SIZE, 0x3);
+		}
+	}
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		for (j = 0; j < gswdev->tpnum; j++) {
+			//pr_err("Enable CTP RMON for logical port %d\n",j);
+			gsw_w32(cdev, (BM_PCFG_CNTEN_OFFSET + (j * 2)), BM_PCFG_CNTEN_SHIFT,
+				BM_PCFG_CNTEN_SIZE, 1);
+			gsw_w32(cdev, (BM_RMON_CTRL_BCAST_CNT_OFFSET + (j * 0x2)),
+				BM_RMON_CTRL_BCAST_CNT_SHIFT, BM_RMON_CTRL_BCAST_CNT_SIZE, 1);
+		}
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0 && gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+			gsw_w32(cdev, PCE_TFCR_NUM_NUM_OFFSET, PCE_TFCR_NUM_NUM_SHIFT,
+				PCE_TFCR_NUM_NUM_SIZE, 0x80);
+		}
+	}
+
+	return GSW_statusOk;
+}
+
+static GSW_return_t switch_core_init(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	static GSW_BRIDGE_portConfig_t brdgport_config;
+	static GSW_CTP_portConfig_t ctp_config;
+	static GSW_CTP_portAssignment_t ctp_assign;
+	static pctbl_prog_t tbl_prog_ctpport_ingress;
+	static pctbl_prog_t tbl_prog_ctpport_egress;
+	u32 j = 0, ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+#ifdef __KERNEL__
+
+		/*Default Exvlan and Vlan filter Local table Init*/
+		gswdev->extendvlan_idx.nUsedEntry = 0;
+
+		for (j = 0; j < gswdev->num_of_extendvlan; j++) {
+			gswdev->extendvlan_idx.vlan_idx[j].VlanBlockId = EXVLAN_ENTRY_INVALID;
+			gswdev->extendvlan_idx.vlan_idx[j].IndexInUsageCnt = 0;
+		}
+
+		gswdev->vlanfilter_idx.nUsedEntry = 0;
+
+		for (j = 0; j < gswdev->num_of_vlanfilter; j++) {
+			gswdev->vlanfilter_idx.filter_idx[j].FilterBlockId = VLANFILTER_ENTRY_INVALID;
+			gswdev->vlanfilter_idx.filter_idx[j].IndexInUsageCnt = 0;
+		}
+
+		/**Bridge Settings*/
+		/*Default configuration :Allocate Bridge/FID 0*/
+		gswdev->brdgeconfig_idx[0].IndexInUse = 1;
+		/*Default configuration :Allocate Bridge port 0 and 1*/
+		gswdev->brdgeportconfig_idx[0].IndexInUse = 1;
+		gswdev->brdgeportconfig_idx[1].IndexInUse = 1;
+
+		/*Default configuration :Force Set 0-127 Ingress bridge port mapping
+		  to no Member and with Bridge/Fid 0,
+		  Egress bridge port destination logical port to 0 */
+		memset(&brdgport_config, 0, sizeof(GSW_BRIDGE_portConfig_t));
+		brdgport_config.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_FORCE |
+					GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
+					GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_CTP_MAPPING |
+					GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
+
+		for (j = 0; j < gswdev->num_of_bridge_port; j++) {
+			brdgport_config.nBridgePortId = j;
+			/*initialize the local BP table*/
+			gswdev->brdgeportconfig_idx[j].IngressExVlanBlkId = EXVLAN_ENTRY_INVALID;
+			gswdev->brdgeportconfig_idx[j].EgressExVlanBlkId = EXVLAN_ENTRY_INVALID;
+			gswdev->brdgeportconfig_idx[j].IngressVlanFilterBlkId = VLANFILTER_ENTRY_INVALID;
+			gswdev->brdgeportconfig_idx[j].EgressVlanFilter1BlkId = VLANFILTER_ENTRY_INVALID;
+			gswdev->brdgeportconfig_idx[j].EgressVlanFilter2BlkId = VLANFILTER_ENTRY_INVALID;
+			gswdev->brdgeportconfig_idx[j].BrdgId = 0;
+			gswdev->brdgeportconfig_idx[j].LearningLimit = 0xFF;
+			/*Default STP State is GSW_STP_PORT_STATE_FORWARD
+			  it can be changed using GSW_Stp_PortCfgSet*/
+			gswdev->brdgeportconfig_idx[j].StpState =
+				GSW_STP_PORT_STATE_FORWARD;
+			/*By Default 8021X State is GSW_8021X_PORT_STATE_AUTHORIZED
+			  it can be changed using GSW_8021X_PortCfgSet*/
+			gswdev->brdgeportconfig_idx[j].P8021xState =
+				GSW_8021X_PORT_STATE_AUTHORIZED;
+
+			ret = GSW_BridgePortConfigSet(cdev, &brdgport_config);
+
+			if (ret == GSW_statusErr) {
+				pr_err("%s:%s:%d (GSW_BridgePortConfigSet returns ERROR)\n",
+				       __FILE__, __func__, __LINE__);
+				return GSW_statusErr;
+			}
+		}
+
+		/**Logical Port Assignment Settings*/
+		/*Default Configuration :Allocate and Assign Logical port 0 with CTP 0-PMAC 0*/
+		/*and*/
+		/*Default Configuration :Allocate and Assign Logical port 1 with CTP 1-PMAC 1*/
+		ctp_assign.nNumberOfCtpPort = 1;
+		ctp_assign.eMode = GSW_LOGICAL_PORT_OTHER;
+
+		for (j = 0; j < 2; j++) {
+			gswdev->ctpportconfig_idx[j].IndexInUse = 1;
+			ctp_assign.nFirstCtpPortId = j;
+			ctp_assign.nLogicalPortId = j;
+			ret = GSW_CTP_PortAssignmentSet(cdev, &ctp_assign);
+
+			if (ret == GSW_statusErr) {
+				pr_err("%s:%s:%d (GSW_CTP_PortAssignmentSet returns ERROR)\n",
+				       __FILE__, __func__, __LINE__);
+				return GSW_statusErr;
+			}
+		}
+
+		/*Allocate CTP 287 - user is not allowed to use this CTP port*/
+		/*Default Configuration :Allocate and Assign Logical port 2 to 11 with CTP 287*/
+		gswdev->ctpportconfig_idx[287].IndexInUse = 1;
+		ctp_assign.nFirstCtpPortId = 287;
+		ctp_assign.nNumberOfCtpPort = 1;
+		ctp_assign.eMode = GSW_LOGICAL_PORT_OTHER;
+
+		for (j = 2; j < gswdev->tpnum; j++) {
+			ctp_assign.nLogicalPortId = j;
+			ret = GSW_CTP_PortAssignmentSet(cdev, &ctp_assign);
+
+			if (ret == GSW_statusErr) {
+				pr_err("%s:%s:%d (GSW_CTP_PortAssignmentSet returns ERROR)\n",
+				       __FILE__, __func__, __LINE__);
+				return GSW_statusErr;
+			}
+		}
+
+		/**CTP port Settings*/
+		/*Default configuration :CTP 0 and 1
+		  Assign Bridge port 0  and 1 respectively
+		  and disable bridge bypass*/
+		for (j = 0; j < 2; j++) {
+			/*initialize the local CTP table*/
+			gswdev->ctpportconfig_idx[j].BrdgPortId = j;
+			gswdev->ctpportconfig_idx[j].AssociatedLogicalPort = j;
+			gswdev->ctpportconfig_idx[j].IngressExVlanIgmpBlkId = EXVLAN_ENTRY_INVALID;
+			gswdev->ctpportconfig_idx[j].IngressExVlanNonIgmpBlkId = EXVLAN_ENTRY_INVALID;
+			gswdev->ctpportconfig_idx[j].EgressExVlanIgmpBlkId = EXVLAN_ENTRY_INVALID;
+			gswdev->ctpportconfig_idx[j].EgressExVlanNonIgmpBlkId = EXVLAN_ENTRY_INVALID;
+			memset(&ctp_config, 0, sizeof(GSW_CTP_portConfig_t));
+			ctp_config.nLogicalPortId = j;
+			ctp_config.nSubIfIdGroup = 0;
+			ctp_config.nBridgePortId = j;
+			ctp_config.eMask = GSW_CTP_PORT_CONFIG_MASK_BRIDGE_PORT_ID |
+					   GSW_CTP_PORT_CONFIG_BRIDGING_BYPASS;
+			ret = GSW_CtpPortConfigSet(cdev, &ctp_config);
+
+			if (ret == GSW_statusErr) {
+				pr_err("%s:%s:%d (GSW_CtpPortConfigSet returns ERROR)\n",
+				       __FILE__, __func__, __LINE__);
+				return GSW_statusErr;
+			}
+		}
+
+		/*Allocate Bridge 127- user is not allowed to use this BP
+		 CTP 2 to 286 not assigned to any logical port and configured with bridge port 127
+		 bridge port 0,1 ,127 and CTP 287 is Special port/Special usage*/
+		gswdev->brdgeportconfig_idx[127].IndexInUse = 1;
+
+		for (j = 2; j < gswdev->num_of_ctp; j++) {
+			gswdev->ctpportconfig_idx[j].AssociatedLogicalPort = NOT_ASSIGNED;
+			gswdev->ctpportconfig_idx[j].BrdgPortId = 127;
+			gswdev->ctpportconfig_idx[j].IngressExVlanIgmpBlkId = EXVLAN_ENTRY_INVALID;
+			gswdev->ctpportconfig_idx[j].IngressExVlanNonIgmpBlkId = EXVLAN_ENTRY_INVALID;
+			gswdev->ctpportconfig_idx[j].EgressExVlanIgmpBlkId = EXVLAN_ENTRY_INVALID;
+			gswdev->ctpportconfig_idx[j].EgressExVlanNonIgmpBlkId = EXVLAN_ENTRY_INVALID;
+
+			/*Same ctp port idx for ingress and egress ctp port configuration*/
+			memset(&tbl_prog_ctpport_ingress, 0, sizeof(pctbl_prog_t));
+			tbl_prog_ctpport_ingress.table = PCE_IGCTP_INDEX;
+			CLEAR_U16(tbl_prog_ctpport_ingress.pcindex);
+			/*Table Entry address (ctp port ingress Table index) Bit 8:0 in PCE_TBL_ADDR*/
+			tbl_prog_ctpport_ingress.pcindex |= (j & 0x1FF);
+
+			memset(&tbl_prog_ctpport_egress, 0, sizeof(pctbl_prog_t));
+			tbl_prog_ctpport_egress.table = PCE_EGCTP_INDEX;
+			CLEAR_U16(tbl_prog_ctpport_egress.pcindex);
+			/*Table Entry address (ctp port egress Table index) Bit 8:0 in PCE_TBL_ADDR*/
+			tbl_prog_ctpport_egress.pcindex |= (j & 0x1FF);
+
+			tbl_prog_ctpport_ingress.val[0] &= ~(0xFF);
+			/*bridge port 127*/
+			tbl_prog_ctpport_ingress.val[0] |= 127;
+
+			/*Address-based write for ingress ctp port configuration*/
+			gsw_pce_table_write(cdev, &tbl_prog_ctpport_ingress);
+			/*Address-based write for egress ctp port configuration*/
+			gsw_pce_table_write(cdev, &tbl_prog_ctpport_egress);
+
+		}
+
+		/*Enable SDMA for logical port 0 (PMAC 0) and 1 (PMAC 1) only
+		  Note: Other logical port's SDMA will be enabled only during CTP Alloc*/
+		for (j = 0; j < 2 ; j++) {
+			gsw_w32(cdev,
+				(SDMA_PCTRL_PEN_OFFSET + (j * 0x6)),
+				SDMA_PCTRL_PEN_SHIFT,
+				SDMA_PCTRL_PEN_SIZE, 1);
+		}
+
+		/*Enable FDMA for all logical ports*/
+		for (j = 0; j < gswdev->tpnum; j++) {
+			gsw_w32(cdev,
+				(FDMA_PCTRL_EN_OFFSET + (j * 0x6)),
+				FDMA_PCTRL_EN_SHIFT,
+				FDMA_PCTRL_EN_SIZE, 1);
+		}
+
+		/*PMAC default queue assignment and configuration*/
+		gsw_set_def_bypass_qmap(cdev, GSW_QOS_QMAP_SINGLE_MODE);
+		gsw_set_def_pce_qmap(cdev);
+		gsw_pmac_init_nondpu();
+		gsw_qos_def_config(cdev);
+#else
+
+		/*Emulation/PC tool*/
+		/*Enable FDMA/SDMA for all logical ports*/
+		for (j = 0; j < gswdev->tpnum; j++) {
+			gsw_w32(cdev,
+				(FDMA_PCTRL_EN_OFFSET + (j * 0x6)),
+				FDMA_PCTRL_EN_SHIFT,
+				FDMA_PCTRL_EN_SIZE, 1);
+			gsw_w32(cdev,
+				(SDMA_PCTRL_PEN_OFFSET + (j * 0x6)),
+				SDMA_PCTRL_PEN_SHIFT,
+				SDMA_PCTRL_PEN_SIZE, 1);
+		}
+
+#if defined(CONFIG_MAC) && CONFIG_MAC
+		struct mac_ops *mac_ops;
+		u32 max_mac = gsw_get_mac_subifcnt(0);
+
+		for (j = 0; j < max_mac; j++) {
+			mac_ops = get_mac_ops(gswdev, j + 2);
+			mac_init_fn_ptrs(mac_ops);
+			mac_ops->init(mac_ops);
+		}
+		struct adap_ops *ops = gsw_get_adap_ops(0);
+
+		if (ops == NULL) {
+			pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+		gswss_init_fn_ptrs(ops);
+#endif
+
+#endif
+
+		/* Enable CTP RMON for all logical port*/
+		for (j = 0; j < gswdev->tpnum; j++) {
+			gsw_w32(cdev, (BM_PCFG_CNTEN_OFFSET + (j * 2)), BM_PCFG_CNTEN_SHIFT,
+				BM_PCFG_CNTEN_SIZE, 1);
+		}
+
+		/* Switch Core Enable for Windows mode will be done in GSW_ENABLE */
+#if defined(WIN_PC_MODE) && WIN_PC_MODE
+#else
+		/*Note: Default Config*/
+		/*LP0 (fdma/sdma enabled) -> CTP 0 allocated ->Bridge port 0 allocated -> bridge/fid 0 allocated) */
+		/*Enable GSWIP 3.1 Switch Core*/
+		GSW_UnFreeze();
+#endif
+		/*Initalize GSWIP Irq*/
+		GSW_Irq_init(cdev);
+	}
+
+	return GSW_statusOk;
+}
+
+
+/*	This is the switch core layer init function.*/
+/*	\param ethcinit This parameter is a pointer */
+/*  to the switch core context. */
+/*	\return Return value as follows: */
+/*	cdev: if successful */
+void *ethsw_api_core_init(ethsw_core_init_t *ethcinit)
+{
+	ethsw_api_dev_t *PrvData;
+	struct core_ops *ops;
+	void *cdev;
+	u32 ret;
+	printk("Switch Core INIT...................\n");
+
+#ifdef __KERNEL__
+	/* KERNEL_MODE */
+	/** Get Platform Driver Data */
+	ops = platform_get_drvdata(ethcinit->pdev);
+
+	/** Get Switch Core Private Data */
+	PrvData = container_of(ops, ethsw_api_dev_t, ops);
+
+	if (PrvData == NULL) {
+		pr_err("%s:%s:%d (Plateform driver data not allocated)\n",
+		       __FILE__, __func__, __LINE__);
+		return PrvData;
+	}
+
+	/** Clear Switch Core Private Data */
+	memset(PrvData, 0, sizeof(ethsw_api_dev_t));
+
+	/** Set Core OPS struct Adress to cdev*/
+	cdev = &PrvData->ops;
+
+	/** Store Platform Device struct in Switch Core Private Data */
+	PrvData->pdev = ethcinit->pdev;
+
+	spin_lock_init(&PrvData->lock_pce);
+	spin_lock_init(&PrvData->lock_bm);
+	spin_lock_init(&PrvData->lock_misc);
+	spin_lock_init(&PrvData->lock_pmac);
+	spin_lock_init(&PrvData->lock_pae);
+	spin_lock_init(&PrvData->lock_irq);
+	spin_lock_init(&PrvData->lock_alloc);
+	spin_lock_init(&PrvData->lock_free);
+	spin_lock_init(&PrvData->lock_mdio);
+	spin_lock_init(&PrvData->lock_mmd);
+
+	/* KERNEL_MODE*/
+#else
+	/* USER SPACE APPLICATION */
+	PrvData = (ethsw_api_dev_t *)malloc(sizeof(ethsw_api_dev_t));
+	cdev = (void *)PrvData;
+
+	if (!PrvData) {
+		pr_err("%s:%s:%d (memory allocation failed)\n",
+		       __FILE__, __func__, __LINE__);
+		return PrvData;
+	}
+
+	memset(PrvData, 0, sizeof(ethsw_api_dev_t));
+	/* USER SPACE APPLICATION */
+#endif
+
+	PrvData->raldev = ethcinit->ecdev;
+	ecoredev[ethcinit->sdev] = PrvData;
+	PrvData->sdev = ethcinit->sdev;
+	PrvData->rst = 0;
+	PrvData->hwinit = 0;
+	PrvData->matimer = DEFAULT_AGING_TIMEOUT;
+	/** Switch Core Base Address */
+	PrvData->gsw_base = ethcinit->gsw_base_addr;
+	printk("Switch Core Base Address = 0x%08x\n", (unsigned int)PrvData->gsw_base);
+
+	/** Get Switch Hardware capablity */
+	get_gsw_hw_cap(cdev);
+
+	/** Initialize Switch Core Function Pointer */
+	ret = gsw_init_fn_ptrs(cdev);
+
+	if (ret ==
+	    GSW_statusErr) {
+		pr_err("%s:%s:%d (Initialize Switch Core Function Pointer failed)\n",
+		       __FILE__, __func__, __LINE__);
+		return PrvData;
+	}
+
+#if defined(CONFIG_LTQ_MULTICAST) && CONFIG_LTQ_MULTICAST
+	/*Reset Multicast software table*/
+	reset_multicast_sw_table(cdev);
+#endif /*CONFIG_LTQ_MULTICAST*/
+
+	/** TFlow Table Init */
+	pce_table_init(&PrvData->phandler);
+
+	/** Parser Micro Code Init */
+#if defined(CONFIG_USE_EMULATOR)
+	gsw_w32(cdev, PCE_GCTRL_0_MC_VALID_OFFSET,
+		PCE_GCTRL_0_MC_VALID_SHIFT, PCE_GCTRL_0_MC_VALID_SIZE, 0x1);
+#else
+	gsw_pmicro_code_init(cdev);
+	printk("Switch API: PCE MicroCode loaded !!\n");
+#endif
+
+	if (IS_VRSN_31(PrvData->gipver))
+		switch_core_init(cdev);
+	else
+		legacy_switch_core_init(cdev);
+
+#ifdef CONFIG_X86_INTEL_CE2700
+	cport_sgmii_config(cdev);
+	GSW_Enable(cdev);
+#endif /*CONFIG_X86_INTEL_CE2700*/
+	return PrvData;
+}
+
+/**	This is the switch core layer cleanup function.*/
+/*	\return Return value as follows: */
+/*	GSW_statusOk: if successful */
+void gsw_corecleanup(void)
+{
+	u8 i;
+	ethsw_api_dev_t *cdev;
+
+	for (i = 0; i < LTQ_FLOW_DEV_MAX; i++) {
+		cdev = (ethsw_api_dev_t *)ecoredev[i];
+
+		if (cdev) {
+			GSW_Irq_deinit(cdev);
+#ifdef __KERNEL__
+			kfree(cdev);
+#else
+			free(cdev);
+#endif
+			cdev = NULL;
+		}
+	}
+}
+
+GSW_return_t GSW_MAC_TableClear(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	/*  Flush all entries from the MAC table */
+	gsw_w32(cdev, PCE_GCTRL_0_MTFL_OFFSET,
+		PCE_GCTRL_0_MTFL_SHIFT,
+		PCE_GCTRL_0_MTFL_SIZE, 1);
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+
+static int conv_id(unsigned short val)
+{
+	static int templ[16] = {
+		-1,  0,  1, -2,
+		2, -2, -2, -2,
+		3, -2, -2, -2,
+		-2, -2, -2, -2
+	};
+
+	int result, r;
+	int i;
+
+	result = -1;
+
+	for (i = 0; val != 0 && i < 4; i++, val >>= 4) {
+		if ((val & 0x0F) == 0)
+			continue;
+
+		r = templ[val & 0x0F];
+
+		if (r < 0 || result >= 0)
+			return -1;
+
+		result = r + i * 4;
+	}
+
+	return result;
+}
+
+static int conv_id_array(unsigned short *pval, unsigned int size)
+{
+	int result, r;
+	unsigned int i;
+
+	result = -1;
+
+	for (i = 0; i < size; i++) {
+		if (pval[i] == 0)
+			continue;
+
+		r = conv_id(pval[i]);
+
+		if (r < 0 || result >= 0)
+			return -1;
+
+		result = r + i * 16;
+	}
+
+	return result;
+}
+
+GSW_return_t GSW_MAC_TableEntryAdd(void *cdev,
+				   GSW_MAC_tableAdd_t *parm)
+{
+	pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if ((parm->nPortId >= gswdev->tpnum) &&
+		    (!(parm->nPortId & 0x80000000))) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+	tbl_prog.table = PCE_MAC_BRIDGE_INDEX;
+	tbl_prog.key[0] = parm->nMAC[4] << 8 | parm->nMAC[5];
+	tbl_prog.key[1] = parm->nMAC[2] << 8 | parm->nMAC[3];
+	tbl_prog.key[2] = parm->nMAC[0] << 8 | parm->nMAC[1];
+	tbl_prog.key[3] = parm->nFId;
+
+	if (gswdev->gipver == LTQ_GSWIP_2_2_ETC)
+		tbl_prog.val[1] = ((parm->nSubIfId & 0xFFF) << 4);
+
+	/*	tbl_prog.val[1] = ((parm->nSVLAN_Id & 0xFFF) << 4); */
+	if (IS_VRSN_30_31(gswdev->gipver))
+		tbl_prog.val[1] = ((parm->nSubIfId & 0x1FFF) << 3);
+
+	/*To configure PCE_TBL_CTRL VLD 12th BIT*/
+	tbl_prog.valid = 1;
+	tbl_prog.val[1] |= (1 << 1); /* Valid Entry */
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+		/*Enable source address filter*/
+		if (parm->nFilterFlag & 0x1)
+			tbl_prog.key[3] |= (1 << 8);
+
+		/*Enable destination address filter*/
+		if (parm->nFilterFlag & 0x2)
+			tbl_prog.key[3] |= (1 << 9);
+	}
+
+	if (parm->bStaticEntry) { /*static entry*/
+		/*Enable static entry flag */
+		tbl_prog.val[1] |= 1;
+
+		if (IS_VRSN_31(gswdev->gipver)) {
+			/*set igmp control flag*/
+			if (parm->bIgmpControlled) {
+				tbl_prog.val[0] |= (1 << 2);
+				//Govind - Is the DMAC matched will go to below Port-Map or?
+			}
+
+			/*Set Bridge Port Map*/
+			if (parm->nPortId & 0x80000000) {
+				tbl_prog.val[2] = parm->nPortMap[0];
+				tbl_prog.val[3] = parm->nPortMap[1];
+				tbl_prog.val[4] = parm->nPortMap[2];
+				tbl_prog.val[5] = parm->nPortMap[3];
+				tbl_prog.val[6] = parm->nPortMap[4];
+				tbl_prog.val[7] = parm->nPortMap[5];
+				tbl_prog.val[8] = parm->nPortMap[6];
+				tbl_prog.val[9] = parm->nPortMap[7];
+				tbl_prog.val[10] = parm->nPortMap[8];
+				tbl_prog.val[11] = parm->nPortMap[9];
+				tbl_prog.val[12] = parm->nPortMap[10];
+				tbl_prog.val[13] = parm->nPortMap[11];
+				tbl_prog.val[14] = parm->nPortMap[12];
+				tbl_prog.val[15] = parm->nPortMap[13];
+				tbl_prog.val[16] = parm->nPortMap[14];
+				tbl_prog.val[17] = parm->nPortMap[15];
+			} else {
+				u32 i, j;
+
+				i = parm->nPortId / (sizeof(tbl_prog.val[0]) * 8);
+				j = parm->nPortId & (sizeof(tbl_prog.val[0]) * 8 - 1);
+				tbl_prog.val[i + 2] = 1 << j;
+			}
+		} else {
+			if (parm->nPortId & 0x80000000) { /*Port Map 3.0 */
+				if (parm->nPortMap[0])
+					tbl_prog.val[0] = parm->nPortMap[0];
+				else
+					tbl_prog.val[0] = (parm->nPortId & 0x7FFF);
+			} else {
+				tbl_prog.val[0] = (1 << parm->nPortId);
+			}
+		}
+
+	} else { /*Dynamic Entry*/
+		if (IS_VRSN_31(gswdev->gipver)) {
+			tbl_prog.val[0] = (parm->nAgeTimer & 0xF);
+			/*Set Bridge Port Member val 0 to 7 bits*/
+			tbl_prog.val[2] = (parm->nPortId & 0xFF);
+		} else {
+			tbl_prog.val[0] = (((parm->nPortId & 0xF) << 4)
+					   | (parm->nAgeTimer & 0xF));
+		}
+	}
+
+	gsw_pce_table_key_write(cdev, &tbl_prog);
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_MAC_TableEntryRead(void *cdev,
+				    GSW_MAC_tableRead_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t tbl_prog;
+	u32 ret = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+
+	if (parm->bInitial == 1) {
+		gswdev->mac_rd_index = 0; /*Start from the index 0 */
+		parm->bInitial = 0;
+	}
+
+	if (gswdev->mac_rd_index >= gswdev->mactblsize) {
+		memset(parm, 0, sizeof(GSW_MAC_tableRead_t));
+		parm->bLast = 1;
+		gswdev->mac_rd_index = 0;
+		ret = GSW_statusOk;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	tbl_prog.table = PCE_MAC_BRIDGE_INDEX;
+
+	do {
+		tbl_prog.pcindex = gswdev->mac_rd_index;
+		gsw_pce_table_read(cdev, &tbl_prog);
+		gswdev->mac_rd_index++;
+
+		if (tbl_prog.valid != 0)
+			break;
+	} while (gswdev->mac_rd_index < gswdev->mactblsize);
+
+	if (tbl_prog.valid == 1) {
+		/*get FID*/
+		parm->nFId = tbl_prog.key[3] & 0x3F;
+
+		if (IS_VRSN_31(gswdev->gipver)) {
+			/*source address filter flag*/
+			if (tbl_prog.key[3] & 0x100)
+				parm->nFilterFlag = parm->nFilterFlag | 0x1;
+
+			/*destination address filter flag*/
+			if (tbl_prog.key[3] & 0x200)
+				parm->nFilterFlag = parm->nFilterFlag | 0x2;
+		}
+
+		/*static flag*/
+		parm->bStaticEntry = (tbl_prog.val[1] & 0x1);
+
+		if (parm->bStaticEntry == 1) { /*Static Entry*/
+			parm->nAgeTimer = 0;
+
+			if (IS_VRSN_31(gswdev->gipver)) {
+				int id;
+
+				/*get igmp control flag*/
+				if (tbl_prog.val[0] & 0x4) {
+					parm->bIgmpControlled = 1;
+				}
+
+				/*Get Bridge Port Map*/
+				parm->nPortMap[0] = tbl_prog.val[2];
+				parm->nPortMap[1] = tbl_prog.val[3];
+				parm->nPortMap[2] = tbl_prog.val[4];
+				parm->nPortMap[3] = tbl_prog.val[5];
+				parm->nPortMap[4] = tbl_prog.val[6];
+				parm->nPortMap[5] = tbl_prog.val[7];
+				parm->nPortMap[6] = tbl_prog.val[8];
+				parm->nPortMap[7] = tbl_prog.val[9];
+				parm->nPortMap[8] = tbl_prog.val[10];
+				parm->nPortMap[9] = tbl_prog.val[11];
+				parm->nPortMap[10] = tbl_prog.val[12];
+				parm->nPortMap[11] = tbl_prog.val[13];
+				parm->nPortMap[12] = tbl_prog.val[14];
+				parm->nPortMap[13] = tbl_prog.val[15];
+				parm->nPortMap[14] = tbl_prog.val[16];
+				parm->nPortMap[15] = tbl_prog.val[17];
+
+
+				id = conv_id_array(&tbl_prog.val[2], 16);
+
+				if (id < 0)
+					parm->nPortId = 0x80000000;
+				else
+					parm->nPortId = (u32)id;
+			} else {
+
+				int id = conv_id(tbl_prog.val[0]);
+
+				if (id < 0)
+					parm->nPortId = (u32)tbl_prog.val[0] | 0x80000000;
+				else
+					parm->nPortId = (u32)id;
+			}
+
+		} else { /*Dynamic Entry*/
+			u32 mant, timer = 300;
+			/* Aging Counter Mantissa Value */
+			gsw_r32(cdev, PCE_AGE_1_MANT_OFFSET,
+				PCE_AGE_1_MANT_SHIFT,
+				PCE_AGE_1_MANT_SIZE, &mant);
+
+			switch (mant) {
+			case AGETIMER_1_DAY:
+				timer = 86400;
+				break;
+
+			case AGETIMER_1_HOUR:
+				timer = 3600;
+				break;
+
+			case AGETIMER_300_SEC:
+				timer = 300;
+				break;
+
+			case AGETIMER_10_SEC:
+				timer = 10;
+				break;
+
+			case AGETIMER_1_SEC:
+				timer = 1;
+				break;
+			}
+
+			parm->nAgeTimer =	tbl_prog.val[0] & 0xF;
+			parm->nAgeTimer =	(timer * parm->nAgeTimer) / 0xF;
+
+			if (IS_VRSN_31(gswdev->gipver)) {
+				/*Set Bridge Port Member val 0 to 7 bits*/
+				parm->nPortId = (tbl_prog.val[2] & 0xFF);
+				/*Changed
+					0: the entry is not changed
+					1: the entry is changed and not accessed yet */
+				parm->bEntryChanged = ((tbl_prog.val[0] >> 8) & 0x1);
+			} else {
+				parm->nPortId =	(tbl_prog.val[0] >> 4) & 0xF;
+			}
+		}
+
+		parm->nMAC[0] = tbl_prog.key[2] >> 8;
+		parm->nMAC[1] = tbl_prog.key[2] & 0xFF;
+		parm->nMAC[2] = tbl_prog.key[1] >> 8;
+		parm->nMAC[3] = tbl_prog.key[1] & 0xFF;
+		parm->nMAC[4] = tbl_prog.key[0] >> 8;
+		parm->nMAC[5] = tbl_prog.key[0] & 0xFF;
+
+		if (gswdev->gipver == LTQ_GSWIP_2_2_ETC)
+			parm->nSubIfId = (tbl_prog.val[1] >> 4 & 0xFFF);
+
+		/*	parm->nSVLAN_Id = (tbl_prog.val[1] >> 4 & 0xFFF); */
+		if (IS_VRSN_30_31(gswdev->gipver))
+			parm->nSubIfId = (tbl_prog.val[1] >> 3 & 0x1FFF);
+
+		parm->bInitial = 0;
+		parm->bLast = 0;
+	} else {
+		memset(parm, 0, sizeof(GSW_MAC_tableRead_t));
+		parm->bLast = 1;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_MAC_TableEntryQuery(void *cdev,
+				     GSW_MAC_tableQuery_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t tbl_prog;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	parm->bFound = 0;
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+	tbl_prog.table = PCE_MAC_BRIDGE_INDEX;
+	tbl_prog.key[0] = parm->nMAC[4] << 8 | parm->nMAC[5];
+	tbl_prog.key[1] = parm->nMAC[2] << 8 | parm->nMAC[3];
+	tbl_prog.key[2] = parm->nMAC[0] << 8 | parm->nMAC[1];
+	tbl_prog.key[3] = parm->nFId;
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+		/*source address filter key*/
+		if (parm->nFilterFlag & 0x1) {
+			tbl_prog.key[3] |= (1 << 8);
+		}
+
+		/*destination address filter key*/
+		if (parm->nFilterFlag & 0x2) {
+			tbl_prog.key[3] |= (1 << 9);
+		}
+	}
+
+	gsw_pce_table_key_read(cdev, &tbl_prog);
+
+	if (tbl_prog.valid == 1) {
+		parm->bFound = 1;
+		parm->bStaticEntry = (tbl_prog.val[1] & 0x1);
+		parm->nSubIfId = ((tbl_prog.val[1] >> 3) & 0x1FFF);
+
+		if (parm->bStaticEntry == 1) {
+			parm->nAgeTimer = 0;
+
+			if (IS_VRSN_31(gswdev->gipver)) {
+				int id;
+
+				/*get igmp control flag*/
+				if (tbl_prog.val[0] & 0x4) {
+					parm->bIgmpControlled = 1;
+				}
+
+				/*Get Bridge Port Map*/
+				parm->nPortMap[0] = tbl_prog.val[2];
+				parm->nPortMap[1] = tbl_prog.val[3];
+				parm->nPortMap[2] = tbl_prog.val[4];
+				parm->nPortMap[3] = tbl_prog.val[5];
+				parm->nPortMap[4] = tbl_prog.val[6];
+				parm->nPortMap[5] = tbl_prog.val[7];
+				parm->nPortMap[6] = tbl_prog.val[8];
+				parm->nPortMap[7] = tbl_prog.val[9];
+				parm->nPortMap[8] = tbl_prog.val[10];
+				parm->nPortMap[9] = tbl_prog.val[11];
+				parm->nPortMap[10] = tbl_prog.val[12];
+				parm->nPortMap[11] = tbl_prog.val[13];
+				parm->nPortMap[12] = tbl_prog.val[14];
+				parm->nPortMap[13] = tbl_prog.val[15];
+				parm->nPortMap[14] = tbl_prog.val[16];
+				parm->nPortMap[15] = tbl_prog.val[17];
+
+				id = conv_id_array(&tbl_prog.val[2], 16);
+
+				if (id < 0)
+					parm->nPortId = 0x80000000;
+				else
+					parm->nPortId = (u32)id;
+			} else {
+				int id = conv_id(tbl_prog.val[0]);
+
+				if (id < 0)
+					parm->nPortId = (u32)tbl_prog.val[0] | 0x80000000;
+				else
+					parm->nPortId = (u32)id;
+			}
+		} else {
+			u32 mant, timer = 300;
+			/* Aging Counter Mantissa Value */
+			gsw_r32(cdev, PCE_AGE_1_MANT_OFFSET,
+				PCE_AGE_1_MANT_SHIFT,
+				PCE_AGE_1_MANT_SIZE, &mant);
+
+			switch (mant) {
+			case AGETIMER_1_DAY:
+				timer = 86400;
+				break;
+
+			case AGETIMER_1_HOUR:
+				timer = 3600;
+				break;
+
+			case AGETIMER_300_SEC:
+				timer = 300;
+				break;
+
+			case AGETIMER_10_SEC:
+				timer = 10;
+				break;
+
+			case AGETIMER_1_SEC:
+				timer = 1;
+				break;
+			}
+
+			parm->nAgeTimer = tbl_prog.val[0] & 0xF;
+			parm->nAgeTimer = (timer * parm->nAgeTimer) / 0xF;
+
+			if (IS_VRSN_31(gswdev->gipver)) {
+				/*Set Bridge Port Member val 0 to 7 bits*/
+				parm->nPortId = (tbl_prog.val[2] & 0xFF);
+
+				/*Changed
+					0: the entry is not changed
+					1: the entry is changed and not accessed yet */
+				parm->bEntryChanged = ((tbl_prog.val[0] >> 8) & 0x1);
+			} else {
+				parm->nPortId =	(tbl_prog.val[0] >> 4) & 0xF;
+			}
+		}
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_MAC_TableEntryRemove(void *cdev,
+				      GSW_MAC_tableRemove_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t tbl_prog;
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	/* MAC table flushing control bit */
+	gsw_r32(cdev, PCE_GCTRL_0_MTFL_OFFSET,
+		PCE_GCTRL_0_MTFL_SHIFT,
+		PCE_GCTRL_0_MTFL_SIZE, &value);
+
+	/* If value is 1, flush all entries from the MAC table in process */
+	if (!value) {
+		memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+		tbl_prog.table = PCE_MAC_BRIDGE_INDEX;
+		tbl_prog.key[0] = parm->nMAC[4] << 8 | parm->nMAC[5];
+		tbl_prog.key[1] = parm->nMAC[2] << 8 | parm->nMAC[3];
+		tbl_prog.key[2] = parm->nMAC[0] << 8 | parm->nMAC[1];
+		tbl_prog.key[3] = parm->nFId;
+
+		if (IS_VRSN_31(gswdev->gipver)) {
+			/*source address filter key*/
+			if (parm->nFilterFlag & 0x1) {
+				tbl_prog.key[3] |= (1 << 8);
+			}
+
+			/*destination address filter key*/
+			if (parm->nFilterFlag & 0x2) {
+				tbl_prog.key[3] |= (1 << 9);
+			}
+		}
+
+		gsw_pce_table_key_read(cdev, &tbl_prog);
+
+		if (tbl_prog.valid == 1) {
+			pctbl_prog_t tbl_cl_prog;
+			memset(&tbl_cl_prog, 0, sizeof(pctbl_prog_t));
+			tbl_cl_prog.table = PCE_MAC_BRIDGE_INDEX;
+			tbl_cl_prog.pcindex = tbl_prog.pcindex;
+			gsw_pce_table_write(cdev, &tbl_cl_prog);
+		}
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_PortCfgGet(void *cdev, GSW_portCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 pidx = parm->nPortId;
+	u32 value, monrx = 0, montx = 0, PEN, EN;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (parm->nPortId >= gswdev->tpnum) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/* See if PORT enable or not */
+	gsw_r32(cdev, (SDMA_PCTRL_PEN_OFFSET + (0x6 * pidx)),
+		SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE, &PEN);
+	gsw_r32(cdev, (FDMA_PCTRL_EN_OFFSET + (0x6 * pidx)),
+		FDMA_PCTRL_EN_SHIFT, FDMA_PCTRL_EN_SIZE, &EN);
+
+	/* Port Enable feature only support 6 port */
+	if (pidx >= gswdev->pnum) {
+		parm->eEnable = 1;
+	} else {
+		if ((PEN == 1) && (EN == 1))
+			parm->eEnable = GSW_PORT_ENABLE_RXTX;
+		else if ((PEN == 1) && (EN == 0))
+			parm->eEnable = GSW_PORT_ENABLE_RX;
+		else if ((PEN == 0) && (EN == 1))
+			parm->eEnable = GSW_PORT_ENABLE_TX;
+		else
+			parm->eEnable = GSW_PORT_DISABLE;
+	}
+
+	/* Learning Limit */
+	gsw_r32(cdev, (PCE_PCTRL_1_LRNLIM_OFFSET + (0xA * pidx)),
+		PCE_PCTRL_1_LRNLIM_SHIFT,
+		PCE_PCTRL_1_LRNLIM_SIZE, &value);
+	parm->nLearningLimit = value;
+
+	/* Learning Limit Port Lock */
+	gsw_r32(cdev, (PCE_PCTRL_0_PLOCK_OFFSET + (0xA * pidx)),
+		PCE_PCTRL_0_PLOCK_SHIFT,
+		PCE_PCTRL_0_PLOCK_SIZE, &value);
+	parm->bLearningMAC_PortLock = value;
+	/* Aging */
+	gsw_r32(cdev, PCE_PCTRL_0_AGEDIS_OFFSET + (0xA * pidx),
+		PCE_PCTRL_0_AGEDIS_SHIFT,
+		PCE_PCTRL_0_AGEDIS_SIZE, &value);
+	parm->bAging = value;
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		/** MAC address table learning on the port specified. */
+		gsw_r32(cdev, (PCE_PCTRL_3_LNDIS_OFFSET + (0xA * pidx)),
+			PCE_PCTRL_3_LNDIS_SHIFT,
+			PCE_PCTRL_3_LNDIS_SIZE, &parm->bLearning);
+		/** MAC spoofing detection. */
+		gsw_r32(cdev, (PCE_PCTRL_0_SPFDIS_OFFSET + (0xA * pidx)),
+			PCE_PCTRL_0_SPFDIS_SHIFT,
+			PCE_PCTRL_0_SPFDIS_SIZE, &parm->bMAC_SpoofingDetection);
+	}
+
+	/* UnicastUnknownDrop */
+	gsw_r32(cdev, PCE_PMAP_3_UUCMAP_OFFSET,
+		PCE_PMAP_3_UUCMAP_SHIFT,
+		PCE_PMAP_3_UUCMAP_SIZE, &value);
+
+	/* UnicastUnknownDrop feature  support  */
+	if ((value & (1 << pidx)) == 0)
+		parm->bUnicastUnknownDrop = 1;
+	else
+		parm->bUnicastUnknownDrop = 0;
+
+	/* MulticastUnknownDrop */
+	gsw_r32(cdev, PCE_PMAP_2_DMCPMAP_OFFSET,
+		PCE_PMAP_2_DMCPMAP_SHIFT,
+		PCE_PMAP_2_DMCPMAP_SIZE, &value);
+
+	/* MulticastUnknownDrop feature  support  */
+	if ((value & (1 << pidx)) == 0) {
+		parm->bMulticastUnknownDrop = 1;
+		parm->bBroadcastDrop = 1;
+	} else {
+		parm->bMulticastUnknownDrop = 0;
+		parm->bBroadcastDrop = 0;
+	}
+
+	/* Require to check later - 3M */
+	parm->bReservedPacketDrop = 0;
+	/* Port Monitor */
+	gsw_r32(cdev, (PCE_PCTRL_3_RXVMIR_OFFSET + (0xA * pidx)),
+		PCE_PCTRL_3_RXVMIR_SHIFT,
+		PCE_PCTRL_3_RXVMIR_SIZE, &monrx);
+	gsw_r32(cdev, (PCE_PCTRL_3_TXMIR_OFFSET + (0xA * pidx)),
+		PCE_PCTRL_3_TXMIR_SHIFT,
+		PCE_PCTRL_3_TXMIR_SIZE, &montx);
+
+	if ((monrx == 1) && (montx == 1))
+		parm->ePortMonitor = GSW_PORT_MONITOR_RXTX;
+	else if ((monrx == 1) && (montx == 0))
+		parm->ePortMonitor = GSW_PORT_MONITOR_RX;
+	else if ((monrx == 0) && (montx == 1))
+		parm->ePortMonitor = GSW_PORT_MONITOR_TX;
+	else
+		parm->ePortMonitor = GSW_PORT_MONITOR_NONE;
+
+	gsw_r32(cdev, (PCE_PCTRL_3_VIO_2_OFFSET + (0xA * pidx)),
+		PCE_PCTRL_3_VIO_2_SHIFT,
+		PCE_PCTRL_3_VIO_2_SIZE, &monrx);
+
+	if (monrx == 1)
+		parm->ePortMonitor |= GSW_PORT_MONITOR_VLAN_UNKNOWN;
+
+	gsw_r32(cdev, (PCE_PCTRL_3_VIO_4_OFFSET + (0xA * pidx)),
+		PCE_PCTRL_3_VIO_4_SHIFT,
+		PCE_PCTRL_3_VIO_4_SIZE, &monrx);
+
+	if (monrx == 1)
+		parm->ePortMonitor |= GSW_PORT_MONITOR_VLAN_MEMBERSHIP;
+
+	gsw_r32(cdev, (PCE_PCTRL_3_VIO_5_OFFSET + (0xA * pidx)),
+		PCE_PCTRL_3_VIO_5_SHIFT,
+		PCE_PCTRL_3_VIO_5_SIZE, &monrx);
+
+	if (monrx == 1)
+		parm->ePortMonitor |= GSW_PORT_MONITOR_PORT_STATE;
+
+	gsw_r32(cdev, (PCE_PCTRL_3_VIO_6_OFFSET + (0xA * pidx)),
+		PCE_PCTRL_3_VIO_6_SHIFT,
+		PCE_PCTRL_3_VIO_6_SIZE, &monrx);
+
+	if (monrx == 1)
+		parm->ePortMonitor |= GSW_PORT_MONITOR_LEARNING_LIMIT;
+
+	gsw_r32(cdev, (PCE_PCTRL_3_VIO_7_OFFSET + (0xA * pidx)),
+		PCE_PCTRL_3_VIO_7_SHIFT,
+		PCE_PCTRL_3_VIO_7_SIZE, &monrx);
+
+	if (monrx == 1)
+		parm->ePortMonitor |= GSW_PORT_MONITOR_PORT_LOCK;
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		gsw_r32(cdev, (BM_RMON_CTRL_IFRMONFST_OFFSET + (0x2 * pidx)),
+			BM_RMON_CTRL_IFRMONFST_SHIFT,
+			BM_RMON_CTRL_IFRMONFST_SIZE, &parm->nIfCountStartIdx);
+
+		if (parm->nIfCountStartIdx)
+			parm->bIfCounters = 1;
+
+		gsw_r32(cdev, (BM_RMON_CTRL_IFRMONMD_OFFSET + (0x2 * pidx)),
+			BM_RMON_CTRL_IFRMONMD_SHIFT,
+			BM_RMON_CTRL_IFRMONMD_SIZE, &parm->eIfRMONmode);
+
+		if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+			if (parm->nPortId == 15) {
+				/*				pr_err("%s:%s:%d",__FILE__, __func__, __LINE__);*/
+				gsw_r32(cdev, MAC_PSTAT_TXPAUEN_OFFSET,
+					MAC_PSTAT_TXPAUEN_SHIFT, 2, &value);
+			}
+		} else {
+			if ((parm->nPortId |= 0) && (parm->nPortId < (gswdev->pnum - 1))) {
+				gsw_r32(cdev, (MAC_PSTAT_TXPAUEN_OFFSET + (0xC * (parm->nPortId - 1))),
+					MAC_PSTAT_TXPAUEN_SHIFT, 2, &value);
+			}
+		}
+	} else {
+		gsw_r32(cdev, (MAC_PSTAT_TXPAUEN_OFFSET + (0xC * pidx)),
+			MAC_PSTAT_TXPAUEN_SHIFT, 2, &value);
+	}
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+#if defined(CONFIG_MAC) && CONFIG_MAC
+
+		/* MAC API's to get flow control */
+		if (parm->ePortType == GSW_PHYSICAL_PORT ||
+		    parm->ePortType == GSW_LOGICAL_PORT) {
+			struct mac_ops *ops = get_mac_ops(gswdev, parm->nPortId);
+
+			if (!ops) {
+				pr_err("MAC %d is not initialized\n", parm->nPortId);
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			parm->eFlowCtrl = ops->get_flow_ctl(ops);
+		} else
+			pr_err("MAC configuration is not valid for CTP or Bridge Port %d \n", parm->nPortId);
+
+#endif
+	} else {
+		switch (value) {
+		case 0:
+			parm->eFlowCtrl = GSW_FLOW_OFF;
+			break;
+
+		case 1:
+			parm->eFlowCtrl = GSW_FLOW_TX;
+			break;
+
+		case 3:
+			parm->eFlowCtrl = GSW_FLOW_RXTX;
+			break;
+
+		case 2:
+			parm->eFlowCtrl = GSW_FLOW_RX;
+			break;
+
+		default:
+			parm->eFlowCtrl = GSW_FLOW_AUTO;
+		}
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_PortCfgSet(void *cdev, GSW_portCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 pidx = parm->nPortId;
+	u32 paddr;
+	u32 value, EN, PEN, PACT;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (parm->nPortId >= gswdev->tpnum) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/* Port locking flag  */
+		gsw_w32(cdev, (PCE_PCTRL_0_PLOCK_OFFSET + (0xA * pidx)),
+			PCE_PCTRL_0_PLOCK_SHIFT,
+			PCE_PCTRL_0_PLOCK_SIZE, parm->bLearningMAC_PortLock);
+	}
+
+	/* Learning Limit Action */
+	if (parm->nLearningLimit == 0xFFFF)
+		value = 0xFF;
+	else
+		value = parm->nLearningLimit;
+
+	gswdev->pconfig[parm->nPortId].llimit = value;
+	/* Learning Limit */
+	gsw_w32(cdev, (PCE_PCTRL_1_LRNLIM_OFFSET + (0xA * pidx)),
+		PCE_PCTRL_1_LRNLIM_SHIFT,
+		PCE_PCTRL_1_LRNLIM_SIZE, value);
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		/** MAC address table learning on the port specified */
+		gsw_w32(cdev, (PCE_PCTRL_3_LNDIS_OFFSET + (0xA * pidx)),
+			PCE_PCTRL_3_LNDIS_SHIFT,
+			PCE_PCTRL_3_LNDIS_SIZE, parm->bLearning);
+		/** MAC spoofing detection. */
+		gsw_w32(cdev, (PCE_PCTRL_0_SPFDIS_OFFSET + (0xA * pidx)),
+			PCE_PCTRL_0_SPFDIS_SHIFT,
+			PCE_PCTRL_0_SPFDIS_SIZE, parm->bMAC_SpoofingDetection);
+	}
+
+	/* Aging */ //Govind- aging dis/en is not in 3.1?
+	gsw_w32(cdev, PCE_PCTRL_0_AGEDIS_OFFSET + (0xA * pidx),
+		PCE_PCTRL_0_AGEDIS_SHIFT,
+		PCE_PCTRL_0_AGEDIS_SIZE, parm->bAging);
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		/* UnicastUnknownDrop Read first */
+		gsw_r32(cdev, PCE_PMAP_3_UUCMAP_OFFSET,
+			PCE_PMAP_3_UUCMAP_SHIFT,
+			PCE_PMAP_3_UUCMAP_SIZE, &value);
+
+		if (parm->bUnicastUnknownDrop == 1)
+			value &= ~(1 << pidx);
+		else
+			value |= 1 << pidx;
+
+		/* UnicastUnknownDrop write back */
+		gsw_w32(cdev, PCE_PMAP_3_UUCMAP_OFFSET,
+			PCE_PMAP_3_UUCMAP_SHIFT,
+			PCE_PMAP_3_UUCMAP_SIZE, value);
+
+		/* MulticastUnknownDrop */
+		gsw_r32(cdev, PCE_PMAP_2_DMCPMAP_OFFSET,
+			PCE_PMAP_2_DMCPMAP_SHIFT,
+			PCE_PMAP_2_DMCPMAP_SIZE, &value);
+
+		if (parm->bMulticastUnknownDrop == 1)
+			value &= ~(1 << pidx);
+		else
+			value |= 1 << pidx;
+
+		/* MulticastUnknownDrop */
+		gsw_w32(cdev, PCE_PMAP_2_DMCPMAP_OFFSET,
+			PCE_PMAP_2_DMCPMAP_SHIFT,
+			PCE_PMAP_2_DMCPMAP_SIZE, value);
+	}
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		/* Flow Control */
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			if ((pidx == 0 /*GSW_3X_SOC_CPU_PORT*/)) {
+				PEN = 0;
+				PACT = 0;
+			} else {
+				if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+					if (parm->nPortId == 15) {
+						gsw_r32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
+							(GSWT_MDCCFG_0_PEN_1_SHIFT), GSWT_MDCCFG_0_PEN_1_SIZE, &PEN);
+						gsw_r32(cdev, (GSWT_MDIO_STAT_1_PACT_OFFSET + GSW30_TOP_OFFSET),
+							GSWT_MDIO_STAT_1_PACT_SHIFT, GSWT_MDIO_STAT_1_PACT_SIZE, &PACT);
+						gsw_r32(cdev, (GSWT_PHY_ADDR_1_ADDR_OFFSET  + GSW30_TOP_OFFSET),
+							GSWT_PHY_ADDR_1_ADDR_SHIFT, GSWT_PHY_ADDR_1_ADDR_SIZE, &paddr);
+					} else {
+						PEN = 0;
+						PACT = 0;
+					}
+				} else {
+					if (pidx < gswdev->pnum) {
+						gsw_r32(cdev, (GSWT_MDCCFG_0_PEN_0_OFFSET + GSW30_TOP_OFFSET),
+							(GSWT_MDCCFG_0_PEN_0_SHIFT + pidx),	GSWT_MDCCFG_0_PEN_0_SIZE, &PEN);
+						gsw_r32(cdev, ((GSWT_MDIO_STAT_1_PACT_OFFSET + ((pidx - 1) * 4)) + GSW30_TOP_OFFSET),
+							GSWT_MDIO_STAT_1_PACT_SHIFT, GSWT_MDIO_STAT_1_PACT_SIZE, &PACT);
+						gsw_r32(cdev, ((GSWT_PHY_ADDR_1_ADDR_OFFSET + ((parm->nPortId - 1) * 4)) + GSW30_TOP_OFFSET),
+							GSWT_PHY_ADDR_1_ADDR_SHIFT, GSWT_PHY_ADDR_1_ADDR_SIZE, &paddr);
+					} else {
+						PEN = 0;
+						PACT = 0;
+					}
+				}
+			}
+		} else {
+			if (pidx < gswdev->pnum) {
+				gsw_r32(cdev, (MDC_CFG_0_PEN_0_OFFSET + GSW_TREG_OFFSET),
+					(MDC_CFG_0_PEN_0_SHIFT + pidx), MDC_CFG_0_PEN_0_SIZE, &PEN);
+				gsw_r32(cdev, (MDIO_STAT_0_PACT_OFFSET + GSW_TREG_OFFSET + pidx),
+					MDIO_STAT_0_PACT_SHIFT, MDIO_STAT_0_PACT_SIZE, &PACT);
+				gsw_r32(cdev, ((PHY_ADDR_0_ADDR_OFFSET - pidx) + GSW_TREG_OFFSET),
+					PHY_ADDR_0_ADDR_SHIFT, PHY_ADDR_0_ADDR_SIZE, &paddr);
+			} else {
+				PEN = 0;
+				PACT = 0;
+			}
+		}
+	} else {
+		PEN = 0;
+		PACT = 0;
+	}
+
+	/* PHY polling statemachine (of the MAC) is activated and */
+	/* an external PHY reacts on the MDIO accesses. */
+	/* Therefore update the MDIO register of the attached PHY.*/
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if ((PEN == 1) && (PACT == 1)) {
+			GSW_MDIO_data_t mddata;
+			/* Write directly to MDIO register */
+			mddata.nAddressDev = paddr;
+			mddata.nAddressReg = 0x4;
+			GSW_MDIO_DataRead(cdev, &mddata);
+			mddata.nData &= ~(0xC00);
+
+			switch (parm->eFlowCtrl) {
+			case GSW_FLOW_OFF:
+				break;
+
+			case GSW_FLOW_TX:
+				mddata.nData |= 0x800;
+				break;
+
+			case GSW_FLOW_RXTX:
+				mddata.nData |= 0x400;
+				break;
+
+			case GSW_FLOW_RX:
+			case GSW_FLOW_AUTO:
+				mddata.nData |= 0xC00;
+				break;
+			}
+
+			GSW_MDIO_DataWrite(cdev, &mddata);
+			/* Restart Auto negotiation */
+			mddata.nAddressReg = 0x0;
+			GSW_MDIO_DataRead(cdev, &mddata);
+			mddata.nData |= 0x1200;
+			GSW_MDIO_DataWrite(cdev, &mddata);
+		} else {
+			u32 RX = 0, TX = 0;
+
+			switch (parm->eFlowCtrl) {
+			case GSW_FLOW_OFF:
+				RX = 3;
+				TX = 3;
+				break;
+
+			case GSW_FLOW_TX:
+				RX = 3;
+				TX = 2;
+				break;
+
+			case GSW_FLOW_RXTX:
+				RX = 2;
+				TX = 2;
+				break;
+
+			case GSW_FLOW_RX:
+				RX = 2;
+				TX = 3;
+				break;
+
+			case GSW_FLOW_AUTO:
+				RX = 0;
+				TX = 0;
+				break;
+			}
+
+			if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				if (pidx != 0) {
+					if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+						if (pidx == 15) {
+							gsw_w32(cdev, MAC_CTRL_0_FCON_OFFSET, MAC_CTRL_0_FCON_SHIFT,
+								MAC_CTRL_0_FCON_SIZE, parm->eFlowCtrl);
+							gsw_w32(cdev, (GSWT_PHY_ADDR_1_FCONTX_OFFSET + GSW30_TOP_OFFSET),
+								GSWT_PHY_ADDR_1_FCONTX_SHIFT, GSWT_PHY_ADDR_1_FCONTX_SIZE, TX);
+							gsw_w32(cdev, (GSWT_PHY_ADDR_1_FCONRX_OFFSET + GSW30_TOP_OFFSET),
+								GSWT_PHY_ADDR_1_FCONRX_SHIFT,	GSWT_PHY_ADDR_1_FCONRX_SIZE, RX);
+						}
+					} else {
+						if (pidx < gswdev->pnum) {
+							gsw_w32(cdev, (MAC_CTRL_0_FCON_OFFSET + (0xC * (pidx - 1))),
+								MAC_CTRL_0_FCON_SHIFT, MAC_CTRL_0_FCON_SIZE, parm->eFlowCtrl);
+							gsw_w32(cdev, ((GSWT_PHY_ADDR_1_FCONTX_OFFSET + ((pidx - 1) * 4)) + GSW30_TOP_OFFSET),
+								GSWT_PHY_ADDR_1_FCONTX_SHIFT, GSWT_PHY_ADDR_1_FCONTX_SIZE, TX);
+							gsw_w32(cdev, ((GSWT_PHY_ADDR_1_FCONRX_OFFSET + ((pidx - 1) * 4)) + GSW30_TOP_OFFSET),
+								GSWT_PHY_ADDR_1_FCONRX_SHIFT, GSWT_PHY_ADDR_1_FCONRX_SIZE, RX);
+						}
+					}
+				}
+			} else {
+				if (pidx < gswdev->pnum) {
+					gsw_w32(cdev, (MAC_CTRL_0_FCON_OFFSET + (0xC * pidx)),
+						MAC_CTRL_0_FCON_SHIFT, MAC_CTRL_0_FCON_SIZE, parm->eFlowCtrl);
+					gsw_w32(cdev, (PHY_ADDR_0_FCONTX_OFFSET - (0x1 * pidx)),
+						PHY_ADDR_0_FCONTX_SHIFT, PHY_ADDR_0_FCONTX_SIZE, TX);
+					gsw_w32(cdev, (PHY_ADDR_0_FCONRX_OFFSET - (0x1 * pidx)),
+						PHY_ADDR_0_FCONRX_SHIFT, PHY_ADDR_0_FCONRX_SIZE, RX);
+				}
+			}
+		}
+	}
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+#if defined(CONFIG_MAC) && CONFIG_MAC
+
+		/* MAC API's to set flow control */
+		if (parm->ePortType == GSW_PHYSICAL_PORT ||
+		    parm->ePortType == GSW_LOGICAL_PORT) {
+			struct mac_ops *ops = get_mac_ops(gswdev, parm->nPortId);
+
+			if (!ops) {
+				pr_err("MAC %d is not initialized\n", parm->nPortId);
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			ops->set_flow_ctl(ops, parm->eFlowCtrl);
+		} else
+			pr_err("MAC configuration is not valid for CTP or Bridge Port %d\n", parm->nPortId);
+
+#endif
+	}
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		switch (parm->ePortMonitor) {
+		case GSW_PORT_MONITOR_NONE:
+			gsw_w32(cdev,
+				(PCE_PCTRL_3_RXVMIR_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_RXVMIR_SHIFT,
+				PCE_PCTRL_3_RXVMIR_SIZE, 0);
+			gsw_w32(cdev,
+				(PCE_PCTRL_3_TXMIR_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_TXMIR_SHIFT,
+				PCE_PCTRL_3_TXMIR_SIZE, 0);
+			gsw_w32(cdev,
+				(PCE_PCTRL_3_VIO_2_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_VIO_2_SHIFT,
+				PCE_PCTRL_3_VIO_2_SIZE, 0);
+			gsw_w32(cdev,
+				(PCE_PCTRL_3_VIO_4_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_VIO_4_SHIFT,
+				PCE_PCTRL_3_VIO_4_SIZE, 0);
+			gsw_w32(cdev,
+				(PCE_PCTRL_3_VIO_5_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_VIO_5_SHIFT,
+				PCE_PCTRL_3_VIO_5_SIZE, 0);
+			gsw_w32(cdev,
+				(PCE_PCTRL_3_VIO_6_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_VIO_6_SHIFT,
+				PCE_PCTRL_3_VIO_6_SIZE, 0);
+			gsw_w32(cdev,
+				(PCE_PCTRL_3_VIO_7_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_VIO_7_SHIFT,
+				PCE_PCTRL_3_VIO_7_SIZE, 0);
+			break;
+
+		case GSW_PORT_MONITOR_RX:
+			gsw_w32(cdev, (PCE_PCTRL_3_RXVMIR_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_RXVMIR_SHIFT,
+				PCE_PCTRL_3_RXVMIR_SIZE, 1);
+			gsw_w32(cdev, (PCE_PCTRL_3_TXMIR_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_TXMIR_SHIFT,
+				PCE_PCTRL_3_TXMIR_SIZE, 0);
+			break;
+
+		case GSW_PORT_MONITOR_TX:
+			gsw_w32(cdev, (PCE_PCTRL_3_RXVMIR_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_RXVMIR_SHIFT,
+				PCE_PCTRL_3_RXVMIR_SIZE, 0);
+			gsw_w32(cdev, (PCE_PCTRL_3_TXMIR_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_TXMIR_SHIFT,
+				PCE_PCTRL_3_TXMIR_SIZE, 1);
+			break;
+
+		case GSW_PORT_MONITOR_RXTX:
+			gsw_w32(cdev, (PCE_PCTRL_3_RXVMIR_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_RXVMIR_SHIFT,
+				PCE_PCTRL_3_RXVMIR_SIZE, 1);
+			gsw_w32(cdev, (PCE_PCTRL_3_TXMIR_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_TXMIR_SHIFT,
+				PCE_PCTRL_3_TXMIR_SIZE, 1);
+			break;
+
+		case GSW_PORT_MONITOR_VLAN_UNKNOWN:
+			gsw_w32(cdev, (PCE_PCTRL_3_VIO_2_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_VIO_2_SHIFT,
+				PCE_PCTRL_3_VIO_2_SIZE, 1);
+			break;
+
+		case GSW_PORT_MONITOR_VLAN_MEMBERSHIP:
+			gsw_w32(cdev, (PCE_PCTRL_3_VIO_4_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_VIO_4_SHIFT,
+				PCE_PCTRL_3_VIO_4_SIZE, 1);
+			break;
+
+		case GSW_PORT_MONITOR_PORT_STATE:
+			gsw_w32(cdev, (PCE_PCTRL_3_VIO_5_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_VIO_5_SHIFT,
+				PCE_PCTRL_3_VIO_5_SIZE, 1);
+			break;
+
+		case GSW_PORT_MONITOR_LEARNING_LIMIT:
+			gsw_w32(cdev, (PCE_PCTRL_3_VIO_6_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_VIO_6_SHIFT,
+				PCE_PCTRL_3_VIO_6_SIZE, 1);
+			break;
+
+		case GSW_PORT_MONITOR_PORT_LOCK:
+			gsw_w32(cdev, (PCE_PCTRL_3_VIO_7_OFFSET + (0xA * pidx)),
+				PCE_PCTRL_3_VIO_7_SHIFT,
+				PCE_PCTRL_3_VIO_7_SIZE, 1);
+			break;
+		}
+	} else {
+		// TODO: Port Mirroring uses CTP port configuration
+	}
+
+	if (parm->eEnable == GSW_PORT_ENABLE_RXTX) {
+		PEN = 1;
+		EN = 1;
+	} else if (parm->eEnable == GSW_PORT_ENABLE_RX) {
+		PEN = 1;
+		EN = 0;
+	} else if (parm->eEnable == GSW_PORT_ENABLE_TX) {
+		PEN = 0;
+		EN = 1;
+	} else {
+		PEN = 0;
+		EN = 0;
+	}
+
+	/* Set SDMA_PCTRL_PEN PORT enable */
+	gsw_w32(cdev, (SDMA_PCTRL_PEN_OFFSET + (6 * pidx)),
+		SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE, PEN);
+	/* Set FDMA_PCTRL_EN PORT enable  */
+	gsw_w32(cdev, (FDMA_PCTRL_EN_OFFSET + (0x6 * pidx)),
+		FDMA_PCTRL_EN_SHIFT, FDMA_PCTRL_EN_SIZE, EN);
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (parm->bIfCounters == 1) {
+			gsw_w32(cdev, (BM_RMON_CTRL_IFRMONFST_OFFSET + (0x2 * pidx)),
+				BM_RMON_CTRL_IFRMONFST_SHIFT, BM_RMON_CTRL_IFRMONFST_SIZE, parm->nIfCountStartIdx);
+		}
+
+		gsw_w32(cdev, (BM_RMON_CTRL_IFRMONMD_OFFSET + (0x2 * pidx)),
+			BM_RMON_CTRL_IFRMONMD_SHIFT, BM_RMON_CTRL_IFRMONMD_SIZE, parm->eIfRMONmode);
+	}
+
+	ret = GSW_statusOk;
+
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+
+#if defined(CONFIG_LTQ_STP) && CONFIG_LTQ_STP
+GSW_return_t GSW_STP_BPDU_RuleGet(void *cdev,
+				  GSW_STP_BPDU_Rule_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	stp8021x_t *scfg;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	scfg = &gswdev->stpconfig;
+	parm->eForwardPort = scfg->spstate;
+	parm->nForwardPortId = scfg->stppid;
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_STP_BPDU_RuleSet(void *cdev,
+				  GSW_STP_BPDU_Rule_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	stp8021x_t *scfg = &gswdev->stpconfig;
+	static GSW_PCE_rule_t pcrule;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	scfg->spstate = parm->eForwardPort;
+	scfg->stppid = parm->nForwardPortId;
+	memset(&pcrule, 0, sizeof(GSW_PCE_rule_t));
+	/* Attached the PCE rule for BPDU packet */
+	pcrule.pattern.nIndex = BPDU_PCE_RULE_INDEX;
+	pcrule.pattern.bEnable = 1;
+	pcrule.pattern.bMAC_DstEnable = 1;
+	pcrule.pattern.nMAC_Dst[0] = 0x01;
+	pcrule.pattern.nMAC_Dst[1] = 0x80;
+	pcrule.pattern.nMAC_Dst[2] = 0xC2;
+	pcrule.pattern.nMAC_Dst[3] = 0x00;
+	pcrule.pattern.nMAC_Dst[4] = 0x00;
+	pcrule.pattern.nMAC_Dst[5] = 0x00;
+	pcrule.action.eCrossStateAction	= GSW_PCE_ACTION_CROSS_STATE_CROSS;
+
+	if ((scfg->spstate < 4) && (scfg->spstate > 0))
+		pcrule.action.ePortMapAction = scfg->spstate + 1;
+	else {
+		pr_err("(Incorrect forward port action) %s:%s:%d\n",
+		       __FILE__, __func__, __LINE__);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	pcrule.action.nForwardPortMap[0] = (1 << scfg->stppid); //Govind - Can occur out of array bounds problem.
+
+	/* We prepare everything and write into PCE Table */
+	if (0 != pce_rule_write(cdev, &gswdev->phandler, &pcrule)) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_STP_PortCfgGet(void *cdev, GSW_STP_portCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (parm->nPortId >= gswdev->tpnum) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		parm->ePortState = gswdev->pconfig[parm->nPortId].pcstate;
+	}
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if (parm->nPortId >= gswdev->num_of_bridge_port) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/*If Bridge Port ID is valid,Check whether it is InUSE
+		  if not InUse,return ERROR*/
+		if (!(gswdev->brdgeportconfig_idx[parm->nPortId].IndexInUse)) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		parm->ePortState = gswdev->brdgeportconfig_idx[parm->nPortId].StpState;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_STP_PortCfgSet(void *cdev, GSW_STP_portCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 StpState, P8021xState;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (parm->nPortId >= gswdev->tpnum) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		gswdev->pconfig[parm->nPortId].pcstate = parm->ePortState;
+		/* Config the Table */
+		set_port_state(cdev, parm->nPortId,
+			       gswdev->pconfig[parm->nPortId].pcstate,
+			       gswdev->pconfig[parm->nPortId].p8021xs);
+	}
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if (parm->nPortId >= gswdev->num_of_bridge_port) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/*If Bridge Port ID is valid,Check whether it is InUSE
+		  if not InUse,return ERROR*/
+		if (!(gswdev->brdgeportconfig_idx[parm->nPortId].IndexInUse)) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		StpState = parm->ePortState;
+		P8021xState = gswdev->brdgeportconfig_idx[parm->nPortId].P8021xState;
+		gswdev->brdgeportconfig_idx[parm->nPortId].StpState = StpState;
+
+		/* Config the Table */
+		set_port_state(cdev, parm->nPortId, StpState, P8021xState);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_TrunkingCfgGet(void *cdev, GSW_trunkingCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	/* Supported for GSWIP 2.2 and newer and returns */
+	/* with an error for older hardware revisions. */
+	if (gswdev->gipver != LTQ_GSWIP_2_0) {
+		/* Destination IP Mask */
+		gsw_r32(cdev, PCE_TRUNK_CONF_DIP_OFFSET,
+			PCE_TRUNK_CONF_DIP_SHIFT,
+			PCE_TRUNK_CONF_DIP_SIZE, &parm->bIP_Dst);
+		/* 'Source IP Mask */
+		gsw_r32(cdev, PCE_TRUNK_CONF_SIP_OFFSET,
+			PCE_TRUNK_CONF_SIP_SHIFT,
+			PCE_TRUNK_CONF_SIP_SIZE, &parm->bIP_Src);
+		/* Destination MAC Mask */
+		gsw_r32(cdev, PCE_TRUNK_CONF_DA_OFFSET,
+			PCE_TRUNK_CONF_DA_SHIFT,
+			PCE_TRUNK_CONF_DA_SIZE, &parm->bMAC_Dst);
+		/* 'Source MAC Mask */
+		gsw_r32(cdev, PCE_TRUNK_CONF_SA_OFFSET,
+			PCE_TRUNK_CONF_SA_SHIFT,
+			PCE_TRUNK_CONF_SA_SIZE, &parm->bMAC_Src);
+		ret = GSW_statusOk;
+		goto UNLOCK_AND_RETURN;
+	} else {
+		ret = GSW_statusNoSupport;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_TrunkingCfgSet(void *cdev,
+				GSW_trunkingCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	/* Supported for GSWIP 2.2 and newer and returns */
+	/* with an error for older hardware revisions. */
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (gswdev->gipver != LTQ_GSWIP_2_0) {
+		/* Destination IP Mask */
+		if (parm->bIP_Dst == 1) {
+			gsw_w32(cdev, PCE_TRUNK_CONF_DIP_OFFSET,
+				PCE_TRUNK_CONF_DIP_SHIFT,
+				PCE_TRUNK_CONF_DIP_SIZE, 1);
+		} else {
+			gsw_w32(cdev, PCE_TRUNK_CONF_DIP_OFFSET,
+				PCE_TRUNK_CONF_DIP_SHIFT,
+				PCE_TRUNK_CONF_DIP_SIZE, 0);
+		}
+
+		/* 'Source IP Mask */
+		if (parm->bIP_Src == 1) {
+			gsw_w32(cdev, PCE_TRUNK_CONF_SIP_OFFSET,
+				PCE_TRUNK_CONF_SIP_SHIFT,
+				PCE_TRUNK_CONF_SIP_SIZE, 1);
+		} else {
+			gsw_w32(cdev, PCE_TRUNK_CONF_SIP_OFFSET,
+				PCE_TRUNK_CONF_SIP_SHIFT,
+				PCE_TRUNK_CONF_SIP_SIZE, 0);
+		}
+
+		/* Destination MAC Mask */
+		if (parm->bMAC_Dst == 1) {
+			gsw_w32(cdev, PCE_TRUNK_CONF_DA_OFFSET,
+				PCE_TRUNK_CONF_DA_SHIFT,
+				PCE_TRUNK_CONF_DA_SIZE, 1);
+		} else {
+			gsw_w32(cdev, PCE_TRUNK_CONF_DA_OFFSET,
+				PCE_TRUNK_CONF_DA_SHIFT,
+				PCE_TRUNK_CONF_DA_SIZE, 0);
+		}
+
+		/* 'Source MAC Mask */
+		if (parm->bMAC_Src == 1) {
+			gsw_w32(cdev, PCE_TRUNK_CONF_SA_OFFSET,
+				PCE_TRUNK_CONF_SA_SHIFT,
+				PCE_TRUNK_CONF_SA_SIZE, 1);
+		} else {
+			gsw_w32(cdev, PCE_TRUNK_CONF_SA_OFFSET,
+				PCE_TRUNK_CONF_SA_SHIFT,
+				PCE_TRUNK_CONF_SA_SIZE, 0);
+		}
+
+		ret = GSW_statusOk;
+		goto UNLOCK_AND_RETURN;
+	} else {
+		ret = GSW_statusNoSupport;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_TrunkingPortCfgGet(void *cdev,
+				    GSW_trunkingPortCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+	u32 value;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= (gswdev->tpnum)) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/* Supported for GSWIP 2.2 and newer and returns with */
+	/* an error for older hardware revisions. */
+	if (gswdev->gipver != LTQ_GSWIP_2_0) {
+		/** Ports are aggregated. the 'nPortId' and the */
+		/* 'nAggrPortId' ports form an aggregated link. */
+		gsw_r32(cdev, (PCE_PTRUNK_EN_OFFSET + (parm->nPortId * 0x2)),
+			PCE_PTRUNK_EN_SHIFT, PCE_PTRUNK_EN_SIZE, &value);
+		parm->bAggregateEnable = value;
+		gsw_r32(cdev, (PCE_PTRUNK_PARTER_OFFSET + (parm->nPortId * 0x2)),
+			PCE_PTRUNK_PARTER_SHIFT, PCE_PTRUNK_PARTER_SIZE, &value);
+		parm->nAggrPortId = value;
+		ret = GSW_statusOk;
+		goto UNLOCK_AND_RETURN;
+	} else {
+		ret = GSW_statusNoSupport;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_TrunkingPortCfgSet(void *cdev, GSW_trunkingPortCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= (gswdev->tpnum)) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/* Supported for GSWIP 2.2 and newer and returns */
+	/* with an error for older hardware revisions. */
+	if (gswdev->gipver != LTQ_GSWIP_2_0) {
+		/** Ports are aggregated. the 'nPortId' and the */
+		/* 'nAggrPortId' ports form an aggregated link.*/
+		if (parm->bAggregateEnable == 1) {
+			gsw_w32(cdev, (PCE_PTRUNK_EN_OFFSET + (parm->nPortId * 0x2)),
+				PCE_PTRUNK_EN_SHIFT, PCE_PTRUNK_EN_SIZE, 1);
+			gsw_w32(cdev, (PCE_PTRUNK_PARTER_OFFSET + (parm->nPortId * 0x2)),
+				PCE_PTRUNK_PARTER_SHIFT, PCE_PTRUNK_PARTER_SIZE, (parm->nAggrPortId & 0xF));
+		} else {
+			gsw_w32(cdev, (PCE_PTRUNK_EN_OFFSET + (parm->nPortId * 0x2)),
+				PCE_PTRUNK_EN_SHIFT, PCE_PTRUNK_EN_SIZE, 0);
+		}
+
+		ret = GSW_statusOk;
+		goto UNLOCK_AND_RETURN;
+	} else {
+		ret = GSW_statusNoSupport;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_TimestampTimerSet(void *cdev, GSW_TIMESTAMP_Timer_t *parm)
+{
+	u32 value;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	/* Supported for GSWIP 2.2 and newer and returns with */
+	/* an error for older hardware revisions. */
+	if (gswdev->gipver != LTQ_GSWIP_2_0) {
+		/** Second. Absolute second timer count. */
+		gsw_w32(cdev, (TIMER_SEC_LSB_SECLSB_OFFSET),
+			TIMER_SEC_LSB_SECLSB_SHIFT,
+			TIMER_SEC_LSB_SECLSB_SIZE, (parm->nSec & 0xFFFF));
+		gsw_w32(cdev, (TIMER_SEC_MSB_SECMSB_OFFSET),
+			TIMER_SEC_MSB_SECMSB_SHIFT,
+			TIMER_SEC_MSB_SECMSB_SIZE,
+			((parm->nSec >> 16) & 0xFFFF));
+		/** Nano Second. Absolute nano second timer count.*/
+		gsw_w32(cdev, (TIMER_NS_LSB_NSLSB_OFFSET),
+			TIMER_NS_LSB_NSLSB_SHIFT,
+			TIMER_NS_LSB_NSLSB_SIZE,
+			(parm->nNanoSec & 0xFFFF));
+		gsw_w32(cdev, (TIMER_NS_MSB_NSMSB_OFFSET),
+			TIMER_NS_MSB_NSMSB_SHIFT,
+			TIMER_NS_MSB_NSMSB_SIZE,
+			((parm->nNanoSec >> 16) & 0xFFFF));
+		/** Fractional Nano Second. Absolute fractional nano */
+		/* second timer count. This counter specifis a */
+		/* 2^32 fractional 'nNanoSec'. */
+		gsw_w32(cdev, (TIMER_FS_LSB_FSLSB_OFFSET),
+			TIMER_FS_LSB_FSLSB_SHIFT,
+			TIMER_FS_LSB_FSLSB_SIZE,
+			(parm->nFractionalNanoSec & 0xFFFF));
+		gsw_w32(cdev, (TIMER_FS_MSB_FSMSB_OFFSET),
+			TIMER_FS_MSB_FSMSB_SHIFT,
+			TIMER_FS_MSB_FSMSB_SIZE,
+			((parm->nFractionalNanoSec >> 16) & 0xFFFF));
+		value = 1;
+		gsw_w32(cdev, (TIMER_CTRL_WR_OFFSET),
+			TIMER_CTRL_WR_SHIFT,
+			TIMER_CTRL_WR_SIZE, value);
+
+		CHECK_BUSY(TIMER_CTRL_WR_OFFSET,
+			   TIMER_CTRL_WR_SHIFT, TIMER_CTRL_WR_SIZE, RETURN_FROM_FUNCTION);
+
+
+		ret = GSW_statusOk;
+		goto UNLOCK_AND_RETURN;
+	} else {
+		ret = GSW_statusNoSupport;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_TimestampTimerGet(void *cdev,
+				   GSW_TIMESTAMP_Timer_t *parm)
+{
+	u32 value;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+	value = 1;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	/* Supported for GSWIP 2.2 and newer and returns */
+	/* with an error for older hardware revisions. */
+	if (gswdev->gipver != LTQ_GSWIP_2_0) {
+		gsw_w32(cdev, (TIMER_CTRL_RD_OFFSET),
+			TIMER_CTRL_RD_SHIFT,
+			TIMER_CTRL_RD_SIZE, value);
+
+		CHECK_BUSY(TIMER_CTRL_RD_OFFSET,
+			   TIMER_CTRL_RD_SHIFT, TIMER_CTRL_RD_SIZE, RETURN_FROM_FUNCTION);
+
+		/** Second. Absolute second timer count. */
+		gsw_r32(cdev, (TIMER_SEC_LSB_SECLSB_OFFSET),
+			TIMER_SEC_LSB_SECLSB_SHIFT,
+			TIMER_SEC_LSB_SECLSB_SIZE, &value);
+		parm->nSec = value & 0xFFFF;
+		gsw_r32(cdev, (TIMER_SEC_MSB_SECMSB_OFFSET),
+			TIMER_SEC_MSB_SECMSB_SHIFT,
+			TIMER_SEC_MSB_SECMSB_SIZE, &value);
+		parm->nSec |= (value & 0xFFFF << 16);
+		/** Nano Second. Absolute nano second timer count. */
+		gsw_r32(cdev, (TIMER_NS_LSB_NSLSB_OFFSET),
+			TIMER_NS_LSB_NSLSB_SHIFT,
+			TIMER_NS_LSB_NSLSB_SIZE, &value);
+		parm->nNanoSec = value & 0xFFFF;
+		gsw_r32(cdev, (TIMER_NS_MSB_NSMSB_OFFSET),
+			TIMER_NS_MSB_NSMSB_SHIFT,
+			TIMER_NS_MSB_NSMSB_SIZE, &value);
+		parm->nNanoSec |= (value & 0xFFFF << 16);
+		/** Fractional Nano Second. Absolute fractional */
+		/* nano second timer count. */
+		/*	This counter specifis a 2^32 fractional 'nNanoSec'. */
+		gsw_r32(cdev, (TIMER_FS_LSB_FSLSB_OFFSET),
+			TIMER_FS_LSB_FSLSB_SHIFT,
+			TIMER_FS_LSB_FSLSB_SIZE, &value);
+		parm->nFractionalNanoSec = value & 0xFFFF;
+		gsw_r32(cdev, (TIMER_FS_MSB_FSMSB_OFFSET),
+			TIMER_FS_MSB_FSMSB_SHIFT,
+			TIMER_FS_MSB_FSMSB_SIZE, &value);
+		parm->nFractionalNanoSec |= (value & 0xFFFF << 16);
+		ret = GSW_statusOk;
+		goto UNLOCK_AND_RETURN;
+	} else {
+		ret = GSW_statusNoSupport;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+GSW_return_t GSW_TimestampPortRead(void *cdev,
+				   GSW_TIMESTAMP_PortRead_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 tstamp0, tstamp1;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= ((gswdev->tpnum - 1))) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/* Supported for GSWIP 2.2 and newer and returns */
+	/* with an error for older hardware revisions. */
+	if (gswdev->gipver != LTQ_GSWIP_2_0) {
+		/** Second. Absolute second timer count. */
+		gsw_r32(cdev, (FDMA_TSTAMP0_TSTL_OFFSET +
+			       (parm->nPortId * 0x6)),
+			FDMA_TSTAMP0_TSTL_SHIFT,
+			FDMA_TSTAMP0_TSTL_SIZE, &tstamp0);
+		gsw_r32(cdev, (FDMA_TSTAMP1_TSTH_OFFSET +
+			       (parm->nPortId * 0x6)),
+			FDMA_TSTAMP1_TSTH_SHIFT,
+			FDMA_TSTAMP1_TSTH_SIZE, &tstamp1);
+		parm->nEgressSec = ((tstamp0 | (tstamp1 << 16))) >> 30;
+		parm->nEgressNanoSec = (((tstamp0 | (tstamp1 << 16)))
+					& 0x7FFFFFFF);
+		/** Nano Second. Absolute nano second timer count. */
+		gsw_r32(cdev, (SDMA_TSTAMP0_TSTL_OFFSET +
+			       (parm->nPortId * 0x6)),
+			SDMA_TSTAMP0_TSTL_SHIFT,
+			SDMA_TSTAMP0_TSTL_SIZE, &tstamp0);
+		gsw_r32(cdev, (SDMA_TSTAMP1_TSTH_OFFSET +
+			       (parm->nPortId * 0x6)),
+			SDMA_TSTAMP1_TSTH_SHIFT,
+			SDMA_TSTAMP1_TSTH_SIZE, &tstamp1);
+		parm->nIngressSec = ((tstamp0 | (tstamp1 << 16))) >> 30;
+		parm->nIngressNanoSec = (((tstamp0 | (tstamp1 << 16)))
+					 & 0x7FFFFFFF);
+		ret = GSW_statusOk;
+		goto UNLOCK_AND_RETURN;
+	} else {
+		ret = GSW_statusNoSupport;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+#endif /* CONFIG_LTQ_STP */
+#if defined(CONFIG_LTQ_VLAN) && CONFIG_LTQ_VLAN
+GSW_return_t GSW_VLAN_Member_Init(void *cdev,
+				  GSW_VLAN_memberInit_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		pctbl_prog_t pcetable;
+		u16 pcindex;
+
+		for (pcindex = 0; pcindex < 4096; pcindex++) {
+			memset(&pcetable, 0, sizeof(pctbl_prog_t));
+			pcetable.pcindex = pcindex;
+			pcetable.table = PCE_VLANMAP_INDEX;
+			gsw_pce_table_read(cdev, &pcetable);
+			pcetable.pcindex = pcindex;
+			pcetable.table = PCE_VLANMAP_INDEX;
+			pcetable.val[1] = (parm->nPortMemberMap & 0xFFFF);
+			pcetable.val[2] = (parm->nEgressTagMap & 0xFFFF);
+			gsw_pce_table_write(cdev, &pcetable);
+		}
+
+		ret = GSW_statusOk;
+		goto UNLOCK_AND_RETURN;
+	} else {
+		ret = GSW_statusNoSupport;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_VLAN_IdCreate(void *cdev,
+			       GSW_VLAN_IdCreate_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.pcindex = parm->nVId;
+		pcetable.table = PCE_VLANMAP_INDEX;
+		pcetable.val[0] = (parm->nFId & 0x3F);
+		gsw_pce_table_write(cdev, &pcetable);
+	} else {
+		u8 pcindex;
+		avlan_tbl_t avlantbl;
+
+		if (find_active_vlan_index(cdev, parm->nVId) != 0xFF) {
+			pr_err("This vid exists\n");
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		pcindex = fempty_avlan_index_table(cdev);
+
+		if (pcindex == 0xFF) {
+			pr_err("There is no table entry avariable\n");
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		memset(&avlantbl, 0, sizeof(avlan_tbl_t));
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		avlantbl.valid = 1;
+		avlantbl.vid = parm->nVId;
+		avlantbl.fid = parm->nFId;
+
+		if (pcindex >= 64) {
+			ret = GSW_statusValueRange;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		vlan_entry_set(cdev, pcindex, &avlantbl);
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.pcindex = pcindex;
+		pcetable.table = PCE_ACTVLAN_INDEX;
+		pcetable.key[0] = parm->nVId;
+		pcetable.val[0] = parm->nFId;
+		pcetable.valid = 1;
+		gsw_pce_table_write(cdev, &pcetable);
+		pcetable.table = PCE_VLANMAP_INDEX;
+		pcetable.val[0] = parm->nVId;
+		pcetable.val[1] = 0;
+		pcetable.val[2] = 0;
+		gsw_pce_table_write(cdev, &pcetable);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_VLAN_IdDelete(void *cdev,
+			       GSW_VLAN_IdDelete_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.pcindex = parm->nVId;
+		pcetable.table = PCE_VLANMAP_INDEX;
+		gsw_pce_table_write(cdev, &pcetable);
+	} else {
+		u8 pcindex;
+		avlan_tbl_t avlantbl;
+		ltq_pce_table_t *pcvtbl = &gswdev->phandler;
+		memset(&avlantbl, 0, sizeof(avlan_tbl_t));
+		pcindex = find_active_vlan_index(cdev, parm->nVId);
+
+		if (pcindex == 0xFF) {
+			pr_err("(VID not exists) %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (gavlan_tbl_index(&pcvtbl->pce_sub_tbl,
+				     pcindex) != GSW_statusOk) {
+			pr_err("(VID: 0x%0x used by flow table) %s:%s:%d\n",
+			       parm->nVId, __FILE__, __func__, __LINE__);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (pcindex >= 64) {
+			ret = GSW_statusValueRange;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		vlan_entry_set(cdev, pcindex, &avlantbl);
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.pcindex = pcindex;
+		pcetable.table = PCE_ACTVLAN_INDEX;
+		pcetable.valid = 0;
+		gsw_pce_table_write(cdev, &pcetable);
+		pcetable.table = PCE_VLANMAP_INDEX;
+		gsw_pce_table_write(cdev, &pcetable);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_VLAN_IdGet(void *cdev, GSW_VLAN_IdGet_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.pcindex = parm->nVId;
+		pcetable.table = PCE_VLANMAP_INDEX;
+		gsw_pce_table_read(cdev, &pcetable);
+		parm->nFId = pcetable.val[0] & 0x3F;
+	} else {
+		u8 pcindex;
+		avlan_tbl_t avlantbl;
+		pcindex = find_active_vlan_index(cdev, parm->nVId);
+
+		if (pcindex == 0xFF) {
+			pr_err("(VID not exists) %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (pcindex >= 64) {
+			ret = GSW_statusValueRange;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		get_vlan_sw_table(cdev, pcindex, &avlantbl);
+		parm->nFId = avlantbl.fid;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_VLAN_PortCfgGet(void *cdev,
+				 GSW_VLAN_portCfg_t *parm)
+{
+	u32 value;
+	int pcindex;
+	ltq_bool_t uvr, vimr, vemr;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	avlan_tbl_t avlantbl;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	gsw_r32(cdev, (PCE_DEFPVID_PVID_OFFSET + (10 * parm->nPortId)),
+		PCE_DEFPVID_PVID_SHIFT, PCE_DEFPVID_PVID_SIZE, &value);
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		parm->nPortVId = value;
+	} else {
+		pcindex = value;
+
+		if (pcindex >= 64) {
+			ret = GSW_statusValueRange;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		get_vlan_sw_table(cdev, pcindex, &avlantbl);
+		parm->nPortVId = avlantbl.vid;
+	}
+
+	gsw_r32(cdev, (PCE_VCTRL_UVR_OFFSET + (10 * parm->nPortId)),
+		PCE_VCTRL_UVR_SHIFT, PCE_VCTRL_UVR_SIZE, &value);
+	uvr = value;
+
+	if (uvr == 1)
+		parm->bVLAN_UnknownDrop = 1;
+	else
+		parm->bVLAN_UnknownDrop = 0;
+
+	gsw_r32(cdev, (PCE_VCTRL_VSR_OFFSET +
+		       (10 * parm->nPortId)),
+		PCE_VCTRL_VSR_SHIFT,
+		PCE_VCTRL_VSR_SIZE, &value);
+	parm->bVLAN_ReAssign = value;
+	gsw_r32(cdev, (PCE_VCTRL_VIMR_OFFSET +
+		       (10 * parm->nPortId)),
+		PCE_VCTRL_VIMR_SHIFT,
+		PCE_VCTRL_VIMR_SIZE, &value);
+	vimr = value;
+
+	gsw_r32(cdev, (PCE_VCTRL_VEMR_OFFSET +
+		       (10 * parm->nPortId)),
+		PCE_VCTRL_VEMR_SHIFT,
+		PCE_VCTRL_VEMR_SIZE, &value);
+	vemr = value;
+
+	if (vimr == 0 && vemr == 0)
+		parm->eVLAN_MemberViolation = GSW_VLAN_MEMBER_VIOLATION_NO;
+	else if (vimr == 1 && vemr == 0)
+		parm->eVLAN_MemberViolation = GSW_VLAN_MEMBER_VIOLATION_INGRESS;
+	else if (vimr == 0 && vemr == 1)
+		parm->eVLAN_MemberViolation = GSW_VLAN_MEMBER_VIOLATION_EGRESS;
+	else if (vimr == 1 && vemr == 1)
+		parm->eVLAN_MemberViolation = GSW_VLAN_MEMBER_VIOLATION_BOTH;
+
+	gsw_r32(cdev, (PCE_VCTRL_VINR_OFFSET +
+		       (10 * parm->nPortId)),
+		PCE_VCTRL_VINR_SHIFT,
+		PCE_VCTRL_VINR_SIZE, &value);
+
+	switch (value) {
+	case 0:
+		parm->eAdmitMode = GSW_VLAN_ADMIT_ALL;
+		break;
+
+	case 1:
+		parm->eAdmitMode = GSW_VLAN_ADMIT_TAGGED;
+		break;
+
+	case 2:
+		parm->eAdmitMode = GSW_VLAN_ADMIT_UNTAGGED;
+		break;
+
+	default:
+		break;
+	}
+
+	gsw_r32(cdev, (PCE_PCTRL_0_TVM_OFFSET +
+		       (10 * parm->nPortId)),
+		PCE_PCTRL_0_TVM_SHIFT,
+		PCE_PCTRL_0_TVM_SIZE, &value);
+	parm->bTVM = value;
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_VLAN_PortCfgSet(void *cdev,
+				 GSW_VLAN_portCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value;
+	u8 pcindex;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		value = parm->nPortVId;
+	} else {
+		pcindex = find_active_vlan_index(cdev, parm->nPortVId);
+
+		if (pcindex == 0xFF) {
+			pr_err("(VID not exists) %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		value = pcindex;
+	}
+
+	gsw_w32(cdev, (PCE_DEFPVID_PVID_OFFSET +
+		       (10 * parm->nPortId)),
+		PCE_DEFPVID_PVID_SHIFT,
+		PCE_DEFPVID_PVID_SIZE, value);
+	value = 0;
+
+	if (parm->bVLAN_UnknownDrop == 1)
+		value = 1;
+
+	gsw_w32(cdev, (PCE_VCTRL_UVR_OFFSET +
+		       (10 * parm->nPortId)),
+		PCE_VCTRL_UVR_SHIFT,
+		PCE_VCTRL_UVR_SIZE, value);
+	value = parm->bVLAN_ReAssign;
+	gsw_w32(cdev, (PCE_VCTRL_VSR_OFFSET +
+		       (10 * parm->nPortId)),
+		PCE_VCTRL_VSR_SHIFT,
+		PCE_VCTRL_VSR_SIZE, value);
+
+	switch (parm->eVLAN_MemberViolation) {
+	case GSW_VLAN_MEMBER_VIOLATION_NO:
+		gsw_w32(cdev, (PCE_VCTRL_VIMR_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_VCTRL_VIMR_SHIFT,
+			PCE_VCTRL_VIMR_SIZE, 0);
+		gsw_w32(cdev, (PCE_VCTRL_VEMR_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_VCTRL_VEMR_SHIFT,
+			PCE_VCTRL_VEMR_SIZE, 0);
+		break;
+
+	case GSW_VLAN_MEMBER_VIOLATION_INGRESS:
+		gsw_w32(cdev, (PCE_VCTRL_VIMR_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_VCTRL_VIMR_SHIFT,
+			PCE_VCTRL_VIMR_SIZE, 1);
+		gsw_w32(cdev, (PCE_VCTRL_VEMR_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_VCTRL_VEMR_SHIFT,
+			PCE_VCTRL_VEMR_SIZE, 0);
+		break;
+
+	case GSW_VLAN_MEMBER_VIOLATION_EGRESS:
+		gsw_w32(cdev, (PCE_VCTRL_VIMR_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_VCTRL_VIMR_SHIFT,
+			PCE_VCTRL_VIMR_SIZE, 0);
+		gsw_w32(cdev, (PCE_VCTRL_VEMR_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_VCTRL_VEMR_SHIFT,
+			PCE_VCTRL_VEMR_SIZE, 1);
+		break;
+
+	case GSW_VLAN_MEMBER_VIOLATION_BOTH:
+		gsw_w32(cdev, (PCE_VCTRL_VIMR_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_VCTRL_VIMR_SHIFT,
+			PCE_VCTRL_VIMR_SIZE, 1);
+		gsw_w32(cdev, (PCE_VCTRL_VEMR_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_VCTRL_VEMR_SHIFT,
+			PCE_VCTRL_VEMR_SIZE, 1);
+		break;
+
+	default:
+		pr_err("WARNING:(eVLAN_MemberViolation) %s:%s:%d\n",
+		       __FILE__, __func__, __LINE__);
+	}
+
+	switch (parm->eAdmitMode) {
+	case GSW_VLAN_ADMIT_ALL:
+		value = 0;
+		break;
+
+	case GSW_VLAN_ADMIT_TAGGED:
+		value = 1;
+		break;
+
+	case GSW_VLAN_ADMIT_UNTAGGED:
+		value = 2;
+		break;
+
+	default:
+		value = 0;
+		pr_err("%s:%s:%d (eAdmitMode)\n",
+		       __FILE__, __func__, __LINE__);
+	}
+
+	gsw_w32(cdev, (PCE_VCTRL_VINR_OFFSET +
+		       (10 * parm->nPortId)),
+		PCE_VCTRL_VINR_SHIFT,
+		PCE_VCTRL_VINR_SIZE, value);
+	value = 0;
+
+	if (parm->bTVM == 1)
+		value = 1;
+
+	gsw_w32(cdev, (PCE_PCTRL_0_TVM_OFFSET +
+		       (10 * parm->nPortId)),
+		PCE_PCTRL_0_TVM_SHIFT,
+		PCE_PCTRL_0_TVM_SIZE, value);
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_VLAN_PortMemberAdd(void *cdev,
+				    GSW_VLAN_portMemberAdd_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if ((parm->nPortId >= gswdev->tpnum) &&
+	    (!(parm->nPortId & 0x80000000))) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+
+	}
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		u16  portmap, tagmap, val0;
+
+		if (parm->nVId > 4096) {
+			pr_err("ERROR: %s:%s:%d, (VID:%d)\n",
+			       __FILE__, __func__, __LINE__, parm->nVId);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.table = PCE_VLANMAP_INDEX;
+		pcetable.pcindex = parm->nVId;
+		gsw_pce_table_read(cdev, &pcetable);
+		portmap	= (pcetable.val[1]);
+		tagmap = (pcetable.val[2]);
+		val0 = (pcetable.val[0]);
+
+		/*  Support  portmap information. */
+		/*  To differentiate between port index and portmap, */
+		/* the MSB (highest data bit) should be 1.*/
+		if (parm->nPortId & 0x80000000) { /*Port Map */
+			portmap |= ((parm->nPortId) & 0xFFFF);
+
+			if (parm->bVLAN_TagEgress)
+				tagmap |= ((parm->nPortId) & 0xFFFF);
+			else
+				tagmap &= ~((parm->nPortId) & 0xFFFF);
+		} else {
+			portmap |= 1 << parm->nPortId;
+
+			if (parm->bVLAN_TagEgress)
+				tagmap |= 1 << parm->nPortId;
+			else
+				tagmap &= ~(1 << parm->nPortId);
+		}
+
+		pcetable.table = PCE_VLANMAP_INDEX;
+		pcetable.pcindex = parm->nVId;
+		pcetable.val[0] = val0;
+		pcetable.val[1] = portmap;
+		pcetable.val[2] = tagmap;
+		gsw_pce_table_write(cdev, &pcetable);
+	} else {
+		u8 pcindex;
+		avlan_tbl_t avlantbl;
+		pcindex = find_active_vlan_index(cdev,
+						 parm->nVId);
+
+		if (pcindex == 0xFF) {
+			pr_err("(VID not exists) %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (pcindex >= 64) {
+			ret = GSW_statusValueRange;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		get_vlan_sw_table(cdev, pcindex, &avlantbl);
+
+		if (avlantbl.reserved == 1) {
+			pr_err("(VID was already reserved) %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (parm->nPortId & 0x80000000) { /*Port Map */
+			avlantbl.pm |= ((parm->nPortId) & 0x7FFF);
+
+			if (parm->bVLAN_TagEgress)
+				avlantbl.tm |= ((parm->nPortId) & 0x7FFF);
+			else
+				avlantbl.tm &= ~((parm->nPortId) & 0x7FFF);
+		} else {
+			avlantbl.pm |= 1 << parm->nPortId;
+
+			if (parm->bVLAN_TagEgress)
+				avlantbl.tm |= 1 << parm->nPortId;
+			else
+				avlantbl.tm &= ~(1 << parm->nPortId);
+		}
+
+		if (pcindex >= 64) {
+			ret = GSW_statusValueRange;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		vlan_entry_set(cdev, pcindex, &avlantbl);
+		pcetable.table = PCE_VLANMAP_INDEX;
+		pcetable.pcindex = pcindex;
+		gsw_pce_table_read(cdev, &pcetable);
+		pcetable.table = PCE_VLANMAP_INDEX;
+		pcetable.pcindex = pcindex;
+		pcetable.val[1] = avlantbl.pm;
+		pcetable.val[2] = avlantbl.tm;
+		gsw_pce_table_write(cdev, &pcetable);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_VLAN_PortMemberRead(void *cdev,
+				     GSW_VLAN_portMemberRead_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (parm->bInitial == 1) {
+		/*Start from the index 0 */
+		gswdev->vlan_rd_index = 0;
+		pcetable.table = PCE_VLANMAP_INDEX;
+		pcetable.pcindex = gswdev->vlan_rd_index;
+		gsw_pce_table_read(cdev, &pcetable);
+		parm->nVId = gswdev->vlan_rd_index;
+		/* Port Map */
+		parm->nPortId = (pcetable.val[1] | 0x80000000);
+		parm->nTagId = (pcetable.val[2] | 0x80000000);
+		parm->bInitial = 0;
+		parm->bLast = 0;
+	}
+
+	if (parm->bLast != 1) {
+		if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+		    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+			if (gswdev->vlan_rd_index < 4096) {
+				gswdev->vlan_rd_index++;
+				pcetable.table = PCE_VLANMAP_INDEX;
+				pcetable.pcindex = gswdev->vlan_rd_index;
+				gsw_pce_table_read(cdev, &pcetable);
+				parm->nVId = gswdev->vlan_rd_index;
+				/* Port Map */
+				parm->nPortId = (pcetable.val[1] | 0x80000000);
+				parm->nTagId = (pcetable.val[2] | 0x80000000);
+			} else {
+				parm->bLast = 1;
+				gswdev->vlan_rd_index = 0;
+			}
+		} else {
+			if (gswdev->vlan_rd_index < gswdev->avlantsz) {
+				gswdev->vlan_rd_index++;
+				pcetable.table = PCE_VLANMAP_INDEX;
+				pcetable.pcindex = gswdev->vlan_rd_index;
+				gsw_pce_table_read(cdev, &pcetable);
+				parm->nVId = (pcetable.val[0] & 0xFFF);
+				/* Port Map */
+				parm->nPortId = (pcetable.val[1] | 0x80000000);
+				parm->nTagId = (pcetable.val[2] | 0x80000000);
+			} else {
+				parm->bLast = 1;
+				gswdev->vlan_rd_index = 0;
+			}
+		}
+	}
+
+	ret = GSW_statusOk;
+
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_VLAN_PortMemberRemove(void *cdev,
+				       GSW_VLAN_portMemberRemove_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if ((parm->nPortId >= gswdev->tpnum) &&
+	    (!(parm->nPortId & 0x80000000))) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		u16  portmap, tagmap, val0;
+
+		if (parm->nVId > 4096) {
+			pr_err("ERROR: %s:%s:%d, (VID:%d)\n",
+			       __FILE__, __func__, __LINE__, parm->nVId);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.table = PCE_VLANMAP_INDEX;
+		pcetable.pcindex = parm->nVId;
+		gsw_pce_table_read(cdev, &pcetable);
+		portmap	= (pcetable.val[1]);
+		tagmap = (pcetable.val[2]);
+		val0 = (pcetable.val[0]);
+
+		if (parm->nPortId & 0x80000000)
+			portmap  &= ~((parm->nPortId) & 0x7FFF);
+		else
+			portmap &= ~(1 << parm->nPortId);
+
+		tagmap &= ~(1 << parm->nPortId);
+		pcetable.table = PCE_VLANMAP_INDEX;
+		pcetable.pcindex = parm->nVId;
+		pcetable.val[0] = val0;
+		pcetable.val[1] = portmap;
+		pcetable.val[2] = tagmap;
+		gsw_pce_table_write(cdev, &pcetable);
+	} else {
+		avlan_tbl_t avlantbl;
+		u8 pcindex;
+		pcindex = find_active_vlan_index(cdev,
+						 parm->nVId);
+
+		if (pcindex == 0xFF) {
+			pr_err("This vid doesn't exists\n");
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (pcindex >= 64) {
+			ret = GSW_statusValueRange;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		get_vlan_sw_table(cdev, pcindex, &avlantbl);
+
+		if (parm->nPortId & 0x80000000)
+			avlantbl.pm  &= ~((parm->nPortId) & 0x7FFF);
+		else
+			avlantbl.pm &= ~(1 << parm->nPortId);
+
+		avlantbl.tm &= ~(1 << parm->nPortId);
+
+		if (pcindex >= 64) {
+			ret = GSW_statusValueRange;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		vlan_entry_set(cdev, pcindex, &avlantbl);
+		pcetable.table = PCE_VLANMAP_INDEX;
+		pcetable.pcindex = pcindex;
+		gsw_pce_table_read(cdev, &pcetable);
+
+		if (parm->nPortId & 0x80000000) {
+			pcetable.val[1] &= ~((parm->nPortId) & 0x7FFF);
+			pcetable.val[2] &= ~((parm->nPortId) & 0x7FFF);
+		} else {
+			pcetable.val[1] &= ~(1 << parm->nPortId);
+			pcetable.val[2] &= ~(1 << parm->nPortId);
+		}
+
+		gsw_pce_table_write(cdev, &pcetable);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_VLAN_ReservedAdd(void *cdev,
+				  GSW_VLAN_reserved_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		if (parm->nVId > 4096) {
+			pr_err("ERROR: %s:%s:%d,(VID:%d)\n",
+			       __FILE__, __func__, __LINE__, parm->nVId);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.table = PCE_VLANMAP_INDEX;
+		pcetable.pcindex = parm->nVId;
+		gsw_pce_table_read(cdev, &pcetable);
+		pcetable.val[0] |= (1 << 8);
+		gsw_pce_table_write(cdev, &pcetable);
+	} else {
+		u8 pcindex;
+		avlan_tbl_t avlantbl;
+		pcindex = find_active_vlan_index(cdev,
+						 parm->nVId);
+
+		if (pcindex == 0xFF) {
+			pr_err("(VID not exist, create VID) %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (pcindex >= 64) {
+			ret = GSW_statusValueRange;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		get_vlan_sw_table(cdev, pcindex, &avlantbl);
+
+		if (avlantbl.pm != 0) {
+			pr_err("(Added to member & can't be reserve %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (avlantbl.tm != 0) {
+			pr_err("(Added to member & can't be reserve %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		avlantbl.reserved = 1;
+
+		if (pcindex >= 64) {
+			ret = GSW_statusValueRange;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		vlan_entry_set(cdev, pcindex, &avlantbl);
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.pcindex = pcindex;
+		pcetable.table = PCE_ACTVLAN_INDEX;
+		pcetable.val[0] |= (1 << 8);
+		gsw_pce_table_write(cdev, &pcetable);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_VLAN_ReservedRemove(void *cdev,
+				     GSW_VLAN_reserved_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		if (parm->nVId > 4096) {
+			pr_err("ERROR: %s:%s:%d,(VID:%d)\n",
+			       __FILE__, __func__, __LINE__, parm->nVId);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.table = PCE_VLANMAP_INDEX;
+		pcetable.pcindex = parm->nVId;
+		gsw_pce_table_read(cdev, &pcetable);
+		pcetable.val[0] &= ~(1 << 8);
+		gsw_pce_table_write(cdev, &pcetable);
+	} else {
+		u8 pcindex;
+		avlan_tbl_t avlantbl;
+		pcindex = find_active_vlan_index(cdev, parm->nVId);
+
+		if (pcindex == 0xFF) {
+			pr_err("This vid doesn't exists, create VID first\n");
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (pcindex >= 64) {
+			ret = GSW_statusValueRange;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		get_vlan_sw_table(cdev, pcindex, &avlantbl);
+
+		if (avlantbl.pm != 0) {
+			pr_err("(Added to member & can't be remove the reserve %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (avlantbl.tm != 0) {
+			pr_err("(Added to member & can't be remove the reserve %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (pcindex >= 64) {
+			ret = GSW_statusValueRange;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (avlantbl.reserved == 0) {
+			pr_err("This VID was not reserve, reserve it first\n");
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		} else {
+			avlantbl.reserved = 0;
+			vlan_entry_set(cdev, pcindex, &avlantbl);
+		}
+
+		vlan_entry_set(cdev, pcindex, &avlantbl);
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.pcindex = pcindex;
+		pcetable.table = PCE_ACTVLAN_INDEX;
+		pcetable.val[0] &= ~(1 << 8);
+		gsw_pce_table_write(cdev, &pcetable);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_PCE_EG_VLAN_CfgSet(void *cdev,
+				    GSW_PCE_EgVLAN_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (parm->eEgVLANmode ==
+		    GSW_PCE_EG_VLAN_SUBIFID_BASED) {
+			gsw_w32(cdev, (PCE_EVLANCFG_EGVMD_OFFSET
+				       + (0x10 * parm->nPortId)),
+				PCE_EVLANCFG_EGVMD_SHIFT,
+				PCE_EVLANCFG_EGVMD_SIZE, 1);
+		} else {
+			gsw_w32(cdev, (PCE_EVLANCFG_EGVMD_OFFSET
+				       + (0x10 * parm->nPortId)),
+				PCE_EVLANCFG_EGVMD_SHIFT,
+				PCE_EVLANCFG_EGVMD_SIZE, 0);
+		}
+
+		gsw_w32(cdev, (PCE_EVLANCFG_EGVFST_OFFSET
+			       + (0x10 * parm->nPortId)),
+			PCE_EVLANCFG_EGVFST_SHIFT,
+			PCE_EVLANCFG_EGVFST_SIZE,
+			parm->nEgStartVLANIdx);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_PCE_EG_VLAN_CfgGet(void *cdev,
+				    GSW_PCE_EgVLAN_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return  GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	/*	if (parm->nPortId >= gswdev->tpnum) */
+	/*		ret = GSW_statusErr; */
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		gsw_r32(cdev, (PCE_EVLANCFG_EGVMD_OFFSET
+			       + (0x10 * parm->nPortId)),
+			PCE_EVLANCFG_EGVMD_SHIFT,
+			PCE_EVLANCFG_EGVMD_SIZE, &parm->eEgVLANmode);
+		gsw_r32(cdev, (PCE_EVLANCFG_EGVFST_OFFSET
+			       + (0x10 * parm->nPortId)),
+			PCE_EVLANCFG_EGVFST_SHIFT,
+			PCE_EVLANCFG_EGVFST_SIZE, &value);
+		parm->nEgStartVLANIdx = value;
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_PCE_EG_VLAN_EntryWrite(void *cdev,
+					GSW_PCE_EgVLAN_Entry_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	/*	if (parm->nPortId >= gswdev->tpnum) */
+	/*		ret = GSW_statusErr;*/
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.pcindex = (parm->nIndex & 0xFF);
+
+		if (parm->bEgVLAN_Action == 1)
+			pcetable.val[0] |= (1 << 0);
+
+		if (parm->bEgSVidRem_Action == 1)
+			pcetable.val[0] |= (1 << 2);
+
+		if (parm->bEgSVidIns_Action == 1)
+			pcetable.val[0] |= (1 << 3);
+
+		pcetable.val[0] |= ((parm->nEgSVid & 0xFFF) << 4);
+
+		if (parm->bEgCVidRem_Action == 1)
+			pcetable.val[1] |= (1 << 2);
+
+		if (parm->bEgCVidIns_Action == 1)
+			pcetable.val[1] |= (1 << 3);
+
+		pcetable.val[1] |= ((parm->nEgCVid & 0xFFF) << 4);
+		pcetable.table = PCE_EG_VLAN_INDEX;
+		gsw_pce_table_write(cdev, &pcetable);
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_PCE_EG_VLAN_EntryRead(void *cdev,
+				       GSW_PCE_EgVLAN_Entry_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	/*if (parm->nPortId >= gswdev->tpnum) */
+	/*	ret = GSW_statusErr; */
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.pcindex = (parm->nIndex & 0xFF);
+		pcetable.table = PCE_EG_VLAN_INDEX;
+		gsw_pce_table_read(cdev, &pcetable);
+		parm->bEgVLAN_Action = pcetable.val[0] & 0x1;
+		parm->bEgSVidRem_Action = (pcetable.val[0] >> 2) & 0x1;
+		parm->bEgSVidIns_Action = (pcetable.val[0] >> 3) & 0x1;
+		parm->nEgSVid = (pcetable.val[0] >> 4) & 0xFFF;
+		parm->bEgCVidRem_Action = (pcetable.val[1] >> 2) & 0x1;
+		parm->bEgCVidIns_Action = (pcetable.val[1] >> 3) & 0x1;
+		parm->nEgCVid = (pcetable.val[1] >> 4) & 0xFFF;
+	}
+
+	gsw_w32(cdev, PCE_TBL_CTRL_ADDR_OFFSET, 0, 16, 0);
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_SVLAN_CfgGet(void *cdev,
+			      GSW_SVLAN_cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 reg_val;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC)
+	    || (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		gsw_r32(cdev, (FDMA_SVTETYPE_OFFSET),
+			FDMA_SVTETYPE_ETYPE_SHIFT,
+			FDMA_SVTETYPE_ETYPE_SIZE, &reg_val);
+		parm->nEthertype = reg_val;
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_SVLAN_CfgSet(void *cdev,
+			      GSW_SVLAN_cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 reg_val;
+	u32 ret;
+	reg_val = parm->nEthertype & 0xFFFF;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		gsw_w32(cdev, (FDMA_SVTETYPE_OFFSET),
+			FDMA_SVTETYPE_ETYPE_SHIFT,
+			FDMA_SVTETYPE_ETYPE_SIZE, reg_val);
+		gsw_w32(cdev, (MAC_VLAN_ETYPE_1_INNER_OFFSET),
+			MAC_VLAN_ETYPE_1_INNER_SHIFT,
+			MAC_VLAN_ETYPE_1_INNER_SIZE, reg_val);
+		/* ToDo: Update the Micro code based on SVAN*/
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_SVLAN_PortCfgGet(void *cdev,
+				  GSW_SVLAN_portCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value;
+	ltq_bool_t svimr, svemr;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/** nPortVId: retrieve the corresponding VLAN ID */
+	/* from the Active VLAN Table*/
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		gsw_r32(cdev, (PCE_DEFPSVID_PVID_OFFSET +
+			       (2 * parm->nPortId)),
+			PCE_DEFPSVID_PVID_SHIFT,
+			PCE_DEFPSVID_PVID_SIZE, &value);
+		parm->nPortVId = value;
+		/* bSVLAN_TagSupport */
+		gsw_r32(cdev, (PCE_VCTRL_STEN_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_VCTRL_STEN_SHIFT,
+			PCE_VCTRL_STEN_SIZE, &value);
+		parm->bSVLAN_TagSupport = value;
+
+		/** bVLAN_ReAssign */
+		gsw_r32(cdev, (PCE_VCTRL_SVSR_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_VCTRL_SVSR_SHIFT,
+			PCE_VCTRL_SVSR_SIZE, &value);
+		parm->bVLAN_ReAssign = value;
+
+		/** bVlanMemberViolationIngress */
+		gsw_r32(cdev, (PCE_VCTRL_SVIMR_OFFSET
+			       + (10 * parm->nPortId)),
+			PCE_VCTRL_SVIMR_SHIFT,
+			PCE_VCTRL_SVIMR_SIZE, &value);
+		svimr = value;
+		/** bVlanMemberViolationEgress */
+		gsw_r32(cdev, (PCE_VCTRL_SVEMR_OFFSET
+			       + (10 * parm->nPortId)),
+			PCE_VCTRL_SVEMR_SHIFT,
+			PCE_VCTRL_SVEMR_SIZE, &value);
+		svemr = value;
+
+		if (svimr == 0 && svemr == 0)
+			parm->eVLAN_MemberViolation =
+				GSW_VLAN_MEMBER_VIOLATION_NO;
+
+		if (svimr == 1 && svemr == 0)
+			parm->eVLAN_MemberViolation =
+				GSW_VLAN_MEMBER_VIOLATION_INGRESS;
+
+		if (svimr == 0 && svemr == 1)
+			parm->eVLAN_MemberViolation =
+				GSW_VLAN_MEMBER_VIOLATION_EGRESS;
+
+		if (svimr == 1 && svemr == 1)
+			parm->eVLAN_MemberViolation =
+				GSW_VLAN_MEMBER_VIOLATION_BOTH;
+
+		/* eAdmitMode:  */
+		gsw_r32(cdev, (PCE_VCTRL_SVINR_OFFSET
+			       + (10 * parm->nPortId)),
+			PCE_VCTRL_SVINR_SHIFT,
+			PCE_VCTRL_SVINR_SIZE, &value);
+
+		switch (value) {
+		case 0:
+			parm->eAdmitMode = GSW_VLAN_ADMIT_ALL;
+			break;
+
+		case 1:
+			parm->eAdmitMode = GSW_VLAN_ADMIT_TAGGED;
+			break;
+
+		case 2:
+			parm->eAdmitMode = GSW_VLAN_ADMIT_UNTAGGED;
+			break;
+
+		default:
+			break;
+		} /* -----  end switch  ----- */
+
+		/** bSVLAN_MACbasedTag */
+		gsw_r32(cdev, (PCE_VCTRL_MACEN_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_VCTRL_MACEN_SHIFT,
+			PCE_VCTRL_MACEN_SIZE, &value);
+		parm->bSVLAN_MACbasedTag = value;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_SVLAN_PortCfgSet(void *cdev,
+				  GSW_SVLAN_portCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		value = parm->nPortVId;
+		gsw_w32(cdev, (PCE_DEFPSVID_PVID_OFFSET +
+			       (2 * parm->nPortId)),
+			PCE_DEFPSVID_PVID_SHIFT,
+			PCE_DEFPSVID_PVID_SIZE, value);
+		/* bSVLAN_TagSupport */
+		value = parm->bSVLAN_TagSupport;
+		gsw_w32(cdev, (PCE_VCTRL_STEN_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_VCTRL_STEN_SHIFT,
+			PCE_VCTRL_STEN_SIZE, value);
+
+		if (parm->bSVLAN_TagSupport == 1) {
+			gsw_w32(cdev, (FDMA_PCTRL_SVLANMOD_OFFSET +
+				       (6 * parm->nPortId)),
+				FDMA_PCTRL_SVLANMOD_SHIFT,
+				FDMA_PCTRL_SVLANMOD_SIZE, 3);
+		} else {
+			gsw_w32(cdev, (FDMA_PCTRL_SVLANMOD_OFFSET +
+				       (6 * parm->nPortId)),
+				FDMA_PCTRL_SVLANMOD_SHIFT,
+				FDMA_PCTRL_SVLANMOD_SIZE, 0);
+		}
+
+		/** bVLAN_ReAssign */
+		value = parm->bVLAN_ReAssign;
+		gsw_w32(cdev, (PCE_VCTRL_SVSR_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_VCTRL_SVSR_SHIFT,
+			PCE_VCTRL_SVSR_SIZE, value);
+
+		/** eVLAN_MemberViolation  */
+		switch (parm->eVLAN_MemberViolation) {
+		case GSW_VLAN_MEMBER_VIOLATION_NO:
+			gsw_w32(cdev, (PCE_VCTRL_SVIMR_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_VCTRL_SVIMR_SHIFT,
+				PCE_VCTRL_SVIMR_SIZE, 0);
+			gsw_w32(cdev, (PCE_VCTRL_SVEMR_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_VCTRL_SVEMR_SHIFT,
+				PCE_VCTRL_SVEMR_SIZE, 0);
+			break;
+
+		case GSW_VLAN_MEMBER_VIOLATION_INGRESS:
+			gsw_w32(cdev, (PCE_VCTRL_SVIMR_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_VCTRL_SVIMR_SHIFT,
+				PCE_VCTRL_SVIMR_SIZE, 1);
+			gsw_w32(cdev, (PCE_VCTRL_SVEMR_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_VCTRL_SVEMR_SHIFT,
+				PCE_VCTRL_SVEMR_SIZE, 0);
+			break;
+
+		case GSW_VLAN_MEMBER_VIOLATION_EGRESS:
+			gsw_w32(cdev, (PCE_VCTRL_SVIMR_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_VCTRL_SVIMR_SHIFT,
+				PCE_VCTRL_SVIMR_SIZE, 0);
+			gsw_w32(cdev, (PCE_VCTRL_SVEMR_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_VCTRL_SVEMR_SHIFT,
+				PCE_VCTRL_SVEMR_SIZE, 1);
+			break;
+
+		case GSW_VLAN_MEMBER_VIOLATION_BOTH:
+			gsw_w32(cdev, (PCE_VCTRL_SVIMR_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_VCTRL_SVIMR_SHIFT,
+				PCE_VCTRL_SVIMR_SIZE, 1);
+			gsw_w32(cdev, (PCE_VCTRL_SVEMR_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_VCTRL_SVEMR_SHIFT,
+				PCE_VCTRL_SVEMR_SIZE, 1);
+			break;
+		} /* -----  end switch  ----- */
+
+		/** eAdmitMode */
+		switch (parm->eAdmitMode) {
+		case GSW_VLAN_ADMIT_ALL:
+			value = 0;
+			break;
+
+		case GSW_VLAN_ADMIT_TAGGED:
+			value = 1;
+			break;
+
+		case GSW_VLAN_ADMIT_UNTAGGED:
+			value = 2;
+			break;
+
+		default:
+			value = 0;
+		} /* -----  end switch  ----- */
+
+		gsw_w32(cdev, (PCE_VCTRL_SVINR_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_VCTRL_SVINR_SHIFT,
+			PCE_VCTRL_SVINR_SIZE, value);
+		/** bSVLAN_MACbasedTag */
+		value = parm->bSVLAN_MACbasedTag;
+		gsw_w32(cdev, (PCE_VCTRL_MACEN_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_VCTRL_MACEN_SHIFT,
+			PCE_VCTRL_MACEN_SIZE, value);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_SVLAN_ClassPCP_PortGet(void *cdev,
+		GSW_QoS_SVLAN_ClassPCP_PortCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32  value, dei;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		for (value = 0; value < 16; value++) {
+			memset(&pcetable, 0, sizeof(pctbl_prog_t));
+			pcetable.pcindex = (((parm->nPortId & 0xF) << 4)
+					    | (value));
+			pcetable.table = PCE_EGREMARK_INDEX;
+			gsw_pce_table_read(cdev, &pcetable);
+			parm->nDSCP[value] = (pcetable.val[0] & 0x3F);
+			parm->nCPCP[value] = ((pcetable.val[0] >> 8) & 0x7);
+			parm->nSPCP[value] = ((pcetable.val[1] >> 8) & 0x7);
+			dei = ((pcetable.val[1]) & 0x1);
+			parm->nSPCP[value]	|= (dei << 7);
+		}
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_SVLAN_ClassPCP_PortSet(void *cdev,
+		GSW_QoS_SVLAN_ClassPCP_PortCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32  value;
+	u32 ret;
+	u8 cpcp, dscp, spcp, dei;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		for (value = 0; value < 16; value++) {
+			memset(&pcetable, 0, sizeof(pctbl_prog_t));
+			pcetable.pcindex = (((parm->nPortId & 0xF) << 4)
+					    | (value));
+			dscp = parm->nDSCP[value] & 0x3F;
+			spcp = parm->nSPCP[value] & 0x7;
+			cpcp = parm->nCPCP[value] & 0x7;
+			dei = ((parm->nSPCP[value] >> 7) & 1);
+			pcetable.val[1] = ((spcp << 8) | dei);
+			pcetable.val[0] = (dscp | (cpcp << 8));
+			pcetable.table = PCE_EGREMARK_INDEX;
+			gsw_pce_table_write(cdev, &pcetable);
+		}
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_SVLAN_PCP_ClassGet(void *cdev,
+					GSW_QoS_SVLAN_PCP_ClassCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t ptbl;
+	u32  value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0) ||
+	    (IS_VRSN_31(gswdev->gipver))) {
+		memset(&ptbl, 0, sizeof(pctbl_prog_t));
+
+		for (value = 0; value < 16; value++) {
+			ptbl.table = PCE_SPCP_INDEX;
+			ptbl.pcindex = value;
+			gsw_pce_table_read(cdev, &ptbl);
+			parm->nTrafficClass[value] = ptbl.val[0] & 0xF;
+
+			/*Following are not applicable for GSWIP 3.1*/
+			if (IS_VRSN_NOT_31(gswdev->gipver)) {
+				parm->nTrafficColor[value] = ((ptbl.val[0] >> 6) & 0x3);
+				parm->nPCP_Remark_Enable[value] = ((ptbl.val[0] >> 4) & 0x1);
+				parm->nDEI_Remark_Enable[value] = ((ptbl.val[0] >> 5) & 0x1);
+			}
+		}
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_SVLAN_PCP_ClassSet(void *cdev,
+					GSW_QoS_SVLAN_PCP_ClassCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0) ||
+	    (IS_VRSN_31(gswdev->gipver))) {
+		pctbl_prog_t pcetable;
+		u32  value;
+
+		for (value = 0; value < 16; value++) {
+			memset(&pcetable, 0, sizeof(pctbl_prog_t));
+			pcetable.table = PCE_SPCP_INDEX;
+			pcetable.pcindex = value;
+			pcetable.val[0] = parm->nTrafficClass[value] & 0xF;
+
+			/*Following are not applicable for GSWIP 3.1*/
+			if (IS_VRSN_NOT_31(gswdev->gipver)) {
+				pcetable.val[0] |=
+					(parm->nTrafficColor[value] & 0x3) << 6;
+				pcetable.val[0] |=
+					(parm->nPCP_Remark_Enable[value] & 0x1) << 4;
+				pcetable.val[0] |=
+					(parm->nDEI_Remark_Enable[value] & 0x1) << 5;
+			}
+
+			gsw_pce_table_write(cdev, &pcetable);
+		}
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+#endif /*CONFIG_LTQ_VLAN */
+
+
+#if defined(CONFIG_LTQ_QOS) && CONFIG_LTQ_QOS
+
+GSW_return_t GSW_QoS_MeterCfgGet(void *cdev,
+				 GSW_QoS_meterCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 mid = parm->nMeterId, value, exp, mant, ibs;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+		if (mid > gswdev->num_of_meters) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		gsw_w32(cdev, GSW_INST_SEL_INST_OFFSET,
+			GSW_INST_SEL_INST_SHIFT,
+			GSW_INST_SEL_INST_SIZE, mid);
+		/* Enable/Disable the meter shaper */
+		gsw_r32(cdev, GSW_PCE_TCM_CTRL_TCMEN_OFFSET,
+			GSW_PCE_TCM_CTRL_TCMEN_SHIFT,
+			GSW_PCE_TCM_CTRL_TCMEN_SIZE, &value);
+		parm->bEnable = value;
+		/* Committed Burst Size */
+		gsw_r32(cdev, GSW_PCE_TCM_CBS_CBS_OFFSET,
+			GSW_PCE_TCM_CBS_CBS_SHIFT,
+			GSW_PCE_TCM_CBS_CBS_SIZE, &value);
+		parm->nCbs = (value * 64);
+		/* Excess Burst Size (EBS [bytes]) */
+		gsw_r32(cdev, GSW_PCE_TCM_EBS_EBS_OFFSET,
+			GSW_PCE_TCM_EBS_EBS_SHIFT,
+			GSW_PCE_TCM_EBS_EBS_SIZE, &value);
+		parm->nEbs = (value * 64);
+		/* Rate Counter Exponent */
+		gsw_r32(cdev, GSW_PCE_TCM_CIR_EXP_EXP_OFFSET,
+			GSW_PCE_TCM_CIR_EXP_EXP_SHIFT,
+			GSW_PCE_TCM_CIR_EXP_EXP_SIZE, &exp);
+		/* Rate Counter Mantissa */
+		gsw_r32(cdev, GSW_PCE_TCM_CIR_MANT_MANT_OFFSET,
+			GSW_PCE_TCM_CIR_MANT_MANT_SHIFT,
+			GSW_PCE_TCM_CIR_MANT_MANT_SIZE, &mant);
+
+		/* Rate Counter iBS */
+		if (IS_VRSN_31(gswdev->gipver))
+			gsw_r32(cdev, GSW_PCE_TCM_IBS_IBS_OFFSET,
+				GSW_PCE_TCM_IBS_IBS_SHIFT,
+				GSW_PCE_TCM_IBS_IBS_SIZE_GSWIP_3_1, &ibs);
+		else
+			gsw_r32(cdev, GSW_PCE_TCM_IBS_IBS_OFFSET,
+				GSW_PCE_TCM_IBS_IBS_SHIFT,
+				GSW_PCE_TCM_IBS_IBS_SIZE, &ibs);
+
+		/* calc the Rate */
+		if (IS_VRSN_31(gswdev->gipver))
+			parm->nRate = mratecalc_3_1(ibs, exp, mant);
+		else
+			parm->nRate = mratecalc(ibs, exp, mant);
+
+		/* Rate Counter Exponent */
+		gsw_r32(cdev, GSW_PCE_TCM_PIR_EXP_EXP_OFFSET,
+			GSW_PCE_TCM_PIR_EXP_EXP_SHIFT,
+			GSW_PCE_TCM_PIR_EXP_EXP_SIZE, &exp);
+		/* Rate Counter Mantissa */
+		gsw_r32(cdev, GSW_PCE_TCM_PIR_MANT_MANT_OFFSET,
+			GSW_PCE_TCM_PIR_MANT_MANT_SHIFT,
+			GSW_PCE_TCM_PIR_MANT_MANT_SIZE, &mant);
+
+		/* Rate Counter iBS */
+		if (IS_VRSN_31(gswdev->gipver))
+			gsw_r32(cdev, GSW_PCE_TCM_IBS_IBS_OFFSET,
+				GSW_PCE_TCM_IBS_IBS_SHIFT,
+				GSW_PCE_TCM_IBS_IBS_SIZE_GSWIP_3_1, &ibs);
+		else
+			gsw_r32(cdev, GSW_PCE_TCM_IBS_IBS_OFFSET,
+				GSW_PCE_TCM_IBS_IBS_SHIFT,
+				GSW_PCE_TCM_IBS_IBS_SIZE, &ibs);
+
+		/* calc the Rate */
+		if (IS_VRSN_31(gswdev->gipver))
+			parm->nPiRate = mratecalc_3_1(ibs, exp, mant);
+		else
+			parm->nPiRate = mratecalc(ibs, exp, mant);
+
+		/* parm->nPbs=??? how to calculate it*/
+		gsw_r32(cdev, GSW_PCE_TCM_CTRL_TMOD_OFFSET,
+			GSW_PCE_TCM_CTRL_TMOD_SHIFT,
+			GSW_PCE_TCM_CTRL_TMOD_SIZE, &parm->eMtrType);
+
+		if (IS_VRSN_31(gswdev->gipver))
+			gsw_r32(cdev, GSW_PCE_TCM_CTRL_BLIND_OFFSET,
+				GSW_PCE_TCM_CTRL_BLIND_SHIFT,
+				GSW_PCE_TCM_CTRL_BLIND_SIZE, &parm->nColourBlindMode);
+	} else {
+		if (mid > 7) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/* Enable/Disable the meter shaper */
+		gsw_r32(cdev, (PCE_TCM_CTRL_TCMEN_OFFSET + (mid * 7)),
+			PCE_TCM_CTRL_TCMEN_SHIFT,
+			PCE_TCM_CTRL_TCMEN_SIZE, &value);
+		parm->bEnable = value;
+		/* Committed Burst Size */
+		gsw_r32(cdev, (PCE_TCM_CBS_CBS_OFFSET + (mid * 7)),
+			PCE_TCM_CBS_CBS_SHIFT,
+			PCE_TCM_CBS_CBS_SIZE, &value);
+		parm->nCbs = (value * 64);
+		/* Excess Burst Size (EBS [bytes]) */
+		gsw_r32(cdev, (PCE_TCM_EBS_EBS_OFFSET + (mid * 7)),
+			PCE_TCM_EBS_EBS_SHIFT,
+			PCE_TCM_EBS_EBS_SIZE, &value);
+		parm->nEbs = (value * 64);
+		/* Rate Counter Exponent */
+		gsw_r32(cdev, (PCE_TCM_CIR_EXP_EXP_OFFSET + (mid * 7)),
+			PCE_TCM_CIR_EXP_EXP_SHIFT,
+			PCE_TCM_CIR_EXP_EXP_SIZE, &exp);
+		/* Rate Counter Mantissa */
+		gsw_r32(cdev, (PCE_TCM_CIR_MANT_MANT_OFFSET + (mid * 7)),
+			PCE_TCM_CIR_MANT_MANT_SHIFT,
+			PCE_TCM_CIR_MANT_MANT_SIZE, &mant);
+		/* Rate Counter iBS */
+		gsw_r32(cdev, (PCE_TCM_IBS_IBS_OFFSET + (mid * 7)),
+			PCE_TCM_IBS_IBS_SHIFT,
+			PCE_TCM_IBS_IBS_SIZE, &ibs);
+		/* calc the Rate */
+		parm->nRate = mratecalc(ibs, exp, mant);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_MeterCfgSet(void *cdev,
+				 GSW_QoS_meterCfg_t *parm)
+{
+	u32 mid, cbs, ebs, exp = 0, mant = 0, rate, ibs = 0;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	mid = parm->nMeterId;
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+		if (mid > gswdev->num_of_meters) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		gsw_w32(cdev, GSW_INST_SEL_INST_OFFSET,
+			GSW_INST_SEL_INST_SHIFT,
+			GSW_INST_SEL_INST_SIZE, mid);
+
+		/* Committed Burst Size */
+		if (parm->nCbs > 0xFFC0)
+			cbs = 0x3FF;
+		else
+			cbs = ((parm->nCbs + 63) / 64);
+
+		gsw_w32(cdev, GSW_PCE_TCM_CBS_CBS_OFFSET,
+			GSW_PCE_TCM_CBS_CBS_SHIFT,
+			GSW_PCE_TCM_CBS_CBS_SIZE, cbs);
+
+		/* Excess Burst Size (EBS [bytes]) */
+		if (parm->nEbs > 0xFFC0)
+			ebs = 0x3FF;
+		else
+			ebs = ((parm->nEbs + 63) / 64);
+
+		gsw_w32(cdev, GSW_PCE_TCM_EBS_EBS_OFFSET,
+			GSW_PCE_TCM_EBS_EBS_SHIFT,
+			GSW_PCE_TCM_EBS_EBS_SIZE, ebs);
+		/* Calc the Rate and convert to MANT and EXP*/
+		rate = parm->nRate;
+
+		if (rate) {
+			if (IS_VRSN_31(gswdev->gipver))
+				calc_mtoken_3_1(rate, &ibs, &exp, &mant);
+			else
+				calc_mtoken(rate, &ibs, &exp, &mant);
+		}
+
+		/* Rate Counter Exponent */
+		gsw_w32(cdev, GSW_PCE_TCM_CIR_EXP_EXP_OFFSET,
+			GSW_PCE_TCM_CIR_EXP_EXP_SHIFT,
+			GSW_PCE_TCM_CIR_EXP_EXP_SIZE, exp);
+		/* Rate Counter Mantissa */
+		gsw_w32(cdev, GSW_PCE_TCM_CIR_MANT_MANT_OFFSET,
+			GSW_PCE_TCM_CIR_MANT_MANT_SHIFT,
+			GSW_PCE_TCM_CIR_MANT_MANT_SIZE, mant);
+
+		/* Rate Counter iBS */
+		if (IS_VRSN_31(gswdev->gipver))
+			gsw_w32(cdev, GSW_PCE_TCM_IBS_IBS_OFFSET,
+				GSW_PCE_TCM_IBS_IBS_SHIFT,
+				GSW_PCE_TCM_IBS_IBS_SIZE_GSWIP_3_1, ibs);
+		else
+			gsw_w32(cdev, GSW_PCE_TCM_IBS_IBS_OFFSET,
+				GSW_PCE_TCM_IBS_IBS_SHIFT,
+				GSW_PCE_TCM_IBS_IBS_SIZE_GSWIP_3_1, ibs);
+
+		/* Calc the Rate and convert to MANT and EXP*/
+		rate = parm->nPiRate;
+
+		if (rate) {
+			if (IS_VRSN_31(gswdev->gipver))
+				calc_mtoken_3_1(rate, &ibs, &exp, &mant);
+			else
+				calc_mtoken(rate, &ibs, &exp, &mant);
+		}
+
+		/* Rate Counter Exponent */
+		gsw_w32(cdev, GSW_PCE_TCM_PIR_EXP_EXP_OFFSET,
+			GSW_PCE_TCM_PIR_EXP_EXP_SHIFT,
+			GSW_PCE_TCM_PIR_EXP_EXP_SIZE, exp);
+		/* Rate Counter Mantissa */
+		gsw_w32(cdev, GSW_PCE_TCM_PIR_MANT_MANT_OFFSET,
+			GSW_PCE_TCM_PIR_MANT_MANT_SHIFT,
+			GSW_PCE_TCM_PIR_MANT_MANT_SIZE, mant);
+		/* Rate Counter iBS */
+		/*		gsw_w32(cdev, GSW_PCE_TCM_IBS_IBS_OFFSET, */
+		/*			GSW_PCE_TCM_IBS_IBS_SHIFT,*/
+		/*			GSW_PCE_TCM_IBS_IBS_SIZE, ibs);*/
+		gsw_w32(cdev, GSW_PCE_TCM_CTRL_TMOD_OFFSET,
+			GSW_PCE_TCM_CTRL_TMOD_SHIFT,
+			GSW_PCE_TCM_CTRL_TMOD_SIZE, parm->eMtrType);
+		/* Enable/Disable the meter shaper */
+		gsw_w32(cdev, GSW_PCE_TCM_CTRL_TCMEN_OFFSET,
+			GSW_PCE_TCM_CTRL_TCMEN_SHIFT,
+			GSW_PCE_TCM_CTRL_TCMEN_SIZE, parm->bEnable);
+
+		if (IS_VRSN_31(gswdev->gipver))
+			gsw_w32(cdev, GSW_PCE_TCM_CTRL_BLIND_OFFSET,
+				GSW_PCE_TCM_CTRL_BLIND_SHIFT,
+				GSW_PCE_TCM_CTRL_BLIND_SIZE, parm->nColourBlindMode);
+	} else {
+		if (mid > 7) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/* Committed Burst Size */
+		if (parm->nCbs > 0xFFC0)
+			cbs = 0x3FF;
+		else
+			cbs = ((parm->nCbs + 63) / 64);
+
+		gsw_w32(cdev, (PCE_TCM_CBS_CBS_OFFSET +
+			       (mid * 7)),
+			PCE_TCM_CBS_CBS_SHIFT,
+			PCE_TCM_CBS_CBS_SIZE, cbs);
+
+		/* Excess Burst Size (EBS [bytes]) */
+		if (parm->nEbs > 0xFFC0)
+			ebs = 0x3FF;
+		else
+			ebs = ((parm->nEbs + 63) / 64);
+
+		gsw_w32(cdev, (PCE_TCM_EBS_EBS_OFFSET +
+			       (mid * 7)),
+			PCE_TCM_EBS_EBS_SHIFT,
+			PCE_TCM_EBS_EBS_SIZE, ebs);
+		/* Calc the Rate and convert to MANT and EXP*/
+		rate = parm->nRate;
+
+		if (rate)
+			calc_mtoken(rate, &ibs, &exp, &mant);
+
+		/* Rate Counter Exponent */
+		gsw_w32(cdev, (PCE_TCM_CIR_EXP_EXP_OFFSET +
+			       (mid * 7)),
+			PCE_TCM_CIR_EXP_EXP_SHIFT,
+			PCE_TCM_CIR_EXP_EXP_SIZE, exp);
+		/* Rate Counter Mantissa */
+		gsw_w32(cdev, (PCE_TCM_CIR_MANT_MANT_OFFSET +
+			       (mid * 7)),
+			PCE_TCM_CIR_MANT_MANT_SHIFT,
+			PCE_TCM_CIR_MANT_MANT_SIZE, mant);
+		/* Rate Counter iBS */
+		gsw_w32(cdev, (PCE_TCM_IBS_IBS_OFFSET +
+			       (mid * 7)),
+			PCE_TCM_IBS_IBS_SHIFT,
+			PCE_TCM_IBS_IBS_SIZE, ibs);
+		/* Enable/Disable the meter shaper */
+		gsw_w32(cdev, (PCE_TCM_CTRL_TCMEN_OFFSET +
+			       (mid * 7)),
+			PCE_TCM_CTRL_TCMEN_SHIFT,
+			PCE_TCM_CTRL_TCMEN_SIZE, parm->bEnable);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_MeterPortAssign(void *cdev,
+				     GSW_QoS_meterPort_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32 ret;
+	u32 eport, iport, value1, value2;
+	ltq_bool_t eftbl = 0, nempftbl = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+		/* GSW_QoS_MeterPortAssign should not be called for GSWIP3.1
+			Meter should be assigned during CTP/Bridge Port Config*/
+		ret = GSW_statusNoSupport;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	memset(&pcetable, 0, sizeof(pctbl_prog_t));
+	value1 = 0;
+
+	while (value1 < 8) {
+		pcetable.table = PCE_METER_INS_0_INDEX;
+		pcetable.pcindex = value1;
+		gsw_pce_table_read(cdev, &pcetable);
+
+		if (pcetable.valid == 1) {
+			iport = pcetable.key[0] & 0xF;
+			eport = (pcetable.key[0] >> 8) & 0xF;
+
+			if ((eport == parm->nPortEgressId) &&
+			    (iport == parm->nPortIngressId)) {
+				eftbl = 1;
+				value2 = 0;
+
+				while (value2 < 8) {
+					pcetable.table = PCE_METER_INS_1_INDEX;
+					pcetable.pcindex = value2;
+					gsw_pce_table_read(cdev, &pcetable);
+
+					if (pcetable.valid == 1) {
+						iport = pcetable.key[0] & 0xF;
+						eport = ((pcetable.key[0] >> 8) & 0xF);
+
+						if ((eport == parm->nPortEgressId) &&
+						    (iport == parm->nPortIngressId)) {
+							ret = GSW_statusErr;
+							goto UNLOCK_AND_RETURN;
+						}
+					}
+
+					value2++;
+				}
+			}
+		}
+
+		value1++;
+	}
+
+	/*  Not in the original table, write a new one */
+	if (eftbl == 0) {
+		value1 = 0;
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+
+		/* Search for whole Table 1*/
+		while (value1 < 8) {
+			pcetable.table = PCE_METER_INS_0_INDEX;
+			pcetable.pcindex = value1;
+			gsw_pce_table_read(cdev, &pcetable);
+
+			/* We found the empty one */
+			if (pcetable.valid == 0) {
+				switch (parm->eDir) {
+				case GSW_DIRECTION_BOTH:
+					pcetable.key[0] =
+						(((parm->nPortEgressId & 0xF) << 8)
+						 | (parm->nPortIngressId & 0xF));
+					pcetable.mask[0] = 0;
+					break;
+
+				case GSW_DIRECTION_EGRESS:
+					pcetable.key[0] =
+						(((parm->nPortEgressId & 0xF) << 8)
+						 | 0xF);
+					pcetable.mask[0] = 1;
+					break;
+
+				case GSW_DIRECTION_INGRESS:
+					pcetable.key[0] = (0xF00 |
+							   (parm->nPortIngressId & 0xF));
+					pcetable.mask[0] = 4;
+					break;
+
+				default:
+					pcetable.key[0] = 0;
+					pcetable.mask[0] = 5;
+				}
+
+				pcetable.val[0] = parm->nMeterId & 0x3F;
+				pcetable.valid = 1;
+				gsw_pce_table_write(cdev, &pcetable);
+				ret = GSW_statusOk;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			value1++;
+		}
+
+		if (value1 >= 8)
+			nempftbl = 1;
+	}
+
+	/* The Table 1 is full, We go search table 2 */
+	if ((nempftbl == 1) || (eftbl == 1)) {
+		value2 = 0;
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+
+		while (value2 < 8) {
+			pcetable.table = PCE_METER_INS_1_INDEX;
+			pcetable.pcindex = value2;
+			gsw_pce_table_read(cdev, &pcetable);
+
+			/* We found the empty one */
+			if (pcetable.valid == 0) {
+				switch (parm->eDir) {
+				case GSW_DIRECTION_BOTH:
+					pcetable.key[0] =
+						(((parm->nPortEgressId & 0xF) << 8) |
+						 (parm->nPortIngressId & 0xF));
+					pcetable.mask[0] = 0;
+					break;
+
+				case GSW_DIRECTION_EGRESS:
+					pcetable.key[0] =
+						(((parm->nPortEgressId & 0xF) << 8)
+						 | 0xF);
+					pcetable.mask[0] = 1;
+					break;
+
+				case GSW_DIRECTION_INGRESS:
+					pcetable.key[0] = (0xF00 |
+							   (parm->nPortIngressId & 0xF));
+					pcetable.mask[0] = 4;
+					break;
+
+				default:
+					pcetable.key[0] = 0;
+					pcetable.mask[0] = 5;
+				}
+
+				pcetable.val[0] = parm->nMeterId & 0x3F;
+				pcetable.valid = 1;
+				gsw_pce_table_write(cdev, &pcetable);
+				nempftbl = 0;
+				ret = GSW_statusOk;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			value2++;
+		}
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_MeterPortDeassign(void *cdev,
+				       GSW_QoS_meterPort_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32  eport, iport, mid, i, j;
+	ltq_bool_t eftbl = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	for (i = 0; i < 2; i++) {
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+
+		if (i == 0)
+			pcetable.table = PCE_METER_INS_0_INDEX;
+		else
+			pcetable.table = PCE_METER_INS_1_INDEX;
+
+		for (j = 0; j < 8; j++) {
+			pcetable.pcindex = j;
+			gsw_pce_table_read(cdev, &pcetable);
+
+			if (pcetable.valid == 1) {
+				iport = pcetable.key[0] & 0xF;
+				eport = (pcetable.key[0] >> 8) & 0xF;
+				mid = pcetable.val[0] & 0x1F;
+
+				if ((eport == parm->nPortEgressId) &&
+				    (iport == parm->nPortIngressId) &&
+				    (mid == parm->nMeterId)) {
+					if (i == 0)
+						pcetable.table =
+							PCE_METER_INS_0_INDEX;
+					else
+						pcetable.table =
+							PCE_METER_INS_1_INDEX;
+
+					pcetable.key[0] = 0;
+					pcetable.val[0] = 0;
+					pcetable.valid = 0;
+					gsw_pce_table_write(cdev, &pcetable);
+					eftbl = 1;
+					pr_err("Found the entry, delet it\n");
+				}
+
+			}
+		}
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_MeterPortGet(void *cdev,
+				  GSW_QoS_meterPortGet_t *parm)
+{
+	pctbl_prog_t pcetable;
+	u32 value = 0;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	memset(&pcetable, 0, sizeof(pctbl_prog_t));
+	/*	gsw_r32(cdev, ETHSW_CAP_3_METERS_OFFSET,*/
+	/*		ETHSW_CAP_3_METERS_SHIFT,*/
+	/*		ETHSW_CAP_3_METERS_SIZE, &value); */
+	value = gswdev->num_of_meters;
+
+	if (parm->bInitial == 1) {
+		gswdev->meter_cnt = 0;
+		parm->bInitial = 0;
+	} else {
+		if (gswdev->meter_cnt > (value * 2))
+			parm->bLast = 1;
+	}
+
+	if (gswdev->meter_cnt > value)
+		pcetable.table = PCE_METER_INS_1_INDEX;
+	else
+		pcetable.table = PCE_METER_INS_0_INDEX;
+
+	pcetable.pcindex = gswdev->meter_cnt;
+	gsw_pce_table_read(cdev, &pcetable);
+
+	if (pcetable.valid) {
+		parm->nMeterId = (pcetable.val[0] & 0x3F);
+		parm->nPortEgressId = ((pcetable.key[0] >> 8) & 0xF);
+		parm->nPortIngressId = (pcetable.key[0] & 0xF);
+
+		if ((pcetable.mask[0] & 0x5) == 0)
+			parm->eDir = GSW_DIRECTION_BOTH;
+		else if ((pcetable.mask[0] & 0x5) == 1)
+			parm->eDir = GSW_DIRECTION_EGRESS;
+		else if ((pcetable.mask[0] & 0x5) == 4)
+			parm->eDir = GSW_DIRECTION_INGRESS;
+		else
+			parm->eDir = GSW_DIRECTION_NONE;
+	}
+
+	gswdev->meter_cnt++;
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_DSCP_ClassGet(void *cdev,
+				   GSW_QoS_DSCP_ClassCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32  value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	for (value = 0; value <= 63; value++) {
+		pcetable.table = PCE_DSCP_INDEX;
+		pcetable.pcindex = value;
+		gsw_pce_table_read(cdev, &pcetable);
+		parm->nTrafficClass[value] = (pcetable.val[0] & 0xF);
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_DSCP_ClassSet(void *cdev,
+				   GSW_QoS_DSCP_ClassCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32  value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+
+	for (value = 0; value <= 63; value++) {
+		pcetable.table = PCE_DSCP_INDEX;
+		pcetable.pcindex = value;
+		gsw_pce_table_read(cdev, &pcetable);
+		pcetable.val[0] &= ~(0xF);
+		pcetable.val[0] |= (parm->nTrafficClass[value] & 0xF);
+		gsw_pce_table_write(cdev, &pcetable);
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_ClassDSCP_Get(void *cdev,
+				   GSW_QoS_ClassDSCP_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32  value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (gswdev->gipver != LTQ_GSWIP_3_0 ||
+	    IS_VRSN_NOT_31(gswdev->gipver)) {
+		for (value = 0; value < 16; value++) {
+			pcetable.table = PCE_REMARKING_INDEX;
+			pcetable.pcindex = value;
+			gsw_pce_table_read(cdev, &pcetable);
+			parm->nDSCP[value] = pcetable.val[0] & 0x3F;
+		}
+	} else {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_ClassDSCP_Set(void *cdev,
+				   GSW_QoS_ClassDSCP_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32  dscp, pcp, value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (gswdev->gipver != LTQ_GSWIP_3_0
+	    || IS_VRSN_NOT_31(gswdev->gipver)) {
+		for (value = 0; value < 16; value++) {
+			pcetable.table = PCE_REMARKING_INDEX;
+			pcetable.pcindex = value;
+			gsw_pce_table_read(cdev, &pcetable);
+			pcp = (pcetable.val[0] >> 8) & 0x7;
+			dscp	= parm->nDSCP[value] & 0x3F;
+			pcetable.val[0] = ((pcp << 8) | dscp);
+			gsw_pce_table_write(cdev, &pcetable);
+		}
+	} else {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_DSCP_DropPrecedenceCfgGet(void *cdev,
+		GSW_QoS_DSCP_DropPrecedenceCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32  value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	for (value = 0; value <= 63; value++) {
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.table = PCE_DSCP_INDEX;
+		pcetable.pcindex = value;
+		gsw_pce_table_read(cdev, &pcetable);
+		parm->nDSCP_DropPrecedence[value]	=
+			((pcetable.val[0] >> 4) & 0x3);
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_DSCP_DropPrecedenceCfgSet(void *cdev,
+		GSW_QoS_DSCP_DropPrecedenceCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32  value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	for (value = 0; value <= 63; value++) {
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.table = PCE_DSCP_INDEX;
+		pcetable.pcindex = value;
+		gsw_pce_table_read(cdev, &pcetable);
+		pcetable.val[0] &= ~(0x3 << 4);
+		pcetable.val[0] |=
+			((parm->nDSCP_DropPrecedence[value] & 0x3) << 4);
+		gsw_pce_table_write(cdev, &pcetable);
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_PortRemarkingCfgGet(void *cdev,
+		GSW_QoS_portRemarkingCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32  value, vclpen = 0, vdpen = 0, vdscpmod = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*Applicable for 3.1 also*/
+	gsw_r32(cdev, (PCE_PCTRL_0_CLPEN_OFFSET +
+		       (10 * parm->nPortId)),
+		PCE_PCTRL_0_CLPEN_SHIFT,
+		PCE_PCTRL_0_CLPEN_SIZE, &vclpen);
+
+	/*Applicable only for 3.0 and below switch version*/
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		gsw_r32(cdev, (PCE_PCTRL_0_DPEN_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_0_DPEN_SHIFT,
+			PCE_PCTRL_0_DPEN_SIZE, &vdpen);
+		gsw_r32(cdev, (PCE_PCTRL_2_DSCPMOD_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_2_DSCPMOD_SHIFT,
+			PCE_PCTRL_2_DSCPMOD_SIZE, &vdscpmod);
+	}
+
+	/*Applicable only for 3.0 and below switch version*/
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if ((vclpen == 0) && (vdpen == 0)
+		    && (vdscpmod == 0))
+			parm->eDSCP_IngressRemarkingEnable =
+				GSW_DSCP_REMARK_DISABLE;
+		else if ((vclpen == 1) && (vdpen == 0)
+			 && (vdscpmod == 1))
+			parm->eDSCP_IngressRemarkingEnable =
+				GSW_DSCP_REMARK_TC6;
+		else if ((vclpen == 1) && (vdpen == 1) &&
+			 (vdscpmod == 1))
+			parm->eDSCP_IngressRemarkingEnable =
+				GSW_DSCP_REMARK_TC3;
+		else if ((vclpen == 0) && (vdpen == 1) &&
+			 (vdscpmod == 1))
+			parm->eDSCP_IngressRemarkingEnable =
+				GSW_DSCP_REMARK_DP3;
+		else if ((vclpen == 1) && (vdpen == 1) &&
+			 (vdscpmod == 1))
+			parm->eDSCP_IngressRemarkingEnable =
+				GSW_DSCP_REMARK_DP3_TC3;
+	}
+
+	/*Applicable only for 3.1*/
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if (vclpen == 0)
+			parm->eDSCP_IngressRemarkingEnable =
+				GSW_DSCP_REMARK_DISABLE;
+		else if (vclpen == 1)
+			parm->eDSCP_IngressRemarkingEnable =
+				GSW_DSCP_REMARK_TC6;
+	}
+
+	/*PCP Remarking Enable/Disable,Applicable for 3.1 also*/
+	gsw_r32(cdev, (PCE_PCTRL_0_PCPEN_OFFSET +
+		       (10 * parm->nPortId)),
+		PCE_PCTRL_0_PCPEN_SHIFT,
+		PCE_PCTRL_0_PCPEN_SIZE, &value);
+	parm->bPCP_IngressRemarkingEnable = value;
+
+	/*DSCP Remarking Enable/Disable,Applicable for 3.1 also*/
+	gsw_r32(cdev, (FDMA_PCTRL_DSCPRM_OFFSET +
+		       (6 * parm->nPortId)),
+		FDMA_PCTRL_DSCPRM_SHIFT,
+		FDMA_PCTRL_DSCPRM_SIZE, &value);
+	parm->bDSCP_EgressRemarkingEnable = value;
+
+	/*Applicable only for 3.0 and below switch version*/
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		gsw_r32(cdev, (FDMA_PCTRL_VLANMOD_OFFSET +
+			       (6 * parm->nPortId)),
+			FDMA_PCTRL_VLANMOD_SHIFT,
+			FDMA_PCTRL_VLANMOD_SIZE, &value);
+
+		if (value == 3)
+			parm->bPCP_EgressRemarkingEnable = 1;
+		else
+			parm->bPCP_EgressRemarkingEnable = 0;
+	}
+
+	/*Applicable only for 3.1
+	  FDMA_PCTRL_VLANMOD is reduced to 1 bit in GSWIP 3.1*/
+	if (IS_VRSN_31(gswdev->gipver)) {
+		/*JIRA GSWIP-147 Implemented*/
+		gsw_r32(cdev, (FDMA_PCTRL_VLANMOD_OFFSET +
+			       (6 * parm->nPortId)),
+			FDMA_PCTRL_VLANMOD_SHIFT,
+			FDMA_GSWIP3_1_PCTRL_VLANMOD_SIZE, &value);
+
+		if (value == 1)
+			parm->bPCP_EgressRemarkingEnable = 1;
+		else
+			parm->bPCP_EgressRemarkingEnable = 0;
+	}
+
+	/*The following are not applicable for GSWIP 3.1*/
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		gsw_r32(cdev, (PCE_PCTRL_2_SPCPEN_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_2_SPCPEN_SHIFT,
+			PCE_PCTRL_2_SPCPEN_SIZE,
+			&parm->bSTAG_PCP_IngressRemarkingEnable);
+		gsw_r32(cdev, (PCE_PCTRL_2_SDEIEN_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_2_SDEIEN_SHIFT,
+			PCE_PCTRL_2_SDEIEN_SIZE,
+			&parm->bSTAG_DEI_IngressRemarkingEnable);
+		gsw_w32(cdev, (FDMA_PCTRL_SVLANMOD_OFFSET +
+			       (6 * parm->nPortId)),
+			FDMA_PCTRL_SVLANMOD_SHIFT,
+			FDMA_PCTRL_SVLANMOD_SIZE, value);
+
+		if (value == 3)
+			parm->bSTAG_PCP_DEI_EgressRemarkingEnable = 1;
+		else
+			parm->bSTAG_PCP_DEI_EgressRemarkingEnable = 0;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_PortRemarkingCfgSet(void *cdev,
+		GSW_QoS_portRemarkingCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32  value, vclpen = 0, vdpen = 0, vdscpmod = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	switch (parm->eDSCP_IngressRemarkingEnable) {
+	case GSW_DSCP_REMARK_DISABLE:
+		vclpen = 0;
+		vdpen = 0;
+		vdscpmod = 0;
+		break;
+
+	case GSW_DSCP_REMARK_TC6:
+		vclpen = 1;
+		vdpen = 0;
+		vdscpmod = 1;
+		break;
+
+	case GSW_DSCP_REMARK_TC3:
+		vclpen = 1;
+		vdpen = 1;
+		vdscpmod = 1;
+
+		/*Not supported in GSWIP 3.1*/
+		if (IS_VRSN_31(gswdev->gipver)) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		break;
+
+	case GSW_DSCP_REMARK_DP3:
+		vclpen = 0;
+		vdpen = 1;
+		vdscpmod = 1;
+
+		/*Not supported in GSWIP 3.1*/
+		if (IS_VRSN_31(gswdev->gipver)) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		break;
+
+	case GSW_DSCP_REMARK_DP3_TC3:
+		vclpen = 1;
+		vdpen = 1;
+		vdscpmod = 1;
+
+		/*Not supported in GSWIP 3.1*/
+		if (IS_VRSN_31(gswdev->gipver)) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		break;
+	}
+
+	/*Applicable for 3.1 also*/
+	gsw_w32(cdev, PCE_PCTRL_0_CLPEN_OFFSET +
+		(10 * parm->nPortId),
+		PCE_PCTRL_0_CLPEN_SHIFT,
+		PCE_PCTRL_0_CLPEN_SIZE, vclpen);
+
+	/*The following are not applicable for GSWIP 3.1*/
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		gsw_w32(cdev, PCE_PCTRL_0_DPEN_OFFSET +
+			(10 * parm->nPortId),
+			PCE_PCTRL_0_DPEN_SHIFT,
+			PCE_PCTRL_0_DPEN_SIZE, vdpen);
+		gsw_w32(cdev, PCE_PCTRL_2_DSCPMOD_OFFSET +
+			(10 * parm->nPortId),
+			PCE_PCTRL_2_DSCPMOD_SHIFT,
+			PCE_PCTRL_2_DSCPMOD_SIZE, vdscpmod);
+	}
+
+	/*DSCP Remarking Enable/Disable,Applicable for 3.1 also*/
+	if (parm->bDSCP_EgressRemarkingEnable > 0)
+		value = parm->bDSCP_EgressRemarkingEnable;
+	else
+		value = 0;
+
+	gsw_w32(cdev, (FDMA_PCTRL_DSCPRM_OFFSET +
+		       (6 * parm->nPortId)),
+		FDMA_PCTRL_DSCPRM_SHIFT,
+		FDMA_PCTRL_DSCPRM_SIZE, value);
+
+	/*PCP Remarking Enable/Disable,Applicable for 3.1 also*/
+	if (parm->bPCP_IngressRemarkingEnable > 0)
+		value = parm->bPCP_IngressRemarkingEnable;
+	else
+		value = 0;
+
+	gsw_w32(cdev, (PCE_PCTRL_0_PCPEN_OFFSET +
+		       (10 * parm->nPortId)),
+		PCE_PCTRL_0_PCPEN_SHIFT,
+		PCE_PCTRL_0_PCPEN_SIZE, value);
+
+	/*Applicable only for 3.0 and below switch version*/
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (parm->bPCP_EgressRemarkingEnable > 0)
+			value = 3;
+		else
+			value = 0;
+
+		gsw_w32(cdev, (FDMA_PCTRL_VLANMOD_OFFSET +
+			       (6 * parm->nPortId)),
+			FDMA_PCTRL_VLANMOD_SHIFT,
+			FDMA_PCTRL_VLANMOD_SIZE, value);
+	}
+
+	/*FDMA_PCTRL_VLANMOD is reduced to 1 bit in GSWIP 3.1*/
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if (parm->bPCP_EgressRemarkingEnable > 0)
+			value = 1;
+		else
+			value = 0;
+
+		/*JIRA GSWIP-147 Implemented*/
+		gsw_w32(cdev, (FDMA_PCTRL_VLANMOD_OFFSET +
+			       (6 * parm->nPortId)),
+			FDMA_PCTRL_VLANMOD_SHIFT,
+			FDMA_GSWIP3_1_PCTRL_VLANMOD_SIZE, value);
+	}
+
+	/*The following are not applicable for GSWIP 3.1*/
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		gsw_w32(cdev, (PCE_PCTRL_2_SPCPEN_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_2_SPCPEN_SHIFT,
+			PCE_PCTRL_2_SPCPEN_SIZE,
+			parm->bSTAG_PCP_IngressRemarkingEnable);
+		gsw_w32(cdev, (PCE_PCTRL_2_SDEIEN_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_2_SDEIEN_SHIFT,
+			PCE_PCTRL_2_SDEIEN_SIZE,
+			parm->bSTAG_DEI_IngressRemarkingEnable);
+
+
+		if (parm->bSTAG_PCP_DEI_EgressRemarkingEnable > 0)
+			value = 3;
+		else
+			value = 0;
+
+		/*		gsw_w32(cdev, (FDMA_PCTRL_DEIMOD_OFFSET + */
+		/*			(6 * parm->nPortId)), */
+		/*			FDMA_PCTRL_DEIMOD_SHIFT,*/
+		/*			FDMA_PCTRL_DEIMOD_SIZE,*/
+		/*			parm->bSTAG_PCP_DEI_EgressRemarkingEnable);	*/
+		gsw_w32(cdev, (FDMA_PCTRL_SVLANMOD_OFFSET +
+			       (6 * parm->nPortId)),
+			FDMA_PCTRL_SVLANMOD_SHIFT,
+			FDMA_PCTRL_SVLANMOD_SIZE, value);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_ClassPCP_Get(void *cdev,
+				  GSW_QoS_ClassPCP_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32  value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (gswdev->gipver != LTQ_GSWIP_3_0 ||
+	    IS_VRSN_NOT_31(gswdev->gipver)) {
+		for (value = 0; value < 16; value++) {
+			pcetable.table = PCE_REMARKING_INDEX;
+			pcetable.pcindex = value;
+			gsw_pce_table_read(cdev, &pcetable);
+			parm->nPCP[value] = (pcetable.val[0] >> 8) & 0x7;
+		}
+	} else {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_ClassPCP_Set(void *cdev,
+				  GSW_QoS_ClassPCP_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32  dscp, pcp, value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (gswdev->gipver != LTQ_GSWIP_3_0 ||
+	    IS_VRSN_NOT_31(gswdev->gipver)) {
+		for (value = 0; value < 16; value++) {
+			pcetable.table = PCE_REMARKING_INDEX;
+			pcetable.pcindex = value;
+			gsw_pce_table_read(cdev, &pcetable);
+			dscp = pcetable.val[0] & 0x3F;
+			pcp = parm->nPCP[value] & 0x7;
+			pcetable.val[0] = (pcp << 8) | dscp;
+			gsw_pce_table_write(cdev, &pcetable);
+		}
+	} else {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_PCP_ClassGet(void *cdev,
+				  GSW_QoS_PCP_ClassCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32  value;
+	u32 ret;
+	u8 inrPcpEntries = PCE_INNER_PCP_DFL_ENTRIES;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+
+
+	for (value = 0; value < inrPcpEntries; value++) {
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.table = PCE_PCP_INDEX;
+		pcetable.pcindex = value;
+		gsw_pce_table_read(cdev, &pcetable);
+		parm->nTrafficClass[value] = (pcetable.val[0] & 0xF);
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_PCP_ClassSet(void *cdev,
+				  GSW_QoS_PCP_ClassCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32  value;
+	u32 ret;
+	u8 inrPcpEntries = PCE_INNER_PCP_DFL_ENTRIES;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+
+
+	for (value = 0; value < inrPcpEntries; value++) {
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.table = PCE_PCP_INDEX;
+		pcetable.pcindex = value;
+		pcetable.val[0] = (parm->nTrafficClass[value] & 0xF);
+		gsw_pce_table_write(cdev, &pcetable);
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_PortCfgGet(void *cdev,
+				GSW_QoS_portCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32  value, dscp, cpcp, spcp = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	gsw_r32(cdev, (PCE_PCTRL_2_DSCP_OFFSET +
+		       (10 * parm->nPortId)),
+		PCE_PCTRL_2_DSCP_SHIFT,
+		PCE_PCTRL_2_DSCP_SIZE, &dscp);
+	gsw_r32(cdev, (PCE_PCTRL_2_PCP_OFFSET +
+		       (10 * parm->nPortId)),
+		PCE_PCTRL_2_PCP_SHIFT,
+		PCE_PCTRL_2_PCP_SIZE, &cpcp);
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (IS_VRSN_30_31(gswdev->gipver))) {
+		gsw_r32(cdev, (PCE_PCTRL_2_SPCP_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_2_SPCP_SHIFT,
+			PCE_PCTRL_2_SPCP_SIZE, &spcp);
+	}
+
+	if ((dscp == 0) && (cpcp == 0) && (spcp == 0))
+		parm->eClassMode = GSW_QOS_CLASS_SELECT_NO;
+	else if ((dscp == 2) && (cpcp == 0) && (spcp == 0))
+		parm->eClassMode = GSW_QOS_CLASS_SELECT_DSCP;
+	else if ((dscp == 0) && (cpcp == 1) && (spcp == 0))
+		parm->eClassMode = GSW_QOS_CLASS_SELECT_PCP;
+	else if ((dscp == 2) && (cpcp == 1) && (spcp == 0))
+		parm->eClassMode = GSW_QOS_CLASS_SELECT_DSCP_PCP;
+	else if ((dscp == 1) && (cpcp == 1) && (spcp == 0))
+		parm->eClassMode = GSW_QOS_CLASS_SELECT_PCP_DSCP;
+	else if ((dscp == 0) && (cpcp == 0) && (spcp == 1))
+		parm->eClassMode = GSW_QOS_CLASS_SELECT_SPCP;
+	else if ((dscp == 1) && (cpcp == 0) && (spcp == 1))
+		parm->eClassMode = GSW_QOS_CLASS_SELECT_SPCP_DSCP;
+	else if ((dscp == 2) && (cpcp == 0) && (spcp == 1))
+		parm->eClassMode = GSW_QOS_CLASS_SELECT_DSCP_SPCP;
+	else if ((dscp == 0) && (cpcp == 1) && (spcp == 1))
+		parm->eClassMode = GSW_QOS_CLASS_SELECT_SPCP_PCP;
+	else if ((dscp == 1) && (cpcp == 1) && (spcp == 1))
+		parm->eClassMode = GSW_QOS_CLASS_SELECT_SPCP_PCP_DSCP;
+	else if ((dscp == 2) && (cpcp == 1) && (spcp == 1))
+		parm->eClassMode = GSW_QOS_CLASS_SELECT_DSCP_SPCP_PCP;
+	else
+		parm->eClassMode = GSW_QOS_CLASS_SELECT_NO;
+
+	/*PCLASS is removed in PCE_PCTRL_2 for GSWIP 3.1*/
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		gsw_r32(cdev, (PCE_PCTRL_2_PCLASS_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_2_PCLASS_SHIFT,
+			PCE_PCTRL_2_PCLASS_SIZE, &value);
+		parm->nTrafficClass = value;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_PortCfgSet(void *cdev,
+				GSW_QoS_portCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	switch (parm->eClassMode) {
+	case GSW_QOS_CLASS_SELECT_NO:
+		gsw_w32(cdev, (PCE_PCTRL_2_DSCP_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_2_DSCP_SHIFT,
+			PCE_PCTRL_2_DSCP_SIZE, 0);
+		gsw_w32(cdev, (PCE_PCTRL_2_PCP_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_2_PCP_SHIFT,
+			PCE_PCTRL_2_PCP_SIZE, 0);
+
+		if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC)
+		    || (IS_VRSN_30_31(gswdev->gipver))) {
+			gsw_w32(cdev, (PCE_PCTRL_2_SPCP_OFFSET
+				       + (10 * parm->nPortId)),
+				PCE_PCTRL_2_SPCP_SHIFT,
+				PCE_PCTRL_2_SPCP_SIZE, 0);
+		}
+
+		break;
+
+	case GSW_QOS_CLASS_SELECT_DSCP:
+		gsw_w32(cdev, (PCE_PCTRL_2_DSCP_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_2_DSCP_SHIFT,
+			PCE_PCTRL_2_DSCP_SIZE, 2);
+		gsw_w32(cdev, (PCE_PCTRL_2_PCP_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_2_PCP_SHIFT,
+			PCE_PCTRL_2_PCP_SIZE, 0);
+
+		if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+		    (IS_VRSN_30_31(gswdev->gipver))) {
+			gsw_w32(cdev, (PCE_PCTRL_2_SPCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_SPCP_SHIFT,
+				PCE_PCTRL_2_SPCP_SIZE, 0);
+		}
+
+		break;
+
+	case GSW_QOS_CLASS_SELECT_PCP:
+		gsw_w32(cdev, (PCE_PCTRL_2_DSCP_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_2_DSCP_SHIFT,
+			PCE_PCTRL_2_DSCP_SIZE, 0);
+		gsw_w32(cdev, PCE_PCTRL_2_PCP_OFFSET +
+			(10 * parm->nPortId),
+			PCE_PCTRL_2_PCP_SHIFT,
+			PCE_PCTRL_2_PCP_SIZE, 1);
+
+		if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+		    (IS_VRSN_30_31(gswdev->gipver))) {
+			gsw_w32(cdev, (PCE_PCTRL_2_SPCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_SPCP_SHIFT,
+				PCE_PCTRL_2_SPCP_SIZE, 0);
+		}
+
+		break;
+
+	case GSW_QOS_CLASS_SELECT_DSCP_PCP:
+		gsw_w32(cdev, (PCE_PCTRL_2_DSCP_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_2_DSCP_SHIFT,
+			PCE_PCTRL_2_DSCP_SIZE, 2);
+		gsw_w32(cdev, (PCE_PCTRL_2_PCP_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_2_PCP_SHIFT,
+			PCE_PCTRL_2_PCP_SIZE, 1);
+
+		if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+		    (IS_VRSN_30_31(gswdev->gipver))) {
+			gsw_w32(cdev, (PCE_PCTRL_2_SPCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_SPCP_SHIFT,
+				PCE_PCTRL_2_SPCP_SIZE, 0);
+		}
+
+		break;
+
+	case GSW_QOS_CLASS_SELECT_PCP_DSCP:
+		gsw_w32(cdev, (PCE_PCTRL_2_DSCP_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_2_DSCP_SHIFT,
+			PCE_PCTRL_2_DSCP_SIZE, 1);
+		gsw_w32(cdev, (PCE_PCTRL_2_PCP_OFFSET +
+			       (10 * parm->nPortId)),
+			PCE_PCTRL_2_PCP_SHIFT,
+			PCE_PCTRL_2_PCP_SIZE, 1);
+
+		if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+		    (IS_VRSN_30_31(gswdev->gipver))) {
+			gsw_w32(cdev, (PCE_PCTRL_2_SPCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_SPCP_SHIFT,
+				PCE_PCTRL_2_SPCP_SIZE, 0);
+		}
+
+		break;
+
+		if ((gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+		    (IS_VRSN_30_31(gswdev->gipver))) {
+		case GSW_QOS_CLASS_SELECT_SPCP:
+			gsw_w32(cdev, (PCE_PCTRL_2_DSCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_DSCP_SHIFT,
+				PCE_PCTRL_2_DSCP_SIZE, 0);
+			gsw_w32(cdev, (PCE_PCTRL_2_PCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_PCP_SHIFT,
+				PCE_PCTRL_2_PCP_SIZE, 0);
+			gsw_w32(cdev, (PCE_PCTRL_2_SPCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_SPCP_SHIFT,
+				PCE_PCTRL_2_SPCP_SIZE, 1);
+			break;
+
+		case GSW_QOS_CLASS_SELECT_SPCP_DSCP:
+			gsw_w32(cdev, (PCE_PCTRL_2_DSCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_DSCP_SHIFT,
+				PCE_PCTRL_2_DSCP_SIZE, 1);
+			gsw_w32(cdev, (PCE_PCTRL_2_PCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_PCP_SHIFT,
+				PCE_PCTRL_2_PCP_SIZE, 0);
+			gsw_w32(cdev, (PCE_PCTRL_2_SPCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_SPCP_SHIFT,
+				PCE_PCTRL_2_SPCP_SIZE, 1);
+			break;
+
+		case GSW_QOS_CLASS_SELECT_DSCP_SPCP:
+			gsw_w32(cdev, (PCE_PCTRL_2_DSCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_DSCP_SHIFT,
+				PCE_PCTRL_2_DSCP_SIZE, 2);
+			gsw_w32(cdev, (PCE_PCTRL_2_PCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_PCP_SHIFT,
+				PCE_PCTRL_2_PCP_SIZE, 0);
+			gsw_w32(cdev, (PCE_PCTRL_2_SPCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_SPCP_SHIFT,
+				PCE_PCTRL_2_SPCP_SIZE, 1);
+			break;
+
+		case GSW_QOS_CLASS_SELECT_SPCP_PCP:
+			gsw_w32(cdev, (PCE_PCTRL_2_DSCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_DSCP_SHIFT,
+				PCE_PCTRL_2_DSCP_SIZE, 0);
+			gsw_w32(cdev, (PCE_PCTRL_2_PCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_PCP_SHIFT,
+				PCE_PCTRL_2_PCP_SIZE, 1);
+			gsw_w32(cdev, (PCE_PCTRL_2_SPCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_SPCP_SHIFT,
+				PCE_PCTRL_2_SPCP_SIZE, 1);
+			break;
+
+		case GSW_QOS_CLASS_SELECT_SPCP_PCP_DSCP:
+			gsw_w32(cdev, (PCE_PCTRL_2_DSCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_DSCP_SHIFT,
+				PCE_PCTRL_2_DSCP_SIZE, 1);
+			gsw_w32(cdev, (PCE_PCTRL_2_PCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_PCP_SHIFT,
+				PCE_PCTRL_2_PCP_SIZE, 1);
+			gsw_w32(cdev, (PCE_PCTRL_2_SPCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_SPCP_SHIFT,
+				PCE_PCTRL_2_SPCP_SIZE, 1);
+			break;
+
+		case GSW_QOS_CLASS_SELECT_DSCP_SPCP_PCP:
+			gsw_w32(cdev, (PCE_PCTRL_2_DSCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_DSCP_SHIFT,
+				PCE_PCTRL_2_DSCP_SIZE, 2);
+			gsw_w32(cdev, (PCE_PCTRL_2_PCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_PCP_SHIFT,
+				PCE_PCTRL_2_PCP_SIZE, 1);
+			gsw_w32(cdev, (PCE_PCTRL_2_SPCP_OFFSET +
+				       (10 * parm->nPortId)),
+				PCE_PCTRL_2_SPCP_SHIFT,
+				PCE_PCTRL_2_SPCP_SIZE, 1);
+			break;
+		}
+	}
+
+	/*PCLASS is removed in PCE_PCTRL_2 for GSWIP 3.1*/
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (parm->nTrafficClass > 0xF) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		} else {
+			gsw_w32(cdev, PCE_PCTRL_2_PCLASS_OFFSET
+				+ (10 * parm->nPortId),
+				PCE_PCTRL_2_PCLASS_SHIFT,
+				PCE_PCTRL_2_PCLASS_SIZE,
+				parm->nTrafficClass);
+		}
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_QueuePortGet(void *cdev,
+				  GSW_QoS_queuePort_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	bmtbl_prog_t bmtable = {0};
+	u32 sPceBpReg = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d\n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	memset(&pcetable, 0, sizeof(pctbl_prog_t));
+	pcetable.table = PCE_QUEUE_MAP_INDEX;
+	pcetable.pcindex = ((parm->nPortId << 4) | parm->nTrafficClassId);
+
+	if ((gswdev->gipver == LTQ_GSWIP_3_0 && parm->bRedirectionBypass) ||
+	    (IS_VRSN_31(gswdev->gipver) && parm->bExtrationEnable)) {
+		pcetable.pcindex |= (1 << 8);
+	}
+
+	gsw_pce_table_read(cdev, &pcetable);
+	parm->nQueueId = (pcetable.val[0] & 0x3F);
+
+	if (IS_VRSN_31(gswdev->gipver) && parm->bRedirectionBypass) {
+		/* PCE Bypass Configuration. GSWIP-3.1 only. */
+		gsw_r32_raw(cdev, (SDMA_BYPASS_PCE_REG_OFFSET + (parm->nPortId * 0x6)),
+			    &sPceBpReg);
+		GET_VAL_FROM_REG(parm->eQMapMode, SDMA_BYPASS_PCE_MD_SHIFT, SDMA_BYPASS_PCE_MD_SIZE, sPceBpReg);
+
+		if (!parm->bExtrationEnable) {
+			GET_VAL_FROM_REG(parm->nQueueId, SDMA_BYPASS_PCE_NMQID_SHIFT, SDMA_BYPASS_PCE_NMQID_SIZE, sPceBpReg);
+		} else {
+			GET_VAL_FROM_REG(parm->nQueueId, SDMA_BYPASS_PCE_EXTQID_SHIFT, SDMA_BYPASS_PCE_EXTQID_SIZE, sPceBpReg);
+		}
+	}
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+		bmtable.adr.qMapTbl.nQueueId = parm->nQueueId;
+		bmtable.tableID = (BM_Table_ID) BUF_MGR_Q_MAP_TABLE;
+		bmtable.numValues = 1;
+		gsw_bm_table_read(cdev, &bmtable);
+		parm->nRedirectPortId = (bmtable.value[0] & 0x7);
+		parm->nRedirectPortId |= ((bmtable.value[0] >> 1) & 0x8);
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_QueuePortSet(void *cdev,
+				  GSW_QoS_queuePort_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u32  eport = 0, qid, sPceBpReg = 0;
+	bmtbl_prog_t bmtable = {0};
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+		GSW_Freeze();
+	}
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (IS_VRSN_30_31(gswdev->gipver))
+		qid = parm->nQueueId & 0x1F;
+	else
+		qid = parm->nQueueId & 0x3F;
+
+	if (IS_VRSN_31(gswdev->gipver) && parm->bRedirectionBypass) {
+		/* PCE Bypass Configuration. GSWIP-3.1 only. */
+		gsw_r32_raw(cdev, (SDMA_BYPASS_PCE_REG_OFFSET + (parm->nPortId * 0x6)),
+			    &sPceBpReg);
+
+		//Populate PCE Bypass control register.
+		if (!parm->bExtrationEnable) {
+			if (parm->eQMapMode == GSW_QOS_QMAP_SINGLE_MODE)
+				CLEAR_FILL_CTRL_REG(sPceBpReg, SDMA_BYPASS_PCE_MD_SHIFT,
+						    SDMA_BYPASS_PCE_MD_SIZE, 1);
+			else
+				CLEAR_FILL_CTRL_REG(sPceBpReg, SDMA_BYPASS_PCE_MD_SHIFT,
+						    SDMA_BYPASS_PCE_MD_SIZE, 0);
+
+			CLEAR_FILL_CTRL_REG(sPceBpReg, SDMA_BYPASS_PCE_NMQID_SHIFT,
+					    SDMA_BYPASS_PCE_NMQID_SIZE, qid);
+		} else {
+			CLEAR_FILL_CTRL_REG(sPceBpReg, SDMA_BYPASS_PCE_EXTQID_SHIFT,
+					    SDMA_BYPASS_PCE_EXTQID_SIZE, qid);
+		}
+
+		gsw_w32_raw(cdev, (SDMA_BYPASS_PCE_REG_OFFSET + (parm->nPortId * 0x6)),
+			    sPceBpReg);
+	} else {
+		/*Program Queue Mapping Table*/
+		memset(&pcetable, 0, sizeof(pctbl_prog_t));
+		pcetable.table = PCE_QUEUE_MAP_INDEX;
+		pcetable.pcindex = ((parm->nPortId & 0x0F) << 4) |
+				   (parm->nTrafficClassId & 0x0F);
+
+		if ((gswdev->gipver == LTQ_GSWIP_3_0 && parm->bRedirectionBypass) ||
+		    (IS_VRSN_31(gswdev->gipver) && parm->bExtrationEnable)) {
+			pcetable.pcindex |= 1 << 8;
+		}
+
+		pcetable.val[0] = qid;
+		gsw_pce_table_write(cdev, &pcetable);
+	}
+
+	/*Program BM table*/
+	/* Assign the Egress Port Id and Enable the Queue */
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		eport = (parm->nPortId & 0xF) << 8;
+		eport |= (parm->nRedirectPortId & 0x7);
+		eport |= (((parm->nRedirectPortId >> 3) & 0x1) << 4);
+	} else if (IS_VRSN_31(gswdev->gipver)) {
+		eport = (parm->nRedirectPortId & 0x7);
+		eport |= (((parm->nRedirectPortId >> 3) & 0x1) << 4);
+	} else {
+		eport = (parm->nPortId & 0x7);
+		eport |= (((parm->nPortId >> 3) & 0x1) << 4);
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	bmtable.value[0] = eport;
+	bmtable.adr.qMapTbl.nQueueId = parm->nQueueId;
+	bmtable.tableID = BUF_MGR_Q_MAP_TABLE;
+	bmtable.numValues = 1;
+	ret = gsw_bm_table_write(cdev, &bmtable);
+	if (IS_VRSN_31(gswdev->gipver)) {
+		GSW_UnFreeze();
+	}
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+
+}
+
+GSW_return_t GSW_QoS_SchedulerCfgGet(void *cdev,
+				     GSW_QoS_schedulerCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	int qid = parm->nQueueId;
+	bmtbl_prog_t bmtable = {0};
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	/*	gsw_r32(cdev, ETHSW_CAP_1_QUEUE_OFFSET,*/
+	/*		ETHSW_CAP_1_QUEUE_SHIFT, */
+	/*		ETHSW_CAP_1_QUEUE_SIZE, &value); */
+	if (qid >= gswdev->num_of_queues) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	bmtable.adr.wfq.nQueueId = qid;
+	bmtable.tableID = (BM_Table_ID) WFQ_PARAM;
+	bmtable.numValues = 1;
+	gsw_bm_table_read(cdev, &bmtable);
+
+	parm->nWeight = bmtable.value[0];
+
+	if ((bmtable.value[0] == 0xFFFF) || (bmtable.value[0] == 0x1800))
+		parm->eType = GSW_QOS_SCHEDULER_STRICT;
+	else
+		parm->eType = GSW_QOS_SCHEDULER_WFQ;
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_SchedulerCfgSet(void *cdev,
+				     GSW_QoS_schedulerCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	int qid = parm->nQueueId;
+	bmtbl_prog_t bmtable = {0};
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	/*	gsw_r32(cdev, ETHSW_CAP_1_QUEUE_OFFSET, */
+	/*		ETHSW_CAP_1_QUEUE_SHIFT, */
+	/*		ETHSW_CAP_1_QUEUE_SIZE, &value); */
+	if (qid >= gswdev->num_of_queues) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if ((parm->eType == GSW_QOS_SCHEDULER_WFQ) && (parm->nWeight == 0)) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	bmtable.adr.wfq.nQueueId = qid;
+	bmtable.value[0] = (GSW_QOS_SCHEDULER_STRICT == parm->eType) ? 0xFFFF : parm->nWeight;
+	bmtable.tableID = WFQ_PARAM;
+	bmtable.numValues = 1;
+	gsw_bm_table_write(cdev, &bmtable);
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_ShaperCfgGet(void *cdev,
+				  GSW_QoS_ShaperCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	int rshid = parm->nRateShaperId;
+	u32  value, exp, mant, ibs;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (rshid >= gswdev->num_of_shapers) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/* Enable/Disable the rate shaper  */
+	gsw_r32(cdev, RS_CTRL_RSEN_OFFSET + (rshid * 0x5),
+		RS_CTRL_RSEN_SHIFT, RS_CTRL_RSEN_SIZE, &value);
+	parm->bEnable = value;
+	/* Committed Burst Size (CBS [bytes]) */
+	gsw_r32(cdev, RS_CBS_CBS_OFFSET + (rshid * 0x5),
+		RS_CBS_CBS_SHIFT, RS_CBS_CBS_SIZE, &value);
+	parm->nCbs = (value * 64);
+	/** Rate [Mbit/s] */
+	gsw_r32(cdev, RS_CIR_EXP_EXP_OFFSET + (rshid * 0x5),
+		RS_CIR_EXP_EXP_SHIFT, RS_CIR_EXP_EXP_SIZE, &exp);
+	gsw_r32(cdev, RS_CIR_MANT_MANT_OFFSET + (rshid * 0x5),
+		RS_CIR_MANT_MANT_SHIFT, RS_CIR_MANT_MANT_SIZE, &mant);
+
+	if (IS_VRSN_31(gswdev->gipver))
+		gsw_r32(cdev, RS_IBS_IBS_OFFSET + (rshid * 0x5),
+			RS_IBS_IBS_SHIFT, RS_IBS_IBS_SIZE_GSWIP_3_1, &ibs);
+	else
+		gsw_r32(cdev, RS_IBS_IBS_OFFSET + (rshid * 0x5),
+			RS_IBS_IBS_SHIFT, RS_IBS_IBS_SIZE, &ibs);
+
+	/* calc the Rate */
+	if (IS_VRSN_31(gswdev->gipver))
+		parm->nRate = mratecalc_3_1(ibs, exp, mant);
+	else
+		parm->nRate = mratecalc(ibs, exp, mant);
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (IS_VRSN_30_31(gswdev->gipver))) {
+		gsw_r32(cdev, RS_CTRL_RSMOD_OFFSET + (rshid * 0x5),
+			RS_CTRL_RSMOD_SHIFT, RS_CTRL_RSMOD_SIZE, &parm->bAVB);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_ShaperCfgSet(void *cdev,
+				  GSW_QoS_ShaperCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	int rshid = parm->nRateShaperId;
+	u32  value, exp = 0, mant = 0, rate = 0, ibs = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (rshid >= gswdev->num_of_shapers) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/* Committed Burst Size */
+	if (parm->nCbs > 0xFFC0)
+		value = 0x3FF;
+	else
+		value = ((parm->nCbs + 63) / 64);
+
+	/* Committed Burst Size (CBS [bytes]) */
+	gsw_w32(cdev, RS_CBS_CBS_OFFSET + (rshid * 0x5),
+		RS_CBS_CBS_SHIFT, RS_CBS_CBS_SIZE, value);
+	/* Rate [kbit/s] */
+	/* Calc the Rate */
+	rate = parm->nRate;
+
+	if (rate) {
+		if (IS_VRSN_31(gswdev->gipver))
+			calc_mtoken_3_1(rate, &ibs, &exp, &mant);
+		else
+			calc_mtoken(rate, &ibs, &exp, &mant);
+	}
+
+	//Set CIR Exponent and Mantissa.
+	gsw_w32(cdev, RS_CIR_EXP_EXP_OFFSET + (rshid * 0x5),
+		RS_CIR_EXP_EXP_SHIFT, RS_CIR_EXP_EXP_SIZE, exp);
+	gsw_w32(cdev, RS_CIR_MANT_MANT_OFFSET + (rshid * 0x5),
+		RS_CIR_MANT_MANT_SHIFT, RS_CIR_MANT_MANT_SIZE, mant);
+
+	//Set Instantaneous Burst Size.
+	if (IS_VRSN_31(gswdev->gipver))
+		gsw_w32(cdev, RS_IBS_IBS_OFFSET + (rshid * 0x5),
+			RS_IBS_IBS_SHIFT, RS_IBS_IBS_SIZE_GSWIP_3_1, ibs);
+	else
+		gsw_w32(cdev, RS_IBS_IBS_OFFSET + (rshid * 0x5),
+			RS_IBS_IBS_SHIFT, RS_IBS_IBS_SIZE, ibs);
+
+	/* Enable/Disable the Rate Shaper  */
+	gsw_w32(cdev, RS_CTRL_RSEN_OFFSET + (rshid * 0x5),
+		RS_CTRL_RSEN_SHIFT, RS_CTRL_RSEN_SIZE, parm->bEnable);
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (IS_VRSN_30_31(gswdev->gipver))) {
+		gsw_w32(cdev, RS_CTRL_RSMOD_OFFSET + (rshid * 0x5),
+			RS_CTRL_RSMOD_SHIFT, RS_CTRL_RSMOD_SIZE, parm->bAVB);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_ShaperQueueAssign(void *cdev,
+				       GSW_QoS_ShaperQueue_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 rshid = parm->nRateShaperId, qid = parm->nQueueId;
+	u32 value1_RS, value1_ShaperId, value2_RS, value2_ShaperId;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (qid >= gswdev->num_of_queues) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if (rshid >= gswdev->num_of_shapers) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/* Check Rate Shaper 1 Enable  */
+	gsw_r32(cdev, PQM_RS_EN1_OFFSET + (qid * 2),
+		PQM_RS_EN1_SHIFT, PQM_RS_EN1_SIZE, &value1_RS);
+	gsw_r32(cdev, PQM_RS_RS1_OFFSET + (qid * 2),
+		PQM_RS_RS1_SHIFT, PQM_RS_RS1_SIZE, &value1_ShaperId);
+	/* Check Rate Shaper 2 Enable  */
+	gsw_r32(cdev, PQM_RS_EN2_OFFSET + (qid * 2),
+		PQM_RS_EN2_SHIFT, PQM_RS_EN2_SIZE, &value2_RS);
+	gsw_r32(cdev, PQM_RS_RS2_OFFSET + (qid * 2),
+		PQM_RS_RS2_SHIFT, PQM_RS_RS2_SIZE, &value2_ShaperId);
+
+	if ((value1_RS == 1) && (value1_ShaperId == rshid)) {
+		ret = GSW_statusOk;
+		goto UNLOCK_AND_RETURN;
+	} else if ((value2_RS == 1) && (value2_ShaperId == rshid)) {
+		ret = GSW_statusOk;
+		goto UNLOCK_AND_RETURN;
+	} else if (value1_RS == 0) {
+		gswdev->shaper_idx[rshid].usageCount++;
+		gsw_w32(cdev, PQM_RS_RS1_OFFSET + (qid * 2),
+			PQM_RS_RS1_SHIFT, PQM_RS_RS1_SIZE, rshid);
+		gsw_w32(cdev, PQM_RS_EN1_OFFSET + (qid * 2),
+			PQM_RS_EN1_SHIFT, PQM_RS_EN1_SIZE, 0x1);
+		//Govind - Already enabled in ShaperCfgSet.
+		gsw_w32(cdev, RS_CTRL_RSEN_OFFSET + (rshid * 0x5),
+			RS_CTRL_RSEN_SHIFT, RS_CTRL_RSEN_SIZE, 0x1);
+	} else if (value2_RS == 0) {
+		gswdev->shaper_idx[rshid].usageCount++;
+		gsw_w32(cdev, PQM_RS_RS2_OFFSET + (qid * 2),
+			PQM_RS_RS2_SHIFT, PQM_RS_RS2_SIZE, rshid);
+		gsw_w32(cdev, PQM_RS_EN2_OFFSET + (qid * 2),
+			PQM_RS_EN2_SHIFT, PQM_RS_EN2_SIZE, 0x1);
+		//Govind - Already enabled in ShaperCfgSet.
+		gsw_w32(cdev, RS_CTRL_RSEN_OFFSET + (rshid * 0x5),
+			RS_CTRL_RSEN_SHIFT, RS_CTRL_RSEN_SIZE, 0x1);
+	} else {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_ShaperQueueDeassign(void *cdev,
+		GSW_QoS_ShaperQueue_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 rshid = parm->nRateShaperId, qid = parm->nQueueId;
+	u32 value1, value2, value3, value4;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (qid >= gswdev->num_of_queues) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if (rshid >= gswdev->num_of_shapers) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/* Rate Shaper 1 Read  */
+	gsw_r32(cdev, PQM_RS_EN1_OFFSET + (qid * 2),
+		PQM_RS_EN1_SHIFT, PQM_RS_EN1_SIZE, &value1);
+	gsw_r32(cdev, PQM_RS_RS1_OFFSET + (qid * 2),
+		PQM_RS_RS1_SHIFT, PQM_RS_RS1_SIZE, &value2);
+	/* Rate Shaper 2 Read  */
+	gsw_r32(cdev, PQM_RS_EN2_OFFSET + (qid * 2),
+		PQM_RS_EN2_SHIFT, PQM_RS_EN2_SIZE, &value3);
+	gsw_r32(cdev, PQM_RS_RS2_OFFSET + (qid * 2),
+		PQM_RS_RS2_SHIFT, PQM_RS_RS2_SIZE, &value4);
+
+	if ((value1 == 1) && (value2 == rshid)) {
+		gswdev->shaper_idx[rshid].usageCount--;
+		gsw_w32(cdev, PQM_RS_EN1_OFFSET + (qid * 2),
+			PQM_RS_EN1_SHIFT, PQM_RS_EN1_SIZE, 0);
+		gsw_w32(cdev, PQM_RS_RS1_OFFSET + (qid * 2),
+			PQM_RS_RS1_SHIFT, PQM_RS_RS1_SIZE, 0);
+		ret = GSW_statusOk;
+		goto UNLOCK_AND_RETURN;
+	} else if ((value3 == 1) && (value4 == rshid)) {
+		gswdev->shaper_idx[rshid].usageCount--;
+		gsw_w32(cdev, PQM_RS_EN2_OFFSET + (qid * 2),
+			PQM_RS_EN2_SHIFT, PQM_RS_EN2_SIZE, 0);
+		gsw_w32(cdev, PQM_RS_RS2_OFFSET + (qid * 2),
+			PQM_RS_RS2_SHIFT, PQM_RS_RS2_SIZE, 0);
+		ret = GSW_statusOk;
+		goto UNLOCK_AND_RETURN;
+	} else {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if ((value1 == 0) && (value3 == 0) &&
+	    (0 == gswdev->shaper_idx[rshid].usageCount)) {
+		gsw_w32(cdev, RS_CTRL_RSEN_OFFSET + (rshid * 0x5),
+			RS_CTRL_RSEN_SHIFT, RS_CTRL_RSEN_SIZE, 0);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_ShaperQueueGet(void *cdev,
+				    GSW_QoS_ShaperQueueGet_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 rsh, value;
+	u8 qid = parm->nQueueId;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (qid >= gswdev->num_of_queues) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	parm->bAssigned = 0;
+	parm->nRateShaperId = 0;
+	gsw_r32(cdev, PQM_RS_EN1_OFFSET + (qid * 2),
+		PQM_RS_EN1_SHIFT, PQM_RS_EN1_SIZE, &rsh);
+
+	if (rsh == 1) {
+		parm->bAssigned = 1;
+		gsw_r32(cdev, PQM_RS_RS1_OFFSET + (qid * 2),
+			PQM_RS_RS1_SHIFT, PQM_RS_RS1_SIZE, &value);
+		parm->nRateShaperId = value;
+	}
+
+	gsw_r32(cdev, PQM_RS_EN2_OFFSET + (qid * 2),
+		PQM_RS_EN2_SHIFT, PQM_RS_EN2_SIZE, &rsh);
+
+	if (rsh == 1) {
+		gsw_r32(cdev, PQM_RS_RS2_OFFSET + (qid * 2),
+			PQM_RS_RS2_SHIFT, PQM_RS_RS2_SIZE, &value);
+		parm->nRateShaperId = value;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_StormCfgSet(void *cdev,
+				 GSW_QoS_stormCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 SCONBC, SCONMC, SCONUC, mid;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if ((parm->bBroadcast == 0) &&
+	    (parm->bMulticast == 0)	&&
+	    (parm->bUnknownUnicast == 0)) {
+		/*  Storm Control Mode  */
+		gsw_w32(cdev, PCE_GCTRL_0_SCONMOD_OFFSET,
+			PCE_GCTRL_0_SCONMOD_SHIFT,
+			PCE_GCTRL_0_SCONMOD_SIZE, 0);
+		/* Meter instances used for broadcast traffic */
+		gsw_w32(cdev, PCE_GCTRL_0_SCONBC_OFFSET,
+			PCE_GCTRL_0_SCONBC_SHIFT,
+			PCE_GCTRL_0_SCONBC_SIZE, 0);
+		/* Meter instances used for multicast traffic */
+		gsw_w32(cdev, PCE_GCTRL_0_SCONMC_OFFSET,
+			PCE_GCTRL_0_SCONMC_SHIFT,
+			PCE_GCTRL_0_SCONMC_SIZE, 0);
+		/* Meter instances used for unknown unicast traffic */
+		gsw_w32(cdev, PCE_GCTRL_0_SCONUC_OFFSET,
+			PCE_GCTRL_0_SCONUC_SHIFT,
+			PCE_GCTRL_0_SCONUC_SIZE, 0);
+	}
+
+	/*  Meter ID */
+	gsw_r32(cdev, PCE_GCTRL_0_SCONMET_OFFSET,
+		PCE_GCTRL_0_SCONMET_SHIFT,
+		PCE_GCTRL_0_SCONMET_SIZE, &mid);
+	/* Meter instances used for broadcast traffic */
+	gsw_r32(cdev, PCE_GCTRL_0_SCONBC_OFFSET,
+		PCE_GCTRL_0_SCONBC_SHIFT,
+		PCE_GCTRL_0_SCONBC_SIZE, &SCONBC);
+	/* Meter instances used for multicast traffic */
+	gsw_r32(cdev, PCE_GCTRL_0_SCONMC_OFFSET,
+		PCE_GCTRL_0_SCONMC_SHIFT,
+		PCE_GCTRL_0_SCONMC_SIZE, &SCONMC);
+	/* Meter instances used for unknown unicast traffic */
+	gsw_r32(cdev, PCE_GCTRL_0_SCONUC_OFFSET,
+		PCE_GCTRL_0_SCONUC_SHIFT,
+		PCE_GCTRL_0_SCONUC_SIZE, &SCONUC);
+
+	if ((SCONBC == 1) || (SCONMC == 1) || (SCONMC == 1)) {
+		if (parm->nMeterId == (mid + 1)) {
+			/*  Storm Control Mode  */
+			gsw_w32(cdev, PCE_GCTRL_0_SCONMOD_OFFSET,
+				PCE_GCTRL_0_SCONMOD_SHIFT,
+				PCE_GCTRL_0_SCONMOD_SIZE, 3);
+		} else if (parm->nMeterId != mid) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	} else {
+		/*  Storm Control Mode */
+		gsw_w32(cdev, PCE_GCTRL_0_SCONMOD_OFFSET,
+			PCE_GCTRL_0_SCONMOD_SHIFT,
+			PCE_GCTRL_0_SCONMOD_SIZE, 1);
+		gsw_w32(cdev, PCE_GCTRL_0_SCONMET_OFFSET,
+			PCE_GCTRL_0_SCONMET_SHIFT,
+			PCE_GCTRL_0_SCONMET_SIZE, parm->nMeterId);
+	}
+
+	/* Meter instances used for broadcast traffic */
+	gsw_w32(cdev, PCE_GCTRL_0_SCONBC_OFFSET,
+		PCE_GCTRL_0_SCONBC_SHIFT,
+		PCE_GCTRL_0_SCONBC_SIZE, parm->bBroadcast);
+	/* Meter instances used for multicast traffic */
+	gsw_w32(cdev, PCE_GCTRL_0_SCONMC_OFFSET,
+		PCE_GCTRL_0_SCONMC_SHIFT,
+		PCE_GCTRL_0_SCONMC_SIZE, parm->bMulticast);
+	/* Meter instances used for unknown unicast traffic */
+	gsw_w32(cdev, PCE_GCTRL_0_SCONUC_OFFSET,
+		PCE_GCTRL_0_SCONUC_SHIFT,
+		PCE_GCTRL_0_SCONUC_SIZE, parm->bUnknownUnicast);
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_StormCfgGet(void *cdev,
+				 GSW_QoS_stormCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	/*  Storm Control Mode  */
+	gsw_r32(cdev, PCE_GCTRL_0_SCONMOD_OFFSET,
+		PCE_GCTRL_0_SCONMOD_SHIFT,
+		PCE_GCTRL_0_SCONMOD_SIZE, &value);
+
+	if (value == 0) {
+		parm->nMeterId = 0;
+		parm->bBroadcast = 0;
+		parm->bMulticast = 0;
+		parm->bUnknownUnicast =  0;
+	} else {
+		gsw_r32(cdev, PCE_GCTRL_0_SCONMET_OFFSET,
+			PCE_GCTRL_0_SCONMET_SHIFT,
+			PCE_GCTRL_0_SCONMET_SIZE, &value);
+		parm->nMeterId = value;
+		/* Meter instances used for broadcast traffic */
+		gsw_r32(cdev, PCE_GCTRL_0_SCONBC_OFFSET,
+			PCE_GCTRL_0_SCONBC_SHIFT,
+			PCE_GCTRL_0_SCONBC_SIZE, &value);
+		parm->bBroadcast = value;
+		/* Meter instances used for multicast traffic */
+		gsw_r32(cdev, PCE_GCTRL_0_SCONMC_OFFSET,
+			PCE_GCTRL_0_SCONMC_SHIFT,
+			PCE_GCTRL_0_SCONMC_SIZE, &value);
+		parm->bMulticast = value;
+		/* Meter instances used for unknown unicast traffic */
+		gsw_r32(cdev, PCE_GCTRL_0_SCONUC_OFFSET,
+			PCE_GCTRL_0_SCONUC_SHIFT,
+			PCE_GCTRL_0_SCONUC_SIZE, &value);
+		parm->bUnknownUnicast = value;
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_WredCfgGet(void *cdev,
+				GSW_QoS_WRED_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 Gl_Mod_Size = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	/* Description: 'Drop Probability Profile' */
+	gsw_r32(cdev, BM_QUEUE_GCTRL_DPROB_OFFSET,
+		BM_QUEUE_GCTRL_DPROB_SHIFT,
+		BM_QUEUE_GCTRL_DPROB_SIZE, &parm->eProfile);
+
+	/*Automatic/Manual - Adaptive Watermark Type */
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+		gsw_r32(cdev, BM_QUEUE_GCTRL_BUFMOD_OFFSET,
+			BM_QUEUE_GCTRL_BUFMOD_SHIFT,
+			BM_QUEUE_GCTRL_BUFMOD_SIZE, &parm->eMode);
+	}
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (IS_VRSN_30_31(gswdev->gipver)))
+		Gl_Mod_Size = BM_QUEUE_GCTRL_GL_MOD_SIZE2;
+	else
+		Gl_Mod_Size = BM_QUEUE_GCTRL_GL_MOD_SIZE;
+
+	/* Get the Local/Global threshold */
+	gsw_r32(cdev, BM_QUEUE_GCTRL_GL_MOD_OFFSET,
+		BM_QUEUE_GCTRL_GL_MOD_SHIFT,
+		Gl_Mod_Size, &parm->eThreshMode);
+	/* WRED Red Threshold - Minimum */
+	gsw_r32(cdev, BM_WRED_RTH_0_MINTH_OFFSET,
+		BM_WRED_RTH_0_MINTH_SHIFT,
+		BM_WRED_RTH_0_MINTH_SIZE, &parm->nRed_Min);
+	/* WRED Red Threshold - Maximum */
+	gsw_r32(cdev, BM_WRED_RTH_1_MAXTH_OFFSET,
+		BM_WRED_RTH_1_MAXTH_SHIFT,
+		BM_WRED_RTH_1_MAXTH_SIZE, &parm->nRed_Max);
+	/* WRED Yellow Threshold - Minimum */
+	gsw_r32(cdev, BM_WRED_YTH_0_MINTH_OFFSET,
+		BM_WRED_YTH_0_MINTH_SHIFT,
+		BM_WRED_YTH_0_MINTH_SIZE, &parm->nYellow_Min);
+	/* WRED Yellow Threshold - Maximum */
+	gsw_r32(cdev, BM_WRED_YTH_1_MAXTH_OFFSET,
+		BM_WRED_YTH_1_MAXTH_SHIFT,
+		BM_WRED_YTH_1_MAXTH_SIZE, &parm->nYellow_Max);
+	/* WRED Green Threshold - Minimum */
+	gsw_r32(cdev, BM_WRED_GTH_0_MINTH_OFFSET,
+		BM_WRED_GTH_0_MINTH_SHIFT,
+		BM_WRED_GTH_0_MINTH_SIZE, &parm->nGreen_Min);
+	/* WRED Green Threshold - Maximum */
+	gsw_r32(cdev, BM_WRED_GTH_1_MAXTH_OFFSET,
+		BM_WRED_GTH_1_MAXTH_SHIFT,
+		BM_WRED_GTH_1_MAXTH_SIZE, &parm->nGreen_Max);
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_WredCfgSet(void *cdev,
+				GSW_QoS_WRED_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 Gl_Mod_Size = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	/* Description: 'Drop Probability Profile' */
+	gsw_w32(cdev, BM_QUEUE_GCTRL_DPROB_OFFSET,
+		BM_QUEUE_GCTRL_DPROB_SHIFT,
+		BM_QUEUE_GCTRL_DPROB_SIZE, parm->eProfile);
+
+	/* Automatic/Manual - Adaptive Watermark Type */
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+		gsw_w32(cdev, BM_QUEUE_GCTRL_BUFMOD_OFFSET,
+			BM_QUEUE_GCTRL_BUFMOD_SHIFT,
+			BM_QUEUE_GCTRL_BUFMOD_SIZE, parm->eMode);
+	}
+
+	//GL_MOD size
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (IS_VRSN_30_31(gswdev->gipver)))
+		Gl_Mod_Size = BM_QUEUE_GCTRL_GL_MOD_SIZE2;
+	else
+		Gl_Mod_Size = BM_QUEUE_GCTRL_GL_MOD_SIZE;
+
+	switch (parm->eThreshMode) {
+	case GSW_QOS_WRED_Local_Thresh:
+		/* Set the Local threshold */
+		gsw_w32(cdev, BM_QUEUE_GCTRL_GL_MOD_OFFSET,
+			BM_QUEUE_GCTRL_GL_MOD_SHIFT,
+			Gl_Mod_Size, 0x0);
+		break;
+
+	case GSW_QOS_WRED_Global_Thresh:
+		/* Set the global threshold */
+		gsw_w32(cdev, BM_QUEUE_GCTRL_GL_MOD_OFFSET,
+			BM_QUEUE_GCTRL_GL_MOD_SHIFT,
+			Gl_Mod_Size, 0x1);
+		break;
+
+	case GSW_QOS_WRED_Port_Thresh:
+		/* Port queue and Port WRED Thresholds */
+		gsw_w32(cdev, BM_QUEUE_GCTRL_GL_MOD_OFFSET,
+			BM_QUEUE_GCTRL_GL_MOD_SHIFT,
+			Gl_Mod_Size, 0x2);
+		break;
+
+	default:
+		/* Set the Local threshold */
+		gsw_w32(cdev, BM_QUEUE_GCTRL_GL_MOD_OFFSET,
+			BM_QUEUE_GCTRL_GL_MOD_SHIFT,
+			Gl_Mod_Size, 0x0);
+	}
+
+	/* WRED Red Threshold - Minimum */
+	gsw_w32(cdev, BM_WRED_RTH_0_MINTH_OFFSET,
+		BM_WRED_RTH_0_MINTH_SHIFT,
+		BM_WRED_RTH_0_MINTH_SIZE, parm->nRed_Min);
+	/* WRED Red Threshold - Maximum */
+	gsw_w32(cdev, BM_WRED_RTH_1_MAXTH_OFFSET,
+		BM_WRED_RTH_1_MAXTH_SHIFT,
+		BM_WRED_RTH_1_MAXTH_SIZE, parm->nRed_Max);
+	/* WRED Yellow Threshold - Minimum */
+	gsw_w32(cdev, BM_WRED_YTH_0_MINTH_OFFSET,
+		BM_WRED_YTH_0_MINTH_SHIFT,
+		BM_WRED_YTH_0_MINTH_SIZE, parm->nYellow_Min);
+	/* WRED Yellow Threshold - Maximum */
+	gsw_w32(cdev, BM_WRED_YTH_1_MAXTH_OFFSET,
+		BM_WRED_YTH_1_MAXTH_SHIFT,
+		BM_WRED_YTH_1_MAXTH_SIZE, parm->nYellow_Max);
+	/* WRED Green Threshold - Minimum */
+	gsw_w32(cdev, BM_WRED_GTH_0_MINTH_OFFSET,
+		BM_WRED_GTH_0_MINTH_SHIFT,
+		BM_WRED_GTH_0_MINTH_SIZE, parm->nGreen_Min);
+	/* WRED Green Threshold - Maximum */
+	gsw_w32(cdev, BM_WRED_GTH_1_MAXTH_OFFSET,
+		BM_WRED_GTH_1_MAXTH_SHIFT,
+		BM_WRED_GTH_1_MAXTH_SIZE, parm->nGreen_Max);
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_WredQueueCfgGet(void *cdev,
+				     GSW_QoS_WRED_QueueCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 qid = parm->nQueueId, addr;
+	u8 crcode;
+	u32 ret;
+	bmtbl_prog_t bmtable = {0};
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	/*	gsw_r32(cdev, ETHSW_CAP_1_QUEUE_OFFSET, */
+	/*		ETHSW_CAP_1_QUEUE_SHIFT, */
+	/*		ETHSW_CAP_1_QUEUE_SIZE, &value); */
+	if (qid >= gswdev->num_of_queues) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/* For different color 0(not drop) 1(Green) 2(Yellow) 3(Red) */
+	for (crcode = 1; crcode < 4; crcode++) {
+		addr = ((qid << 3) | crcode);
+
+		bmtable.adr.raw = (u16)addr;
+		bmtable.numValues = 2;
+		bmtable.tableID = (BM_Table_ID) PQM_THRESHOLD;
+		gsw_bm_table_read(cdev, &bmtable);
+
+		switch (crcode) {
+		case 3:
+			parm->nRed_Max = bmtable.value[1];
+			parm->nRed_Min = bmtable.value[0];
+			break;
+
+		case 2:
+			parm->nYellow_Max = bmtable.value[1];
+			parm->nYellow_Min = bmtable.value[0];
+			break;
+
+		case 1:
+			parm->nGreen_Max = bmtable.value[1];
+			parm->nGreen_Min = bmtable.value[0];
+			break;
+		}
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_WredQueueCfgSet(void *cdev,
+				     GSW_QoS_WRED_QueueCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 qid = parm->nQueueId, addr;
+	bmtbl_prog_t bmtable = {0};
+	u8 crcode;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	if (qid >= gswdev->num_of_queues) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/* For different color 0(not drop) 1(Green) 2(Yellow) 3(Red) */
+	for (crcode = 1; crcode < 4; crcode++) {
+		addr = (((qid << 3) & 0xF8) | crcode);
+
+		bmtable.adr.raw = (u16)addr;
+
+		switch (crcode) {
+		case 3:
+			bmtable.value[1] = parm->nRed_Max;
+			bmtable.value[0] = parm->nRed_Min;
+			break;
+
+		case 2:
+			bmtable.value[1] = parm->nYellow_Max;
+			bmtable.value[0] = parm->nYellow_Min;
+			break;
+
+		case 1:
+			bmtable.value[1] = parm->nGreen_Max;
+			bmtable.value[0] = parm->nGreen_Min;
+			break;
+		}
+
+		bmtable.tableID = PQM_THRESHOLD;
+		bmtable.numValues = 2;
+		gsw_bm_table_write(cdev, &bmtable);
+	}
+
+	/* Set the local threshold */
+	/*	gsw_w32(cdev, BM_QUEUE_GCTRL_GL_MOD_OFFSET, */
+	/*		BM_QUEUE_GCTRL_GL_MOD_SHIFT, */
+	/*		BM_QUEUE_GCTRL_GL_MOD_SIZE, 0); */
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_WredPortCfgGet(void *cdev,
+				    GSW_QoS_WRED_PortCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/* Supported for GSWIP 2.2 and newer and returns with*/
+	/*  an error for older hardware revisions. */
+	/** WRED Red Threshold Min [number of segments].*/
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (IS_VRSN_30_31(gswdev->gipver))) {
+		gsw_r32(cdev, (BM_PWRED_RTH_0_MINTH_OFFSET
+			       + (parm->nPortId * 0x6)),
+			BM_PWRED_RTH_0_MINTH_SHIFT,
+			BM_PWRED_RTH_0_MINTH_SIZE, &parm->nRed_Min);
+		/** WRED Red Threshold Max [number of segments].*/
+		gsw_r32(cdev, (BM_PWRED_RTH_1_MAXTH_OFFSET
+			       + (parm->nPortId * 0x6)),
+			BM_PWRED_RTH_1_MAXTH_SHIFT,
+			BM_PWRED_RTH_1_MAXTH_SIZE, &parm->nRed_Max);
+		/* WRED Yellow Threshold - Minimum */
+		gsw_r32(cdev, (BM_PWRED_YTH_0_MINTH_OFFSET
+			       + (parm->nPortId * 0x6)),
+			BM_PWRED_YTH_0_MINTH_SHIFT,
+			BM_PWRED_YTH_0_MINTH_SIZE, &parm->nYellow_Min);
+		/* WRED Yellow Threshold - Maximum */
+		gsw_r32(cdev, (BM_PWRED_YTH_1_MAXTH_OFFSET
+			       + (parm->nPortId * 0x6)),
+			BM_PWRED_YTH_1_MAXTH_SHIFT,
+			BM_PWRED_YTH_1_MAXTH_SIZE, &parm->nYellow_Max);
+		/* WRED Green Threshold - Minimum */
+		gsw_r32(cdev, (BM_PWRED_GTH_0_MINTH_OFFSET
+			       + (parm->nPortId * 0x6)),
+			BM_PWRED_GTH_0_MINTH_SHIFT,
+			BM_PWRED_GTH_0_MINTH_SIZE, &parm->nGreen_Min);
+		/* WRED Green Threshold - Maximum */
+		gsw_r32(cdev, (BM_PWRED_GTH_1_MAXTH_OFFSET
+			       + (parm->nPortId * 0x6)),
+			BM_PWRED_GTH_1_MAXTH_SHIFT,
+			BM_PWRED_GTH_1_MAXTH_SIZE, &parm->nGreen_Max);
+		ret = GSW_statusOk;
+	} else {
+		ret = GSW_statusErr;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_WredPortCfgSet(void *cdev,
+				    GSW_QoS_WRED_PortCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/* Supported for GSWIP 2.2 and newer and returns */
+	/* with an error for older hardware revisions. */
+	/** WRED Red Threshold Min [number of segments]. */
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (IS_VRSN_30_31(gswdev->gipver))) {
+		gsw_w32(cdev, (BM_PWRED_RTH_0_MINTH_OFFSET
+			       + (parm->nPortId * 0x6)),
+			BM_PWRED_RTH_0_MINTH_SHIFT,
+			BM_PWRED_RTH_0_MINTH_SIZE, parm->nRed_Min);
+		/** WRED Red Threshold Max [number of segments]. */
+		gsw_w32(cdev, (BM_PWRED_RTH_1_MAXTH_OFFSET
+			       + (parm->nPortId * 0x6)),
+			BM_PWRED_RTH_1_MAXTH_SHIFT,
+			BM_PWRED_RTH_1_MAXTH_SIZE, parm->nRed_Max);
+		/* WRED Yellow Threshold - Minimum */
+		gsw_w32(cdev, (BM_PWRED_YTH_0_MINTH_OFFSET
+			       + (parm->nPortId * 0x6)),
+			BM_PWRED_YTH_0_MINTH_SHIFT,
+			BM_PWRED_YTH_0_MINTH_SIZE, parm->nYellow_Min);
+		/* WRED Yellow Threshold - Maximum */
+		gsw_w32(cdev, (BM_PWRED_YTH_1_MAXTH_OFFSET
+			       + (parm->nPortId * 0x6)),
+			BM_PWRED_YTH_1_MAXTH_SHIFT,
+			BM_PWRED_YTH_1_MAXTH_SIZE, parm->nYellow_Max);
+		/* WRED Green Threshold - Minimum */
+		gsw_w32(cdev, (BM_PWRED_GTH_0_MINTH_OFFSET
+			       + (parm->nPortId * 0x6)),
+			BM_PWRED_GTH_0_MINTH_SHIFT,
+			BM_PWRED_GTH_0_MINTH_SIZE, parm->nGreen_Min);
+		/* WRED Green Threshold - Maximum */
+		gsw_w32(cdev, (BM_PWRED_GTH_1_MAXTH_OFFSET
+			       + (parm->nPortId * 0x6)),
+			BM_PWRED_GTH_1_MAXTH_SHIFT,
+			BM_PWRED_GTH_1_MAXTH_SIZE, parm->nGreen_Max);
+		ret = GSW_statusOk;
+	} else {
+		ret = GSW_statusErr;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_FlowctrlCfgGet(void *cdev,
+				    GSW_QoS_FlowCtrlCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	/* Supported for GSWIP 2.2 and newer and returns */
+	/* with an error for older hardware revisions. */
+	/** Global Buffer Non Conforming Flow Control */
+	/*  Threshold Minimum [number of segments]. */
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (IS_VRSN_30_31(gswdev->gipver))) {
+		gsw_r32(cdev, (SDMA_FCTHR1_THR1_OFFSET),
+			SDMA_FCTHR1_THR1_SHIFT,
+			SDMA_FCTHR1_THR1_SIZE,
+			&parm->nFlowCtrlNonConform_Min);
+		/** Global Buffer Non Conforming Flow Control */
+		/* Threshold Maximum [number of segments]. */
+		gsw_r32(cdev, (SDMA_FCTHR2_THR2_OFFSET),
+			SDMA_FCTHR2_THR2_SHIFT,
+			SDMA_FCTHR2_THR2_SIZE,
+			&parm->nFlowCtrlNonConform_Max);
+		/** Global Buffer Conforming Flow Control Threshold */
+		/*  Minimum [number of segments]. */
+		gsw_r32(cdev, (SDMA_FCTHR3_THR3_OFFSET),
+			SDMA_FCTHR3_THR3_SHIFT,
+			SDMA_FCTHR3_THR3_SIZE,
+			&parm->nFlowCtrlConform_Min);
+		/** Global Buffer Conforming Flow Control */
+		/* Threshold Maximum [number of segments]. */
+		gsw_r32(cdev, (SDMA_FCTHR4_THR4_OFFSET),
+			SDMA_FCTHR4_THR4_SHIFT,
+			SDMA_FCTHR4_THR4_SIZE,
+			&parm->nFlowCtrlConform_Max);
+		ret = GSW_statusOk;
+	} else {
+		ret = GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_FlowctrlCfgSet(void *cdev,
+				    GSW_QoS_FlowCtrlCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	/* Supported for GSWIP 2.2 and newer and returns with */
+	/* an error for older hardware revisions. */
+	/** Global Buffer Non Conforming Flow Control */
+	/* Threshold Minimum [number of segments]. */
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (IS_VRSN_30_31(gswdev->gipver))) {
+		gsw_w32(cdev, (SDMA_FCTHR1_THR1_OFFSET),
+			SDMA_FCTHR1_THR1_SHIFT,
+			SDMA_FCTHR1_THR1_SIZE,
+			parm->nFlowCtrlNonConform_Min);
+		/** Global Buffer Non Conforming Flow Control */
+		/* Threshold Maximum [number of segments]. */
+		gsw_w32(cdev, (SDMA_FCTHR2_THR2_OFFSET),
+			SDMA_FCTHR2_THR2_SHIFT,
+			SDMA_FCTHR2_THR2_SIZE,
+			parm->nFlowCtrlNonConform_Max);
+		/** Global Buffer Conforming Flow Control Threshold */
+		/*  Minimum [number of segments]. */
+		gsw_w32(cdev, (SDMA_FCTHR3_THR3_OFFSET),
+			SDMA_FCTHR3_THR3_SHIFT,
+			SDMA_FCTHR3_THR3_SIZE,
+			parm->nFlowCtrlConform_Min);
+		/** Global Buffer Conforming Flow Control Threshold */
+		/*  Maximum [number of segments]. */
+		gsw_w32(cdev, (SDMA_FCTHR4_THR4_OFFSET),
+			SDMA_FCTHR4_THR4_SHIFT,
+			SDMA_FCTHR4_THR4_SIZE,
+			parm->nFlowCtrlConform_Max);
+		ret = GSW_statusOk;
+	} else {
+		ret = GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_FlowctrlPortCfgGet(void *cdev,
+					GSW_QoS_FlowCtrlPortCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/* Supported for GSWIP 2.2 and newer and returns with */
+	/* an error for older hardware revisions. */
+	/** Ingress Port occupied Buffer Flow Control */
+	/* Threshold Minimum [number of segments]. */
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC)) {
+		gsw_r32(cdev, (SDMA_PFCTHR8_THR8_OFFSET22
+			       + (parm->nPortId * 0x4)),
+			SDMA_PFCTHR8_THR8_SHIFT,
+			SDMA_PFCTHR8_THR8_SIZE, &parm->nFlowCtrl_Min);
+		/** Ingress Port occupied Buffer Flow Control */
+		/* Threshold Maximum [number of segments]. */
+		gsw_r32(cdev, (SDMA_PFCTHR9_THR9_OFFSET22
+			       + (parm->nPortId * 0x4)),
+			SDMA_PFCTHR9_THR9_SHIFT,
+			SDMA_PFCTHR9_THR9_SIZE, &parm->nFlowCtrl_Max);
+		ret = GSW_statusOk;
+	} else if (IS_VRSN_30_31(gswdev->gipver)) {
+		/** Ingress Port occupied Buffer Flow Control */
+		/* Threshold Minimum [number of segments]. */
+		gsw_r32(cdev, (SDMA_PFCTHR8_THR8_OFFSET30
+			       + (parm->nPortId * 0x2)),
+			SDMA_PFCTHR8_THR8_SHIFT,
+			SDMA_PFCTHR8_THR8_SIZE, &parm->nFlowCtrl_Min);
+		/** Ingress Port occupied Buffer Flow Control */
+		/* Threshold Maximum [number of segments]. */
+		gsw_r32(cdev, (SDMA_PFCTHR9_THR9_OFFSET30
+			       + (parm->nPortId * 0x2)),
+			SDMA_PFCTHR9_THR9_SHIFT,
+			SDMA_PFCTHR9_THR9_SIZE,
+			&parm->nFlowCtrl_Max);
+		ret = GSW_statusOk;
+	} else {
+		ret = GSW_statusErr;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_FlowctrlPortCfgSet(void *cdev,
+					GSW_QoS_FlowCtrlPortCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/* Supported for GSWIP 2.2 and newer and returns with */
+	/*  an error for older hardware revisions. */
+	/** Ingress Port occupied Buffer Flow Control */
+	/* Threshold Minimum [number of segments]. */
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC)) {
+		gsw_w32(cdev, (SDMA_PFCTHR8_THR8_OFFSET22
+			       + (parm->nPortId * 0x4)),
+			SDMA_PFCTHR8_THR8_SHIFT,
+			SDMA_PFCTHR8_THR8_SIZE, parm->nFlowCtrl_Min);
+		/** Ingress Port occupied Buffer Flow Control Threshold */
+		/* Maximum [number of segments]. */
+		gsw_w32(cdev, (SDMA_PFCTHR9_THR9_OFFSET22
+			       + (parm->nPortId * 0x4)),
+			SDMA_PFCTHR9_THR9_SHIFT,
+			SDMA_PFCTHR9_THR9_SIZE, parm->nFlowCtrl_Max);
+		ret = GSW_statusOk;
+	} else if (IS_VRSN_30_31(gswdev->gipver)) {
+		/** Ingress Port occupied Buffer Flow Control Threshold*/
+		/*  Minimum [number of segments]. */
+		gsw_w32(cdev, (SDMA_PFCTHR8_THR8_OFFSET30
+			       + (parm->nPortId * 0x2)),
+			SDMA_PFCTHR8_THR8_SHIFT,
+			SDMA_PFCTHR8_THR8_SIZE, parm->nFlowCtrl_Min);
+		/** Ingress Port occupied Buffer Flow Control Threshold */
+		/*  Maximum [number of segments]. */
+		gsw_w32(cdev, (SDMA_PFCTHR9_THR9_OFFSET30
+			       + (parm->nPortId * 0x2)),
+			SDMA_PFCTHR9_THR9_SHIFT,
+			SDMA_PFCTHR9_THR9_SIZE, parm->nFlowCtrl_Max);
+		ret = GSW_statusOk;
+	} else {
+		ret = GSW_statusErr;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QoS_QueueBufferReserveCfgGet(void *cdev,
+		GSW_QoS_QueueBufferReserveCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	bmtbl_prog_t bmtable = {0};
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	/*	gsw_r32(cdev, ETHSW_CAP_1_QUEUE_OFFSET, */
+	/*		ETHSW_CAP_1_QUEUE_SHIFT, */
+	/*		ETHSW_CAP_1_QUEUE_SIZE, &value); */
+	if (parm->nQueueId >= gswdev->num_of_queues) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/* Supported for GSWIP 2.2 and newer and returns with an error */
+	/*  for older hardware revisions. */
+	/* Colourcode = 0  and fixed offset = 0 */
+	/* Set the BM RAM ADDR  */
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (IS_VRSN_30_31(gswdev->gipver))) {
+		/* What about mode2, mode3 and mode1 with color  */
+		bmtable.adr.pqmThr.mode = 0; /*BM_RAM_ADDR.ADDR[2]=0 -> Mode 1*/
+		bmtable.adr.pqmThr.color_or_submode = 0; /* color = 0 (Not Drop eligible)*/
+		bmtable.adr.pqmThr.nQueueId = parm->nQueueId;
+		bmtable.tableID = (BM_Table_ID) PQM_THRESHOLD;
+		bmtable.numValues = 2;
+		gsw_bm_table_read(cdev, &bmtable);
+		/*Minimum threshold (used as reserved buffer threshold when color = 0)*/
+		parm->nBufferReserved = bmtable.value[0];
+		/* value[1] Maximum threshold (not used when color = 0) */
+		ret = GSW_statusOk;
+	} else {
+		ret = GSW_statusErr;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QoS_QueueBufferReserveCfgSet(void *cdev,
+		GSW_QoS_QueueBufferReserveCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	bmtbl_prog_t bmtable = {0};
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	/*	gsw_r32(cdev, ETHSW_CAP_1_QUEUE_OFFSET, */
+	/*		ETHSW_CAP_1_QUEUE_SHIFT, */
+	/*		ETHSW_CAP_1_QUEUE_SIZE, &value); */
+
+	if (parm->nQueueId >= gswdev->num_of_queues) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/* Supported for GSWIP 2.2 and newer and returns with an error */
+	/* for older hardware revisions. */
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (IS_VRSN_30_31(gswdev->gipver))) {
+		/* What about mode1 with color & mode2, mode3 */
+		bmtable.adr.pqmThr.mode = 0; /*BM_RAM_ADDR.ADDR[2]=0 -> Mode 1*/
+		bmtable.adr.pqmThr.color_or_submode = 0; /* color = 0 (Not Drop eligible)*/
+		bmtable.adr.pqmThr.nQueueId = parm->nQueueId;
+		bmtable.value[0] = parm->nBufferReserved;
+		/* value[1] Maximum threshold (not used when color = 0) */
+		bmtable.tableID = PQM_THRESHOLD;
+		bmtable.numValues = 2;
+		ret = gsw_bm_table_write(cdev, &bmtable);
+	} else {
+		ret = GSW_statusErr;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+}
+GSW_return_t GSW_QoS_Meter_Act(void *cdev,
+			       GSW_QoS_mtrAction_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32  value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (parm->nCpuUserId >= 2) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		value = parm->nMeterId;
+		gsw_w32(cdev, (PCE_CPUMETER_MID0_MID_OFFSET
+			       + (parm->nCpuUserId * 0x8)),
+			PCE_CPUMETER_MID0_MID_SHIFT,
+			PCE_CPUMETER_MID0_MID_SIZE, value);
+		gsw_w32(cdev, (PCE_CPUMETER_CTRL_MT0EN_OFFSET
+			       + (parm->nCpuUserId * 0x8)),
+			PCE_CPUMETER_CTRL_MT0EN_SHIFT,
+			PCE_CPUMETER_CTRL_MT0EN_SIZE, parm->bMeterEna);
+
+		value = parm->nSecMeterId;
+		gsw_w32(cdev, (PCE_CPUMETER_MID1_MID_OFFSET
+			       + (parm->nCpuUserId * 0x8)),
+			PCE_CPUMETER_MID1_MID_SHIFT,
+			PCE_CPUMETER_MID1_MID_SIZE, value);
+		gsw_w32(cdev, (PCE_CPUMETER_CTRL_MT1EN_OFFSET
+			       + (parm->nCpuUserId * 0x8)),
+			PCE_CPUMETER_CTRL_MT1EN_SHIFT,
+			PCE_CPUMETER_CTRL_MT1EN_SIZE, parm->bSecMeterEna);
+
+		value = parm->pktLen;
+		gsw_w32(cdev, (PCE_CPUMETER_SIZE_SIZE_OFFSET
+			       + (parm->nCpuUserId * 0x8)),
+			PCE_CPUMETER_SIZE_SIZE_SHIFT,
+			PCE_CPUMETER_SIZE_SIZE_SIZE, value);
+
+		gsw_w32(cdev, (PCE_CPUMETER_CTRL_PRECOL_OFFSET
+			       + (parm->nCpuUserId * 0x8)),
+			PCE_CPUMETER_CTRL_PRECOL_SHIFT,
+			PCE_CPUMETER_CTRL_PRECOL_SIZE, parm->ePreColor);
+		/*
+				gsw_w32(cdev, (PCE_CPUMETER_CTRL_REQ_OFFSET
+					+ (parm->nCpuUserId * 0x8)),
+					PCE_CPUMETER_CTRL_REQ_SHIFT,
+					PCE_CPUMETER_CTRL_REQ_SIZE, 1);
+
+				do {
+					gsw_r32(cdev, (PCE_CPUMETER_CTRL_REQ_OFFSET
+						+ (parm->nCpuUserId * 0x8)),
+						PCE_CPUMETER_CTRL_REQ_SHIFT,
+						PCE_CPUMETER_CTRL_REQ_SIZE, &value);
+				} while(value);
+
+				gsw_w32(cdev, PCE_CPUMETER_CTRL_AFTCOL_OFFSET
+					+ (parm->nCpuUserId * 0x8),
+					PCE_CPUMETER_CTRL_AFTCOL_SHIFT,
+					PCE_CPUMETER_CTRL_AFTCOL_SIZE, parm->eOutColor);
+		*/
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+#endif  /* CONFIG_LTQ_QOS */
+
+#if defined(CONFIG_LTQ_MULTICAST) && CONFIG_LTQ_MULTICAST
+GSW_return_t GSW_MulticastRouterPortAdd(void *cdev,
+					GSW_multicastRouter_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	gsw_igmp_t *hitbl = &gswdev->iflag;
+	u32 value = 0;
+	u8 pidx = parm->nPortId;
+	u32 ret;
+	static GSW_PCE_rule_t pcrule;
+	int i;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if ((IS_VRSN_NOT_31(gswdev->gipver)) ||
+	    ((IS_VRSN_31(gswdev->gipver)) && (gswdev->mcsthw_snoop == MCAST_HWSNOOP_EN))) {
+		//Govind - Below registers are not supported in 3.1. Need to take care of it?
+		/* Read the Default Router Port Map - DRPM */
+		gsw_r32(cdev, PCE_IGMP_DRPM_DRPM_OFFSET,
+			PCE_IGMP_DRPM_DRPM_SHIFT,
+			PCE_IGMP_DRPM_DRPM_SIZE, &value);
+
+		if (((value >> pidx) & 0x1) == 1) {
+			pr_err("Error: the prot was already in the member\n");
+		} else {
+			value = (value | (1 << pidx));
+			/* Write the Default Router Port Map - DRPM  */
+			gsw_w32(cdev, PCE_IGMP_DRPM_DRPM_OFFSET,
+				PCE_IGMP_DRPM_DRPM_SHIFT,
+				PCE_IGMP_DRPM_DRPM_SIZE, value);
+		}
+	}
+
+	if ((IS_VRSN_31(gswdev->gipver)) && (gswdev->mcsthw_snoop == MCAST_HWSNOOP_DIS)) {
+		//Govind - Returning an error for this case in read API?
+		pr_err("CPU Port for sending traffic %d\n", (1 << gswdev->cport));
+		// In PCE rule, need to program 1, for PMAC 0
+		value = (1 << gswdev->cport);
+	}
+
+	if (hitbl->igmode == GSW_MULTICAST_SNOOP_MODE_FORWARD) {
+
+
+		for (i = 0; i < 2; i++) {
+			memset(&pcrule, 0, sizeof(GSW_PCE_rule_t));
+			pcrule.pattern.bEnable = 1;
+			pcrule.pattern.bProtocolEnable = 1;
+
+			switch (i) {
+			case 0:
+				/*	Management port remaining IGMP packets (forwarding */
+				/* them to Router Ports) */
+				pcrule.pattern.nIndex = MPCE_RULES_INDEX;
+				pcrule.pattern.nProtocol = 0x2; /* IGMP */
+				pcrule.pattern.bAppMaskRangeMSB_Select = 1;
+				pcrule.pattern.bAppDataMSB_Enable	= 1;
+				pcrule.pattern.nAppDataMSB = 0x1200;
+				pcrule.pattern.nAppMaskRangeMSB	= 0x1DFF;
+				break;
+
+			case 1:
+				/* Management Port ICMPv6 Multicast Listerner Report */
+				/* & Leave (Avoiding Loopback abd Discard) */
+				pcrule.pattern.nIndex = MPCE_RULES_INDEX + 3;
+				pcrule.pattern.bAppDataMSB_Enable	= 1;
+				pcrule.pattern.bAppMaskRangeMSB_Select = 1;
+				pcrule.pattern.nAppDataMSB = 0x8300;
+				pcrule.pattern.nAppMaskRangeMSB	= 0x1FF;
+				pcrule.pattern.nProtocol = 0x3A;  /*for IPv6*/
+				break;
+			}
+
+			/* Router portmap */
+			pcrule.action.ePortMapAction =
+				GSW_PCE_ACTION_PORTMAP_ALTERNATIVE;
+			pcrule.action.nForwardPortMap[0] = value;
+
+			if (hitbl->igcos != 0) {
+				pcrule.action.eTrafficClassAction = 1; //Govind - this should be 2?
+				pcrule.action.nTrafficClassAlternate = gswdev->iflag.igcos;
+			}
+
+			/*  Set eForwardPort */
+			pcrule.pattern.bPortIdEnable = 1;
+
+			if (hitbl->igfport == GSW_PORT_FORWARD_PORT)
+				pcrule.pattern.nPortId = hitbl->igfpid;
+			else if (hitbl->igfport == GSW_PORT_FORWARD_CPU)
+				pcrule.pattern.nPortId = (gswdev->cport);
+
+			//Govind - what if both of above 'if' fails? Port-Id '0' will be written.
+
+			if (hitbl->igxvlan)
+				pcrule.action.eVLAN_CrossAction =
+					GSW_PCE_ACTION_CROSS_VLAN_CROSS;
+			else
+				pcrule.action.eVLAN_CrossAction =
+					GSW_PCE_ACTION_CROSS_VLAN_DISABLE;
+
+			/* We prepare everything and write into PCE Table */
+			if (0 != pce_rule_write(cdev,
+						&gswdev->phandler, &pcrule)) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		}
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_MulticastRouterPortRead(void *cdev,
+		GSW_multicastRouterRead_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value_1, value_2;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if ((IS_VRSN_31(gswdev->gipver)) && (gswdev->mcsthw_snoop == MCAST_HWSNOOP_DIS)) {
+		pr_err("%s:%s not supported in GSWIP v3.1 :%d\n", __FILE__, __func__, __LINE__);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	//Govind - Below registers are not supported in 3.1. Need to take care of it?
+	if (parm->bInitial == 1) {
+		/* Read the Default Router Port Map - DRPM*/
+		gsw_r32(cdev, PCE_IGMP_DRPM_DRPM_OFFSET,
+			PCE_IGMP_DRPM_DRPM_SHIFT,
+			PCE_IGMP_DRPM_DRPM_SIZE, &value_1);
+		/* Read the Default Router Port Map - IGPM */
+		gsw_r32(cdev, PCE_IGMP_STAT_IGPM_OFFSET,
+			PCE_IGMP_STAT_IGPM_SHIFT,
+			PCE_IGMP_STAT_IGPM_SIZE, &value_2);
+		gswdev->iflag.igrport = (value_1 | value_2);
+		parm->bInitial = 0;
+		gswdev->mrtpcnt = 0;
+	}
+
+	if (parm->bLast == 0) {
+		/* Need to clarify the different between DRPM & IGPM */
+		while (((gswdev->iflag.igrport >>
+			 gswdev->mrtpcnt) & 0x1) == 0) {
+			gswdev->mrtpcnt++;
+
+			if (gswdev->mrtpcnt > (gswdev->tpnum - 1)) {
+				parm->bLast = 1;
+				ret = GSW_statusOk;
+				goto UNLOCK_AND_RETURN;
+			}
+		}
+
+		parm->nPortId = gswdev->mrtpcnt;
+
+		if (gswdev->mrtpcnt < gswdev->tpnum)
+			gswdev->mrtpcnt++;
+		else
+			parm->bLast = 1;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_MulticastRouterPortRemove(void *cdev,
+		GSW_multicastRouter_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	gsw_igmp_t *hitbl	= &gswdev->iflag;
+	u32 value_1 = 0, value_2 = 0;
+	u8 pidx = parm->nPortId;
+	u32 ret;
+	static GSW_PCE_rule_t pcrule;
+	int i;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if ((IS_VRSN_NOT_31(gswdev->gipver)) ||
+	    ((IS_VRSN_31(gswdev->gipver)) && (gswdev->mcsthw_snoop == MCAST_HWSNOOP_EN))) {
+		//Govind - Below registers are not supported in 3.1. Need to take care of it?
+		/* Read the Default Router Port Map - DRPM */
+		gsw_r32(cdev, PCE_IGMP_DRPM_DRPM_OFFSET,
+			PCE_IGMP_DRPM_DRPM_SHIFT,
+			PCE_IGMP_DRPM_DRPM_SIZE, &value_1);
+		/* Read the Default Router Port Map - IGPM */
+		gsw_r32(cdev, PCE_IGMP_STAT_IGPM_OFFSET,
+			PCE_IGMP_STAT_IGPM_SHIFT,
+			PCE_IGMP_STAT_IGPM_SIZE, &value_2);
+
+		if (((value_1 >> pidx) & 0x1) == 0) {
+			pr_err("Error: the port was not in the member\n");
+			ret = GSW_statusOk;
+			goto UNLOCK_AND_RETURN;
+		} else {
+			value_1 = (value_1 & ~(1 << pidx));
+			/* Write the Default Router Port Map - DRPM*/
+			gsw_w32(cdev, PCE_IGMP_DRPM_DRPM_OFFSET,
+				PCE_IGMP_DRPM_DRPM_SHIFT,
+				PCE_IGMP_DRPM_DRPM_SIZE, value_1);
+		}
+	}
+
+	if ((IS_VRSN_31(gswdev->gipver)) && (gswdev->mcsthw_snoop == MCAST_HWSNOOP_DIS)) {
+		value_1 = gsw_check_hashtable_entry(cdev);
+	}
+
+	//Govind - Again creating a rule instaed of deleting?
+	if ((hitbl->igmode ==
+	     GSW_MULTICAST_SNOOP_MODE_FORWARD) & value_1) {
+
+		for (i = 0; i < 2; i++) {
+			memset(&pcrule, 0, sizeof(GSW_PCE_rule_t));
+			pcrule.pattern.bEnable = 1;
+			pcrule.pattern.bProtocolEnable = 1;
+
+			switch (i) {
+			case 0:
+				/*	Management port remaining IGMP packets */
+				/*(forwarding them to Router Ports) */
+				pcrule.pattern.nIndex = MPCE_RULES_INDEX;
+				/* for IPv4 */
+				pcrule.pattern.nProtocol = 0x2;
+				pcrule.pattern.bAppMaskRangeMSB_Select = 1;
+				pcrule.pattern.bAppDataMSB_Enable	= 1;
+				pcrule.pattern.nAppDataMSB = 0x1200;
+				pcrule.pattern.nAppMaskRangeMSB	= 0x1DFF;
+				break;
+
+			case 1:
+				/* Management Port ICMPv6 Multicast Listerner Report */
+				/* & Leave (Avoiding Loopback abd Discard) */
+				pcrule.pattern.nIndex = MPCE_RULES_INDEX + 3;
+				pcrule.pattern.bAppDataMSB_Enable	= 1;
+				pcrule.pattern.bAppMaskRangeMSB_Select = 1;
+				pcrule.pattern.nAppDataMSB = 0x8300;
+				pcrule.pattern.nAppMaskRangeMSB	= 0x1FF;
+				/*for IPv6*/
+				pcrule.pattern.nProtocol = 0x3A;
+				break;
+			}
+
+			/* Router portmap */
+			pcrule.action.ePortMapAction =
+				GSW_PCE_ACTION_PORTMAP_ALTERNATIVE;
+			pcrule.action.nForwardPortMap[0] = value_1;
+
+			if (hitbl->igcos != 0) {
+				pcrule.action.eTrafficClassAction = 1;
+				pcrule.action.nTrafficClassAlternate =
+					gswdev->iflag.igcos;
+			}
+
+			/*  Set eForwardPort */
+			pcrule.pattern.bPortIdEnable = 1;
+
+			if (hitbl->igfport == GSW_PORT_FORWARD_PORT)
+				pcrule.pattern.nPortId = hitbl->igfpid;
+			else if (hitbl->igfport == GSW_PORT_FORWARD_CPU)
+				pcrule.pattern.nPortId = (gswdev->cport);
+
+			if (hitbl->igxvlan)
+				pcrule.action.eVLAN_CrossAction =
+					GSW_PCE_ACTION_CROSS_VLAN_CROSS;
+			else
+				pcrule.action.eVLAN_CrossAction =
+					GSW_PCE_ACTION_CROSS_VLAN_DISABLE;
+
+			/* We prepare everything and write into PCE Table */
+			if (pce_rule_write(cdev,
+					   &gswdev->phandler, &pcrule) != 0) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		}
+	} else if ((hitbl->igmode ==
+		    GSW_MULTICAST_SNOOP_MODE_FORWARD) & !value_1) {
+
+		for (i = 0; i < 2; i++) {
+			memset(&pcrule, 0, sizeof(GSW_PCE_rule_t));
+
+			switch (i) {
+			case 0:
+				pcrule.pattern.nIndex = MPCE_RULES_INDEX;
+				break;
+
+			case 1:
+				/* Management Port ICMPv6 Multicast Listerner Report */
+				/* & Leave (Avoiding Loopback abd Discard) */
+				pcrule.pattern.nIndex =
+					MPCE_RULES_INDEX + 3;
+				break;
+			}
+
+			if (pce_pattern_delete(cdev, &gswdev->phandler, pcrule.pattern.nIndex) != 0) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		}
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+//Govind - Is this API compatible for 3.1?
+GSW_return_t GSW_MulticastSnoopCfgGet(void *cdev,
+				      GSW_multicastSnoopCfg_t *parm)
+{
+	u32 data_1, data_2, value;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if ((IS_VRSN_31(gswdev->gipver)) && (gswdev->mcsthw_snoop == MCAST_HWSNOOP_DIS)) {
+		//pr_err("%s:%s not supported in GSWIP v3.1 :%d\n",__FILE__, __func__, __LINE__);
+		ret = GSW_statusOk;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	parm->eIGMP_Mode = gswdev->iflag.igmode;
+	parm->bIGMPv3 = gswdev->iflag.igv3;
+	parm->bCrossVLAN = gswdev->iflag.igxvlan;
+	parm->eForwardPort = gswdev->iflag.igfport;
+	parm->nForwardPortId = gswdev->iflag.igfpid;
+	parm->nClassOfService = gswdev->iflag.igcos;
+	gsw_r32(cdev, PCE_IGMP_CTRL_ROB_OFFSET,
+		PCE_IGMP_CTRL_ROB_SHIFT,
+		PCE_IGMP_CTRL_ROB_SIZE, &value);
+	parm->nRobust = value;
+	gsw_r32(cdev, PCE_IGMP_CTRL_DMRT_OFFSET,
+		PCE_IGMP_CTRL_DMRT_SHIFT,
+		PCE_IGMP_CTRL_DMRT_SIZE, &value);
+	parm->nQueryInterval = value;
+	gsw_r32(cdev, PCE_IGMP_CTRL_REPSUP_OFFSET,
+		PCE_IGMP_CTRL_REPSUP_SHIFT,
+		PCE_IGMP_CTRL_REPSUP_SIZE, &data_1);
+	gsw_r32(cdev, PCE_IGMP_CTRL_JASUP_OFFSET,
+		PCE_IGMP_CTRL_JASUP_SHIFT,
+		PCE_IGMP_CTRL_JASUP_SIZE, &data_2);
+
+	if (data_1 == 0 && data_2 == 0)
+		parm->eSuppressionAggregation = GSW_MULTICAST_TRANSPARENT;
+	else if (data_1 == 1 && data_2 == 0)
+		parm->eSuppressionAggregation = GSW_MULTICAST_REPORT;
+	else if (data_1 == 1 && data_2 == 1)
+		parm->eSuppressionAggregation = GSW_MULTICAST_REPORT_JOIN;
+	else
+		parm->eSuppressionAggregation = GSW_MULTICAST_TRANSPARENT;
+
+	gsw_r32(cdev, PCE_IGMP_CTRL_FLEAVE_OFFSET,
+		PCE_IGMP_CTRL_FLEAVE_SHIFT,
+		PCE_IGMP_CTRL_FLEAVE_SIZE, &value);
+
+	if (value == 1)
+		parm->bFastLeave = 1;
+	else
+		parm->bFastLeave = 0;
+
+	gsw_r32(cdev, PCE_IGMP_CTRL_SRPEN_OFFSET,
+		PCE_IGMP_CTRL_SRPEN_SHIFT,
+		PCE_IGMP_CTRL_SRPEN_SIZE, &value);
+	parm->bLearningRouter = value;
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		gsw_r32(cdev, PCE_GCTRL_1_UKIPMC_OFFSET,
+			PCE_GCTRL_1_UKIPMC_SHIFT,
+			PCE_GCTRL_1_UKIPMC_SIZE,
+			&parm->bMulticastUnknownDrop);
+	}
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		gsw_r32(cdev, PCE_GCTRL_1_MKFIDEN_OFFSET,
+			PCE_GCTRL_1_MKFIDEN_SHIFT,
+			PCE_GCTRL_1_MKFIDEN_SIZE,
+			&parm->bMulticastFIDmode);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+//Govind - Is this API compatible for 3.1?
+GSW_return_t GSW_MulticastSnoopCfgSet(void *cdev,
+				      GSW_multicastSnoopCfg_t *parm)
+{
+	u32 i, data_1 = 0, data_2 = 0, pmcindex = MPCE_RULES_INDEX;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	static GSW_PCE_rule_t pcrule;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	/* Choose IGMP Mode */
+	switch (parm->eIGMP_Mode) {
+	case GSW_MULTICAST_SNOOP_MODE_DISABLED:
+		/* Snooping of Router Port Disable */
+		gsw_w32(cdev, PCE_IGMP_CTRL_SRPEN_OFFSET,
+			PCE_IGMP_CTRL_SRPEN_SHIFT,
+			PCE_IGMP_CTRL_SRPEN_SIZE, 0);
+		gsw_w32(cdev, PCE_GCTRL_0_IGMP_OFFSET,
+			PCE_GCTRL_0_IGMP_SHIFT,
+			PCE_GCTRL_0_IGMP_SIZE, 0);
+
+		for (i = 0; i <= gswdev->tpnum; i++) {
+			gsw_w32(cdev, PCE_PCTRL_0_MCST_OFFSET + (0xA * i),
+				PCE_PCTRL_0_MCST_SHIFT,
+				PCE_PCTRL_0_MCST_SIZE, 0);
+		}
+
+		break;
+
+	case GSW_MULTICAST_SNOOP_MODE_AUTOLEARNING:
+		/* Snooping of Router Port Enable */
+		gsw_w32(cdev, PCE_GCTRL_0_IGMP_OFFSET,
+			PCE_GCTRL_0_IGMP_SHIFT,
+			PCE_GCTRL_0_IGMP_SIZE, 0);
+		gsw_w32(cdev, PCE_IGMP_CTRL_SRPEN_OFFSET,
+			PCE_IGMP_CTRL_SRPEN_SHIFT,
+			PCE_IGMP_CTRL_SRPEN_SIZE, 1);
+
+		for (i = 0; i <= gswdev->tpnum; i++) {
+			gsw_w32(cdev, PCE_PCTRL_0_MCST_OFFSET + (0xA * i),
+				PCE_PCTRL_0_MCST_SHIFT,
+				PCE_PCTRL_0_MCST_SIZE, 1);
+		}
+
+		break;
+
+	case GSW_MULTICAST_SNOOP_MODE_FORWARD:
+
+		/* Snooping of Router Port Forward */
+		if ((IS_VRSN_NOT_31(gswdev->gipver)) ||
+		    ((IS_VRSN_31(gswdev->gipver)) && (gswdev->mcsthw_snoop == MCAST_HWSNOOP_EN))) {
+			gsw_w32(cdev, PCE_IGMP_CTRL_SRPEN_OFFSET,
+				PCE_IGMP_CTRL_SRPEN_SHIFT,
+				PCE_IGMP_CTRL_SRPEN_SIZE, 0);
+		}
+
+		gsw_w32(cdev, PCE_GCTRL_0_IGMP_OFFSET,
+			PCE_GCTRL_0_IGMP_SHIFT,
+			PCE_GCTRL_0_IGMP_SIZE, 1);
+
+		if ((IS_VRSN_NOT_31(gswdev->gipver)) ||
+		    ((IS_VRSN_31(gswdev->gipver)) && (gswdev->mcsthw_snoop == MCAST_HWSNOOP_EN))) {
+			for (i = 0; i < gswdev->tpnum; i++) {
+				gsw_w32(cdev, PCE_PCTRL_0_MCST_OFFSET + (0xA * i),
+					PCE_PCTRL_0_MCST_SHIFT,
+					PCE_PCTRL_0_MCST_SIZE, 1);
+			}
+		}
+
+		break;
+
+	default:
+		pr_err("This Mode doesn't exists\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+
+	}
+
+	/* Set the Flag for eIGMP_Mode flag*/
+	gswdev->iflag.igmode = parm->eIGMP_Mode;
+	/* Set bIGMPv3 flag*/
+	gswdev->iflag.igv3 =  parm->bIGMPv3;
+	/* Set bCrossVLAN flag*/
+	gswdev->iflag.igxvlan = parm->bCrossVLAN;
+	/* Set eForwardPort flag */
+	gswdev->iflag.igfport = parm->eForwardPort;
+
+	/* Set nForwardPortId */
+	if (parm->eForwardPort == GSW_PORT_FORWARD_CPU)
+		gswdev->iflag.igfpid = (1 << gswdev->cport);
+	else
+		gswdev->iflag.igfpid = parm->nForwardPortId;
+
+	gswdev->iflag.igcos = parm->nClassOfService;
+
+	/* If IGMP mode set to AutoLearning then the following Rule have to add it */
+	if (parm->eIGMP_Mode ==
+	    GSW_MULTICAST_SNOOP_MODE_AUTOLEARNING) {
+
+		if ((IS_VRSN_31(gswdev->gipver)) && (gswdev->mcsthw_snoop == MCAST_HWSNOOP_DIS)) {
+			//pr_err("%s:%s not supported in GSWIP v3.1 :%d\n",__FILE__, __func__, __LINE__);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		for (i = pmcindex; i <= (pmcindex + 7); i++) {
+			memset(&pcrule, 0, sizeof(GSW_PCE_rule_t));
+			pcrule.pattern.nIndex = i;
+			pcrule.pattern.bEnable = 1;
+			pcrule.pattern.bAppDataMSB_Enable = 1;
+
+			if ((i == pmcindex + 0) ||
+			    (i == pmcindex + 1) ||
+			    (i == pmcindex + 2))
+				pcrule.pattern.nAppDataMSB = 0x1100;
+			else if (i == pmcindex + 3)
+				pcrule.pattern.nAppDataMSB = 0x1200;
+			else if (i == pmcindex + 4)
+				pcrule.pattern.nAppDataMSB = 0x1600;
+			else if (i == pmcindex + 5)
+				pcrule.pattern.nAppDataMSB = 0x1700;
+			else if (i == pmcindex + 6)
+				pcrule.pattern.nAppDataMSB = 0x3100;
+			else if (i == pmcindex + 7)
+				pcrule.pattern.nAppDataMSB = 0x3000;
+
+			pcrule.pattern.bAppMaskRangeMSB_Select = 0;
+			/*			if (gswdev->gipver == LTQ_GSWIP_3_0) { */
+			/*				pcrule.pattern.nAppMaskRangeMSB = 0x0; */
+			/*			} else { */
+			pcrule.pattern.nAppMaskRangeMSB = 0x3;
+
+			/*		} */
+			if ((i == pmcindex + 0) ||
+			    (i == pmcindex + 1) ||
+			    (i == pmcindex + 6) ||
+			    (i == pmcindex + 7))
+				pcrule.pattern.eDstIP_Select = 1;
+
+			if ((i == pmcindex + 0) ||
+			    (i == pmcindex + 1))
+				pcrule.pattern.nDstIP.nIPv4 = 0xE0000001;
+			else if (i == pmcindex + 6)
+				pcrule.pattern.nDstIP.nIPv4 = 0xE0000002;
+			else if (i == pmcindex + 7)
+				pcrule.pattern.nDstIP.nIPv4 = 0xE00000A6;
+
+			pcrule.pattern.nDstIP_Mask = 0xFF00;
+
+			if (i == pmcindex + 1)
+				pcrule.pattern.eSrcIP_Select = 1;
+			else
+				pcrule.pattern.eSrcIP_Select = 0;
+
+			if (i == pmcindex + 1)
+				pcrule.pattern.nSrcIP_Mask = 0xFF00;
+			else
+				pcrule.pattern.nSrcIP_Mask = 0xFFFF;
+
+			pcrule.pattern.bProtocolEnable = 1;
+			pcrule.pattern.nProtocol = 0x2;
+
+			if (gswdev->iflag.igcos == 0) {
+				pcrule.action.eTrafficClassAction = 0;
+				pcrule.action.nTrafficClassAlternate = 0;
+			} else {
+				pcrule.action.eTrafficClassAction = 1;
+				pcrule.action.nTrafficClassAlternate =
+					gswdev->iflag.igcos;
+			}
+
+			if (i == pmcindex + 0)
+				pcrule.action.eSnoopingTypeAction =
+					GSW_PCE_ACTION_IGMP_SNOOP_QUERY;
+			else if (i == pmcindex + 1)
+				pcrule.action.eSnoopingTypeAction =
+					GSW_PCE_ACTION_IGMP_SNOOP_QUERY_NO_ROUTER;
+			else if (i == pmcindex + 2)
+				pcrule.action.eSnoopingTypeAction =
+					GSW_PCE_ACTION_IGMP_SNOOP_QUERY_GROUP;
+			else if (i == pmcindex + 3)
+				pcrule.action.eSnoopingTypeAction =
+					GSW_PCE_ACTION_IGMP_SNOOP_REPORT;
+			else if (i == pmcindex + 4)
+				pcrule.action.eSnoopingTypeAction =
+					GSW_PCE_ACTION_IGMP_SNOOP_REPORT;
+			else if (i == pmcindex + 5)
+				pcrule.action.eSnoopingTypeAction =
+					GSW_PCE_ACTION_IGMP_SNOOP_LEAVE;
+			else if (i == pmcindex + 6)
+				pcrule.action.eSnoopingTypeAction =
+					GSW_PCE_ACTION_IGMP_SNOOP_AD;
+			else if (i == pmcindex + 7)
+				pcrule.action.eSnoopingTypeAction =
+					GSW_PCE_ACTION_IGMP_SNOOP_AD;
+
+			pcrule.action.ePortMapAction =
+				GSW_PCE_ACTION_PORTMAP_MULTICAST_ROUTER;
+
+			if (parm->bCrossVLAN)
+				pcrule.action.eVLAN_CrossAction =
+					GSW_PCE_ACTION_CROSS_VLAN_CROSS;
+			else
+				pcrule.action.eVLAN_CrossAction =
+					GSW_PCE_ACTION_CROSS_VLAN_DISABLE;
+
+			/* We prepare everything and write into PCE Table */
+			if (0 != pce_rule_write(cdev,
+						&gswdev->phandler, &pcrule)) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		}
+	}
+
+	/* If IGMP mode set to forwarding then the */
+	/* following Rule have to add it */
+	if (parm->eIGMP_Mode == GSW_MULTICAST_SNOOP_MODE_FORWARD) {
+		for (i = pmcindex; i <= (pmcindex + 7); i++) {
+			memset(&pcrule, 0, sizeof(GSW_PCE_rule_t));
+			pcrule.pattern.nIndex = i;
+			pcrule.pattern.bEnable = 1;
+			pcrule.pattern.bProtocolEnable = 1;
+
+			switch (i - pmcindex) {
+			/*		case 0: */
+			/*Rule added by Router port ADD function based on router port for IPv4*/
+			/*					break; */
+			case 1:
+				/*	Avoid IGMP Packets Redirection when seen on Management Port */
+				pcrule.pattern.nProtocol = 0x2; /* for IPv4 */
+				pcrule.pattern.bPortIdEnable = 1;
+				/* Action Enabled, no redirection (default portmap) */
+				pcrule.action.ePortMapAction =
+					GSW_PCE_ACTION_PORTMAP_REGULAR;
+				break;
+
+			case 2:
+				/* IGMPv1/2/3 IPv4 */
+				pcrule.pattern.nProtocol = 0x2; /* for IPv4 */
+				pcrule.action.ePortMapAction =
+					GSW_PCE_ACTION_PORTMAP_ALTERNATIVE;
+				break;
+
+			/*		case 3: */
+			/*Rules added by Router port ADD function */
+			/* based on router port for IPv6 */
+			/*			break; */
+			case 4:
+				/*	Managemnt Port Remaining ICMPv6/MLD packets */
+				/* (Avoiding Loopback and Disacard) */
+				pcrule.pattern.bPortIdEnable = 1;
+				pcrule.pattern.nPortId = parm->nForwardPortId;
+				pcrule.pattern.nProtocol = 0x3A;  /*for IPv6*/
+				pcrule.pattern.bPortIdEnable = 1;
+				pcrule.action.ePortMapAction =
+					GSW_PCE_ACTION_PORTMAP_REGULAR;
+				break;
+
+			case 5:
+				/* ICMPv6 Multicast Listener Query/Report/Done(Leave) */
+				pcrule.pattern.bAppDataMSB_Enable	= 1;
+				pcrule.pattern.bAppMaskRangeMSB_Select = 1;
+				pcrule.pattern.nAppDataMSB = 0x8200;
+				pcrule.pattern.nAppMaskRangeMSB	= 0x2FF;
+				pcrule.pattern.nProtocol = 0x3A;  /*for IPv6*/
+				pcrule.action.ePortMapAction =
+					GSW_PCE_ACTION_PORTMAP_ALTERNATIVE;
+				break;
+
+			case 6:
+				/* ICMPv6 Multicast Listener Report */
+				pcrule.pattern.bAppDataMSB_Enable	= 1;
+				pcrule.pattern.nAppDataMSB = 0x8F00;
+				pcrule.pattern.nAppMaskRangeMSB = 0x3;
+				pcrule.pattern.nProtocol = 0x3A;  /*for IPv6*/
+				pcrule.action.ePortMapAction =
+					GSW_PCE_ACTION_PORTMAP_ALTERNATIVE;
+				break;
+
+			case 7:
+				/* ICMPv6 Multicast Router Advertisement/Solicitation/Termination */
+				pcrule.pattern.bAppDataMSB_Enable	= 1;
+				pcrule.pattern.bAppMaskRangeMSB_Select = 1;
+				pcrule.pattern.nAppDataMSB = 0x9700;
+				pcrule.pattern.nAppMaskRangeMSB	= 0x2FF;
+				pcrule.pattern.nProtocol = 0x3A;  /*for IPv6*/
+				pcrule.action.ePortMapAction =
+					GSW_PCE_ACTION_PORTMAP_ALTERNATIVE;
+				break;
+
+			default:
+				continue;
+			}
+
+			if (gswdev->iflag.igcos != 0) {
+				pcrule.action.eTrafficClassAction = 1;
+				pcrule.action.nTrafficClassAlternate =
+					gswdev->iflag.igcos;
+			}
+
+			/*  Set eForwardPort */
+			if (parm->eForwardPort == GSW_PORT_FORWARD_PORT) {
+				pcrule.action.nForwardPortMap[0] =
+					(1 << parm->nForwardPortId);
+				pcrule.pattern.nPortId = parm->nForwardPortId;
+			} else if (parm->eForwardPort == GSW_PORT_FORWARD_CPU) {
+				pcrule.action.nForwardPortMap[0] =
+					(1 << gswdev->cport);
+				pcrule.pattern.nPortId = gswdev->cport;
+			}
+
+			if (parm->bCrossVLAN)
+				pcrule.action.eVLAN_CrossAction =
+					GSW_PCE_ACTION_CROSS_VLAN_CROSS;
+			else
+				pcrule.action.eVLAN_CrossAction =
+					GSW_PCE_ACTION_CROSS_VLAN_DISABLE;
+
+			/* We prepare everything and write into PCE Table */
+			if (pce_rule_write(cdev,
+					   &gswdev->phandler, &pcrule) != 0) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		}
+
+	}
+
+
+	if ((IS_VRSN_31(gswdev->gipver)) && (gswdev->mcsthw_snoop == MCAST_HWSNOOP_DIS)) {
+		//pr_err("%s:%s not supported in GSWIP v3.1 :%d\n",__FILE__, __func__, __LINE__);
+		ret = GSW_statusOk;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if (parm->eIGMP_Mode ==
+	    GSW_MULTICAST_SNOOP_MODE_DISABLED) {
+		pmcindex = MPCE_RULES_INDEX;
+
+		for (i = pmcindex; i <= (pmcindex + 7); i++) {
+			pcrule.pattern.nIndex = i;
+			pcrule.pattern.bEnable = 0;
+
+			/* We prepare everything and write into PCE Table */
+			if (0 != pce_pattern_delete(cdev, &gswdev->phandler, i)) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		}
+	}
+
+	if (parm->nRobust < 4) {
+		gsw_w32(cdev, PCE_IGMP_CTRL_ROB_OFFSET,
+			PCE_IGMP_CTRL_ROB_SHIFT,
+			PCE_IGMP_CTRL_ROB_SIZE, parm->nRobust);
+	} else {
+		pr_err("The Robust time would only support 0..3\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	gsw_w32(cdev, PCE_IGMP_CTRL_DMRTEN_OFFSET,
+		PCE_IGMP_CTRL_DMRTEN_SHIFT,
+		PCE_IGMP_CTRL_DMRTEN_SIZE, 1);
+	gsw_w32(cdev, PCE_IGMP_CTRL_DMRT_OFFSET,
+		PCE_IGMP_CTRL_DMRT_SHIFT,
+		PCE_IGMP_CTRL_DMRT_SIZE,
+		parm->nQueryInterval);
+
+
+	if (parm->eIGMP_Mode ==
+	    GSW_MULTICAST_SNOOP_MODE_AUTOLEARNING) {
+		switch (parm->eSuppressionAggregation) {
+		case GSW_MULTICAST_REPORT_JOIN:
+			data_2 = 1;
+			data_1 = 1;
+			break;
+
+		case GSW_MULTICAST_REPORT:
+			data_2 = 0;
+			data_1 = 1;
+			break;
+
+		case GSW_MULTICAST_TRANSPARENT:
+			data_2 = 0;
+			data_1 = 0;
+			break;
+		}
+
+		gsw_w32(cdev, PCE_IGMP_CTRL_REPSUP_OFFSET,
+			PCE_IGMP_CTRL_REPSUP_SHIFT,
+			PCE_IGMP_CTRL_REPSUP_SIZE, data_1);
+		gsw_w32(cdev, PCE_IGMP_CTRL_JASUP_OFFSET,
+			PCE_IGMP_CTRL_JASUP_SHIFT,
+			PCE_IGMP_CTRL_JASUP_SIZE, data_2);
+	}
+
+	if (parm->eIGMP_Mode ==
+	    GSW_MULTICAST_SNOOP_MODE_AUTOLEARNING) {
+		gsw_w32(cdev, PCE_IGMP_CTRL_SRPEN_OFFSET,
+			PCE_IGMP_CTRL_SRPEN_SHIFT,
+			PCE_IGMP_CTRL_SRPEN_SIZE,
+			parm->bLearningRouter);
+
+		if (parm->bFastLeave == 1)
+			gsw_w32(cdev, PCE_IGMP_CTRL_FLEAVE_OFFSET,
+				PCE_IGMP_CTRL_FLEAVE_SHIFT,
+				PCE_IGMP_CTRL_FLEAVE_SIZE, 1);
+		else
+			gsw_w32(cdev, PCE_IGMP_CTRL_FLEAVE_OFFSET,
+				PCE_IGMP_CTRL_FLEAVE_SHIFT,
+				PCE_IGMP_CTRL_FLEAVE_SIZE, 0);
+	} else {
+		gsw_w32(cdev, PCE_IGMP_CTRL_FLEAVE_OFFSET,
+			PCE_IGMP_CTRL_FLEAVE_SHIFT,
+			PCE_IGMP_CTRL_FLEAVE_SIZE, 0);
+	}
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		gsw_w32(cdev, PCE_GCTRL_1_UKIPMC_OFFSET,
+			PCE_GCTRL_1_UKIPMC_SHIFT,
+			PCE_GCTRL_1_UKIPMC_SIZE,
+			parm->bMulticastUnknownDrop);
+	}
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		gsw_w32(cdev, PCE_GCTRL_1_MKFIDEN_OFFSET,
+			PCE_GCTRL_1_MKFIDEN_SHIFT,
+			PCE_GCTRL_1_MKFIDEN_SIZE,
+			parm->bMulticastFIDmode);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_MulticastTableEntryAdd(void *cdev,
+					GSW_multicastTable_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	gsw_igmp_t	*hitbl = &gswdev->iflag;
+	u8 pidx = parm->nPortId;
+	static pctbl_prog_t ptdata;
+	int ret = 0;
+	u32 index = 0, i, available = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (parm->nPortId >= gswdev->tpnum) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	memset(&ptdata, 0, sizeof(pctbl_prog_t));
+
+	if (hitbl->igmode == GSW_MULTICAST_SNOOP_MODE_AUTOLEARNING) {
+
+		if ((IS_VRSN_31(gswdev->gipver)) && (gswdev->mcsthw_snoop == MCAST_HWSNOOP_DIS)) {
+			pr_err("%s:%s not supported in GSWIP v3.1 :%d\n", __FILE__, __func__, __LINE__);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if ((gswdev->iflag.igv3 == 1) ||
+		    (parm->eIPVersion == GSW_IP_SELECT_IPV6)) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/* Read Out all of the HW Table */
+		for (i = 0; i < gswdev->mctblsize; i++) {
+			ptdata.table = PCE_MULTICAST_HW_INDEX;
+			ptdata.pcindex = i;
+			gsw_pce_table_read(cdev, &ptdata);
+
+			if (ptdata.valid) {
+				if ((ptdata.key[0] ==
+				     (parm->uIP_Gda.nIPv4 & 0xFFFF)) &&
+				    (ptdata.key[1] ==
+				     ((parm->uIP_Gda.nIPv4 >> 16) & 0xFFFF))) {
+					index = i;
+					available = 1;
+					break;
+				}
+			}
+		}
+
+		ptdata.table = PCE_MULTICAST_HW_INDEX;
+
+		if (available == 0) {
+			index = gswdev->mctblsize;
+
+			for (i = 0; i < gswdev->mctblsize; i++) {
+				ptdata.pcindex = i;
+				gsw_pce_table_read(cdev, &ptdata);
+
+				if (ptdata.valid == 0) {
+					index = i;  /* Free index */
+					break;
+				}
+			}
+		}
+
+		if (index < gswdev->mctblsize) {
+			ptdata.table = PCE_MULTICAST_HW_INDEX;
+			ptdata.pcindex = index;
+			ptdata.key[1] = ((parm->uIP_Gda.nIPv4 >> 16) & 0xFFFF);
+			ptdata.key[0] = (parm->uIP_Gda.nIPv4 & 0xFFFF);
+			ptdata.val[0] |= (1 << pidx);
+			ptdata.val[4] |= (1 << 14);
+			ptdata.valid = 1;
+			gsw_pce_table_write(cdev, &ptdata);
+		} else {
+			pr_err("Error: (IGMP HW Table is full) %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+	} else if (hitbl->igmode == GSW_MULTICAST_SNOOP_MODE_FORWARD) {
+		/* Program the Multicast SW Table */
+		if (gswdev->gipver == LTQ_GSWIP_3_0)
+			gsw3x_msw_table_wr(cdev, parm);
+		else if (IS_VRSN_31(gswdev->gipver)) {
+			ret = gsw_insert_hashtable_entry(cdev, parm);
+
+			if (ret < 0) {
+				pr_err("%s:%s Entry Cannot insert :%d %d\n", __FILE__, __func__, __LINE__, ret);
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		} else
+			gsw2x_msw_table_wr(cdev, parm);
+	} else {
+		/* Disable All Multicast SW Table */
+		pr_err("Please Select the IGMP Mode through Multicast Snooping Configuration API\n");
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_MulticastTableEntryRead(void *cdev,
+		GSW_multicastTableRead_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	gsw_igmp_t	*hitbl = &gswdev->iflag;
+	static pctbl_prog_t ptdata;
+	u32 ret = 0;
+	u32 dlsbid, slsbid, dmsbid, smsbid;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return  GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (hitbl->igmode == GSW_MULTICAST_SNOOP_MODE_DISABLED) {
+		pr_err("Error: (IGMP snoop is not enabled) %s:%s:%d\n",
+		       __FILE__, __func__, __LINE__);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+
+	if (hitbl->igmode == GSW_MULTICAST_SNOOP_MODE_AUTOLEARNING) {
+
+		if ((IS_VRSN_31(gswdev->gipver)) && (gswdev->mcsthw_snoop == MCAST_HWSNOOP_DIS)) {
+			pr_err("%s:%s not supported in GSWIP v3.1 :%d\n", __FILE__, __func__, __LINE__);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (parm->bInitial == 1) {
+			gswdev->mhw_rinx = 0; /*Start from the index 0 */
+			parm->bInitial = 0;
+		}
+
+		if (gswdev->mhw_rinx >= gswdev->mctblsize) {
+			memset(parm, 0, sizeof(GSW_multicastTableRead_t));
+			parm->bLast = 1;
+			gswdev->mhw_rinx = 0;
+			ret = GSW_statusOk;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		do {
+			memset(&ptdata, 0, sizeof(pctbl_prog_t));
+			ptdata.table = PCE_MULTICAST_HW_INDEX;
+			ptdata.pcindex = gswdev->mhw_rinx;
+			gsw_pce_table_read(cdev, &ptdata);
+			gswdev->mhw_rinx++;
+
+			if (ptdata.valid != 0)
+				break;
+		} while (gswdev->mhw_rinx < gswdev->mctblsize);
+
+		if (ptdata.valid != 0) {
+			parm->nPortId = ptdata.val[0] | 0x80000000;
+			parm->uIP_Gda.nIPv4 =
+				((ptdata.key[1] << 16) |
+				 ptdata.key[0]);
+			parm->uIP_Gsa.nIPv4 = 0;
+			parm->eModeMember = GSW_IGMP_MEMBER_DONT_CARE;
+			parm->eIPVersion = GSW_IP_SELECT_IPV4;
+			parm->bInitial = 0;
+			parm->bLast = 0;
+		} else {
+			memset(parm, 0, sizeof(GSW_multicastTableRead_t));
+			parm->bLast = 1;
+			gswdev->mhw_rinx = 0;
+		}
+	}
+
+	/*Snooping in Forward mode */
+	if (hitbl->igmode == GSW_MULTICAST_SNOOP_MODE_FORWARD) {
+
+		if (parm->bInitial == 1) {
+			gswdev->msw_rinx = 0; /*Start from the index 0 */
+			parm->bInitial = 0;
+		}
+
+		if (gswdev->msw_rinx >= gswdev->mctblsize) {
+			memset(parm, 0, sizeof(GSW_multicastTableRead_t));
+			parm->bLast = 1;
+			gswdev->msw_rinx = 0;
+			ret = GSW_statusOk;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (IS_VRSN_31(gswdev->gipver)) {
+			do {
+				ret = gsw_get_swmcast_entry(cdev, parm, gswdev->msw_rinx);
+				gswdev->msw_rinx++;
+
+				if (ret != 0)
+					break;
+
+			} while (gswdev->msw_rinx < gswdev->mctblsize);
+
+			if (ret) {
+				parm->bInitial = 0;
+				parm->bLast = 0;
+				ret = GSW_statusOk;
+				goto UNLOCK_AND_RETURN;
+			} else {
+				memset(parm, 0, sizeof(GSW_multicastTableRead_t));
+				parm->bLast = 1;
+				gswdev->msw_rinx = 0;
+			}
+		}
+
+		do {
+			memset(&ptdata, 0, sizeof(pctbl_prog_t));
+			ptdata.table = PCE_MULTICAST_SW_INDEX;
+			ptdata.pcindex = gswdev->msw_rinx;
+			gsw_pce_table_read(cdev, &ptdata);
+			gswdev->msw_rinx++;
+
+			if (ptdata.valid != 0)
+				break;
+		} while (gswdev->msw_rinx < gswdev->mctblsize);
+
+		if (ptdata.valid == 1) {
+			pctbl_prog_t iptbl;
+			parm->nPortId = ptdata.val[0] | 0x80000000;
+
+			if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				parm->nSubIfId = (ptdata.val[1] >> 3) & 0xFFFF;
+				parm->nFID = (ptdata.key[2] & 0x3F);
+				parm->bExclSrcIP =
+					((ptdata.key[2] >> 15) & 0x1);
+			}
+
+			dlsbid = ptdata.key[0] & 0xFF;
+			dmsbid = (ptdata.key[0] >> 8) & 0xFF;
+			slsbid = ptdata.key[1] & 0xFF;
+			smsbid = (ptdata.key[1] >> 8) & 0xFF;
+
+			if (dlsbid <= 0x3F) {
+				memset(&iptbl, 0, sizeof(pctbl_prog_t));
+				iptbl.table = PCE_IP_DASA_LSB_INDEX;
+				/* Search the DIP */
+				iptbl.pcindex = dlsbid;
+				gsw_pce_table_read(cdev, &iptbl);
+
+				if (iptbl.valid == 1) {
+					if (gswdev->gipver == LTQ_GSWIP_3_0) {
+						if ((iptbl.mask[0] == 0x0) &&
+						    ((iptbl.mask[1] == 0x0)) &&
+						    ((iptbl.mask[2] == 0xFFFF)) &&
+						    ((iptbl.mask[3] == 0xFFFF))) {
+							parm->uIP_Gda.nIPv4 =
+								((iptbl.key[1] << 16)
+								 | (iptbl.key[0]));
+							parm->eIPVersion =
+								GSW_IP_SELECT_IPV4;
+						} else if ((iptbl.mask[0] == 0x0) &&
+							   ((iptbl.mask[1] == 0x0)) &&
+							   ((iptbl.mask[2] == 0x0)) &&
+							   ((iptbl.mask[3] == 0x0))) {
+							parm->uIP_Gda.nIPv6[4] =
+								(iptbl.key[3]);
+							parm->uIP_Gda.nIPv6[5] =
+								(iptbl.key[2]);
+							parm->uIP_Gda.nIPv6[6] =
+								(iptbl.key[1]);
+							parm->uIP_Gda.nIPv6[7] =
+								(iptbl.key[0]);
+							parm->eIPVersion =
+								GSW_IP_SELECT_IPV6;
+						}
+					} else {
+						if (iptbl.mask[0] == 0xFF00) {
+							parm->uIP_Gda.nIPv4 =
+								((iptbl.key[1] << 16)
+								 | (iptbl.key[0]));
+							parm->eIPVersion =
+								GSW_IP_SELECT_IPV4;
+						} else if (iptbl.mask[0] == 0x0) {
+							parm->uIP_Gda.nIPv6[4] =
+								(iptbl.key[3]);
+							parm->uIP_Gda.nIPv6[5] =
+								(iptbl.key[2]);
+							parm->uIP_Gda.nIPv6[6] =
+								(iptbl.key[1]);
+							parm->uIP_Gda.nIPv6[7] =
+								(iptbl.key[0]);
+							parm->eIPVersion =
+								GSW_IP_SELECT_IPV6;
+						}
+					}
+				}
+			}
+
+			if (slsbid <= 0x3F) {
+				memset(&iptbl, 0, sizeof(pctbl_prog_t));
+				iptbl.table = PCE_IP_DASA_LSB_INDEX;
+				/* Search the SIP */
+				iptbl.pcindex = slsbid;
+				gsw_pce_table_read(cdev, &iptbl);
+
+				if (iptbl.valid == 1) {
+					if (gswdev->gipver == LTQ_GSWIP_3_0) {
+						if ((iptbl.mask[0] == 0x0) &&
+						    ((iptbl.mask[1] == 0x0)) &&
+						    ((iptbl.mask[2] == 0xFFFF)) &&
+						    ((iptbl.mask[3] == 0xFFFF))) {
+							parm->uIP_Gsa.nIPv4 =
+								((iptbl.key[1] << 16)
+								 | (iptbl.key[0]));
+							parm->eIPVersion =
+								GSW_IP_SELECT_IPV4;
+						} else if ((iptbl.mask[0] == 0x0) &&
+							   ((iptbl.mask[1] == 0x0)) &&
+							   ((iptbl.mask[2] == 0x0)) &&
+							   ((iptbl.mask[3] == 0x0))) {
+							parm->uIP_Gsa.nIPv6[4] =
+								(iptbl.key[3]);
+							parm->uIP_Gsa.nIPv6[5] =
+								(iptbl.key[2]);
+							parm->uIP_Gsa.nIPv6[6] =
+								(iptbl.key[1]);
+							parm->uIP_Gsa.nIPv6[7] =
+								(iptbl.key[0]);
+						}
+					} else {
+						if (iptbl.mask[0] == 0xFF00) {
+							parm->uIP_Gsa.nIPv4 =
+								((iptbl.key[1] << 16)
+								 | (iptbl.key[0]));
+							parm->eIPVersion =
+								GSW_IP_SELECT_IPV4;
+						} else if (iptbl.mask == 0x0) {
+							parm->uIP_Gsa.nIPv6[4] =
+								(iptbl.key[3]);
+							parm->uIP_Gsa.nIPv6[5] =
+								(iptbl.key[2]);
+							parm->uIP_Gsa.nIPv6[6] =
+								(iptbl.key[1]);
+							parm->uIP_Gsa.nIPv6[7] =
+								(iptbl.key[0]);
+						}
+					}
+				}
+			}
+
+			if (dmsbid <= 0xF) {
+				memset(&iptbl, 0, sizeof(pctbl_prog_t));
+				iptbl.table = PCE_IP_DASA_MSB_INDEX;
+				/* Search the DIP */
+				iptbl.pcindex = dmsbid;
+				gsw_pce_table_read(cdev, &iptbl);
+
+				if (iptbl.valid == 1) {
+					if (gswdev->gipver == LTQ_GSWIP_3_0) {
+						if ((iptbl.mask[0] == 0) &&
+						    ((iptbl.mask[1] == 0)) &&
+						    ((iptbl.mask[2] == 0)) &&
+						    ((iptbl.mask[3] == 0))) {
+							parm->uIP_Gda.nIPv6[0] =
+								(iptbl.key[3]);
+							parm->uIP_Gda.nIPv6[1] =
+								(iptbl.key[2]);
+							parm->uIP_Gda.nIPv6[2] =
+								(iptbl.key[1]);
+							parm->uIP_Gda.nIPv6[3] =
+								(iptbl.key[0]);
+						}
+					} else {
+						if (iptbl.mask  == 0) {
+							parm->uIP_Gda.nIPv6[0] =
+								(iptbl.key[3]);
+							parm->uIP_Gda.nIPv6[1] =
+								(iptbl.key[2]);
+							parm->uIP_Gda.nIPv6[2] =
+								(iptbl.key[1]);
+							parm->uIP_Gda.nIPv6[3] =
+								(iptbl.key[0]);
+						}
+					}
+				}
+			}
+
+			if (smsbid <= 0xF) {
+				memset(&iptbl, 0, sizeof(pctbl_prog_t));
+				iptbl.table = PCE_IP_DASA_MSB_INDEX;
+				/* Search the DIP */
+				iptbl.pcindex = smsbid;
+				gsw_pce_table_read(cdev, &iptbl);
+
+				if (iptbl.valid == 1) {
+					if (gswdev->gipver == LTQ_GSWIP_3_0) {
+						if ((iptbl.mask[0] == 0) &&
+						    ((iptbl.mask[1] == 0)) &&
+						    ((iptbl.mask[2] == 0)) &&
+						    ((iptbl.mask[3] == 0))) {
+							parm->uIP_Gsa.nIPv6[0] =
+								(iptbl.key[3]);
+							parm->uIP_Gsa.nIPv6[1] =
+								(iptbl.key[2]);
+							parm->uIP_Gsa.nIPv6[2] =
+								(iptbl.key[1]);
+							parm->uIP_Gsa.nIPv6[3] =
+								(iptbl.key[0]);
+						}
+					} else {
+						if (iptbl.mask == 0) {
+							parm->uIP_Gsa.nIPv6[0] =
+								(iptbl.key[3]);
+							parm->uIP_Gsa.nIPv6[1] =
+								(iptbl.key[2]);
+							parm->uIP_Gsa.nIPv6[2] =
+								(iptbl.key[1]);
+							parm->uIP_Gsa.nIPv6[3] =
+								(iptbl.key[0]);
+						}
+					}
+				}
+			}
+
+			parm->eModeMember =
+				hitbl->mctable[gswdev->msw_rinx - 1].mcmode;
+			parm->bInitial = 0;
+			parm->bLast = 0;
+		} else {
+			memset(parm, 0, sizeof(GSW_multicastTableRead_t));
+			parm->bLast = 1;
+			gswdev->msw_rinx = 0;
+		}
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_MulticastTableEntryRemove(void *cdev,
+		GSW_multicastTable_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	gsw_igmp_t	*hitbl = &gswdev->iflag;
+	u8 pidx = parm->nPortId;
+	static pctbl_prog_t ptdata;
+	ltq_bool_t dflag = 0;
+	u32 port = 0, i;
+	int ret = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (parm->nPortId >= gswdev->tpnum) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	memset(&ptdata, 0, sizeof(pctbl_prog_t));
+
+	if (hitbl->igmode ==
+	    GSW_MULTICAST_SNOOP_MODE_AUTOLEARNING) {
+
+		if ((IS_VRSN_31(gswdev->gipver)) && (gswdev->mcsthw_snoop == MCAST_HWSNOOP_DIS)) {
+			pr_err("%s:%s not supported in GSWIP v3.1 :%d\n", __FILE__, __func__, __LINE__);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (gswdev->iflag.igv3 == 1) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/* Read Out all of the HW Table */
+		for (i = 0; i < gswdev->mctblsize; i++) {
+			memset(&ptdata, 0, sizeof(pctbl_prog_t));
+			ptdata.table = PCE_MULTICAST_HW_INDEX;
+			ptdata.pcindex = i;
+			gsw_pce_table_read(cdev, &ptdata);
+
+			/* Fill into Structure */
+			if (((ptdata.val[0] >> pidx) & 0x1) == 1) {
+				if (parm->uIP_Gda.nIPv4 ==
+				    ((ptdata.key[1] << 16)
+				     | (ptdata.key[0]))) {
+					port = (ptdata.val[0] & (~(1 << pidx)));
+
+					if (port == 0) {
+						ptdata.val[0] = 0;
+						ptdata.key[1] = 0;
+						ptdata.val[4] = 0;
+					} else {
+						ptdata.val[0] &= ~(1 << pidx);
+					}
+
+					dflag = 1;
+					gsw_pce_table_write(cdev, &ptdata);
+				}
+			}
+		}
+
+		if (dflag == 0)
+			pr_err("The input did not found\n");
+	} else if (hitbl->igmode ==
+		   GSW_MULTICAST_SNOOP_MODE_FORWARD) {
+		if (gswdev->gipver == LTQ_GSWIP_3_0)
+			gsw3x_msw_table_rm(cdev, parm);
+		else if (IS_VRSN_31(gswdev->gipver)) {
+			ret = gsw_remove_hashtable_entry(cdev, parm);
+
+			if (ret < 0) {
+				pr_err("%s:%s Entry Cannot remove :%d %d\n", __FILE__, __func__, __LINE__, ret);
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		} else
+			gsw2x_msw_table_rm(cdev, parm);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+#endif /*CONFIG_LTQ_MULTICAST*/
+
+GSW_return_t GSW_CapGet(void *cdev, GSW_cap_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value, data1, data2;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return  GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nCapType >= GSW_CAP_TYPE_LAST) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	} else {
+		strcpy(parm->cDesc, capdes[parm->nCapType].desci);
+		/* As request, attached the code in the next version*/
+	}
+
+	switch (parm->nCapType) {
+	case GSW_CAP_TYPE_PORT:
+		gsw_r32(cdev, ETHSW_CAP_1_PPORTS_OFFSET,
+			ETHSW_CAP_1_PPORTS_SHIFT,
+			ETHSW_CAP_1_PPORTS_SIZE, &value);
+		parm->nCap = value;
+		break;
+
+	case GSW_CAP_TYPE_VIRTUAL_PORT:
+		gsw_r32(cdev, ETHSW_CAP_1_VPORTS_OFFSET,
+			ETHSW_CAP_1_VPORTS_SHIFT,
+			ETHSW_CAP_1_VPORTS_SIZE, &value);
+		parm->nCap = value;
+		break;
+
+	case GSW_CAP_TYPE_BUFFER_SIZE:
+		gsw_r32(cdev, ETHSW_CAP_11_BSIZEL_OFFSET,
+			ETHSW_CAP_11_BSIZEL_SHIFT,
+			ETHSW_CAP_11_BSIZEL_SIZE, &data1);
+		gsw_r32(cdev, ETHSW_CAP_12_BSIZEH_OFFSET,
+			ETHSW_CAP_12_BSIZEH_SHIFT,
+			ETHSW_CAP_12_BSIZEH_SIZE, &data2);
+		parm->nCap = (data2 << 16 | data1);
+		break;
+
+	case GSW_CAP_TYPE_SEGMENT_SIZE:
+		/* This is Hard coded */
+		parm->nCap = LTQ_SOC_CAP_SEGMENT;
+		break;
+
+	case GSW_CAP_TYPE_PRIORITY_QUEUE:
+		parm->nCap = gswdev->num_of_queues;
+		break;
+
+	case GSW_CAP_TYPE_METER:
+		parm->nCap = gswdev->num_of_meters;
+		break;
+
+	case GSW_CAP_TYPE_RATE_SHAPER:
+		parm->nCap = gswdev->num_of_shapers;
+		break;
+
+	case GSW_CAP_TYPE_VLAN_GROUP:
+		parm->nCap = gswdev->avlantsz;
+		break;
+
+	case GSW_CAP_TYPE_FID:
+		/* This is Hard coded */
+		parm->nCap = VRX_PLATFORM_CAP_FID;
+		break;
+
+	case GSW_CAP_TYPE_MAC_TABLE_SIZE:
+		parm->nCap = gswdev->mactblsize;
+		break;
+
+	case GSW_CAP_TYPE_MULTICAST_TABLE_SIZE:
+		parm->nCap = gswdev->mctblsize;
+		break;
+
+	case GSW_CAP_TYPE_PPPOE_SESSION:
+		parm->nCap = gswdev->num_of_pppoe;
+		break;
+
+	case GSW_CAP_TYPE_SVLAN_GROUP:
+		parm->nCap = gswdev->avlantsz;
+		break;
+
+	case GSW_CAP_TYPE_PMAC:
+		parm->nCap = gswdev->num_of_pmac;
+		break;
+
+	case GSW_CAP_TYPE_PAYLOAD:
+		parm->nCap = gswdev->pdtblsize;
+		break;
+
+	case GSW_CAP_TYPE_IF_RMON:
+		parm->nCap = gswdev->num_of_ifrmon;
+		break;
+
+	case GSW_CAP_TYPE_EGRESS_VLAN:
+		parm->nCap = gswdev->num_of_egvlan;
+		break;
+
+	case GSW_CAP_TYPE_RT_SMAC:
+		parm->nCap = gswdev->num_of_rt_smac;
+		break;
+
+	case GSW_CAP_TYPE_RT_DMAC:
+		parm->nCap = gswdev->num_of_rt_dmac;
+		break;
+
+	case GSW_CAP_TYPE_RT_PPPoE:
+		parm->nCap = gswdev->num_of_rt_ppoe;
+		break;
+
+	case GSW_CAP_TYPE_RT_NAT:
+		parm->nCap = gswdev->num_of_rt_nat;
+		break;
+
+	case GSW_CAP_TYPE_RT_MTU:
+		parm->nCap = gswdev->num_of_rt_mtu;
+		break;
+
+	case GSW_CAP_TYPE_RT_TUNNEL:
+		parm->nCap = gswdev->num_of_rt_tunnel;
+		break;
+
+	case GSW_CAP_TYPE_RT_RTP:
+		parm->nCap = gswdev->num_of_rt_rtp;
+		break;
+
+	case GSW_CAP_TYPE_LAST:
+		parm->nCap = GSW_CAP_TYPE_LAST;
+		break;
+
+	default:
+		parm->nCap = 0;
+		break;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_CfgGet(void *cdev, GSW_cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+#if defined(CONFIG_MAC) && CONFIG_MAC
+	struct mac_ops *ops;
+#endif
+	u32 value, data2;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	/* Aging Counter Mantissa Value */
+	gsw_r32(cdev, PCE_AGE_1_MANT_OFFSET,
+		PCE_AGE_1_MANT_SHIFT,
+		PCE_AGE_1_MANT_SIZE, &data2);
+
+	if (data2 == AGETIMER_1_DAY)
+		parm->eMAC_TableAgeTimer = GSW_AGETIMER_1_DAY;
+	else if (data2 == AGETIMER_1_HOUR)
+		parm->eMAC_TableAgeTimer = GSW_AGETIMER_1_HOUR;
+	else if (data2 == AGETIMER_300_SEC)
+		parm->eMAC_TableAgeTimer = GSW_AGETIMER_300_SEC;
+	else if (data2 == AGETIMER_10_SEC)
+		parm->eMAC_TableAgeTimer = GSW_AGETIMER_10_SEC;
+	else if (data2 == AGETIMER_1_SEC)
+		parm->eMAC_TableAgeTimer = GSW_AGETIMER_1_SEC;
+	else
+		parm->eMAC_TableAgeTimer = 0;
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		gsw_r32(cdev, MAC_FLEN_LEN_OFFSET,
+			MAC_FLEN_LEN_SHIFT, MAC_FLEN_LEN_SIZE, &value);
+		parm->nMaxPacketLen = value;
+		gsw_r32(cdev, MAC_PFAD_CFG_SAMOD_OFFSET,
+			MAC_PFAD_CFG_SAMOD_SHIFT,
+			MAC_PFAD_CFG_SAMOD_SIZE, &value);
+		parm->bPauseMAC_ModeSrc = value;
+		gsw_r32(cdev, PCE_GCTRL_0_VLAN_OFFSET,
+			PCE_GCTRL_0_VLAN_SHIFT,
+			PCE_GCTRL_0_VLAN_SIZE, &value);
+		parm->bVLAN_Aware = value;
+	} else if (IS_VRSN_31(gswdev->gipver)) {
+#if defined(CONFIG_MAC) && CONFIG_MAC
+		/* Get MTU for MAC2/3/4 */
+		ops = get_mac_ops(gswdev, 2);
+
+		if (!ops) {
+			pr_err("MAC 2 is not initialized\n");
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		parm->nMaxPacketLen = ops->get_mtu(ops);
+#endif
+	}
+
+	/* MAC Address Learning Limitation Mode */
+	gsw_r32(cdev, PCE_GCTRL_0_PLIMMOD_OFFSET,
+		PCE_GCTRL_0_PLIMMOD_SHIFT,
+		PCE_GCTRL_0_PLIMMOD_SIZE, &value);
+	parm->bLearningLimitAction = value;
+
+	/*Accept or discard MAC spoofing and port MAC locking violation packets */
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC) ||
+	    (IS_VRSN_30_31(gswdev->gipver))) {
+		gsw_r32(cdev, PCE_GCTRL_0_PLCKMOD_OFFSET,
+			PCE_GCTRL_0_PLCKMOD_SHIFT,
+			PCE_GCTRL_0_PLCKMOD_SIZE,
+			&parm->bMAC_SpoofingAction);
+	}
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (parm->bPauseMAC_ModeSrc) {
+			gsw_r32(cdev, MAC_PFSA_0_PFAD_OFFSET,
+				MAC_PFSA_0_PFAD_SHIFT, MAC_PFSA_0_PFAD_SIZE, &value);
+			parm->nPauseMAC_Src[5] = value & 0xFF;
+			parm->nPauseMAC_Src[4] = (value >> 8) & 0xFF;
+			gsw_r32(cdev, MAC_PFSA_1_PFAD_OFFSET,
+				MAC_PFSA_1_PFAD_SHIFT, MAC_PFSA_1_PFAD_SIZE, &value);
+			parm->nPauseMAC_Src[3] = value & 0xFF;
+			parm->nPauseMAC_Src[2] = (value >> 8) & 0xFF;
+			gsw_r32(cdev, MAC_PFSA_2_PFAD_OFFSET,
+				MAC_PFSA_2_PFAD_SHIFT, MAC_PFSA_2_PFAD_SIZE, &value);
+			parm->nPauseMAC_Src[1] = value & 0xFF;
+			parm->nPauseMAC_Src[0] = (value >> 8) & 0xFF;
+		}
+	} else if (IS_VRSN_31(gswdev->gipver)) {
+#if defined(CONFIG_MAC) && CONFIG_MAC
+		/* Get MAC used in pause frame */
+		ops = get_mac_ops(gswdev, 2);
+
+		if (!ops) {
+			pr_err("MAC 2 is not initialized\n");
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		ops->get_pfsa(ops, parm->nPauseMAC_Src, &parm->bPauseMAC_ModeSrc);
+#endif
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_CfgSet(void *cdev, GSW_cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	struct mac_ops *ops;
+	u32 MANT = 0, EXP = 0, value, i;
+	u32 max_mac;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	switch (parm->eMAC_TableAgeTimer) {
+	case GSW_AGETIMER_1_SEC:
+		MANT = AGETIMER_1_SEC;
+		EXP = 0x2;
+		gswdev->matimer = 1;
+		break;
+
+	case GSW_AGETIMER_10_SEC:
+		MANT = AGETIMER_10_SEC;
+		EXP = 0x2;
+		gswdev->matimer = 10;
+		break;
+
+	case GSW_AGETIMER_300_SEC:
+		MANT = AGETIMER_300_SEC;
+		EXP = 0x2;
+		gswdev->matimer = 300;
+		break;
+
+	case GSW_AGETIMER_1_HOUR:
+		MANT = AGETIMER_1_HOUR;
+		EXP = 0x6;
+		gswdev->matimer = 3600;
+		break;
+
+	case GSW_AGETIMER_1_DAY:
+		MANT = AGETIMER_1_DAY;
+		EXP = 0xA;
+		gswdev->matimer = 86400;
+		break;
+
+	default:
+		MANT = AGETIMER_300_SEC;
+		EXP = 0x2;
+		gswdev->matimer = 300;
+	}
+
+	/* Aging Counter Exponent Value */
+	gsw_w32(cdev, PCE_AGE_0_EXP_OFFSET,
+		PCE_AGE_0_EXP_SHIFT, PCE_AGE_0_EXP_SIZE, EXP);
+	/* Aging Counter Mantissa Value */
+	gsw_w32(cdev, PCE_AGE_1_MANT_OFFSET,
+		PCE_AGE_1_MANT_SHIFT, PCE_AGE_1_MANT_SIZE, MANT);
+
+	/* Maximum Ethernet packet length */
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (parm->nMaxPacketLen < MAX_PACKET_LENGTH)
+			value = parm->nMaxPacketLen;
+		else
+			value = MAX_PACKET_LENGTH;
+
+		gsw_w32(cdev, MAC_FLEN_LEN_OFFSET,
+			MAC_FLEN_LEN_SHIFT, MAC_FLEN_LEN_SIZE, value);
+
+		if (parm->nMaxPacketLen > 0x5EE) {
+			for (i = 0; i < 6; i++) {
+				gsw_w32(cdev, (MAC_CTRL_2_MLEN_OFFSET + (i * 0xC)),
+					MAC_CTRL_2_MLEN_SHIFT,
+					MAC_CTRL_2_MLEN_SIZE, 1);
+			}
+		}
+	} else if (IS_VRSN_31(gswdev->gipver)) {
+		/* Set MTU for MAC2/3/4 */
+		if (parm->nMaxPacketLen < V31_MAX_PACKET_LENGTH)
+			value = parm->nMaxPacketLen;
+		else
+			value = V31_MAX_PACKET_LENGTH;
+
+#if defined(CONFIG_MAC) && CONFIG_MAC
+		max_mac = gsw_get_mac_subifcnt(0);
+
+		for (i = 2; i < max_mac + 2; i++) {
+			ops = get_mac_ops(gswdev, i);
+
+			if (!ops) {
+				pr_err("MAC %d is not initialized\n", i);
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			ops->set_mtu(ops, value);
+		}
+
+#endif
+	}
+
+	/* MAC Address Learning Limitation Mode */
+	gsw_w32(cdev, PCE_GCTRL_0_PLIMMOD_OFFSET,
+		PCE_GCTRL_0_PLIMMOD_SHIFT,
+		PCE_GCTRL_0_PLIMMOD_SIZE, parm->bLearningLimitAction);
+
+	/*Accept or discard MAC spoofing and port */
+	/* MAC locking violation packets */
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (IS_VRSN_30_31(gswdev->gipver)) ||
+	    (gswdev->gipver == LTQ_GSWIP_2_2_ETC)) {
+		gsw_w32(cdev, PCE_GCTRL_0_PLCKMOD_OFFSET,
+			PCE_GCTRL_0_PLCKMOD_SHIFT,
+			PCE_GCTRL_0_PLCKMOD_SIZE, parm->bMAC_SpoofingAction);
+	}
+
+	/* VLAN-aware Switching */
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		gsw_w32(cdev, PCE_GCTRL_0_VLAN_OFFSET,
+			PCE_GCTRL_0_VLAN_SHIFT,
+			PCE_GCTRL_0_VLAN_SIZE, parm->bVLAN_Aware);
+
+		if (parm->bPauseMAC_ModeSrc == 1) {
+			gsw_w32(cdev, MAC_PFAD_CFG_SAMOD_OFFSET,
+				MAC_PFAD_CFG_SAMOD_SHIFT,
+				MAC_PFAD_CFG_SAMOD_SIZE, parm->bPauseMAC_ModeSrc);
+			value = parm->nPauseMAC_Src[4] << 8 | parm->nPauseMAC_Src[5];
+			gsw_w32(cdev, MAC_PFSA_0_PFAD_OFFSET,
+				MAC_PFSA_0_PFAD_SHIFT, MAC_PFSA_0_PFAD_SIZE, value);
+			value = parm->nPauseMAC_Src[2] << 8 | parm->nPauseMAC_Src[3];
+			gsw_w32(cdev, MAC_PFSA_1_PFAD_OFFSET,
+				MAC_PFSA_1_PFAD_SHIFT, MAC_PFSA_1_PFAD_SIZE, value);
+			value = parm->nPauseMAC_Src[0] << 8 | parm->nPauseMAC_Src[1];
+			gsw_w32(cdev, MAC_PFSA_2_PFAD_OFFSET,
+				MAC_PFSA_2_PFAD_SHIFT,
+				MAC_PFSA_2_PFAD_SIZE, value);
+		}
+	} else if (IS_VRSN_31(gswdev->gipver)) {
+#if defined(CONFIG_MAC) && CONFIG_MAC
+		max_mac = gsw_get_mac_subifcnt(0);
+
+		for (i = 2; i < max_mac + 2; i++) {
+
+			/* Set MAC to use in pause frame */
+			ops = get_mac_ops(gswdev, 2);
+
+			if (!ops) {
+				pr_err("MAC 2 is not initialized\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			ops->set_pfsa(ops, parm->nPauseMAC_Src,
+				      parm->bPauseMAC_ModeSrc);
+		}
+
+#endif
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_HW_Init(void *cdev, GSW_HW_Init_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 j;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	/* Reset the Switch via Switch IP register*/
+	j = 1;
+	gsw_w32(cdev, ETHSW_SWRES_R0_OFFSET,
+		ETHSW_SWRES_R0_SHIFT, ETHSW_SWRES_R0_SIZE, j);
+
+	do {
+//		udelay(100);
+		gsw_r32(cdev, ETHSW_SWRES_R0_OFFSET,
+			ETHSW_SWRES_R0_SHIFT, ETHSW_SWRES_R0_SIZE, &j);
+	} while (j);
+
+#if defined(CONFIG_USE_EMULATOR) && CONFIG_USE_EMULATOR
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		/* Set Auto-Polling of connected PHYs - For all ports */
+		gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET
+			       + GSW30_TOP_OFFSET),
+			GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x0);
+	} else {
+		/* Set Auto-Polling of connected PHYs - For all ports */
+		gsw_w32(cdev, (MDC_CFG_0_PEN_0_OFFSET
+			       + GSW_TREG_OFFSET),
+			MDC_CFG_0_PEN_0_SHIFT, 6, 0x0);
+	}
+
+#else
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+#ifdef __KERNEL__
+			gsw_r_init();
+#endif
+			gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
+				GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x1);
+		} else {
+			gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
+				GSWT_MDCCFG_0_PEN_1_SHIFT, 6, 0x1e);
+		}
+	}
+
+#endif  /* CONFIG_USE_EMULATOR */
+	/*	platform_device_init(cdev); */
+	gswdev->hwinit = 1;
+	/*	get_gsw_hw_cap (cdev); */
+	/* Software Table Init */
+#if defined(CONFIG_LTQ_VLAN) && CONFIG_LTQ_VLAN
+	reset_vlan_sw_table(cdev);
+#endif /*CONFIG_LTQ_VLAN */
+	ltq_ethsw_port_cfg_init(cdev);
+#if defined(CONFIG_LTQ_MULTICAST) && CONFIG_LTQ_MULTICAST
+	reset_multicast_sw_table(cdev);
+#endif /*CONFIG_LTQ_MULTICAST*/
+	pce_table_init(&gswdev->phandler);
+	/* HW Init */
+	gsw_pmicro_code_init(cdev);
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+			/*suresh*/
+//			rt_table_init();
+			gsw_w32(cdev, PCE_TFCR_NUM_NUM_OFFSET, PCE_TFCR_NUM_NUM_SHIFT,
+				PCE_TFCR_NUM_NUM_SIZE, 0x80);
+		}
+
+		/* EEE auto negotiation overides:*/
+		/*  clock disable (ANEG_EEE_0.CLK_STOP_CAPABLE)  */
+		for (j = 0; j < gswdev->pnum - 1; j++) {
+			gsw_w32(cdev,
+				((GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_OFFSET
+				  + (4 * j)) + GSW30_TOP_OFFSET),
+				GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_SHIFT,
+				GSWT_ANEG_EEE_1_CLK_STOP_CAPABLE_SIZE, 0x3);
+		}
+	} else {
+		/* Configure the MDIO Clock 97.6 Khz */
+		gsw_w32(cdev, (MDC_CFG_1_FREQ_OFFSET + GSW_TREG_OFFSET),
+			MDC_CFG_1_FREQ_SHIFT,
+			MDC_CFG_1_FREQ_SIZE, 0xFF);
+
+		for (j = 0; j < gswdev->pnum - 1; j++) {
+			gsw_w32(cdev, ((ANEG_EEE_0_CLK_STOP_CAPABLE_OFFSET + j)
+				       + GSW_TREG_OFFSET),
+				ANEG_EEE_0_CLK_STOP_CAPABLE_SHIFT,
+				ANEG_EEE_0_CLK_STOP_CAPABLE_SIZE, 0x3);
+		}
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_MDIO_CfgGet(void *cdev, GSW_MDIO_cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_mdio);
+#endif
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		gsw_r32(cdev, (GSWT_MDCCFG_1_FREQ_OFFSET
+			       + GSW30_TOP_OFFSET),
+			GSWT_MDCCFG_1_FREQ_SHIFT,
+			GSWT_MDCCFG_1_FREQ_SIZE, &value);
+		parm->nMDIO_Speed = value & 0xFF;
+		gsw_r32(cdev, (GSWT_MDCCFG_1_MCEN_OFFSET
+			       + GSW30_TOP_OFFSET),
+			GSWT_MDCCFG_1_MCEN_SHIFT,
+			GSWT_MDCCFG_1_MCEN_SIZE, &value);
+		parm->bMDIO_Enable = value;
+	} else {
+		gsw_r32(cdev, (MDC_CFG_1_FREQ_OFFSET + GSW_TREG_OFFSET),
+			MDC_CFG_1_FREQ_SHIFT,
+			MDC_CFG_1_FREQ_SIZE, &value);
+		parm->nMDIO_Speed = value & 0xFF;
+		gsw_r32(cdev, (MDC_CFG_1_MCEN_OFFSET
+			       + GSW_TREG_OFFSET),
+			MDC_CFG_1_MCEN_SHIFT,
+			MDC_CFG_1_MCEN_SIZE, &value);
+		parm->bMDIO_Enable = value;
+	}
+
+	if (value == 1)
+		parm->bMDIO_Enable = 1;
+	else
+		parm->bMDIO_Enable = 0;
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_mdio);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_MDIO_CfgSet(void *cdev, GSW_MDIO_cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_mdio);
+#endif
+
+	pr_err("**********%s:%s:%d*************\n", __FILE__, __func__, __LINE__);
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		gsw_w32(cdev, (GSWT_MDCCFG_1_FREQ_OFFSET + GSW30_TOP_OFFSET),
+			GSWT_MDCCFG_1_FREQ_SHIFT, GSWT_MDCCFG_1_FREQ_SIZE, parm->nMDIO_Speed);
+
+		if (parm->bMDIO_Enable)
+			value = 0x3F;
+		else
+			value = 0;
+
+		/* Set Auto-Polling of connected PHYs - For all ports */
+		gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
+			GSWT_MDCCFG_0_PEN_1_SHIFT, 6, value);
+		gsw_w32(cdev, (GSWT_MDCCFG_1_MCEN_OFFSET + GSW30_TOP_OFFSET),
+			GSWT_MDCCFG_1_MCEN_SHIFT, GSWT_MDCCFG_1_MCEN_SIZE, parm->bMDIO_Enable);
+	} else {
+		gsw_w32(cdev, (MDC_CFG_1_FREQ_OFFSET + GSW_TREG_OFFSET),
+			MDC_CFG_1_FREQ_SHIFT, MDC_CFG_1_FREQ_SIZE, parm->nMDIO_Speed);
+
+		if (parm->bMDIO_Enable)
+			value = 0x3F;
+		else
+			value = 0;
+
+		/* Set Auto-Polling of connected PHYs - For all ports */
+		gsw_w32(cdev, (MDC_CFG_0_PEN_0_OFFSET + GSW_TREG_OFFSET),
+			MDC_CFG_0_PEN_0_SHIFT, 6, value);
+		gsw_w32(cdev, (MDC_CFG_1_MCEN_OFFSET + GSW_TREG_OFFSET),
+			MDC_CFG_1_MCEN_SHIFT,
+			MDC_CFG_1_MCEN_SIZE, parm->bMDIO_Enable);
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_mdio);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_MDIO_DataRead(void *cdev, GSW_MDIO_data_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_mdio);
+#endif
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+
+		CHECK_BUSY_MDIO((GSWT_MDCTRL_MBUSY_OFFSET + GSW30_TOP_OFFSET),
+				GSWT_MDCTRL_MBUSY_SHIFT, GSWT_MDCTRL_MBUSY_SIZE, RETURN_FROM_FUNCTION);
+
+		value = ((0x2 << 10) | ((parm->nAddressDev & 0x1F) << 5)
+			 | (parm->nAddressReg & 0x1F));
+		/* Special write command, becouse we need to write */
+		/* "MDIO Control Register" once at a time */
+		gsw_w32(cdev, (GSWT_MDCTRL_MBUSY_OFFSET + GSW30_TOP_OFFSET), 0, 16, value);
+
+		CHECK_BUSY_MDIO((GSWT_MDCTRL_MBUSY_OFFSET + GSW30_TOP_OFFSET),
+				GSWT_MDCTRL_MBUSY_SHIFT, GSWT_MDCTRL_MBUSY_SIZE, RETURN_FROM_FUNCTION);
+
+		gsw_r32(cdev, (GSWT_MDREAD_RDATA_OFFSET + GSW30_TOP_OFFSET),
+			GSWT_MDREAD_RDATA_SHIFT, GSWT_MDREAD_RDATA_SIZE, &value);
+		parm->nData = (value & 0xFFFF);
+	} else {
+		CHECK_BUSY_MDIO((MDIO_CTRL_MBUSY_OFFSET + GSW_TREG_OFFSET),
+				MDIO_CTRL_MBUSY_SHIFT, MDIO_CTRL_MBUSY_SIZE, RETURN_FROM_FUNCTION);
+		value = ((0x2 << 10) | ((parm->nAddressDev & 0x1F) << 5)
+			 | (parm->nAddressReg & 0x1F));
+		/* Special write command, becouse we need to write */
+		/* "MDIO Control Register" once at a time */
+		gsw_w32(cdev, (MDIO_CTRL_MBUSY_OFFSET + GSW_TREG_OFFSET), 0, 16, value);
+		CHECK_BUSY_MDIO((MDIO_CTRL_MBUSY_OFFSET + GSW_TREG_OFFSET),
+				MDIO_CTRL_MBUSY_SHIFT, MDIO_CTRL_MBUSY_SIZE, RETURN_FROM_FUNCTION);
+
+		gsw_r32(cdev, (MDIO_READ_RDATA_OFFSET + GSW_TREG_OFFSET),
+			MDIO_READ_RDATA_SHIFT, MDIO_READ_RDATA_SIZE, &value);
+		parm->nData = (value & 0xFFFF);
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_mdio);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_MDIO_DataWrite(void *cdev, GSW_MDIO_data_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_mdio);
+#endif
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		CHECK_BUSY_MDIO((GSWT_MDCTRL_MBUSY_OFFSET + GSW30_TOP_OFFSET),
+				GSWT_MDCTRL_MBUSY_SHIFT, GSWT_MDCTRL_MBUSY_SIZE, RETURN_FROM_FUNCTION);
+		value = parm->nData & 0xFFFF;
+		gsw_w32(cdev, (GSWT_MDWRITE_WDATA_OFFSET + GSW30_TOP_OFFSET),
+			GSWT_MDWRITE_WDATA_SHIFT, GSWT_MDWRITE_WDATA_SIZE, value);
+		value = ((0x1 << 10) | ((parm->nAddressDev & 0x1F) << 5)
+			 | (parm->nAddressReg & 0x1F));
+		/* Special write command, becouse we need to write*/
+		/* "MDIO Control Register" once at a time */
+		gsw_w32(cdev, (GSWT_MDCTRL_MBUSY_OFFSET + GSW30_TOP_OFFSET), 0, 16, value);
+
+		CHECK_BUSY_MDIO((GSWT_MDCTRL_MBUSY_OFFSET + GSW30_TOP_OFFSET),
+				GSWT_MDCTRL_MBUSY_SHIFT, GSWT_MDCTRL_MBUSY_SIZE, RETURN_FROM_FUNCTION);
+	} else {
+
+		CHECK_BUSY_MDIO((MDIO_CTRL_MBUSY_OFFSET + GSW_TREG_OFFSET),
+				MDIO_CTRL_MBUSY_SHIFT, MDIO_CTRL_MBUSY_SIZE, RETURN_FROM_FUNCTION);
+		value = parm->nData & 0xFFFF;
+		gsw_w32(cdev, (MDIO_WRITE_WDATA_OFFSET + GSW_TREG_OFFSET),
+			MDIO_WRITE_WDATA_SHIFT, MDIO_WRITE_WDATA_SIZE, value);
+		value = ((0x1 << 10) | ((parm->nAddressDev & 0x1F) << 5)
+			 | (parm->nAddressReg & 0x1F));
+		/* Special write command, becouse we need to write*/
+		/* "MDIO Control Register" once at a time */
+		gsw_w32(cdev, (MDIO_CTRL_MBUSY_OFFSET + GSW_TREG_OFFSET), 0, 16, value);
+
+		CHECK_BUSY_MDIO((MDIO_CTRL_MBUSY_OFFSET + GSW_TREG_OFFSET),
+				MDIO_CTRL_MBUSY_SHIFT, MDIO_CTRL_MBUSY_SIZE, RETURN_FROM_FUNCTION);
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_mdio);
+#endif
+	return ret;
+
+}
+
+static inline void ltq_mdelay(int delay)
+{
+	int i;
+
+	for (i = delay; i > 0; i--)
+		;
+
+	//udelay(1000);
+}
+
+static int force_to_configure_phy_settings(void *cdev, u8 pidx, u8 link_status)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 mdio_stat_reg, phy_addr_reg = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (pidx >= (gswdev->pnum - 1))
+		return GSW_statusErr;
+
+//	if ((pidx == GSW_3X_SOC_CPU_PORT) || ((pidx == GSW_2X_SOC_CPU_PORT)))
+//		return 1;
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		gsw_r32(cdev, ((GSWT_PHY_ADDR_1_ADDR_OFFSET
+				+ ((pidx - 1) * 4)) + GSW30_TOP_OFFSET),
+			GSWT_PHY_ADDR_1_ADDR_SHIFT, 16, &phy_addr_reg);
+		gsw_r32(cdev, ((GSWT_MDIO_STAT_1_TXPAUEN_OFFSET
+				+ ((pidx - 1) * 4)) + GSW30_TOP_OFFSET),
+			GSWT_MDIO_STAT_1_TXPAUEN_SHIFT, 16, &mdio_stat_reg);
+	} else {
+		gsw_r32(cdev, ((PHY_ADDR_0_ADDR_OFFSET - pidx)
+			       + GSW_TREG_OFFSET),
+			PHY_ADDR_0_ADDR_SHIFT, 16, &phy_addr_reg);
+		gsw_r32(cdev, (MDIO_STAT_0_TXPAUEN_OFFSET
+			       + GSW_TREG_OFFSET + pidx),
+			MDIO_STAT_0_TXPAUEN_SHIFT, 16, &mdio_stat_reg);
+	}
+
+	if (link_status) {
+		/* PHY active Status */
+		if ((mdio_stat_reg >> 6) & 0x1) {
+			u32 temp = 0;
+
+			/* Link Status */
+			if ((mdio_stat_reg >> 5) & 0x1) {
+				phy_addr_reg &= ~(0xFFE0);
+				phy_addr_reg |= (1 << 13); /* Link up */
+				temp = ((mdio_stat_reg >> 3) & 0x3); /*Speed */
+				phy_addr_reg |= (temp << 11); /*Speed */
+
+				if ((mdio_stat_reg >> 2) & 0x1) { /*duplex */
+					phy_addr_reg |= (0x1 << 9); /*duplex */
+				} else {
+					phy_addr_reg |= (0x3 << 9);
+				}
+
+				/*Receive Pause Enable Status */
+				if ((mdio_stat_reg >> 1) & 0x1) {
+					/*Receive Pause Enable Status */
+					phy_addr_reg |= (0x1 << 5);
+				} else {
+					phy_addr_reg |= (0x3 << 5);
+				}
+
+				/*Transmit Pause Enable Status */
+				if ((mdio_stat_reg >> 0) & 0x1) {
+					/*Transmit Pause Enable Status */
+					phy_addr_reg |= (0x1 << 7);
+				} else {
+					phy_addr_reg |= (0x3 << 7);
+				}
+
+				if (gswdev->gipver == LTQ_GSWIP_3_0) {
+					if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+						//Reddy
+					} else {
+					}
+
+					gsw_w32(cdev,
+						((GSWT_PHY_ADDR_1_ADDR_OFFSET
+						  + ((pidx - 1) * 4))
+						 + GSW30_TOP_OFFSET),
+						GSWT_PHY_ADDR_1_ADDR_SHIFT,
+						16, phy_addr_reg);
+				} else {
+					gsw_w32(cdev,
+						((PHY_ADDR_0_ADDR_OFFSET - pidx)
+						 + GSW_TREG_OFFSET),
+						PHY_ADDR_0_ADDR_SHIFT,
+						16, phy_addr_reg);
+				}
+			}
+		}
+	} else {
+		phy_addr_reg &= ~(0xFFE0);
+		phy_addr_reg |= (0x3 << 11);
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+				//Reddy
+			} else {
+			}
+
+			gsw_w32(cdev, ((GSWT_PHY_ADDR_1_ADDR_OFFSET
+					+ ((pidx - 1) * 4)) + GSW30_TOP_OFFSET),
+				GSWT_PHY_ADDR_1_ADDR_SHIFT,
+				16, phy_addr_reg);
+		} else {
+			gsw_w32(cdev, ((PHY_ADDR_0_ADDR_OFFSET - pidx)
+				       + GSW_TREG_OFFSET),
+				PHY_ADDR_0_ADDR_SHIFT, 16, phy_addr_reg);
+		}
+	}
+
+	return 1;
+}
+
+GSW_return_t GSW_MmdDataRead(void *cdev, GSW_MMD_data_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	GSW_MDIO_data_t mmd_data;
+	u32 found = 0, rphy, rmdc, phy_addr, mdc_reg, dev, pidx;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_mmd);
+#endif
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+			if ((parm->nAddressDev == 1)) {
+				gsw_r32(cdev, (GSWT_PHY_ADDR_1_ADDR_OFFSET + GSW30_TOP_OFFSET),
+					GSWT_PHY_ADDR_1_ADDR_SHIFT, GSWT_PHY_ADDR_1_ADDR_SIZE, &phy_addr);
+				gsw_r32(cdev, (GSWT_PHY_ADDR_1_ADDR_OFFSET + GSW30_TOP_OFFSET),
+					GSWT_PHY_ADDR_1_ADDR_SHIFT, 16, &rphy);
+				found = 1;
+				pidx = 1;
+			} else {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		} else {
+			for (pidx = 1; pidx < gswdev->pnum; pidx++) {
+				gsw_r32(cdev, ((GSWT_PHY_ADDR_1_ADDR_OFFSET + ((pidx - 1) * 4)) + GSW30_TOP_OFFSET),
+					GSWT_PHY_ADDR_1_ADDR_SHIFT, GSWT_PHY_ADDR_1_ADDR_SIZE, &phy_addr);
+
+				if (phy_addr == parm->nAddressDev) {
+					found = 1;
+					gsw_r32(cdev, ((GSWT_PHY_ADDR_1_ADDR_OFFSET + ((pidx - 1) * 4)) + GSW30_TOP_OFFSET),
+						GSWT_PHY_ADDR_1_ADDR_SHIFT, 16, &rphy);
+					break;
+				}
+			}
+		}
+	} else {
+		for (pidx = 0; pidx < (gswdev->pnum - 1); pidx++) {
+			gsw_r32(cdev, ((PHY_ADDR_0_ADDR_OFFSET - pidx) + GSW_TREG_OFFSET),
+				PHY_ADDR_0_ADDR_SHIFT, PHY_ADDR_0_ADDR_SIZE, &phy_addr);
+
+			if (phy_addr == parm->nAddressDev) {
+				found = 1;
+				gsw_r32(cdev, ((PHY_ADDR_0_ADDR_OFFSET - pidx) + GSW_TREG_OFFSET),
+					PHY_ADDR_0_ADDR_SHIFT, 16, &rphy);
+				break;
+			}
+		}
+	}
+
+	if (found) {
+		force_to_configure_phy_settings(cdev, pidx, 1);
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			gsw_r32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
+				GSWT_MDCCFG_0_PEN_1_SHIFT, 6, &mdc_reg);
+		} else {
+			gsw_r32(cdev, (MDC_CFG_0_PEN_0_OFFSET + GSW_TREG_OFFSET),
+				MDC_CFG_0_PEN_0_SHIFT, 6, &mdc_reg);
+		}
+
+		rmdc = mdc_reg;
+		mdc_reg &= ~(1 << pidx);
+		dev = ((parm->nAddressReg >> 16) & 0x1F);
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
+				GSWT_MDCCFG_0_PEN_1_SHIFT, 6, mdc_reg);
+		} else {
+			gsw_w32(cdev, (MDC_CFG_0_PEN_0_OFFSET + GSW_TREG_OFFSET),
+				MDC_CFG_0_PEN_0_SHIFT, 6, mdc_reg);
+		}
+
+		ltq_mdelay(20);
+		mmd_data.nAddressDev = parm->nAddressDev;
+		mmd_data.nAddressReg = 0xd;
+		mmd_data.nData = dev;
+		GSW_MDIO_DataWrite(cdev, &mmd_data);
+
+		mmd_data.nAddressDev = parm->nAddressDev;
+		mmd_data.nAddressReg = 0xe;
+		mmd_data.nData = parm->nAddressReg & 0xFFFF;
+		GSW_MDIO_DataWrite(cdev, &mmd_data);
+
+		mmd_data.nAddressDev = parm->nAddressDev;
+		mmd_data.nAddressReg = 0xd;
+		mmd_data.nData = ((0x4000) | dev);
+		GSW_MDIO_DataWrite(cdev, &mmd_data);
+
+		mmd_data.nAddressDev = parm->nAddressDev;
+		mmd_data.nAddressReg = 0xe;
+		GSW_MDIO_DataRead(cdev, &mmd_data);
+		parm->nData = mmd_data.nData;
+
+//		mdc_reg |= (1 << pidx);
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			gsw_w32(cdev, ((GSWT_PHY_ADDR_1_ADDR_OFFSET + ((pidx - 1) * 4)) + GSW30_TOP_OFFSET),
+				GSWT_PHY_ADDR_1_ADDR_SHIFT, 16, rphy);
+			gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
+				GSWT_MDCCFG_0_PEN_1_SHIFT, 6, rmdc);
+		} else {
+			gsw_w32(cdev, ((PHY_ADDR_0_ADDR_OFFSET - pidx) + GSW_TREG_OFFSET),
+				PHY_ADDR_0_ADDR_SHIFT, 16, rphy);
+			gsw_w32(cdev, (MDC_CFG_0_PEN_0_OFFSET + GSW_TREG_OFFSET),
+				MDC_CFG_0_PEN_0_SHIFT, 6, rmdc);
+		}
+
+		ltq_mdelay(100);
+		force_to_configure_phy_settings(cdev, pidx, 0);
+	} else {
+		pr_err("(Invalid PHY Address) %s:%s:%d\n",
+		       __FILE__, __func__, __LINE__);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_mmd);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_MmdDataWrite(void *cdev, GSW_MMD_data_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	GSW_MDIO_data_t mmd_data;
+	u32 found = 0, rphy, rmdc, phy_addr, mdc_reg, dev, pidx;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_mmd);
+#endif
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+			if ((parm->nAddressDev == 1)) {
+				gsw_r32(cdev, (GSWT_PHY_ADDR_1_ADDR_OFFSET + GSW30_TOP_OFFSET),
+					GSWT_PHY_ADDR_1_ADDR_SHIFT, GSWT_PHY_ADDR_1_ADDR_SIZE, &phy_addr);
+				gsw_r32(cdev, (GSWT_PHY_ADDR_1_ADDR_OFFSET + GSW30_TOP_OFFSET),
+					GSWT_PHY_ADDR_1_ADDR_SHIFT, 16, &rphy);
+				found = 1;
+				pidx = 1;
+			} else {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		} else {
+			for (pidx = 1; pidx < gswdev->pnum; pidx++) {
+				gsw_r32(cdev, ((GSWT_PHY_ADDR_1_ADDR_OFFSET + ((pidx - 1) * 4)) + GSW30_TOP_OFFSET),
+					GSWT_PHY_ADDR_1_ADDR_SHIFT, GSWT_PHY_ADDR_1_ADDR_SIZE, &phy_addr);
+
+				if (phy_addr == parm->nAddressDev) {
+					found = 1;
+					gsw_r32(cdev, ((GSWT_PHY_ADDR_1_ADDR_OFFSET + ((pidx - 1) * 4)) + GSW30_TOP_OFFSET),
+						GSWT_PHY_ADDR_1_ADDR_SHIFT, 16, &rphy);
+					break;
+				}
+			}
+		}
+	} else {
+		for (pidx = 0; pidx < (gswdev->pnum - 1); pidx++) {
+			gsw_r32(cdev, ((PHY_ADDR_0_ADDR_OFFSET - pidx) + GSW_TREG_OFFSET),
+				PHY_ADDR_0_ADDR_SHIFT, PHY_ADDR_0_ADDR_SIZE, &phy_addr);
+
+			if (phy_addr == parm->nAddressDev) {
+				found = 1;
+				gsw_r32(cdev, ((PHY_ADDR_0_ADDR_OFFSET - pidx) + GSW_TREG_OFFSET),
+					PHY_ADDR_0_ADDR_SHIFT, 16, &rphy);
+				break;
+			}
+		}
+	}
+
+	if (found) {
+		force_to_configure_phy_settings(cdev, pidx, 1);
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			gsw_r32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET
+				       + GSW30_TOP_OFFSET),
+				GSWT_MDCCFG_0_PEN_1_SHIFT, 6, &mdc_reg);
+		} else {
+			gsw_r32(cdev, (MDC_CFG_0_PEN_0_OFFSET
+				       + GSW_TREG_OFFSET),
+				MDC_CFG_0_PEN_0_SHIFT, 6, &mdc_reg);
+		}
+
+		rmdc = mdc_reg;
+		mdc_reg &= ~(1 << pidx);
+		dev = ((parm->nAddressReg >> 16) & 0x1F);
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET
+				       + GSW30_TOP_OFFSET),
+				GSWT_MDCCFG_0_PEN_1_SHIFT, 6, mdc_reg);
+		} else {
+			gsw_w32(cdev, (MDC_CFG_0_PEN_0_OFFSET
+				       + GSW_TREG_OFFSET),
+				MDC_CFG_0_PEN_0_SHIFT, 6, mdc_reg);
+		}
+
+		ltq_mdelay(20);
+		mmd_data.nAddressDev = parm->nAddressDev;
+		mmd_data.nAddressReg = 0xd;
+		mmd_data.nData = dev;
+		GSW_MDIO_DataWrite(cdev, &mmd_data);
+
+		mmd_data.nAddressDev = parm->nAddressDev;
+		mmd_data.nAddressReg = 0xe;
+		mmd_data.nData = parm->nAddressReg & 0xFFFF;
+		GSW_MDIO_DataWrite(cdev, &mmd_data);
+
+		mmd_data.nAddressDev = parm->nAddressDev;
+		mmd_data.nAddressReg = 0xd;
+		mmd_data.nData = ((0x4000) | dev);
+		GSW_MDIO_DataWrite(cdev, &mmd_data);
+
+		mmd_data.nAddressDev = parm->nAddressDev;
+		mmd_data.nAddressReg = 0xe;
+		mmd_data.nData = parm->nData;
+		GSW_MDIO_DataWrite(cdev, &mmd_data);
+
+//		mdc_reg |= (1 << pidx);
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			gsw_w32(cdev, ((GSWT_PHY_ADDR_1_ADDR_OFFSET + ((pidx - 1) * 4)) + GSW30_TOP_OFFSET),
+				GSWT_PHY_ADDR_1_ADDR_SHIFT, 16, rphy);
+			gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET + GSW30_TOP_OFFSET),
+				GSWT_MDCCFG_0_PEN_1_SHIFT, 6, rmdc);
+		} else {
+			gsw_w32(cdev, ((PHY_ADDR_0_ADDR_OFFSET - pidx) + GSW_TREG_OFFSET),
+				PHY_ADDR_0_ADDR_SHIFT, 16, rphy);
+			gsw_w32(cdev, (MDC_CFG_0_PEN_0_OFFSET + GSW_TREG_OFFSET),
+				MDC_CFG_0_PEN_0_SHIFT, 6, rmdc);
+		}
+
+		ltq_mdelay(100);
+		force_to_configure_phy_settings(cdev, pidx, 0);
+	} else {
+		pr_err("(Invalid PHY Address)  %s:%s:%d\n",
+		       __FILE__, __func__, __LINE__);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_mmd);
+#endif
+	return ret;
+
+}
+
+static GSW_return_t GSW_MMD_MDIO_DataWrite(void *cdev,
+		GSW_MDIO_data_t *parm, u8 pidx, u8 dev)
+{
+	GSW_MDIO_data_t mmd_data;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 mdc_reg;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_mmd);
+#endif
+
+	if (pidx >= (gswdev->pnum - 1)) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	force_to_configure_phy_settings(cdev, pidx, 1);
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		gsw_r32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET
+			       + GSW30_TOP_OFFSET),
+			GSWT_MDCCFG_0_PEN_1_SHIFT, 6, &mdc_reg);
+	} else {
+		gsw_r32(cdev, (MDC_CFG_0_PEN_0_OFFSET + GSW_TREG_OFFSET),
+			MDC_CFG_0_PEN_0_SHIFT, 6, &mdc_reg);
+	}
+
+	mdc_reg &= ~(1 << pidx);
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET
+			       + GSW30_TOP_OFFSET),
+			GSWT_MDCCFG_0_PEN_1_SHIFT, 6, mdc_reg);
+	} else {
+		gsw_w32(cdev, (MDC_CFG_0_PEN_0_OFFSET + GSW_TREG_OFFSET),
+			MDC_CFG_0_PEN_0_SHIFT, 6, mdc_reg);
+	}
+
+	ltq_mdelay(20);
+
+	mmd_data.nAddressDev = parm->nAddressDev;
+	mmd_data.nAddressReg = 0xd;
+	mmd_data.nData = dev;
+	GSW_MDIO_DataWrite(cdev, &mmd_data);
+
+	mmd_data.nAddressDev = parm->nAddressDev;
+	mmd_data.nAddressReg = 0xe;
+	mmd_data.nData = parm->nAddressReg;
+	GSW_MDIO_DataWrite(cdev, &mmd_data);
+
+	mmd_data.nAddressDev = parm->nAddressDev;
+	mmd_data.nAddressReg = 0xd;
+	mmd_data.nData = ((0x4000) | (dev & 0x1F));
+	GSW_MDIO_DataWrite(cdev, &mmd_data);
+
+	mmd_data.nAddressDev = parm->nAddressDev;
+	mmd_data.nAddressReg = 0xe;
+	mmd_data.nData = parm->nData;
+	GSW_MDIO_DataWrite(cdev, &mmd_data);
+
+	mdc_reg |= (1 << pidx);
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		gsw_w32(cdev, (GSWT_MDCCFG_0_PEN_1_OFFSET
+			       + GSW30_TOP_OFFSET),
+			GSWT_MDCCFG_0_PEN_1_SHIFT, 6, mdc_reg);
+	} else {
+		gsw_w32(cdev, (MDC_CFG_0_PEN_0_OFFSET + GSW_TREG_OFFSET),
+			MDC_CFG_0_PEN_0_SHIFT, 6, mdc_reg);
+	}
+
+	ltq_mdelay(100);
+	force_to_configure_phy_settings(cdev, pidx, 0);
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_mmd);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_MonitorPortCfgGet(void *cdev, GSW_monitorPortCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 pmapReg1 = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	//Validate given Port-Id.
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	//Get monitoring port-map.
+	gsw_r32_raw(cdev, PCE_PMAP_1_REG_OFFSET, &pmapReg1);
+	parm->nPortId = pmapReg1;
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+		parm->bMonitorPort = 1;
+		GET_VAL_FROM_REG(parm->nPortId, PCE_PMAP_1_PID_SHIFT, PCE_PMAP_1_PID_SIZE, pmapReg1);
+		GET_VAL_FROM_REG(parm->nSubIfId, PCE_PMAP_1_SUBID_SHIFT, PCE_PMAP_1_SUBID_SIZE, pmapReg1);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_MonitorPortCfgSet(void *cdev, GSW_monitorPortCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 pidx = parm->nPortId;
+	u32 pmapReg1 = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	//Validate given Port-Id.
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	//En/disabel monitoring on given port-id. It is logical port-id.
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		//First read the monitoring register map.
+		gsw_r32_raw(cdev, PCE_PMAP_1_REG_OFFSET, &pmapReg1);
+
+		if (parm->bMonitorPort == 1)
+			pmapReg1 |= (1 << pidx); //Enable monitoring.
+		else
+			pmapReg1 = (pmapReg1 & ~(1 << pidx)); ////Disable monitoring.
+
+		//Update the monitoring register map.
+		gsw_w32_raw(cdev, PCE_PMAP_1_REG_OFFSET, pmapReg1);
+	} else {
+		//To test, enable mirroring on ing/egr CTP port and check?.
+		FILL_CTRL_REG(pmapReg1, PCE_PMAP_1_PID_SHIFT, parm->nPortId);
+		FILL_CTRL_REG(pmapReg1, PCE_PMAP_1_SUBID_SHIFT, parm->nSubIfId);
+		gsw_w32_raw(cdev, PCE_PMAP_1_REG_OFFSET, pmapReg1);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_PortLinkCfgGet(void *cdev, GSW_portLinkCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value;
+	u8 pidx = parm->nPortId;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+				if (pidx == 15)
+					pidx = 0;
+				else {
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+			} else {
+				if (!parm->nPortId || (parm->nPortId > (gswdev->pnum - 1))) {
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+
+				pidx = pidx - 1;
+			}
+		} else {
+			if (parm->nPortId > (gswdev->pnum - 1)) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		}
+	}
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+#if defined(CONFIG_MAC) && CONFIG_MAC
+		struct mac_ops *ops = get_mac_ops(gswdev, parm->nPortId);
+		int val = 0;
+
+		if (!ops) {
+			pr_err("MAC %d is not initialized\n", parm->nPortId);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/* MAC API's to Get Duplex */
+		val = ops->get_duplex(ops);
+
+		if (val == -1)
+			parm->bDuplexForce = 0;
+		else {
+			parm->bDuplexForce = 1;
+			parm->eDuplex = val;
+		}
+
+		/* MAC API's to Get MII Interface */
+		parm->eMII_Mode = ops->get_mii_if(ops);
+
+		/* MAC API's to Get Speed */
+		parm->eSpeed = ops->get_speed(ops);
+
+		if (parm->eSpeed != 0)
+			parm->bSpeedForce = 1;
+
+		parm->bLPI = ops->get_lpi(ops);
+
+		val = ops->get_link_sts(ops);
+
+		if (val == -1)
+			parm->bLinkForce = 0;
+		else {
+			parm->bLinkForce = 1;
+			parm->eLink = val;
+		}
+
+#endif
+	} else {
+		gsw_r32(cdev, (MAC_PSTAT_FDUP_OFFSET + (0xC * pidx)),
+			MAC_PSTAT_FDUP_SHIFT, MAC_PSTAT_FDUP_SIZE, &value);
+
+		if (value)
+			parm->eDuplex = GSW_DUPLEX_FULL;
+		else
+			parm->eDuplex = GSW_DUPLEX_HALF;
+
+		gsw_r32(cdev, (MAC_PSTAT_GBIT_OFFSET + (0xC * pidx)),
+			MAC_PSTAT_GBIT_SHIFT, MAC_PSTAT_GBIT_SIZE, &value);
+
+		if (value) {
+			parm->eSpeed = GSW_PORT_SPEED_1000;
+		} else {
+			gsw_r32(cdev, (MAC_PSTAT_MBIT_OFFSET + (0xC * pidx)),
+				MAC_PSTAT_MBIT_SHIFT, MAC_PSTAT_MBIT_SIZE, &value);
+
+			if (value)
+				parm->eSpeed = GSW_PORT_SPEED_100;
+			else
+				parm->eSpeed = GSW_PORT_SPEED_10;
+		}
+
+		/* Low-power Idle Mode  configuration*/
+		gsw_r32(cdev, (MAC_CTRL_4_LPIEN_OFFSET + (0xC * pidx)),
+			MAC_CTRL_4_LPIEN_SHIFT, MAC_CTRL_4_LPIEN_SIZE, &value);
+		parm->bLPI = value;
+		gsw_r32(cdev, (MAC_PSTAT_LSTAT_OFFSET + (0xC * pidx)),
+			MAC_PSTAT_LSTAT_SHIFT, MAC_PSTAT_LSTAT_SIZE, &value);
+
+		if (value)
+			parm->eLink = GSW_PORT_LINK_UP;
+		else
+			parm->eLink = GSW_PORT_LINK_DOWN;
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			gsw_r32(cdev, ((GSWT_PHY_ADDR_1_LNKST_OFFSET + ((pidx) * 4)) + GSW30_TOP_OFFSET),
+				GSWT_PHY_ADDR_1_LNKST_SHIFT, GSWT_PHY_ADDR_1_LNKST_SIZE, &value);
+		} else {
+			gsw_r32(cdev, ((PHY_ADDR_0_ADDR_OFFSET - pidx) + GSW_TREG_OFFSET),
+				PHY_ADDR_5_LNKST_SHIFT, PHY_ADDR_5_LNKST_SIZE, &value);
+		}
+
+		if ((value == 1) || (value == 2)) {
+			parm->bLinkForce = 1;
+		}
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			gsw_r32(cdev, (GSWT_MII_CFG_1_MIIMODE_OFFSET
+				       + GSW30_TOP_OFFSET),
+				GSWT_MII_CFG_1_MIIMODE_SHIFT,
+				GSWT_MII_CFG_1_MIIMODE_SIZE, &value);
+		} else {
+			gsw_r32(cdev, (MII_CFG_0_MIIMODE_OFFSET + (0x2 * pidx)
+				       + GSW_TREG_OFFSET),
+				MII_CFG_0_MIIMODE_SHIFT,
+				MII_CFG_0_MIIMODE_SIZE, &value);
+		}
+
+		switch (value) {
+		case 0:
+			parm->eMII_Mode = GSW_PORT_HW_MII;
+			parm->eMII_Type = GSW_PORT_PHY;
+			break;
+
+		case 1:
+			parm->eMII_Mode = GSW_PORT_HW_MII;
+			parm->eMII_Type = GSW_PORT_MAC;
+			break;
+
+		case 2:
+			parm->eMII_Mode = GSW_PORT_HW_RMII;
+			parm->eMII_Type = GSW_PORT_PHY;
+			break;
+
+		case 3:
+			parm->eMII_Mode = GSW_PORT_HW_RMII;
+			parm->eMII_Type = GSW_PORT_MAC;
+			break;
+
+		case 4:
+			parm->eMII_Mode = GSW_PORT_HW_RGMII;
+			parm->eMII_Type = GSW_PORT_MAC;
+			break;
+		}
+
+		parm->eClkMode = GSW_PORT_CLK_NA;
+
+		if (parm->eMII_Mode == GSW_PORT_HW_RMII) {
+			if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				gsw_r32(cdev, (GSWT_MII_CFG_1_RMII_OFFSET
+					       + GSW30_TOP_OFFSET),
+					GSWT_MII_CFG_1_RMII_SHIFT,
+					GSWT_MII_CFG_1_RMII_SIZE, &value);
+			} else {
+				gsw_r32(cdev, (MII_CFG_0_RMII_OFFSET + (0x2 * pidx)
+					       + GSW_TREG_OFFSET),
+					MII_CFG_0_RMII_SHIFT,
+					MII_CFG_0_RMII_SIZE, &value);
+			}
+
+			if (value == 1)
+				parm->eClkMode = GSW_PORT_CLK_MASTER;
+			else
+				parm->eClkMode = GSW_PORT_CLK_SLAVE;
+		}
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_PortLinkCfgSet(void *cdev, GSW_portLinkCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 data, phy_addr, phyreg, phy_ctrl = 0, duplex, PEN = 0, PACT = 0;
+	u8 pidx = parm->nPortId;
+	GSW_MDIO_data_t mddata;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+				if (pidx == 15)
+					pidx = 1;
+				else {
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+			} else {
+				if (!parm->nPortId || (parm->nPortId > (gswdev->pnum - 1))) {
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+			}
+		} else {
+			if (parm->nPortId > (gswdev->pnum - 1)) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		}
+	}
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+#if defined(CONFIG_MAC) && CONFIG_MAC
+		struct mac_ops *ops = get_mac_ops(gswdev, parm->nPortId);
+
+		if (!ops) {
+			pr_err("MAC %d is not initialized\n", parm->nPortId);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/* MAC API's to Set Duplex */
+		if (parm->bDuplexForce == 1)
+			ops->set_duplex(ops, parm->eDuplex);
+		else
+			ops->set_duplex(ops, GSW_DUPLEX_FULL);// Set to Full Duplex
+
+		/* MAC API's to Set MII Interface */
+		ops->set_mii_if(ops, parm->eMII_Mode);
+
+		/* MAC API's to Set Speed */
+		if (parm->bSpeedForce == 1)
+			ops->set_speed(ops, parm->eSpeed);
+		else
+			ops->set_speed(ops, 0);// Set to Auto
+
+		/* LPI Wait Time for 1G -- 50us */
+		/* LPI Wait Time for 100M -- 21us */
+		// TODO: Need to see the Wait time for XGMAC
+		ops->set_lpi(ops, parm->bLPI, 0x32, 0x15);
+
+		if (parm->bLinkForce == 1)
+			ops->set_link_sts(ops, parm->eLink);
+		else
+			ops->set_link_sts(ops, GSW_PORT_LINK_UP);	// Default to UP
+
+#endif
+	} else {
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			gsw_r32(cdev, (GSWT_MDCCFG_0_PEN_0_OFFSET + GSW30_TOP_OFFSET),
+				(GSWT_MDCCFG_0_PEN_0_SHIFT + pidx),	GSWT_MDCCFG_0_PEN_0_SIZE, &PEN);
+			gsw_r32(cdev, ((GSWT_MDIO_STAT_1_PACT_OFFSET + ((pidx - 1) * 4)) + GSW30_TOP_OFFSET),
+				GSWT_MDIO_STAT_1_PACT_SHIFT, GSWT_MDIO_STAT_1_PACT_SIZE, &PACT);
+			gsw_r32(cdev, ((GSWT_PHY_ADDR_1_ADDR_OFFSET + ((pidx - 1) * 4)) + GSW30_TOP_OFFSET),
+				0, 16, &phyreg);
+		} else {
+			gsw_r32(cdev, (MDC_CFG_0_PEN_0_OFFSET + GSW_TREG_OFFSET),
+				(MDC_CFG_0_PEN_0_SHIFT + pidx), MDC_CFG_0_PEN_0_SIZE, &PEN);
+			gsw_r32(cdev, (MDIO_STAT_0_PACT_OFFSET + GSW_TREG_OFFSET + pidx),
+				MDIO_STAT_0_PACT_SHIFT, MDIO_STAT_0_PACT_SIZE, &PACT);
+			gsw_r32(cdev, ((PHY_ADDR_0_ADDR_OFFSET - pidx) + GSW_TREG_OFFSET),
+				0, 16, &phyreg);
+		}
+
+		/*pr_err("%s:%s:%d PEN:%d, PACT:%d,  phyreg:0x%08x\n",
+			__FILE__, __func__, __LINE__,PEN, PACT,phyreg); */
+		if ((PEN == 1) && (PACT == 1)) {
+			if (parm->bDuplexForce == 1) {
+				if (parm->eDuplex == GSW_DUPLEX_FULL) {
+					data = DUPLEX_EN;
+					duplex = DUPLEX_EN;
+				} else {
+					data = DUPLEX_DIS;
+					duplex = DUPLEX_DIS;
+				}
+			} else {
+				data = DUPLEX_AUTO;
+				duplex = DUPLEX_AUTO;
+			}
+
+			data = 3; /*default value*/
+
+			if (parm->bSpeedForce == 1) {
+				switch (parm->eSpeed) {
+				case GSW_PORT_SPEED_10:
+					data = 0;
+
+					if (duplex == DUPLEX_DIS)
+						phy_ctrl = PHY_AN_ADV_10HDX;
+					else
+						phy_ctrl = PHY_AN_ADV_10FDX;
+
+					break;
+
+				case GSW_PORT_SPEED_100:
+					data = 1;
+
+					if (duplex == DUPLEX_DIS)
+						phy_ctrl = PHY_AN_ADV_100HDX;
+					else
+						phy_ctrl = PHY_AN_ADV_100FDX;
+
+					break;
+
+				case GSW_PORT_SPEED_200:
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+
+				case GSW_PORT_SPEED_1000:
+					data = 2;
+
+					if (duplex == DUPLEX_DIS)
+						phy_ctrl = PHY_AN_ADV_1000HDX;
+					else
+						phy_ctrl = PHY_AN_ADV_1000FDX;
+
+					break;
+
+				default:
+					break;
+				}
+			}
+
+			if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				gsw_r32(cdev, ((GSWT_PHY_ADDR_1_ADDR_OFFSET
+						+ ((pidx - 1) * 4)) + GSW30_TOP_OFFSET),
+					GSWT_PHY_ADDR_1_ADDR_SHIFT,
+					GSWT_PHY_ADDR_1_ADDR_SIZE, &phy_addr);
+			} else {
+				gsw_r32(cdev, ((PHY_ADDR_0_ADDR_OFFSET - pidx)
+					       + GSW_TREG_OFFSET),
+					PHY_ADDR_0_ADDR_SHIFT,
+					PHY_ADDR_0_ADDR_SIZE, &phy_addr);
+			}
+
+			mddata.nAddressDev = phy_addr;
+			GSW_MDIO_DataRead(cdev, &mddata);
+
+			if ((data == 0) || (data == 1)) {
+				mddata.nAddressReg = 4;
+				GSW_MDIO_DataRead(cdev, &mddata);
+				mddata.nData &= ~(PHY_AN_ADV_10HDX
+						  | PHY_AN_ADV_10FDX
+						  | PHY_AN_ADV_100HDX
+						  | PHY_AN_ADV_100FDX);
+				mddata.nData |= phy_ctrl;
+				GSW_MDIO_DataWrite(cdev, &mddata);
+				mddata.nAddressReg = 9;
+				GSW_MDIO_DataRead(cdev, &mddata);
+				mddata.nData &= ~(PHY_AN_ADV_1000HDX | PHY_AN_ADV_1000FDX);
+				GSW_MDIO_DataWrite(cdev, &mddata);
+			}
+
+			if (data == 2) {
+				mddata.nAddressReg = 9;
+				GSW_MDIO_DataRead(cdev, &mddata);
+				mddata.nData &= ~(PHY_AN_ADV_1000HDX | PHY_AN_ADV_1000FDX);
+				mddata.nData |= phy_ctrl;
+				GSW_MDIO_DataWrite(cdev, &mddata);
+				mddata.nAddressReg = 4;
+				GSW_MDIO_DataRead(cdev, &mddata);
+				mddata.nData &= ~(PHY_AN_ADV_10HDX
+						  | PHY_AN_ADV_10FDX
+						  | PHY_AN_ADV_100HDX
+						  | PHY_AN_ADV_100FDX);
+				GSW_MDIO_DataWrite(cdev, &mddata);
+			}
+
+			if (data == 3) {
+				mddata.nAddressReg = 4;
+				GSW_MDIO_DataRead(cdev, &mddata);
+
+				if (duplex == DUPLEX_DIS) {
+					mddata.nData &= ~(PHY_AN_ADV_10HDX
+							  | PHY_AN_ADV_10FDX
+							  | PHY_AN_ADV_100HDX
+							  | PHY_AN_ADV_100FDX);
+					mddata.nData |= (PHY_AN_ADV_10HDX
+							 | PHY_AN_ADV_100HDX);
+				} else {
+					mddata.nData |= (PHY_AN_ADV_10HDX
+							 | PHY_AN_ADV_10FDX
+							 | PHY_AN_ADV_100HDX
+							 | PHY_AN_ADV_100FDX);
+				}
+
+				GSW_MDIO_DataWrite(cdev, &mddata);
+				mddata.nAddressReg = 9;
+				GSW_MDIO_DataRead(cdev, &mddata);
+
+				if (duplex == DUPLEX_DIS) {
+					mddata.nData &= ~(PHY_AN_ADV_1000HDX
+							  | PHY_AN_ADV_1000FDX);
+					mddata.nData |= (PHY_AN_ADV_1000HDX);
+				} else {
+					mddata.nData |= (PHY_AN_ADV_1000HDX
+							 | PHY_AN_ADV_1000FDX);
+				}
+
+				GSW_MDIO_DataWrite(cdev, &mddata);
+			}
+
+			if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				gsw_w32(cdev, (MAC_CTRL_4_LPIEN_OFFSET + (0xC * (pidx - 1))),
+					MAC_CTRL_4_LPIEN_SHIFT,
+					MAC_CTRL_4_LPIEN_SIZE, parm->bLPI);
+				/* LPI Wait Time for 1G -- 50us */
+				gsw_w32(cdev, (MAC_CTRL_4_GWAIT_OFFSET + (0xC * (pidx - 1))),
+					MAC_CTRL_4_GWAIT_SHIFT,
+					MAC_CTRL_4_GWAIT_SIZE, 0x32);
+				/* LPI Wait Time for 100M -- 21us */
+				gsw_w32(cdev, (MAC_CTRL_4_WAIT_OFFSET + (0xC * (pidx - 1))),
+					MAC_CTRL_4_WAIT_SHIFT,
+					MAC_CTRL_4_WAIT_SIZE, 0x15);
+			} else {
+				gsw_w32(cdev, (MAC_CTRL_4_LPIEN_OFFSET + (0xC * pidx)),
+					MAC_CTRL_4_LPIEN_SHIFT,
+					MAC_CTRL_4_LPIEN_SIZE, parm->bLPI);
+				/* LPI Wait Time for 1G -- 50us */
+				gsw_w32(cdev, (MAC_CTRL_4_GWAIT_OFFSET + (0xC * pidx)),
+					MAC_CTRL_4_GWAIT_SHIFT,
+					MAC_CTRL_4_GWAIT_SIZE, 0x32);
+				/* LPI Wait Time for 100M -- 21us */
+				gsw_w32(cdev, (MAC_CTRL_4_WAIT_OFFSET + (0xC * pidx)),
+					MAC_CTRL_4_WAIT_SHIFT,
+					MAC_CTRL_4_WAIT_SIZE, 0x15);
+			}
+
+			/* LPI request controlled by data available for  port */
+			gsw_w32(cdev, (FDMA_CTRL_LPI_MODE_OFFSET),
+				FDMA_CTRL_LPI_MODE_SHIFT,
+				FDMA_CTRL_LPI_MODE_SIZE, 0x4);
+			mddata.nAddressDev = phy_addr;
+			mddata.nAddressReg = 0x3C;
+
+			if (parm->bLPI == 1) {
+				mddata.nData = 0x6;
+				GSW_MMD_MDIO_DataWrite(cdev, &mddata, pidx, 0x07);
+			} else {
+				mddata.nData = 0x0;
+				GSW_MMD_MDIO_DataWrite(cdev, &mddata, pidx, 0x07);
+			}
+
+			mddata.nAddressDev = phy_addr;
+			mddata.nAddressReg = 0;
+			GSW_MDIO_DataRead(cdev, &mddata);
+			mddata.nData = 0x1200;
+			data = 0;
+
+			if (parm->bLinkForce == 1) {
+				if (parm->eLink == GSW_PORT_LINK_UP) {
+					data = 1;
+				} else {
+					data = 2;
+					mddata.nData = 0x800;
+				}
+			}
+
+			GSW_MDIO_DataWrite(cdev, &mddata);
+		} else {
+			if (parm->bDuplexForce == 1) {
+				phyreg &= ~(3 << 9);
+
+				if (parm->eDuplex == GSW_DUPLEX_FULL) {
+					phyreg |= (1 << 9);
+				} else {
+					phyreg |= (3 << 9);
+				}
+			}
+
+			if (parm->bLinkForce == 1) {
+				phyreg &= ~(3 << 13);
+
+				if (parm->eLink == GSW_PORT_LINK_UP) {
+					phyreg |= (1 << 13);
+				} else {
+					phyreg |= (2 << 13);
+				}
+			}
+
+			if (parm->bSpeedForce == 1) {
+				phyreg &= ~(3 << 11);
+
+				switch (parm->eSpeed) {
+				case GSW_PORT_SPEED_10:
+					break;
+
+				case GSW_PORT_SPEED_100:
+					phyreg |= (1 << 11);
+					break;
+
+				case GSW_PORT_SPEED_200:
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+
+				case GSW_PORT_SPEED_1000:
+					phyreg |= (2 << 11);
+					break;
+
+				default:
+					break;
+				}
+			}
+
+			/*		pr_err("%s:%s:%d PEN:%d, PACT:%d,  phyreg:0x%08x\n",
+						__FILE__, __func__, __LINE__,PEN, PACT,phyreg);*/
+			if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				gsw_w32(cdev, ((GSWT_PHY_ADDR_1_ADDR_OFFSET + ((parm->nPortId - 1) * 4)) + GSW30_TOP_OFFSET),
+					0, 16, phyreg);
+			} else {
+				gsw_w32(cdev, ((PHY_ADDR_0_ADDR_OFFSET - pidx) + GSW_TREG_OFFSET),
+					0, 16, phyreg);
+			}
+		}
+
+		data = 4; /*default mode */
+
+		switch (parm->eMII_Mode) {
+		case GSW_PORT_HW_MII:
+			data = 1;
+
+			if (parm->eMII_Type == GSW_PORT_PHY)
+				data = 0;
+
+			break;
+
+		case GSW_PORT_HW_RMII:
+			data = 3;
+
+			if (parm->eMII_Type == GSW_PORT_PHY)
+				data = 2;
+
+			break;
+
+		case GSW_PORT_HW_RGMII:
+			data = 4;
+			break;
+
+		case GSW_PORT_HW_GMII:
+			/*	data = 1; */
+			break;
+
+		default:
+			break;
+		}
+
+		if (!(parm->eMII_Mode == GSW_PORT_HW_GMII)) {
+			if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				gsw_w32(cdev, (GSWT_MII_CFG_1_MIIMODE_OFFSET
+					       + GSW30_TOP_OFFSET),
+					GSWT_MII_CFG_1_MIIMODE_SHIFT,
+					GSWT_MII_CFG_1_MIIMODE_SIZE, data);
+			} else {
+				gsw_w32(cdev, (MII_CFG_0_MIIMODE_OFFSET + (0x2 * pidx)
+					       + GSW_TREG_OFFSET),
+					MII_CFG_0_MIIMODE_SHIFT,
+					MII_CFG_0_MIIMODE_SIZE, data);
+			}
+		}
+
+		data = 0;
+
+		if (parm->eMII_Mode == GSW_PORT_HW_RMII) {
+			if (parm->eClkMode == GSW_PORT_CLK_MASTER)
+				data = 1;
+
+			if (gswdev->gipver == LTQ_GSWIP_3_0) {
+				gsw_w32(cdev, (GSWT_MII_CFG_1_RMII_OFFSET
+					       + GSW30_TOP_OFFSET),
+					GSWT_MII_CFG_1_RMII_SHIFT,
+					GSWT_MII_CFG_1_RMII_SIZE, data);
+			} else {
+				gsw_w32(cdev, (MII_CFG_0_RMII_OFFSET + (0x2 * pidx)
+					       + GSW_TREG_OFFSET),
+					MII_CFG_0_RMII_SHIFT,
+					MII_CFG_0_RMII_SIZE, data);
+			}
+		}
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_PortPHY_AddrGet(void *cdev, GSW_portPHY_Addr_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 pidx = parm->nPortId, num_ports;
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (!parm->nPortId) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+			num_ports = gswdev->tpnum;
+
+			if (parm->nPortId == 15)
+				pidx = 1;
+			else {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		} else
+			num_ports = (gswdev->pnum - 1);
+
+		if (parm->nPortId > (num_ports)) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		gsw_r32(cdev, ((GSWT_PHY_ADDR_1_ADDR_OFFSET
+				+ ((pidx - 1) * 4)) + GSW30_TOP_OFFSET),
+			GSWT_PHY_ADDR_1_ADDR_SHIFT,
+			GSWT_PHY_ADDR_1_ADDR_SIZE, &value);
+	} else {
+		if (parm->nPortId >= (gswdev->pnum - 1)) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		gsw_r32(cdev, ((PHY_ADDR_0_ADDR_OFFSET - pidx)
+			       + GSW_TREG_OFFSET),
+			PHY_ADDR_0_ADDR_SHIFT,
+			PHY_ADDR_0_ADDR_SIZE, &value);
+	}
+
+	parm->nAddressDev = value;
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_PortPHY_Query(void *cdev, GSW_portPHY_Query_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 pidx = parm->nPortId;
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (!parm->nPortId || (parm->nPortId > (gswdev->pnum))) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	} else {
+		if (parm->nPortId >= (gswdev->pnum - 1)) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	gsw_r32(cdev, (MAC_PSTAT_PACT_OFFSET + (0xC * pidx)),
+		MAC_PSTAT_PACT_SHIFT, MAC_PSTAT_PACT_SIZE, &value);
+	parm->bPHY_Present = value;
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_PortRGMII_ClkCfgGet(void *cdev, GSW_portRGMII_ClkCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (!parm->nPortId || (parm->nPortId > (gswdev->pnum))) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	} else {
+		if (parm->nPortId >= (gswdev->pnum - 1)) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		gsw_r32(cdev, GSWT_PCDU_1_RXDLY_OFFSET
+			+ GSW30_TOP_OFFSET,
+			GSWT_PCDU_1_RXDLY_SHIFT,
+			GSWT_PCDU_1_RXDLY_SIZE, &value);
+		parm->nDelayRx = value;
+		gsw_r32(cdev, GSWT_PCDU_1_TXDLY_OFFSET
+			+ GSW30_TOP_OFFSET,
+			GSWT_PCDU_1_TXDLY_SHIFT,
+			GSWT_PCDU_1_TXDLY_SIZE, &value);
+		parm->nDelayTx = value;
+	} else {
+		gsw_r32(cdev, PCDU_0_RXDLY_OFFSET + (0x2 * parm->nPortId)
+			+ GSW_TREG_OFFSET,
+			PCDU_0_RXDLY_SHIFT,
+			PCDU_0_RXDLY_SIZE, &value);
+		parm->nDelayRx = value;
+		gsw_r32(cdev, PCDU_0_TXDLY_OFFSET + (0x2 * parm->nPortId)
+			+ GSW_TREG_OFFSET,
+			PCDU_0_TXDLY_SHIFT,
+			PCDU_0_TXDLY_SIZE, &value);
+		parm->nDelayTx = value;
+	}
+
+	ret = GSW_statusOk;
+
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_PortRGMII_ClkCfgSet(void *cdev, GSW_portRGMII_ClkCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (!parm->nPortId || (parm->nPortId > (gswdev->pnum))) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	} else {
+		if (parm->nPortId >= (gswdev->pnum - 1)) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		gsw_w32(cdev, (GSWT_PCDU_1_RXDLY_OFFSET
+			       + GSW30_TOP_OFFSET),
+			GSWT_PCDU_1_RXDLY_SHIFT,
+			GSWT_PCDU_1_RXDLY_SIZE, parm->nDelayRx);
+		gsw_w32(cdev, (GSWT_PCDU_1_TXDLY_OFFSET
+			       + GSW30_TOP_OFFSET),
+			GSWT_PCDU_1_TXDLY_SHIFT,
+			GSWT_PCDU_1_TXDLY_SIZE, parm->nDelayTx);
+	} else {
+		gsw_w32(cdev, (PCDU_0_RXDLY_OFFSET + (0x2 * parm->nPortId)
+			       + GSW_TREG_OFFSET),
+			PCDU_0_RXDLY_SHIFT,
+			PCDU_0_RXDLY_SIZE, parm->nDelayRx);
+		gsw_w32(cdev, (PCDU_0_TXDLY_OFFSET + (0x2 * parm->nPortId)
+			       + GSW_TREG_OFFSET),
+			PCDU_0_TXDLY_SHIFT,
+			PCDU_0_TXDLY_SIZE, parm->nDelayTx);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_PortRedirectGet(void *cdev, GSW_portRedirectCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 pidx = parm->nPortId;
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	gsw_r32(cdev, (PCE_PCTRL_3_EDIR_OFFSET + (0xA * pidx)),
+		PCE_PCTRL_3_EDIR_SHIFT,
+		PCE_PCTRL_3_EDIR_SIZE, &value);
+	parm->bRedirectEgress = value;
+
+	if (prdflag > 0)
+		parm->bRedirectIngress = 1;
+	else
+		parm->bRedirectIngress = 0;
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_PortRedirectSet(void *cdev, GSW_portRedirectCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	static GSW_PCE_rule_t pcrule;
+	u8 pidx = parm->nPortId;
+	u32 ret;
+	u32 rdport = 0, value = 0, i;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	value |= (1 << gswdev->mpnum);
+	rdport = value;
+	gsw_w32(cdev, PCE_PMAP_1_MPMAP_OFFSET, PCE_PMAP_1_MPMAP_SHIFT,
+		PCE_PMAP_1_MPMAP_SIZE, value);
+	value = parm->bRedirectEgress;
+	gsw_w32(cdev, (PCE_PCTRL_3_EDIR_OFFSET + (0xA * pidx)),
+		PCE_PCTRL_3_EDIR_SHIFT, PCE_PCTRL_3_EDIR_SIZE, value);
+
+	if (parm->bRedirectIngress == 1)
+		prdflag |= (1 << parm->nPortId);
+	else
+		prdflag &= ~(1 << parm->nPortId);
+
+	for (i = 0; i < gswdev->pnum; i++) {
+		if (((prdflag >> i) & 0x1) == 1) {
+			memset(&pcrule, 0, sizeof(GSW_PCE_rule_t));
+			pcrule.pattern.nIndex = (PRD_PRULE_INDEX + i);
+			pcrule.pattern.bEnable = 1;
+			pcrule.pattern.bPortIdEnable = 1;
+			pcrule.pattern.nPortId = i;
+
+			if (parm->bRedirectIngress == 1)
+				pcrule.action.ePortMapAction =
+					GSW_PCE_ACTION_PORTMAP_ALTERNATIVE;
+
+			pcrule.action.nForwardPortMap[0] = rdport;
+
+			/* We prepare everything and write into PCE Table */
+			if (0 != pce_rule_write(cdev,
+						&gswdev->phandler, &pcrule)) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		}  else {
+			if (0 != pce_pattern_delete(cdev,
+						    &gswdev->phandler, PRD_PRULE_INDEX + i)) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		}
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_RMON_Clear(void *cdev, GSW_RMON_clear_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 index, num_ports, pidx = parm->nRmonId;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	if ((gswdev->sdev == LTQ_FLOW_DEV_INT_R) &&
+	    (gswdev->gipver == LTQ_GSWIP_3_0)) {
+		/*if gswip 3.0: tpnum = physical port + virutual port*/
+		num_ports = gswdev->tpnum;
+	} else if (IS_VRSN_31(gswdev->gipver)) {
+		/*if gswpi 3.1: tpnum = physical port + virutual port*/
+		num_ports = gswdev->tpnum;
+	} else {
+		/*pnum is logical port: pnum = physical port*/
+		num_ports = gswdev->pnum;
+	}
+
+	switch (parm->eRmonType) {
+	case GSW_RMON_ALL_TYPE:
+		/* NOTE:Software Reset for All Interface RMON RAM in case of 3.0*/
+		/* NOTE:Software Reset for All Bridge Port RMON RAM in case of 3.1*/
+		gsw_w32(cdev, BM_RMON_GCTRL_ALLITF_RES_OFFSET,
+			BM_RMON_GCTRL_ALLITF_RES_SHIFT,
+			BM_RMON_GCTRL_ALLITF_RES_SIZE, 0x1);
+
+		/* Software Reset for PMAC RMON RAM*/
+		gsw_w32(cdev, BM_RMON_GCTRL_PMAC_RES_OFFSET,
+			BM_RMON_GCTRL_PMAC_RES_SHIFT,
+			BM_RMON_GCTRL_PMAC_RES_SIZE, 0x1);
+		/*  Software Reset for Meter RMON RAM */
+		gsw_w32(cdev, BM_RMON_GCTRL_METER_RES_OFFSET,
+			BM_RMON_GCTRL_METER_RES_SHIFT,
+			BM_RMON_GCTRL_METER_RES_SIZE, 0x1);
+
+		/*Not Applicable for GSWIP 3.1*/
+		if (IS_VRSN_NOT_31(gswdev->gipver)) {
+			/*  Software Reset for Redirection RMON RAM */
+			gsw_w32(cdev, BM_RMON_GCTRL_RED_RES_OFFSET,
+				BM_RMON_GCTRL_RED_RES_SHIFT,
+				BM_RMON_GCTRL_RED_RES_SIZE, 0x1);
+		}
+
+		/* Reset all port based RMON counter */
+		for (index = 0; index < num_ports; index++) {
+			pr_err("Rmon clear for CTP RX/TX --Logical Port %u\n", index);
+			gsw_w32(cdev,
+				BM_RMON_CTRL_RAM1_RES_OFFSET + (index * 2),
+				BM_RMON_CTRL_RAM1_RES_SHIFT,
+				BM_RMON_CTRL_RAM1_RES_SIZE, 0x1);
+			gsw_w32(cdev,
+				BM_RMON_CTRL_RAM2_RES_OFFSET + (index * 2),
+				BM_RMON_CTRL_RAM2_RES_SHIFT,
+				BM_RMON_CTRL_RAM2_RES_SIZE, 0x1);
+
+			/*Not Applicable for GSWIP 3.1*/
+			if (IS_VRSN_NOT_31(gswdev->gipver)) {
+				/*  Software Reset for Routing RMON RAM */
+				gsw_w32(cdev,
+					BM_RMON_CTRL_ROUT_RES_OFFSET + (index * 2),
+					BM_RMON_CTRL_ROUT_RES_SHIFT,
+					BM_RMON_CTRL_ROUT_RES_SIZE, 0x1);
+			}
+		}
+
+		break;
+
+	case GSW_RMON_PMAC_TYPE:
+		/* Software Reset for PMAC RMON RAM*/
+		gsw_w32(cdev, BM_RMON_GCTRL_PMAC_RES_OFFSET,
+			BM_RMON_GCTRL_PMAC_RES_SHIFT,
+			BM_RMON_GCTRL_PMAC_RES_SIZE, 0x1);
+		break;
+
+	case GSW_RMON_PORT_TYPE:
+	case GSW_RMON_CTP_TYPE:
+		if (pidx >= num_ports) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/* Reset all RMON counter */
+		/* Incase of GSWIP 3.1 Reset CTP pidx RX/TX counter */
+		gsw_w32(cdev,
+			BM_RMON_CTRL_RAM1_RES_OFFSET + (pidx * 2),
+			BM_RMON_CTRL_RAM1_RES_SHIFT,
+			BM_RMON_CTRL_RAM1_RES_SIZE, 0x1);
+		gsw_w32(cdev,
+			BM_RMON_CTRL_RAM2_RES_OFFSET + (pidx * 2),
+			BM_RMON_CTRL_RAM2_RES_SHIFT,
+			BM_RMON_CTRL_RAM2_RES_SIZE, 0x1);
+		break;
+
+	case GSW_RMON_METER_TYPE:
+		/*  Software Reset for Meter RMON RAM */
+		gsw_w32(cdev, BM_RMON_GCTRL_METER_RES_OFFSET,
+			BM_RMON_GCTRL_METER_RES_SHIFT,
+			BM_RMON_GCTRL_METER_RES_SIZE, 0x1);
+		break;
+
+	case GSW_RMON_IF_TYPE:
+	case GSW_RMON_BRIDGE_TYPE:
+		/* Interface ID to be Reset 3.0 */
+		/* Brideg Port ID to be Reset 3.1 */
+		gsw_w32(cdev, BM_RMON_GCTRL_ITFID_OFFSET,
+			BM_RMON_GCTRL_ITFID_SHIFT,
+			BM_RMON_GCTRL_ITFID_SIZE, pidx);
+		/*  Software Reset for a Single Interface RMON RAM */
+		gsw_w32(cdev, BM_RMON_GCTRL_INT_RES_OFFSET,
+			BM_RMON_GCTRL_INT_RES_SHIFT,
+			BM_RMON_GCTRL_INT_RES_SIZE, 0x1);
+		break;
+
+	case GSW_RMON_ROUTE_TYPE:
+		if (IS_VRSN_31(gswdev->gipver)) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/*  Software Reset for Routing RMON RAM */
+		gsw_w32(cdev,
+			BM_RMON_CTRL_ROUT_RES_OFFSET + (pidx * 2),
+			BM_RMON_CTRL_ROUT_RES_SHIFT,
+			BM_RMON_CTRL_ROUT_RES_SIZE, 0x1);
+		break;
+
+	case GSW_RMON_REDIRECT_TYPE:
+		if (IS_VRSN_31(gswdev->gipver)) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/*  Software Reset for Redirection RMON RAM */
+		gsw_w32(cdev, BM_RMON_GCTRL_RED_RES_OFFSET,
+			BM_RMON_GCTRL_RED_RES_SHIFT,
+			BM_RMON_GCTRL_RED_RES_SIZE, 0x1);
+		break;
+
+	default:
+		break;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+}
+
+static GSW_return_t GSW_RMON_Port_Get_Active(void *cdev, GSW_RMON_Port_cnt_t *parm)
+{
+	u8 RmonCntOffset = 0;
+	u32 data = 0, data1 = 0;
+	u32 r_frame = 0, r_unicast = 0, r_multicast = 0,
+	    t_frame = 0, t_unicast = 0, t_multicast = 0;
+	u32 rgbcl = 0, rbbcl = 0, tgbcl = 0;
+	u64 rgbch = 0, rbbch = 0, tgbch = 0;
+	u32 Portmode = 0, PortId = 0;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 count = 0;
+	bmtbl_prog_t bmtable = {0};
+	u32 ret;
+	GSW_CTP_portAssignment_t ctp_get;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	Portmode = parm->ePortType;
+	PortId = parm->nPortId;
+	/*Clear the structure before using*/
+	memset(parm, 0, sizeof(GSW_RMON_Port_cnt_t));
+
+	switch (Portmode) {
+	case GSW_CTP_PORT:
+
+		/*check based on number of logical port*/
+		if (PortId > gswdev->tpnum) {
+			pr_err("PortId %d >= gswdev->num_of_ctp %d\n", PortId, gswdev->num_of_ctp);
+			return GSW_statusErr;
+		}
+
+		ctp_get.nLogicalPortId = PortId;
+		ret = GSW_CTP_PortAssignmentGet(cdev, &ctp_get);
+
+		if (ret == GSW_statusErr) {
+			pr_err("GSW_CTP_PortAssignmentGet returns error\n");
+			return ret;
+		}
+
+		PortId = ctp_get.nFirstCtpPortId + parm->nSubIfIdGroup;
+
+		if (PortId > gswdev->num_of_ctp) {
+			pr_err("PortId %d > gswdev->num_of_ctp\n", PortId);
+			return GSW_statusErr;
+		}
+
+		if (PortId < ctp_get.nFirstCtpPortId ||
+		    PortId >= (ctp_get.nFirstCtpPortId + ctp_get.nNumberOfCtpPort)) {
+			pr_err("ERROR :CTP port not with in Allocated range\n");
+			pr_err("Check CTP assignment Get\n");
+			return GSW_statusErr;
+		}
+
+		break;
+
+	case GSW_BRIDGE_PORT:
+		if (PortId >= gswdev->num_of_bridge_port) {
+			pr_err("PortId %d >= gswdev->num_of_ctp %d\n", PortId, gswdev->num_of_bridge_port);
+			return GSW_statusErr;
+		}
+
+		break;
+
+	default:
+		pr_err("ePortType Not Supported :ERROR (ePortType=%d)\n", Portmode);
+		return GSW_statusErr;
+	}
+
+	/*GSW_ENABLE should be called before calling RMON_GET
+	  In GSW_ENABLE RMON Counter for 0- 15 logical port are enabled*/
+
+	/*Only for RX, As per SAS counter offset 0 - 21 is
+	  shared between RX and TX.
+	  Depends upon ePortType selection*/
+
+	//One-time populate.
+	bmtable.adr.rmon.portOffset = PortId;
+
+	if (Portmode == GSW_CTP_PORT) {
+		bmtable.tableID = (BM_Table_ID)GSW_RMON_CTP_PORT_RX;
+	} else {
+		bmtable.tableID = (BM_Table_ID)GSW_RMON_BRIDGE_PORT_RX;
+	}
+
+	bmtable.b64bitMode = 1;
+	bmtable.numValues = 4;
+	count = RMON_COUNTER_OFFSET_GSWIP3_1;
+
+	for (RmonCntOffset = 0; (RmonCntOffset < count) && !parm->bPceBypass; RmonCntOffset++) {
+		bmtable.adr.rmon.counterOffset = RmonCntOffset;
+		gsw_bm_table_read(cdev, &bmtable);
+		data = (bmtable.value[1] << 16) | (bmtable.value[0] & 0xFFFF);
+		data1 = (bmtable.value[3] << 16) | (bmtable.value[2] & 0xFFFF);
+
+		switch (RmonCntOffset) {
+		case 0x00: /*RX Size 64 frame count*/
+			parm->nRx64BytePkts = data;
+			parm->nRx127BytePkts = data1; /* Receive Size 65-127 Frame Count */
+			break;
+
+		case 0x02: /* Receive Size 128-255 Frame Count */
+			parm->nRx255BytePkts = data;
+			parm->nRx511BytePkts = data1; /* Receive Size 256-511 Frame Count */
+			break;
+
+		case 0x04: /* Receive Size 512-1023 Frame Count */
+			parm->nRx1023BytePkts = data;
+			parm->nRxMaxBytePkts = data1; /* Receive Size 1024 - 1518 Frame Count */
+			break;
+
+		case 0x06: /* Receive Unicast Frame Count */
+			parm->nRxUnicastPkts = r_unicast = data;
+			parm->nRxMulticastPkts = r_multicast = data1; /* Receive Multicast Frame Count1 */
+			break;
+
+		case 0x08: /* Receive Undersize Good Count */
+			parm->nRxUnderSizeGoodPkts = data; /* Less than 64 byes. */
+			parm->nRxOversizeGoodPkts = data1; /* Receive Oversize (> 1518) Good Count */
+			break;
+
+		case 0x0A: /* Receive Good Byte Count (Low) */
+			rgbcl = data;
+			rgbch = data1; /* Receive Good Byte Count (High) */
+			break;
+
+		case 0x0C: /* Receive Frme Count */
+			parm->nRxBroadcastPkts = r_frame = data;
+			parm->nRxFilteredPkts = data1; /* Receive Drop (Filter) Frame Count */
+			break;
+
+		case 0x0E: /* Receive Extended Vlan Discard Frame Count */
+			parm->nRxExtendedVlanDiscardPkts = data;
+
+			/*only applicable for CTP RX*/
+			if (Portmode == GSW_RMON_CTP_PORT_RX)
+				parm->nRxFCSErrorPkts = data1; /* Receive MAC/FCS Error frame Count */
+
+			break;
+
+		case 0x10: /* Receive Undersize Bad Count */
+
+			/*only applicable for CTP RX*/
+			if (Portmode == GSW_RMON_CTP_PORT_RX)
+				parm->nRxUnderSizeErrorPkts = data;
+
+			/*only applicable for CTP RX*/
+			if (Portmode == GSW_RMON_CTP_PORT_RX)
+				parm->nRxOversizeErrorPkts = data1; /* Receive Oversize Bad Count */
+
+			break;
+
+		case 0x12: /* MTU Exceed Discard Count */
+
+			/*only applicable for CTP RX*/
+			if (Portmode == GSW_RMON_CTP_PORT_RX)
+				parm->nMtuExceedDiscardPkts = data;
+
+			/*only applicable for CTP RX*/
+			if (Portmode == GSW_RMON_CTP_PORT_RX)
+				parm->nRxDroppedPkts = data1; /* Receive Discard (Tail-Drop) Frame Count */
+
+			break;
+
+		case 0x14: /* Receive Bad Byte Count (Low) */
+
+			/*only applicable for CTP RX*/
+			if (Portmode == GSW_RMON_CTP_PORT_RX)
+				rbbcl = data;
+
+			/*only applicable for CTP RX*/
+			if (Portmode == GSW_RMON_CTP_PORT_RX)
+				rbbch = data1; /* Receive Bad Byte Count (High) */
+
+			break;
+		}
+
+		RmonCntOffset = RmonCntOffset + 1;
+	}
+
+
+	if ((Portmode == GSW_CTP_PORT ||
+	     Portmode == GSW_BRIDGE_PORT) &&
+	    !parm->bPceBypass) {
+		/* Receive Good Byte Count */
+		parm->nRxGoodBytes = (u64)(((rgbch & 0xFFFFFFFF) << 32) | (rgbcl & 0xFFFFFFFF));
+
+		if (Portmode == GSW_CTP_PORT) {
+			/* Receive Bad Byte Count */
+			parm->nRxBadBytes = (u64)(((rbbch & 0xFFFFFFFF) << 32) | (rbbcl & 0xFFFFFFFF));
+		}
+
+		parm->nRxGoodPkts = r_frame + r_unicast + r_multicast;
+	}
+
+
+	/*Only for TX, As per SAS counter offset 0 - 13 is
+	  shared between RX and TX.
+	  Depends upon ePortType selection*/
+
+	//One-time populate.
+	bmtable.adr.rmon.portOffset = PortId;
+
+	if (Portmode == GSW_CTP_PORT) {
+		if (parm->bPceBypass)
+			bmtable.tableID = (BM_Table_ID)GSW_RMON_CTP_PORT_PCE_BYPASS;
+		else
+			bmtable.tableID = (BM_Table_ID)GSW_RMON_CTP_PORT_TX;
+	} else {
+		bmtable.tableID = (BM_Table_ID)GSW_RMON_BRIDGE_PORT_TX;
+	}
+
+	bmtable.b64bitMode = 1;
+	bmtable.numValues = 4;
+	count = 14;
+
+	for (RmonCntOffset = 0; RmonCntOffset < count; RmonCntOffset++) {
+
+		bmtable.adr.rmon.counterOffset = RmonCntOffset;
+		gsw_bm_table_read(cdev, &bmtable);
+		data = (bmtable.value[1] << 16) | (bmtable.value[0] & 0xFFFF);
+		data1 = (bmtable.value[3] << 16) | (bmtable.value[2] & 0xFFFF);
+
+		switch (RmonCntOffset) {
+		case 0x00: /* Transmit Size 64 Frame Count */
+			parm->nTx64BytePkts = data;
+			parm->nTx127BytePkts = data1; /* Transmit Size 65-127 Frame Count */
+			break;
+
+		case 0x02: /* Transmit Size 128-255 Frame Count */
+			parm->nTx255BytePkts = data;
+			parm->nTx511BytePkts = data1; /* Transmit Size 256-511 Frame Count */
+			break;
+
+		case 0x04: /* Transmit Size 512-1023 Frame Count */
+			parm->nTx1023BytePkts = data;
+			parm->nTxMaxBytePkts = data1; /* Transmit Size 1024 - 1518 Frame Count */
+			break;
+
+		case 0x06:  /* Transmit Unicast Frame Count */
+			parm->nTxUnicastPkts = t_unicast = data;
+			parm->nTxMulticastPkts = t_multicast = data1; /* Transmit Multicast Frame Count1 */
+			break;
+
+		case 0x08: /* Transmit Undersize Good Count */
+			parm->nTxUnderSizeGoodPkts = data; /* Less than 64 byes */
+			parm->nTxOversizeGoodPkts = data1; /* Transmit Oversize (> 1518) Good Count */
+			break;
+
+		case 0x0A: /* Transmit Good Byte Count (Low) */
+			tgbcl = data;
+			tgbch = data1; /* Transmit Good Byte Count (High) */
+			break;
+
+		case 0x0C: /* Transmit BroadCast Count */
+			parm->nTxBroadcastPkts = t_frame = data;
+			parm->nTxAcmDroppedPkts = data1; /* Egress Queue Discard,(Active Congestion Management) frame count.*/
+			break;
+		}
+
+		RmonCntOffset = RmonCntOffset + 1;
+	}
+
+	parm->nTxGoodPkts = t_frame + t_unicast + t_multicast;
+	/* Transmit Good Byte Count */
+	parm->nTxGoodBytes = (u64)(((tgbch & 0xFFFFFFFF) << 32) | (tgbcl & 0xFFFFFFFF));
+
+	return GSW_statusOk;
+}
+
+static GSW_return_t GSW_RMON_Port_Get_Legacy(void *cdev, GSW_RMON_Port_cnt_t *parm)
+{
+	u8 pidx, i;
+	u32 data, value, bcast_cnt;
+	u32 r_frame = 0, r_unicast = 0, r_multicast = 0,
+	    t_frame = 0, t_unicast = 0, t_multicast = 0;
+	u32 rgbcl = 0, rbbcl = 0, tgbcl = 0;
+	u64 rgbch = 0, rbbch = 0, tgbch = 0;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	bmtbl_prog_t bmtable = {0};
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	pidx = parm->nPortId;
+
+	if (gswdev) {
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			if (parm->nPortId >= gswdev->tpnum)
+				return GSW_statusErr;
+		} else {
+			if (parm->nPortId >= gswdev->pnum)
+				return GSW_statusErr;
+		}
+	}
+
+	gsw_w32(cdev, BM_PCFG_CNTEN_OFFSET + (pidx * 2),
+		BM_PCFG_CNTEN_SHIFT, BM_PCFG_CNTEN_SIZE, 1);
+	memset(parm, 0, sizeof(GSW_RMON_Port_cnt_t));
+	parm->nPortId = pidx;
+	gsw_r32(cdev, BM_RMON_CTRL_BCAST_CNT_OFFSET + (pidx * 2),
+		BM_RMON_CTRL_BCAST_CNT_SHIFT,
+		BM_RMON_CTRL_BCAST_CNT_SIZE, &bcast_cnt);
+
+	for (i = 0; i < RMON_COUNTER_OFFSET; i++) {
+		bmtable.adr.raw = (u16)i;
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			value = (pidx >= 8) ? (pidx + 8) : parm->nPortId;
+			bmtable.tableID = (BM_Table_ID)value;
+		} else {
+			bmtable.tableID = (BM_Table_ID)pidx;
+		}
+
+		bmtable.numValues = 2;
+		gsw_bm_table_read(cdev, &bmtable);
+		data = (bmtable.value[1] << 16) | bmtable.value[0];
+
+		switch (i) {
+		case 0x1F: /* Receive Frme Count */
+			if (bcast_cnt == 1)
+				parm->nRxBroadcastPkts = data;
+			else
+				parm->nRxGoodPkts = data;
+
+			r_frame = data;
+			break;
+
+		case 0x23: /* Receive Unicast Frame Count */
+			parm->nRxUnicastPkts = data;
+			r_unicast = data;
+			break;
+
+		case 0x22: /* Receive Multicast Frame Count1 */
+			parm->nRxMulticastPkts = data;
+			r_multicast = data;
+			break;
+
+		case 0x21: /* Receive CRC Errors Count */
+			parm->nRxFCSErrorPkts = data;
+			break;
+
+		case 0x1D: /* Receive Undersize Good Count */
+			parm->nRxUnderSizeGoodPkts = data;
+			break;
+
+		case 0x1B: /* Receive Oversize Good Count */
+			parm->nRxOversizeGoodPkts = data;
+			break;
+
+		case 0x1E: /* Receive Undersize Bad Count */
+			parm->nRxUnderSizeErrorPkts = data;
+			break;
+
+		case 0x20: /* Receive Pause Good Count */
+			parm->nRxGoodPausePkts = data;
+			break;
+
+		case 0x1C: /* Receive Oversize Bad Count */
+			parm->nRxOversizeErrorPkts = data;
+			break;
+
+		case 0x1A: /* Receive Alignment Errors Count */
+			parm->nRxAlignErrorPkts = data;
+			break;
+
+		case 0x12: /* Receive Size 64 Frame Count1 */
+			parm->nRx64BytePkts = data;
+			break;
+
+		case 0x13: /* Receive Size 65-127 Frame Count */
+			parm->nRx127BytePkts = data;
+			break;
+
+		case 0x14: /* Receive Size 128-255 Frame Count */
+			parm->nRx255BytePkts = data;
+			break;
+
+		case 0x15: /* Receive Size 256-511 Frame Count */
+			parm->nRx511BytePkts = data;
+			break;
+
+		case 0x16: /* Receive Size 512-1023 Frame Count */
+			parm->nRx1023BytePkts = data;
+			break;
+
+		case 0x17: /* Receive Size Greater 1023 Frame Count */
+			parm->nRxMaxBytePkts = data;
+			break;
+
+		case 0x18: /* Receive Discard (Tail-Drop) Frame Count */
+			parm->nRxDroppedPkts = data;
+			break;
+
+		case 0x19: /* Receive Drop (Filter) Frame Count */
+			parm->nRxFilteredPkts = data;
+			break;
+
+		case 0x24: /* Receive Good Byte Count (Low) */
+			rgbcl = data;
+			break;
+
+		case 0x25: /* Receive Good Byte Count (High) */
+			rgbch = data;
+			break;
+
+		case 0x26: /* Receive Bad Byte Count (Low) */
+			rbbcl = data;
+			break;
+
+		case 0x27: /* Receive Bad Byte Count (High) */
+			rbbch = data;
+			break;
+
+		case 0x0C: /* Transmit Frame Count */
+			if (bcast_cnt == 1)
+				parm->nTxBroadcastPkts = data;
+			else
+				parm->nTxGoodPkts = data;
+
+			t_frame = data;
+			break;
+
+		case 0x06: /* Transmit Unicast Frame Count */
+			parm->nTxUnicastPkts = data;
+			t_unicast = data;
+			break;
+
+		case 0x07: /* Transmit Multicast Frame Count1 */
+			parm->nTxMulticastPkts = data;
+			t_multicast = data;
+			break;
+
+		case 0x00: /* Transmit Size 64 Frame Count */
+			parm->nTx64BytePkts = data;
+			break;
+
+		case 0x01: /* Transmit Size 65-127 Frame Count */
+			parm->nTx127BytePkts = data;
+			break;
+
+		case 0x02: /* Transmit Size 128-255 Frame Count */
+			parm->nTx255BytePkts = data;
+			break;
+
+		case 0x03: /* Transmit Size 256-511 Frame Count */
+			parm->nTx511BytePkts = data;
+			break;
+
+		case 0x04: /* Transmit Size 512-1023 Frame Count */
+			parm->nTx1023BytePkts = data;
+			break;
+
+		case 0x05: /* Transmit Size Greater 1024 Frame Count */
+			parm->nTxMaxBytePkts = data;
+			break;
+
+		case 0x08: /* Transmit Single Collision Count. */
+			parm->nTxSingleCollCount = data;
+			break;
+
+		case 0x09: /* Transmit Multiple Collision Count */
+			parm->nTxMultCollCount = data;
+			break;
+
+		case 0x0A: /* Transmit Late Collision Count */
+			parm->nTxLateCollCount = data;
+			break;
+
+		case 0x0B: /* Transmit Excessive Collision.*/
+			parm->nTxExcessCollCount = data;
+			break;
+
+		case 0x0D: /* Transmit Pause Frame Count */
+			parm->nTxPauseCount = data;
+			break;
+
+		case 0x10: /* Transmit Drop Frame Count */
+			parm->nTxDroppedPkts = data;
+			break;
+
+		case 0x0E: /* Transmit Good Byte Count (Low) */
+			tgbcl = data;
+			break;
+
+		case 0x0F: /* Transmit Good Byte Count (High) */
+			tgbch = data;
+			break;
+
+		case 0x11:
+			/* Transmit Dropped Packet Cound, based on Congestion Management.*/
+			parm->nTxAcmDroppedPkts = data;
+			break;
+		}
+	}
+
+	if (bcast_cnt == 1) {
+		parm->nRxGoodPkts = r_frame + r_unicast + r_multicast;
+		parm->nTxGoodPkts = t_frame + t_unicast + t_multicast;
+	} else {
+		/* Receive Broadcase Frme Count */
+		parm->nRxBroadcastPkts = r_frame - r_unicast - r_multicast;
+		/* Transmit Broadcase Frme Count */
+		parm->nTxBroadcastPkts = t_frame - t_unicast - t_multicast;
+	}
+
+	/* Receive Good Byte Count */
+	parm->nRxGoodBytes = (u64)(((rgbch & 0xFFFFFFFF) << 32) | (rgbcl & 0xFFFFFFFF));
+	/* Receive Bad Byte Count */
+	parm->nRxBadBytes = (u64)(((rbbch & 0xFFFFFFFF) << 32) | (rbbcl & 0xFFFFFFFF));
+	/* Transmit Good Byte Count */
+	parm->nTxGoodBytes = (u64)(((tgbch & 0xFFFFFFFF) << 32) | (tgbcl & 0xFFFFFFFF));
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_RMON_Port_Get(void *cdev, GSW_RMON_Port_cnt_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+		ret = GSW_RMON_Port_Get_Active(cdev, parm);
+
+		if (ret == GSW_statusErr)
+			goto UNLOCK_AND_RETURN;
+	} else {
+		ret = GSW_RMON_Port_Get_Legacy(cdev, parm);
+
+		if (ret == GSW_statusErr)
+			goto UNLOCK_AND_RETURN;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_RMON_Mode_Set(void *cdev, GSW_RMON_mode_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	if (((gswdev->gipver == LTQ_GSWIP_3_0) && (gswdev->sdev == LTQ_FLOW_DEV_INT_R)) ||
+	    IS_VRSN_31(gswdev->gipver)) {
+		switch (parm->eRmonType) {
+		case GSW_RMON_ALL_TYPE:
+			break;
+
+		case GSW_RMON_PMAC_TYPE:
+			break;
+
+		case GSW_RMON_PORT_TYPE:
+			break;
+
+		case GSW_RMON_METER_TYPE:
+			if (parm->eCountMode == GSW_RMON_COUNT_BYTES)
+				gsw_w32(cdev, BM_RMON_GCTRL_MRMON_OFFSET, BM_RMON_GCTRL_MRMON_SHIFT, \
+					BM_RMON_GCTRL_MRMON_SIZE, 1);
+			else
+				gsw_w32(cdev, BM_RMON_GCTRL_MRMON_OFFSET, BM_RMON_GCTRL_MRMON_SHIFT, \
+					BM_RMON_GCTRL_MRMON_SIZE, 0);
+
+			break;
+
+		case GSW_RMON_IF_TYPE:
+			if (IS_VRSN_31(gswdev->gipver)) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			if (parm->eCountMode == GSW_RMON_DROP_COUNT)
+				gsw_w32(cdev, BM_RMON_GCTRL_INTMON_OFFSET, BM_RMON_GCTRL_INTMON_SHIFT, \
+					BM_RMON_GCTRL_INTMON_SIZE, 1);
+			else
+				gsw_w32(cdev, BM_RMON_GCTRL_INTMON_OFFSET, BM_RMON_GCTRL_INTMON_SHIFT, \
+					BM_RMON_GCTRL_INTMON_SIZE, 0);
+
+			break;
+
+		case GSW_RMON_ROUTE_TYPE:
+			if (IS_VRSN_31(gswdev->gipver)) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			if (parm->eCountMode == GSW_RMON_COUNT_BYTES)
+				gsw_w32(cdev, PCE_GCTRL_1_RSCNTMD_OFFSET, PCE_GCTRL_1_RSCNTMD_SHIFT, \
+					PCE_GCTRL_1_RSCNTMD_SIZE, 1);
+			else
+				gsw_w32(cdev, PCE_GCTRL_1_RSCNTMD_OFFSET, PCE_GCTRL_1_RSCNTMD_SHIFT, \
+					PCE_GCTRL_1_RSCNTMD_SIZE, 0);
+
+			break;
+
+		case GSW_RMON_REDIRECT_TYPE:
+			break;
+
+		default:
+			break;
+		}
+	} else {
+		ret = GSW_statusErr;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+}
+
+static GSW_return_t GSW_RMON_Meter_Get_Legacy(void *cdev, GSW_RMON_Meter_cnt_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if ((gswdev->gipver == LTQ_GSWIP_3_0) && (gswdev->sdev == LTQ_FLOW_DEV_INT_R)) {
+		u8 index, addr;
+		u32 data, data0, data1;
+		u8 i, j, m, rpt, loc, hc, crd[MAX_READ] = {0};
+		u32 rdcount[MAX_READ], br;
+		u8 meterid = parm->nMeterId;
+
+		if (parm->nMeterId >= gswdev->num_of_meters)
+			return GSW_statusErr;
+
+		for (index = 0; index <= 3; index++) {
+			rpt = 0;
+			hc = 0;
+			br = 0;
+			addr = (meterid | (index << 6));
+			gsw_w32(cdev, BM_RAM_ADDR_ADDR_OFFSET,
+				BM_RAM_ADDR_ADDR_SHIFT,
+				BM_RAM_ADDR_ADDR_SIZE, addr);
+repeat:
+			rpt++;
+
+			for (i = 0; i < MAX_READ; i++)
+				crd[i] = 0;
+
+			loc = 0;
+
+			for (j = 0; j < MAX_READ; j++) {
+#ifndef CONFIG_X86_INTEL_CE2700
+				/*suresh*/
+//				ltq_w32(0x8019, gswr_bm_addr);
+//				ltq_w32(0x0019, gswr_bm_addr);
+				//			asm("SYNC");
+//				ltq_w32(0x8019, gswr_bm_addr);
+#endif
+				CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET, BM_RAM_CTRL_BAS_SHIFT,
+					   BM_RAM_CTRL_BAS_SIZE, RETURN_FROM_FUNCTION);
+
+				for (i = 0; i < 4; i++) {
+					gsw_r32(cdev, BM_RAM_VAL_0_VAL0_OFFSET,
+						BM_RAM_VAL_0_VAL0_SHIFT,
+						BM_RAM_VAL_0_VAL0_SIZE, &data0);
+					gsw_r32(cdev, BM_RAM_VAL_1_VAL1_OFFSET,
+						BM_RAM_VAL_1_VAL1_SHIFT,
+						BM_RAM_VAL_1_VAL1_SIZE, &data1);
+				}
+
+				data = (data1 << 16 | data0);
+
+				switch (index) {
+				case 0:
+					rdcount[j] = data;
+					break;
+
+				case 1:
+					rdcount[j] = data;
+					break;
+
+				case 2:
+					rdcount[j] = data;
+					break;
+
+				case 3:
+					rdcount[j] = data;
+					break;
+				}
+			}
+
+			switch (index) {
+			case 0:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nResCount = br;
+				break;
+
+			case 1:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nGreenCount = br;
+				break;
+
+			case 2:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nYellowCount = br;
+				break;
+
+			case 3:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nRedCount = br;
+				break;
+			}
+		}
+	} else {
+		return GSW_statusErr;
+	}
+
+	return GSW_statusOk;
+}
+
+static GSW_return_t GSW_RMON_Meter_Get_Active(void *cdev, GSW_RMON_Meter_cnt_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 counter, data0, data1;
+	u32 meterIndex, ctrlRegData = 0, addrRegData = 0, cntOffset = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d\n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	//Temp store.
+	meterIndex = parm->nMeterId;
+	//Init to zero.
+	memset(parm, 0, sizeof(GSW_RMON_Meter_cnt_t));
+	//Restire back.
+	parm->nMeterId = meterIndex;
+
+	//Validate meter-id.
+	if (parm->nMeterId > gswdev->num_of_meters) //Max index check.
+		return GSW_statusErr;
+
+	//Populate 'data' register's Meter-Id.
+	FILL_CTRL_REG(addrRegData, BM_RAM_ADDR_RMON_METER_NUM_SHIFT, meterIndex);
+
+	//Populate 'control' register data.
+	FILL_CTRL_REG(ctrlRegData, BM_RAM_CTRL_ADDR_SHIFT, GSW_RMON_METER);
+	//RAM in read mode.
+	//FILL_CTRL_REG(ctrlRegData, BM_RAM_CTRL_OPMOD_SHIFT, 0);
+	//Set access busy bit.
+	FILL_CTRL_REG(ctrlRegData, BM_RAM_CTRL_BAS_SHIFT, 1);
+
+	//Read all Green/Yellow/Red counters.
+	for (cntOffset = GSW_RMON_METER_COLOR_GREEN;
+	     cntOffset <= GSW_RMON_METER_COLOR_RED; cntOffset++) {
+		//Populate 'data' register's Counter-Offset.
+		CLEAR_FILL_CTRL_REG(addrRegData, BM_RAM_ADDR_RMON_METER_CLR_SHIFT,
+				    BM_RAM_ADDR_RMON_METER_CLR_SIZE, cntOffset);
+		//Set RAM address to read.
+		gsw_w32_raw(cdev, BM_RAM_ADDR_REG_OFFSET, addrRegData);
+		//Set RAM table to read.
+		gsw_w32_raw(cdev, BM_RAM_CTRL_REG_OFFSET, ctrlRegData);
+		//Wait untill RAM is ready to read.
+		CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET, BM_RAM_CTRL_BAS_SHIFT,
+			   BM_RAM_CTRL_BAS_SIZE, RETURN_FROM_FUNCTION);
+		gsw_r32_raw(cdev, BM_RAM_VAL_0_VAL0_OFFSET, &data0);
+		gsw_r32_raw(cdev, BM_RAM_VAL_1_VAL1_OFFSET, &data1);
+		counter = (data1 << 16 | data0);
+
+		switch (cntOffset) {
+		case GSW_RMON_METER_COLOR_GREEN: /* Green color */
+			parm->nGreenCount = counter;
+			break;
+
+		case GSW_RMON_METER_COLOR_YELLOW: /* Yellow color */
+			parm->nYellowCount = counter;
+			break;
+
+		case GSW_RMON_METER_COLOR_RED: /* Red color */
+			parm->nRedCount = counter;
+			break;
+
+		default:
+			break;
+		}
+
+		counter = data0 = data1 = 0;
+	}
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_RMON_Meter_Get(void *cdev, GSW_RMON_Meter_cnt_t *parm)
+{
+	u32 ret;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+		ret = GSW_RMON_Meter_Get_Active(cdev, parm);
+
+		if (ret == GSW_statusErr)
+			goto UNLOCK_AND_RETURN;
+	} else {
+		ret = GSW_RMON_Meter_Get_Legacy(cdev, parm);
+
+		if (ret == GSW_statusErr)
+			goto UNLOCK_AND_RETURN;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+
+}
+
+
+GSW_return_t GSW_RMON_Redirect_Get(void *cdev, GSW_RMON_Redirect_cnt_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	if ((gswdev->gipver == LTQ_GSWIP_3_0) && (gswdev->sdev == LTQ_FLOW_DEV_INT_R)) {
+		u8 index;
+		u8 i, j, m, rpt, loc, hc, crd[MAX_READ] = {0};
+		u32 rdcount[MAX_READ] = {0}, br;
+		u32 data, data0, data1;
+		u64  rxbytes_l = 0, rxbytes_h = 0;
+		u64 txbytes_l = 0, txbytes_h = 0;
+
+		for (index = 0; index < 8; index++) {
+			rpt = 0;
+			hc = 0;
+			br = 0;
+			gsw_w32(cdev, BM_RAM_ADDR_ADDR_OFFSET, BM_RAM_ADDR_ADDR_SHIFT,
+				BM_RAM_ADDR_ADDR_SIZE, index);
+repeat:
+			rpt++;
+
+			for (i = 0; i < MAX_READ; i++)
+				crd[i] = 0;
+
+			loc = 0;
+
+			for (j = 0; j < MAX_READ; j++) {
+#ifndef CONFIG_X86_INTEL_CE2700
+				/*suresh*/
+//				ltq_w32(0x8018, gswr_bm_addr);
+//				ltq_w32(0x0018, gswr_bm_addr);
+				//			asm("SYNC");
+//				ltq_w32(0x8018, gswr_bm_addr);
+#endif
+
+				if (GSW_statusErr == CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET,
+								BM_RAM_CTRL_BAS_OFFSET, BM_RAM_CTRL_BAS_OFFSET, RETURN_ERROR_CODE))
+					continue; /*Error already printed. Try the next iteration*/
+
+				for (i = 0; i < 4; i++) {
+					gsw_r32(cdev, BM_RAM_VAL_0_VAL0_OFFSET,
+						BM_RAM_VAL_0_VAL0_SHIFT,
+						BM_RAM_VAL_0_VAL0_SIZE, &data0);
+					gsw_r32(cdev, BM_RAM_VAL_1_VAL1_OFFSET,
+						BM_RAM_VAL_1_VAL1_SHIFT,
+						BM_RAM_VAL_1_VAL1_SIZE, &data1);
+				}
+
+				data = (data1 << 16 | data0);
+
+				switch (index) {
+				case 0:
+					rdcount[j] = data;
+					break;
+
+				case 1:
+					rdcount[j] = data;
+					break;
+
+				case 2:
+					rdcount[j] = data;
+					break;
+
+				case 3:
+					rdcount[j] = data;
+					break;
+
+				case 4:
+					rdcount[j] = data;
+					break;
+
+				case 5:
+					rdcount[j] = data;
+					break;
+
+				case 6:
+					rdcount[j] = data;
+					break;
+
+				case 7:
+					rdcount[j] = data;
+					break;
+				}
+			}
+
+			switch (index) {
+			case 0:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nRxPktsCount = br;
+				break;
+
+			case 1:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nRxDiscPktsCount = br;
+				break;
+
+			case 2:
+				calc_credit_byte_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				rxbytes_l = br;
+				break;
+
+			case 3:
+				calc_credit_byte_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				rxbytes_h = br;
+				break;
+
+			case 4:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nTxPktsCount = br;
+				break;
+
+			case 5:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nTxDiscPktsCount = br;
+				break;
+
+			case 6:
+				calc_credit_byte_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				txbytes_l = br;
+				/*		parm->nTxBytesCount = br; */
+				break;
+
+			case 7:
+				calc_credit_byte_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				txbytes_h = br;
+				/*		parm->nTxBytesCount |= (br << 32); */
+				break;
+			}
+		}
+
+		parm->nRxBytesCount = (u64)(((rxbytes_h & 0xFFFFFFFF) << 32) | (rxbytes_l & 0xFFFFFFFF));
+		parm->nTxBytesCount = (u64)(((txbytes_h & 0xFFFFFFFF) << 32) | (txbytes_l & 0xFFFFFFFF));
+	} else {
+		ret = GSW_statusErr;
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_RMON_If_Get(void *cdev, GSW_RMON_If_cnt_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	if ((gswdev->gipver == LTQ_GSWIP_3_0) && (gswdev->sdev == LTQ_FLOW_DEV_INT_R)) {
+		u8 index, i, j, m, rpt, loc, hc, crd[MAX_READ] = {0};
+		u32 data, data0, data1, addr, intmon;
+		u32 rdcount[MAX_READ] = {0}, br;
+		u8 ifid = parm->nIfId;
+
+		if (parm->nIfId >= 256) { /* ETHSW_CAP_13 register*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		gsw_r32(cdev, BM_RMON_GCTRL_INTMON_OFFSET,
+			BM_RMON_GCTRL_INTMON_SHIFT,
+			BM_RMON_GCTRL_INTMON_SIZE, &intmon);
+
+		if (intmon)
+			parm->countMode = GSW_RMON_DROP_COUNT;
+		else
+			parm->countMode = GSW_RMON_COUNT_BYTES;
+
+		for (index = 0; index <= 3; index++) {
+			rpt = 0;
+			hc = 0;
+			br = 0;
+			addr = (ifid | (index << 8));
+			gsw_w32(cdev, BM_RAM_ADDR_ADDR_OFFSET, BM_RAM_ADDR_ADDR_SHIFT,
+				BM_RAM_ADDR_ADDR_SIZE, addr);
+repeat:
+			rpt++;
+
+			for (i = 0; i < MAX_READ; i++)
+				crd[i] = 0;
+
+			loc = 0;
+
+			for (j = 0; j < MAX_READ; j++) {
+#ifndef CONFIG_X86_INTEL_CE2700
+				/*suresh*/
+				//			ltq_w32(0x801A, gswr_bm_addr);
+				//			ltq_w32(0x001A, gswr_bm_addr);
+				//			asm("SYNC");
+				//			ltq_w32(0x801A, gswr_bm_addr);
+#endif
+
+				if (GSW_statusErr == CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET,
+								BM_RAM_CTRL_BAS_SHIFT, BM_RAM_CTRL_BAS_SIZE, RETURN_ERROR_CODE))
+					continue;
+
+				for (i = 0; i < 4; i++) {
+					gsw_r32(cdev, BM_RAM_VAL_0_VAL0_OFFSET,
+						BM_RAM_VAL_0_VAL0_SHIFT,
+						BM_RAM_VAL_0_VAL0_SIZE, &data0);
+					gsw_r32(cdev, BM_RAM_VAL_1_VAL1_OFFSET,
+						BM_RAM_VAL_1_VAL1_SHIFT,
+						BM_RAM_VAL_1_VAL1_SIZE, &data1);
+				}
+
+				data = (data1 << 16 | data0);
+
+				switch (index) {
+				case 0:
+					rdcount[j] = data;
+					break;
+
+				case 1:
+					rdcount[j] = data;
+					break;
+
+				case 2:
+					rdcount[j] = data;
+					break;
+
+				case 3:
+					rdcount[j] = data;
+					break;
+				}
+			}
+
+			switch (index) {
+			case 0:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nRxPktsCount = br;
+				break;
+
+			case 1:
+				if (intmon)
+					calc_credit_value(rdcount, &m, &loc);
+				else
+					calc_credit_byte_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				if (intmon) {
+					parm->nRxDiscPktsCount = br;
+					parm->nRxBytesCount = 0;
+				} else {
+					parm->nRxBytesCount = br;
+					parm->nRxDiscPktsCount = 0;
+				}
+
+				break;
+
+			case 2:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nTxPktsCount = br;
+				break;
+
+			case 3:
+				if (intmon)
+					calc_credit_value(rdcount, &m, &loc);
+				else
+					calc_credit_byte_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				if (intmon) {
+					parm->nTxDiscPktsCount = br;
+					parm->nTxBytesCount = 0;
+				} else {
+					parm->nTxBytesCount = br;
+					parm->nTxDiscPktsCount = 0;
+				}
+
+				break;
+			}
+		}
+	} else {
+		ret = GSW_statusErr;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_RMON_Route_Get(void *cdev, GSW_RMON_Route_cnt_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return  GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	if ((gswdev->gipver == LTQ_GSWIP_3_0) && (gswdev->sdev == LTQ_FLOW_DEV_INT_R)) {
+		u8 index, addr;
+		u8 i, j, m, rpt, loc, hc, crd[MAX_READ] = {0};
+		u32 rdcount[MAX_READ] = {0}, br;
+		u32 data, data0, data1;
+		u8 rid = parm->nRoutedPortId;
+
+		if (parm->nRoutedPortId >= 16 /* gswdev->tpnum*/) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		for (index = 0; index <= 13; index++) {
+			addr = (rid | (index << 4));
+			gsw_w32(cdev, BM_RAM_ADDR_ADDR_OFFSET, BM_RAM_ADDR_ADDR_SHIFT,
+				BM_RAM_ADDR_ADDR_SIZE, addr);
+			rpt = 0;
+			hc = 0;
+			br = 0;
+repeat:
+			rpt++;
+
+			for (i = 0; i < MAX_READ; i++)
+				crd[i] = 0;
+
+			loc = 0;
+
+			for (j = 0; j < MAX_READ; j++) {
+#ifndef CONFIG_X86_INTEL_CE2700
+				/*suresh*/
+//				ltq_w32(0x801B, gswr_bm_addr);
+//				ltq_w32(0x001B, gswr_bm_addr);
+				//			asm("SYNC");
+//				ltq_w32(0x801B, gswr_bm_addr);
+#endif
+
+				if (GSW_statusErr == CHECK_BUSY(BM_RAM_CTRL_BAS_SIZE,
+								BM_RAM_CTRL_BAS_SHIFT, BM_RAM_CTRL_BAS_SIZE, RETURN_ERROR_CODE))
+					continue;
+
+				for (i = 0; i < 4; i++) {
+					gsw_r32(cdev, BM_RAM_VAL_0_VAL0_OFFSET,
+						BM_RAM_VAL_0_VAL0_SHIFT,
+						BM_RAM_VAL_0_VAL0_SIZE, &data0);
+					gsw_r32(cdev, BM_RAM_VAL_1_VAL1_OFFSET,
+						BM_RAM_VAL_1_VAL1_SHIFT,
+						BM_RAM_VAL_1_VAL1_SIZE, &data1);
+				}
+
+				data = (data1 << 16 | data0);
+
+				switch (index) {
+				case 0:
+					rdcount[j] = data;
+					break;
+
+				case 1:
+					rdcount[j] = data;
+					break;
+
+				case 2:
+					rdcount[j] = data;
+					break;
+
+				case 3:
+					rdcount[j] = data;
+					break;
+
+				case 4:
+					rdcount[j] = data;
+					break;
+
+				case 5:
+					rdcount[j] = data;
+					break;
+
+				case 6:
+					rdcount[j] = data;
+					break;
+
+				case 7:
+					rdcount[j] = data;
+					break;
+
+				case 8:
+					rdcount[j] = data;
+					break;
+
+				case 9:
+					rdcount[j] = data;
+					break;
+
+				case 0x0A:
+					rdcount[j] = data;
+					break;
+
+				case 0x0B:
+					rdcount[j] = data;
+					break;
+
+				case 0x0C:
+					rdcount[j] = data;
+					break;
+
+				case 0x0D:
+					rdcount[j] = data;
+					break;
+				}
+			}
+
+			switch (index) {
+			case 0:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nRxUCv4UDPPktsCount = br;
+				break;
+
+			case 1:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nRxUCv4TCPPktsCount = br;
+				break;
+
+			case 2:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nRxMCv4PktsCount = br;
+				break;
+
+			case 3:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nRxUCv6UDPPktsCount = br;
+				break;
+
+			case 4:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nRxUCv6TCPPktsCount = br;
+				break;
+
+			case 5:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nRxMCv6PktsCount = br;
+				break;
+
+			case 6:
+				calc_credit_byte_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nRxIPv4BytesCount = br;
+				break;
+
+			case 7:
+				calc_credit_byte_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nRxIPv6BytesCount = br;
+				break;
+
+			case 8:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nRxCpuPktsCount = br;
+				break;
+
+			case 9:
+				calc_credit_byte_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nRxCpuBytesCount = br;
+				break;
+
+			case 0x0A:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nRxPktsDropCount = br;
+				break;
+
+			case 0x0B:
+				calc_credit_byte_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nRxBytesDropCount = br;
+				break;
+
+			case 0x0C:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nTxPktsCount = br;
+				break;
+
+			case 0x0D:
+				calc_credit_byte_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nTxBytesCount = br;
+				break;
+			}
+		}
+	} else {
+		ret = GSW_statusErr;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+
+}
+
+static GSW_return_t GSW_PMAC_CountGet_v31(void *cdev, GSW_PMAC_Cnt_t *parm)
+{
+	u8 i = 0;
+	u32 data;
+	bmtbl_prog_t bmtable = {0};
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return  GSW_statusErr;
+	}
+
+	/* For Ingress it is 0 - 16, for Egress 0 - 15. */
+	if ((parm->nTxDmaChanId >= 17) || (parm->nPmacId >= 2)) {
+		return GSW_statusErr;
+	}
+
+	for (i = 0; i < 8; i++) {
+		/* Egress csum counter not present with 3.1 */
+		if ((i == 2) || (i == 3))
+			continue;
+
+		bmtable.adr.pmacRmon.channel_or_port = parm->nTxDmaChanId;
+		bmtable.adr.pmacRmon.count = i;
+		bmtable.adr.pmacRmon.pmacNo = parm->nPmacId;
+		bmtable.b64bitMode = parm->b64BitMode;
+		bmtable.tableID = PMAC_RMON_COUNTER;
+		bmtable.numValues = 2;
+		gsw_bm_table_read(cdev, &bmtable);
+		data = (bmtable.value[1] << 16) | (bmtable.value[0] & 0xFFFF);
+
+		switch (i) {
+		case 0:
+			parm->nDiscPktsCount = data;
+			break;
+
+		case 1:
+			parm->nDiscBytesCount = data;
+			break;
+
+		case 4:
+			parm->nIngressPktsCount = data;
+			break;
+
+		case 5:
+			parm->nIngressBytesCount = data;
+			break;
+
+		case 6:
+			parm->nEgressPktsCount = data;
+			break;
+
+		case 7:
+			parm->nEgressBytesCount = data;
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	return GSW_statusOk;
+}
+
+int GSW_PMAC_CountGet(void *cdev, GSW_PMAC_Cnt_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	if ((gswdev->gipver == LTQ_GSWIP_3_0) && (gswdev->sdev == LTQ_FLOW_DEV_INT_R)) {
+		u8 index;
+		u8 i, j, m, rpt, loc, hc, crd[MAX_READ] = {0};
+		u32 rdcount[MAX_READ] = {0}, br;
+		u32 data0, data1, data, value;
+
+		if (parm->nTxDmaChanId >= 16) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		for (index = 0; index < 4; index++) {
+			value = ((index << 4) | (parm->nTxDmaChanId & 0xF));
+			gsw_w32(cdev, BM_RAM_ADDR_ADDR_OFFSET, BM_RAM_ADDR_ADDR_SHIFT,
+				BM_RAM_ADDR_ADDR_SIZE, value);
+			rpt = 0;
+			hc = 0;
+			br = 0;
+repeat:
+			rpt++;
+
+			for (i = 0; i < MAX_READ; i++)
+				crd[i] = 0;
+
+			loc = 0;
+
+			for (j = 0; j < MAX_READ; j++) {
+#ifndef CONFIG_X86_INTEL_CE2700
+				//ltq_w32(0x801C, gswr_bm_addr);
+				//ltq_w32(0x001C, gswr_bm_addr);
+//				asm("SYNC");
+				//ltq_w32(0x801C, gswr_bm_addr);
+#endif
+
+				if (GSW_statusErr == CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET,
+								BM_RAM_CTRL_BAS_SHIFT, BM_RAM_CTRL_BAS_SIZE, RETURN_ERROR_CODE))
+					continue;
+
+				for (i = 0; i < 4; i++) {
+					gsw_r32(cdev, BM_RAM_VAL_0_VAL0_OFFSET,
+						BM_RAM_VAL_0_VAL0_SHIFT,
+						BM_RAM_VAL_0_VAL0_SIZE, &data0);
+					gsw_r32(cdev, BM_RAM_VAL_1_VAL1_OFFSET,
+						BM_RAM_VAL_1_VAL1_SHIFT,
+						BM_RAM_VAL_1_VAL1_SIZE, &data1);
+				}
+
+				data = (data1 << 16 | data0);
+
+				switch (index) {
+				case 0:
+					rdcount[j] = data;
+					break;
+
+				case 1:
+					rdcount[j] = data;
+					break;
+
+				case 2:
+					rdcount[j] = data;
+					break;
+
+				case 3:
+					rdcount[j] = data;
+					break;
+				}
+			}
+
+			switch (index) {
+			case 0:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nDiscPktsCount = br;
+				break;
+
+			case 1:
+				calc_credit_byte_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nDiscBytesCount = br;
+				break;
+
+			case 2:
+				calc_credit_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nChkSumErrPktsCount = br;
+				break;
+
+			case 3:
+				calc_credit_byte_value(rdcount, &m, &loc);
+
+				if (m > hc) {
+					hc = m;
+					br = rdcount[loc];
+				}
+
+				if ((m < REPEAT_L) && (rpt < REPEAT_M)) {
+					goto repeat;
+				}
+
+				parm->nChkSumErrBytesCount = br;
+				break;
+			}
+		}
+	} else if ((gswdev->gipver == LTQ_GSWIP_3_1)) {
+		GSW_PMAC_CountGet_v31(cdev, parm);
+	} else {
+		ret = GSW_statusErr;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+}
+
+
+
+GSW_return_t GSW_PMAC_GLBL_CfgSet(void *cdev, GSW_PMAC_Glbl_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 pmac_ctrl0, pmac_ctrl1, pmac_ctrl2, pmac_ctrl3, pmac_ctrl4;
+	u32 pmac_ctrl0_off,
+	    pmac_ctrl1_off,
+	    pmac_ctrl2_off,
+	    pmac_ctrl3_off,
+	    pmac_ctrl4_off,
+	    pmac_bsl1_off,
+	    pmac_bsl2_off,
+	    pmac_bsl3_off;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pmac);
+#endif
+
+	pmac_ctrl0_off = pmac_addr_off(PMAC_CTRL_0_PADEN_OFFSET, parm->nPmacId);
+	pmac_ctrl1_off = pmac_addr_off(PMAC_CTRL_1_MLEN_OFFSET, parm->nPmacId);
+	pmac_ctrl2_off = pmac_addr_off(PMAC_CTRL_2_LCHKL_OFFSET, parm->nPmacId);
+	pmac_ctrl3_off = pmac_addr_off(PMAC_CTRL_3_JUMBO_OFFSET, parm->nPmacId);
+	pmac_ctrl4_off = pmac_addr_off(PMAC_CTRL_4_FLAGEN_OFFSET, parm->nPmacId);
+
+	pmac_bsl1_off = pmac_addr_off(PMAC_BSL_LEN0_OFFSET, parm->nPmacId);
+	pmac_bsl2_off = pmac_addr_off(PMAC_BSL_LEN1_OFFSET, parm->nPmacId);
+	pmac_bsl3_off = pmac_addr_off(PMAC_BSL_LEN2_OFFSET, parm->nPmacId);
+
+	gsw_r32_raw(cdev, pmac_ctrl0_off, &pmac_ctrl0);
+
+	if (IS_VRSN_31(gswdev->gipver))
+		gsw_r32_raw(cdev, pmac_ctrl1_off, &pmac_ctrl1);
+
+	gsw_r32_raw(cdev, pmac_ctrl2_off, &pmac_ctrl2);
+	gsw_r32_raw(cdev, pmac_ctrl3_off, &pmac_ctrl3);
+	gsw_r32_raw(cdev, pmac_ctrl4_off, &pmac_ctrl4);
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+		pmac_ctrl0 = gsw_field_w32(pmac_ctrl0, PMAC_CTRL_0_APADEN_SHIFT,
+					   PMAC_CTRL_0_APADEN_SIZE, parm->bAPadEna);
+		pmac_ctrl0 = gsw_field_w32(pmac_ctrl0, PMAC_CTRL_0_PADEN_SHIFT,
+					   PMAC_CTRL_0_PADEN_SIZE, parm->bPadEna);
+		pmac_ctrl0 = gsw_field_w32(pmac_ctrl0, PMAC_CTRL_0_VPADEN_SHIFT,
+					   PMAC_CTRL_0_VPADEN_SIZE, parm->bVPadEna);
+		pmac_ctrl0 = gsw_field_w32(pmac_ctrl0, PMAC_CTRL_0_VPAD2EN_SHIFT,
+					   PMAC_CTRL_0_VPAD2EN_SIZE, parm->bSVPadEna);
+		pmac_ctrl0 = gsw_field_w32(pmac_ctrl0, PMAC_CTRL_0_FCS_SHIFT,
+					   PMAC_CTRL_0_FCS_SIZE, parm->bTxFCSDis);
+
+		if (IS_VRSN_31(gswdev->gipver)) {
+			pmac_ctrl0 = gsw_field_w32(pmac_ctrl0, PMAC_CTRL_0_FCSEN_SHIFT,
+						   PMAC_CTRL_0_FCSEN_SIZE, parm->bRxFCSDis);
+		}
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			pmac_ctrl0 = gsw_field_w32(pmac_ctrl0, PMAC_CTRL_0_CHKREG_SHIFT,
+						   PMAC_CTRL_0_CHKREG_SIZE, parm->bIPTransChkRegDis);
+			pmac_ctrl0 = gsw_field_w32(pmac_ctrl0, PMAC_CTRL_0_CHKVER_SHIFT,
+						   PMAC_CTRL_0_CHKVER_SIZE, parm->bIPTransChkVerDis);
+			pmac_ctrl4 = gsw_field_w32(pmac_ctrl4, PMAC_CTRL_4_FLAGEN_SHIFT,
+						   PMAC_CTRL_4_FLAGEN_SIZE, parm->bProcFlagsEgCfgEna);
+		}
+
+		if (parm->bJumboEna == 1) {
+			pmac_ctrl2 = gsw_field_w32(pmac_ctrl2, PMAC_CTRL_2_MLEN_SHIFT,
+						   PMAC_CTRL_2_MLEN_SIZE, 1);
+
+			if (IS_VRSN_31(gswdev->gipver))
+				pmac_ctrl1 = gsw_field_w32(pmac_ctrl1, PMAC_CTRL_1_MLEN_SHIFT,
+							   PMAC_CTRL_1_MLEN_SIZE, parm->nMaxJumboLen);
+
+			if (gswdev->gipver == LTQ_GSWIP_3_0)
+				pmac_ctrl3 = gsw_field_w32(pmac_ctrl3, PMAC_CTRL_3_JUMBO_SHIFT,
+							   PMAC_CTRL_3_JUMBO_SIZE, parm->nMaxJumboLen);
+		} else {
+			pmac_ctrl2 = gsw_field_w32(pmac_ctrl2, PMAC_CTRL_2_MLEN_SHIFT,
+						   PMAC_CTRL_2_MLEN_SIZE, 0);
+
+			if (gswdev->gipver == LTQ_GSWIP_3_0)
+				pmac_ctrl3 = gsw_field_w32(pmac_ctrl3, PMAC_CTRL_3_JUMBO_SHIFT,
+							   PMAC_CTRL_3_JUMBO_SIZE, 0x8F8);
+		}
+
+		pmac_ctrl2 = gsw_field_w32(pmac_ctrl2, PMAC_CTRL_2_LCHKL_SHIFT,
+					   PMAC_CTRL_2_LCHKL_SIZE, parm->bLongFrmChkDis);
+
+		switch (parm->eShortFrmChkType) {
+		case GSW_PMAC_SHORT_LEN_DIS:
+			pmac_ctrl2 = gsw_field_w32(pmac_ctrl2, PMAC_CTRL_2_LCHKS_SHIFT,
+						   PMAC_CTRL_2_LCHKS_SIZE, 0);
+			break;
+
+		case GSW_PMAC_SHORT_LEN_ENA_UNTAG:
+			pmac_ctrl2 = gsw_field_w32(pmac_ctrl2, PMAC_CTRL_2_LCHKS_SHIFT,
+						   PMAC_CTRL_2_LCHKS_SIZE, 1);
+			break;
+
+		case GSW_PMAC_SHORT_LEN_ENA_TAG:
+			pmac_ctrl2 = gsw_field_w32(pmac_ctrl2, PMAC_CTRL_2_LCHKS_SHIFT,
+						   PMAC_CTRL_2_LCHKS_SIZE, 2);
+			break;
+
+		case GSW_PMAC_SHORT_LEN_RESERVED:
+			pmac_ctrl2 = gsw_field_w32(pmac_ctrl2, PMAC_CTRL_2_LCHKS_SHIFT,
+						   PMAC_CTRL_2_LCHKS_SIZE, 3);
+			break;
+		}
+
+		if (IS_VRSN_31(gswdev->gipver)) {
+			switch (parm->eProcFlagsEgCfg) {
+			case GSW_PMAC_PROC_FLAGS_NONE:
+				break;
+
+			case GSW_PMAC_PROC_FLAGS_TC:
+				pmac_ctrl4 = gsw_field_w32(pmac_ctrl4, PMAC_CTRL_4_FLAGEN_SHIFT,
+							   PMAC_CTRL_4_GSWIP3_1_FLAGEN_SIZE, 0);
+				break;
+
+			case GSW_PMAC_PROC_FLAGS_FLAG:
+				pmac_ctrl4 = gsw_field_w32(pmac_ctrl4, PMAC_CTRL_4_FLAGEN_SHIFT,
+							   PMAC_CTRL_4_GSWIP3_1_FLAGEN_SIZE, 1);
+				break;
+
+			case GSW_PMAC_PROC_FLAGS_MIX:
+				pmac_ctrl4 = gsw_field_w32(pmac_ctrl4, PMAC_CTRL_4_FLAGEN_SHIFT,
+							   PMAC_CTRL_4_GSWIP3_1_FLAGEN_SIZE, 2);
+				break;
+			}
+
+			if (parm->nBslThreshold[0]) {
+				gsw_w32(cdev, pmac_bsl1_off,
+					PMAC_BSL_LEN0_SHIFT,
+					PMAC_BSL_LEN0_SIZE,
+					parm->nBslThreshold[0]);
+			}
+
+			if (parm->nBslThreshold[1]) {
+				gsw_w32(cdev, pmac_bsl2_off,
+					PMAC_BSL_LEN1_SHIFT,
+					PMAC_BSL_LEN1_SIZE,
+					parm->nBslThreshold[1]);
+			}
+
+			if (parm->nBslThreshold[2]) {
+				gsw_w32(cdev, pmac_bsl3_off,
+					PMAC_BSL_LEN2_SHIFT,
+					PMAC_BSL_LEN2_SIZE,
+					parm->nBslThreshold[2]);
+			}
+		}
+
+		gsw_w32_raw(cdev, pmac_ctrl0_off, pmac_ctrl0);
+
+		if (IS_VRSN_31(gswdev->gipver))
+			gsw_w32_raw(cdev, pmac_ctrl1_off, pmac_ctrl1);
+
+		gsw_w32_raw(cdev, pmac_ctrl2_off, pmac_ctrl2);
+		gsw_w32_raw(cdev, pmac_ctrl3_off, pmac_ctrl3);
+		gsw_w32_raw(cdev, pmac_ctrl4_off, pmac_ctrl4);
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pmac);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_PMAC_GLBL_CfgGet(void *cdev, GSW_PMAC_Glbl_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 regval;
+	u32 pmac_ctrl0, pmac_ctrl1, pmac_ctrl2, pmac_ctrl3, pmac_ctrl4;
+	u32 pmac_ctrl0_off,
+	    pmac_ctrl1_off,
+	    pmac_ctrl2_off,
+	    pmac_ctrl3_off,
+	    pmac_ctrl4_off,
+	    pmac_bsl1_off,
+	    pmac_bsl2_off,
+	    pmac_bsl3_off;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pmac);
+#endif
+
+	pmac_ctrl0_off = pmac_addr_off(PMAC_CTRL_0_PADEN_OFFSET, parm->nPmacId);
+	pmac_ctrl1_off = pmac_addr_off(PMAC_CTRL_1_MLEN_OFFSET, parm->nPmacId);
+	pmac_ctrl2_off = pmac_addr_off(PMAC_CTRL_2_LCHKL_OFFSET, parm->nPmacId);
+	pmac_ctrl3_off = pmac_addr_off(PMAC_CTRL_3_JUMBO_OFFSET, parm->nPmacId);
+	pmac_ctrl4_off = pmac_addr_off(PMAC_CTRL_4_FLAGEN_OFFSET, parm->nPmacId);
+
+	pmac_bsl1_off = pmac_addr_off(PMAC_BSL_LEN0_OFFSET, parm->nPmacId);
+	pmac_bsl2_off = pmac_addr_off(PMAC_BSL_LEN1_OFFSET, parm->nPmacId);
+	pmac_bsl3_off = pmac_addr_off(PMAC_BSL_LEN2_OFFSET, parm->nPmacId);
+
+
+	gsw_r32_raw(cdev, pmac_ctrl0_off, &pmac_ctrl0);
+
+	if (IS_VRSN_31(gswdev->gipver))
+		gsw_r32_raw(cdev, pmac_ctrl1_off, &pmac_ctrl1);
+
+	gsw_r32_raw(cdev, pmac_ctrl2_off, &pmac_ctrl2);
+	gsw_r32_raw(cdev, pmac_ctrl3_off, &pmac_ctrl3);
+	gsw_r32_raw(cdev, pmac_ctrl4_off, &pmac_ctrl4);
+
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+
+		parm->bAPadEna = gsw_field_r32(pmac_ctrl0, PMAC_CTRL_0_APADEN_SHIFT,
+					       PMAC_CTRL_0_APADEN_SIZE);
+		parm->bPadEna = gsw_field_r32(pmac_ctrl0, PMAC_CTRL_0_PADEN_SHIFT,
+					      PMAC_CTRL_0_PADEN_SIZE);
+		parm->bVPadEna = gsw_field_r32(pmac_ctrl0, PMAC_CTRL_0_VPADEN_SHIFT,
+					       PMAC_CTRL_0_VPADEN_SIZE);
+		parm->bSVPadEna = gsw_field_r32(pmac_ctrl0, PMAC_CTRL_0_VPAD2EN_SHIFT,
+						PMAC_CTRL_0_VPAD2EN_SIZE);
+		parm->bTxFCSDis = gsw_field_r32(pmac_ctrl0, PMAC_CTRL_0_FCS_SHIFT,
+						PMAC_CTRL_0_FCS_SIZE);
+
+		if (IS_VRSN_31(gswdev->gipver)) {
+			parm->bRxFCSDis = gsw_field_r32(pmac_ctrl0, PMAC_CTRL_0_FCSEN_SHIFT,
+							PMAC_CTRL_0_FCSEN_SIZE);
+		}
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			parm->bIPTransChkRegDis = gsw_field_r32(pmac_ctrl0, PMAC_CTRL_0_CHKREG_SHIFT,
+								PMAC_CTRL_0_CHKREG_SIZE);
+			parm->bIPTransChkVerDis = gsw_field_r32(pmac_ctrl0, PMAC_CTRL_0_CHKVER_SHIFT,
+								PMAC_CTRL_0_CHKVER_SIZE);
+			parm->bProcFlagsEgCfgEna = gsw_field_r32(pmac_ctrl4, PMAC_CTRL_4_FLAGEN_SHIFT,
+						   PMAC_CTRL_4_FLAGEN_SIZE);
+			regval = gsw_field_r32(pmac_ctrl3, PMAC_CTRL_3_JUMBO_SHIFT,
+					       PMAC_CTRL_3_JUMBO_SIZE);
+			parm->nMaxJumboLen = regval;
+		}
+
+		parm->bJumboEna = gsw_field_r32(pmac_ctrl2, PMAC_CTRL_2_MLEN_SHIFT,
+						PMAC_CTRL_2_MLEN_SIZE);
+		parm->bLongFrmChkDis = gsw_field_r32(pmac_ctrl2, PMAC_CTRL_2_LCHKL_SHIFT,
+						     PMAC_CTRL_2_LCHKL_SIZE);
+		regval = gsw_field_r32(pmac_ctrl2, PMAC_CTRL_2_LCHKS_SHIFT,
+				       PMAC_CTRL_2_LCHKS_SIZE);
+		parm->eShortFrmChkType = regval;
+
+
+		if (IS_VRSN_31(gswdev->gipver)) {
+			gsw_r32_raw(cdev, pmac_ctrl1_off, &regval);
+
+			parm->nMaxJumboLen = regval;
+
+			parm->eProcFlagsEgCfg = gsw_field_r32(pmac_ctrl4,
+							      PMAC_CTRL_4_FLAGEN_SHIFT,
+							      PMAC_CTRL_4_GSWIP3_1_FLAGEN_SIZE);
+
+			gsw_r32(cdev,
+				pmac_bsl1_off,
+				PMAC_BSL_LEN0_SHIFT,
+				PMAC_BSL_LEN0_SIZE,
+				&parm->nBslThreshold[0]);
+
+			gsw_r32(cdev,
+				pmac_bsl2_off,
+				PMAC_BSL_LEN1_SHIFT,
+				PMAC_BSL_LEN1_SIZE,
+				&parm->nBslThreshold[1]);
+
+			gsw_r32(cdev,
+				pmac_bsl3_off,
+				PMAC_BSL_LEN2_SHIFT,
+				PMAC_BSL_LEN2_SIZE,
+				&parm->nBslThreshold[2]);
+		}
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pmac);
+#endif
+	return ret;
+}
+
+
+/* Back pressure mapping Table */
+int GSW_PMAC_BM_CfgSet(void *cdev, GSW_PMAC_BM_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pmtbl_prog_t pmtbl;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pmac);
+#endif
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+
+		memset(&pmtbl, 0, sizeof(pmtbl));
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0)
+			pmtbl.ptaddr = (parm->nTxDmaChanId & 0x0F);
+
+		if (IS_VRSN_31(gswdev->gipver))
+			pmtbl.ptaddr = (parm->nTxDmaChanId & 0x1F);
+
+		pmtbl.pmacId = parm->nPmacId;
+
+		/* RX Port Congestion Mask (bit 15:0) */
+		pmtbl.val[0] = (parm->rxPortMask & 0xFFFF);
+		/* TX Queue Congestion Mask (bit 15:0) */
+		pmtbl.val[1] = (parm->txQMask & 0xFFFF);
+		/* TX Queue Congestion Mask (bit 31:16)  */
+		pmtbl.val[2] = ((parm->txQMask >> 16) & 0xFFFF);
+		pmtbl.ptcaddr = PMAC_BPMAP_INDEX;
+
+		xwayflow_pmac_table_write(cdev, &pmtbl);
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pmac);
+#endif
+	return ret;
+
+}
+
+int GSW_PMAC_BM_CfgGet(void *cdev, GSW_PMAC_BM_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pmtbl_prog_t pmtbl;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pmac);
+#endif
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+		memset(&pmtbl, 0, sizeof(pmtbl));
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0)
+			pmtbl.ptaddr = (parm->nTxDmaChanId & 0x0F);
+
+		if (IS_VRSN_31(gswdev->gipver))
+			pmtbl.ptaddr = (parm->nTxDmaChanId & 0x1F);
+
+		pmtbl.pmacId = parm->nPmacId;
+
+		pmtbl.ptcaddr	= PMAC_BPMAP_INDEX;
+		xwayflow_pmac_table_read(cdev, &pmtbl);
+
+		/* RX Port Congestion Mask (bit 15:0) */
+		parm->rxPortMask = (pmtbl.val[0]);
+		/* TX Queue Congestion Mask (bit 15:0) */
+		parm->txQMask = (pmtbl.val[1]);
+		/* TX Queue Congestion Mask (bit 31:16)  */
+		parm->txQMask |= (pmtbl.val[2]) << 16;
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pmac);
+#endif
+	return ret;
+}
+
+int GSW_PMAC_IG_CfgSet(void *cdev, GSW_PMAC_Ig_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pmtbl_prog_t pmtbl;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pmac);
+#endif
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+		memset(&pmtbl, 0, sizeof(pmtbl));
+
+		pmtbl.pmacId = parm->nPmacId;
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0)
+			pmtbl.ptaddr = (parm->nTxDmaChanId & 0x0F);
+
+		if (IS_VRSN_31(gswdev->gipver))
+			pmtbl.ptaddr = (parm->nTxDmaChanId & 0x1F);
+
+		/* Default PMAC Header Bytes */
+		pmtbl.val[0] = (((parm->defPmacHdr[0] & 0xFF) << 8)
+				| (parm->defPmacHdr[1] & 0xFF));
+		pmtbl.val[1] = (((parm->defPmacHdr[2] & 0xFF) << 8)
+				| (parm->defPmacHdr[3] & 0xFF));
+		pmtbl.val[2] = (((parm->defPmacHdr[4] & 0xFF) << 8)
+				| (parm->defPmacHdr[5] & 0xFF));
+		pmtbl.val[3] = (((parm->defPmacHdr[6] & 0xFF) << 8)
+				| (parm->defPmacHdr[7] & 0xFF));
+
+		/* Packet has PMAC header or not */
+		if (parm->bPmacPresent)
+			pmtbl.val[4] |= (1 << 0);
+
+		/* Source Port Id from default PMAC header */
+		if (parm->bSpIdDefault)
+			pmtbl.val[4] |= (1 << 1);
+		else {
+			/*GSWIP 3.1: SPPID from packet descriptor*/
+			pmtbl.val[4] &= ~(1 << 1);
+		}
+
+		/* Sub_Interface Id  Info from default PMAC header  */
+		switch (parm->eSubId) {
+		case GSW_PMAC_IG_CFG_SRC_DMA_DESC:
+			pmtbl.val[4] &= ~(1 << 2);
+			break;
+
+		case GSW_PMAC_IG_CFG_SRC_PMAC:
+		case GSW_PMAC_IG_CFG_SRC_DEF_PMAC:
+			pmtbl.val[4] |= (1 << 2);
+			break;
+
+		default:
+			break;
+		}
+
+		/* Class Enable info from default PMAC header  */
+		if (parm->bClassEna)
+			pmtbl.val[4] |= (1 << 3);
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			/* Port Map Enable info from default PMAC header */
+			if (parm->bPmapEna)
+				pmtbl.val[4] |= (1 << 4);
+
+			/* Port Map info from default PMAC header  */
+			if (parm->bPmapDefault)
+				pmtbl.val[4] |= (1 << 6);
+		}
+
+		/* Class Info from default PMAC header */
+		if (parm->bClassDefault)
+			pmtbl.val[4] |= (1 << 5);
+
+
+		/* Error set packets to be discarded  */
+		if (parm->bErrPktsDisc)
+			pmtbl.val[4] |= (1 << 7);
+
+		pmtbl.ptcaddr	= PMAC_IGCFG_INDEX;
+		xwayflow_pmac_table_write(cdev, &pmtbl);
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pmac);
+#endif
+	return ret;
+
+}
+
+
+int GSW_PMAC_IG_CfgGet(void *cdev, GSW_PMAC_Ig_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pmtbl_prog_t pmtbl;
+	u32 SubidMode;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pmac);
+#endif
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+		memset(&pmtbl, 0, sizeof(pmtbl));
+
+		pmtbl.pmacId = parm->nPmacId;
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0)
+			pmtbl.ptaddr = (parm->nTxDmaChanId & 0x0F);
+
+		if (IS_VRSN_31(gswdev->gipver))
+			pmtbl.ptaddr = (parm->nTxDmaChanId & 0x1F);
+
+		pmtbl.ptcaddr	= PMAC_IGCFG_INDEX;
+		xwayflow_pmac_table_read(cdev, &pmtbl);
+
+		/* Default PMAC Header Bytes */
+		parm->defPmacHdr[0] = ((pmtbl.val[0] >> 8) & 0xFF);
+		parm->defPmacHdr[1] = (pmtbl.val[0] & 0xFF);
+		parm->defPmacHdr[2] = ((pmtbl.val[1] >> 8) & 0xFF);
+		parm->defPmacHdr[3] = (pmtbl.val[1] & 0xFF);
+		parm->defPmacHdr[4] = ((pmtbl.val[2] >> 8) & 0xFF);
+		parm->defPmacHdr[5] = (pmtbl.val[2] & 0xFF);
+		parm->defPmacHdr[6] = ((pmtbl.val[3] >> 8) & 0xFF);
+		parm->defPmacHdr[7] = (pmtbl.val[3] & 0xFF);
+
+		/* Packet has PMAC header or not */
+		if ((pmtbl.val[4] >> 0) & 0x1)
+			parm->bPmacPresent = 1;
+
+		/* Source Port Id from default PMAC header */
+		if ((pmtbl.val[4] >> 1) & 0x1)
+			parm->bSpIdDefault = 1;
+
+		/* Sub_Interface Id  Info */
+		SubidMode = ((pmtbl.val[4] >> 2) & 0x1);
+
+		if (SubidMode == 0) {
+			parm->eSubId = GSW_PMAC_IG_CFG_SRC_DMA_DESC;
+		} else {
+			if (IS_VRSN_31(gswdev->gipver)) {
+				parm->eSubId = GSW_PMAC_IG_CFG_SRC_DEF_PMAC;
+			} else {
+				parm->eSubId = GSW_PMAC_IG_CFG_SRC_PMAC;
+			}
+		}
+
+		/* Class Enable info from default PMAC header  */
+		if ((pmtbl.val[4] >> 3) & 0x1)
+			parm->bClassEna = 1;
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			/* Port Map Enable info from default PMAC header */
+			if ((pmtbl.val[4] >> 4) & 0x1)
+				parm->bPmapEna = 1;
+
+			/* Port Map info from default PMAC header  */
+			if ((pmtbl.val[4] >> 6) & 0x1)
+				parm->bPmapDefault = 1;
+		}
+
+		/* Class Info from default PMAC header */
+		if ((pmtbl.val[4] >> 5) & 0x1)
+			parm->bClassDefault = 1;
+
+		/* Error set packets to be discarded  */
+		if ((pmtbl.val[4] >> 7) & 0x1)
+			parm->bErrPktsDisc = 1;
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pmac);
+#endif
+	return ret;
+}
+
+int GSW_PMAC_EG_CfgSet(void *cdev, GSW_PMAC_Eg_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pmtbl_prog_t pmtbl;
+	u32 regval, pmac_ctrl4_off;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pmac);
+#endif
+
+	pmac_ctrl4_off = pmac_addr_off(PMAC_CTRL_4_FLAGEN_OFFSET, parm->nPmacId);
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+		memset(&pmtbl, 0, sizeof(pmtbl));
+
+		pmtbl.pmacId = parm->nPmacId;
+
+		pmtbl.ptaddr = parm->nDestPortId & 0x0F;
+		pmtbl.ptaddr |= (parm->nFlowIDMsb & 0x03) << 8;
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			gsw_r32(cdev, pmac_ctrl4_off,
+				PMAC_CTRL_4_FLAGEN_SHIFT,
+				PMAC_CTRL_4_FLAGEN_SIZE,
+				&regval);
+		}
+
+		if (IS_VRSN_31(gswdev->gipver)) {
+			gsw_r32(cdev, pmac_ctrl4_off,
+				PMAC_CTRL_4_FLAGEN_SHIFT,
+				PMAC_CTRL_4_GSWIP3_1_FLAGEN_SIZE,
+				&regval);
+		}
+
+		/*if (parm->bTCEnable == 1) { */
+
+		if ((parm->bProcFlagsSelect == 0) && (regval == 0)) {
+			/*regval 00 tc use traffic class as part of the adress
+			  (bit 7 to bit 4)*/
+
+			pmtbl.ptaddr |= (parm->nTrafficClass & 0x0F) << 4;
+		} else if ((parm->bProcFlagsSelect == 1) && (regval == 1)) {
+			/* regval 01 Flag use processing flags as part of the address
+			   (bit 7 to bit 4)*/
+
+			/* MPE-1 Marked Flag  */
+			if (parm->bMpe1Flag)
+				pmtbl.ptaddr |= (1 << 4);
+
+			/* MPE-2 Marked Flag  */
+			if (parm->bMpe2Flag)
+				pmtbl.ptaddr |= (1 << 5);
+
+			/* Cryptography Encryption Action Flag  */
+			if (parm->bEncFlag)
+				pmtbl.ptaddr |= (1 << 6);
+
+			/* Cryptography Decryption Action Flag  */
+			if (parm->bDecFlag)
+				pmtbl.ptaddr |= (1 << 7);
+		} else if ((parm->bProcFlagsSelect == 1) && (regval == 2) &&
+			   (IS_VRSN_31(gswdev->gipver))) {
+			/*regval 10 Mixed use MPE flags as part of the address (bit 5 to 4)
+			  and reduced traffic class as part of the address
+			  (bit 7 to bit 6)*/
+
+			pmtbl.ptaddr |= (parm->nTrafficClass & 0x3) << 6;
+
+			/* MPE-1 Marked Flag  */
+			if (parm->bMpe1Flag)
+				pmtbl.ptaddr |= (1 << 4);
+
+			/* MPE-2 Marked Flag  */
+			if (parm->bMpe2Flag)
+				pmtbl.ptaddr |= (1 << 5);
+		} else {
+			ret = GSW_statusNoSupport;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			/*nRes2DW0 -- DW0 (bit 14 to 13),*/
+			/*nRes1DW0 -- DW0 (bit 31 to 29), nResDW1 -- DW1 (bit 7 to 4)*/
+			pmtbl.val[0] = ((parm->nRes2DW0 & 0x3) |
+					((parm->nRes1DW0 & 0x3) << 2) |
+					((parm->nResDW1 & 0x0F) << 5));
+		}
+
+		if (IS_VRSN_31(gswdev->gipver)) {
+			/*DES RES DW) Bit 31 (For Redir bit set) BIT 4 of VAL 0*/
+			if (parm->bRedirEnable)
+				pmtbl.val[0] |= (1 << 4);
+
+			/* Redirection bit can be overwritten by nRes1DW0 */
+			if (parm->bRes1DW0Enable) {
+				/*nRes1DW0 -- DW0 (bit 31 to 29)*/
+				pmtbl.val[0] &= ~(0x7 << 2);
+				pmtbl.val[0] |= ((parm->nRes1DW0 & 0x7) << 2);
+			}
+
+			if (parm->bRes2DW0Enable) {
+				/*nRes2DW0 -- DW0 (bit 14 to 13),*/
+				pmtbl.val[0] &= ~(0x3);
+				pmtbl.val[0] |= (parm->nRes2DW0 & 0x3);
+			}
+
+			/*BSL Bit 2 to 0 -- VLA 0 BIT 7:5*/
+			pmtbl.val[0] |= ((parm->nBslTrafficClass & 0x3) << 5);
+			pmtbl.val[0] |= (parm->bBslSegmentDisable << 7);
+		}
+
+		/* Receive DMA Channel Identifier (0..7) */
+		pmtbl.val[1] = (parm->nRxDmaChanId & 0x0F);
+
+		/* Packet has PMAC */
+		if (parm->bPmacEna == 1)
+			pmtbl.val[2] |= (1 << 0);
+
+		/* Packet has FCS */
+		if (parm->bFcsEna == 1)
+			pmtbl.val[2] |= (1 << 1);
+
+		/* To remove L2 header & additional bytes  */
+		if (parm->bRemL2Hdr == 1) {
+			pmtbl.val[2] |= (1 << 2);
+			/* No. of bytes to be removed after Layer-2 Header,*/
+			/*valid when bRemL2Hdr is set  */
+			pmtbl.val[2] |= ((parm->numBytesRem & 0xFF) << 8);
+		}
+
+		pmtbl.ptcaddr	= PMAC_EGCFG_INDEX;
+		xwayflow_pmac_table_write(cdev, &pmtbl);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pmac);
+#endif
+	return ret;
+
+}
+
+int GSW_PMAC_EG_CfgGet(void *cdev, GSW_PMAC_Eg_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pmtbl_prog_t pmtbl;
+	u32 regval, pmac_ctrl4_off;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pmac);
+#endif
+
+	pmac_ctrl4_off = pmac_addr_off(PMAC_CTRL_4_FLAGEN_OFFSET, parm->nPmacId);
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+		memset(&pmtbl, 0, sizeof(pmtbl));
+
+		pmtbl.pmacId = parm->nPmacId;
+
+		pmtbl.ptaddr = parm->nDestPortId & 0x0F;
+		pmtbl.ptaddr |= (parm->nFlowIDMsb & 0x03) << 8;
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			gsw_r32(cdev, pmac_ctrl4_off,
+				PMAC_CTRL_4_FLAGEN_SHIFT,
+				PMAC_CTRL_4_FLAGEN_SIZE,
+				&regval);
+		}
+
+		if (IS_VRSN_31(gswdev->gipver)) {
+			gsw_r32(cdev, pmac_ctrl4_off,
+				PMAC_CTRL_4_FLAGEN_SHIFT,
+				PMAC_CTRL_4_GSWIP3_1_FLAGEN_SIZE,
+				&regval);
+		}
+
+
+		/*		if (parm->bTCEnable == 1) { */
+		if ((parm->bProcFlagsSelect == 0) && (regval == 0)) {
+			pmtbl.ptaddr |= (parm->nTrafficClass & 0x0F) << 4;
+		} else if ((parm->bProcFlagsSelect == 1) && (regval == 1)) {
+			/* MPE-1 Marked Flag  */
+			if (parm->bMpe1Flag)
+				pmtbl.ptaddr |= (1 << 4);
+
+			/* MPE-2 Marked Flag  */
+			if (parm->bMpe2Flag)
+				pmtbl.ptaddr |= (1 << 5);
+
+			/* Cryptography Encryption Action Flag  */
+			if (parm->bEncFlag)
+				pmtbl.ptaddr |= (1 << 6);
+
+			/* Cryptography Decryption Action Flag  */
+			if (parm->bDecFlag)
+				pmtbl.ptaddr |= (1 << 7);
+		} else if ((parm->bProcFlagsSelect == 1) && (regval == 2) &&
+			   (IS_VRSN_31(gswdev->gipver))) {
+			pmtbl.ptaddr |= (parm->nTrafficClass & 0x3) << 6;
+
+			/* MPE-1 Marked Flag  */
+			if (parm->bMpe1Flag)
+				pmtbl.ptaddr |= (1 << 4);
+
+			/* MPE-2 Marked Flag  */
+			if (parm->bMpe2Flag)
+				pmtbl.ptaddr |= (1 << 5);
+		} else {
+			ret = GSW_statusNoSupport;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		pmtbl.ptcaddr	= PMAC_EGCFG_INDEX;
+		xwayflow_pmac_table_read(cdev, &pmtbl);
+
+		/*  nRes2DW0 -- DW0 (bit 14 to 13),*/
+		/*nRes1DW0 -- DW0 (bit 31 to 29), nResDW1 -- DW1 (bit 7 to 4)*/
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			parm->nRes2DW0 = pmtbl.val[0] & 0x3;
+			parm->nRes1DW0 = (pmtbl.val[0] >> 2) & 0x3;
+			parm->nResDW1 = (pmtbl.val[0] >> 5) & 0x0F;
+		}
+
+		if (IS_VRSN_31(gswdev->gipver)) {
+			/*Redir bit set*/
+			parm->nRes2DW0 = pmtbl.val[0] & 0x3;
+			parm->nRes1DW0 = ((pmtbl.val[0] >> 2) & 0x7);
+			parm->bRedirEnable = ((pmtbl.val[0] & 0x10) >> 4);
+
+			parm->nBslTrafficClass = ((pmtbl.val[0] & 0x60) >> 5);
+			parm->bBslSegmentDisable = ((pmtbl.val[0] & 0x80) >> 7);
+		}
+
+		/* Receive DMA Channel Identifier (0..7) */
+		parm->nRxDmaChanId = (pmtbl.val[1] & 0x0F);
+
+		/* Packet has PMAC */
+		if ((pmtbl.val[2] >> 0) & 0x1)
+			parm->bPmacEna = 1;
+
+		/* Packet has FCS */
+		if ((pmtbl.val[2] >> 1) & 0x1)
+			parm->bFcsEna = 1;
+
+		/* To remove L2 header & additional bytes  */
+		if ((pmtbl.val[2] >> 2) & 0x1) {
+			parm->bRemL2Hdr = 1;
+			/* No. of bytes to be removed after Layer-2 Header */
+			/* valid when bRemL2Hdr is set  */
+			parm->numBytesRem = ((pmtbl.val[2] >> 8) & 0xFF);
+		}
+	}
+
+	ret  = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pmac);
+#endif
+	return ret;
+}
+
+#if defined(CONFIG_LTQ_8021X) && CONFIG_LTQ_8021X
+GSW_return_t GSW_8021X_EAPOL_RuleGet(void *cdev, GSW_8021X_EAPOL_Rule_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	stp8021x_t *scfg = &gswdev->stpconfig;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+	parm->eForwardPort = scfg->sfport;
+	parm->nForwardPortId = scfg->fpid8021x;
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_8021X_EAPOL_RuleSet(void *cdev, GSW_8021X_EAPOL_Rule_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	stp8021x_t *scfg = &gswdev->stpconfig;
+	static GSW_PCE_rule_t pcrule;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	scfg->sfport = parm->eForwardPort;
+	scfg->fpid8021x = parm->nForwardPortId;
+	memset(&pcrule, 0, sizeof(GSW_PCE_rule_t));
+	pcrule.pattern.nIndex = EAPOL_PCE_RULE_INDEX;
+	pcrule.pattern.bEnable = 1;
+	pcrule.pattern.bMAC_DstEnable	= 1;
+	pcrule.pattern.nMAC_Dst[0] = 0x01;
+	pcrule.pattern.nMAC_Dst[1] = 0x80;
+	pcrule.pattern.nMAC_Dst[2] = 0xC2;
+	pcrule.pattern.nMAC_Dst[3] = 0x00;
+	pcrule.pattern.nMAC_Dst[4] = 0x00;
+	pcrule.pattern.nMAC_Dst[5] = 0x03;
+	pcrule.pattern.nMAC_Src[5] = 0;
+	pcrule.pattern.bEtherTypeEnable	= 1;
+	pcrule.pattern.nEtherType	= 0x888E;
+	pcrule.action.eCrossStateAction = GSW_PCE_ACTION_CROSS_STATE_CROSS;
+
+	if ((scfg->sfport < 4) && (scfg->sfport > 0))
+		pcrule.action.ePortMapAction = scfg->sfport + 1;
+	else
+		pr_err("(Incorrect forward port action) %s:%s:%d\n",
+		       __FILE__, __func__, __LINE__);
+
+	/*TODO*/
+	//Govind - Can occur out of array bounds problem.
+	pcrule.action.nForwardPortMap[0] = (1 << parm->nForwardPortId);
+
+	/* We prepare everything and write into PCE Table */
+	if (0 != pce_rule_write(cdev, &gswdev->phandler, &pcrule)) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_8021X_PortCfgGet(void *cdev, GSW_8021X_portCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+	port_config_t *pcfg;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return  GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (parm->nPortId >= gswdev->tpnum) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		pcfg = &gswdev->pconfig[parm->nPortId];
+		parm->eState = pcfg->p8021xs;
+	}
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if (parm->nPortId >= gswdev->num_of_bridge_port) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/*If Bridge Port ID is valid,Check whether it is InUSE
+		  if not InUse,return ERROR*/
+		if (!(gswdev->brdgeportconfig_idx[parm->nPortId].IndexInUse)) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		parm->eState = gswdev->brdgeportconfig_idx[parm->nPortId].P8021xState;
+	}
+
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+
+}
+
+GSW_return_t GSW_8021X_PortCfgSet(void *cdev, GSW_8021X_portCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 StpState, P8021xState;
+	u32 ret;
+
+	port_config_t *pcfg;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (parm->nPortId >= gswdev->tpnum) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		pcfg = &gswdev->pconfig[parm->nPortId];
+		pcfg->p8021xs	= parm->eState;
+		set_port_state(cdev, parm->nPortId, pcfg->pcstate,
+			       pcfg->p8021xs);
+	}
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if (parm->nPortId >= gswdev->num_of_bridge_port) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/*If Bridge Port ID is valid,Check whether it is InUSE
+		  if not InUse,return ERROR*/
+		if (!(gswdev->brdgeportconfig_idx[parm->nPortId].IndexInUse)) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		P8021xState = parm->eState;
+		StpState = gswdev->brdgeportconfig_idx[parm->nPortId].StpState;
+		gswdev->brdgeportconfig_idx[parm->nPortId].P8021xState = P8021xState;
+
+		/* Config the Table */
+		set_port_state(cdev, parm->nPortId, StpState, P8021xState);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+#endif /*CONFIG_LTQ_8021X  */
+GSW_return_t GSW_CPU_PortCfgGet(void *cdev, GSW_CPU_PortCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 pidx = parm->nPortId;
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if (pidx ==  gswdev->cport)
+		parm->bCPU_PortValid = 1;
+	else
+		parm->bCPU_PortValid = 0;
+
+	/* Special Tag Egress*/
+	gsw_r32(cdev, (FDMA_PCTRL_STEN_OFFSET + (0x6 * pidx)),
+		FDMA_PCTRL_STEN_SHIFT, FDMA_PCTRL_STEN_SIZE, &value);
+	parm->bSpecialTagEgress = value;
+	/* Special Tag Igress*/
+	gsw_r32(cdev, (PCE_PCTRL_0_IGSTEN_OFFSET + (0xa * pidx)),
+		PCE_PCTRL_0_IGSTEN_SHIFT, PCE_PCTRL_0_IGSTEN_SIZE, &value);
+	parm->bSpecialTagIngress = value;
+	/* FCS Check */
+	gsw_r32(cdev, (SDMA_PCTRL_FCSIGN_OFFSET + (0x6 * pidx)),
+		SDMA_PCTRL_FCSIGN_SHIFT,
+		SDMA_PCTRL_FCSIGN_SIZE, &value);
+	parm->bFcsCheck = value;
+
+	/* FCS Generate */
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			if (pidx != 0) {
+				gsw_r32(cdev, (MAC_CTRL_0_FCS_OFFSET + (0xC * (pidx - 1))),
+					MAC_CTRL_0_FCS_SHIFT, MAC_CTRL_0_FCS_SIZE, &value);
+				parm->bFcsGenerate = value;
+			}
+		}
+
+		if (IS_VRSN_31(gswdev->gipver)) {
+			if ((1 < pidx) && (pidx < 5)) {
+#if defined(CONFIG_MAC) && CONFIG_MAC
+				/* MAC API's to set FCS Generation */
+				struct mac_ops *ops = get_mac_ops(gswdev, pidx);
+
+				if (!ops) {
+					pr_err("MAC %d is not initialized\n", pidx);
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+
+				parm->bFcsGenerate = ops->get_fcsgen(ops);
+#endif
+			}
+		}
+
+		gsw_r32(cdev, FDMA_PASR_CPU_OFFSET,	FDMA_PASR_CPU_SHIFT,
+			FDMA_PASR_CPU_SIZE, &value);
+		parm->eNoMPEParserCfg = value;
+		gsw_r32(cdev, FDMA_PASR_MPE1_OFFSET,	FDMA_PASR_MPE1_SHIFT,
+			FDMA_PASR_MPE1_SIZE, &value);
+		parm->eMPE1ParserCfg = value;
+		gsw_r32(cdev, FDMA_PASR_MPE2_OFFSET,	FDMA_PASR_MPE2_SHIFT,
+			FDMA_PASR_MPE2_SIZE, &value);
+		parm->eMPE2ParserCfg = value;
+		gsw_r32(cdev, FDMA_PASR_MPE3_OFFSET,	FDMA_PASR_MPE3_SHIFT,
+			FDMA_PASR_MPE3_SIZE, &value);
+		parm->eMPE1MPE2ParserCfg = value;
+	} else {
+		gsw_r32(cdev, (MAC_CTRL_0_FCS_OFFSET + (0xC * pidx)),
+			MAC_CTRL_0_FCS_SHIFT, MAC_CTRL_0_FCS_SIZE, &value);
+		parm->bFcsGenerate = value;
+	}
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		gsw_r32(cdev, (FDMA_PCTRL_ST_TYPE_OFFSET + (0x6 * pidx)),
+			FDMA_PCTRL_ST_TYPE_SHIFT, FDMA_PCTRL_ST_TYPE_SIZE, &value);
+	}
+
+	parm->bSpecialTagEthType = value;
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+
+}
+
+GSW_return_t GSW_CPU_PortCfgSet(void *cdev, GSW_CPU_PortCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 pidx = parm->nPortId;
+	u32 RST, AS, AST, RXSH;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if (pidx == gswdev->cport)
+		parm->bCPU_PortValid = 1;
+	else
+		parm->bCPU_PortValid = 0;
+
+	gswdev->mpnum = pidx;
+	/* Special Tag Egress*/
+	gsw_w32(cdev, (FDMA_PCTRL_STEN_OFFSET + (0x6 * pidx)),
+		FDMA_PCTRL_STEN_SHIFT,
+		FDMA_PCTRL_STEN_SIZE, parm->bSpecialTagEgress);
+
+	/* xRX CPU port */
+	if ((pidx == gswdev->cport) && !(gswdev->gipver == LTQ_GSWIP_3_0)) {
+		if (parm->bSpecialTagEgress == 0) {
+			RST = 1;
+			AS = 0;
+		} else {
+			RST = 0;
+			AS = 1;
+		}
+
+		gsw_w32(cdev, (PMAC_HD_CTL_RST_OFFSET + GSW_TREG_OFFSET),
+			PMAC_HD_CTL_RST_SHIFT, PMAC_HD_CTL_RST_SIZE, RST);
+		gsw_w32(cdev, (PMAC_HD_CTL_AS_OFFSET + GSW_TREG_OFFSET),
+			PMAC_HD_CTL_AS_SHIFT, PMAC_HD_CTL_AS_SIZE, AS);
+	}
+
+	/* Special Tag Igress*/
+	gsw_w32(cdev, (PCE_PCTRL_0_IGSTEN_OFFSET + (0xa * pidx)),
+		PCE_PCTRL_0_IGSTEN_SHIFT,
+		PCE_PCTRL_0_IGSTEN_SIZE, parm->bSpecialTagIngress);
+
+	if ((pidx == gswdev->cport) && !(gswdev->gipver == LTQ_GSWIP_3_0)) {
+		if (parm->bSpecialTagIngress == 0) {
+			AST = 0;
+			RXSH = 0;
+		} else {
+			AST = 1;
+			RXSH = 1;
+		}
+
+		gsw_w32(cdev, (PMAC_HD_CTL_AST_OFFSET + GSW_TREG_OFFSET),
+			PMAC_HD_CTL_AST_SHIFT, PMAC_HD_CTL_AST_SIZE, AST);
+		gsw_w32(cdev, (PMAC_HD_CTL_RXSH_OFFSET + GSW_TREG_OFFSET),
+			PMAC_HD_CTL_RXSH_SHIFT, PMAC_HD_CTL_RXSH_SIZE, RXSH);
+		/* FCS Generate */
+		gsw_w32(cdev, (MAC_CTRL_0_FCS_OFFSET + (0xC * pidx)),
+			MAC_CTRL_0_FCS_SHIFT, MAC_CTRL_0_FCS_SIZE, parm->bFcsGenerate);
+	}
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+		/* FCS Generate */
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			if (pidx != 0) {
+				gsw_w32(cdev, (MAC_CTRL_0_FCS_OFFSET + (0xC * (pidx - 1))),
+					MAC_CTRL_0_FCS_SHIFT, MAC_CTRL_0_FCS_SIZE, parm->bFcsGenerate);
+			}
+		}
+
+		if (IS_VRSN_31(gswdev->gipver)) {
+			if ((1 < pidx) && (pidx < 5)) {
+#if defined(CONFIG_MAC) && CONFIG_MAC
+				/* MAC API's to set FCS Generation */
+				struct mac_ops *ops = get_mac_ops(gswdev, pidx);
+
+				if (!ops) {
+					pr_err("MAC %d is not initialized\n", pidx);
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+
+				ops->set_fcsgen(ops, 1);
+#endif
+			}
+		}
+
+		switch (parm->eNoMPEParserCfg) {
+		case GSW_CPU_PARSER_NIL:
+			gsw_w32(cdev, FDMA_PASR_CPU_OFFSET,	FDMA_PASR_CPU_SHIFT,
+				FDMA_PASR_CPU_SIZE, 0);
+			break;
+
+		case GSW_CPU_PARSER_FLAGS:
+			gsw_w32(cdev, FDMA_PASR_CPU_OFFSET,	FDMA_PASR_CPU_SHIFT,
+				FDMA_PASR_CPU_SIZE, 1);
+			break;
+
+		case GSW_CPU_PARSER_OFFSETS_FLAGS:
+			gsw_w32(cdev, FDMA_PASR_CPU_OFFSET,	FDMA_PASR_CPU_SHIFT,
+				FDMA_PASR_CPU_SIZE, 2);
+			break;
+
+		case GSW_CPU_PARSER_RESERVED:
+			gsw_w32(cdev, FDMA_PASR_CPU_OFFSET,	FDMA_PASR_CPU_SHIFT,
+				FDMA_PASR_CPU_SIZE, 3);
+			break;
+		}
+
+		switch (parm->eMPE1ParserCfg) {
+		case GSW_CPU_PARSER_NIL:
+			gsw_w32(cdev, FDMA_PASR_MPE1_OFFSET,	FDMA_PASR_MPE1_SHIFT,
+				FDMA_PASR_MPE1_SIZE, 0);
+			break;
+
+		case GSW_CPU_PARSER_FLAGS:
+			gsw_w32(cdev, FDMA_PASR_MPE1_OFFSET,	FDMA_PASR_MPE1_SHIFT,
+				FDMA_PASR_MPE1_SIZE, 1);
+			break;
+
+		case GSW_CPU_PARSER_OFFSETS_FLAGS:
+			gsw_w32(cdev, FDMA_PASR_MPE1_OFFSET,	FDMA_PASR_MPE1_SHIFT,
+				FDMA_PASR_MPE1_SIZE, 2);
+			break;
+
+		case GSW_CPU_PARSER_RESERVED:
+			gsw_w32(cdev, FDMA_PASR_MPE1_OFFSET,	FDMA_PASR_MPE1_SHIFT,
+				FDMA_PASR_MPE1_SIZE, 3);
+			break;
+		}
+
+		switch (parm->eMPE2ParserCfg) {
+		case GSW_CPU_PARSER_NIL:
+			gsw_w32(cdev, FDMA_PASR_MPE2_OFFSET,	FDMA_PASR_MPE2_SHIFT,
+				FDMA_PASR_MPE2_SIZE, 0);
+			break;
+
+		case GSW_CPU_PARSER_FLAGS:
+			gsw_w32(cdev, FDMA_PASR_MPE2_OFFSET,	FDMA_PASR_MPE2_SHIFT,
+				FDMA_PASR_MPE2_SIZE, 1);
+			break;
+
+		case GSW_CPU_PARSER_OFFSETS_FLAGS:
+			gsw_w32(cdev, FDMA_PASR_MPE2_OFFSET,	FDMA_PASR_MPE2_SHIFT,
+				FDMA_PASR_MPE2_SIZE, 2);
+			break;
+
+		case GSW_CPU_PARSER_RESERVED:
+			gsw_w32(cdev, FDMA_PASR_MPE2_OFFSET,	FDMA_PASR_MPE2_SHIFT,
+				FDMA_PASR_MPE2_SIZE, 3);
+			break;
+		}
+
+		switch (parm->eMPE1MPE2ParserCfg) {
+		case GSW_CPU_PARSER_NIL:
+			gsw_w32(cdev, FDMA_PASR_MPE3_OFFSET,	FDMA_PASR_MPE3_SHIFT,
+				FDMA_PASR_MPE3_SIZE, 0);
+			break;
+
+		case GSW_CPU_PARSER_FLAGS:
+			gsw_w32(cdev, FDMA_PASR_MPE3_OFFSET,	FDMA_PASR_MPE3_SHIFT,
+				FDMA_PASR_MPE3_SIZE, 1);
+			break;
+
+		case GSW_CPU_PARSER_OFFSETS_FLAGS:
+			gsw_w32(cdev, FDMA_PASR_MPE3_OFFSET,	FDMA_PASR_MPE3_SHIFT,
+				FDMA_PASR_MPE3_SIZE, 2);
+			break;
+
+		case GSW_CPU_PARSER_RESERVED:
+			gsw_w32(cdev, FDMA_PASR_MPE3_OFFSET,	FDMA_PASR_MPE3_SHIFT,
+				FDMA_PASR_MPE3_SIZE, 3);
+			break;
+		}
+	}
+
+	/* FCS Check */
+	gsw_w32(cdev, (SDMA_PCTRL_FCSIGN_OFFSET + (0x6 * pidx)),
+		SDMA_PCTRL_FCSIGN_SHIFT,
+		SDMA_PCTRL_FCSIGN_SIZE, parm->bFcsCheck);
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (parm->bSpecialTagEthType == GSW_CPU_ETHTYPE_FLOWID) {
+			gsw_w32(cdev, (FDMA_PCTRL_ST_TYPE_OFFSET + (0x6 * pidx)),
+				FDMA_PCTRL_ST_TYPE_SHIFT, FDMA_PCTRL_ST_TYPE_SIZE, 1);
+		} else {
+			gsw_w32(cdev, (FDMA_PCTRL_ST_TYPE_OFFSET + (0x6 * pidx)),
+				FDMA_PCTRL_ST_TYPE_SHIFT, FDMA_PCTRL_ST_TYPE_SIZE, 0);
+		}
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_CPU_PortExtendCfgGet(void *cdev, GSW_CPU_PortExtendCfg_t *parm)
+{
+	u32  value, value_add, value_vlan;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	} else {
+		gsw_r32(cdev,
+			(PMAC_HD_CTL_ADD_OFFSET + GSW_TREG_OFFSET),
+			PMAC_HD_CTL_ADD_SHIFT,
+			PMAC_HD_CTL_ADD_SIZE, &value_add);
+		gsw_r32(cdev,
+			(PMAC_HD_CTL_TAG_OFFSET + GSW_TREG_OFFSET),
+			PMAC_HD_CTL_TAG_SHIFT,
+			PMAC_HD_CTL_TAG_SIZE, &value_vlan);
+	}
+
+	if (value_add == 0 && value_vlan == 0)
+		parm->eHeaderAdd = 0;
+	else if (value_add == 1 && value_vlan == 0)
+		parm->eHeaderAdd = 1;
+	else if (value_add == 1 && value_vlan == 1)
+		parm->eHeaderAdd = 2;
+	else
+		parm->eHeaderAdd = 0;
+
+	gsw_r32(cdev, (PMAC_HD_CTL_RL2_OFFSET + GSW_TREG_OFFSET),
+		PMAC_HD_CTL_RL2_SHIFT, PMAC_HD_CTL_RL2_SIZE, &value);
+	parm->bHeaderRemove = value;
+	memset(&parm->sHeader, 0, sizeof(GSW_CPU_Header_t));
+
+	if (value_add == 1) {
+		/* Output the Src MAC */
+		gsw_r32(cdev,
+			(PMAC_SA3_SA_15_0_OFFSET + GSW_TREG_OFFSET),
+			PMAC_SA3_SA_15_0_SHIFT,
+			PMAC_SA3_SA_15_0_SIZE, &value);
+		parm->sHeader.nMAC_Src[0] = value & 0xFF;
+		parm->sHeader.nMAC_Src[1] = ((value >> 8) & 0xFF);
+		gsw_r32(cdev,
+			(PMAC_SA2_SA_31_16_OFFSET + GSW_TREG_OFFSET),
+			PMAC_SA2_SA_31_16_SHIFT,
+			PMAC_SA2_SA_31_16_SIZE, &value);
+		parm->sHeader.nMAC_Src[2] = value & 0xFF;
+		parm->sHeader.nMAC_Src[3] = ((value >> 8) & 0xFF);
+		gsw_r32(cdev,
+			(PMAC_SA1_SA_47_32_OFFSET + GSW_TREG_OFFSET),
+			PMAC_SA1_SA_47_32_SHIFT,
+			PMAC_SA1_SA_47_32_SIZE, &value);
+		parm->sHeader.nMAC_Src[4] = value & 0xFF;
+		parm->sHeader.nMAC_Src[5] = ((value >> 8) & 0xFF);
+		/* Output the Dst MAC */
+		gsw_r32(cdev,
+			(PMAC_DA3_DA_15_0_OFFSET + GSW_TREG_OFFSET),
+			PMAC_DA3_DA_15_0_SHIFT, PMAC_DA3_DA_15_0_SIZE, &value);
+		parm->sHeader.nMAC_Dst[0] = value & 0xFF;
+		parm->sHeader.nMAC_Dst[1] = ((value >> 8) & 0xFF);
+		gsw_r32(cdev,
+			(PMAC_DA2_DA_31_16_OFFSET + GSW_TREG_OFFSET),
+			PMAC_DA2_DA_31_16_SHIFT,
+			PMAC_DA2_DA_31_16_SIZE, &value);
+		parm->sHeader.nMAC_Dst[2] = value & 0xFF;
+		parm->sHeader.nMAC_Dst[3] = ((value >> 8) & 0xFF);
+		gsw_r32(cdev,
+			(PMAC_DA1_SA_47_32_OFFSET + GSW_TREG_OFFSET),
+			PMAC_DA1_SA_47_32_SHIFT,
+			PMAC_DA1_SA_47_32_SIZE, &value);
+		parm->sHeader.nMAC_Dst[4] = value & 0xFF;
+		parm->sHeader.nMAC_Dst[5] = ((value >> 8) & 0xFF);
+		/* Input the Ethernet Type */
+		gsw_r32(cdev,
+			(PMAC_TL_TYPE_LEN_OFFSET + GSW_TREG_OFFSET),
+			PMAC_TL_TYPE_LEN_SHIFT, PMAC_TL_TYPE_LEN_SIZE, &value);
+		parm->sHeader.nEthertype = value;
+	}
+
+	if (value_vlan == 1) {
+		gsw_r32(cdev, (PMAC_VLAN_PRI_OFFSET + GSW_TREG_OFFSET),
+			PMAC_VLAN_PRI_SHIFT, PMAC_VLAN_PRI_SIZE, &value);
+		parm->sHeader.nVLAN_Prio = value;
+		gsw_r32(cdev, (PMAC_VLAN_CFI_OFFSET + GSW_TREG_OFFSET),
+			PMAC_VLAN_CFI_SHIFT, PMAC_VLAN_CFI_SIZE, &value);
+		parm->sHeader.nVLAN_CFI = value;
+		gsw_r32(cdev,
+			(PMAC_VLAN_VLAN_ID_OFFSET + GSW_TREG_OFFSET),
+			PMAC_VLAN_VLAN_ID_SHIFT,
+			PMAC_VLAN_VLAN_ID_SIZE, &value);
+		parm->sHeader.nVLAN_ID = value;
+	}
+
+	gsw_r32(cdev, (PMAC_HD_CTL_FC_OFFSET + GSW_TREG_OFFSET),
+		PMAC_HD_CTL_FC_SHIFT, PMAC_HD_CTL_FC_SIZE, &value);
+	parm->ePauseCtrl = value;
+	gsw_r32(cdev, (PMAC_HD_CTL_RC_OFFSET + GSW_TREG_OFFSET),
+		PMAC_HD_CTL_RC_SHIFT, PMAC_HD_CTL_RC_SIZE, &value);
+	parm->bFcsRemove = value;
+	gsw_r32(cdev, (PMAC_EWAN_EWAN_OFFSET + GSW_TREG_OFFSET),
+		PMAC_EWAN_EWAN_SHIFT, PMAC_EWAN_EWAN_SIZE, &value);
+	parm->nWAN_Ports = value;
+	ret = GSW_statusOk;
+
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_CPU_PortExtendCfgSet(void *cdev, GSW_CPU_PortExtendCfg_t *parm)
+{
+	u32 value_add = 0, value_vlan = 0;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (IS_VRSN_30_31(gswdev->gipver)) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	switch (parm->eHeaderAdd) {
+	case GSW_CPU_HEADER_NO:
+		value_add = 0;
+		value_vlan = 0;
+		break;
+
+	case GSW_CPU_HEADER_MAC:
+		value_add = 1;
+		value_vlan = 0;
+		break;
+
+	case GSW_CPU_HEADER_VLAN:
+		value_add = 1;
+		value_vlan = 1;
+		break;
+	}
+
+	if ((parm->bHeaderRemove == 1)
+	    && (parm->eHeaderAdd != GSW_CPU_HEADER_NO)) {
+		pr_err("The Header Can't be remove because the Header Add parameter is not 0");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}  else {
+		gsw_w32(cdev, (PMAC_HD_CTL_RL2_OFFSET + GSW_TREG_OFFSET),
+			PMAC_HD_CTL_RL2_SHIFT,
+			PMAC_HD_CTL_RL2_SIZE, parm->bHeaderRemove);
+	}
+
+	gsw_w32(cdev, (PMAC_HD_CTL_ADD_OFFSET + GSW_TREG_OFFSET),
+		PMAC_HD_CTL_ADD_SHIFT, PMAC_HD_CTL_ADD_SIZE, value_add);
+	gsw_w32(cdev, (PMAC_HD_CTL_TAG_OFFSET + GSW_TREG_OFFSET),
+		PMAC_HD_CTL_TAG_SHIFT, PMAC_HD_CTL_TAG_SIZE, value_vlan);
+
+	if (parm->eHeaderAdd == GSW_CPU_HEADER_MAC) {
+		u32 macdata;
+		/* Input the Src MAC */
+		macdata = ((parm->sHeader.nMAC_Src[0])
+			   | (parm->sHeader.nMAC_Src[1] << 8));
+		gsw_w32(cdev,
+			(PMAC_SA3_SA_15_0_OFFSET + GSW_TREG_OFFSET),
+			PMAC_SA3_SA_15_0_SHIFT,
+			PMAC_SA3_SA_15_0_SIZE, macdata);
+		macdata = (parm->sHeader.nMAC_Src[2]
+			   | parm->sHeader.nMAC_Src[3] << 8);
+		gsw_w32(cdev,
+			(PMAC_SA2_SA_31_16_OFFSET + GSW_TREG_OFFSET),
+			PMAC_SA2_SA_31_16_SHIFT,
+			PMAC_SA2_SA_31_16_SIZE, macdata);
+		macdata = (parm->sHeader.nMAC_Src[4]
+			   | parm->sHeader.nMAC_Src[5] << 8);
+		gsw_w32(cdev,
+			(PMAC_SA1_SA_47_32_OFFSET + GSW_TREG_OFFSET),
+			PMAC_SA1_SA_47_32_SHIFT,
+			PMAC_SA1_SA_47_32_SIZE, macdata);
+		/* Input the Dst MAC */
+		macdata = (parm->sHeader.nMAC_Dst[0]
+			   | parm->sHeader.nMAC_Dst[1] << 8);
+		gsw_w32(cdev,
+			(PMAC_DA3_DA_15_0_OFFSET + GSW_TREG_OFFSET),
+			PMAC_DA3_DA_15_0_SHIFT,
+			PMAC_DA3_DA_15_0_SIZE, macdata);
+		macdata = (parm->sHeader.nMAC_Dst[2]
+			   | parm->sHeader.nMAC_Dst[3] << 8);
+		gsw_w32(cdev,
+			(PMAC_DA2_DA_31_16_OFFSET + GSW_TREG_OFFSET),
+			PMAC_DA2_DA_31_16_SHIFT,
+			PMAC_DA2_DA_31_16_SIZE, macdata);
+		macdata = ((parm->sHeader.nMAC_Dst[4])
+			   | (parm->sHeader.nMAC_Dst[5] << 8));
+		gsw_w32(cdev,
+			(PMAC_DA1_SA_47_32_OFFSET + GSW_TREG_OFFSET),
+			PMAC_DA1_SA_47_32_SHIFT,
+			PMAC_DA1_SA_47_32_SIZE, macdata);
+		/* Input the Ethernet Type */
+		gsw_w32(cdev,
+			(PMAC_TL_TYPE_LEN_OFFSET + GSW_TREG_OFFSET),
+			PMAC_TL_TYPE_LEN_SHIFT,
+			PMAC_TL_TYPE_LEN_SIZE, parm->sHeader.nEthertype);
+	}
+
+	if (parm->eHeaderAdd == GSW_CPU_HEADER_VLAN) {
+		gsw_w32(cdev, (PMAC_VLAN_PRI_OFFSET + GSW_TREG_OFFSET),
+			PMAC_VLAN_PRI_SHIFT,
+			PMAC_VLAN_PRI_SIZE, parm->sHeader.nVLAN_Prio);
+		gsw_w32(cdev, (PMAC_VLAN_CFI_OFFSET + GSW_TREG_OFFSET),
+			PMAC_VLAN_CFI_SHIFT,
+			PMAC_VLAN_CFI_SIZE, parm->sHeader.nVLAN_CFI);
+		gsw_w32(cdev, (PMAC_VLAN_VLAN_ID_OFFSET + GSW_TREG_OFFSET),
+			PMAC_VLAN_VLAN_ID_SHIFT,
+			PMAC_VLAN_VLAN_ID_SIZE, parm->sHeader.nVLAN_ID);
+	}
+
+	gsw_w32(cdev, (PMAC_HD_CTL_FC_OFFSET + GSW_TREG_OFFSET),
+		PMAC_HD_CTL_FC_SHIFT, PMAC_HD_CTL_FC_SIZE, parm->ePauseCtrl);
+	gsw_w32(cdev, (PMAC_HD_CTL_RC_OFFSET + GSW_TREG_OFFSET),
+		PMAC_HD_CTL_RC_SHIFT, PMAC_HD_CTL_RC_SIZE, parm->bFcsRemove);
+	gsw_w32(cdev, (PMAC_EWAN_EWAN_OFFSET + GSW_TREG_OFFSET),
+		PMAC_EWAN_EWAN_SHIFT, PMAC_EWAN_EWAN_SIZE, parm->nWAN_Ports);
+	ret = GSW_statusOk;
+
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+#if defined(CONFIG_LTQ_WOL) && CONFIG_LTQ_WOL
+GSW_return_t GSW_WoL_CfgGet(void *cdev, GSW_WoL_Cfg_t *parm)
+{
+	u32 value;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	gsw_r32(cdev, WOL_GLB_CTRL_PASSEN_OFFSET, WOL_GLB_CTRL_PASSEN_SHIFT,
+		WOL_GLB_CTRL_PASSEN_SIZE, &value);
+	parm->bWolPasswordEnable = value;
+	gsw_r32(cdev, WOL_DA_2_DA2_OFFSET, WOL_DA_2_DA2_SHIFT,
+		WOL_DA_2_DA2_SIZE, &value);
+	parm->nWolMAC[0] = (value >> 8 & 0xFF);
+	parm->nWolMAC[1] = (value & 0xFF);
+	gsw_r32(cdev, WOL_DA_1_DA1_OFFSET, WOL_DA_1_DA1_SHIFT,
+		WOL_DA_1_DA1_SIZE, &value);
+	parm->nWolMAC[2] = (value >> 8 & 0xFF);
+	parm->nWolMAC[3] = (value & 0xFF);
+	gsw_r32(cdev, WOL_DA_0_DA0_OFFSET, WOL_DA_0_DA0_SHIFT,
+		WOL_DA_0_DA0_SIZE, &value);
+	parm->nWolMAC[4] = (value >> 8 & 0xFF);
+	parm->nWolMAC[5] = (value & 0xFF);
+	gsw_r32(cdev, WOL_PW_2_PW2_OFFSET, WOL_PW_2_PW2_SHIFT,
+		WOL_PW_2_PW2_SIZE, &value);
+	parm->nWolPassword[0] = (value >> 8 & 0xFF);
+	parm->nWolPassword[1] = (value & 0xFF);
+	gsw_r32(cdev, WOL_PW_1_PW1_OFFSET, WOL_PW_1_PW1_SHIFT,
+		WOL_PW_1_PW1_SIZE, &value);
+	parm->nWolPassword[2] = (value >> 8 & 0xFF);
+	parm->nWolPassword[3] = (value & 0xFF);
+	gsw_r32(cdev, WOL_PW_0_PW0_OFFSET, WOL_PW_0_PW0_SHIFT,
+		WOL_PW_0_PW0_SIZE, &value);
+	parm->nWolPassword[4] = (value >> 8 & 0xFF);
+	parm->nWolPassword[5] = (value & 0xFF);
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_WoL_CfgSet(void *cdev, GSW_WoL_Cfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	gsw_w32(cdev, WOL_GLB_CTRL_PASSEN_OFFSET, WOL_GLB_CTRL_PASSEN_SHIFT,
+		WOL_GLB_CTRL_PASSEN_SIZE, parm->bWolPasswordEnable);
+	gsw_w32(cdev, WOL_DA_2_DA2_OFFSET,
+		WOL_DA_2_DA2_SHIFT, WOL_DA_2_DA2_SIZE,
+		(((parm->nWolMAC[0] & 0xFF) << 8)
+		 | (parm->nWolMAC[1] & 0xFF)));
+	gsw_w32(cdev, WOL_DA_1_DA1_OFFSET,
+		WOL_DA_1_DA1_SHIFT, WOL_DA_1_DA1_SIZE,
+		(((parm->nWolMAC[2] & 0xFF) << 8)
+		 | (parm->nWolMAC[3] & 0xFF)));
+	gsw_w32(cdev, WOL_DA_0_DA0_OFFSET,
+		WOL_DA_0_DA0_SHIFT, WOL_DA_0_DA0_SIZE,
+		(((parm->nWolMAC[4] & 0xFF) << 8)
+		 | (parm->nWolMAC[5] & 0xFF)));
+	gsw_w32(cdev, WOL_PW_2_PW2_OFFSET,
+		WOL_PW_2_PW2_SHIFT, WOL_PW_2_PW2_SIZE,
+		(((parm->nWolPassword[0] & 0xFF) << 8)
+		 | (parm->nWolPassword[1] & 0xFF)));
+	gsw_w32(cdev, WOL_PW_1_PW1_OFFSET,
+		WOL_PW_1_PW1_SHIFT, WOL_PW_1_PW1_SIZE,
+		(((parm->nWolPassword[2] & 0xFF) << 8)
+		 | (parm->nWolPassword[3] & 0xFF)));
+	gsw_w32(cdev, WOL_PW_0_PW0_OFFSET,
+		WOL_PW_0_PW0_SHIFT, WOL_PW_0_PW0_SIZE,
+		(((parm->nWolPassword[4] & 0xFF) << 8)
+		 | (parm->nWolPassword[5] & 0xFF)));
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_WoL_PortCfgGet(void *cdev, GSW_WoL_PortCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	gsw_r32(cdev, (WOL_CTRL_PORT_OFFSET + (0xA * parm->nPortId)),
+		WOL_CTRL_PORT_SHIFT, WOL_CTRL_PORT_SIZE, &value);
+	parm->bWakeOnLAN_Enable = value;
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+		gsw_r32(cdev, (WOL_CTRL_ADDRDIS_OFFSET + (0xA * parm->nPortId)),
+			WOL_CTRL_ADDRDIS_SHIFT, WOL_CTRL_ADDRDIS_SIZE, &value);
+		parm->bIgnoreAdrCheck = value;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_WoL_PortCfgSet(void *cdev, GSW_WoL_PortCfg_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	gsw_w32(cdev, (WOL_CTRL_PORT_OFFSET + (0xA * parm->nPortId)),
+		WOL_CTRL_PORT_SHIFT,
+		WOL_CTRL_PORT_SIZE, parm->bWakeOnLAN_Enable);
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+		gsw_w32(cdev, (WOL_CTRL_ADDRDIS_OFFSET + (0xA * parm->nPortId)),
+			WOL_CTRL_ADDRDIS_SHIFT,
+			WOL_CTRL_ADDRDIS_SIZE, parm->bIgnoreAdrCheck);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+#endif /* CONFIG_LTQ_WOL */
+GSW_return_t GSW_RegisterGet(void *cdev, GSW_register_t *parm)
+{
+	u32 rvalue, raddr = parm->nRegAddr;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	gsw_r32(cdev, raddr,	0, 16, &rvalue);
+	parm->nData = rvalue;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_RegisterSet(void *cdev, GSW_register_t *parm)
+{
+	u32 rvalue = parm->nData, raddr = parm->nRegAddr;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	gsw_w32(cdev, raddr, 0, 16, rvalue);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_IrqGet(void *cdev, GSW_irq_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/* ToDo: Require future clarify for how to display */
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_IrqMaskGet(void *cdev, GSW_irq_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 pidx = parm->nPortId;
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if (parm->eIrqSrc == GSW_IRQ_WOL) {
+		gsw_r32(cdev, (PCE_PIER_WOL_OFFSET + (0xA * pidx)),
+			PCE_PIER_WOL_SHIFT, PCE_PIER_WOL_SIZE, &value);
+	} else if (parm->eIrqSrc == GSW_IRQ_LIMIT_ALERT) {
+		gsw_r32(cdev, (PCE_PIER_LOCK_OFFSET + (0xA * pidx)),
+			PCE_PIER_LOCK_SHIFT, PCE_PIER_LOCK_SIZE, &value);
+	} else if (parm->eIrqSrc == GSW_IRQ_LOCK_ALERT) {
+		gsw_r32(cdev, (PCE_PIER_LIM_OFFSET + (0xA * pidx)),
+			PCE_PIER_LIM_SHIFT, PCE_PIER_LIM_SIZE, &value);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_IrqMaskSet(void *cdev, GSW_irq_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 pidx = parm->nPortId;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if (parm->eIrqSrc == GSW_IRQ_WOL) {
+		gsw_w32(cdev, (PCE_PIER_WOL_OFFSET + (0xA * pidx)),
+			PCE_PIER_WOL_SHIFT, PCE_PIER_WOL_SIZE, 1);
+	} else if (parm->eIrqSrc == GSW_IRQ_LIMIT_ALERT) {
+		gsw_w32(cdev, (PCE_PIER_LOCK_OFFSET + (0xA * pidx)),
+			PCE_PIER_LOCK_SHIFT, PCE_PIER_LOCK_SIZE, 1);
+	} else if (parm->eIrqSrc == GSW_IRQ_LOCK_ALERT) {
+		gsw_w32(cdev, (PCE_PIER_LIM_OFFSET + (0xA * pidx)),
+			PCE_PIER_LIM_SHIFT, PCE_PIER_LIM_SIZE, 1);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_IrqStatusClear(void *cdev, GSW_irq_t *parm)
+{
+	/* ToDo: Request future clarify */
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_PceRuleRead(void *cdev, GSW_PCE_rule_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return  GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (0 != pce_rule_read(cdev, &gswdev->phandler, parm)) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_PceRuleWrite(void *cdev, GSW_PCE_rule_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (0 != pce_rule_write(cdev, &gswdev->phandler, parm)) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_PceRuleDelete(void *cdev, GSW_PCE_ruleDelete_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 index; //Traffic-Flow table index.
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	index = parm->nIndex;
+
+	if (0 != pce_pattern_delete(cdev, &gswdev->phandler, index)) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+
+/*Applicable only for GSWIP 3.1*/
+static u8 GSW_SearchContiguousCtp(ethsw_api_dev_t *gswdev, u32 ctp, u32 NumberOfEntries)
+{
+	u32 i;
+
+	for (i = ctp; i < (ctp + NumberOfEntries); i++) {
+		if (gswdev->ctpportconfig_idx[i].IndexInUse)
+			return 0;
+	}
+
+	return 1;
+}
+
+GSW_return_t GSW_CTP_PortAssignmentAlloc(void *cdev, GSW_CTP_portAssignment_t *parm)
+{
+	static GSW_CTP_portConfig_t CtpConfig;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 i, ret, ctp;
+	u8 ContiguousCtpFound = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_alloc);
+#endif
+
+	if (!(gswdev->brdgeportconfig_idx[parm->nBridgePortId].IndexInUse)) {
+		pr_err("ERROR :BridgePortId %d index not in use,Please allocate the BridgePortId\n", parm->nBridgePortId);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*CTP 0 is for special use, so allocation search will start from CTP 1 to CTP 287*/
+	for (ctp = 1; ctp < gswdev->num_of_ctp && !ContiguousCtpFound; ctp++) {
+		/*If CTP Index not in use*/
+		if (!gswdev->ctpportconfig_idx[ctp].IndexInUse) {
+			/*Note: CTP allocation should be contiguous as per the requested nNumberOfCtpPort*/
+			ContiguousCtpFound = GSW_SearchContiguousCtp(gswdev, ctp, parm->nNumberOfCtpPort);
+		}
+
+		/*Contiguous CTP indexes which is not in use is found*/
+		if (ContiguousCtpFound) {
+			parm->nFirstCtpPortId = ctp;
+
+			/*Mark the contiguous ctp indexes as InUse and tag it with the logical port*/
+			for (i = parm->nFirstCtpPortId; i < (parm->nFirstCtpPortId + parm->nNumberOfCtpPort); i++) {
+				gswdev->ctpportconfig_idx[i].IndexInUse = 1;
+				gswdev->ctpportconfig_idx[i].AssociatedLogicalPort = parm->nLogicalPortId;
+			}
+		}
+	}
+
+	/*Contiguous CTP indexes not found*/
+	if (!ContiguousCtpFound) {
+		pr_err("ERROR:No Contiguous CTP indexes Found as per the requested nNumberOfCtpPort\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*Configure CTP StartIdx,EndIdx and Mode to the
+	  corresponding logical port*/
+	ret = GSW_CTP_PortAssignmentSet(cdev, parm);
+
+	if (ret == GSW_statusErr) {
+		pr_err("GSW_CTP_PortAssignmentSet returns ERROR\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	memset(&CtpConfig, 0, sizeof(GSW_CTP_portConfig_t));
+	CtpConfig.eMask = GSW_CTP_PORT_CONFIG_MASK_BRIDGE_PORT_ID;
+	/*Associate the bridge port to the allocated CTP*/
+	CtpConfig.nBridgePortId = parm->nBridgePortId;
+	/*Logical Port and SubInterfaceID will fetch the CTP index
+	  in GSW_CtpPortConfigSet */
+	CtpConfig.nLogicalPortId = parm->nLogicalPortId;
+	CtpConfig.nSubIfIdGroup = 0;
+
+	for (i = parm->nFirstCtpPortId; i < (parm->nFirstCtpPortId + parm->nNumberOfCtpPort); i++) {
+		ret = GSW_CtpPortConfigSet(cdev, &CtpConfig);
+
+		if (ret == GSW_statusErr) {
+			pr_err("GSW_CtpPortConfigSet returns ERROR\n");
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		CtpConfig.nSubIfIdGroup++;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	/*Enable SDMA for the corresponding logical port*/
+	gsw_w32(cdev, (SDMA_PCTRL_PEN_OFFSET + (parm->nLogicalPortId * 0x6)),
+		SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE, 1);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_alloc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_CTP_PortAssignmentFree(void *cdev, GSW_CTP_portAssignment_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 i, ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_free);
+#endif
+
+	ret = GSW_CTP_PortAssignmentGet(cdev, parm);
+
+	if (ret == GSW_statusErr) {
+		pr_err("GSW_CTP_PortAssignmentGet returns ERROR\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*Set Index not in-Use to the CTPs assoicated with this logical port*/
+	for (i = parm->nFirstCtpPortId; i < (parm->nFirstCtpPortId + parm->nNumberOfCtpPort); i++)
+		gswdev->ctpportconfig_idx[i].IndexInUse = 0;
+
+	/*Disable the SDMA for this logical port*/
+	gsw_w32(cdev, (SDMA_PCTRL_PEN_OFFSET + (parm->nLogicalPortId * 0x6)),
+		SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE, 0);
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_free);
+#endif
+	return ret;
+}
+
+
+GSW_return_t GSW_CTP_PortAssignmentSet(void *cdev, GSW_CTP_portAssignment_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	/*Checking based on number of logical port */
+	if (parm->nLogicalPortId >= gswdev->tpnum) {
+		pr_err("ERROR: logical port id %d >= than gswdev->tpnum %d\n",
+		       parm->nLogicalPortId, gswdev->tpnum);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if (parm->nFirstCtpPortId >= gswdev->num_of_ctp) {
+		pr_err("ERROR: nFirstCtpPortId %d >= than gswdev->num_of_ctp %d\n",
+		       parm->nFirstCtpPortId, gswdev->num_of_ctp);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if ((parm->nFirstCtpPortId + (parm->nNumberOfCtpPort - 1)) >= gswdev->num_of_ctp) {
+		pr_err("ERROR: nNumberOfCtpPort %d >= than gswdev->num_of_ctp %d\n",
+		       (parm->nFirstCtpPortId + parm->nNumberOfCtpPort), gswdev->num_of_ctp);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	switch (parm->eMode) {
+	case GSW_LOGICAL_PORT_8BIT_WLAN:
+		gsw_w32(cdev, ETHSW_CTP_STARTID_GET(parm->nLogicalPortId),
+			ETHSW_CTP_STARTID_MD_SHIFT, ETHSW_CTP_STARTID_MD_SIZE, 0);
+		break;
+
+	case GSW_LOGICAL_PORT_9BIT_WLAN:
+		gsw_w32(cdev, ETHSW_CTP_STARTID_GET(parm->nLogicalPortId),
+			ETHSW_CTP_STARTID_MD_SHIFT, ETHSW_CTP_STARTID_MD_SIZE, 1);
+		break;
+
+	default:
+		gsw_w32(cdev, ETHSW_CTP_STARTID_GET(parm->nLogicalPortId),
+			ETHSW_CTP_STARTID_MD_SHIFT, ETHSW_CTP_STARTID_MD_SIZE, 2);
+	}
+
+	gsw_w32(cdev, ETHSW_CTP_STARTID_GET(parm->nLogicalPortId),
+		ETHSW_CTP_STARTID_SHIFT, ETHSW_CTP_STARTID_SIZE, parm->nFirstCtpPortId);
+
+	gsw_w32(cdev, ETHSW_CTP_ENDID_GET(parm->nLogicalPortId),
+		ETHSW_CTP_ENDID_SHIFT, ETHSW_CTP_ENDID_SIZE, (parm->nFirstCtpPortId + parm->nNumberOfCtpPort - 1));
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_CTP_PortAssignmentGet(void *cdev, GSW_CTP_portAssignment_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	/*Checking based on number of logical port*/
+	if (parm->nLogicalPortId >= gswdev->tpnum) {
+		pr_err("ERROR: logical port id %u >= than gswdev->tpnum %u\n",
+		       parm->nLogicalPortId, gswdev->tpnum);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	gsw_r32(cdev, ETHSW_CTP_STARTID_GET(parm->nLogicalPortId),
+		ETHSW_CTP_STARTID_MD_SHIFT, ETHSW_CTP_STARTID_MD_SIZE, &value);
+	parm->eMode = value;
+
+	gsw_r32(cdev, ETHSW_CTP_STARTID_GET(parm->nLogicalPortId),
+		ETHSW_CTP_STARTID_SHIFT, ETHSW_CTP_STARTID_SIZE, &value);
+	parm->nFirstCtpPortId = value;
+
+	gsw_r32(cdev, ETHSW_CTP_ENDID_GET(parm->nLogicalPortId),
+		ETHSW_CTP_ENDID_SHIFT, ETHSW_CTP_ENDID_SIZE, &value);
+
+	if (parm->nFirstCtpPortId < value)
+		parm->nNumberOfCtpPort = value - parm->nFirstCtpPortId + 1;
+	else if (parm->nFirstCtpPortId == value)
+		parm->nNumberOfCtpPort = 1;
+	else
+		parm->nNumberOfCtpPort = 0;
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+
+GSW_return_t GSW_QOS_ColorMarkingTableSet(void *cdev, GSW_QoS_colorMarkingEntry_t *parm)
+{
+	pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 pcp, dscp, tbl_index;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+	tbl_prog.table = PCE_MAMRK_INDEX;
+
+	switch (parm->eMode) {
+	case GSW_MARKING_ALL_GREEN:
+		break;
+
+	case GSW_MARKING_INTERNAL_MARKING:
+		break;
+
+	case GSW_MARKING_DEI:
+		break;
+
+	case GSW_MARKING_PCP_8P0D:
+
+	/*	For mode 3 there are 16 entries corresponding to PCP (bit3 to 1) + DEI (bit 0)
+		Table Entry index from 0 to 15	*/
+	case GSW_MARKING_PCP_7P1D:
+
+	/*	For mode 4 there are 16 entries corresponding to PCP (bit3 to 1) + DEI (bit 0)
+		Table Entry index from 16 to 31 */
+	case GSW_MARKING_PCP_6P2D:
+
+	/*	For mode 5 there are 16 entries corresponding to PCP (bit3 to 1) + DEI (bit 0)
+		Table Entry index from 32 to 47 */
+	case GSW_MARKING_PCP_5P3D:
+		/*	For mode 6 there are 16 entries corresponding to PCP (bit3 to 1) + DEI (bit 0)
+			Table Entry index from 48 to 63 */
+		tbl_index = (((parm->eMode) - GSW_MARKING_PCP_8P0D) << 4);
+
+		for (pcp = 0; pcp <= 15; pcp++, tbl_index++) {
+			/*Set Table Entry Index*/
+			CLEAR_U16(tbl_prog.pcindex);
+			/*Set Color Marking Mode Entry address in PCE_TBL_ADDR 2:0*/
+			/*Set DEI Entry address in PCE_TBL_ADDR (bit 4 set to 0)*/
+			/*Set PCP Entry address in PCE_TBL_ADDR*/
+			tbl_prog.pcindex |= (pcp << 4);
+			/*Set Color Marking Mode Entry address in PCE_TBL_ADDR*/
+			tbl_prog.pcindex |= parm->eMode;
+
+			/*Set PCE_TBL_VAL 0*/
+			CLEAR_U16(tbl_prog.val[0]);
+			/*Set Priority in PCE_TBL_VAL 0 (bit 6:4)*/
+			tbl_prog.val[0] |= ((parm->nPriority[tbl_index] & 0x7) << 4);
+			/*Set Color in PCE_TBL_VAL 0 (bit 8:7)*/
+			tbl_prog.val[0] |= ((parm->nColor[tbl_index] & 0x3) << 7);
+			/*Address-based write*/
+			gsw_pce_table_write(cdev, &tbl_prog);
+		}
+
+		break;
+
+	case GSW_MARKING_DSCP_AF:
+		/*	For mode 7 there are 64 entries corresponding to DSCP
+			Table Entry index from 64 to 127 */
+		tbl_index = 0;
+
+		for (dscp = 0; dscp <= 63; dscp++, tbl_index++) {
+			/*Set Table Entry Index*/
+			CLEAR_U16(tbl_prog.pcindex);
+			/*Set DSCP Entry address in PCE_TBL_ADDR*/
+			tbl_prog.pcindex |= (dscp << 4);
+			/*Set Color Marking Mode Entry address in PCE_TBL_ADDR*/
+			tbl_prog.pcindex |= GSW_MARKING_DSCP_AF;
+
+			/*Set PCE_TBL_VAL 0*/
+			CLEAR_U16(tbl_prog.val[0]);
+			/*Set Priority in PCE_TBL_VAL 0 (bit 6:4)*/
+			tbl_prog.val[0] |= ((parm->nPriority[tbl_index] & 0x7) << 4);
+			/*Set Color in PCE_TBL_VAL 0 (bit 8:7)*/
+			tbl_prog.val[0] |= ((parm->nColor[tbl_index] & 0x3) << 7);
+			/*Address-based write*/
+			gsw_pce_table_write(cdev, &tbl_prog);
+		}
+
+		break;
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QOS_ColorMarkingTableGet(void *cdev, GSW_QoS_colorMarkingEntry_t *parm)
+{
+	pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 pcp, dscp, tbl_index;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+	tbl_prog.table = PCE_MAMRK_INDEX;
+
+	switch (parm->eMode) {
+	case GSW_MARKING_ALL_GREEN:
+		break;
+
+	case GSW_MARKING_INTERNAL_MARKING:
+		break;
+
+	case GSW_MARKING_DEI:
+		break;
+
+	case GSW_MARKING_PCP_8P0D:
+
+	/*	For mode 3 there are 16 entries corresponding to PCP (bit3 to 1) + DEI (bit 0)
+		Table Entry index from 0 to 15	*/
+	case GSW_MARKING_PCP_7P1D:
+
+	/*	For mode 4 there are 16 entries corresponding to PCP (bit3 to 1) + DEI (bit 0)
+		Table Entry index from 16 to 31 */
+	case GSW_MARKING_PCP_6P2D:
+
+	/*	For mode 5 there are 16 entries corresponding to PCP (bit3 to 1) + DEI (bit 0)
+		Table Entry index from 32 to 47 */
+	case GSW_MARKING_PCP_5P3D:
+		/*	For mode 6 there are 16 entries corresponding to PCP (bit3 to 1) + DEI (bit 0)
+			Table Entry index from 48 to 63 */
+		tbl_index = (((parm->eMode) - GSW_MARKING_PCP_8P0D) << 4);
+
+		for (pcp = 0; pcp <= 15; pcp++, tbl_index++) {
+			tbl_prog.table = PCE_MAMRK_INDEX;
+			/*Set Table Entry Index*/
+			CLEAR_U16(tbl_prog.pcindex);
+			/*Set PCP Entry address in PCE_TBL_ADDR*/
+			tbl_prog.pcindex |= (pcp << 4);
+			/*Set Color Marking Mode Entry address in PCE_TBL_ADDR*/
+			tbl_prog.pcindex |= parm->eMode;
+			/*Address-based read*/
+			gsw_pce_table_read(cdev, &tbl_prog);
+
+			/*Get PCE_TBL_VAL 0*/
+			/*Get Priority in PCE_TBL_VAL 0 (bit 6:4)*/
+			parm->nPriority[tbl_index] = ((tbl_prog.val[0] & 0x70) >> 4);
+			/*Get Color in PCE_TBL_VAL 0 (bit 8:7)*/
+			parm->nColor[tbl_index] |= ((tbl_prog.val[0] & 0x180) >> 7);
+		}
+
+		break;
+
+	case GSW_MARKING_DSCP_AF:
+		/*	For mode 7 there are 64 entries corresponding to DSCP
+			Table Entry index from 64 to 127 */
+		tbl_index = 0;
+
+		for (dscp = 0; dscp <= 63; dscp++, tbl_index++) {
+			tbl_prog.table = PCE_MAMRK_INDEX;
+			/*Set Table Entry Index*/
+			CLEAR_U16(tbl_prog.pcindex);
+			/*Set DSCP Entry address in PCE_TBL_ADDR*/
+			tbl_prog.pcindex |= (dscp << 4);
+			/*Set Color Marking Mode Entry address in PCE_TBL_ADDR*/
+			tbl_prog.pcindex |= GSW_MARKING_DSCP_AF;
+			/*Address-based read*/
+			gsw_pce_table_read(cdev, &tbl_prog);
+
+			/*Get PCE_TBL_VAL 0*/
+			/*Get Priority in PCE_TBL_VAL 0 (bit 6:4)*/
+			parm->nPriority[tbl_index] = ((tbl_prog.val[0] & 0x70) >> 4);
+			/*Get Color in PCE_TBL_VAL 0 (bit 8:7)*/
+			parm->nColor[tbl_index] |= ((tbl_prog.val[0] & 0x180) >> 7);
+		}
+
+		break;
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QOS_ColorReMarkingTableSet(void *cdev, GSW_QoS_colorRemarkingEntry_t *parm)
+{
+	pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 priority, traffic_class, index;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+	tbl_prog.table = PCE_REMARK_INDEX;
+
+	switch (parm->eMode) {
+	case GSW_REMARKING_NONE:
+		break;
+
+	case GSW_REMARKING_DEI:
+		break;
+
+	case GSW_REMARKING_PCP_8P0D:
+
+	/*	For mode 3 there are 16 entries corresponding to Priority + Color Bit*/
+	case GSW_REMARKING_PCP_7P1D:
+
+	/*	For mode 4 there are 16 entries corresponding to Priority + Color Bit*/
+	case GSW_REMARKING_PCP_6P2D:
+
+	/*	For mode 5 there are 16 entries corresponding to Priority + Color Bit*/
+	case GSW_REMARKING_PCP_5P3D:
+		/*	For mode 6 there are 16 entries corresponding to Priority + Color Bit*/
+
+		index = 0;
+
+		/*Set Color Bit 0's entries from 0 t0 7
+			  Color Bit 1's entries from 8 t0 15*/
+		for (priority = 0; priority <= 15; priority++, index++) {
+			/*Set Table Entry Index*/
+			CLEAR_U16(tbl_prog.pcindex);
+			/*Set Priority Entry address in PCE_TBL_ADDR*/
+			tbl_prog.pcindex |= (priority << 4);
+			/*Set Color ReMarking Mode Entry address in PCE_TBL_ADDR*/
+			tbl_prog.pcindex |= parm->eMode;
+
+			/*Set PCE_TBL_VAL 0*/
+			CLEAR_U16(tbl_prog.val[0]);
+			/*Set New DEI in PCE_TBL_VAL 0 (bit 0)*/
+			tbl_prog.val[0] |= (parm->nVal[index] & 0x1);
+			/*Set New PCP in PCE_TBL_VAL 0 (bit 3:1)*/
+			tbl_prog.val[0] |= (parm->nVal[index] & 0xE);
+
+			/*Address-based write*/
+			gsw_pce_table_write(cdev, &tbl_prog);
+		}
+
+		break;
+
+	case GSW_REMARKING_DSCP_AF:
+		/*	For mode 7 there are 16 entries corresponding to Traffic Class + Color Bit
+			Table Entry index from 64 to 79*/
+		index = 0;
+
+		/*Set Color Bit 0's entries from 0 t0 7
+			  Color Bit 1's entries from 8 t0 15*/
+		for (traffic_class = 0; traffic_class <= 15; traffic_class++, index++) {
+			/*Set Table Entry Index*/
+			CLEAR_U16(tbl_prog.pcindex);
+			/*Set Traffic Class Entry address in PCE_TBL_ADDR*/
+			tbl_prog.pcindex |= (traffic_class << 4);
+			/*Set Color ReMarking Mode Entry address in PCE_TBL_ADDR*/
+			tbl_prog.pcindex |= parm->eMode;
+
+			/*Set PCE_TBL_VAL 0*/
+			CLEAR_U16(tbl_prog.val[0]);
+			/*Set New DSCP in PCE_TBL_VAL 0 (bit 5:0)*/
+			tbl_prog.val[0] |= (parm->nVal[index] & 0x3F);
+
+			/*Address-based write*/
+			gsw_pce_table_write(cdev, &tbl_prog);
+		}
+
+		break;
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QOS_ColorReMarkingTableGet(void *cdev, GSW_QoS_colorRemarkingEntry_t *parm)
+{
+	pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 priority, traffic_class, index;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+
+	switch (parm->eMode) {
+	case GSW_REMARKING_NONE:
+		break;
+
+	case GSW_REMARKING_DEI:
+		break;
+
+	case GSW_REMARKING_PCP_8P0D:
+
+	/*	For mode 3 there are 16 entries corresponding to Priority + Color Bit
+		Table Entry index from 0 to 15	*/
+	case GSW_REMARKING_PCP_7P1D:
+
+	/*	For mode 4 there are 16 entries corresponding to Priority + Color Bit
+		Table Entry index from 16 to 31	*/
+	case GSW_REMARKING_PCP_6P2D:
+
+	/*	For mode 5 there are 16 entries corresponding to Priority + Color Bit
+		Table Entry index from 32 to 47	*/
+	case GSW_REMARKING_PCP_5P3D:
+		/*	For mode 6 there are 16 entries corresponding to Priority + Color Bit
+			Table Entry index from 48 to 63	*/
+		index = 0;
+
+		/*Get Color Bit 0's entries from 0 t0 7
+			  Color Bit 1's entries from 8 t0 15*/
+		for (priority = 0; priority <= 15; priority++, index++) {
+			tbl_prog.table = PCE_REMARK_INDEX;
+			/*Set Table Entry Index*/
+			CLEAR_U16(tbl_prog.pcindex);
+			/*Set Priority Entry address in PCE_TBL_ADDR*/
+			tbl_prog.pcindex |= (priority << 4);
+			/*Set Color ReMarking Mode Entry address in PCE_TBL_ADDR*/
+			tbl_prog.pcindex |= parm->eMode;
+			/*Address-based read*/
+			gsw_pce_table_read(cdev, &tbl_prog);
+
+			/*Get New DEI in PCE_TBL_VAL 0 (bit 0)*/
+			parm->nVal[index] |= (tbl_prog.val[0] & 0x1);
+			/*Get New PCP in PCE_TBL_VAL 0 (bit 3:1)*/
+			parm->nVal[index] |= (tbl_prog.val[0] & 0xE);
+		}
+
+		break;
+
+	case GSW_REMARKING_DSCP_AF:
+		/*	For mode 7 there are 16 entries corresponding to Traffic Class + Color Bit
+			Table Entry index from 64 to 79*/
+		index = 0;
+
+		/*Get Color Bit 0's entries from 0 t0 7
+			  Color Bit 1's entries from 8 t0 15*/
+		for (traffic_class = 0; traffic_class <= 15; traffic_class++, index++) {
+			tbl_prog.table = PCE_REMARK_INDEX;
+			/*Set Table Entry Index*/
+			CLEAR_U16(tbl_prog.pcindex);
+			/*Set Traffic Class Entry address in PCE_TBL_ADDR*/
+			tbl_prog.pcindex |= (traffic_class << 4);
+			/*Set Color ReMarking Mode Entry address in PCE_TBL_ADDR*/
+			tbl_prog.pcindex |= parm->eMode;
+
+			/*Address-based read*/
+			gsw_pce_table_read(cdev, &tbl_prog);
+
+			/*Get New DSCP in PCE_TBL_VAL 0 (bit 3:1)*/
+			parm->nVal[index] = (tbl_prog.val[0] & 0x3F);
+		}
+
+		break;
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QOS_Dscp2PcpTableSet(void *cdev, GSW_DSCP2PCP_map_t *parm)
+{
+	pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 reg_index, dscp, bitshift;
+
+	/*This API is used internally,so no spin lock needed*/
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (parm->nIndex > 7) {
+		return GSW_statusErr;
+	}
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+	tbl_prog.table = PCE_DSCP2PCP_INDEX;
+
+	switch (parm->nIndex) {
+	case 0:
+		reg_index = 0;
+		bitshift = 0;
+		break;
+
+	case 1:
+		reg_index = 0;
+		bitshift = 4;
+		break;
+
+	case 2:
+		reg_index = 0;
+		bitshift = 8;
+		break;
+
+	case 3:
+		reg_index = 0;
+		bitshift = 12;
+		break;
+
+	case 4:
+		reg_index = 1;
+		bitshift = 0;
+		break;
+
+	case 5:
+		reg_index = 1;
+		bitshift = 4;
+		break;
+
+	case 6:
+		reg_index = 1;
+		bitshift = 8;
+		break;
+
+	case 7:
+		reg_index = 1;
+		bitshift = 12;
+		break;
+	}
+
+	for (dscp = 0; dscp < 64; dscp++) {
+		CLEAR_U16(tbl_prog.pcindex);
+		/*Table Entry address (DSCP value)*/
+		tbl_prog.pcindex |= (dscp & 0x3F);
+		/*Address-based read - make sure the other pointer values are not disturbed*/
+		tbl_prog.table = PCE_DSCP2PCP_INDEX;
+		gsw_pce_table_read(cdev, &tbl_prog);
+		/*Set map DSCP value to PCP value in PCE_TBL_VAL 0 or PCE_TBL_VAL 1
+		based on DSCP2PCP pointer index*/
+		tbl_prog.val[reg_index] |= ((parm->nMap[dscp] & 0x7) << bitshift);
+		/*Address-based write*/
+		tbl_prog.table = PCE_DSCP2PCP_INDEX;
+		gsw_pce_table_write(cdev, &tbl_prog);
+	}
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_QOS_Dscp2PcpTableGet(void *cdev, GSW_DSCP2PCP_map_t *parm)
+{
+	pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 reg_index, dscp, bitshift;
+
+	/*This API is used internally,so no spin lock needed*/
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (parm->nIndex > 7) {
+		return GSW_statusErr;
+	}
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+
+	switch (parm->nIndex) {
+	case 0:
+		reg_index = 0;
+		bitshift = 0;
+		break;
+
+	case 1:
+		reg_index = 0;
+		bitshift = 4;
+		break;
+
+	case 2:
+		reg_index = 0;
+		bitshift = 8;
+		break;
+
+	case 3:
+		reg_index = 0;
+		bitshift = 12;
+		break;
+
+	case 4:
+		reg_index = 1;
+		bitshift = 0;
+		break;
+
+	case 5:
+		reg_index = 1;
+		bitshift = 4;
+		break;
+
+	case 6:
+		reg_index = 1;
+		bitshift = 8;
+		break;
+
+	case 7:
+		reg_index = 1;
+		bitshift = 12;
+		break;
+	}
+
+	for (dscp = 0; dscp < 64; dscp++) {
+		tbl_prog.table = PCE_DSCP2PCP_INDEX;
+		CLEAR_U16(tbl_prog.pcindex);
+		/*Table Entry address (DSCP value) Bit 5:0 in PCE_TBL_ADDR*/
+		tbl_prog.pcindex |= (dscp & 0x3F);
+		/*Address-based read*/
+		gsw_pce_table_read(cdev, &tbl_prog);
+
+		/*Get Mapped PCP value from PCE_TBL_VAL 0 or PCE_TBL_VAL 1
+		based on DSCP2PCP pointer index*/
+		parm->nMap[dscp] = ((tbl_prog.val[reg_index] >> bitshift) & 0x7);
+	}
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_QOS_PmapperTableSet(void *cdev, GSW_PMAPPER_t *parm)
+{
+	pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 pcp, dscp, entry_index;
+	u32 idx, freeidxfound = 0;
+
+	/*This API is used internally,so no spin lock needed*/
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	/*If P-Mapper ID is invalid ,find a free P-Mapper table index and allocate
+	  New P-Mapper configuration table index*/
+	if (parm->nPmapperId == PMAPPER_ENTRY_INVALID) {
+		for (idx = 0; idx < gswdev->num_of_pmapper && !freeidxfound; idx++) {
+			if (!gswdev->pmapper_idx[idx].IndexInUse) {
+				gswdev->pmapper_idx[idx].IndexInUse = 1;
+				parm->nPmapperId = idx;
+				freeidxfound = 1;
+			}
+		}
+
+		/*No free Slot return Error*/
+		if (!freeidxfound) {
+			pr_err("No P-mapper slot found\n");
+			return GSW_statusErr;
+		}
+	}
+
+	if (parm->nPmapperId >= gswdev->num_of_pmapper) {
+		pr_err("parm->nPmapperId >= gswdev->num_of_pmapper\n");
+		return GSW_statusErr;
+	}
+
+	/*If P-Mapper ID is valid,Check whether it is InUSE
+	  if not InUse,return ERROR*/
+	if (!gswdev->pmapper_idx[parm->nPmapperId].IndexInUse) {
+		pr_err("gswdev->pmapper_idx[parm->nPmapperId].IndexInUse not in use\n");
+		return GSW_statusErr;
+	}
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+	tbl_prog.table = PCE_PMAP_INDEX;
+
+	/*P-mapper MODE 00:The First Entry of each P-mapper index is for Non-IP and Non-VLAN tagging packets
+	  BIT 7:2 in PCE_TBL_ADDR is 0 and BIT 1:0 is 0 for MODE 00
+	*/
+	entry_index = 0;
+	CLEAR_U16(tbl_prog.pcindex);
+	/*Index of P-mapper. */
+	tbl_prog.pcindex |= ((parm->nPmapperId & 0x3f) << 8) ;
+	CLEAR_U16(tbl_prog.val[0]);
+	/*Set Destination sub-interface ID group field in PCE_TBL_VAL 0 (Bit 7:0)*/
+	tbl_prog.val[0] |= (parm->nDestSubIfIdGroup[entry_index] & 0xFF);
+	/*Address-based write*/
+	gsw_pce_table_write(cdev, &tbl_prog);
+
+	/*P-mapper MODE 01:The Entry 8 to 1 of each P-mapper index is for PCP mapping entries
+	  applies to VLAN tagging packet whenP-mapper mapping mode is PCP
+	  BIT 4:2 in PCE_TBL_ADDR is for MODE 01
+	*/
+	entry_index = 1;
+
+	for (pcp = 0; entry_index <= 8; pcp++, entry_index++) {
+		CLEAR_U16(tbl_prog.pcindex);
+		/*P-mapper Mode- PCP mapping 01*/
+		tbl_prog.pcindex |= 1 ;
+		/*Index of P-mapper. */
+		tbl_prog.pcindex |= ((parm->nPmapperId & 0x3f) << 8) ;
+		/*Table Entry address (PCP value)*/
+		tbl_prog.pcindex |= ((pcp & 0x7) << 2);
+		/*Set Destination sub-interface ID group field in PCE_TBL_VAL 0 (Bit 7:0)*/
+		CLEAR_U16(tbl_prog.val[0]);
+		tbl_prog.val[0] |= (parm->nDestSubIfIdGroup[entry_index] & 0xFF);
+		/*Address-based write*/
+		gsw_pce_table_write(cdev, &tbl_prog);
+	}
+
+	/*P-mapper MODE 10:The Entry 72 to 9 of each P-mapper index is for DSCP mapping entries
+	  applies to IP packets without VLAN tag or IP packet with VLAN
+	  BIT 7:2 in PCE_TBL_ADDR is for MODE 10
+	*/
+	entry_index = 9;
+
+	/* TODO: use dscp as for loop index */
+	for (dscp = 0; entry_index <= 72; dscp++, entry_index++) {
+		CLEAR_U16(tbl_prog.pcindex);
+		/*P-mapper Mode- DSCP mapping 10*/
+		tbl_prog.pcindex |= 2 ;
+		/*Index of P-mapper. */
+		tbl_prog.pcindex |= ((parm->nPmapperId & 0x3f) << 8) ;
+		/*Table Entry address (DSCP value)*/
+		tbl_prog.pcindex |= ((dscp & 0x3F) << 2);
+		/*Set Destination sub-interface ID group field in PCE_TBL_VAL 0 (Bit 7:0)*/
+		CLEAR_U16(tbl_prog.val[0]);
+		tbl_prog.val[0] |= (parm->nDestSubIfIdGroup[entry_index] & 0xFF);
+		/*Address-based write*/
+		gsw_pce_table_write(cdev, &tbl_prog);
+	}
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_QOS_PmapperTableGet(void *cdev, GSW_PMAPPER_t *parm)
+{
+	pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 pcp, dscp, entry_index;
+
+	/*This API is used internally,so no spin lock needed*/
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	/*If P-Mapper ID is valid,Check whether it is InUSE
+	  if not InUse,return ERROR*/
+	if (!gswdev->pmapper_idx[parm->nPmapperId].IndexInUse) {
+		pr_err("gswdev->pmapper_idx[parm->nPmapperId].IndexInUse not in use\n");
+		return GSW_statusErr;
+	}
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+
+	/*P-mapper MODE 00:The First Entry of each P-mapper index is for Non-IP and Non-VLAN tagging packets
+	  BIT 7:2 in PCE_TBL_ADDR is 0 and BIT 1:0 is 0 for MODE 00
+	*/
+	entry_index = 0;
+	CLEAR_U16(tbl_prog.pcindex);
+	tbl_prog.table = PCE_PMAP_INDEX;
+	/*Index of P-mapper. */
+	tbl_prog.pcindex |= ((parm->nPmapperId & 0x3f) << 8) ;
+	CLEAR_U16(tbl_prog.val[0]);
+	/*Address-based read*/
+	gsw_pce_table_read(cdev, &tbl_prog);
+	/*Get Destination sub-interface ID group field in PCE_TBL_VAL 0 (Bit 7:0)*/
+	parm->nDestSubIfIdGroup[entry_index] = (tbl_prog.val[0] & 0xFF);
+
+	/*P-mapper MODE 01:The Entry 8 to 1 of each P-mapper index is for PCP mapping entries
+	  applies to VLAN tagging packet whenP-mapper mapping mode is PCP
+	  BIT 4:2 in PCE_TBL_ADDR is for MODE 01
+	*/
+	entry_index = 1;
+
+	for (pcp = 0; entry_index <= 8; pcp++, entry_index++) {
+		tbl_prog.table = PCE_PMAP_INDEX;
+		CLEAR_U16(tbl_prog.pcindex);
+		/*P-mapper Mode- PCP mapping 01*/
+		tbl_prog.pcindex |= 1 ;
+		/*Index of P-mapper. */
+		tbl_prog.pcindex |= ((parm->nPmapperId & 0x3f) << 8) ;
+		/*Table Entry address (PCP value)*/
+		tbl_prog.pcindex |= ((pcp & 0x7) << 2);
+		/*Address-based read*/
+		gsw_pce_table_read(cdev, &tbl_prog);
+		/*Get Destination sub-interface ID group field in PCE_TBL_VAL 0 (Bit 7:0)*/
+		parm->nDestSubIfIdGroup[entry_index] = (tbl_prog.val[0] & 0xFF);
+	}
+
+	/*P-mapper MODE 10:The Entry 72 to 9 of each P-mapper index is for DSCP mapping entries
+	  applies to IP packets without VLAN tag or IP packet with VLAN
+	  BIT 7:2 in PCE_TBL_ADDR is for MODE 10
+	*/
+	entry_index = 9;
+
+	for (dscp = 0; entry_index <= 72; dscp++, entry_index++) {
+		tbl_prog.table = PCE_PMAP_INDEX;
+		CLEAR_U16(tbl_prog.pcindex);
+		/*P-mapper Mode- DSCP mapping 10*/
+		tbl_prog.pcindex |= 2 ;
+		/*Index of P-mapper. */
+		tbl_prog.pcindex |= ((parm->nPmapperId & 0x3f) << 8) ;
+		/*Table Entry address (DSCP value)*/
+		tbl_prog.pcindex |= ((dscp & 0x3F) << 2);
+		/*Address-based read*/
+		gsw_pce_table_read(cdev, &tbl_prog);
+		/*Get Destination sub-interface ID group field in PCE_TBL_VAL 0 (Bit 7:0)*/
+		parm->nDestSubIfIdGroup[entry_index] = (tbl_prog.val[0] & 0xFF);
+	}
+
+	return GSW_statusOk;
+}
+
+static u8 GSW_SearchExVlanContiguousBlock(ethsw_api_dev_t *gswdev, u32 BlockId, u32 NumberOfEntries)
+{
+	u32 i;
+
+	for (i = BlockId; i <= (BlockId + NumberOfEntries); i++) {
+		if (gswdev->extendvlan_idx.vlan_idx[i].IndexInUse)
+			return 0;
+	}
+
+	return 1;
+}
+
+
+GSW_return_t GSW_ExtendedVlanAlloc(void *cdev, GSW_EXTENDEDVLAN_alloc_t *parm)
+{
+
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u16 ExVlanIndex = 0;
+	u8 ContiguousBlockFound = 0;
+	u32 i, ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_alloc);
+#endif
+
+	/*
+		Allocate New Block as per the number of table Entries requested
+		The Block must be allocated with contiguous table index
+	*/
+
+	if (parm->nNumberOfEntries > (gswdev->num_of_extendvlan - gswdev->extendvlan_idx.nUsedEntry)) {
+		pr_err(" nNumberOfEntries requested is more than Exvlan index limit  %s:%s:%d",
+		       __FILE__, __func__, __LINE__);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	for (ExVlanIndex = 0; ExVlanIndex < gswdev->num_of_extendvlan && !ContiguousBlockFound; ExVlanIndex++) {
+		/*Table Index not in use*/
+		if (!gswdev->extendvlan_idx.vlan_idx[ExVlanIndex].IndexInUse) {
+			ContiguousBlockFound = GSW_SearchExVlanContiguousBlock(gswdev, ExVlanIndex, parm->nNumberOfEntries);
+		}
+
+		/*Contiguous block found in the table*/
+		if (ContiguousBlockFound) {
+			parm->nExtendedVlanBlockId = ExVlanIndex;
+
+			/*Mark the contiguous table indexes as InUse and tag it with block id*/
+			for (i = parm->nExtendedVlanBlockId; i < (parm->nExtendedVlanBlockId + parm->nNumberOfEntries); i++) {
+				gswdev->extendvlan_idx.vlan_idx[i].IndexInUse = 1;
+				gswdev->extendvlan_idx.vlan_idx[i].VlanBlockId = parm->nExtendedVlanBlockId;
+				gswdev->extendvlan_idx.nUsedEntry++;
+			}
+		}
+	}
+
+	/*Contiguous block not found in the table*/
+	if (!ContiguousBlockFound) {
+		pr_err(" ContiguousBlockFound %s:%s:%d", __FILE__, __func__, __LINE__);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_alloc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_ExtendedVlanSet(void *cdev, GSW_EXTENDEDVLAN_config_t *parm)
+{
+	static pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 ret, all_entry_match = 0;
+	u8 dscp2pcpmatch_found = 0;
+	u32 idx = 0, dscp2pcp_pointer = 0, dscp = 0, meterid = 0;
+	u32 empty_dscp2pcptblslot_found = 0, bDscp2PcpMapEnable = 0;
+	static GSW_DSCP2PCP_map_t dscp2pcp_get, dscp2pcp_set;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	/* Once the New blk allocated,param->nEntryIndex will decide which index with in this block
+	   has to be set.only one index will be set at a time.
+	   It is users responsibility to set all the index with in this block
+	   by calling GSW_ExtendedVlanSet as many times as required (i.e) param->nNumberOfEntries*/
+	idx = parm->nExtendedVlanBlockId + parm->nEntryIndex;
+
+	if (idx >= gswdev->num_of_extendvlan) {
+		pr_err("ERROR : idx %d >= gswdev->num_of_extendvlan \n", idx);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if (gswdev->extendvlan_idx.vlan_idx[idx].VlanBlockId != parm->nExtendedVlanBlockId) {
+		pr_err("ERROR : VlanBlockId %d != parm->nExtendedVlanBlockId %d \n",
+		       gswdev->extendvlan_idx.vlan_idx[idx].VlanBlockId, parm->nExtendedVlanBlockId);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if (!gswdev->extendvlan_idx.vlan_idx[idx].IndexInUse) {
+		pr_err("ERROR : idx %d not in Use \n", idx);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+	tbl_prog.table = PCE_EXTVLAN_INDEX;
+	CLEAR_U16(tbl_prog.pcindex);
+	/*Table Entry address (Egress VLAN treatment index) Bit 9:0 in PCE_TBL_ADDR*/
+	tbl_prog.pcindex |= (idx & 0x3FF);
+
+	/** Extended VLAN Table Filter **/
+	/*Program Outer VLAN Filter*/
+	switch (parm->sFilter.sOuterVlan.eType) {
+	/** There is tag and criteria applies. */
+	case GSW_EXTENDEDVLAN_FILTER_TYPE_NORMAL:
+		CLEAR_U16(tbl_prog.key[1]);
+		CLEAR_U16(tbl_prog.key[0]);
+
+		if (parm->sFilter.sOuterVlan.bPriorityEnable) {
+			/*Filter on outer priority
+			  PCP value key 1 BIT 15:12*/
+			tbl_prog.key[1] |= ((parm->sFilter.sOuterVlan.nPriorityVal & 0x7) << 12);
+		} else {
+			/*Do not filter on outer priority
+			Filter Outer PCP key 1 BIT 15:12 set to 8 */
+			tbl_prog.key[1] |= (8 << 12);
+		}
+
+		if (parm->sFilter.sOuterVlan.bVidEnable) {
+			/*Do filter on outer VID
+			  Filter Outer VID (Total 13 bits)
+			  key 0 BIT 15
+			  key 1 BIT 11:0
+			  Set nVidVal
+			*/
+			tbl_prog.key[0] |= ((parm->sFilter.sOuterVlan.nVidVal & 0x1) << 15);
+			tbl_prog.key[1] |= ((parm->sFilter.sOuterVlan.nVidVal & 0x1FFE) >> 1);
+		} else {
+			/*Do not filter on outer VID
+			Filter Outer VID (Total 13 bits)
+			key 0 BIT 15
+			key 1 BIT 11:0
+			Set 4096
+			*/
+			tbl_prog.key[0] |= ((4096 & 0x1) << 15);
+			tbl_prog.key[1] |= ((4096 & 0x1FFE) >> 1);
+		}
+
+		/*Filter out outer TPID/DEI*/
+		switch (parm->sFilter.sOuterVlan.eTpid) {
+		/** Do not filter TPID. */
+		case GSW_EXTENDEDVLAN_FILTER_TPID_NO_FILTER:
+			/*Do not filter on outer TPID
+			  Filter Outer TPID key 0 BIT 14:12 set to 0 */
+			tbl_prog.key[0] &= ~(7 << 12);
+			break;
+
+		/** TPID is 0x8100. key 0 BIT 14:12 set 4*/
+		case GSW_EXTENDEDVLAN_FILTER_TPID_8021Q:
+			tbl_prog.key[0] |= (4 << 12);
+			break;
+
+		/** TPID is global configured value. */
+		case GSW_EXTENDEDVLAN_FILTER_TPID_VTETYPE:
+			switch (parm->sFilter.sOuterVlan.eDei) {
+			/** Do not filter (don't care) key 0 BIT 14:12 set 5 */
+			case GSW_EXTENDEDVLAN_FILTER_DEI_NO_FILTER:
+				tbl_prog.key[0] |= (5 << 12);
+				break;
+
+			/** DEI=0 key 0 BIT 14:12 set 6 */
+			case GSW_EXTENDEDVLAN_FILTER_DEI_0:
+				tbl_prog.key[0] |= (6 << 12);
+				break;
+
+			/** DEI=1 key 0 BIT 14:12 set 7 */
+			case GSW_EXTENDEDVLAN_FILTER_DEI_1:
+				tbl_prog.key[0] |= (7 << 12);
+				break;
+			}
+
+			break;
+		}
+
+		break;
+
+	/** There is tag but no criteria. */
+	case GSW_EXTENDEDVLAN_FILTER_TYPE_NO_FILTER:
+		CLEAR_U16(tbl_prog.key[1]);
+		CLEAR_U16(tbl_prog.key[0]);
+
+		/*Do not filter on outer priority
+		  Filter Outer PCP key 1 BIT 15:12 set to 8 */
+		tbl_prog.key[1] |= (8 << 12);
+
+		/*Do not filter on outer VID
+		  Filter Outer VID (Total 13 bits)
+		  key 0 BIT 15
+		  key 1 BIT 11:0
+		  Set 4096
+		*/
+		tbl_prog.key[0] |= ((4096 & 0x1) << 15);
+		tbl_prog.key[1] |= ((4096 & 0x1FFE) >> 1);
+
+		/*Do not filter on outer TPID
+		  Filter Outer PCP key 0 BIT 14:12 set to 0 */
+		tbl_prog.key[0] &= ~(7 << 12);
+		break;
+
+	/** Default entry if no other rule applies. */
+	case GSW_EXTENDEDVLAN_FILTER_TYPE_DEFAULT:
+		CLEAR_U16(tbl_prog.key[1]);
+		/*Default entry if no other rule applies
+		  Filter Outer PCP key 1 BIT 15:12 set to 14 */
+		tbl_prog.key[1] |= (14 << 12);
+		break;
+
+	/** There is no tag. */
+	case GSW_EXTENDEDVLAN_FILTER_TYPE_NO_TAG:
+		CLEAR_U16(tbl_prog.key[1]);
+		/*No Outer Tag
+		  Filter Outer PCP key 1 BIT 15:12 set to 15 */
+		tbl_prog.key[1] |= (15 << 12);
+		break;
+
+	case GSW_EXTENDEDVLAN_BLOCK_INVALID:
+		CLEAR_U16(tbl_prog.key[1]);
+		/*SET BLOCK INVALID - should be set only on outer priority filter
+		  Filter Outer PCP key 1 BIT 15:12 set to 13 */
+		tbl_prog.key[1] |= (13 << 12);
+		break;
+
+	default:
+		break;
+	}
+
+	/*Program inner VLAN Filter*/
+	switch (parm->sFilter.sInnerVlan.eType) {
+	/** There is tag and criteria applies. */
+	case GSW_EXTENDEDVLAN_FILTER_TYPE_NORMAL:
+		CLEAR_U16(tbl_prog.key[3]);
+		CLEAR_U16(tbl_prog.key[2]);
+
+		if (parm->sFilter.sInnerVlan.bPriorityEnable) {
+			/*Filter on inner priority
+			  PCP value key 3 BIT 15:12*/
+			tbl_prog.key[3] |= ((parm->sFilter.sInnerVlan.nPriorityVal & 0x7) << 12);
+		} else {
+			/*Do not filter on inner priority
+			Filter inner PCP key 3 BIT 15:12 set to 8 */
+			tbl_prog.key[3] |= (8 << 12);
+		}
+
+		if (parm->sFilter.sInnerVlan.bVidEnable) {
+			/*Do not filter on inner VID
+			  Filter inner VID (Total 13 bits)
+			  key 2 BIT 15
+			  key 3 BIT 11:0
+			  Set nVidVal
+			*/
+			tbl_prog.key[2] |= ((parm->sFilter.sInnerVlan.nVidVal & 0x1) << 15);
+			tbl_prog.key[3] |= ((parm->sFilter.sInnerVlan.nVidVal & 0x1FFE) >> 1);
+		} else {
+			/*Do not filter on inner VID
+			 Filter inner VID (Total 13 bits)
+			 key 2 BIT 15
+			 key 3 BIT 11:0
+			 Set 4096
+			*/
+			tbl_prog.key[2] |= ((4096 & 0x1) << 15);
+			tbl_prog.key[3] |= ((4096 & 0x1FFE) >> 1);
+		}
+
+		/*Filter out inner TPID/DEI*/
+		switch (parm->sFilter.sInnerVlan.eTpid) {
+		/** Do not filter TPID. */
+		case GSW_EXTENDEDVLAN_FILTER_TPID_NO_FILTER:
+			/*Do not filter on inner TPID
+			  Filter inner TPID key 2 BIT 14:12 set to 0 */
+			tbl_prog.key[2] &= ~(7 << 12);
+			break;
+
+		/** TPID is 0x8100. key 2 BIT 14:12 set 4*/
+		case GSW_EXTENDEDVLAN_FILTER_TPID_8021Q:
+			tbl_prog.key[2] |= (4 << 12);
+			break;
+
+		/** TPID is global configured value. */
+		case GSW_EXTENDEDVLAN_FILTER_TPID_VTETYPE:
+			switch (parm->sFilter.sInnerVlan.eDei) {
+			/** Do not filter (don't care) key 2 BIT 14:12 set 5 */
+			case GSW_EXTENDEDVLAN_FILTER_DEI_NO_FILTER:
+				tbl_prog.key[2] |= (5 << 12);
+				break;
+
+			/** DEI=0 key 2 BIT 14:12 set 6 */
+			case GSW_EXTENDEDVLAN_FILTER_DEI_0:
+				tbl_prog.key[2] |= (6 << 12);
+				break;
+
+			/** DEI=1 key 2 BIT 14:12 set 7 */
+			case GSW_EXTENDEDVLAN_FILTER_DEI_1:
+				tbl_prog.key[2] |= (7 << 12);
+				break;
+			}
+
+			break;
+		}
+
+		break;
+
+	/** There is tag but no criteria. */
+	case GSW_EXTENDEDVLAN_FILTER_TYPE_NO_FILTER:
+		CLEAR_U16(tbl_prog.key[3]);
+		CLEAR_U16(tbl_prog.key[2]);
+
+		/*Do not filter on inner priority
+		  Filter inner PCP key 3 BIT 15:12 set to 8 */
+		tbl_prog.key[3] |= (8 << 12);
+
+		/*Do not filter on inner VID
+		  Filter inner VID (Total 13 bits)
+		  key 2 BIT 15
+		  key 3 BIT 11:0
+		  Set 4096
+		*/
+		tbl_prog.key[2] |= ((4096 & 0x1) << 15);
+		tbl_prog.key[3] |= ((4096 & 0x1FFE) >> 1);
+
+		/*Do not filter on inner TPID
+		  Filter inner PCP key 2 BIT 14:12 set to 0 */
+		tbl_prog.key[2] &= ~(7 << 12);
+		break;
+
+	/** Default entry if no other rule applies. */
+	case GSW_EXTENDEDVLAN_FILTER_TYPE_DEFAULT:
+		CLEAR_U16(tbl_prog.key[3]);
+
+		/*Default entry if no other rule applies
+		  Filter inner PCP key 3 BIT 15:12 set to 14 */
+		tbl_prog.key[3] |= (14 << 12);
+		break;
+
+	/** There is no tag. */
+	case GSW_EXTENDEDVLAN_FILTER_TYPE_NO_TAG:
+		CLEAR_U16(tbl_prog.key[3]);
+		/*No inner Tag
+		  Filter inner PCP key 3 BIT 15:12 set to 15 */
+		tbl_prog.key[3] |= (15 << 12);
+		break;
+
+	default:
+		break;
+	}
+
+	/*Filter Ether type key 2 BIT 4:0*/
+	tbl_prog.key[2] &= ~(0x1F);
+
+	switch (parm->sFilter.eEtherType) {
+	/** Do not filter Ether Type*/
+	case GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_NO_FILTER:
+		tbl_prog.key[2] |= 0;
+		break;
+
+	/** IPoE frame (Ethertyp is 0x0800). */
+	case GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_IPOE:
+		tbl_prog.key[2] |= 1;
+		break;
+
+	/** PPPoE frame (Ethertyp is 0x8863 or 0x8864). */
+	case GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_PPPOE:
+		tbl_prog.key[2] |= 2;
+		break;
+
+	/** ARP frame (Ethertyp is 0x0806). */
+	case GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_ARP:
+		tbl_prog.key[2] |= 3;
+		break;
+
+	/** IPv6 IPoE frame (Ethertyp is 0x86DD). */
+	case GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_IPV6IPOE:
+		tbl_prog.key[2] |= 4;
+		break;
+
+	/** EAPOL (Ethertyp is 0x888E). */
+	case GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_EAPOL :
+		tbl_prog.key[2] |= 5;
+		break;
+
+	}
+
+
+
+	/** Extended VLAN Table Treatment **/
+
+	/** Number of VLAN tag to remove. val 1 BIT 15:14*/
+	tbl_prog.val[1] &= ~(0xC000);
+
+	switch (parm->sTreatment.eRemoveTag) {
+	/* Do not remove VLAN tag. set 0 */
+	case GSW_EXTENDEDVLAN_TREATMENT_NOT_REMOVE_TAG:
+		tbl_prog.val[1] &= ~(0xC000);
+		break;
+
+	/* Remove 1 VLAN tag following DA/SA. set 1*/
+	case GSW_EXTENDEDVLAN_TREATMENT_REMOVE_1_TAG:
+		tbl_prog.val[1] |= (1 << 14);
+		break;
+
+	/* Remove 2 VLAN tag following DA/SA. set 2*/
+	case GSW_EXTENDEDVLAN_TREATMENT_REMOVE_2_TAG:
+		tbl_prog.val[1] |= (2 << 14);
+		break;
+
+	/* Discard upstream traffic. set 3*/
+	case GSW_EXTENDEDVLAN_TREATMENT_DISCARD_UPSTREAM:
+		tbl_prog.val[1] |= (3 << 14);
+		break;
+	}
+
+	/** Enable outer VLAN tag add/modification. */
+	if (parm->sTreatment.bAddOuterVlan) {
+		/*Treatment for outer Priority val 1 BIT 3:0*/
+		tbl_prog.val[1] &= ~(0xF);
+
+		switch (parm->sTreatment.sOuterVlan.ePriorityMode) {
+		/* Add an Outer Tag and set priority with given value. */
+		case GSW_EXTENDEDVLAN_TREATMENT_PRIORITY_VAL:
+			tbl_prog.val[1] |= (parm->sTreatment.sOuterVlan.ePriorityVal & 0x7);
+			break;
+
+		/* Add an Outer Tag and Priority value is copied from inner VLAN tag of received packet. set 8*/
+		case GSW_EXTENDEDVLAN_TREATMENT_INNER_PRORITY:
+			tbl_prog.val[1] |= 8;
+			break;
+
+		/*Add an Outer Tag and Priority value is copied from outer VLAN tag of received packet. set 9 */
+		case GSW_EXTENDEDVLAN_TREATMENT_OUTER_PRORITY:
+			tbl_prog.val[1] |= 9;
+			break;
+
+		/* Add an Outer Tag and Priority value is derived from DSCP field of received packet. set 10
+		   Priority Value is set as per DSCP to PCP mapping attribute*/
+		case GSW_EXTENDEDVLAN_TREATMENT_DSCP:
+			tbl_prog.val[1] |= 10;
+			bDscp2PcpMapEnable = 1;
+			break;
+		}
+
+		/*Treatment for outer VID val 0 BIT 15:3*/
+		tbl_prog.val[0] &= ~(0xFFF8);
+
+		switch (parm->sTreatment.sOuterVlan.eVidMode) {
+		/* Set VID with given value. */
+		case GSW_EXTENDEDVLAN_TREATMENT_VID_VAL:
+			tbl_prog.val[0] |= ((parm->sTreatment.sOuterVlan.eVidVal & 0xFFF) << 3);
+			break;
+
+		/* VID is copied from inner VLAN tag of received packet. set 4096*/
+		case GSW_EXTENDEDVLAN_TREATMENT_INNER_VID:
+			tbl_prog.val[0] |= (4096 << 3);
+			break;
+
+		/* VID is copied from outer VLAN tag of received packet.set 4097 */
+		case GSW_EXTENDEDVLAN_TREATMENT_OUTER_VID:
+			tbl_prog.val[0] |= (4097 << 3);
+			break;
+		}
+
+		/*Treatment for outer TPID/DEI val 0 BIT 2:0*/
+		tbl_prog.val[0] &= ~(0x7);
+
+		switch (parm->sTreatment.sOuterVlan.eTpid) {
+		/* TPID is copied from inner VLAN tag of received packet.set 0 */
+		case GSW_EXTENDEDVLAN_TREATMENT_INNER_TPID:
+			tbl_prog.val[0] &= ~(0x7);
+			break;
+
+		/* TPID is copied from outer VLAN tag of received packet. set 1*/
+		case GSW_EXTENDEDVLAN_TREATMENT_OUTER_TPID:
+			tbl_prog.val[0] |= 1;
+			break;
+
+		/* TPID is 0x8100. */
+		case GSW_EXTENDEDVLAN_TREATMENT_8021Q:
+			tbl_prog.val[0] |= 4;
+			break;
+
+		/* TPID is global configured value. */
+		case GSW_EXTENDEDVLAN_TREATMENT_VTETYPE:
+			switch (parm->sTreatment.sOuterVlan.eDei) {
+			/* DEI (if applicable) is copied from inner VLAN tag of received packet. set 2*/
+			case GSW_EXTENDEDVLAN_TREATMENT_INNER_DEI:
+				tbl_prog.val[0] |= 2;
+				break;
+
+			/* DEI (if applicable) is copied from outer VLAN tag of received packet. set 3*/
+			case GSW_EXTENDEDVLAN_TREATMENT_OUTER_DEI:
+				tbl_prog.val[0] |= 3;
+				break;
+
+			/* DEI is 0. set 6*/
+			case GSW_EXTENDEDVLAN_TREATMENT_DEI_0:
+				tbl_prog.val[0] |= 6;
+				break;
+
+			/* DEI is 1. set 7*/
+			case GSW_EXTENDEDVLAN_TREATMENT_DEI_1:
+				tbl_prog.val[0] |= 7;
+				break;
+			}
+
+			break;
+		}
+
+		/*	}*/
+	} else {
+		/*DO Not Add an Outer Tag. val 1 BIT 3:0 set 15*/
+		tbl_prog.val[1] &= ~(0xF);
+		tbl_prog.val[1] |= 15;
+	}
+
+	/** Enable inner VLAN tag add/modification. */
+	if (parm->sTreatment.bAddInnerVlan) {
+		/*Treatment for inner Priority val 3 BIT 3:0*/
+		tbl_prog.val[3] &= ~(0xF);
+
+		switch (parm->sTreatment.sInnerVlan.ePriorityMode) {
+		/* Add an inner Tag and set priority with given value. */
+		case GSW_EXTENDEDVLAN_TREATMENT_PRIORITY_VAL:
+			tbl_prog.val[3] |= (parm->sTreatment.sInnerVlan.ePriorityVal & 0x7);
+			break;
+
+		/* Add an inner Tag and Priority value is copied from inner VLAN tag of received packet. set 8*/
+		case GSW_EXTENDEDVLAN_TREATMENT_INNER_PRORITY:
+			tbl_prog.val[3] |= 8;
+			break;
+
+		/*Add an inner Tag and Priority value is copied from outer VLAN tag of received packet. set 9 */
+		case GSW_EXTENDEDVLAN_TREATMENT_OUTER_PRORITY:
+			tbl_prog.val[3] |= 9;
+			break;
+
+		/* Add an inner Tag and Priority value is derived from DSCP field of received packet. set 10
+		   Priority Value is set as per DSCP to PCP mapping attribute*/
+		case GSW_EXTENDEDVLAN_TREATMENT_DSCP:
+			tbl_prog.val[3] |= 10;
+			bDscp2PcpMapEnable = 1;
+			break;
+		}
+
+		/*Treatment for inner VID val 2 BIT 15:3*/
+		tbl_prog.val[2] &= ~(0xFFF8);
+
+		switch (parm->sTreatment.sInnerVlan.eVidMode) {
+		/* Set VID with given value. */
+		case GSW_EXTENDEDVLAN_TREATMENT_VID_VAL:
+			tbl_prog.val[2] |= ((parm->sTreatment.sInnerVlan.eVidVal & 0xFFF) << 3);
+			break;
+
+		/* VID is copied from inner VLAN tag of received packet. set 4096*/
+		case GSW_EXTENDEDVLAN_TREATMENT_INNER_VID:
+			tbl_prog.val[2] |= (4096 << 3);
+			break;
+
+		/* VID is copied from outer VLAN tag of received packet.set 4097 */
+		case GSW_EXTENDEDVLAN_TREATMENT_OUTER_VID:
+			tbl_prog.val[2] |= (4097 << 3);
+			break;
+		}
+
+		/*Treatment for inner TPID/DEI val 2 BIT 2:0*/
+		tbl_prog.val[2] &= ~(0x7);
+
+		switch (parm->sTreatment.sInnerVlan.eTpid) {
+		/* TPID is copied from inner VLAN tag of received packet.set 0 */
+		case GSW_EXTENDEDVLAN_TREATMENT_INNER_TPID:
+			tbl_prog.val[2] &= ~(0x7);
+			break;
+
+		/* TPID is copied from outer VLAN tag of received packet. set 1*/
+		case GSW_EXTENDEDVLAN_TREATMENT_OUTER_TPID:
+			tbl_prog.val[2] |= 1;
+			break;
+
+		/* TPID is 0x8100. */
+		case GSW_EXTENDEDVLAN_TREATMENT_8021Q:
+			tbl_prog.val[2] |= 4;
+			break;
+
+		/* TPID is global configured value. */
+		case GSW_EXTENDEDVLAN_TREATMENT_VTETYPE:
+			switch (parm->sTreatment.sInnerVlan.eDei) {
+			/* DEI (if applicable) is copied from inner VLAN tag of received packet. set 2*/
+			case GSW_EXTENDEDVLAN_TREATMENT_INNER_DEI:
+				tbl_prog.val[2] |= 2;
+				break;
+
+			/* DEI (if applicable) is copied from outer VLAN tag of received packet. set 3*/
+			case GSW_EXTENDEDVLAN_TREATMENT_OUTER_DEI:
+				tbl_prog.val[2] |= 3;
+				break;
+
+			/* DEI is 0. set 6*/
+			case GSW_EXTENDEDVLAN_TREATMENT_DEI_0:
+				tbl_prog.val[2] |= 6;
+				break;
+
+			/* DEI is 1. set 7*/
+			case GSW_EXTENDEDVLAN_TREATMENT_DEI_1:
+				tbl_prog.val[2] |= 7;
+				break;
+			}
+
+			break;
+		}
+
+		/*}*/
+	} else {
+		/*DO Not Add an inner Tag. val 3 BIT 3:0 set 15*/
+		tbl_prog.val[3] &= ~(0xF);
+		tbl_prog.val[3] |= 15;
+	}
+
+	/** Treatment Bridge port
+		val 4 BIT 8 to enable new bridge port treatment
+		val 4 BIT 7:0 for new bridge port id
+	**/
+	tbl_prog.val[4] &= ~(0x1FF);
+
+	/*(0..127 no action and 128..255 re-assign bridge port id*/
+	if (parm->sTreatment.bReassignBridgePort) {
+		tbl_prog.val[4] |= (1 << 8);
+		tbl_prog.val[4] |= (parm->sTreatment.nNewBridgePortId & 0xFF);
+	}
+
+	/** Treatment DSCP
+		val 4 BIT 15 to enable new DSCP treatment
+		val 4 BIT 14:9 for new DSCP value
+	**/
+	tbl_prog.val[4] &= ~(0xFE00);
+
+	/*(0..63 no action and 64..127 New DSCP in bit 5 to 0*/
+	if (parm->sTreatment.bNewDscpEnable) {
+		tbl_prog.val[4] |= (1 << 15);
+		tbl_prog.val[4] |= ((parm->sTreatment.nNewDscp & 0x3F) << 9);
+	}
+
+	/** Treatment Traffic Class
+		val 5 BIT 13 to enable new Traffic class treatment
+		val 5 BIT 12:9 for new Traffic class value
+	**/
+	tbl_prog.val[5] &= ~(0x3E00);
+
+	/*(0..15 no action and 16..31 New Traffic class in bit 3 to 0*/
+	if (parm->sTreatment.bNewTrafficClassEnable) {
+		tbl_prog.val[5] |= (1 << 13);
+		tbl_prog.val[5] |= ((parm->sTreatment.nNewTrafficClass & 0xF) << 9);
+	}
+
+	/** Treatment Metering
+		val 5 BIT 8 to enable Metering
+		val 5 BIT 7:0 for New Meter ID
+	**/
+	tbl_prog.val[5] &= ~(0x1FF);
+
+	/* New meter ID TODO - KEEP CHECK on METERID.
+	Meter should be allocated with \ref GSW_QOS_METER_ALLOC before extended
+	VLAN treatment is added. If this extended VLAN treatment is deleted,
+	this meter should be released with \ref GSW_QOS_METER_FREE.
+	*/
+	if (parm->sTreatment.bNewMeterEnable) {
+		meterid = parm->sTreatment.sNewTrafficMeterId;
+		/*This below field enable indicates that this meter id is
+		 already assigned and it's idx recorded for this Exvlan tbl.
+		 If next time the user update this meter field with different meter idx !!
+		 or wanted to allocate a new meter idx ??!! may happen by mistake ??!!
+		 the previous meter idx must be released from this Exvlan tbl*/
+
+		if (gswdev->extendvlan_idx.vlan_idx[idx].MeterAssigned) {
+			if (gswdev->extendvlan_idx.vlan_idx[idx].MeterId !=
+			    meterid) {
+				/*release the usage of previous meter idx*/
+				gswdev->meter_idx[gswdev->extendvlan_idx.vlan_idx[idx].MeterId].IndexInUsageCnt--;
+				gswdev->extendvlan_idx.vlan_idx[idx].MeterAssigned = 0;
+				gswdev->extendvlan_idx.vlan_idx[idx].MeterId = 0;
+			}
+		}
+
+		/*This Meter ID should be in use (i.e) that is this Meter ID should be allocated
+		before calling Exvlan configuration
+		If not in use return ERROR
+		*/
+		if (gswdev->meter_idx[meterid].IndexInUse) {
+			/*Usage count will be incremented only once during meter idx assignment
+			for this Exvlan id*/
+			if (!gswdev->extendvlan_idx.vlan_idx[idx].MeterAssigned) {
+				gswdev->extendvlan_idx.vlan_idx[idx].MeterAssigned = 1;
+				gswdev->extendvlan_idx.vlan_idx[idx].MeterId
+					= meterid;
+				/*Since this meter id can be shared,Increment the it's usage count*/
+				gswdev->meter_idx[meterid].IndexInUsageCnt++;
+			}
+
+			tbl_prog.val[5] |= (1 << 8);
+			tbl_prog.val[5] |= (parm->sTreatment.sNewTrafficMeterId & 0xFF);
+		} else {
+			pr_err("ERROR :Meter Id %d not alocated,Call Meter Alloc before Exvlan configuration\n", meterid);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+
+		}
+	}
+
+	/** Enable loopback. val 5 BIT 14*/
+	tbl_prog.val[5] &= ~(0x4000);
+
+	if (parm->sTreatment.bLoopbackEnable)
+		tbl_prog.val[5] |= (1 << 14);
+
+	/** Enable destination/source MAC address swap. val 5 BIT 15*/
+	tbl_prog.val[5] &= ~(0x8000);
+
+	if (parm->sTreatment.bDaSaSwapEnable)
+		tbl_prog.val[5] |= (1 << 15);
+
+	/** Enable traffic mirrored to the monitoring port. val 3 BIT 15 */
+	tbl_prog.val[3] &= ~(0x8000);
+
+	if (parm->sTreatment.bMirrorEnable)
+		tbl_prog.val[3] |= (1 << 15);
+
+	/** Treatment for DSCP2PCP **/
+	if (bDscp2PcpMapEnable) {
+		/* Check for match in DSCP2PCP Map for each index - 0 to 7 DSCP2PCP pointers*/
+		dscp2pcpmatch_found = 0;
+
+		for (idx = 0; idx <= 7 && !dscp2pcpmatch_found; idx++) {
+			/*Check only the dscp2pcp pointer which is in InUse*/
+			if (gswdev->dscp2pcp_idx[idx].IndexInUse &&
+			    gswdev->dscp2pcp_idx[idx].IndexInUsageCnt) {
+				memset(&dscp2pcp_get, 0, sizeof(GSW_DSCP2PCP_map_t));
+				dscp2pcp_get.nIndex = idx;
+				ret = GSW_QOS_Dscp2PcpTableGet(cdev, &dscp2pcp_get);
+
+				if (ret == GSW_statusErr) {
+					pr_err("ERROR: GSW_QOS_Dscp2PcpTableGet");
+					goto UNLOCK_AND_RETURN;
+				}
+
+				/*check and compare DSCP 0 to 63 entry address's pcp value*/
+				all_entry_match = 1;
+
+				for (dscp = 0; dscp < 64 && all_entry_match; dscp++) {
+					if (parm->sTreatment.nDscp2PcpMap[dscp] != dscp2pcp_get.nMap[dscp])
+						all_entry_match = 0;
+				}
+
+				/*All dscp 0 to 63 entry address's pcp value match for this pointer/idx
+				 Record this dscp2pcp pointer*/
+				if (all_entry_match) {
+					dscp2pcp_pointer = idx;
+					dscp2pcpmatch_found = 1;
+					pr_err("dscp2pcpmatch_found : dscp2pcp_pointer = %d\n", dscp2pcp_pointer);
+				}
+			}
+		}
+
+		if (!dscp2pcpmatch_found) {
+			/*If no match found in the dscp2pcp table,search for an empty slot*/
+			for (idx = 0; idx <= 7 && !empty_dscp2pcptblslot_found; idx++) {
+				if (!gswdev->dscp2pcp_idx[idx].IndexInUse &&
+				    gswdev->dscp2pcp_idx[idx].IndexInUsageCnt == 0) {
+					empty_dscp2pcptblslot_found = 1;
+					dscp2pcp_pointer = idx;
+				}
+			}
+
+			/*If the empty slot found,allocate and set the sTreatment.nDscp2PcpMap[64] to
+			  corresponding dscp2pcp table index
+			*/
+			if (empty_dscp2pcptblslot_found) {
+				pr_err("empty_dscp2pcptblslot_found : dscp2pcp_pointer = %d\n", dscp2pcp_pointer);
+				memcpy(dscp2pcp_set.nMap, parm->sTreatment.nDscp2PcpMap, (sizeof(u8) * 64));
+				dscp2pcp_set.nIndex = dscp2pcp_pointer;
+				ret = GSW_QOS_Dscp2PcpTableSet(cdev, &dscp2pcp_set);
+
+				if (ret == GSW_statusErr) {
+					pr_err("ERROR: GSW_QOS_Dscp2PcpTableSet\n");
+					goto UNLOCK_AND_RETURN;
+				}
+			} else {
+				pr_err("dscp2pcp table full\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		}
+
+		/*This below field enable indicates that this dscp2pcp pointer is
+		 already assigned and it's idx recorded for this Extended Vlan index.
+		 If next time user calls EXVlanAdd again for same idx with different
+		 nDscp2PcpMap array value!!
+		 may happen by mistake ??!!
+		 the search may give different pointer or allocate new pointer ??!!
+		 so the previous dscp2pcp pointer must be released from this
+		 Extended VLAN idx*/
+		idx = parm->nExtendedVlanBlockId + parm->nEntryIndex;
+
+		if (gswdev->extendvlan_idx.vlan_idx[idx].Dscp2PcpPointerAssigned) {
+			int old_dscp2pcp_pointer;
+
+			if (gswdev->extendvlan_idx.vlan_idx[idx].Dscp2PcpPointer !=
+			    dscp2pcp_pointer) {
+				old_dscp2pcp_pointer = gswdev->extendvlan_idx.vlan_idx[idx].Dscp2PcpPointer;
+				/*release the usage of previous DSCP2PCP pointer*/
+				gswdev->dscp2pcp_idx[old_dscp2pcp_pointer].IndexInUsageCnt--;
+
+				if (gswdev->dscp2pcp_idx[old_dscp2pcp_pointer].IndexInUsageCnt
+				    == 0) {
+					gswdev->dscp2pcp_idx[old_dscp2pcp_pointer].IndexInUse = 0;
+				}
+
+				gswdev->extendvlan_idx.vlan_idx[idx].Dscp2PcpPointerAssigned = 0;
+				gswdev->extendvlan_idx.vlan_idx[idx].Dscp2PcpPointer = 0;
+			}
+		}
+
+		/*Treatment DSCP2PCP pointer-VAL 3 BIT 6:4.
+		  Set the recorded 0..7 dscp2pcp pointer*/
+		tbl_prog.val[3] &= ~(0x70);
+		tbl_prog.val[3] |= ((dscp2pcp_pointer & 0x7) << 4);
+
+		/* dscp2pcp pointer usage count can be incremented only once for this vlan idx*/
+		if (!gswdev->extendvlan_idx.vlan_idx[idx].Dscp2PcpPointerAssigned) {
+			gswdev->extendvlan_idx.vlan_idx[idx].Dscp2PcpPointerAssigned = 1;
+			gswdev->extendvlan_idx.vlan_idx[idx].Dscp2PcpPointer
+				= dscp2pcp_pointer;
+			/*Since this DSCP2PCP can be shared,Increment the it's usage count*/
+			gswdev->dscp2pcp_idx[dscp2pcp_pointer].IndexInUse = 1;
+			gswdev->dscp2pcp_idx[dscp2pcp_pointer].IndexInUsageCnt++;
+		}
+	}
+
+	/*Address-based write*/
+	gsw_pce_table_write(cdev, &tbl_prog);
+	ret = GSW_statusOk;
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_ExtendedVlanGet(void *cdev, GSW_EXTENDEDVLAN_config_t *parm)
+{
+	pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 ret = 0;
+	u32 idx = 0, dscp2pcp_pointer, tpid_dei, ethtype, removetag;
+	u32 bDscp2PcpMapEnable = 0;
+	GSW_DSCP2PCP_map_t dscp2pcp_get;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	idx = parm->nExtendedVlanBlockId + parm->nEntryIndex;
+
+	if (idx >= gswdev->num_of_extendvlan) {
+		pr_err("ERROR : idx %d >= gswdev->num_of_extendvlan \n", idx);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*Index does not belongs to this ExtendedVlanBlock*/
+	if (gswdev->extendvlan_idx.vlan_idx[idx].VlanBlockId != parm->nExtendedVlanBlockId) {
+		pr_err("ERROR : VlanBlockId %d != parm->nExtendedVlanBlockId %d \n",
+		       gswdev->extendvlan_idx.vlan_idx[idx].VlanBlockId, parm->nExtendedVlanBlockId);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*Index is not in USE*/
+	if (!gswdev->extendvlan_idx.vlan_idx[idx].IndexInUse) {
+		pr_err("ERROR : idx %d not in Use \n", idx);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+	tbl_prog.table = PCE_EXTVLAN_INDEX;
+	CLEAR_U16(tbl_prog.pcindex);
+	/*Table Entry address (Egress VLAN treatment index) Bit 9:0 in PCE_TBL_ADDR*/
+	tbl_prog.pcindex |= (idx & 0x3FF);
+	/*Address-based read*/
+	gsw_pce_table_read(cdev, &tbl_prog);
+
+	/*Get Outer VLAn Filter*/
+	parm->sFilter.sOuterVlan.nPriorityVal = ((tbl_prog.key[1] >> 12) & 0xf);
+	parm->sFilter.sOuterVlan.nVidVal |= ((tbl_prog.key[0] & 0x8000) >> 15);
+	parm->sFilter.sOuterVlan.nVidVal |= ((tbl_prog.key[1] & 0xFFF) << 1);
+	tpid_dei = ((tbl_prog.key[0] & 0x7000) >> 12);
+
+	if (parm->sFilter.sOuterVlan.nPriorityVal == 8 &&
+	    parm->sFilter.sOuterVlan.nVidVal == 4096 &&
+	    tpid_dei == 0) {
+		parm->sFilter.sOuterVlan.eType = GSW_EXTENDEDVLAN_FILTER_TYPE_NO_FILTER;
+		parm->sFilter.sOuterVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_NO_FILTER;
+		parm->sFilter.sOuterVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_NO_FILTER;
+		parm->sFilter.sOuterVlan.bVidEnable = 0;
+		parm->sFilter.sOuterVlan.bPriorityEnable = 0;
+	} else if (parm->sFilter.sOuterVlan.nPriorityVal == 14) {
+		parm->sFilter.sOuterVlan.eType = GSW_EXTENDEDVLAN_FILTER_TYPE_DEFAULT;
+		parm->sFilter.sOuterVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_NO_FILTER;
+		parm->sFilter.sOuterVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_NO_FILTER;
+		parm->sFilter.sOuterVlan.bVidEnable = 0;
+		parm->sFilter.sOuterVlan.bPriorityEnable = 0;
+	} else if (parm->sFilter.sOuterVlan.nPriorityVal == 15) {
+		parm->sFilter.sOuterVlan.eType = GSW_EXTENDEDVLAN_FILTER_TYPE_NO_TAG;
+		parm->sFilter.sOuterVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_NO_FILTER;
+		parm->sFilter.sOuterVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_NO_FILTER;
+		parm->sFilter.sOuterVlan.bVidEnable = 0;
+		parm->sFilter.sOuterVlan.bPriorityEnable = 0;
+	} else if (parm->sFilter.sOuterVlan.nPriorityVal == 13) {
+		parm->sFilter.sOuterVlan.eType = GSW_EXTENDEDVLAN_BLOCK_INVALID;
+		parm->sFilter.sOuterVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_NO_FILTER;
+		parm->sFilter.sOuterVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_NO_FILTER;
+		parm->sFilter.sOuterVlan.bVidEnable = 0;
+		parm->sFilter.sOuterVlan.bPriorityEnable = 0;
+	} else {
+		parm->sFilter.sOuterVlan.eType = GSW_EXTENDEDVLAN_FILTER_TYPE_NORMAL;
+
+		if (parm->sFilter.sOuterVlan.nPriorityVal != 8)
+			parm->sFilter.sOuterVlan.bPriorityEnable = 1;
+		else
+			parm->sFilter.sOuterVlan.bPriorityEnable = 0;
+
+		if (parm->sFilter.sOuterVlan.nVidVal != 4096)
+			parm->sFilter.sOuterVlan.bVidEnable = 1;
+		else
+			parm->sFilter.sOuterVlan.bVidEnable = 0;
+
+		switch (tpid_dei) {
+		case 0:
+			parm->sFilter.sOuterVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_NO_FILTER;
+			parm->sFilter.sOuterVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_NO_FILTER;
+			break;
+
+		case 4:
+			parm->sFilter.sOuterVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_8021Q;
+			parm->sFilter.sOuterVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_NO_FILTER;
+			break;
+
+		case 5:
+			parm->sFilter.sOuterVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_VTETYPE;
+			parm->sFilter.sOuterVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_NO_FILTER;
+			break;
+
+		case 6:
+			parm->sFilter.sOuterVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_VTETYPE;
+			parm->sFilter.sOuterVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_0;
+			break;
+
+		case 7:
+			parm->sFilter.sOuterVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_VTETYPE;
+			parm->sFilter.sOuterVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_1;
+			break;
+		}
+	}
+
+	/*Get Inner VLAn Filter*/
+	parm->sFilter.sInnerVlan.nPriorityVal = ((tbl_prog.key[3] >> 12) & 0xf);
+	parm->sFilter.sInnerVlan.nVidVal |= ((tbl_prog.key[2] & 0x8000) >> 15);
+	parm->sFilter.sInnerVlan.nVidVal |= ((tbl_prog.key[3] & 0xFFF) << 1);
+	tpid_dei = ((tbl_prog.key[2] & 0x7000) >> 12);
+
+	if (parm->sFilter.sInnerVlan.nPriorityVal == 8 &&
+	    parm->sFilter.sInnerVlan.nVidVal == 4096 &&
+	    tpid_dei == 0) {
+		parm->sFilter.sInnerVlan.eType = GSW_EXTENDEDVLAN_FILTER_TYPE_NO_FILTER;
+		parm->sFilter.sInnerVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_NO_FILTER;
+		parm->sFilter.sInnerVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_NO_FILTER;
+		parm->sFilter.sInnerVlan.bVidEnable = 0;
+		parm->sFilter.sInnerVlan.bPriorityEnable = 0;
+	} else if (parm->sFilter.sInnerVlan.nPriorityVal == 14) {
+		parm->sFilter.sInnerVlan.eType = GSW_EXTENDEDVLAN_FILTER_TYPE_DEFAULT;
+		parm->sFilter.sInnerVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_NO_FILTER;
+		parm->sFilter.sInnerVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_NO_FILTER;
+		parm->sFilter.sInnerVlan.bVidEnable = 0;
+		parm->sFilter.sInnerVlan.bPriorityEnable = 0;
+	} else if (parm->sFilter.sInnerVlan.nPriorityVal == 15) {
+		parm->sFilter.sInnerVlan.eType = GSW_EXTENDEDVLAN_FILTER_TYPE_NO_TAG;
+		parm->sFilter.sInnerVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_NO_FILTER;
+		parm->sFilter.sInnerVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_NO_FILTER;
+		parm->sFilter.sInnerVlan.bVidEnable = 0;
+		parm->sFilter.sInnerVlan.bPriorityEnable = 0;
+	} else {
+		parm->sFilter.sInnerVlan.eType = GSW_EXTENDEDVLAN_FILTER_TYPE_NORMAL;
+
+		if (parm->sFilter.sInnerVlan.nPriorityVal != 8)
+			parm->sFilter.sInnerVlan.bPriorityEnable = 1;
+		else
+			parm->sFilter.sInnerVlan.bPriorityEnable = 0;
+
+		if (parm->sFilter.sInnerVlan.nVidVal != 4096)
+			parm->sFilter.sInnerVlan.bVidEnable = 1;
+		else
+			parm->sFilter.sInnerVlan.bVidEnable = 0;
+
+		switch (tpid_dei) {
+		case 0:
+			parm->sFilter.sInnerVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_NO_FILTER;
+			parm->sFilter.sInnerVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_NO_FILTER;
+			break;
+
+		case 4:
+			parm->sFilter.sInnerVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_8021Q;
+			parm->sFilter.sInnerVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_NO_FILTER;
+			break;
+
+		case 5:
+			parm->sFilter.sInnerVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_VTETYPE;
+			parm->sFilter.sInnerVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_NO_FILTER;
+			break;
+
+		case 6:
+			parm->sFilter.sInnerVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_VTETYPE;
+			parm->sFilter.sInnerVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_0;
+			break;
+
+		case 7:
+			parm->sFilter.sInnerVlan.eTpid = GSW_EXTENDEDVLAN_FILTER_TPID_VTETYPE;
+			parm->sFilter.sInnerVlan.eDei = GSW_EXTENDEDVLAN_FILTER_DEI_1;
+			break;
+		}
+	}
+
+	/*Get Ether type filter*/
+	ethtype = (tbl_prog.key[2] & 0x1F);
+
+	switch (ethtype) {
+	case 0:
+		parm->sFilter.eEtherType = GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_NO_FILTER;
+		break;
+
+	case 1:
+		parm->sFilter.eEtherType = GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_IPOE;
+		break;
+
+	case 2:
+		parm->sFilter.eEtherType = GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_PPPOE;
+		break;
+
+	case 3:
+		parm->sFilter.eEtherType = GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_ARP;
+		break;
+
+	case 4:
+		parm->sFilter.eEtherType = GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_IPV6IPOE;
+		break;
+
+	case 5:
+		parm->sFilter.eEtherType = GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_EAPOL;
+		break;
+	}
+
+	/**Treatment Get**/
+	/** Get Number of VLAN tag to remove treatment.*/
+	removetag = ((tbl_prog.val[1] & 0xC000) >> 14);
+
+	switch (removetag) {
+	case 0:
+		parm->sTreatment.eRemoveTag = GSW_EXTENDEDVLAN_TREATMENT_NOT_REMOVE_TAG;
+		break;
+
+	case 1:
+		parm->sTreatment.eRemoveTag = GSW_EXTENDEDVLAN_TREATMENT_REMOVE_1_TAG;
+		break;
+
+	case 2:
+		parm->sTreatment.eRemoveTag = GSW_EXTENDEDVLAN_TREATMENT_REMOVE_2_TAG;
+		break;
+
+	case 3:
+		parm->sTreatment.eRemoveTag = GSW_EXTENDEDVLAN_TREATMENT_DISCARD_UPSTREAM;
+		break;
+	}
+
+	/** Get outer VLAN tag treatment. */
+	parm->sTreatment.sOuterVlan.ePriorityVal = (tbl_prog.val[1] & 0xF);
+
+	if (parm->sTreatment.sOuterVlan.ePriorityVal == 15) {
+		/*no outer VLAN tag added*/
+		parm->sTreatment.bAddOuterVlan = 0;
+	} else {
+		parm->sTreatment.bAddOuterVlan = 1;
+
+		switch (parm->sTreatment.sOuterVlan.ePriorityVal) {
+		case 8:
+			parm->sTreatment.sOuterVlan.ePriorityMode = GSW_EXTENDEDVLAN_TREATMENT_INNER_PRORITY;
+			break;
+
+		case 9:
+			parm->sTreatment.sOuterVlan.ePriorityMode = GSW_EXTENDEDVLAN_TREATMENT_OUTER_PRORITY;
+			break;
+
+		case 10:
+			parm->sTreatment.sOuterVlan.ePriorityMode = GSW_EXTENDEDVLAN_TREATMENT_DSCP;
+			bDscp2PcpMapEnable = 1;
+			break;
+
+		default:
+			parm->sTreatment.sOuterVlan.ePriorityMode = GSW_EXTENDEDVLAN_TREATMENT_PRIORITY_VAL;
+			break;
+		}
+
+		/*Get Treatment for outer VID*/
+		parm->sTreatment.sOuterVlan.eVidVal = ((tbl_prog.val[0] & 0xFFF8) >> 3);
+
+		if (parm->sTreatment.sOuterVlan.eVidVal == 4096)
+			parm->sTreatment.sOuterVlan.eVidMode = GSW_EXTENDEDVLAN_TREATMENT_INNER_VID;
+		else if (parm->sTreatment.sOuterVlan.eVidVal == 4097)
+			parm->sTreatment.sOuterVlan.eVidMode = GSW_EXTENDEDVLAN_TREATMENT_OUTER_VID;
+		else
+			parm->sTreatment.sOuterVlan.eVidMode = GSW_EXTENDEDVLAN_TREATMENT_VID_VAL;
+
+		/*Treatment for outer TPID/DEI*/
+		tpid_dei = (tbl_prog.val[0] & 0x7);
+
+		switch (tpid_dei) {
+		case 0:
+			parm->sTreatment.sOuterVlan.eTpid = GSW_EXTENDEDVLAN_TREATMENT_INNER_TPID;
+			parm->sTreatment.sOuterVlan.eDei = GSW_EXTENDEDVLAN_TREATMENT_INNER_DEI;
+			break;
+
+		case 1:
+			parm->sTreatment.sOuterVlan.eTpid = GSW_EXTENDEDVLAN_TREATMENT_OUTER_TPID;
+			parm->sTreatment.sOuterVlan.eDei = GSW_EXTENDEDVLAN_TREATMENT_OUTER_DEI;
+			break;
+
+		case 2:
+			parm->sTreatment.sOuterVlan.eTpid = GSW_EXTENDEDVLAN_TREATMENT_VTETYPE;
+			parm->sTreatment.sOuterVlan.eDei = GSW_EXTENDEDVLAN_TREATMENT_INNER_DEI;
+			break;
+
+		case 3:
+			parm->sTreatment.sOuterVlan.eTpid = GSW_EXTENDEDVLAN_TREATMENT_VTETYPE;
+			parm->sTreatment.sOuterVlan.eDei = GSW_EXTENDEDVLAN_TREATMENT_OUTER_DEI;
+			break;
+
+		case 4:
+			parm->sTreatment.sOuterVlan.eTpid = GSW_EXTENDEDVLAN_TREATMENT_8021Q;
+			parm->sTreatment.sOuterVlan.eDei = GSW_EXTENDEDVLAN_TREATMENT_DEI_0;
+
+			break;
+
+		case 6:
+			parm->sTreatment.sOuterVlan.eTpid = GSW_EXTENDEDVLAN_TREATMENT_VTETYPE;
+			parm->sTreatment.sOuterVlan.eDei = GSW_EXTENDEDVLAN_TREATMENT_DEI_0;
+			break;
+
+		case 7:
+			parm->sTreatment.sOuterVlan.eTpid = GSW_EXTENDEDVLAN_TREATMENT_VTETYPE;
+			parm->sTreatment.sOuterVlan.eDei = GSW_EXTENDEDVLAN_TREATMENT_DEI_1;
+			break;
+		}
+	}
+
+	/** Get inner VLAN tag treatment. */
+	parm->sTreatment.sInnerVlan.ePriorityVal = (tbl_prog.val[3] & 0xF);
+
+	if (parm->sTreatment.sInnerVlan.ePriorityVal == 15) {
+		/*no inner VLAN tag added*/
+		parm->sTreatment.bAddInnerVlan = 0;
+	} else {
+		parm->sTreatment.bAddInnerVlan = 1;
+		parm->sTreatment.sInnerVlan.ePriorityVal = (tbl_prog.val[3] & 0xF);
+
+		switch (parm->sTreatment.sInnerVlan.ePriorityVal) {
+		case 8:
+			parm->sTreatment.sInnerVlan.ePriorityMode = GSW_EXTENDEDVLAN_TREATMENT_INNER_PRORITY;
+			break;
+
+		case 9:
+			parm->sTreatment.sInnerVlan.ePriorityMode = GSW_EXTENDEDVLAN_TREATMENT_OUTER_PRORITY;
+			break;
+
+		case 10:
+			parm->sTreatment.sInnerVlan.ePriorityMode = GSW_EXTENDEDVLAN_TREATMENT_DSCP;
+			bDscp2PcpMapEnable = 1;
+			break;
+
+		default:
+			parm->sTreatment.sInnerVlan.ePriorityMode = GSW_EXTENDEDVLAN_TREATMENT_PRIORITY_VAL;
+			break;
+		}
+
+		/*Get Treatment for inner VID*/
+		parm->sTreatment.sInnerVlan.eVidVal = ((tbl_prog.val[2] & 0xFFF8) >> 3);
+
+		if (parm->sTreatment.sInnerVlan.eVidVal == 4096)
+			parm->sTreatment.sInnerVlan.eVidMode = GSW_EXTENDEDVLAN_TREATMENT_INNER_VID;
+		else if (parm->sTreatment.sInnerVlan.eVidVal == 4097)
+			parm->sTreatment.sInnerVlan.eVidMode = GSW_EXTENDEDVLAN_TREATMENT_OUTER_VID;
+		else
+			parm->sTreatment.sInnerVlan.eVidMode = GSW_EXTENDEDVLAN_TREATMENT_VID_VAL;
+
+		/*Treatment for inner TPID/DEI*/
+		tpid_dei = (tbl_prog.val[2] & 0x7);
+
+		switch (tpid_dei) {
+		case 0:
+			parm->sTreatment.sInnerVlan.eTpid = GSW_EXTENDEDVLAN_TREATMENT_INNER_TPID;
+			parm->sTreatment.sInnerVlan.eDei = GSW_EXTENDEDVLAN_TREATMENT_INNER_DEI;
+			break;
+
+		case 1:
+			parm->sTreatment.sInnerVlan.eTpid = GSW_EXTENDEDVLAN_TREATMENT_OUTER_TPID;
+			parm->sTreatment.sInnerVlan.eDei = GSW_EXTENDEDVLAN_TREATMENT_OUTER_DEI;
+			break;
+
+		case 2:
+			parm->sTreatment.sInnerVlan.eTpid = GSW_EXTENDEDVLAN_TREATMENT_VTETYPE;
+			parm->sTreatment.sInnerVlan.eDei = GSW_EXTENDEDVLAN_TREATMENT_INNER_DEI;
+			break;
+
+		case 3:
+			parm->sTreatment.sInnerVlan.eTpid = GSW_EXTENDEDVLAN_TREATMENT_VTETYPE;
+			parm->sTreatment.sInnerVlan.eDei = GSW_EXTENDEDVLAN_TREATMENT_OUTER_DEI;
+			break;
+
+		case 4:
+			parm->sTreatment.sInnerVlan.eTpid = GSW_EXTENDEDVLAN_TREATMENT_8021Q;
+			parm->sTreatment.sInnerVlan.eDei = GSW_EXTENDEDVLAN_TREATMENT_DEI_0;
+
+			break;
+
+		case 6:
+			parm->sTreatment.sInnerVlan.eTpid = GSW_EXTENDEDVLAN_TREATMENT_VTETYPE;
+			parm->sTreatment.sInnerVlan.eDei = GSW_EXTENDEDVLAN_TREATMENT_DEI_0;
+			break;
+
+		case 7:
+			parm->sTreatment.sInnerVlan.eTpid = GSW_EXTENDEDVLAN_TREATMENT_VTETYPE;
+			parm->sTreatment.sInnerVlan.eDei = GSW_EXTENDEDVLAN_TREATMENT_DEI_1;
+			break;
+		}
+	}
+
+	/** Get Treatment Bridge port **/
+	parm->sTreatment.bReassignBridgePort = ((tbl_prog.val[4] &  0x100) >> 8);
+
+	if (parm->sTreatment.bReassignBridgePort)
+		parm->sTreatment.nNewBridgePortId = (tbl_prog.val[4] & 0xFF);
+
+	/** Get Treatment DSCP **/
+	parm->sTreatment.bNewDscpEnable = ((tbl_prog.val[4] & 0x8000) >> 15);
+
+	if (parm->sTreatment.bNewDscpEnable)
+		parm->sTreatment.nNewDscp = ((tbl_prog.val[4] & 0x7E00) >> 9);
+
+	/** Get Treatment Traffic Class **/
+	parm->sTreatment.bNewTrafficClassEnable	= ((tbl_prog.val[5] & 0x2000) >> 13);
+
+	if (parm->sTreatment.bNewTrafficClassEnable)
+		parm->sTreatment.nNewTrafficClass = ((tbl_prog.val[5] & 0x1E00) >> 9);
+
+	/** Treatment Metering **/
+	parm->sTreatment.bNewMeterEnable = ((tbl_prog.val[5] &  0x100) >> 8);
+
+	if (parm->sTreatment.bNewMeterEnable)
+		parm->sTreatment.sNewTrafficMeterId = (tbl_prog.val[5] & 0xFF);
+
+	/** Get loopback. val 5 BIT 14*/
+	parm->sTreatment.bLoopbackEnable = ((tbl_prog.val[5] & 0x4000) >> 14);
+	/** Get destination/source MAC address swap. val 5 BIT 15*/
+	parm->sTreatment.bDaSaSwapEnable = ((tbl_prog.val[5] & 0x8000) >> 15);
+	/** Get traffic mirrored to the monitoring port. val 3 BIT 15 */
+	parm->sTreatment.bMirrorEnable = ((tbl_prog.val[3] & 0x8000) >> 15);
+
+	if (bDscp2PcpMapEnable) {
+		dscp2pcp_pointer = ((tbl_prog.val[3] & 0x70) >> 4);
+		pr_err("dscp pointer = %d\n", dscp2pcp_pointer);
+
+		/** Get DSCP2PCP map **/
+		/*This dscp2pcp idx should be in use*/
+		if (!gswdev->dscp2pcp_idx[dscp2pcp_pointer].IndexInUse) {
+			printk("ERROR dscp2pcp_pointer not in use %d \n", dscp2pcp_pointer);
+			goto UNLOCK_AND_RETURN;
+		}
+
+		dscp2pcp_get.nIndex = dscp2pcp_pointer;
+		ret = GSW_QOS_Dscp2PcpTableGet(cdev, &dscp2pcp_get);
+
+		if (ret == GSW_statusErr) {
+			pr_err("%s:%s:%d - GSW_QOS_Dscp2PcpTableGet", __FILE__, __func__, __LINE__);
+			goto UNLOCK_AND_RETURN;
+		}
+
+		memcpy(parm->sTreatment.nDscp2PcpMap, dscp2pcp_get.nMap, (sizeof(u8) * 64));
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_ExtendedVlanFree(void *cdev, GSW_EXTENDEDVLAN_alloc_t *param)
+{
+	pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 idx = 0, dscp2pcp_pointer = 0, meterid = 0, meterenable = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (param->nExtendedVlanBlockId >= gswdev->num_of_extendvlan) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*nExtendedVlanBlockId should be in use,if not in use return error*/
+	if (!gswdev->extendvlan_idx.vlan_idx[param->nExtendedVlanBlockId].IndexInUse) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*if this nExtendedVlanBlockId usage count is not zero that means it is used by some one.
+	  This Block can be deleted, only if that some one release this block*/
+	if (gswdev->extendvlan_idx.vlan_idx[param->nExtendedVlanBlockId].IndexInUsageCnt) {
+		pr_err("ERROR :Extended Vlan block %u is used by some resource,can not delete\n", param->nExtendedVlanBlockId);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	idx = param->nExtendedVlanBlockId;
+	param->nNumberOfEntries = 0;
+
+	if (gswdev->extendvlan_idx.vlan_idx[idx].VlanBlockId != param->nExtendedVlanBlockId) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*Condition to delete idx
+		1. idx should belong to this block
+		2. idx should be in Use
+		3. idx should be with in valid Extended VLAN table range (Entry 0-1023 is valid)
+	*/
+	while (gswdev->extendvlan_idx.vlan_idx[idx].IndexInUse && idx < gswdev->num_of_extendvlan
+	       && (gswdev->extendvlan_idx.vlan_idx[idx].VlanBlockId == param->nExtendedVlanBlockId)) {
+
+
+		memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+		tbl_prog.table = PCE_EXTVLAN_INDEX;
+		CLEAR_U16(tbl_prog.pcindex);
+		/*Table Entry address (Egress VLAN treatment index) Bit 9:0 in PCE_TBL_ADDR*/
+		tbl_prog.pcindex |= (idx & 0x3FF);
+		/*Address-based read*/
+		gsw_pce_table_read(cdev, &tbl_prog);
+
+		if (gswdev->extendvlan_idx.vlan_idx[idx].Dscp2PcpPointerAssigned) {
+			/*get dscp2pcp table pointer*/
+			dscp2pcp_pointer = ((tbl_prog.val[3] & 0x70) >> 4);
+
+			/*Check whether the dscp2pcp pointer in use.
+			  It should be in use,since it got allocated or assigned in GSW_ExtendedVlanAdd
+			  for this ExtendedVlan table idx (i.e) it is marked as InUse and Usage count
+			  has been incremented during allocation or Usage count has been incremented
+			  if assigned.
+			*/
+			if (!gswdev->dscp2pcp_idx[dscp2pcp_pointer].IndexInUse) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Decrement the dscp2pcp index usage count.
+			  If it becomes zero after decrement,then this index is free
+			  for allocation by others.
+			  In next allocation this dscp2pcp pointer's value
+			  will be over written.
+			 */
+			gswdev->dscp2pcp_idx[dscp2pcp_pointer].IndexInUsageCnt--;
+
+			if (gswdev->dscp2pcp_idx[dscp2pcp_pointer].IndexInUsageCnt == 0)
+				gswdev->dscp2pcp_idx[dscp2pcp_pointer].IndexInUse = 0;
+
+			gswdev->extendvlan_idx.vlan_idx[idx].Dscp2PcpPointerAssigned = 0;
+			gswdev->extendvlan_idx.vlan_idx[idx].Dscp2PcpPointer = 0;
+		}
+
+		/** Treatment Metering **/
+		if (gswdev->extendvlan_idx.vlan_idx[idx].MeterAssigned) {
+			meterenable = ((tbl_prog.val[5] &  0x100) >> 8);
+			meterid = (tbl_prog.val[5] & 0xFF);
+
+			if (!meterenable) {
+				pr_err("Meterid %d is assigned while allocation for this ExVlan idx=%d\n",
+				       meterid, idx);
+				pr_err("ERROR : why it is not enabled in Exvlan Table\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			gswdev->extendvlan_idx.vlan_idx[idx].MeterAssigned = 0;
+			gswdev->extendvlan_idx.vlan_idx[idx].MeterId = 0;
+			gswdev->meter_idx[meterid].IndexInUsageCnt--;
+		}
+
+		/*Zero the Key/Value REG and write to this ExtendedVlan table idx*/
+		memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+		tbl_prog.table = PCE_EXTVLAN_INDEX;
+		CLEAR_U16(tbl_prog.pcindex);
+		/*Table Entry address (Egress VLAN treatment index) Bit 9:0 in PCE_TBL_ADDR*/
+		tbl_prog.pcindex |= (idx & 0x3FF);
+		/*Address-based write*/
+		gsw_pce_table_write(cdev, &tbl_prog);
+
+		/*free this idx and decrement the the number of used table entries/idx*/
+		gswdev->extendvlan_idx.vlan_idx[idx].IndexInUse = 0;
+		/*(Entry 0-1023 is valid) EXVLAN_ENTRY_INVALID is 1024*/
+		gswdev->extendvlan_idx.vlan_idx[idx].VlanBlockId = EXVLAN_ENTRY_INVALID;
+		gswdev->extendvlan_idx.nUsedEntry--;
+		/*A reference for the user, how many entries has been deleted in this block
+		  debugging purpose*/
+		param->nNumberOfEntries++;
+		/*increment the idx,since the block's allocation in ADD is Contiguous*/
+		idx++;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+
+}
+
+static u8 GSW_SearchVlanFilterContiguousBlock(ethsw_api_dev_t *gswdev, u32 BlockId, u32 NumberOfEntries)
+{
+	u32 i;
+
+	for (i = BlockId; i <= (BlockId + NumberOfEntries); i++) {
+		if (gswdev->vlanfilter_idx.filter_idx[i].IndexInUse)
+			return 0;
+	}
+
+	return 1;
+}
+
+GSW_return_t GSW_VlanFilterAlloc(void *cdev, GSW_VLANFILTER_alloc_t *param)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u16 VlanFilterIndex;
+	u8 ContiguousBlockFound = 0;
+	u32 i, ret;
+
+	/*
+		Allocate New Block as per the number of table Entries requested
+		The Block must be allocated with contiguous table index
+	*/
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_alloc);
+#endif
+
+	if (param->nNumberOfEntries > (gswdev->num_of_vlanfilter - gswdev->vlanfilter_idx.nUsedEntry)) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	for (VlanFilterIndex = 0; VlanFilterIndex < gswdev->num_of_vlanfilter && !ContiguousBlockFound; VlanFilterIndex++) {
+		/*Table Index not in use*/
+		if (!gswdev->vlanfilter_idx.filter_idx[VlanFilterIndex].IndexInUse) {
+			ContiguousBlockFound = GSW_SearchVlanFilterContiguousBlock(gswdev, VlanFilterIndex, param->nNumberOfEntries);
+		}
+
+		/*Contiguous block found in the table*/
+		if (ContiguousBlockFound) {
+			param->nVlanFilterBlockId = VlanFilterIndex;
+
+			/*Mark the contiguous table indexes as InUse and tag it with block id*/
+			for (i = param->nVlanFilterBlockId; i < (param->nVlanFilterBlockId + param->nNumberOfEntries); i++) {
+				gswdev->vlanfilter_idx.filter_idx[i].IndexInUse = 1;
+				gswdev->vlanfilter_idx.filter_idx[i].FilterBlockId = param->nVlanFilterBlockId;
+				/* The following are stored as part of Index information,
+				   Since it will be used as part of Bridge Port Configuration (GSW_BRIDGE_PORT_CONFIG_SET).
+				   It will be used to enable/disable the following in Bridge Port Configuration Table.
+				   1. VLAN filtering untagged traffic forwarding mode
+				   2. VLAN filtering tagged unmatched traffic forwarding mode
+				   It is not part of VLAN Filter Table Configuration
+				*/
+				gswdev->vlanfilter_idx.filter_idx[i].DiscardUntagged = param->bDiscardUntagged;
+				gswdev->vlanfilter_idx.filter_idx[i].DiscardUnMatchedTagged = param->bDiscardUnmatchedTagged;
+				gswdev->vlanfilter_idx.nUsedEntry++;
+			}
+		}
+	}
+
+	/*Contiguous block not found in the table*/
+	if (!ContiguousBlockFound) {
+		ret = GSW_statusErr;
+		pr_err(" ContiguousBlockFound %s:%s:%d", __FILE__, __func__, __LINE__);
+		goto UNLOCK_AND_RETURN;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_alloc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_VlanFilterSet(void *cdev, GSW_VLANFILTER_config_t *param)
+{
+	pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 idx = 0;
+	u32 ret = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	/* Once the New blk allocated,param->nEntryIndex will decide which index with in this block
+	   has to be set.only one index will be set at a time.
+	   It is users responsibility to set all the index with in this block
+	   by calling GSW_ExtendedVlanAdd as many times as required (i.e) param->nNumberOfEntries*/
+	idx = param->nVlanFilterBlockId + param->nEntryIndex;
+
+	if (idx >= gswdev->num_of_vlanfilter) {
+		pr_err("ERROR: nVlanFilterBlockId idx %d  out of range [supported num_of_vlanfilter %d]\n", idx, (gswdev->num_of_vlanfilter - 1));
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if (!gswdev->vlanfilter_idx.filter_idx[idx].IndexInUse) {
+		pr_err("ERROR: Index not InUse\n");
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if (gswdev->vlanfilter_idx.filter_idx[idx].FilterBlockId != param->nVlanFilterBlockId) {
+		pr_err("gswdev->vlanfilter_idx.filter_idx[idx].FilterBlockId != param->nVlanFilterBlockId\n");
+		goto UNLOCK_AND_RETURN;
+	}
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+	tbl_prog.table = PCE_VLANFILTER_INDEX;
+	CLEAR_U16(tbl_prog.pcindex);
+	/*Table Entry address (VLAN Filter index) Bit 11:0 in PCE_TBL_ADDR*/
+	tbl_prog.pcindex |= (idx & 0xFFF);
+
+	/*This is the Filter mask which will be applied for all the Index with in
+	 this Allocated Block*/
+	gswdev->vlanfilter_idx.filter_idx[idx].FilterMask = param->eVlanFilterMask;
+
+	CLEAR_U16(tbl_prog.key[0]);
+
+	/* KEY REG0 BIT 11:0 -VID,BIT 15:13-PCP,BIT 12-DEI*/
+	switch (gswdev->vlanfilter_idx.filter_idx[idx].FilterMask) {
+	case GSW_VLAN_FILTER_TCI_MASK_VID:
+		tbl_prog.key[0] |= (param->nVal & 0xFFF);
+		break;
+
+	case GSW_VLAN_FILTER_TCI_MASK_PCP:
+		tbl_prog.key[0] |= ((param->nVal & 0x7) << 13);
+		break;
+
+	case GSW_VLAN_FILTER_TCI_MASK_TCI:
+		tbl_prog.key[0] |= (param->nVal & 0xFFFF);
+		break;
+
+	default:
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*VLAN Filter Match action*/
+	/* VAL REG0 BIT 0
+	   0 - Traffic Allowed
+	   1 - Traffic Blocked
+	*/
+	if (param->bDiscardMatched)
+		tbl_prog.val[0] |= 1;
+	else
+		tbl_prog.val[0] &= ~(1);
+
+	/*Address-based write*/
+	gsw_pce_table_write(cdev, &tbl_prog);
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_VlanFilterGet(void *cdev, GSW_VLANFILTER_config_t *parm)
+{
+	pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 idx = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (parm->nVlanFilterBlockId > gswdev->num_of_vlanfilter) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	idx = parm->nVlanFilterBlockId + parm->nEntryIndex;
+
+	if (idx >= gswdev->num_of_vlanfilter) {
+		pr_err("ERROR: nVlanFilterBlockId idx %d  out of range [supported num_of_vlanfilter %d]\n", idx, (gswdev->num_of_vlanfilter - 1));
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*Index is not in USE*/
+	if (!gswdev->vlanfilter_idx.filter_idx[idx].IndexInUse) {
+		pr_err("Error :Index not in use\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*Index does not belongs to this VlanBlock*/
+	if (gswdev->vlanfilter_idx.filter_idx[idx].FilterBlockId != parm->nVlanFilterBlockId) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+	tbl_prog.table = PCE_VLANFILTER_INDEX;
+	CLEAR_U16(tbl_prog.pcindex);
+	/*Table Entry address (VLAN Filter index) Bit 11:0 in PCE_TBL_ADDR*/
+	tbl_prog.pcindex |= (idx & 0xFFF);
+	/*Address-based read*/
+	gsw_pce_table_read(cdev, &tbl_prog);
+
+	parm->eVlanFilterMask = gswdev->vlanfilter_idx.filter_idx[idx].FilterMask;
+//	parm->bDiscardUntagged=gswdev->vlanfilter_idx.filter_idx[idx].DiscardUntagged;
+//	parm->bDiscardUnmatchedTagged=gswdev->vlanfilter_idx.filter_idx[idx].DiscardUnMatchedTagged;
+
+	/* KEY REG0 BIT 11:0 -VID,BIT 15:13-PCP,BIT 12-DEI*/
+	switch (gswdev->vlanfilter_idx.filter_idx[idx].FilterMask) {
+	case GSW_VLAN_FILTER_TCI_MASK_VID:
+		parm->nVal = (tbl_prog.key[0] & 0xFFF);
+		break;
+
+	case GSW_VLAN_FILTER_TCI_MASK_PCP:
+		parm->nVal = ((tbl_prog.key[0] & 0xE000) >> 13);
+		break;
+
+	case GSW_VLAN_FILTER_TCI_MASK_TCI:
+		parm->nVal = (tbl_prog.key[0] & 0xFFFF);
+		break;
+
+	default:
+		goto UNLOCK_AND_RETURN;
+	}
+
+	parm->bDiscardMatched = (tbl_prog.val[0] & 0x1);
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_VlanFilterFree(void *cdev, GSW_VLANFILTER_alloc_t *parm)
+{
+	pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 idx = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (parm->nVlanFilterBlockId >= gswdev->num_of_vlanfilter) {
+		pr_err("ERROR: nVlanFilterBlockId idx %d  out of range [supported num_of_vlanfilter %d]\n", idx, (gswdev->num_of_vlanfilter - 1));
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*nVlanFilterBlockId should be in use,if not in use return error*/
+	if (!gswdev->vlanfilter_idx.filter_idx[parm->nVlanFilterBlockId].IndexInUse) {
+		pr_err("Error :Index not in use\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*If this nVlanFilterBlockId usage count is not zero, that means it is still used by some one.
+	  This Block can be deleted, only if that some one release this block*/
+	if (gswdev->vlanfilter_idx.filter_idx[parm->nVlanFilterBlockId].IndexInUsageCnt) {
+		pr_err("ERROR :Vlan Filter block %u is used by some resource,can not delete\n", parm->nVlanFilterBlockId);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	idx = parm->nVlanFilterBlockId;
+	parm->nNumberOfEntries = 0;
+
+	if (gswdev->vlanfilter_idx.filter_idx[idx].FilterBlockId != parm->nVlanFilterBlockId) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*Condition to delete idx
+		1. idx should belong to this block
+		2. idx should be in Use
+		3. idx should be with in valid VLAN Filter table range (Entry 0-1023 is valid)
+	*/
+	while (gswdev->vlanfilter_idx.filter_idx[idx].IndexInUse && idx < gswdev->num_of_vlanfilter
+	       && (gswdev->vlanfilter_idx.filter_idx[idx].FilterBlockId == parm->nVlanFilterBlockId)) {
+		/*Zero the Key/Value REG and write to this VLAN Filter table idx*/
+		memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+		tbl_prog.table = PCE_VLANFILTER_INDEX;
+		CLEAR_U16(tbl_prog.pcindex);
+		/*Table Entry address (VLAN Filter treatment index) Bit 9:0 in PCE_TBL_ADDR*/
+		tbl_prog.pcindex |= (idx & 0xFFF);
+		/*Address-based write*/
+		gsw_pce_table_write(cdev, &tbl_prog);
+		/*free this idx and decrement the the number of used table entries/idx*/
+		gswdev->vlanfilter_idx.filter_idx[idx].IndexInUse = 0;
+		/*(Entry 0-1023 is valid) VLANFILTER_ENTRY_INVALID is 1024*/
+		gswdev->vlanfilter_idx.filter_idx[idx].FilterBlockId = VLANFILTER_ENTRY_INVALID;
+		gswdev->vlanfilter_idx.nUsedEntry--;
+		/*A reference for the user, how many entries has been deleted in this block
+		  debugging purpose*/
+		parm->nNumberOfEntries++;
+		/*increment the idx,since the block's allocation in ADD is Contiguous*/
+		idx++;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_BridgeAlloc(void *cdev, GSW_BRIDGE_alloc_t *param)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 idx = 0, freeidxfound = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_alloc);
+#endif
+
+	/*find a free Bridge configuration table index and allocate
+	 New Bridge configuration table index
+	 note: bridge port 0 is special purpose-can not be allocated*/
+	for (idx = 1; idx < gswdev->num_of_bridge && !freeidxfound; idx++) {
+		if (!(gswdev->brdgeconfig_idx[idx].IndexInUse)) {
+			gswdev->brdgeconfig_idx[idx].IndexInUse = 1;
+			param->nBridgeId = idx;
+			freeidxfound = 1;
+		}
+	}
+
+	/*No free Slot return Error*/
+	if (!freeidxfound) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_alloc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_BridgeConfigSet(void *cdev, GSW_BRIDGE_config_t *param)
+{
+	pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 idx = 0, meterid;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+
+	if (param->nBridgeId >= gswdev->num_of_bridge) {
+		pr_err("nBridgeId %d out of range [Suported num_of_bridge = %d]\n", param->nBridgeId, (gswdev->num_of_bridge - 1));
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+
+	/*GSW_BRIDGE_CONFIG_MASK_FORCE is for debugging purpose only
+	 if this mask is enabled , there is no check on index in-use*/
+	if (!(param->eMask & GSW_BRIDGE_CONFIG_MASK_FORCE)) {
+		/*If Bridge ID is valid,Check whether it is InUSE
+		  if not InUse,return ERROR*/
+		if (!(gswdev->brdgeconfig_idx[param->nBridgeId].IndexInUse)) {
+			pr_err("ERROR nBridgeId %d: Index not in use\n", param->nBridgeId);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+	tbl_prog.table = PCE_BRGCFG_INDEX;
+	CLEAR_U16(tbl_prog.pcindex);
+	/*Table Entry address (Bridge Config Table index) Bit 9:0 in PCE_TBL_ADDR*/
+	tbl_prog.pcindex |= (param->nBridgeId & 0x3F);
+
+	/*Address-based read - Do Not disturb the existing value in case of
+	 configuration update, so read first,then update only the required field*/
+	gsw_pce_table_read(cdev, &tbl_prog);
+
+	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_MAC_LEARNING_LIMIT) {
+		/*If Learning limit is enabled,Set the user defined limit
+		  If Learning limit not enable,Set default limit -255*/
+		if (param->bMacLearningLimitEnable) {
+			tbl_prog.val[0] &= ~0xFF;
+			tbl_prog.val[0] |= (param->nMacLearningLimit & 0xFF);
+		} else
+			/*Set default limit -255*/
+			tbl_prog.val[0] |= (0xFF);
+	}
+
+	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_SUB_METER) {
+		/**
+		Bridge Meter for bridge process with specific type
+		As defined in GSW_BridgePortEgressMeter_t
+
+		Index of broadcast traffic meter
+		   GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST = 0,
+		Index of known multicast traffic meter
+		   GSW_BRIDGE_PORT_EGRESS_METER_MULTICAST = 1,
+		Index of unknown multicast IP traffic meter
+		   GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_MC_IP = 2,
+		Index of unknown multicast non-IP traffic meter
+		   GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_MC_NON_IP = 3,
+		Index of unknown unicast traffic meter
+		   GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_UC = 4,
+		**/
+		/*GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST*/
+		if (param->bSubMeteringEnable[0]) {
+			meterid = param->nTrafficSubMeterId[0];
+
+			/*This below field enable indicates that this meter id is
+			 already assigned and it's idx recorded for this Bridge Port id.
+			 If next time the user update this meter field with different meter idx !!
+			 or wanted to allocate a new meter idx ??!! may happen by mistake ??!!
+			 the previous meter idx must be released from this Bridge Port*/
+			if (!(param->eMask & GSW_BRIDGE_CONFIG_MASK_FORCE)) {
+				if (gswdev->brdgeconfig_idx[param->nBridgeId].BroadcastMeteringAssigned) {
+					if (gswdev->brdgeconfig_idx[param->nBridgeId].BroadcastMeteringId !=
+					    meterid) {
+						idx = gswdev->brdgeconfig_idx[param->nBridgeId].BroadcastMeteringId;
+						/*release the usage of previous meter idx*/
+						gswdev->meter_idx[idx].IndexInUsageCnt--;
+						gswdev->brdgeconfig_idx[param->nBridgeId].BroadcastMeteringAssigned = 0;
+						gswdev->brdgeconfig_idx[param->nBridgeId].BroadcastMeteringId = 0;
+					}
+				}
+
+				/*This Meter ID should be in use (i.e) that is this Meter ID should be allocated
+				before calling bridge port configuration
+				If not in use return ERROR
+				*/
+				if (gswdev->meter_idx[meterid].IndexInUse) {
+					/*Usage count will be incremented only once during meter idx assignment
+					for this bridge port id*/
+					if (!gswdev->brdgeconfig_idx[param->nBridgeId].BroadcastMeteringAssigned) {
+						gswdev->brdgeconfig_idx[param->nBridgeId].BroadcastMeteringAssigned = 1;
+						gswdev->brdgeconfig_idx[param->nBridgeId].BroadcastMeteringId
+							= meterid;
+						/*Since this meter id can be shared,Increment the it's usage count*/
+						gswdev->meter_idx[meterid].IndexInUsageCnt++;
+					}
+
+				} else {
+					pr_err("BroadcastMeter Not allocated\n");
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+			}
+
+			/*Clear the field first*/
+			tbl_prog.val[4] &= ~(0x7F << 8);
+			tbl_prog.val[4] |= 1;
+			tbl_prog.val[4] |= ((param->nTrafficSubMeterId[0] & 0x7F) << 8);
+		} else {
+			/*Disable Broadcast sub meter*/
+			tbl_prog.val[4] &= ~1;
+		}
+
+		/*GSW_BRIDGE_PORT_EGRESS_METER_MULTICAST*/
+		if (param->bSubMeteringEnable[1]) {
+			meterid = param->nTrafficSubMeterId[1];
+
+			/*This below field enable indicates that this meter id is
+			 already assigned and it's idx recorded for this Bridge Port id.
+			 If next time the user update this meter field with different meter idx !!
+			 or wanted to allocate a new meter idx ??!! may happen by mistake ??!!
+			 the previous meter idx must be released from this Bridge Port*/
+			if (!(param->eMask & GSW_BRIDGE_CONFIG_MASK_FORCE)) {
+				if (gswdev->brdgeconfig_idx[param->nBridgeId].MulticastMeteringAssigned) {
+					if (gswdev->brdgeconfig_idx[param->nBridgeId].MulticastMeteringId !=
+					    meterid) {
+						idx = gswdev->brdgeconfig_idx[param->nBridgeId].MulticastMeteringId;
+						/*release the usage of previous meter idx*/
+						gswdev->meter_idx[idx].IndexInUsageCnt--;
+						gswdev->brdgeconfig_idx[param->nBridgeId].MulticastMeteringAssigned = 0;
+						gswdev->brdgeconfig_idx[param->nBridgeId].MulticastMeteringId = 0;
+					}
+				}
+
+				/*This Meter ID should be in use (i.e) that is this Meter ID should be allocated
+				before calling bridge port configuration
+				If not in use return ERROR
+				*/
+				if (gswdev->meter_idx[meterid].IndexInUse) {
+					/*Usage count will be incremented only once during meter idx assignment
+					for this bridge port id*/
+					if (!gswdev->brdgeconfig_idx[param->nBridgeId].MulticastMeteringAssigned) {
+						gswdev->brdgeconfig_idx[param->nBridgeId].MulticastMeteringAssigned = 1;
+						gswdev->brdgeconfig_idx[param->nBridgeId].MulticastMeteringId
+							= meterid;
+						/*Since this meter id can be shared,Increment the it's usage count*/
+						gswdev->meter_idx[meterid].IndexInUsageCnt++;
+					}
+
+				} else {
+					pr_err("MulticastMeter Not allocated\n");
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+			}
+
+			/*Clear the field first*/
+			tbl_prog.val[5] &= ~(0x7F << 8);
+			tbl_prog.val[5] |= 1;
+			tbl_prog.val[5] |= ((param->nTrafficSubMeterId[1] & 0x7F) << 8);
+		} else {
+			/*Disable Multicast sub meter*/
+			tbl_prog.val[5] &= ~1;
+		}
+
+		/*GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_MC_IP*/
+		if (param->bSubMeteringEnable[2]) {
+			meterid = param->nTrafficSubMeterId[2];
+
+			/*This below field enable indicates that this meter id is
+			 already assigned and it's idx recorded for this Bridge Port id.
+			 If next time the user update this meter field with different meter idx !!
+			 or wanted to allocate a new meter idx ??!! may happen by mistake ??!!
+			 the previous meter idx must be released from this Bridge Port*/
+			if (!(param->eMask & GSW_BRIDGE_CONFIG_MASK_FORCE)) {
+				if (gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiIpMeteringAssigned) {
+					if (gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiIpMeteringId !=
+					    meterid) {
+						idx = gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiIpMeteringId;
+						/*release the usage of previous meter idx*/
+						gswdev->meter_idx[idx].IndexInUsageCnt--;
+						gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiIpMeteringAssigned = 0;
+						gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiIpMeteringId = 0;
+					}
+				}
+
+				/*This Meter ID should be in use (i.e) that is this Meter ID should be allocated
+				before calling bridge port configuration
+				If not in use return ERROR
+				*/
+				if (gswdev->meter_idx[meterid].IndexInUse) {
+					/*Usage count will be incremented only once during meter idx assignment
+					for this bridge port id*/
+					if (!gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiIpMeteringAssigned) {
+						gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiIpMeteringAssigned = 1;
+						gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiIpMeteringId
+							= meterid;
+						/*Since this meter id can be shared,Increment the it's usage count*/
+						gswdev->meter_idx[meterid].IndexInUsageCnt++;
+					}
+				} else {
+					pr_err("UnknownMultiIpMeter Not allocated\n");
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+			}
+
+			/*Clear the field first*/
+			tbl_prog.val[8] &= ~(0x7F << 8);
+			tbl_prog.val[8] |= 1;
+			tbl_prog.val[8] |= ((param->nTrafficSubMeterId[2] & 0x7F) << 8);
+		} else {
+			/*Disable Unknown Multicast ip sub meter*/
+			tbl_prog.val[8] &= ~1;
+		}
+
+		/*GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_MC_NON_IP*/
+		if (param->bSubMeteringEnable[3]) {
+			meterid = param->nTrafficSubMeterId[3];
+
+			/*This below field enable indicates that this meter id is
+			 already assigned and it's idx recorded for this Bridge Port id.
+			 If next time the user update this meter field with different meter idx !!
+			 or wanted to allocate a new meter idx ??!! may happen by mistake ??!!
+			 the previous meter idx must be released from this Bridge Port*/
+			if (!(param->eMask & GSW_BRIDGE_CONFIG_MASK_FORCE)) {
+				if (gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiNonIpMeteringAssigned) {
+					if (gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiNonIpMeteringId !=
+					    meterid) {
+						idx = gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiNonIpMeteringId;
+						/*release the usage of previous meter idx*/
+						gswdev->meter_idx[meterid].IndexInUsageCnt--;
+						gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiNonIpMeteringAssigned = 0;
+						gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiNonIpMeteringId = 0;
+					}
+				}
+
+				/*This Meter ID should be in use (i.e) that is this Meter ID should be allocated
+				before calling bridge port configuration
+				If not in use return ERROR
+				*/
+				if (gswdev->meter_idx[meterid].IndexInUse) {
+					/*Usage count will be incremented only once during meter idx assignment
+					for this bridge port id*/
+					if (!gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiNonIpMeteringAssigned) {
+						gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiNonIpMeteringAssigned = 1;
+						gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiNonIpMeteringId
+							= meterid;
+						/*Since this meter id can be shared,Increment the it's usage count*/
+						gswdev->meter_idx[meterid].IndexInUsageCnt++;
+					}
+
+				} else {
+					pr_err("UnknownMultiNonIpMeter Not allocated\n");
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+			}
+
+			/*Clear the field first*/
+			tbl_prog.val[7] &= ~(0x7F << 8);
+			tbl_prog.val[7] |= 1;
+			tbl_prog.val[7] |= ((param->nTrafficSubMeterId[3] & 0x7F) << 8);
+		} else {
+			/*Disable Unknown Multicast Non-ip sub meter*/
+			tbl_prog.val[7] &= ~1;
+		}
+
+		/*GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_UC*/
+		if (param->bSubMeteringEnable[4]) {
+			meterid = param->nTrafficSubMeterId[4];
+
+			/*This below field enable indicates that this meter id is
+			 already assigned and it's idx recorded for this Bridge Port id.
+			 If next time the user update this meter field with different meter idx !!
+			 or wanted to allocate a new meter idx ??!! may happen by mistake ??!!
+			 the previous meter idx must be released from this Bridge Port*/
+			if (!(param->eMask & GSW_BRIDGE_CONFIG_MASK_FORCE)) {
+				if (gswdev->brdgeconfig_idx[param->nBridgeId].UnknownUniCastMeteringAssigned) {
+					if (gswdev->brdgeconfig_idx[param->nBridgeId].UnknownUniCastMeteringId !=
+					    meterid) {
+						idx = gswdev->brdgeconfig_idx[param->nBridgeId].UnknownUniCastMeteringId;
+						/*release the usage of previous meter idx*/
+						gswdev->meter_idx[meterid].IndexInUsageCnt--;
+						gswdev->brdgeconfig_idx[param->nBridgeId].UnknownUniCastMeteringAssigned = 0;
+						gswdev->brdgeconfig_idx[param->nBridgeId].UnknownUniCastMeteringId = 0;
+					}
+				}
+
+				/*This Meter ID should be in use (i.e) that is this Meter ID should be allocated
+				before calling bridge port configuration
+				If not in use return ERROR
+				*/
+				if (gswdev->meter_idx[meterid].IndexInUse) {
+					/*Usage count will be incremented only once during meter idx assignment
+					for this bridge port id*/
+					if (!gswdev->brdgeconfig_idx[param->nBridgeId].UnknownUniCastMeteringAssigned) {
+						gswdev->brdgeconfig_idx[param->nBridgeId].UnknownUniCastMeteringAssigned = 1;
+						gswdev->brdgeconfig_idx[param->nBridgeId].UnknownUniCastMeteringId
+							= meterid;
+						/*Since this meter id can be shared,Increment the it's usage count*/
+						gswdev->meter_idx[meterid].IndexInUsageCnt++;
+					}
+				} else {
+					pr_err("UnknownUniCastMeter Not allocated\n");
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+			}
+
+			/*Clear the field first*/
+			tbl_prog.val[6] &= ~(0x7F << 8);
+			tbl_prog.val[6] |= 1;
+			tbl_prog.val[6] |= ((param->nTrafficSubMeterId[4] & 0x7F) << 8);
+		} else {
+			/*Disable Unknown Unicast sub meter*/
+			tbl_prog.val[6] |= ~1;
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_FORWARDING_MODE) {
+		/*Clear the field first*/
+		tbl_prog.val[1] &= ~0x3;
+
+		switch (param->eForwardBroadcast) {
+		case GSW_BRIDGE_FORWARD_FLOOD:
+			break;
+
+		case GSW_BRIDGE_FORWARD_DISCARD:
+			tbl_prog.val[1] |= 0x1;
+			break;
+
+		case GSW_BRIDGE_FORWARD_CPU:
+			tbl_prog.val[1] |= 0x2;
+			break;
+		}
+
+		/*Clear the field first*/
+		tbl_prog.val[1] &= ~0xC;
+
+		switch (param->eForwardUnknownUnicast) {
+		case GSW_BRIDGE_FORWARD_FLOOD:
+			break;
+
+		case GSW_BRIDGE_FORWARD_DISCARD:
+			tbl_prog.val[1] |= (0x1 << 2);
+			break;
+
+		case GSW_BRIDGE_FORWARD_CPU:
+			tbl_prog.val[1] |= (0x2 << 2);
+			break;
+		}
+
+		/*Clear the field first*/
+		tbl_prog.val[1] &= ~0x30;
+
+		switch (param->eForwardUnknownMulticastNonIp) {
+		case GSW_BRIDGE_FORWARD_FLOOD:
+			break;
+
+		case GSW_BRIDGE_FORWARD_DISCARD:
+			tbl_prog.val[1] |= (0x1 << 4);
+			break;
+
+		case GSW_BRIDGE_FORWARD_CPU:
+			tbl_prog.val[1] |= (0x2 << 4);
+			break;
+		}
+
+		/*Clear the field first*/
+		tbl_prog.val[1] &= ~0xC0;
+
+		switch (param->eForwardUnknownMulticastIp) {
+		case GSW_BRIDGE_FORWARD_FLOOD:
+			break;
+
+		case GSW_BRIDGE_FORWARD_DISCARD:
+			tbl_prog.val[1] |= (0x1 << 6);
+			break;
+
+		case GSW_BRIDGE_FORWARD_CPU:
+			tbl_prog.val[1] |= (0x2 << 6);
+			break;
+		}
+	}
+
+	tbl_prog.table = PCE_BRGCFG_INDEX;
+	CLEAR_U16(tbl_prog.pcindex);
+	/*Table Entry address (Bridge Config Table index) Bit 5:0 in PCE_TBL_ADDR*/
+	tbl_prog.pcindex |= (param->nBridgeId & 0x3F);
+
+	/*Address-based write*/
+	gsw_pce_table_write(cdev, &tbl_prog);
+	pr_err("param->nBridgeId %d\n", param->nBridgeId);
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_BridgeConfigGet(void *cdev, GSW_BRIDGE_config_t *param)
+{
+	pctbl_prog_t tbl_prog;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ForwardMode;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (param->nBridgeId >= gswdev->num_of_bridge) {
+		pr_err("nBridgeId %d out of range [Suported num_of_bridge = %d]\n", param->nBridgeId, (gswdev->num_of_bridge - 1));
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*GSW_BRIDGE_CONFIG_MASK_FORCE is for debugging purpose only
+	 if this mask is enabled , there is no check on index in-use*/
+	if (!(param->eMask & GSW_BRIDGE_CONFIG_MASK_FORCE)) {
+		/*If Bridge ID is valid,Check whether it is InUSE
+		  if not InUse,return ERROR*/
+		if (!gswdev->brdgeconfig_idx[param->nBridgeId].IndexInUse) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+	tbl_prog.table = PCE_BRGCFG_INDEX;
+	CLEAR_U16(tbl_prog.pcindex);
+	/*Table Entry address (Bridge Config Table index) Bit 5:0 in PCE_TBL_ADDR*/
+	tbl_prog.pcindex |= (param->nBridgeId & 0x3F);
+	/*Address-based read*/
+	gsw_pce_table_read(cdev, &tbl_prog);
+
+	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_MAC_LEARNING_LIMIT) {
+		param->nMacLearningLimit = (tbl_prog.val[0] & 0xFF);
+
+		if (param->nMacLearningLimit != 255)
+			param->bMacLearningLimitEnable = 1;
+	}
+
+	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_SUB_METER) {
+		/**
+		Bridge Meter for bridge process with specific type
+		As defined in GSW_BridgePortEgressMeter_t
+
+		Index of broadcast traffic meter
+		   GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST = 0,
+		Index of known multicast traffic meter
+		   GSW_BRIDGE_PORT_EGRESS_METER_MULTICAST = 1,
+		Index of unknown multicast IP traffic meter
+		   GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_MC_IP = 2,
+		Index of unknown multicast non-IP traffic meter
+		   GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_MC_NON_IP = 3,
+		Index of unknown unicast traffic meter
+		   GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_UC = 4,
+		**/
+		/*Broadcast*/
+		param->bSubMeteringEnable[0] = (tbl_prog.val[4] & 0x1);
+
+		/*Meter ID*/
+		if (param->bSubMeteringEnable[0])
+			param->nTrafficSubMeterId[0] = ((tbl_prog.val[4] & 0x7F00) >> 8);
+
+		/*Multicast*/
+		param->bSubMeteringEnable[1] = (tbl_prog.val[5] & 0x1);
+
+		/*Meter ID*/
+		if (param->bSubMeteringEnable[1])
+			param->nTrafficSubMeterId[1] = ((tbl_prog.val[5] & 0x7F00) >> 8);
+
+		/*Unknown Multicast IP*/
+		param->bSubMeteringEnable[2] = (tbl_prog.val[8] & 0x1);
+
+		/*Meter ID*/
+		if (param->bSubMeteringEnable[2])
+			param->nTrafficSubMeterId[2] = ((tbl_prog.val[8] & 0x7F00) >> 8);
+
+		/*Unknown Multicast NON-IP*/
+		param->bSubMeteringEnable[3] = (tbl_prog.val[7] & 0x1);
+
+		/*Meter ID*/
+		if (param->bSubMeteringEnable[3])
+			param->nTrafficSubMeterId[3] = ((tbl_prog.val[7] & 0x7F00) >> 8);
+
+		/*Unknown Uni-Cast*/
+		param->bSubMeteringEnable[4] = (tbl_prog.val[6] & 0x1);
+
+		/*Meter ID*/
+		if (param->bSubMeteringEnable[4])
+			param->nTrafficSubMeterId[4] = ((tbl_prog.val[6] & 0x7F00) >> 8);
+	}
+
+	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_FORWARDING_MODE) {
+		ForwardMode = (tbl_prog.val[1] & 0x3);
+
+		switch (ForwardMode) {
+		case 0:
+			param->eForwardBroadcast = GSW_BRIDGE_FORWARD_FLOOD;
+			break;
+
+		case 1:
+			param->eForwardBroadcast = GSW_BRIDGE_FORWARD_DISCARD;
+			break;
+
+		case 2:
+			param->eForwardBroadcast = GSW_BRIDGE_FORWARD_CPU;
+			break;
+		}
+
+		ForwardMode = ((tbl_prog.val[1] & 0xC0) >> 6);
+
+		switch (ForwardMode) {
+		case 0:
+			param->eForwardUnknownMulticastIp = GSW_BRIDGE_FORWARD_FLOOD;
+			break;
+
+		case 1:
+			param->eForwardUnknownMulticastIp = GSW_BRIDGE_FORWARD_DISCARD;
+			break;
+
+		case 2:
+			param->eForwardUnknownMulticastIp = GSW_BRIDGE_FORWARD_CPU;
+			break;
+		}
+
+		ForwardMode = ((tbl_prog.val[1] & 0x30) >> 4);
+
+		switch (ForwardMode) {
+		case 0:
+			param->eForwardUnknownMulticastNonIp = GSW_BRIDGE_FORWARD_FLOOD;
+			break;
+
+		case 1:
+			param->eForwardUnknownMulticastNonIp = GSW_BRIDGE_FORWARD_DISCARD;
+			break;
+
+		case 2:
+			param->eForwardUnknownMulticastNonIp = GSW_BRIDGE_FORWARD_CPU;
+			break;
+		}
+
+		ForwardMode = ((tbl_prog.val[1] & 0xC) >> 2);
+
+		switch (ForwardMode) {
+		case 0:
+			param->eForwardUnknownUnicast = GSW_BRIDGE_FORWARD_FLOOD;
+			break;
+
+		case 1:
+			param->eForwardUnknownUnicast = GSW_BRIDGE_FORWARD_DISCARD;
+			break;
+
+		case 2:
+			param->eForwardUnknownUnicast = GSW_BRIDGE_FORWARD_CPU;
+			break;
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_MAC_LEARNED_COUNT) {
+		param->nMacLearningCount = (tbl_prog.val[9] & 0x1FFF);
+	}
+
+	if (param->eMask & GSW_BRIDGE_CONFIG_MASK_MAC_DISCARD_COUNT) {
+		param->nLearningDiscardEvent |= ((tbl_prog.val[2] & 0xFFFF));
+		param->nLearningDiscardEvent |= (((tbl_prog.val[3] & 0xFFFF) << 16));
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_BridgeFree(void *cdev, GSW_BRIDGE_alloc_t *param)
+{
+	pctbl_prog_t tbl_prog;
+	GSW_BRIDGE_config_t temp;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 count;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (param->nBridgeId >= gswdev->num_of_bridge) {
+		pr_err("nBridgeId %d out of range [Suported num_of_bridge = %d]\n", param->nBridgeId, gswdev->num_of_bridge);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*Bridge ID should be in use,if not in use return error*/
+	if (!gswdev->brdgeconfig_idx[param->nBridgeId].IndexInUse) {
+		pr_err("nBridge %u is Not inUse -> need to allocate before freeing\n", param->nBridgeId);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*If this Bridge usage count is not zero that means it is still used by some one.
+	  This Bridge configuration can be deleted, only if that some one release this Bridge*/
+	if (gswdev->brdgeconfig_idx[param->nBridgeId].IndexInUsageCnt) {
+		count = gswdev->brdgeconfig_idx[param->nBridgeId].IndexInUsageCnt;
+		pr_err("nBridge %u IndexInUsageCnt = %u is not zero ?!,Some Bridge Ports is holding this Bridge ?\n",
+		       param->nBridgeId, count);
+		pr_err("Free that Bridge Ports first,which will detach this association\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/** IMPROTANT : Release the Enabled Sub Meters associated with this bridge
+	    by Decrementing it's Usage count **/
+
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+	tbl_prog.table = PCE_BRGCFG_INDEX;
+	CLEAR_U16(tbl_prog.pcindex);
+	/*Table Entry address (Bridge Configuration Table index) Bit 5:0 in PCE_TBL_ADDR*/
+	tbl_prog.pcindex |= (param->nBridgeId & 0x3F);
+	/*Address-based read*/
+	gsw_pce_table_read(cdev, &tbl_prog);
+
+
+	/*Egress Broadcast Meter*/
+	temp.nTrafficSubMeterId[0] = ((tbl_prog.val[4] & 0x7F00) >> 8);
+
+	if (gswdev->brdgeconfig_idx[param->nBridgeId].BroadcastMeteringAssigned) {
+		if (gswdev->brdgeconfig_idx[param->nBridgeId].BroadcastMeteringId ==
+		    temp.nTrafficSubMeterId[0]) {
+			/*Release this meter id from this Bridge*/
+			gswdev->meter_idx[temp.nTrafficSubMeterId[0]].IndexInUsageCnt--;
+			gswdev->brdgeconfig_idx[param->nBridgeId].BroadcastMeteringAssigned = 0;
+			gswdev->brdgeconfig_idx[param->nBridgeId].BroadcastMeteringId = 0;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/*Egress Multicast Meter*/
+	temp.nTrafficSubMeterId[1] = ((tbl_prog.val[5] & 0x7F00) >> 8);
+
+	if (gswdev->brdgeconfig_idx[param->nBridgeId].MulticastMeteringAssigned) {
+		if (gswdev->brdgeconfig_idx[param->nBridgeId].MulticastMeteringId ==
+		    temp.nTrafficSubMeterId[1]) {
+			/*Release this meter id from this Bridge*/
+			gswdev->meter_idx[temp.nTrafficSubMeterId[1]].IndexInUsageCnt--;
+			gswdev->brdgeconfig_idx[param->nBridgeId].MulticastMeteringAssigned = 0;
+			gswdev->brdgeconfig_idx[param->nBridgeId].MulticastMeteringId = 0;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/*Egress Unknown Multicast IP Meter*/
+	temp.nTrafficSubMeterId[2] = ((tbl_prog.val[8] & 0x7F00) >> 8);
+
+	if (gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiIpMeteringAssigned) {
+		if (gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiIpMeteringId ==
+		    temp.nTrafficSubMeterId[2]) {
+			/*Release this meter id from this Bridge*/
+			gswdev->meter_idx[temp.nTrafficSubMeterId[2]].IndexInUsageCnt--;
+			gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiIpMeteringAssigned = 0;
+			gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiIpMeteringId = 0;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/*Egress Unknown Multicast NON IP Meter*/
+	temp.nTrafficSubMeterId[3] = ((tbl_prog.val[7] & 0x7F00) >> 8);
+
+	if (gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiNonIpMeteringAssigned) {
+		if (gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiNonIpMeteringId ==
+		    temp.nTrafficSubMeterId[3]) {
+			/*Release this meter id from this Bridge*/
+			gswdev->meter_idx[temp.nTrafficSubMeterId[3]].IndexInUsageCnt--;
+			gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiNonIpMeteringAssigned = 0;
+			gswdev->brdgeconfig_idx[param->nBridgeId].UnknownMultiNonIpMeteringId = 0;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/*Egress Unknown UniCast Meter*/
+	temp.nTrafficSubMeterId[4] = ((tbl_prog.val[6] & 0x7F00) >> 8);
+
+	if (gswdev->brdgeconfig_idx[param->nBridgeId].UnknownUniCastMeteringAssigned) {
+		if (gswdev->brdgeconfig_idx[param->nBridgeId].UnknownUniCastMeteringId ==
+		    temp.nTrafficSubMeterId[4]) {
+			/*Release this meter id from this Bridge*/
+			gswdev->meter_idx[temp.nTrafficSubMeterId[4]].IndexInUsageCnt--;
+			gswdev->brdgeconfig_idx[param->nBridgeId].UnknownUniCastMeteringAssigned = 0;
+			gswdev->brdgeconfig_idx[param->nBridgeId].UnknownUniCastMeteringId = 0;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/** Clear the table idx**/
+	/*reset to default this bridge idx*/
+	memset(&tbl_prog, 0, sizeof(pctbl_prog_t));
+	tbl_prog.table = PCE_BRGCFG_INDEX;
+	CLEAR_U16(tbl_prog.pcindex);
+	/*Table Entry address (Bridge Configuration Table index) Bit 5:0 in PCE_TBL_ADDR*/
+	tbl_prog.pcindex |= (param->nBridgeId & 0x3F);
+
+	/*Set default limit -255*/
+	tbl_prog.val[0] |= (0xFF);
+	gsw_pce_table_write(cdev, &tbl_prog);
+	/*Free this bridge Idx*/
+	gswdev->brdgeconfig_idx[param->nBridgeId].IndexInUse = 0;
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_BridgePortAlloc(void *cdev, GSW_BRIDGE_portAlloc_t *param)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t tbl_prog_brdgeport_ingress;
+	pctbl_prog_t tbl_prog_brdgeport_egress;
+	u32 idx = 0;
+	u16 freeidxfound = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_alloc);
+#endif
+
+	/*Find a free Bridge port configuration table index
+	  and allocate
+	  New Bridge Port configuration table index
+	  Bridge Port 0,1 and 127 is reserved ,
+	  So will not be allocated to user*/
+	for (idx = 2; idx < (gswdev->num_of_bridge_port - 1) && !freeidxfound; idx++) {
+		if (!(gswdev->brdgeportconfig_idx[idx].IndexInUse)) {
+			gswdev->brdgeportconfig_idx[idx].IndexInUse = 1;
+			param->nBridgePortId = idx;
+			freeidxfound = 1;
+		}
+	}
+
+	/*No free Slot return Error*/
+	if (!freeidxfound) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	memset(&tbl_prog_brdgeport_ingress, 0, sizeof(pctbl_prog_t));
+	memset(&tbl_prog_brdgeport_egress, 0, sizeof(pctbl_prog_t));
+
+	/*Learning Limit 255*/
+	tbl_prog_brdgeport_ingress.val[4] |= 0xFF;
+	gswdev->brdgeportconfig_idx[param->nBridgePortId].LearningLimit = 0xFF;
+	/*STP state Forward enable*/
+	tbl_prog_brdgeport_ingress.val[0] |= 0x7;
+	tbl_prog_brdgeport_egress.val[0] |= 0x7;
+
+	/*Default STP State is GSW_STP_PORT_STATE_FORWARD
+	  it can be changed using GSW_Stp_PortCfgSet*/
+	gswdev->brdgeportconfig_idx[param->nBridgePortId].StpState =
+		GSW_STP_PORT_STATE_FORWARD;
+	/*By Default 8021X State is GSW_8021X_PORT_STATE_AUTHORIZED
+	  it can be changed using GSW_8021X_PortCfgSet*/
+	gswdev->brdgeportconfig_idx[param->nBridgePortId].P8021xState =
+		GSW_8021X_PORT_STATE_AUTHORIZED;
+	/*NOTE :Bridge Port ingrees port map and Egress destination
+	  logical port will be zero,It is up to the User to configure
+	  these fields using GSW_BridgePortConfigSet */
+
+	/*Same bridge port idx for ingress and egress bridge port configuration*/
+	tbl_prog_brdgeport_ingress.table = PCE_IGBGP_INDEX;
+	CLEAR_U16(tbl_prog_brdgeport_ingress.pcindex);
+	/*Table Entry address (Bridge port ingress Table index) Bit 7:0 in PCE_TBL_ADDR*/
+	tbl_prog_brdgeport_ingress.pcindex |= (param->nBridgePortId & 0xFF);
+
+	tbl_prog_brdgeport_egress.table = PCE_EGBGP_INDEX;
+	CLEAR_U16(tbl_prog_brdgeport_egress.pcindex);
+	/*Table Entry address (Bridge port egress Table index) Bit 7:0 in PCE_TBL_ADDR*/
+	tbl_prog_brdgeport_egress.pcindex |= (param->nBridgePortId & 0xFF);
+
+	/*Address-based write for ingress bridge port configuration*/
+	gsw_pce_table_write(cdev, &tbl_prog_brdgeport_ingress);
+	/*Address-based write for egress bridge port configuration*/
+	gsw_pce_table_write(cdev, &tbl_prog_brdgeport_egress);
+
+	ret = GSW_statusOk;
+
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_alloc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *param)
+{
+	pctbl_prog_t tbl_prog_brdgeport_ingress;
+	pctbl_prog_t tbl_prog_brdgeport_egress;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 idx = 0, FirstIdx, LastIdx, pmapper_idx, meterid;
+	u16 i, val_reg_idx, ret, IngressStpState, EgressStpState;
+	u32 BlkSize = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (param->nBridgePortId >= gswdev->num_of_bridge_port) {
+		pr_err("nBridgePortId %d is out of range [num_of_bridge_port supported =%d]\n",
+		       param->nBridgePortId, (gswdev->num_of_bridge_port - 1));
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*GSW_BRIDGE_PORT_CONFIG_MASK_FORCE is for debugging purpose only
+	 if this mask is enabled , there is no check on index in-use*/
+	if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+		/*If Bridge Port ID is valid,Check whether it is InUSE
+		  if not InUse,return ERROR*/
+		if (!(gswdev->brdgeportconfig_idx[param->nBridgePortId].IndexInUse)) {
+			pr_err("nBridgePortId %d Index not InUse\n", param->nBridgePortId);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/*Same bridge port idx for ingress and egress bridge port configuration*/
+	memset(&tbl_prog_brdgeport_ingress, 0, sizeof(pctbl_prog_t));
+	tbl_prog_brdgeport_ingress.table = PCE_IGBGP_INDEX;
+
+	CLEAR_U16(tbl_prog_brdgeport_ingress.pcindex);
+	/*Table Entry address (Bridge port ingress Table index) Bit 7:0 in PCE_TBL_ADDR*/
+	tbl_prog_brdgeport_ingress.pcindex |= (param->nBridgePortId & 0xFF);
+
+	memset(&tbl_prog_brdgeport_egress, 0, sizeof(pctbl_prog_t));
+	tbl_prog_brdgeport_egress.table = PCE_EGBGP_INDEX;
+	CLEAR_U16(tbl_prog_brdgeport_egress.pcindex);
+	/*Table Entry address (Bridge port egress Table index) Bit 7:0 in PCE_TBL_ADDR*/
+	tbl_prog_brdgeport_egress.pcindex |= (param->nBridgePortId & 0xFF);
+
+	/*Address-based read for ingress bridge port configuration
+	  read before set, so that previous value of this table index
+	  is not disturbed in the case of update specific fields.
+	*/
+	gsw_pce_table_read(cdev, &tbl_prog_brdgeport_ingress);
+
+	/*Address-based read for egress bridge port configuration
+	  read before set, so that previous value of this table index
+	  is not disturbed in the case of update specific fields.
+	*/
+	gsw_pce_table_read(cdev, &tbl_prog_brdgeport_egress);
+
+	/**Default Bridge Port Configuration Settings**/
+	/*By Default STP State are GSW_STP_PORT_STATE_FORWARD.
+	  it can be changed using GSW_STP_PortCfgSet
+	  GSW_BridgePortConfigSet will not set any STP related
+	  configuration in BridgePort Table*/
+	/*STP State - ingress*/
+	IngressStpState = (tbl_prog_brdgeport_ingress.val[0] & 0x7);
+	/*STP State - egress*/
+	EgressStpState = (tbl_prog_brdgeport_egress.val[0] & 0x7);
+
+	/*Both ingress/egress states must be same
+	 if not equal return error*/
+	if (IngressStpState != EgressStpState) {
+		pr_err("IngressStpState != EgressStpState");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*By default MAC Learning Limit default 255
+	  It can be changed using eMask
+	  GSW_BRIDGE_PORT_CONFIG_MASK_MAC_LEARNING_LIMIT
+	  and bMacLearningLimitEnable in GSW_BridgePortConfigSet*/
+	gswdev->brdgeportconfig_idx[param->nBridgePortId].LearningLimit =
+		(tbl_prog_brdgeport_ingress.val[4] & 0xFF);
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID) {
+		if (param->nBridgeId >= gswdev->num_of_bridge) {
+			pr_err("Error : nBridgeId %d >= gswdev->num_of_bridge %d\n",
+			       param->nBridgeId, gswdev->num_of_bridge);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/*GSW_BRIDGE_PORT_CONFIG_MASK_FORCE is for debugging purpose only
+		if this mask is enabled , there is no check on index in-use*/
+		if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+			/*This below field enable indicates that this bridge id is
+			 already assigned and it's idx recorded for this Bridge Port id.
+			 If next time the user update this meter field with different bridge idx !!
+			 or wanted to allocate a new bridge idx ??!! may happen by mistake ??!!
+			 the previous bridge idx must be released from this Bridge Port*/
+			if (gswdev->brdgeportconfig_idx[param->nBridgePortId].BrdgIdAssigned) {
+				if (gswdev->brdgeportconfig_idx[param->nBridgePortId].BrdgId !=
+				    param->nBridgeId) {
+					idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].BrdgId;
+					/*release the usage of previous bridge idx*/
+					gswdev->brdgeconfig_idx[idx].IndexInUsageCnt--;
+					gswdev->brdgeportconfig_idx[param->nBridgePortId].BrdgIdAssigned = 0;
+					gswdev->brdgeportconfig_idx[param->nBridgePortId].BrdgId = 0;
+				}
+			}
+
+			/*This Bridge ID should be in use (i.e) that is this Bridge ID should be allocated
+			  before calling bridge port configuration
+			  If not in use return ERROR
+			  */
+			if (gswdev->brdgeconfig_idx[param->nBridgeId].IndexInUse) {
+				/*Usage count will be incremented only once during bridge idx assignment
+				for this bridge port id*/
+				if (!gswdev->brdgeportconfig_idx[param->nBridgePortId].BrdgIdAssigned) {
+					gswdev->brdgeportconfig_idx[param->nBridgePortId].BrdgIdAssigned = 1;
+					gswdev->brdgeportconfig_idx[param->nBridgePortId].BrdgId
+						= param->nBridgeId;
+					/*Since this bridge id can be shared,Increment it's usage count*/
+					gswdev->brdgeconfig_idx[param->nBridgeId].IndexInUsageCnt++;
+				}
+			} else {
+				pr_err("gswdev->brdgeconfig_idx[param->nBridgeId].IndexInUse not in use\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+		}
+
+		/*Clear the Fields*/
+		tbl_prog_brdgeport_ingress.val[4] &= ~(0x3F << 8);
+		tbl_prog_brdgeport_ingress.val[4] |= ((param->nBridgeId & 0x3F) << 8);
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_VLAN) {
+		if (param->bIngressExtendedVlanEnable) {
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*This below field enable indicates that this vlan block is
+				 already assigned and it's Blk id recorded for this Bridge Port id.
+				 If next time the user update this Vlan blk field with different blk id !!
+				 or wanted to allocate a new vlan blk ??!! may happen by mistake ??!!
+				 the previous blk id must be released from this Bridge Port*/
+				if (gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressExVlanBlkAssigned) {
+					if (gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressExVlanBlkId !=
+					    param->nIngressExtendedVlanBlockId) {
+						idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressExVlanBlkId;
+						/*release the usage of previous vlan block id*/
+						gswdev->extendvlan_idx.vlan_idx[idx].IndexInUsageCnt--;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressExVlanBlkAssigned = 0;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressExVlanBlkId = EXVLAN_ENTRY_INVALID;
+					}
+				}
+			}
+
+			/*Note: First Index of the Block is the BlockID*/
+			FirstIdx = param->nIngressExtendedVlanBlockId;
+
+			if (FirstIdx >= gswdev->num_of_extendvlan) {
+				pr_err("in FirstIdx %d >= gswdev->num_of_egvlan %d\n", FirstIdx, gswdev->num_of_extendvlan);
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index belongs is InUse
+			  Since it will be marked as InUse during allocation.
+			*/
+			if (!gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUse) {
+				pr_err("!gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUse\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index belongs to this  BlockID
+			  Since it will be marked during allocation.
+			*/
+			if (gswdev->extendvlan_idx.vlan_idx[FirstIdx].VlanBlockId
+			    != param->nIngressExtendedVlanBlockId) {
+				pr_err("VlanBlockId != param->nIngressExtendedVlanBlockId\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Search for the Last Index of this block.
+			  Note: The Blocks are always allocated contiguously.
+			*/
+
+			LastIdx = FirstIdx;
+
+			while (gswdev->extendvlan_idx.vlan_idx[LastIdx].VlanBlockId == FirstIdx
+			       && gswdev->extendvlan_idx.vlan_idx[LastIdx].IndexInUse) {
+				LastIdx++;
+			}
+
+			BlkSize = param->nIngressExtendedVlanBlockSize;
+
+			if (BlkSize && ((FirstIdx + BlkSize) <= LastIdx))
+				LastIdx = (FirstIdx + BlkSize);
+
+			/*Enable Extended VLAN operation*/
+			tbl_prog_brdgeport_ingress.val[1] |= (1 << 14);
+			/*Set First Index of the Block*/
+			tbl_prog_brdgeport_ingress.val[1] &= ~(0x3FF);
+			tbl_prog_brdgeport_ingress.val[1] |= (FirstIdx & 0x3FF);
+			/*Set Last Index of the Block*/
+			tbl_prog_brdgeport_ingress.val[2] &= ~(0x3FF);
+			tbl_prog_brdgeport_ingress.val[2] |= ((LastIdx - 1) & 0x3FF);
+			pr_err("\nBridge port ExVlan FirstIdx = %d\n", FirstIdx);
+			pr_err("Bridge port ExVlan LastIdx  = %d\n", LastIdx - 1);
+
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*Usage count will be incremented only once during vlan blk assignment
+				for this bridge port id*/
+				if (!gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressExVlanBlkAssigned) {
+					gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressExVlanBlkAssigned = 1;
+					gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressExVlanBlkId
+						= param->nIngressExtendedVlanBlockId;
+					/*Since this vlan blk can be shared,Increment it's usage count*/
+					gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUsageCnt++;
+				}
+			}
+		} else {
+			/*Disable ingress Extended VLAN*/
+			tbl_prog_brdgeport_ingress.val[1] &= ~(1 << 14);
+
+			if (gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressExVlanBlkAssigned) {
+				idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressExVlanBlkId;
+				/*release the usage of vlan block id, if it is assigned previously
+				 when Extended vlan operation is disabled,it is must to release
+				 the mapped exvlan resource*/
+				gswdev->extendvlan_idx.vlan_idx[idx].IndexInUsageCnt--;
+				gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressExVlanBlkAssigned = 0;
+				gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressExVlanBlkId = EXVLAN_ENTRY_INVALID;
+			}
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN) {
+		if (param->bEgressExtendedVlanEnable) {
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*This below field enable indicates that this vlan block is
+				 already assigned and it's Blk id recorded for this Bridge Port id.
+				 If next time the user update this Vlan blk field with different blk id !!
+				 or wanted to allocate a new vlan blk ??!! may happen by mistake ??!!
+				 the previous blk id must be released from this Bridge Port*/
+				if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressExVlanBlkAssigned) {
+					if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressExVlanBlkId !=
+					    param->nEgressExtendedVlanBlockId) {
+						idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressExVlanBlkId;
+						/*release the usage of previous vlan block id*/
+						gswdev->extendvlan_idx.vlan_idx[idx].IndexInUsageCnt--;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressExVlanBlkAssigned = 0;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressExVlanBlkId = EXVLAN_ENTRY_INVALID;
+					}
+				}
+			}
+
+			/*Note: First Index of the Block is the BlockID*/
+			FirstIdx = param->nEgressExtendedVlanBlockId;
+
+			if (FirstIdx >= gswdev->num_of_extendvlan) {
+				pr_err("FirstIdx >= gswdev->num_of_egvlan\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index belongs is InUse
+			  Since it will be marked as InUse during allocation.
+			*/
+			if (!gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUse) {
+				pr_err("!gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUse\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index belongs to this  BlockID
+			  Since it will be marked during allocation.
+			*/
+			if (gswdev->extendvlan_idx.vlan_idx[FirstIdx].VlanBlockId
+			    != param->nEgressExtendedVlanBlockId) {
+				pr_err("VlanBlockId!= param->nEgressExtendedVlanBlockId\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Search for the Last Index of this block.
+			  Note: The Blocks are always allocated contiguously.
+			*/
+
+			LastIdx = FirstIdx;
+
+			while (gswdev->extendvlan_idx.vlan_idx[LastIdx].VlanBlockId == FirstIdx
+			       && gswdev->extendvlan_idx.vlan_idx[LastIdx].IndexInUse) {
+				LastIdx++;
+			}
+
+			BlkSize = param->nEgressExtendedVlanBlockSize;
+
+			if (BlkSize && ((FirstIdx + BlkSize) <= LastIdx))
+				LastIdx = (FirstIdx + BlkSize);
+
+			/*Enable Extended VLAN operation*/
+			tbl_prog_brdgeport_egress.val[1] |= (1 << 14);
+			/*Set First Index of the Block*/
+			tbl_prog_brdgeport_egress.val[1] &= ~(0x3FF);
+			tbl_prog_brdgeport_egress.val[1] |= (FirstIdx & 0x3FF);
+			/*Set Last Index of the Block*/
+			tbl_prog_brdgeport_egress.val[2] &= ~(0x3FF);
+			tbl_prog_brdgeport_egress.val[2] |= ((LastIdx - 1) & 0x3FF);
+
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*Usage count will be incremented only once during vlan blk assignment
+				for this bridge port id*/
+				if (!gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressExVlanBlkAssigned) {
+					gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressExVlanBlkAssigned = 1;
+					gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressExVlanBlkId
+						= param->nEgressExtendedVlanBlockId;
+					/*Since this vlan blk can be shared,Increment it's usage count*/
+					gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUsageCnt++;
+				}
+			}
+		} else {
+			/*Disable Egress Extended VLAN*/
+			tbl_prog_brdgeport_egress.val[1] &= ~(1 << 14);
+
+			if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressExVlanBlkAssigned) {
+				idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressExVlanBlkId;
+				/*release the usage of vlan block id, if it is assigned previously
+				 when Extended vlan operation is disabled,it is must to release
+				 the mapped exvlan resource*/
+				gswdev->extendvlan_idx.vlan_idx[idx].IndexInUsageCnt--;
+				gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressExVlanBlkAssigned = 0;
+				gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressExVlanBlkId = EXVLAN_ENTRY_INVALID;
+			}
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_MARKING) {
+		tbl_prog_brdgeport_ingress.val[3] &= ~(7);
+
+		switch (param->eIngressMarkingMode) {
+		case GSW_MARKING_ALL_GREEN:
+			break;
+
+		case GSW_MARKING_INTERNAL_MARKING:
+			tbl_prog_brdgeport_ingress.val[3] |= 0x1;
+			break;
+
+		case GSW_MARKING_DEI:
+			tbl_prog_brdgeport_ingress.val[3] |= 0x2;
+			break;
+
+		case GSW_MARKING_PCP_8P0D:
+			tbl_prog_brdgeport_ingress.val[3] |= 0x3;
+			break;
+
+		case GSW_MARKING_PCP_7P1D:
+			tbl_prog_brdgeport_ingress.val[3] |= 0x4;
+			break;
+
+		case GSW_MARKING_PCP_6P2D:
+			tbl_prog_brdgeport_ingress.val[3] |= 0x5;
+			break;
+
+		case GSW_MARKING_PCP_5P3D:
+			tbl_prog_brdgeport_ingress.val[3] |= 0x6;
+			break;
+
+		case GSW_MARKING_DSCP_AF:
+			tbl_prog_brdgeport_ingress.val[3] |= 0x7;
+			break;
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_REMARKING) {
+		tbl_prog_brdgeport_egress.val[3] &= ~(7);
+
+		switch (param->eEgressRemarkingMode) {
+		case GSW_REMARKING_NONE:
+			break;
+
+		case GSW_REMARKING_DEI:
+			tbl_prog_brdgeport_egress.val[3] |= 0x2;
+			break;
+
+		case GSW_REMARKING_PCP_8P0D:
+			tbl_prog_brdgeport_egress.val[3] |= 0x3;
+			break;
+
+		case GSW_REMARKING_PCP_7P1D:
+			tbl_prog_brdgeport_egress.val[3] |= 0x4;
+			break;
+
+		case GSW_REMARKING_PCP_6P2D:
+			tbl_prog_brdgeport_egress.val[3] |= 0x5;
+			break;
+
+		case GSW_REMARKING_PCP_5P3D:
+			tbl_prog_brdgeport_egress.val[3] |= 0x6;
+			break;
+
+		case GSW_REMARKING_DSCP_AF:
+			tbl_prog_brdgeport_egress.val[3] |= 0x7;
+			break;
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_METER) {
+		if (param->bIngressMeteringEnable) {
+			if (param->nIngressTrafficMeterId >= gswdev->num_of_meters) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*This below field enable indicates that this meter id is
+				 already assigned and it's idx recorded for this Bridge Port id.
+				 If next time the user update this meter field with different meter idx !!
+				 or wanted to allocate a new meter idx ??!! may happen by mistake ??!!
+				 the previous meter idx  must be released from this Bridge Port*/
+
+				if (gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressMeteringAssigned) {
+					if (gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressTrafficMeterId !=
+					    param->nIngressTrafficMeterId) {
+						idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressTrafficMeterId;
+						/*release the usage of previous meter idx*/
+						gswdev->meter_idx[idx].IndexInUsageCnt--;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressMeteringAssigned = 0;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressTrafficMeterId = 0;
+					}
+				}
+
+				/*This Meter ID should be in use (i.e) that is this Meter ID should be allocated
+				before calling bridge port configuration
+				If not in use return ERROR
+				*/
+				if (gswdev->meter_idx[param->nIngressTrafficMeterId].IndexInUse) {
+					/*Usage count will be incremented only once during meter idx assignment
+					for this bridge port id*/
+					if (!gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressMeteringAssigned) {
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressMeteringAssigned = 1;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressTrafficMeterId
+							= param->nIngressTrafficMeterId;
+						/*Since this meter id can be shared,Increment the it's usage count*/
+						gswdev->meter_idx[param->nIngressTrafficMeterId].IndexInUsageCnt++;
+					}
+				} else {
+					pr_err("gswdev->meter_idx[param->nIngressTrafficMeterId].IndexInUse\n");
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+			}
+
+			/*Enable Meter Id*/
+			tbl_prog_brdgeport_ingress.val[3] |= (1 << 7);
+			tbl_prog_brdgeport_ingress.val[3] &= ~(0x7F << 8);
+			tbl_prog_brdgeport_ingress.val[3] |= ((param->nIngressTrafficMeterId & 0x7F) << 8);
+		} else {
+			/*Disable Ingress Meter*/
+			tbl_prog_brdgeport_ingress.val[3] &= ~(1 << 7);
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_SUB_METER) {
+		/*GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST*/
+		if (param->bEgressSubMeteringEnable[0]) {
+			meterid = param->nEgressTrafficSubMeterId[0];
+
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*This below field enable indicates that this meter id is
+				 already assigned and it's idx recorded for this Bridge Port id.
+				 If next time the user update this meter field with different meter idx !!
+				 or wanted to allocate a new meter idx ??!! may happen by mistake ??!!
+				 the previous meter idx must be released from this Bridge Port*/
+
+				if (gswdev->brdgeportconfig_idx[param->nBridgePortId].BroadcastMeteringAssigned) {
+					if (gswdev->brdgeportconfig_idx[param->nBridgePortId].BroadcastMeteringId !=
+					    meterid) {
+						idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].BroadcastMeteringId;
+						/*release the usage of previous meter idx*/
+						gswdev->meter_idx[idx].IndexInUsageCnt--;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].BroadcastMeteringAssigned = 0;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].BroadcastMeteringId = 0;
+					}
+				}
+
+				/*This Meter ID should be in use (i.e) that is this Meter ID should be allocated
+				before calling bridge port configuration
+				If not in use return ERROR
+				*/
+				if (gswdev->meter_idx[meterid].IndexInUse) {
+					/*Usage count will be incremented only once during meter idx assignment
+					for this bridge port id*/
+					if (!gswdev->brdgeportconfig_idx[param->nBridgePortId].BroadcastMeteringAssigned) {
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].BroadcastMeteringAssigned = 1;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].BroadcastMeteringId
+							= meterid;
+						/*Since this meter id can be shared,Increment the it's usage count*/
+						gswdev->meter_idx[meterid].IndexInUsageCnt++;
+					}
+				} else {
+					pr_err("gswdev->meter_idx[meterid].IndexInUse\n");
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+			}
+
+			tbl_prog_brdgeport_egress.val[5] |= (1 << 7);
+			tbl_prog_brdgeport_egress.val[5] &= ~(0x7F << 8);
+			tbl_prog_brdgeport_egress.val[5] |= ((param->nEgressTrafficSubMeterId[0] & 0x7F) << 8);
+		} else {
+			/*Disable Broadcast sub meter*/
+			tbl_prog_brdgeport_egress.val[5] &= ~(1 << 7);
+		}
+
+		/*GSW_BRIDGE_PORT_EGRESS_METER_MULTICAST*/
+		if (param->bEgressSubMeteringEnable[1]) {
+			meterid = param->nEgressTrafficSubMeterId[1];
+
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*This below field enable indicates that this meter id is
+				 already assigned and it's idx recorded for this Bridge Port id.
+				 If next time the user update this meter field with different meter idx !!
+				 or wanted to allocate a new meter idx ??!! may happen by mistake ??!!
+				 the previous meter idx must be released from this Bridge Port*/
+
+				if (gswdev->brdgeportconfig_idx[param->nBridgePortId].MulticastMeteringAssigned) {
+					if (gswdev->brdgeportconfig_idx[param->nBridgePortId].MulticastMeteringId !=
+					    meterid) {
+						idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].MulticastMeteringId;
+						/*release the usage of previous meter idx*/
+						gswdev->meter_idx[idx].IndexInUsageCnt--;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].MulticastMeteringAssigned = 0;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].MulticastMeteringId = 0;
+					}
+				}
+
+				/*This Meter ID should be in use (i.e) that is this Meter ID should be allocated
+				before calling bridge port configuration
+				If not in use return ERROR
+				*/
+				if (gswdev->meter_idx[meterid].IndexInUse) {
+					/*Usage count will be incremented only once during meter idx assignment
+					for this bridge port id*/
+					if (!gswdev->brdgeportconfig_idx[param->nBridgePortId].MulticastMeteringAssigned) {
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].MulticastMeteringAssigned = 1;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].MulticastMeteringId
+							= meterid;
+						/*Since this meter id can be shared,Increment the it's usage count*/
+						gswdev->meter_idx[meterid].IndexInUsageCnt++;
+					}
+				} else {
+					pr_err("gswdev->meter_idx[meterid].IndexInUse\n");
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+			}
+
+			tbl_prog_brdgeport_egress.val[6] |= (1 << 7);
+			tbl_prog_brdgeport_egress.val[6] &= ~(0x7F << 8);
+			tbl_prog_brdgeport_egress.val[6] |= ((param->nEgressTrafficSubMeterId[1] & 0x7F) << 8);
+		} else {
+			/*Disable Multicast sub meter*/
+			tbl_prog_brdgeport_egress.val[6] &= ~(1 << 7);
+		}
+
+		/*GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_MC_IP*/
+		if (param->bEgressSubMeteringEnable[2]) {
+			meterid = param->nEgressTrafficSubMeterId[2];
+
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*This below field enable indicates that this meter id is
+				 already assigned and it's idx recorded for this Bridge Port id.
+				 If next time the user update this meter field with different meter idx !!
+				 or wanted to allocate a new meter idx ??!! may happen by mistake ??!!
+				 the previous meter idx must be released from this Bridge Port*/
+
+				if (gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiIpMeteringAssigned) {
+					if (gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiIpMeteringId !=
+					    meterid) {
+						idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiIpMeteringId;
+						/*release the usage of previous meter idx*/
+						gswdev->meter_idx[idx].IndexInUsageCnt--;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiIpMeteringAssigned = 0;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiIpMeteringId = 0;
+					}
+				}
+
+				/*This Meter ID should be in use (i.e) that is this Meter ID should be allocated
+				before calling bridge port configuration
+				If not in use return ERROR
+				*/
+				if (gswdev->meter_idx[meterid].IndexInUse) {
+					/*Usage count will be incremented only once during meter idx assignment
+					for this bridge port id*/
+					if (!gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiIpMeteringAssigned) {
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiIpMeteringAssigned = 1;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiIpMeteringId
+							= meterid;
+						/*Since this meter id can be shared,Increment the it's usage count*/
+						gswdev->meter_idx[meterid].IndexInUsageCnt++;
+					}
+
+				} else {
+					pr_err("gswdev->meter_idx[meterid].IndexInUse\n");
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+			}
+
+			tbl_prog_brdgeport_egress.val[9] |= (1 << 7);
+			tbl_prog_brdgeport_egress.val[9] &= ~(0x7F << 8);
+			tbl_prog_brdgeport_egress.val[9] |= ((param->nEgressTrafficSubMeterId[2] & 0x7F) << 8);
+		} else {
+			/*Disable Unknown Multicast ip sub meter*/
+			tbl_prog_brdgeport_egress.val[9] &= ~(1 << 7);
+		}
+
+		/*GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_MC_NON_IP*/
+		if (param->bEgressSubMeteringEnable[3]) {
+			meterid = param->nEgressTrafficSubMeterId[3];
+
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*This below field enable indicates that this meter id is
+				 already assigned and it's idx recorded for this Bridge Port id.
+				 If next time the user update this meter field with different meter idx !!
+				 or wanted to allocate a new meter idx ??!! may happen by mistake ??!!
+				 the previous meter idx must be released from this Bridge Port*/
+
+				if (gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiNonIpMeteringAssigned) {
+					if (gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiNonIpMeteringId !=
+					    meterid) {
+						idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiNonIpMeteringId;
+						/*release the usage of previous meter idx*/
+						gswdev->meter_idx[idx].IndexInUsageCnt--;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiNonIpMeteringAssigned = 0;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiNonIpMeteringId = 0;
+					}
+				}
+
+				/*This Meter ID should be in use (i.e) that is this Meter ID should be allocated
+				before calling bridge port configuration
+				If not in use return ERROR
+				*/
+				if (gswdev->meter_idx[meterid].IndexInUse) {
+					/*Usage count will be incremented only once during meter idx assignment
+					for this bridge port id*/
+					if (!gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiNonIpMeteringAssigned) {
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiNonIpMeteringAssigned = 1;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiNonIpMeteringId
+							= meterid;
+						/*Since this meter id can be shared,Increment the it's usage count*/
+						gswdev->meter_idx[meterid].IndexInUsageCnt++;
+					}
+				} else {
+					pr_err("gswdev->meter_idx[meterid].IndexInUse\n");
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+			}
+
+			tbl_prog_brdgeport_egress.val[8] |= (1 << 7);
+			tbl_prog_brdgeport_egress.val[8] &= ~(0x7F << 8);
+			tbl_prog_brdgeport_egress.val[8] |= ((param->nEgressTrafficSubMeterId[3] & 0x7F) << 8);
+		} else {
+			/*Disable Unknown Multicast Non-ip sub meter*/
+			tbl_prog_brdgeport_egress.val[8] &= ~(1 << 7);
+		}
+
+		/*GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_UC*/
+		if (param->bEgressSubMeteringEnable[4]) {
+			meterid = param->nEgressTrafficSubMeterId[4];
+
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*This below field enable indicates that this meter id is
+				 already assigned and it's idx recorded for this Bridge Port id.
+				 If next time the user update this meter field with different meter idx !!
+				 or wanted to allocate a new meter idx ??!! may happen by mistake ??!!
+				 the previous meter idx must be released from this Bridge Port*/
+
+				if (gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownUniCastMeteringAssigned) {
+					if (gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownUniCastMeteringId !=
+					    meterid) {
+						idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownUniCastMeteringId;
+						/*release the usage of previous meter idx*/
+						gswdev->meter_idx[idx].IndexInUsageCnt--;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownUniCastMeteringAssigned = 0;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownUniCastMeteringId = 0;
+					}
+				}
+
+				/*This Meter ID should be in use (i.e) that is this Meter ID should be allocated
+				before calling bridge port configuration
+				If not in use return ERROR
+				*/
+				if (gswdev->meter_idx[meterid].IndexInUse) {
+					/*Usage count will be incremented only once during meter idx assignment
+					for this bridge port id*/
+					if (!gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownUniCastMeteringAssigned) {
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownUniCastMeteringAssigned = 1;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownUniCastMeteringId
+							= meterid;
+						/*Since this meter id can be shared,Increment the it's usage count*/
+						gswdev->meter_idx[meterid].IndexInUsageCnt++;
+					}
+				} else {
+					pr_err("gswdev->meter_idx[meterid].IndexInUse\n");
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+			}
+
+			tbl_prog_brdgeport_egress.val[7] |= (1 << 7);
+			tbl_prog_brdgeport_egress.val[7] &= ~(0x7F << 8);
+			tbl_prog_brdgeport_egress.val[7] |= ((param->nEgressTrafficSubMeterId[4] & 0x7F) << 8);
+		} else {
+			/*Disable Unknown Unicast sub meter*/
+			tbl_prog_brdgeport_egress.val[7] &= ~(1 << 7);
+		}
+
+		/*GSW_BRIDGE_PORT_EGRESS_METER_OTHERS*/
+		if (param->bEgressSubMeteringEnable[5]) {
+			meterid = param->nEgressTrafficSubMeterId[5];
+
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*This below field enable indicates that this meter id is
+				 already assigned and it's idx recorded for this Bridge Port id.
+				 If next time the user update this meter field with different meter idx !!
+				 or wanted to allocate a new meter idx ??!! may happen by mistake ??!!
+				 the previous meter idx must be released from this Bridge Port*/
+
+				if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressMeteringAssigned) {
+					if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressTrafficMeterId !=
+					    meterid) {
+						idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressTrafficMeterId;
+						/*release the usage of previous meter idx*/
+						gswdev->meter_idx[idx].IndexInUsageCnt--;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressMeteringAssigned = 0;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressTrafficMeterId = 0;
+					}
+				}
+
+				/*This Meter ID should be in use (i.e) that is this Meter ID should be allocated
+				before calling bridge port configuration
+				If not in use return ERROR
+				*/
+				if (gswdev->meter_idx[meterid].IndexInUse) {
+					/*Usage count will be incremented only once during meter idx assignment
+					for this bridge port id*/
+					if (!gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressMeteringAssigned) {
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressMeteringAssigned = 1;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressTrafficMeterId
+							= meterid;
+						/*Since this meter id can be shared,Increment the it's usage count*/
+						gswdev->meter_idx[meterid].IndexInUsageCnt++;
+					}
+
+				} else {
+					pr_err("Meter Id not In Use\n");
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+
+			}
+
+			/*Enable Meter Id*/
+			tbl_prog_brdgeport_egress.val[3] |= (1 << 7);
+			tbl_prog_brdgeport_egress.val[3] &= ~(0x7F << 8);
+			tbl_prog_brdgeport_egress.val[3] |= ((param->nEgressTrafficSubMeterId[5] & 0x7F) << 8);
+		} else {
+			/*Disable Egress Meter*/
+			tbl_prog_brdgeport_egress.val[3] &= ~(1 << 7);
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_CTP_MAPPING) {
+		/** This field defines destination logical port. */
+		tbl_prog_brdgeport_egress.val[4] &= ~(0xF << 8);
+		tbl_prog_brdgeport_egress.val[4] |= ((param->nDestLogicalPortId & 0xF) << 8);
+
+		if (param->bPmapperEnable) {
+			/*This below field indicates that one P-mapper idx is already allocated and
+			 it's idx recorded for this Bridge Port id.
+			 If next time the user update this p-mapper field with different p-mapper idx !!
+			 or wanted to allocate a new p-mapper idx ??!! may happen by mistake ??!!
+			 the previous p-mapper idx should be released*/
+
+			/*TODO:changed as per code review
+			 As per code review - user is not responsible pmapper allocation*/
+			if (gswdev->brdgeportconfig_idx[param->nBridgePortId].PmapperAssigned)
+				param->sPmapper.nPmapperId = gswdev->brdgeportconfig_idx[param->nBridgePortId].PmappperIdx;
+			else
+				param->sPmapper.nPmapperId = PMAPPER_ENTRY_INVALID;
+
+			/** When bPmapperEnable is TRUE, this field selects either DSCP or PCP to
+			 derive sub interface ID. */
+			/*PCP-P-mapper table entry 1-8*/
+			/*DSCP-P-mapper table entry 9-72. */
+			switch (param->ePmapperMappingMode) {
+			case GSW_PMAPPER_MAPPING_PCP:
+				tbl_prog_brdgeport_egress.val[4] &= ~(1 << 13);
+				break;
+
+			case GSW_PMAPPER_MAPPING_DSCP:
+				tbl_prog_brdgeport_egress.val[4] |= (1 << 13);
+				break;
+			}
+
+			/* If the p-mapper id is invalid then the GSW_QOS_PmapperTableSet will
+			   Allocate/program P-mapper index.
+			   If p-mapper index is valid the GSW_QOS_PmapperTableSet will just program
+			   the table
+			 */
+			ret = GSW_QOS_PmapperTableSet(cdev, &param->sPmapper);
+
+			if (ret == GSW_statusErr) {
+				pr_err("GSW_QOS_PmapperTableSet ERROR\n");
+				goto UNLOCK_AND_RETURN;
+			}
+
+			pmapper_idx = param->sPmapper.nPmapperId;
+
+			/*Usage count will be incremented only once during p-mapper idx allocation
+			 or assignment for this bridge port id*/
+			if (!gswdev->brdgeportconfig_idx[param->nBridgePortId].PmapperAssigned) {
+				gswdev->brdgeportconfig_idx[param->nBridgePortId].PmapperAssigned = 1;
+				gswdev->brdgeportconfig_idx[param->nBridgePortId].PmappperIdx = pmapper_idx;
+			}
+
+			tbl_prog_brdgeport_egress.val[4] |= (1 << 14);
+			tbl_prog_brdgeport_egress.val[4] &= ~(0xFF);
+			tbl_prog_brdgeport_egress.val[4] |= (pmapper_idx & 0xFF);
+		} else {
+			/** When bPmapperEnable is FALSE, this field defines destination sub
+				interface ID group. */
+			/*Disable p-mapper*/
+			tbl_prog_brdgeport_egress.val[4] &= ~(1 << 14);
+			tbl_prog_brdgeport_egress.val[4] &= ~(0xFF);
+			tbl_prog_brdgeport_egress.val[4] |= (param->nDestSubIfIdGroup & 0xFF);
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP) {
+		val_reg_idx = 10;
+
+		for (i = 0; i < 8; i++) {
+			tbl_prog_brdgeport_ingress.val[val_reg_idx] = (param->nBridgePortMap[i] & 0xFFFF);
+			val_reg_idx++;
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_DEST_IP_LOOKUP) {
+		/* 0- disable , 1 - enable*/
+		if (param->bMcDestIpLookupDisable)
+			tbl_prog_brdgeport_ingress.val[0] |= (1 << 13);
+		else
+			tbl_prog_brdgeport_ingress.val[0] &= ~(1 << 13);
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_SRC_IP_LOOKUP) {
+		/* 0- disable , 1 - enable*/
+		if (param->bMcSrcIpLookupEnable)
+			tbl_prog_brdgeport_ingress.val[0] |= (1 << 9);
+		else
+			tbl_prog_brdgeport_ingress.val[0] &= ~(1 << 9);
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_DEST_MAC_LOOKUP) {
+		/* 1- disable , 0 - enable*/
+		if (param->bDestMacLookupDisable)
+			tbl_prog_brdgeport_ingress.val[0] |= (1 << 14);
+		else
+			tbl_prog_brdgeport_ingress.val[0] &= ~(1 << 14);
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_SRC_MAC_LEARNING) {
+		/* 1- disable , 0 - enable*/
+		if (param->bSrcMacLearningDisable)
+			tbl_prog_brdgeport_ingress.val[0] |= (1 << 15);
+		else
+			tbl_prog_brdgeport_ingress.val[0] &= ~(1 << 15);
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MAC_SPOOFING) {
+		/* 0- disable , 1 - enable*/
+		if (param->bMacSpoofingDetectEnable)
+			tbl_prog_brdgeport_ingress.val[0] |= (1 << 11);
+		else
+			tbl_prog_brdgeport_ingress.val[0] &= ~(1 << 11);
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_PORT_LOCK) {
+		/* 0- disable , 1 - enable*/
+		if (param->bPortLockEnable)
+			tbl_prog_brdgeport_ingress.val[0] |= (1 << 12);
+		else
+			tbl_prog_brdgeport_ingress.val[0] &= ~(1 << 12);
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_VLAN_FILTER) {
+		/*BypassEgress vlan filter range 1*/
+		if (param->bBypassEgressVlanFilter1)
+			tbl_prog_brdgeport_ingress.val[5] |= (1 << 15);
+		else
+			tbl_prog_brdgeport_ingress.val[5] &= ~(1 << 15);
+
+		if (param->bIngressVlanFilterEnable) {
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*This below field enable indicates that this vlan block is
+				 already assigned and it's Blk id recorded for this Bridge Port id.
+				 If next time the user update this Vlan blk field with different blk id !!
+				 or wanted to allocate a new vlan blk ??!! may happen by mistake ??!!
+				 the previous blk id must be released from this Bridge Port*/
+
+				if (gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressVlanFilterAssigned) {
+					if (gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressVlanFilterBlkId !=
+					    param->nIngressVlanFilterBlockId) {
+						idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressVlanFilterBlkId;
+						/*release the usage of previous vlan block id*/
+						gswdev->vlanfilter_idx.filter_idx[idx].IndexInUsageCnt--;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressVlanFilterAssigned = 0;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressVlanFilterBlkId = VLANFILTER_ENTRY_INVALID;
+					}
+				}
+			}
+
+			/*Note: First Index of the Block is the BlockID*/
+			FirstIdx = param->nIngressVlanFilterBlockId;
+
+			if (FirstIdx > gswdev->num_of_vlanfilter) {
+				pr_err("FirstIdx > gswdev->num_of_vlanfilter\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index belongs is InUse
+			  Since it will be marked as InUse during allocation.
+			*/
+			if (!gswdev->vlanfilter_idx.filter_idx[FirstIdx].IndexInUse) {
+				pr_err("!gswdev->vlanfilter_idx.filter_idx[FirstIdx].IndexInUse\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index belongs to this  BlockID
+			  Since it will be marked during allocation.
+			*/
+			if (gswdev->vlanfilter_idx.filter_idx[FirstIdx].FilterBlockId
+			    != param->nIngressVlanFilterBlockId) {
+				pr_err("FilterBlockId != param->nIngressVlanFilterBlockId\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Search for the Last Index of this block.
+			  Note: The Blocks are always allocated contiguously.
+			*/
+
+			LastIdx = FirstIdx;
+
+			while (gswdev->vlanfilter_idx.filter_idx[LastIdx].FilterBlockId == FirstIdx
+			       && gswdev->vlanfilter_idx.filter_idx[LastIdx].IndexInUse) {
+				LastIdx++;
+			}
+
+			BlkSize = param->nIngressVlanFilterBlockSize;
+
+			if (BlkSize && ((FirstIdx + BlkSize) <= LastIdx))
+				LastIdx = (FirstIdx + BlkSize);
+
+			/* enable ingress VLAN filtering*/
+			tbl_prog_brdgeport_ingress.val[5] |= (1 << 14);
+			/*Set First Index of the Block*/
+			tbl_prog_brdgeport_ingress.val[5] &= ~(0x3FF);
+			tbl_prog_brdgeport_ingress.val[5] |= (FirstIdx & 0x3FF);
+			/*Set Last Index of the Block*/
+			tbl_prog_brdgeport_ingress.val[6] &= ~(0x3FF);
+			tbl_prog_brdgeport_ingress.val[6] |= ((LastIdx - 1) & 0x3FF);
+
+			if (gswdev->vlanfilter_idx.filter_idx[FirstIdx].DiscardUntagged)
+				tbl_prog_brdgeport_ingress.val[5] |= (1 << 12);
+			else
+				tbl_prog_brdgeport_ingress.val[5] &= ~(1 << 12);
+
+			if (gswdev->vlanfilter_idx.filter_idx[FirstIdx].DiscardUnMatchedTagged)
+				tbl_prog_brdgeport_ingress.val[5] |= (1 << 13);
+			else
+				tbl_prog_brdgeport_ingress.val[5] &= ~(1 << 13);
+
+
+			/* mask mode
+				00 :VID Only
+				01 :RESERVED
+				10 :PCP
+				11 :TCI
+			*/
+
+			tbl_prog_brdgeport_ingress.val[6] &= ~(0x3000);
+
+			switch (gswdev->vlanfilter_idx.filter_idx[FirstIdx].FilterMask) {
+			case GSW_VLAN_FILTER_TCI_MASK_VID:
+				break;
+
+			case GSW_VLAN_FILTER_TCI_MASK_PCP:
+				tbl_prog_brdgeport_ingress.val[6] |= (2 << 12);
+				break;
+
+			case GSW_VLAN_FILTER_TCI_MASK_TCI:
+				tbl_prog_brdgeport_ingress.val[6] |= (3 << 12);
+				break;
+			}
+
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*Usage count will be incremented only once during vlan blk assignment
+				for this bridge port id*/
+				if (!gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressVlanFilterAssigned) {
+					gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressVlanFilterAssigned = 1;
+					gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressVlanFilterBlkId
+						= param->nIngressVlanFilterBlockId;
+					/*Since this vlan blk can be shared,Increment it's usage count*/
+					gswdev->vlanfilter_idx.filter_idx[FirstIdx].IndexInUsageCnt++;;
+				}
+			}
+		} else {
+			/* disable ingress VLAN filtering*/
+			tbl_prog_brdgeport_ingress.val[5] &= ~(1 << 14);
+
+			if (gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressVlanFilterAssigned) {
+				idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressVlanFilterBlkId;
+				/*release the usage of vlan block id, if it is assigned previously
+				 when vlan filter operation is disabled,it is must to release
+				 the mapped vlan filter resource*/
+				gswdev->vlanfilter_idx.filter_idx[idx].IndexInUsageCnt--;
+				gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressVlanFilterAssigned = 0;
+				gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressVlanFilterBlkId = VLANFILTER_ENTRY_INVALID;
+			}
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN_FILTER1) {
+		if (param->bEgressVlanFilter1Enable) {
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*This below field enable indicates that this vlan block is
+				 already assigned and it's Blk id recorded for this Bridge Port id.
+				 If next time the user update this Vlan blk field with different blk id !!
+				 or wanted to allocate a new vlan blk ??!! may happen by mistake ??!!
+				 the previous blk id must be released from this Bridge Port*/
+
+				if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter1Assigned) {
+					if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter1BlkId !=
+					    param->nEgressVlanFilter1BlockId) {
+						idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter1BlkId;
+						/*release the usage of previous vlan block id*/
+						gswdev->vlanfilter_idx.filter_idx[idx].IndexInUsageCnt--;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter1Assigned = 0;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter1BlkId = VLANFILTER_ENTRY_INVALID;
+					}
+				}
+			}
+
+			/*Note: First Index of the Block is the BlockID*/
+			FirstIdx = param->nEgressVlanFilter1BlockId;
+
+			if (FirstIdx > gswdev->num_of_vlanfilter) {
+				pr_err("FirstIdx > gswdev->num_of_vlanfilter\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index belongs is InUse
+			  Since it will be marked as InUse during allocation.
+			*/
+			if (!gswdev->vlanfilter_idx.filter_idx[FirstIdx].IndexInUse) {
+				pr_err("!gswdev->vlanfilter_idx.filter_idx[FirstIdx].IndexInUse\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index belongs to this  BlockID
+			  Since it will be marked during allocation.
+			*/
+			if (gswdev->vlanfilter_idx.filter_idx[FirstIdx].FilterBlockId
+			    != param->nEgressVlanFilter1BlockId) {
+				pr_err("FilterBlockId != param->nEgressVlanFilter1BlockId\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Search for the Last Index of this block.
+			  Note: The Blocks are always allocated contiguously.
+			*/
+
+			LastIdx = FirstIdx;
+
+			while (gswdev->vlanfilter_idx.filter_idx[LastIdx].FilterBlockId == FirstIdx
+			       && gswdev->vlanfilter_idx.filter_idx[LastIdx].IndexInUse) {
+				LastIdx++;
+			}
+
+			BlkSize = param->nEgressVlanFilter1BlockSize;
+
+			if (BlkSize && ((FirstIdx + BlkSize) <= LastIdx))
+				LastIdx = (FirstIdx + BlkSize);
+
+			/* enable egress VLAN filtering -Range 1*/
+			tbl_prog_brdgeport_egress.val[10] |= (1 << 14);
+			/*Set First Index of the Block*/
+			tbl_prog_brdgeport_egress.val[10] &= ~(0x3FF);
+			tbl_prog_brdgeport_egress.val[10] |= (FirstIdx & 0x3FF);
+			/*Set Last Index of the Block*/
+			tbl_prog_brdgeport_egress.val[11] &= ~(0x3FF);
+			tbl_prog_brdgeport_egress.val[11] |= ((LastIdx - 1) & 0x3FF);
+
+
+
+			if (gswdev->vlanfilter_idx.filter_idx[FirstIdx].DiscardUntagged)
+				tbl_prog_brdgeport_egress.val[10] |= (1 << 12);
+			else
+				tbl_prog_brdgeport_egress.val[10] &= ~(1 << 12);
+
+			if (gswdev->vlanfilter_idx.filter_idx[FirstIdx].DiscardUnMatchedTagged)
+				tbl_prog_brdgeport_egress.val[10] |= (1 << 13);
+			else
+				tbl_prog_brdgeport_egress.val[10] &= ~(1 << 13);
+
+			/* mask mode
+				00 :VID Only
+				01 :RESERVED
+				10 :PCP
+				11 :TCI
+			*/
+			tbl_prog_brdgeport_egress.val[11] &= ~(0x3000);
+
+			switch (gswdev->vlanfilter_idx.filter_idx[FirstIdx].FilterMask) {
+			case GSW_VLAN_FILTER_TCI_MASK_VID:
+				break;
+
+			case GSW_VLAN_FILTER_TCI_MASK_PCP:
+				tbl_prog_brdgeport_egress.val[11] |= (2 << 12);
+				break;
+
+			case GSW_VLAN_FILTER_TCI_MASK_TCI:
+				tbl_prog_brdgeport_egress.val[11] |= (3 << 12);
+				break;
+			}
+
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*Usage count will be incremented only once during vlan blk assignment
+				for this bridge port id*/
+				if (!gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter1Assigned) {
+					gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter1Assigned = 1;
+					gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter1BlkId
+						= param->nEgressVlanFilter1BlockId;
+					/*Since this vlan blk can be shared,Increment it's usage count*/
+					gswdev->vlanfilter_idx.filter_idx[FirstIdx].IndexInUsageCnt++;;
+				}
+			}
+		} else {
+			/* disable Egress VLAN filtering - Range 1*/
+			tbl_prog_brdgeport_ingress.val[10] &= ~(1 << 14);
+
+			if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter1Assigned) {
+				idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter1BlkId;
+				/*release the usage of vlan block id, if it is assigned previously
+				 when vlan filter operation is disabled,it is must to release
+				 the mapped vlan filter resource*/
+				gswdev->vlanfilter_idx.filter_idx[idx].IndexInUsageCnt--;
+				gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter1Assigned = 0;
+				gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter1BlkId = VLANFILTER_ENTRY_INVALID;
+			}
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN_FILTER2) {
+		if (param->bEgressVlanFilter2Enable) {
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*This below field enable indicates that this vlan block is
+				 already assigned and it's Blk id recorded for this Bridge Port id.
+				 If next time the user update this Vlan blk field with different blk id !!
+				 or wanted to allocate a new vlan blk ??!! may happen by mistake ??!!
+				 the previous blk id must be released from this Bridge Port*/
+
+				if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter2Assigned) {
+					if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter2BlkId !=
+					    param->nEgressVlanFilter2BlockId) {
+						idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter2BlkId;
+						/*release the usage of previous vlan block id*/
+						gswdev->vlanfilter_idx.filter_idx[idx].IndexInUsageCnt--;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter2Assigned = 0;
+						gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter2BlkId = VLANFILTER_ENTRY_INVALID;
+					}
+				}
+			}
+
+			/*Note: First Index of the Block is the BlockID*/
+			FirstIdx = param->nEgressVlanFilter2BlockId;
+
+			if (FirstIdx > gswdev->num_of_vlanfilter) {
+				pr_err("FirstIdx > gswdev->num_of_vlanfilter\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index belongs is InUse
+			  Since it will be marked as InUse during allocation.
+			*/
+			if (!gswdev->vlanfilter_idx.filter_idx[FirstIdx].IndexInUse) {
+				pr_err("!gswdev->vlanfilter_idx.filter_idx[FirstIdx].IndexInUse\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index belongs to this  BlockID
+			  Since it will be marked during allocation.
+			*/
+			if (gswdev->vlanfilter_idx.filter_idx[FirstIdx].FilterBlockId
+			    != param->nEgressVlanFilter2BlockId) {
+				pr_err("FilterBlockId != param->nEgressVlanFilter2BlockId\n");
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Search for the Last Index of this block.
+			  Note: The Blocks are always allocated contiguously.
+			*/
+
+			LastIdx = FirstIdx;
+
+			while (gswdev->vlanfilter_idx.filter_idx[LastIdx].FilterBlockId == FirstIdx
+			       && gswdev->vlanfilter_idx.filter_idx[LastIdx].IndexInUse) {
+				LastIdx++;
+			}
+
+			BlkSize = param->nEgressVlanFilter2BlockSize;
+
+			if (BlkSize && ((FirstIdx + BlkSize) <= LastIdx))
+				LastIdx = (FirstIdx + BlkSize);
+
+			/* enable egress VLAN filtering -Range 2*/
+			tbl_prog_brdgeport_egress.val[12] |= (1 << 14);
+			/*Set First Index of the Block*/
+			tbl_prog_brdgeport_egress.val[12] &= ~(0x3FF);
+			tbl_prog_brdgeport_egress.val[12] |= (FirstIdx & 0x3FF);
+			/*Set Last Index of the Block*/
+			tbl_prog_brdgeport_egress.val[13] &= ~(0x3FF);
+			tbl_prog_brdgeport_egress.val[13] |= ((LastIdx - 1) & 0x3FF);
+
+
+
+			if (gswdev->vlanfilter_idx.filter_idx[FirstIdx].DiscardUntagged)
+				tbl_prog_brdgeport_egress.val[12] |= (1 << 12);
+			else
+				tbl_prog_brdgeport_egress.val[12] &= ~(1 << 12);
+
+			if (gswdev->vlanfilter_idx.filter_idx[FirstIdx].DiscardUnMatchedTagged)
+				tbl_prog_brdgeport_egress.val[12] |= (1 << 13);
+			else
+				tbl_prog_brdgeport_egress.val[12] &= ~(1 << 13);
+
+			/* mask mode
+				00 :VID Only
+				01 :RESERVED
+				10 :PCP
+				11 :TCI
+			*/
+			tbl_prog_brdgeport_egress.val[13] &= ~(0x3000);
+
+			switch (gswdev->vlanfilter_idx.filter_idx[FirstIdx].FilterMask) {
+			case GSW_VLAN_FILTER_TCI_MASK_VID:
+				break;
+
+			case GSW_VLAN_FILTER_TCI_MASK_PCP:
+				tbl_prog_brdgeport_egress.val[13] |= (2 << 12);
+				break;
+
+			case GSW_VLAN_FILTER_TCI_MASK_TCI:
+				tbl_prog_brdgeport_egress.val[13] |= (3 << 12);
+				break;
+			}
+
+			if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+				/*Usage count will be incremented only once during vlan blk assignment
+				for this bridge port id*/
+				if (!gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter2Assigned) {
+					gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter2Assigned = 1;
+					gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter2BlkId
+						= param->nEgressVlanFilter2BlockId;
+					/*Since this vlan blk can be shared,Increment it's usage count*/
+					gswdev->vlanfilter_idx.filter_idx[FirstIdx].IndexInUsageCnt++;
+				}
+			}
+		} else {
+			/* disable Egress VLAN filtering - Range 2*/
+			tbl_prog_brdgeport_ingress.val[12] &= ~(1 << 14);
+
+			if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter2Assigned) {
+				idx = gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter2BlkId;
+				/*release the usage of vlan block id, if it is assigned previously
+				 when vlan filter operation is disabled,it is must to release
+				 the mapped vlan filter resource*/
+				gswdev->vlanfilter_idx.filter_idx[idx].IndexInUsageCnt--;
+				gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter2Assigned = 0;
+				gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter2BlkId = VLANFILTER_ENTRY_INVALID;
+			}
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MAC_LEARNING_LIMIT) {
+		if (param->bMacLearningLimitEnable) {
+			tbl_prog_brdgeport_ingress.val[4] &= ~0xFF;
+			tbl_prog_brdgeport_ingress.val[4] |= (param->nMacLearningLimit & 0xFF);
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].LearningLimit =
+				param->nMacLearningLimit;
+		}
+	}
+
+	/*Same bridge port idx for ingress and egress bridge port configuration*/
+	tbl_prog_brdgeport_ingress.table = PCE_IGBGP_INDEX;
+	CLEAR_U16(tbl_prog_brdgeport_ingress.pcindex);
+	/*Table Entry address (Bridge port ingress Table index) Bit 7:0 in PCE_TBL_ADDR*/
+	tbl_prog_brdgeport_ingress.pcindex |= (param->nBridgePortId & 0xFF);
+
+	tbl_prog_brdgeport_egress.table = PCE_EGBGP_INDEX;
+	CLEAR_U16(tbl_prog_brdgeport_egress.pcindex);
+	/*Table Entry address (Bridge port egress Table index) Bit 7:0 in PCE_TBL_ADDR*/
+	tbl_prog_brdgeport_egress.pcindex |= (param->nBridgePortId & 0xFF);
+
+	/*Address-based write for ingress bridge port configuration*/
+	gsw_pce_table_write(cdev, &tbl_prog_brdgeport_ingress);
+	/*Address-based write for egress bridge port configuration*/
+	gsw_pce_table_write(cdev, &tbl_prog_brdgeport_egress);
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_BridgePortFree(void *cdev, GSW_BRIDGE_portAlloc_t *param)
+{
+	pctbl_prog_t tbl_prog_brdgeport_ingress;
+	pctbl_prog_t tbl_prog_brdgeport_egress;
+	GSW_BRIDGE_portConfig_t temp;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 FirstIdx, count;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (param->nBridgePortId >= gswdev->num_of_bridge_port) {
+		pr_err("nBridgePortId %d is out of range [num_of_bridge_port supported =%d]\n", param->nBridgePortId, (gswdev->num_of_bridge_port - 1));
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*If Bridge Port ID is valid,Check whether it is InUSE
+	  if not InUse,return ERROR*/
+	if (!gswdev->brdgeportconfig_idx[param->nBridgePortId].IndexInUse) {
+		pr_err("nBridgePortId %u is Not inUse -> need to allocate before freeing\n", param->nBridgePortId);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*If this Bridge port usage count is not zero that means it is still used by some one.
+	  This Bridge configuration can be deleted, only if that some one release this Bridge
+	  port*/
+	if (gswdev->brdgeportconfig_idx[param->nBridgePortId].IndexInUsageCnt) {
+		count = gswdev->brdgeportconfig_idx[param->nBridgePortId].IndexInUsageCnt;
+		pr_err("BridgePortId %u's IndexInUsageCnt=%u is not Zero , some CTP is holding this BP \n",
+		       param->nBridgePortId, count);
+		pr_err("Free that CTP first,which will detach this association\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*Same Bridge port idx for ingress and egress bridge port configuration*/
+	memset(&tbl_prog_brdgeport_ingress, 0, sizeof(pctbl_prog_t));
+	tbl_prog_brdgeport_ingress.table = PCE_IGBGP_INDEX;
+	CLEAR_U16(tbl_prog_brdgeport_ingress.pcindex);
+	/*Table Entry address (Bridge port ingress Table index) Bit 7:0 in PCE_TBL_ADDR*/
+	tbl_prog_brdgeport_ingress.pcindex |= (param->nBridgePortId & 0xFF);
+
+	memset(&tbl_prog_brdgeport_egress, 0, sizeof(pctbl_prog_t));
+	tbl_prog_brdgeport_egress.table = PCE_EGBGP_INDEX;
+	CLEAR_U16(tbl_prog_brdgeport_egress.pcindex);
+	/*Table Entry address (Bridge port egress Table index) Bit 7:0 in PCE_TBL_ADDR*/
+	tbl_prog_brdgeport_egress.pcindex |= (param->nBridgePortId & 0xFF);
+
+	/*Address-based read for ingress bridge port configuration*/
+	gsw_pce_table_read(cdev, &tbl_prog_brdgeport_ingress);
+
+	/*Address-based read for egress bridge port configuration*/
+	gsw_pce_table_read(cdev, &tbl_prog_brdgeport_egress);
+
+	temp.nBridgeId = ((tbl_prog_brdgeport_ingress.val[4] & 0x3F00) >> 8);
+
+	if (gswdev->brdgeportconfig_idx[param->nBridgePortId].BrdgIdAssigned) {
+		if (gswdev->brdgeportconfig_idx[param->nBridgePortId].BrdgId ==
+		    temp.nBridgeId) {
+			/*Release this Bridge from this Bridge Port*/
+			gswdev->brdgeconfig_idx[temp.nBridgeId].IndexInUsageCnt--;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].BrdgIdAssigned = 0;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].BrdgId = 0;
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	temp.nIngressExtendedVlanBlockId = (tbl_prog_brdgeport_ingress.val[1] & 0x3FFF);
+
+	if (gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressExVlanBlkAssigned) {
+		if (gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressExVlanBlkId ==
+		    temp.nIngressExtendedVlanBlockId) {
+			/*Release this vlan blk from this Bridge Port*/
+			FirstIdx = temp.nIngressExtendedVlanBlockId;
+			gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUsageCnt--;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressExVlanBlkAssigned = 0;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressExVlanBlkId = EXVLAN_ENTRY_INVALID;
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	temp.nEgressExtendedVlanBlockId = (tbl_prog_brdgeport_egress.val[1] & 0x3FFF);
+
+	if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressExVlanBlkAssigned) {
+		if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressExVlanBlkId ==
+		    temp.nEgressExtendedVlanBlockId) {
+			/*Release this vlan blk from this Bridge Port*/
+			FirstIdx = temp.nEgressExtendedVlanBlockId;
+			gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUsageCnt--;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressExVlanBlkAssigned = 0;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressExVlanBlkId = EXVLAN_ENTRY_INVALID;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	temp.nIngressTrafficMeterId = ((tbl_prog_brdgeport_ingress.val[3] & 0x7F00) >> 8);
+
+	if (gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressMeteringAssigned) {
+		if (gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressTrafficMeterId ==
+		    temp.nIngressTrafficMeterId) {
+			/*Release this meter id from this Bridge Port*/
+			gswdev->meter_idx[temp.nIngressTrafficMeterId].IndexInUsageCnt--;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressMeteringAssigned = 0;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressTrafficMeterId = 0;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/*other meter*/
+	temp.nEgressTrafficSubMeterId[5] = ((tbl_prog_brdgeport_egress.val[3] & 0x7F00) >> 8);
+
+	if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressMeteringAssigned) {
+		if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressTrafficMeterId ==
+		    temp.nEgressTrafficSubMeterId[5]) {
+			/*Release this meter id from this Bridge Port*/
+			gswdev->meter_idx[temp.nEgressTrafficSubMeterId[5]].IndexInUsageCnt--;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressMeteringAssigned = 0;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressTrafficMeterId = 0;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/*Egress Broadcast Meter*/
+	temp.nEgressTrafficSubMeterId[0] = ((tbl_prog_brdgeport_egress.val[5] & 0x7F00) >> 8);
+
+	if (gswdev->brdgeportconfig_idx[param->nBridgePortId].BroadcastMeteringAssigned) {
+		if (gswdev->brdgeportconfig_idx[param->nBridgePortId].BroadcastMeteringId ==
+		    temp.nEgressTrafficSubMeterId[0]) {
+			/*Release this meter id from this Bridge Port*/
+			gswdev->meter_idx[temp.nEgressTrafficSubMeterId[0]].IndexInUsageCnt--;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].BroadcastMeteringAssigned = 0;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].BroadcastMeteringId = 0;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/*Egress Multicast Meter*/
+	temp.nEgressTrafficSubMeterId[1] = ((tbl_prog_brdgeport_egress.val[6] & 0x7F00) >> 8);
+
+	if (gswdev->brdgeportconfig_idx[param->nBridgePortId].MulticastMeteringAssigned) {
+		if (gswdev->brdgeportconfig_idx[param->nBridgePortId].MulticastMeteringId ==
+		    temp.nEgressTrafficSubMeterId[1]) {
+			/*Release this meter id from this Bridge Port*/
+			gswdev->meter_idx[temp.nEgressTrafficSubMeterId[1]].IndexInUsageCnt--;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].MulticastMeteringAssigned = 0;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].MulticastMeteringId = 0;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/*Egress Unknown Multicast IP Meter*/
+	temp.nEgressTrafficSubMeterId[2] = ((tbl_prog_brdgeport_egress.val[9] & 0x7F00) >> 8);
+
+	if (gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiIpMeteringAssigned) {
+		if (gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiIpMeteringId ==
+		    temp.nEgressTrafficSubMeterId[2]) {
+			/*Release this meter id from this Bridge Port*/
+			gswdev->meter_idx[temp.nEgressTrafficSubMeterId[2]].IndexInUsageCnt--;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiIpMeteringAssigned = 0;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiIpMeteringId = 0;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/*Egress Unknown Multicast NON IP Meter*/
+	temp.nEgressTrafficSubMeterId[3] = ((tbl_prog_brdgeport_egress.val[8] & 0x7F00) >> 8);
+
+	if (gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiNonIpMeteringAssigned) {
+		if (gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiNonIpMeteringId ==
+		    temp.nEgressTrafficSubMeterId[3]) {
+			/*Release this meter id from this Bridge Port*/
+			gswdev->meter_idx[temp.nEgressTrafficSubMeterId[3]].IndexInUsageCnt--;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiNonIpMeteringAssigned = 0;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownMultiNonIpMeteringId = 0;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/*Egress Unknown UniCast Meter*/
+	temp.nEgressTrafficSubMeterId[4] = ((tbl_prog_brdgeport_egress.val[7] & 0x7F00) >> 8);
+
+	if (gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownUniCastMeteringAssigned) {
+		if (gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownUniCastMeteringId ==
+		    temp.nEgressTrafficSubMeterId[4]) {
+			/*Release this meter id from this Bridge Port*/
+			gswdev->meter_idx[temp.nEgressTrafficSubMeterId[4]].IndexInUsageCnt--;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownUniCastMeteringAssigned = 0;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].UnknownUniCastMeteringId = 0;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	temp.sPmapper.nPmapperId = (tbl_prog_brdgeport_egress.val[4] & 0xFF);
+
+	if (gswdev->brdgeportconfig_idx[param->nBridgePortId].PmapperAssigned) {
+		/*Release this p-mapper idx from this Bridge Port*/
+		gswdev->pmapper_idx[temp.sPmapper.nPmapperId].IndexInUse = 0;
+		gswdev->brdgeportconfig_idx[param->nBridgePortId].PmapperAssigned = 0;
+		gswdev->brdgeportconfig_idx[param->nBridgePortId].PmappperIdx = 0;
+	}
+
+	temp.nIngressVlanFilterBlockId = (tbl_prog_brdgeport_ingress.val[5] & 0x3FF);
+
+	if (gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressVlanFilterAssigned) {
+		if (gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressVlanFilterBlkId ==
+		    temp.nIngressVlanFilterBlockId) {
+			/*Release this vlan blk from this Bridge Port*/
+			FirstIdx = temp.nIngressVlanFilterBlockId;
+			gswdev->vlanfilter_idx.filter_idx[FirstIdx].IndexInUsageCnt--;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressVlanFilterAssigned = 0;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].IngressVlanFilterBlkId = VLANFILTER_ENTRY_INVALID;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	temp.nEgressVlanFilter1BlockId = (tbl_prog_brdgeport_egress.val[10] & 0x3FF);
+
+	if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter1Assigned) {
+		if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter1BlkId ==
+		    temp.nEgressVlanFilter1BlockId) {
+			/*Release this vlan blk from this Bridge Port*/
+			FirstIdx = temp.nEgressVlanFilter1BlockId;
+			gswdev->vlanfilter_idx.filter_idx[FirstIdx].IndexInUsageCnt--;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter1Assigned = 0;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter1BlkId = VLANFILTER_ENTRY_INVALID;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	temp.nEgressVlanFilter2BlockId = (tbl_prog_brdgeport_egress.val[12] & 0x3FF);
+
+	if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter2Assigned) {
+		if (gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter2BlkId ==
+		    temp.nEgressVlanFilter2BlockId) {
+			/*Release this vlan blk from this Bridge Port*/
+			FirstIdx = temp.nEgressVlanFilter2BlockId;
+			gswdev->vlanfilter_idx.filter_idx[FirstIdx].IndexInUsageCnt--;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter2Assigned = 0;
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].EgressVlanFilter2BlkId = VLANFILTER_ENTRY_INVALID;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/*Zero the ingress/egress bridge port table index*/
+	/*Same Bridge port idx for ingress and egress bridge port configuration*/
+	memset(&tbl_prog_brdgeport_ingress, 0, sizeof(pctbl_prog_t));
+	tbl_prog_brdgeport_ingress.table = PCE_IGBGP_INDEX;
+	CLEAR_U16(tbl_prog_brdgeport_ingress.pcindex);
+	/*Table Entry address (Bridge port ingress Table index) Bit 7:0 in PCE_TBL_ADDR*/
+	tbl_prog_brdgeport_ingress.pcindex |= (param->nBridgePortId & 0xFF);
+
+	memset(&tbl_prog_brdgeport_egress, 0, sizeof(pctbl_prog_t));
+	tbl_prog_brdgeport_egress.table = PCE_EGBGP_INDEX;
+	CLEAR_U16(tbl_prog_brdgeport_egress.pcindex);
+	/*Table Entry address (Bridge port egress Table index) Bit 7:0 in PCE_TBL_ADDR*/
+	tbl_prog_brdgeport_egress.pcindex |= (param->nBridgePortId & 0xFF);
+
+	/*Restore the Learing Limit 255*/
+	tbl_prog_brdgeport_ingress.val[4] |= 0xFF;
+	gswdev->brdgeportconfig_idx[param->nBridgePortId].LearningLimit = 0xFF;
+	/*Stp State disabled for all traffic*/
+	tbl_prog_brdgeport_ingress.val[0] |= 0x3;
+	tbl_prog_brdgeport_egress.val[0] |= 0x3;
+	gswdev->brdgeportconfig_idx[param->nBridgePortId].StpState =
+		GSW_STP_PORT_STATE_DISABLE;
+	gswdev->brdgeportconfig_idx[param->nBridgePortId].P8021xState =
+		GSW_8021X_PORT_STATE_UNAUTHORIZED;
+
+	/*Address-based write for ingress bridge port configuration*/
+	gsw_pce_table_write(cdev, &tbl_prog_brdgeport_ingress);
+	/*Address-based write for egress bridge port configuration*/
+	gsw_pce_table_write(cdev, &tbl_prog_brdgeport_egress);
+
+	/*Free this bridge port idx*/
+	gswdev->brdgeportconfig_idx[param->nBridgePortId].IndexInUse = 0;
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_BridgePortConfigGet(void *cdev, GSW_BRIDGE_portConfig_t *param)
+{
+	pctbl_prog_t tbl_prog_brdgeport_ingress;
+	pctbl_prog_t tbl_prog_brdgeport_egress;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value, FirstIdx, LastIdx, BlkSize;
+	u16 i, val_reg_idx, ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (param->nBridgePortId >= gswdev->num_of_bridge_port) {
+		pr_err("nBridgePortId %d is out of range [num_of_bridge_port supported =%d]\n", param->nBridgePortId, (gswdev->num_of_bridge_port - 1));
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*GSW_BRIDGE_PORT_CONFIG_MASK_FORCE is for debugging purpose only
+	 if this mask is enabled , there is no check on index in-use*/
+	if (!(param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_FORCE)) {
+		/*If Bridge Port ID is valid,Check whether it is InUSE
+		  if not InUse,return ERROR*/
+		if (!(gswdev->brdgeportconfig_idx[param->nBridgePortId].IndexInUse)) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/*Same bridge port idx for ingress and egress bridge port configuration*/
+	memset(&tbl_prog_brdgeport_ingress, 0, sizeof(pctbl_prog_t));
+	tbl_prog_brdgeport_ingress.table = PCE_IGBGP_INDEX;
+	CLEAR_U16(tbl_prog_brdgeport_ingress.pcindex);
+	/*Table Entry address (Bridge port ingress Table index) Bit 7:0 in PCE_TBL_ADDR*/
+	tbl_prog_brdgeport_ingress.pcindex |= (param->nBridgePortId & 0xFF);
+
+	memset(&tbl_prog_brdgeport_egress, 0, sizeof(pctbl_prog_t));
+	tbl_prog_brdgeport_egress.table = PCE_EGBGP_INDEX;
+	CLEAR_U16(tbl_prog_brdgeport_egress.pcindex);
+	/*Table Entry address (Bridge port egress Table index) Bit 7:0 in PCE_TBL_ADDR*/
+	tbl_prog_brdgeport_egress.pcindex |= (param->nBridgePortId & 0xFF);
+
+	/*Address-based read for ingress bridge port configuration*/
+	gsw_pce_table_read(cdev, &tbl_prog_brdgeport_ingress);
+
+	/*Address-based read for egress bridge port configuration*/
+	gsw_pce_table_read(cdev, &tbl_prog_brdgeport_egress);
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID)
+		param->nBridgeId = ((tbl_prog_brdgeport_ingress.val[4] & 0x3F00) >> 8);
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MAC_LEARNING_LIMIT)
+		param->nMacLearningLimit = (tbl_prog_brdgeport_ingress.val[4] & 0xFF);
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_VLAN) {
+		param->bIngressExtendedVlanEnable = ((tbl_prog_brdgeport_ingress.val[1] & 0x4000) >> 14);
+
+		if (param->bIngressExtendedVlanEnable) {
+			param->nIngressExtendedVlanBlockId = ((tbl_prog_brdgeport_ingress.val[1] & 0x3FF));
+			FirstIdx	= param->nIngressExtendedVlanBlockId;
+			LastIdx 	= (tbl_prog_brdgeport_ingress.val[2]  & 0x3FF);
+
+			if (FirstIdx == LastIdx)
+				BlkSize = 1;
+			else
+				BlkSize = ((LastIdx - FirstIdx) + 1);
+
+			param->nIngressExtendedVlanBlockSize = BlkSize;
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN) {
+		param->bEgressExtendedVlanEnable = ((tbl_prog_brdgeport_egress.val[1] & 0x4000) >> 14);
+
+		if (param->bEgressExtendedVlanEnable) {
+			param->nEgressExtendedVlanBlockId = (tbl_prog_brdgeport_egress.val[1] & 0x3FF);
+			FirstIdx	= param->nEgressExtendedVlanBlockId;
+			LastIdx 	= (tbl_prog_brdgeport_egress.val[2]  & 0x3FF);
+
+			if (FirstIdx == LastIdx)
+				BlkSize = 1;
+			else
+				BlkSize = ((LastIdx - FirstIdx) + 1);
+
+			param->nEgressExtendedVlanBlockSize = BlkSize;
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_MARKING) {
+		value = (tbl_prog_brdgeport_ingress.val[3] & 0x7);
+
+		switch (value) {
+		case 0:
+			param->eIngressMarkingMode = GSW_MARKING_ALL_GREEN;
+			break;
+
+		case 1:
+			param->eIngressMarkingMode = GSW_MARKING_INTERNAL_MARKING;
+			break;
+
+		case 2:
+			param->eIngressMarkingMode = GSW_MARKING_DEI;
+			break;
+
+		case 3:
+			param->eIngressMarkingMode = GSW_MARKING_PCP_8P0D;
+			break;
+
+		case 4:
+			param->eIngressMarkingMode = GSW_MARKING_PCP_7P1D;
+			break;
+
+		case 5:
+			param->eIngressMarkingMode = GSW_MARKING_PCP_6P2D;
+			break;
+
+		case 6:
+			param->eIngressMarkingMode = GSW_MARKING_PCP_5P3D;
+			break;
+
+		case 7:
+			param->eIngressMarkingMode = GSW_MARKING_DSCP_AF;
+			break;
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_REMARKING) {
+		value = (tbl_prog_brdgeport_egress.val[3] & 0x7);
+
+		switch (value) {
+		case 0:
+			param->eEgressRemarkingMode = GSW_REMARKING_NONE;
+			break;
+
+		case 1:
+			param->eEgressRemarkingMode = GSW_REMARKING_NONE;
+			break;
+
+		case 2:
+			param->eEgressRemarkingMode = GSW_REMARKING_DEI;
+			break;
+
+		case 3:
+			param->eEgressRemarkingMode = GSW_REMARKING_PCP_8P0D;
+			break;
+
+		case 4:
+			param->eEgressRemarkingMode = GSW_REMARKING_PCP_7P1D;
+			break;
+
+		case 5:
+			param->eEgressRemarkingMode = GSW_REMARKING_PCP_6P2D;
+			break;
+
+		case 6:
+			param->eEgressRemarkingMode = GSW_REMARKING_PCP_5P3D;
+			break;
+
+		case 7:
+			param->eEgressRemarkingMode = GSW_REMARKING_DSCP_AF;
+			break;
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_METER) {
+		param->bIngressMeteringEnable = ((tbl_prog_brdgeport_ingress.val[3] & 0x80) >> 7);
+
+		if (param->bIngressMeteringEnable)
+			param->nIngressTrafficMeterId = ((tbl_prog_brdgeport_ingress.val[3] & 0x7F00) >> 8);
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_SUB_METER) {
+		/*Broadcast meter*/
+		param->bEgressSubMeteringEnable[0] = ((tbl_prog_brdgeport_egress.val[5] & 0x80) >> 7);
+
+		if (param->bEgressSubMeteringEnable[0])
+			param->nEgressTrafficSubMeterId[0] = ((tbl_prog_brdgeport_egress.val[5] & 0x7F00) >> 8);
+
+		/*multicast meter*/
+		param->bEgressSubMeteringEnable[1] = ((tbl_prog_brdgeport_egress.val[6] & 0x80) >> 7);
+
+		if (param->bEgressSubMeteringEnable[1])
+			param->nEgressTrafficSubMeterId[1] = ((tbl_prog_brdgeport_egress.val[6] & 0x7F00) >> 8);
+
+		/*unknown multicast ip meter*/
+		param->bEgressSubMeteringEnable[2] = ((tbl_prog_brdgeport_egress.val[9] & 0x80) >> 7);
+
+		if (param->bEgressSubMeteringEnable[2])
+			param->nEgressTrafficSubMeterId[2] = ((tbl_prog_brdgeport_egress.val[9] & 0x7F00) >> 8);
+
+		/*unknown multicast Non ip meter*/
+		param->bEgressSubMeteringEnable[3] = ((tbl_prog_brdgeport_egress.val[8] & 0x80) >> 7);
+
+		if (param->bEgressSubMeteringEnable[3])
+			param->nEgressTrafficSubMeterId[3] = ((tbl_prog_brdgeport_egress.val[8] & 0x7F00) >> 8);
+
+
+		/*unknown unicast meter*/
+		param->bEgressSubMeteringEnable[4] = ((tbl_prog_brdgeport_egress.val[7] & 0x80) >> 7);
+
+		if (param->bEgressSubMeteringEnable[4])
+			param->nEgressTrafficSubMeterId[4] = ((tbl_prog_brdgeport_egress.val[7] & 0x7F00) >> 8);
+
+		/*other meter*/
+		param->bEgressSubMeteringEnable[5] = ((tbl_prog_brdgeport_egress.val[3] & 0x80) >> 7);
+
+		if (param->bEgressSubMeteringEnable[5])
+			param->nEgressTrafficSubMeterId[5] = ((tbl_prog_brdgeport_egress.val[3] & 0x7F00) >> 8);
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_CTP_MAPPING) {
+		param->nDestLogicalPortId = ((tbl_prog_brdgeport_egress.val[4] & 0xF00) >> 8);
+
+		param->bPmapperEnable = ((tbl_prog_brdgeport_egress.val[4] & 0x4000) >> 14);
+		param->ePmapperMappingMode = ((tbl_prog_brdgeport_egress.val[4] & 0x2000) >> 13);
+
+		if (param->bPmapperEnable) {
+			param->sPmapper.nPmapperId = (tbl_prog_brdgeport_egress.val[4] & 0xFF);
+			ret = GSW_QOS_PmapperTableGet(cdev, &param->sPmapper);
+
+			if (ret == GSW_statusErr) {
+				pr_err("ERROR :P-mapper Get return Error\n");
+				goto UNLOCK_AND_RETURN;
+			}
+		} else {
+			param->nDestSubIfIdGroup = (tbl_prog_brdgeport_egress.val[4] & 0xFF);
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP) {
+		val_reg_idx = 10;
+
+		for (i = 0; i < 8; i++) {
+			param->nBridgePortMap[i] = (tbl_prog_brdgeport_ingress.val[val_reg_idx] & 0xFFFF);
+			val_reg_idx++;
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_DEST_IP_LOOKUP)
+		param->bMcDestIpLookupDisable = ((tbl_prog_brdgeport_ingress.val[0] & 0x2000) >> 13);
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_SRC_IP_LOOKUP)
+		param->bMcSrcIpLookupEnable = ((tbl_prog_brdgeport_ingress.val[0] & 0x200) >> 9);
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_DEST_MAC_LOOKUP)
+		param->bDestMacLookupDisable = ((tbl_prog_brdgeport_ingress.val[0] & 0x4000) >> 14);
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MC_SRC_MAC_LEARNING)
+		param->bSrcMacLearningDisable = ((tbl_prog_brdgeport_ingress.val[0] & 0x8000) >> 15);
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MAC_SPOOFING)
+		param->bMacSpoofingDetectEnable = ((tbl_prog_brdgeport_ingress.val[0] & 0x800) >> 11);
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_PORT_LOCK)
+		param->bPortLockEnable = ((tbl_prog_brdgeport_ingress.val[0] & 0x1000) >> 12);
+
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_VLAN_FILTER) {
+		param->bIngressVlanFilterEnable = ((tbl_prog_brdgeport_ingress.val[5] & 0x4000) >> 14);
+
+		if (param->bIngressVlanFilterEnable) {
+			param->nIngressVlanFilterBlockId = (tbl_prog_brdgeport_ingress.val[5] & 0x3FF);
+			FirstIdx	= param->nIngressVlanFilterBlockId;
+			LastIdx 	= (tbl_prog_brdgeport_ingress.val[6]  & 0x3FF);
+
+			if (FirstIdx == LastIdx)
+				BlkSize = 1;
+			else
+				BlkSize = ((LastIdx - FirstIdx) + 1);
+
+			param->nIngressVlanFilterBlockSize = BlkSize;
+		}
+
+		param->bBypassEgressVlanFilter1 = ((tbl_prog_brdgeport_ingress.val[5] & 0x8000) >> 15);
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN_FILTER1) {
+		param->bEgressVlanFilter1Enable = ((tbl_prog_brdgeport_egress.val[10] & 0x4000) >> 14);
+
+		if (param->bEgressVlanFilter1Enable) {
+			param->nEgressVlanFilter1BlockId = (tbl_prog_brdgeport_egress.val[10] & 0x3FF);
+			FirstIdx	= param->nEgressVlanFilter1BlockId;
+			LastIdx 	= (tbl_prog_brdgeport_egress.val[11]  & 0x3FF);
+
+			if (FirstIdx == LastIdx)
+				BlkSize = 1;
+			else
+				BlkSize = ((LastIdx - FirstIdx) + 1);
+
+			param->nEgressVlanFilter1BlockSize = BlkSize;
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN_FILTER2) {
+		param->bEgressVlanFilter2Enable = ((tbl_prog_brdgeport_egress.val[12] & 0x4000) >> 14);
+
+		if (param->bEgressVlanFilter2Enable) {
+			param->nEgressVlanFilter2BlockId = (tbl_prog_brdgeport_egress.val[12] & 0x3FF);
+			FirstIdx	= param->nEgressVlanFilter2BlockId;
+			LastIdx 	= (tbl_prog_brdgeport_egress.val[13]  & 0x3FF);
+
+			if (FirstIdx == LastIdx)
+				BlkSize = 1;
+			else
+				BlkSize = ((LastIdx - FirstIdx) + 1);
+
+			param->nEgressVlanFilter2BlockSize = BlkSize;
+		}
+	}
+
+	if (param->eMask & GSW_BRIDGE_PORT_CONFIG_MASK_MAC_LEARNED_COUNT)
+		param->nMacLearningCount = (tbl_prog_brdgeport_ingress.val[9] & 0x1FFF);
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_CtpPortConfigSet(void *cdev, GSW_CTP_portConfig_t *param)
+{
+	pctbl_prog_t tbl_prog_ctpport_ingress;
+	pctbl_prog_t tbl_prog_ctpport_egress;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 idx = 0, FirstIdx, LastIdx, pmapper_idx, ctp_port;
+	u32 BlkSize = 0;
+	u32 ret;
+	GSW_CTP_portAssignment_t ctp_get;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	/*Checking based on number of logical port*/
+	if (param->nLogicalPortId >= gswdev->tpnum) {
+		pr_err("nLogicalPortId %d  >=  gswdev->pnum %d\n", param->nLogicalPortId, gswdev->pnum);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*CTP ports has to assigned/mapped to Logical port before calling
+	  CTP port configuration.
+	  GSW_CTP_PortAssignmentGet will get the info on the assignment
+	  Use this info to find whether this CTP port is with in the range
+	  this logical port
+	*/
+	ctp_get.nLogicalPortId = param->nLogicalPortId;
+	ret = GSW_CTP_PortAssignmentGet(cdev, &ctp_get);
+
+	if (ret == GSW_statusErr) {
+		pr_err("GSW_CTP_PortAssignmentGet returns ERROR\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*IMPORTANT NOTE : :As per the CTP concept  nFirstCtpPortId + nSubIfIdGroup is the expected CTP port*/
+	ctp_port = ctp_get.nFirstCtpPortId  + param->nSubIfIdGroup;
+
+	if (ctp_port >= gswdev->num_of_ctp) {
+		pr_err("ctp_port %d  >=  gswdev->num_of_ctp %d\n", ctp_port, gswdev->num_of_ctp);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*If not with in the Assigned range Return Error -This check is just extra*/
+	if (ctp_port < ctp_get.nFirstCtpPortId ||
+	    ctp_port >= (ctp_get.nFirstCtpPortId + ctp_get.nNumberOfCtpPort)) {
+		pr_err("ERROR:ctp_port %d  Assigned range not correct\n", ctp_port);
+		pr_err("ERROR:Check using CTP assignment get\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*NOTE : This Mask is for debugging purpose only
+	  If GSW_CTP_PORT_CONFIG_MASK_FORCE mask is set
+	  It will not check index in-use */
+	if (!(param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE)) {
+		/*Check whether CTP is allocated by GSW_CTP_PortAssignmentAlloc*/
+		if (!gswdev->ctpportconfig_idx[ctp_port].IndexInUse) {
+			pr_err("ERROR :ctp_port %d Index not in use,CTP not allocated\n", ctp_port);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/*Same ctp port idx for ingress and egress ctp port configuration*/
+	memset(&tbl_prog_ctpport_ingress, 0, sizeof(pctbl_prog_t));
+	tbl_prog_ctpport_ingress.table = PCE_IGCTP_INDEX;
+	CLEAR_U16(tbl_prog_ctpport_ingress.pcindex);
+	/*Table Entry address (ctp port ingress Table index) Bit 8:0 in PCE_TBL_ADDR*/
+	tbl_prog_ctpport_ingress.pcindex |= (ctp_port & 0x1FF);
+
+	memset(&tbl_prog_ctpport_egress, 0, sizeof(pctbl_prog_t));
+	tbl_prog_ctpport_egress.table = PCE_EGCTP_INDEX;
+	CLEAR_U16(tbl_prog_ctpport_egress.pcindex);
+	/*Table Entry address (ctp port egress Table index) Bit 8:0 in PCE_TBL_ADDR*/
+	tbl_prog_ctpport_egress.pcindex |= (ctp_port & 0x1FF);
+
+	/*Address-based read for ingress ctp port configuration
+	  read before set, so that previous value of this table index
+	  is not disturbed in the case of update specific fields.
+	*/
+	gsw_pce_table_read(cdev, &tbl_prog_ctpport_ingress);
+
+	/*Address-based read for egress ctp port configuration
+	  read before set, so that previous value of this table index
+	  is not disturbed in the case of update specific fields.
+	*/
+	gsw_pce_table_read(cdev, &tbl_prog_ctpport_egress);
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_BRIDGE_PORT_ID) {
+		if (param->nBridgePortId >= gswdev->num_of_bridge_port) {
+			pr_err("nBridgePortId (%i) >= num_of_bridge_port (%i)\n",
+			       param->nBridgePortId,
+			       gswdev->num_of_bridge_port);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		if (!(param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE)) {
+
+			/*This below field enable indicates that this bridge port id is
+			 already assigned and it's idx recorded for this CTP Port id.
+			 If next time the user update this field with different
+			 bridge port idx !!or wanted to allocate a new bridge port idx ??!!
+			 may happen by mistake ??!!
+			 the previous bridge port idx must be released from this CTP Port*/
+
+			if (gswdev->ctpportconfig_idx[ctp_port].BrdgIdPortAssigned) {
+				if (gswdev->ctpportconfig_idx[ctp_port].BrdgPortId !=
+				    param->nBridgePortId) {
+					idx = gswdev->ctpportconfig_idx[ctp_port].BrdgPortId;
+					/*release the usage of previous bridge port idx*/
+					gswdev->brdgeportconfig_idx[idx].IndexInUsageCnt--;
+					gswdev->ctpportconfig_idx[ctp_port].BrdgIdPortAssigned = 0;
+					gswdev->ctpportconfig_idx[ctp_port].BrdgPortId = 0;
+				}
+			}
+
+			/*This Bridge Port ID should be in use (i.e) that is this Bridge Port ID
+			  should be allocated
+			  before calling CTP port configuration
+			  If not in use return ERROR
+			  */
+			if (gswdev->brdgeportconfig_idx[param->nBridgePortId].IndexInUse) {
+				/*Usage count will be incremented only once during bridge port idx assignment
+				for this CTP port id*/
+				if (!gswdev->ctpportconfig_idx[ctp_port].BrdgIdPortAssigned) {
+					gswdev->ctpportconfig_idx[ctp_port].BrdgIdPortAssigned = 1;
+					gswdev->ctpportconfig_idx[ctp_port].BrdgPortId
+						= param->nBridgePortId;
+					/*Since this bridge port id can be shared,Increment it's usage count*/
+					gswdev->brdgeportconfig_idx[param->nBridgePortId].IndexInUsageCnt++;
+				}
+			} else {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+		}
+
+		tbl_prog_ctpport_ingress.val[0] &= ~(0xFF);
+		tbl_prog_ctpport_ingress.val[0] |= (param->nBridgePortId & 0xFF);
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE_TRAFFIC_CLASS) {
+		/** Default traffic class associated with all traffic from this CTP Port. */
+		tbl_prog_ctpport_ingress.val[0] &= ~(0xF << 8);
+		tbl_prog_ctpport_ingress.val[0] |= ((param->nDefaultTrafficClass & 0xF) << 8);
+
+		/** Default traffic class can not be overridden by other rules (except
+			traffic flow table and special tag) in following stages. */
+		/* 0 -Traffic class can be over written by the following processing stage
+		   1 -Traffic class can not be over written by the following processing stage
+		*/
+		if (param->bForcedTrafficClass)
+			tbl_prog_ctpport_ingress.val[0] |= (1 << 12);
+		else
+			tbl_prog_ctpport_ingress.val[0] &= ~(1 << 12);
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN) {
+		if (param->bIngressExtendedVlanEnable) {
+			/*This below field enable indicates that this vlan block is
+			 already assigned and it's Blk id recorded for this CTP Port id.
+			 If next time the user update this Vlan blk field with different blk id !!
+			 or wanted to allocate a new vlan blk ??!! may happen by mistake ??!!
+			 the previous blk id must be released from this CTP Port*/
+
+			if (!(param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE)) {
+				if (gswdev->ctpportconfig_idx[ctp_port].IngressExVlanNonIgmpBlkAssigned) {
+					if (gswdev->ctpportconfig_idx[ctp_port].IngressExVlanNonIgmpBlkId !=
+					    param->nIngressExtendedVlanBlockId) {
+						idx = gswdev->ctpportconfig_idx[ctp_port].IngressExVlanNonIgmpBlkId;
+						/*release the usage of previous vlan block id*/
+						gswdev->extendvlan_idx.vlan_idx[idx].IndexInUsageCnt--;
+						gswdev->ctpportconfig_idx[ctp_port].IngressExVlanNonIgmpBlkAssigned = 0;
+						gswdev->ctpportconfig_idx[ctp_port].IngressExVlanNonIgmpBlkId = EXVLAN_ENTRY_INVALID;
+					}
+				}
+			}
+
+			/*Note: First Index of the Block is the BlockID*/
+			FirstIdx = param->nIngressExtendedVlanBlockId;
+
+			if (FirstIdx > gswdev->num_of_extendvlan) {
+				pr_err("FirstIdx %d > gswdev->num_of_extendvlan %d\n", FirstIdx, gswdev->num_of_egvlan);
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index is InUse
+			  Since it will be marked as InUse during allocation.
+			*/
+			if (!gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUse) {
+				pr_err("Not in use gswdev->extendvlan_idx.vlan_idx[%d].IndexInUse\n", FirstIdx);
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index belongs to this  BlockID
+			  Since it will be marked during allocation.
+			*/
+			if (gswdev->extendvlan_idx.vlan_idx[FirstIdx].VlanBlockId
+			    != param->nIngressExtendedVlanBlockId) {
+				pr_err("gswdev->extendvlan_idx.vlan_idx[FirstIdx].VlanBlockId != param->nIngressExtendedVlanBlockId\n");
+				pr_err("param->nIngressExtendedVlanBlockId = %d\n", param->nIngressExtendedVlanBlockId);
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Search for the Last Index of this block.
+			  Note: The Blocks are always allocated contiguously.
+			*/
+
+			LastIdx = FirstIdx;
+
+			while (gswdev->extendvlan_idx.vlan_idx[LastIdx].VlanBlockId == FirstIdx
+			       && gswdev->extendvlan_idx.vlan_idx[LastIdx].IndexInUse) {
+				LastIdx++;
+			}
+
+			BlkSize = param->nIngressExtendedVlanBlockSize;
+
+			if (BlkSize && ((FirstIdx + BlkSize) <= LastIdx))
+				LastIdx = (FirstIdx + BlkSize);
+
+			/*Enable Extended VLAN operation*/
+			tbl_prog_ctpport_ingress.val[1] |= (1 << 14);
+			/*Set First Index of the Block*/
+			tbl_prog_ctpport_ingress.val[1] &= ~(0x3FF);
+			tbl_prog_ctpport_ingress.val[1] |= (FirstIdx & 0x3FF);
+			/*Set Last Index of the Block*/
+			tbl_prog_ctpport_ingress.val[2] &= ~(0x3FF);
+			tbl_prog_ctpport_ingress.val[2] |= ((LastIdx - 1) & 0x3FF);
+
+			if (!(param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE)) {
+				/*Usage count will be incremented only once during vlan blk assignment
+				for this CTP port id*/
+				if (!gswdev->ctpportconfig_idx[ctp_port].IngressExVlanNonIgmpBlkAssigned) {
+					gswdev->ctpportconfig_idx[ctp_port].IngressExVlanNonIgmpBlkAssigned = 1;
+					gswdev->ctpportconfig_idx[ctp_port].IngressExVlanNonIgmpBlkId
+						= param->nIngressExtendedVlanBlockId;
+					/*Since this vlan blk can be shared,Increment it's usage count*/
+					gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUsageCnt++;
+				}
+			}
+		} else {
+			/*Disable ingress Extended VLAN non igmp*/
+			tbl_prog_ctpport_ingress.val[1] &= ~(1 << 14);
+
+			if (gswdev->ctpportconfig_idx[ctp_port].IngressExVlanNonIgmpBlkAssigned) {
+				idx = gswdev->ctpportconfig_idx[ctp_port].IngressExVlanNonIgmpBlkId;
+				/*release the usage of vlan block id, if it is assigned previously
+				 when Extended vlan operation is disabled,it is must to release
+				 the mapped exvlan resource*/
+				gswdev->extendvlan_idx.vlan_idx[idx].IndexInUsageCnt--;
+				gswdev->ctpportconfig_idx[ctp_port].IngressExVlanNonIgmpBlkAssigned = 0;
+				gswdev->ctpportconfig_idx[ctp_port].IngressExVlanNonIgmpBlkId = EXVLAN_ENTRY_INVALID;
+			}
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN_IGMP) {
+		if (param->bIngressExtendedVlanIgmpEnable) {
+			/*This below field enable indicates that this vlan block is
+			 already assigned and it's Blk id recorded for this CTP Port id.
+			 If next time the user update this Vlan blk field with different blk id !!
+			 or wanted to allocate a new vlan blk ??!! may happen by mistake ??!!
+			 the previous blk id must be released from this CTP Port*/
+
+			if (!(param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE)) {
+				if (gswdev->ctpportconfig_idx[ctp_port].IngressExVlanIgmpBlkAssigned) {
+					if (gswdev->ctpportconfig_idx[ctp_port].IngressExVlanIgmpBlkId !=
+					    param->nIngressExtendedVlanBlockIdIgmp) {
+						idx = gswdev->ctpportconfig_idx[ctp_port].IngressExVlanIgmpBlkId;
+						/*release the usage of previous vlan block id*/
+						gswdev->extendvlan_idx.vlan_idx[idx].IndexInUsageCnt--;
+						gswdev->ctpportconfig_idx[ctp_port].IngressExVlanIgmpBlkAssigned = 0;
+						gswdev->ctpportconfig_idx[ctp_port].IngressExVlanIgmpBlkId = EXVLAN_ENTRY_INVALID;
+					}
+				}
+			}
+
+			/*Note: First Index of the Block is the BlockID*/
+			FirstIdx = param->nIngressExtendedVlanBlockIdIgmp;
+
+			if (FirstIdx > gswdev->num_of_extendvlan) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index is InUse
+			  Since it will be marked as InUse during allocation.
+			*/
+			if (!gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUse) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index belongs to this  BlockID
+			  Since it will be marked during allocation.
+			*/
+			if (gswdev->extendvlan_idx.vlan_idx[FirstIdx].VlanBlockId
+			    != param->nIngressExtendedVlanBlockIdIgmp) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Search for the Last Index of this block.
+			  Note: The Blocks are always allocated contiguously.
+			*/
+
+			LastIdx = FirstIdx;
+
+			while (gswdev->extendvlan_idx.vlan_idx[LastIdx].VlanBlockId == FirstIdx
+			       && gswdev->extendvlan_idx.vlan_idx[LastIdx].IndexInUse) {
+				LastIdx++;
+			}
+
+			BlkSize = param->nIngressExtendedVlanBlockSizeIgmp;
+
+			if (BlkSize && ((FirstIdx + BlkSize) <= LastIdx))
+				LastIdx = (FirstIdx + BlkSize);
+
+			/*Enable Extended VLAN operation*/
+			tbl_prog_ctpport_ingress.val[5] |= (1 << 14);
+			/*Set First Index of the Block*/
+			tbl_prog_ctpport_ingress.val[5] &= ~(0x3FF);
+			tbl_prog_ctpport_ingress.val[5] |= (FirstIdx & 0x3FF);
+			/*Set Last Index of the Block*/
+			tbl_prog_ctpport_ingress.val[6] &= ~(0x3FF);
+			tbl_prog_ctpport_ingress.val[6] |= ((LastIdx - 1) & 0x3FF);
+
+			if (!(param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE)) {
+				/*Usage count will be incremented only once during vlan blk assignment
+				for this CTP port id*/
+				if (!gswdev->ctpportconfig_idx[ctp_port].IngressExVlanIgmpBlkAssigned) {
+					gswdev->ctpportconfig_idx[ctp_port].IngressExVlanIgmpBlkAssigned = 1;
+					gswdev->ctpportconfig_idx[ctp_port].IngressExVlanIgmpBlkId
+						= param->nIngressExtendedVlanBlockIdIgmp;
+					/*Since this vlan blk can be shared,Increment it's usage count*/
+					gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUsageCnt++;
+				}
+			}
+		} else {
+			/*Disable ingress Extended VLAN igmp*/
+			tbl_prog_ctpport_ingress.val[5] &= ~(1 << 14);
+
+			if (gswdev->ctpportconfig_idx[ctp_port].IngressExVlanIgmpBlkAssigned) {
+				idx = gswdev->ctpportconfig_idx[ctp_port].IngressExVlanIgmpBlkId;
+				/*release the usage of vlan block id, if it is assigned previously
+				 when Extended vlan operation is disabled,it is must to release
+				 the mapped exvlan resource*/
+				gswdev->extendvlan_idx.vlan_idx[idx].IndexInUsageCnt--;
+				gswdev->ctpportconfig_idx[ctp_port].IngressExVlanIgmpBlkAssigned = 0;
+				gswdev->ctpportconfig_idx[ctp_port].IngressExVlanIgmpBlkId = EXVLAN_ENTRY_INVALID;
+			}
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN) {
+		if (param->bEgressExtendedVlanEnable) {
+			if (!(param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE)) {
+				/*This below field enable indicates that this vlan block is
+				 already assigned and it's Blk id recorded for this CTP Port id.
+				 If next time the user update this Vlan blk field with different blk id !!
+				 or wanted to allocate a new vlan blk ??!! may happen by mistake ??!!
+				 the previous blk id must be released from this CTP Port*/
+
+				if (gswdev->ctpportconfig_idx[ctp_port].EgressExVlanNonIgmpBlkAssigned) {
+					if (gswdev->ctpportconfig_idx[ctp_port].EgressExVlanNonIgmpBlkId !=
+					    param->nEgressExtendedVlanBlockId) {
+						idx = gswdev->ctpportconfig_idx[ctp_port].EgressExVlanNonIgmpBlkId;
+						/*release the usage of previous vlan block id*/
+						gswdev->extendvlan_idx.vlan_idx[idx].IndexInUsageCnt--;
+						gswdev->ctpportconfig_idx[ctp_port].EgressExVlanNonIgmpBlkAssigned = 0;
+						gswdev->ctpportconfig_idx[ctp_port].EgressExVlanNonIgmpBlkId = EXVLAN_ENTRY_INVALID;
+					}
+				}
+
+			}
+
+			/*Note: First Index of the Block is the BlockID*/
+			FirstIdx = param->nEgressExtendedVlanBlockId;
+
+			if (FirstIdx > gswdev->num_of_extendvlan) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index is InUse
+			  Since it will be marked as InUse during allocation.
+			*/
+			if (!gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUse) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index belongs to this  BlockID
+			  Since it will be marked during allocation.
+			*/
+			if (gswdev->extendvlan_idx.vlan_idx[FirstIdx].VlanBlockId
+			    != param->nEgressExtendedVlanBlockId) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Search for the Last Index of this block.
+			  Note: The Blocks are always allocated contiguously.
+			*/
+
+			LastIdx = FirstIdx;
+
+			while (gswdev->extendvlan_idx.vlan_idx[LastIdx].VlanBlockId == FirstIdx
+			       && gswdev->extendvlan_idx.vlan_idx[LastIdx].IndexInUse) {
+				LastIdx++;
+			}
+
+			BlkSize = param->nEgressExtendedVlanBlockSize;
+
+			if (BlkSize && ((FirstIdx + BlkSize) <= LastIdx))
+				LastIdx = (FirstIdx + BlkSize);
+
+			/*Enable Extended VLAN operation*/
+			tbl_prog_ctpport_egress.val[1] |= (1 << 14);
+			/*Set First Index of the Block*/
+			tbl_prog_ctpport_egress.val[1] &= ~(0x3FF);
+			tbl_prog_ctpport_egress.val[1] |= (FirstIdx & 0x3FF);
+			/*Set Last Index of the Block*/
+			tbl_prog_ctpport_egress.val[2] &= ~(0x3FF);
+			tbl_prog_ctpport_egress.val[2] |= ((LastIdx - 1) & 0x3FF);
+
+			if (!(param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE)) {
+				/*Usage count will be incremented only once during vlan blk assignment
+				for this CTP port id*/
+				if (!gswdev->ctpportconfig_idx[ctp_port].EgressExVlanNonIgmpBlkAssigned) {
+					gswdev->ctpportconfig_idx[ctp_port].EgressExVlanNonIgmpBlkAssigned = 1;
+					gswdev->ctpportconfig_idx[ctp_port].EgressExVlanNonIgmpBlkId
+						= param->nEgressExtendedVlanBlockId;
+					/*Since this vlan blk can be shared,Increment it's usage count*/
+					gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUsageCnt++;
+				}
+			}
+		} else {
+			/*Disable egress Extended VLAN non igmp*/
+			tbl_prog_ctpport_egress.val[1] &= ~(1 << 14);
+
+			if (gswdev->ctpportconfig_idx[ctp_port].EgressExVlanNonIgmpBlkAssigned) {
+				idx = gswdev->ctpportconfig_idx[ctp_port].EgressExVlanNonIgmpBlkId;
+				/*release the usage of vlan block id, if it is assigned previously
+				 when Extended vlan operation is disabled,it is must to release
+				 the mapped exvlan resource*/
+				gswdev->extendvlan_idx.vlan_idx[idx].IndexInUsageCnt--;
+				gswdev->ctpportconfig_idx[ctp_port].EgressExVlanNonIgmpBlkAssigned = 0;
+				gswdev->ctpportconfig_idx[ctp_port].EgressExVlanNonIgmpBlkId = EXVLAN_ENTRY_INVALID;
+			}
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN_IGMP) {
+		if (param->bEgressExtendedVlanIgmpEnable) {
+			if (!(param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE)) {
+				/*This below field enable indicates that this vlan block is
+				 already assigned and it's Blk id recorded for this CTP Port id.
+				 If next time the user update this Vlan blk field with different blk id !!
+				 or wanted to allocate a new vlan blk ??!! may happen by mistake ??!!
+				 the previous blk id must be released from this CTP Port*/
+
+				if (gswdev->ctpportconfig_idx[ctp_port].EgressExVlanIgmpBlkAssigned) {
+					if (gswdev->ctpportconfig_idx[ctp_port].EgressExVlanIgmpBlkId !=
+					    param->nEgressExtendedVlanBlockIdIgmp) {
+						idx = gswdev->ctpportconfig_idx[ctp_port].EgressExVlanIgmpBlkId;
+						/*release the usage of previous vlan block id*/
+						gswdev->extendvlan_idx.vlan_idx[idx].IndexInUsageCnt--;
+						gswdev->ctpportconfig_idx[ctp_port].EgressExVlanIgmpBlkAssigned = 0;
+						gswdev->ctpportconfig_idx[ctp_port].EgressExVlanIgmpBlkId = EXVLAN_ENTRY_INVALID;
+					}
+				}
+			}
+
+			/*Note: First Index of the Block is the BlockID*/
+			FirstIdx = param->nEgressExtendedVlanBlockIdIgmp;
+
+			if (FirstIdx > gswdev->num_of_extendvlan) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index is InUse
+			  Since it will be marked as InUse during allocation.
+			*/
+			if (!gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUse) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Check whether this index belongs to this  BlockID
+			  Since it will be marked during allocation.
+			*/
+			if (gswdev->extendvlan_idx.vlan_idx[FirstIdx].VlanBlockId
+			    != param->nEgressExtendedVlanBlockIdIgmp) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			/*Search for the Last Index of this block.
+			  Note: The Blocks are always allocated contiguously.
+			*/
+
+			LastIdx = FirstIdx;
+
+			while (gswdev->extendvlan_idx.vlan_idx[LastIdx].VlanBlockId == FirstIdx
+			       && gswdev->extendvlan_idx.vlan_idx[LastIdx].IndexInUse) {
+				LastIdx++;
+			}
+
+			BlkSize = param->nEgressExtendedVlanBlockSizeIgmp;
+
+			if (BlkSize && ((FirstIdx + BlkSize) <= LastIdx))
+				LastIdx = (FirstIdx + BlkSize);
+
+			/*Enable Extended VLAN operation*/
+			tbl_prog_ctpport_egress.val[5] |= (1 << 14);
+			/*Set First Index of the Block*/
+			tbl_prog_ctpport_egress.val[5] &= ~(0x3FF);
+			tbl_prog_ctpport_egress.val[5] |= (FirstIdx & 0x3FF);
+			/*Set Last Index of the Block*/
+			tbl_prog_ctpport_egress.val[6] &= ~(0x3FF);
+			tbl_prog_ctpport_egress.val[6] |= ((LastIdx - 1) & 0x3FF);
+
+			if (!(param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE)) {
+				/*Usage count will be incremented only once during vlan blk assignment
+				for this CTP port id*/
+				if (!gswdev->ctpportconfig_idx[ctp_port].EgressExVlanIgmpBlkAssigned) {
+					gswdev->ctpportconfig_idx[ctp_port].EgressExVlanIgmpBlkAssigned = 1;
+					gswdev->ctpportconfig_idx[ctp_port].EgressExVlanIgmpBlkId
+						= param->nEgressExtendedVlanBlockIdIgmp;
+					/*Since this vlan blk can be shared,Increment it's usage count*/
+					gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUsageCnt++;
+				}
+			}
+		} else {
+			/*Disable ingress Extended VLAN igmp*/
+			tbl_prog_ctpport_egress.val[5] &= ~(1 << 14);
+
+			if (gswdev->ctpportconfig_idx[ctp_port].EgressExVlanIgmpBlkAssigned) {
+				idx = gswdev->ctpportconfig_idx[ctp_port].EgressExVlanIgmpBlkId;
+				/*release the usage of vlan block id, if it is assigned previously
+				 when Extended vlan operation is disabled,it is must to release
+				 the mapped exvlan resource*/
+				gswdev->extendvlan_idx.vlan_idx[idx].IndexInUsageCnt--;
+				gswdev->ctpportconfig_idx[ctp_port].EgressExVlanIgmpBlkAssigned = 0;
+				gswdev->ctpportconfig_idx[ctp_port].EgressExVlanIgmpBlkId = EXVLAN_ENTRY_INVALID;
+			}
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INRESS_NTO1_VLAN) {
+		if (param->bIngressNto1VlanEnable)
+			tbl_prog_ctpport_ingress.val[1] |= (1 << 15);
+		else
+			tbl_prog_ctpport_ingress.val[1] &= ~(1 << 15);
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_NTO1_VLAN) {
+		if (param->bEgressNto1VlanEnable)
+			tbl_prog_ctpport_egress.val[1] |= (1 << 15);
+		else
+			tbl_prog_ctpport_egress.val[1] &= ~(1 << 15);
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_INGRESS_METER) {
+		if (param->bIngressMeteringEnable) {
+			if (param->nIngressTrafficMeterId > gswdev->num_of_meters) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			if (!(param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE)) {
+				/*This below field enable indicates that this meter id is
+				 already assigned and it's idx recorded for this CTP port id.
+				 If next time the user update this meter field with different meter idx !!
+				 or wanted to allocate a new meter idx ??!! may happen by mistake ??!!
+				 the previous meter idx  must be released from this CTP Port*/
+
+				if (gswdev->ctpportconfig_idx[ctp_port].IngressMeteringAssigned) {
+					if (gswdev->ctpportconfig_idx[ctp_port].IngressTrafficMeterId !=
+					    param->nIngressTrafficMeterId) {
+						idx = gswdev->ctpportconfig_idx[ctp_port].IngressTrafficMeterId;
+						/*release the usage of previous meter idx*/
+						gswdev->meter_idx[idx].IndexInUsageCnt--;
+						gswdev->ctpportconfig_idx[ctp_port].IngressMeteringAssigned = 0;
+						gswdev->ctpportconfig_idx[ctp_port].IngressTrafficMeterId = 0;
+					}
+				}
+
+				/*This Meter ID should be in use (i.e) that is this Meter ID should be allocated
+				before calling bridge port configuration
+				If not in use return ERROR
+				*/
+				if (gswdev->meter_idx[param->nIngressTrafficMeterId].IndexInUse) {
+					/*Usage count will be incremented only once during meter idx assignment
+					for this ctp port id*/
+					if (!gswdev->ctpportconfig_idx[ctp_port].IngressMeteringAssigned) {
+						gswdev->ctpportconfig_idx[ctp_port].IngressMeteringAssigned = 1;
+						gswdev->ctpportconfig_idx[ctp_port].IngressTrafficMeterId
+							= param->nIngressTrafficMeterId;
+						/*Since this meter id can be shared,Increment the it's usage count*/
+						gswdev->meter_idx[param->nIngressTrafficMeterId].IndexInUsageCnt++;
+					}
+				} else {
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+			}
+
+			/*Enable Meter Id*/
+			tbl_prog_ctpport_ingress.val[3] |= (1 << 7);
+			tbl_prog_ctpport_ingress.val[3] &= ~(0x7F << 8);
+			tbl_prog_ctpport_ingress.val[3] |= ((param->nIngressTrafficMeterId & 0x7F) << 8);
+		} else {
+			/*Disable Ingress Meter*/
+			tbl_prog_ctpport_ingress.val[3] &= ~(1 << 7);
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_METER) {
+		if (param->bEgressMeteringEnable) {
+			if (param->nEgressTrafficMeterId > gswdev->num_of_meters) {
+				ret = GSW_statusErr;
+				goto UNLOCK_AND_RETURN;
+			}
+
+			if (!(param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE)) {
+				/*This below field enable indicates that this meter id is
+				 already assigned and it's idx recorded for this CTP Port id.
+				 If next time the user update this meter field with different meter idx !!
+				 or wanted to allocate a new meter idx ??!! may happen by mistake ??!!
+				 the previous meter idx must be released from this CTP Port*/
+
+				if (gswdev->ctpportconfig_idx[ctp_port].EgressMeteringAssigned) {
+					if (gswdev->ctpportconfig_idx[ctp_port].EgressTrafficMeterId !=
+					    param->nIngressTrafficMeterId) {
+						idx = gswdev->ctpportconfig_idx[ctp_port].EgressTrafficMeterId;
+						/*release the usage of previous meter idx*/
+						gswdev->meter_idx[idx].IndexInUsageCnt--;
+						gswdev->ctpportconfig_idx[ctp_port].EgressMeteringAssigned = 0;
+						gswdev->ctpportconfig_idx[ctp_port].EgressTrafficMeterId = 0;
+					}
+				}
+
+				/*This Meter ID should be in use (i.e) that is this Meter ID should be allocated
+				 before calling ctp port configuration
+				 If not in use return ERROR
+				*/
+				if (gswdev->meter_idx[param->nEgressTrafficMeterId].IndexInUse) {
+					/*Usage count will be incremented only once during meter idx assignment
+					for this bridge port id*/
+					if (!gswdev->ctpportconfig_idx[ctp_port].EgressMeteringAssigned) {
+						gswdev->ctpportconfig_idx[ctp_port].EgressMeteringAssigned = 1;
+						gswdev->ctpportconfig_idx[ctp_port].EgressTrafficMeterId
+							= param->nEgressTrafficMeterId;
+						/*Since this meter id can be shared,Increment the it's usage count*/
+						gswdev->meter_idx[param->nEgressTrafficMeterId].IndexInUsageCnt++;
+					}
+				} else {
+					ret = GSW_statusErr;
+					goto UNLOCK_AND_RETURN;
+				}
+			}
+
+			/*Enable Meter Id*/
+			tbl_prog_ctpport_egress.val[3] |= (1 << 7);
+			tbl_prog_ctpport_egress.val[3] &= ~(0x7F << 8);
+			tbl_prog_ctpport_egress.val[3] |= ((param->nEgressTrafficMeterId & 0x7F) << 8);
+		} else {
+			/*Disable Egress Meter*/
+			tbl_prog_ctpport_egress.val[3] &= ~(1 << 7);
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_BRIDGING_BYPASS) {
+		if (param->bBridgingBypass) {
+			/** By pass bridging/multicast processing. Following parameters are used
+			  to determine destination. Traffic flow table is not bypassed. */
+			/*Enable Bridge Bypass*/
+			tbl_prog_ctpport_ingress.val[4] |= (1 << 15);
+
+			/** This field defines destination logical port. */
+			tbl_prog_ctpport_ingress.val[4] &= ~(0xF << 8);
+			tbl_prog_ctpport_ingress.val[4] |= ((param->nDestLogicalPortId & 0xF) << 8);
+
+			if (param->bPmapperEnable) {
+				/*TODO : as per code review - user is not responsible to allocate p-mapper*/
+				if (gswdev->ctpportconfig_idx[ctp_port].IngressBridgeBypassPmapperAssigned)
+					param->sPmapper.nPmapperId = gswdev->ctpportconfig_idx[ctp_port].IngressBridgeBypassPmappperIdx;
+				else
+					param->sPmapper.nPmapperId = PMAPPER_ENTRY_INVALID;
+
+
+				/** When bPmapperEnable is TRUE, this field selects either DSCP or PCP to
+				 derive sub interface ID. */
+				/*PCP-P-mapper table entry 1-8*/
+				/*DSCP-P-mapper table entry 9-72. */
+				switch (param->ePmapperMappingMode) {
+				case GSW_PMAPPER_MAPPING_PCP:
+					tbl_prog_ctpport_ingress.val[4] &= ~(1 << 13);
+					break;
+
+				case GSW_PMAPPER_MAPPING_DSCP:
+					tbl_prog_ctpport_ingress.val[4] |= (1 << 13);
+					break;
+				}
+
+				/* If the p-mapper id is invalid then the GSW_QOS_PmapperTableSet will
+				   Allocate/program P-mapper index.
+				   If p-mapper index is valid the GSW_QOS_PmapperTableSet will just program
+				   the table
+				 */
+				ret = GSW_QOS_PmapperTableSet(cdev, &param->sPmapper);
+
+				if (ret == GSW_statusErr) {
+					pr_err("ERROR : GSW_QOS_PmapperTableSet return erro\n");
+					goto UNLOCK_AND_RETURN;
+				}
+
+				pmapper_idx = param->sPmapper.nPmapperId;
+
+				/*Usage count will be incremented only once during p-mapper idx allocation
+				 or assignment for this ctp port id*/
+				if (!gswdev->ctpportconfig_idx[ctp_port].IngressBridgeBypassPmapperAssigned) {
+					gswdev->ctpportconfig_idx[ctp_port].IngressBridgeBypassPmapperAssigned = 1;
+					gswdev->ctpportconfig_idx[ctp_port].IngressBridgeBypassPmappperIdx = pmapper_idx;
+				}
+
+				tbl_prog_ctpport_ingress.val[4] |= (1 << 14);
+				tbl_prog_ctpport_ingress.val[4] &= ~(0xFF);
+				tbl_prog_ctpport_ingress.val[4] |= (pmapper_idx & 0xFF);
+			} else {
+				/** When bPmapperEnable is FALSE, this field defines destination sub
+					interface ID group. */
+				/*Disable p-mapper*/
+				tbl_prog_ctpport_ingress.val[4] &= ~(1 << 14);
+				tbl_prog_ctpport_ingress.val[4] &= ~(0xFF);
+				tbl_prog_ctpport_ingress.val[4] |= (param->nDestSubIfIdGroup & 0xFF);
+			}
+		} else {
+			/*Disable Bridge Bypass*/
+			tbl_prog_ctpport_ingress.val[4] &= ~(1 << 15);
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_INGRESS_MARKING) {
+		tbl_prog_ctpport_ingress.val[3] &= ~(7);
+
+		switch (param->eIngressMarkingMode) {
+		case GSW_MARKING_ALL_GREEN:
+			break;
+
+		case GSW_MARKING_INTERNAL_MARKING:
+			tbl_prog_ctpport_ingress.val[3] |= 0x1;
+			break;
+
+		case GSW_MARKING_DEI:
+			tbl_prog_ctpport_ingress.val[3] |= 0x2;
+			break;
+
+		case GSW_MARKING_PCP_8P0D:
+			tbl_prog_ctpport_ingress.val[3] |= 0x3;
+			break;
+
+		case GSW_MARKING_PCP_7P1D:
+			tbl_prog_ctpport_ingress.val[3] |= 0x4;
+			break;
+
+		case GSW_MARKING_PCP_6P2D:
+			tbl_prog_ctpport_ingress.val[3] |= 0x5;
+			break;
+
+		case GSW_MARKING_PCP_5P3D:
+			tbl_prog_ctpport_ingress.val[3] |= 0x6;
+			break;
+
+		case GSW_MARKING_DSCP_AF:
+			tbl_prog_ctpport_ingress.val[3] |= 0x7;
+			break;
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_MARKING) {
+		tbl_prog_ctpport_ingress.val[3] &= ~(0x70);
+
+		switch (param->eEgressMarkingMode) {
+		case GSW_MARKING_ALL_GREEN:
+			break;
+
+		case GSW_MARKING_INTERNAL_MARKING:
+			tbl_prog_ctpport_ingress.val[3] |= (0x1 << 4);
+			break;
+
+		case GSW_MARKING_DEI:
+			tbl_prog_ctpport_ingress.val[3] |= (0x2 << 4);
+			break;
+
+		case GSW_MARKING_PCP_8P0D:
+			tbl_prog_ctpport_ingress.val[3] |= (0x3 << 4);
+			break;
+
+		case GSW_MARKING_PCP_7P1D:
+			tbl_prog_ctpport_ingress.val[3] |= (0x4 << 4);
+			break;
+
+		case GSW_MARKING_PCP_6P2D:
+			tbl_prog_ctpport_ingress.val[3] |= (0x5 << 4);
+			break;
+
+		case GSW_MARKING_PCP_5P3D:
+			tbl_prog_ctpport_ingress.val[3] |= (0x6 << 4);
+			break;
+
+		case GSW_MARKING_DSCP_AF:
+			tbl_prog_ctpport_ingress.val[3] |= (0x7 << 4);
+			break;
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_REMARKING) {
+		tbl_prog_ctpport_egress.val[3] &= ~(0x7);
+
+		switch (param->eEgressRemarkingMode) {
+		case GSW_REMARKING_NONE:
+			break;
+
+		case GSW_REMARKING_DEI:
+			tbl_prog_ctpport_egress.val[3] |= 0x2;
+			break;
+
+		case GSW_REMARKING_PCP_8P0D:
+			tbl_prog_ctpport_egress.val[3] |= 0x3;
+			break;
+
+		case GSW_REMARKING_PCP_7P1D:
+			tbl_prog_ctpport_egress.val[3] |= 0x4;
+			break;
+
+		case GSW_REMARKING_PCP_6P2D:
+			tbl_prog_ctpport_egress.val[3] |= 0x5;
+			break;
+
+		case GSW_REMARKING_PCP_5P3D:
+			tbl_prog_ctpport_egress.val[3] |= 0x6;
+			break;
+
+		case GSW_REMARKING_DSCP_AF:
+			tbl_prog_ctpport_egress.val[3] |= 0x7;
+			break;
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_MARKING_OVERRIDE) {
+		if (param->bEgressMarkingOverrideEnable) {
+			/*Enable OverRide*/
+			tbl_prog_ctpport_egress.val[3] |= (1 << 3);
+			tbl_prog_ctpport_egress.val[3] &= ~(0x70);
+
+			switch (param->eEgressMarkingModeOverride) {
+			case GSW_MARKING_ALL_GREEN:
+				break;
+
+			case GSW_MARKING_INTERNAL_MARKING:
+				tbl_prog_ctpport_egress.val[3] |= (0x1 << 4);
+				break;
+
+			case GSW_MARKING_DEI:
+				tbl_prog_ctpport_egress.val[3] |= (0x2 << 4);
+				break;
+
+			case GSW_MARKING_PCP_8P0D:
+				tbl_prog_ctpport_egress.val[3] |= (0x3 << 4);
+				break;
+
+			case GSW_MARKING_PCP_7P1D:
+				tbl_prog_ctpport_egress.val[3] |= (0x4 << 4);
+				break;
+
+			case GSW_MARKING_PCP_6P2D:
+				tbl_prog_ctpport_egress.val[3] |= (0x5 << 4);
+				break;
+
+			case GSW_MARKING_PCP_5P3D:
+				tbl_prog_ctpport_egress.val[3] |= (0x6 << 4);
+				break;
+
+			case GSW_MARKING_DSCP_AF:
+				tbl_prog_ctpport_egress.val[3] |= (0x7 << 4);
+				break;
+			}
+		} else {
+			/*Disable OverRide*/
+			tbl_prog_ctpport_egress.val[3] &= ~(1 << 3);
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_FLOW_ENTRY) {
+		tbl_prog_ctpport_ingress.val[7] &= ~(0x7F << 2);
+		tbl_prog_ctpport_ingress.val[7] |= (param->nFirstFlowEntryIndex & 0x1FC);
+		tbl_prog_ctpport_ingress.val[8] &= ~(0xFF << 2);
+		tbl_prog_ctpport_ingress.val[8] |= (param->nNumberOfFlowEntries & 0x3FC);
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_LOOPBACK_AND_MIRROR) {
+		if (param->bIngressLoopbackEnable)
+			tbl_prog_ctpport_ingress.val[2] |= (1 << 14);
+		else
+			tbl_prog_ctpport_ingress.val[2] &= ~(1 << 14);
+
+		if (param->bEgressLoopbackEnable)
+			tbl_prog_ctpport_egress.val[4] |= (1 << 12);
+		else
+			tbl_prog_ctpport_egress.val[4] &= ~(1 << 12);
+
+		if (param->bIngressMirrorEnable)
+			tbl_prog_ctpport_ingress.val[5] |= (1 << 15);
+		else
+			tbl_prog_ctpport_ingress.val[5] &= ~(1 << 15);
+
+		if (param->bEgressMirrorEnable)
+			tbl_prog_ctpport_egress.val[5] |= (1 << 15);
+		else
+			tbl_prog_ctpport_egress.val[5] &= ~(1 << 15);
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_LOOPBACK_AND_MIRROR) {
+		if (param->bIngressDaSaSwapEnable)
+			tbl_prog_ctpport_ingress.val[4] |= (1 << 12);
+		else
+			tbl_prog_ctpport_ingress.val[4] &= ~(1 << 12);
+
+		if (param->bEgressDaSaSwapEnable)
+			tbl_prog_ctpport_egress.val[4] |= (1 << 13);
+		else
+			tbl_prog_ctpport_egress.val[4] &= ~(1 << 13);
+	}
+
+	/*Same ctp port idx for ingress and egress ctp port configuration*/
+	tbl_prog_ctpport_ingress.table = PCE_IGCTP_INDEX;
+	CLEAR_U16(tbl_prog_ctpport_ingress.pcindex);
+	/*Table Entry address (ctp port ingress Table index) Bit 8:0 in PCE_TBL_ADDR*/
+	tbl_prog_ctpport_ingress.pcindex |= (ctp_port & 0x1FF);
+
+	tbl_prog_ctpport_egress.table = PCE_EGCTP_INDEX;
+	CLEAR_U16(tbl_prog_ctpport_egress.pcindex);
+	/*Table Entry address (ctp port egress Table index) Bit 8:0 in PCE_TBL_ADDR*/
+	tbl_prog_ctpport_egress.pcindex |= (ctp_port & 0x1FF);
+
+
+	/*Address-based write for ingress ctp port configuration*/
+	gsw_pce_table_write(cdev, &tbl_prog_ctpport_ingress);
+	/*Address-based write for egress ctp port configuration*/
+	gsw_pce_table_write(cdev, &tbl_prog_ctpport_egress);
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_CtpPortConfigGet(void *cdev, GSW_CTP_portConfig_t *param)
+{
+	pctbl_prog_t tbl_prog_ctpport_ingress;
+	pctbl_prog_t tbl_prog_ctpport_egress;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ctp_port, FirstIdx, LastIdx, BlkSize;
+	u16 ret, value;
+	GSW_CTP_portAssignment_t ctp_get;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	/*check based on number of logical port*/
+	if (param->nLogicalPortId > gswdev->tpnum) {
+		pr_err("param->nLogicalPortId > gswdev->pnum\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*CTP ports has to assigned/mapped to Logical port before calling
+	  CTP port configuration.
+	  GSW_CTP_PortAssignmentGet will get the info on the assignment
+	  Use this info to find whether this CTP port is with in the range
+	  this logical port
+	*/
+	ctp_get.nLogicalPortId = param->nLogicalPortId;
+	ret = GSW_CTP_PortAssignmentGet(cdev, &ctp_get);
+
+	if (ret == GSW_statusErr)
+		goto UNLOCK_AND_RETURN;
+
+	/*IMPORTANT NOTE : :As per the CTP concept  nFirstCtpPortId + nSubIfIdGroup is the expected CTP port*/
+	ctp_port = ctp_get.nFirstCtpPortId + param->nSubIfIdGroup;
+
+	if (ctp_port > gswdev->num_of_ctp) {
+		pr_err("ctp_port %d > gswdev->num_of_ctp\n", ctp_port);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*If not with in the Assigned range Return Error*/
+	if (ctp_port < ctp_get.nFirstCtpPortId ||
+	    ctp_port >= (ctp_get.nFirstCtpPortId + ctp_get.nNumberOfCtpPort)) {
+		pr_err("ERROR :CTP port not with in Allocated range\n");
+		pr_err("Check CTP assignment Get\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*NOTE : This Mask is for debugging purpose only
+	  If GSW_CTP_PORT_CONFIG_MASK_FORCE mask is set
+	  It will not check index in-use */
+	if (!(param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE)) {
+		/*Check whether CTP is allocated by GSW_CTP_PortAssignmentAlloc*/
+		if (!gswdev->ctpportconfig_idx[ctp_port].IndexInUse) {
+			pr_err("ctp_port %d  Index not in use,CTP not allocated\n", ctp_port);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	/*Same ctp port idx for ingress and egress ctp port configuration*/
+	memset(&tbl_prog_ctpport_ingress, 0, sizeof(pctbl_prog_t));
+	tbl_prog_ctpport_ingress.table = PCE_IGCTP_INDEX;
+	CLEAR_U16(tbl_prog_ctpport_ingress.pcindex);
+	/*Table Entry address (ctp port ingress Table index) Bit 8:0 in PCE_TBL_ADDR*/
+	tbl_prog_ctpport_ingress.pcindex |= (ctp_port & 0x1FF);
+
+	memset(&tbl_prog_ctpport_egress, 0, sizeof(pctbl_prog_t));
+	tbl_prog_ctpport_egress.table = PCE_EGCTP_INDEX;
+	CLEAR_U16(tbl_prog_ctpport_egress.pcindex);
+	/*Table Entry address (ctp port egress Table index) Bit 8:0 in PCE_TBL_ADDR*/
+	tbl_prog_ctpport_egress.pcindex |= (ctp_port & 0x1FF);
+
+	/*Address-based read for ingress ctp port configuration*/
+	gsw_pce_table_read(cdev, &tbl_prog_ctpport_ingress);
+
+	/*Address-based read for egress ctp port configuration*/
+	gsw_pce_table_read(cdev, &tbl_prog_ctpport_egress);
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_BRIDGE_PORT_ID) {
+		param->nBridgePortId = (tbl_prog_ctpport_ingress.val[0] & 0xFF);
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE_TRAFFIC_CLASS) {
+		/** Default traffic class associated with all traffic from this CTP Port. */
+		param->nDefaultTrafficClass = ((tbl_prog_ctpport_ingress.val[0] & 0xF00) >> 8);
+		/* 0 -Traffic class can be over written by the following processing stage
+		   1 -Traffic class can not be over written by the following processing stage
+		*/
+		param->bForcedTrafficClass  = ((tbl_prog_ctpport_ingress.val[0] & 0x1000) >> 12);
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN) {
+		param->bIngressExtendedVlanEnable = ((tbl_prog_ctpport_ingress.val[1] & 0x4000) >> 14);
+
+		if (param->bIngressExtendedVlanEnable) {
+			param->nIngressExtendedVlanBlockId = (tbl_prog_ctpport_ingress.val[1] & 0x3FF);
+			FirstIdx 	= param->nIngressExtendedVlanBlockId;
+			LastIdx		= (tbl_prog_ctpport_ingress.val[2] & 0x3FF);
+
+			if (FirstIdx == LastIdx)
+				BlkSize	= 1;
+			else
+				BlkSize = ((LastIdx - FirstIdx) + 1);
+
+			param->nIngressExtendedVlanBlockSize = BlkSize;
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN_IGMP) {
+		param->bIngressExtendedVlanIgmpEnable = ((tbl_prog_ctpport_ingress.val[5] & 0x4000) >> 14);
+
+		if (param->bIngressExtendedVlanIgmpEnable) {
+			param->nIngressExtendedVlanBlockIdIgmp = (tbl_prog_ctpport_ingress.val[5] & 0x3FF);
+			FirstIdx	= param->nIngressExtendedVlanBlockIdIgmp;
+			LastIdx 	= (tbl_prog_ctpport_ingress.val[6] & 0x3FF);
+
+			if (FirstIdx == LastIdx)
+				BlkSize = 1;
+			else
+				BlkSize = ((LastIdx - FirstIdx) + 1);
+
+			param->nIngressExtendedVlanBlockSizeIgmp = BlkSize;
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN) {
+		param->bEgressExtendedVlanEnable = ((tbl_prog_ctpport_egress.val[1] & 0x4000) >> 14);
+
+		if (param->bEgressExtendedVlanEnable) {
+			param->nEgressExtendedVlanBlockId = (tbl_prog_ctpport_egress.val[1] & 0x3FF);
+			FirstIdx	= param->nEgressExtendedVlanBlockId;
+			LastIdx 	= (tbl_prog_ctpport_egress.val[2]  & 0x3FF);
+
+			if (FirstIdx == LastIdx)
+				BlkSize = 1;
+			else
+				BlkSize = ((LastIdx - FirstIdx) + 1);
+
+			param->nEgressExtendedVlanBlockSize = BlkSize;
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN_IGMP) {
+		param->bEgressExtendedVlanIgmpEnable = ((tbl_prog_ctpport_egress.val[5] & 0x4000) >> 14);
+
+		if (param->bEgressExtendedVlanIgmpEnable) {
+			param->nEgressExtendedVlanBlockIdIgmp = (tbl_prog_ctpport_egress.val[5] & 0x3FF);
+			FirstIdx	= param->nEgressExtendedVlanBlockIdIgmp;
+			LastIdx 	= (tbl_prog_ctpport_egress.val[6]  & 0x3FF);
+
+			if (FirstIdx == LastIdx)
+				BlkSize = 1;
+			else
+				BlkSize = ((LastIdx - FirstIdx) + 1);
+
+			param->nEgressExtendedVlanBlockSizeIgmp = BlkSize;
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_INRESS_NTO1_VLAN)
+		param->bIngressNto1VlanEnable = ((tbl_prog_ctpport_ingress.val[1] & 0x8000) >> 15);
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_MASK_EGRESS_NTO1_VLAN)
+		param->bEgressNto1VlanEnable = ((tbl_prog_ctpport_egress.val[1] & 0x8000) >> 15);
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_INGRESS_METER) {
+		param->bIngressMeteringEnable = ((tbl_prog_ctpport_ingress.val[3] & 0x80) >> 7);
+
+		if (param->bIngressMeteringEnable)
+			param->nIngressTrafficMeterId = ((tbl_prog_ctpport_ingress.val[3] & 0x7F00) >> 8);
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_METER) {
+		param->bEgressMeteringEnable = ((tbl_prog_ctpport_egress.val[3] & 0x80) >> 7);
+
+		if (param->bEgressMeteringEnable)
+			param->nEgressTrafficMeterId = ((tbl_prog_ctpport_egress.val[3] & 0x7F00) >> 8);
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_BRIDGING_BYPASS) {
+		param->bBridgingBypass = ((tbl_prog_ctpport_ingress.val[4] & 0x8000) >> 15);
+
+		if (param->bBridgingBypass) {
+			param->nDestLogicalPortId = ((tbl_prog_ctpport_ingress.val[4] & 0xF00) >> 8);
+			param->bPmapperEnable = ((tbl_prog_ctpport_ingress.val[4] & 0x4000) >> 14);
+
+			if (param->bPmapperEnable) {
+				param->sPmapper.nPmapperId = (tbl_prog_ctpport_ingress.val[4] & 0xFF);
+				ret = GSW_QOS_PmapperTableGet(cdev, &param->sPmapper);
+
+				if (ret == GSW_statusErr)
+					goto UNLOCK_AND_RETURN;
+
+				value = ((tbl_prog_ctpport_ingress.val[4] & 0x2000) >> 13);
+
+				switch (value) {
+				case 0:
+					param->ePmapperMappingMode = GSW_PMAPPER_MAPPING_PCP;
+					break;
+
+				case 1:
+					param->ePmapperMappingMode = GSW_PMAPPER_MAPPING_DSCP;
+					break;
+				}
+			} else {
+				param->nDestSubIfIdGroup = (tbl_prog_ctpport_ingress.val[4] & 0xFF);
+			}
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_INGRESS_MARKING) {
+		value = (tbl_prog_ctpport_ingress.val[3] & 0x7);
+
+		switch (value) {
+		case 0:
+			param->eIngressMarkingMode = GSW_MARKING_ALL_GREEN;
+			break;
+
+		case 1:
+			param->eIngressMarkingMode = GSW_MARKING_INTERNAL_MARKING;
+			break;
+
+		case 2:
+			param->eIngressMarkingMode = GSW_MARKING_DEI;
+			break;
+
+		case 3:
+			param->eIngressMarkingMode = GSW_MARKING_PCP_8P0D;
+			break;
+
+		case 4:
+			param->eIngressMarkingMode = GSW_MARKING_PCP_7P1D;
+			break;
+
+		case 5:
+			param->eIngressMarkingMode = GSW_MARKING_PCP_6P2D;
+			break;
+
+		case 6:
+			param->eIngressMarkingMode = GSW_MARKING_PCP_5P3D;
+			break;
+
+		case 7:
+			param->eIngressMarkingMode = GSW_MARKING_DSCP_AF;
+			break;
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_MARKING) {
+		value = ((tbl_prog_ctpport_ingress.val[3] & 0x70) >> 4);
+
+		switch (value) {
+		case 0:
+			param->eEgressMarkingMode = GSW_MARKING_ALL_GREEN;
+			break;
+
+		case 1:
+			param->eEgressMarkingMode = GSW_MARKING_INTERNAL_MARKING;
+			break;
+
+		case 2:
+			param->eEgressMarkingMode = GSW_MARKING_DEI;
+			break;
+
+		case 3:
+			param->eEgressMarkingMode = GSW_MARKING_PCP_8P0D;
+			break;
+
+		case 4:
+			param->eEgressMarkingMode = GSW_MARKING_PCP_7P1D;
+			break;
+
+		case 5:
+			param->eEgressMarkingMode = GSW_MARKING_PCP_6P2D;
+			break;
+
+		case 6:
+			param->eEgressMarkingMode = GSW_MARKING_PCP_5P3D;
+			break;
+
+		case 7:
+			param->eEgressMarkingMode = GSW_MARKING_DSCP_AF;
+			break;
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_REMARKING) {
+		value = (tbl_prog_ctpport_egress.val[3] & 0x7);
+
+		switch (value) {
+		case 0:
+		case 1:
+			param->eEgressRemarkingMode = GSW_REMARKING_NONE;
+			break;
+
+		case 2:
+			param->eEgressRemarkingMode = GSW_REMARKING_DEI;
+			break;
+
+		case 3:
+			param->eEgressRemarkingMode = GSW_REMARKING_PCP_8P0D;
+			break;
+
+		case 4:
+			param->eEgressRemarkingMode = GSW_REMARKING_PCP_7P1D;
+			break;
+
+		case 5:
+			param->eEgressRemarkingMode = GSW_REMARKING_PCP_6P2D;
+			break;
+
+		case 6:
+			param->eEgressRemarkingMode = GSW_REMARKING_PCP_5P3D;
+			break;
+
+		case 7:
+			param->eEgressRemarkingMode = GSW_REMARKING_DSCP_AF;
+			break;
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_EGRESS_MARKING_OVERRIDE) {
+		param->bEgressMarkingOverrideEnable = ((tbl_prog_ctpport_egress.val[3] & 0x8) >> 3);
+
+		if (param->bEgressMarkingOverrideEnable) {
+			value = ((tbl_prog_ctpport_egress.val[3] & 0x70) >> 4);
+
+			switch (value) {
+			case 0:
+				param->eEgressMarkingModeOverride = GSW_MARKING_ALL_GREEN;
+				break;
+
+			case 1:
+				param->eEgressMarkingModeOverride = GSW_MARKING_INTERNAL_MARKING;
+				break;
+
+			case 2:
+				param->eEgressMarkingModeOverride = GSW_MARKING_DEI;
+				break;
+
+			case 3:
+				param->eEgressMarkingModeOverride = GSW_MARKING_PCP_8P0D;
+				break;
+
+			case 4:
+				param->eEgressMarkingModeOverride = GSW_MARKING_PCP_7P1D;
+				break;
+
+			case 5:
+				param->eEgressMarkingModeOverride = GSW_MARKING_PCP_6P2D;
+				break;
+
+			case 6:
+				param->eEgressMarkingModeOverride = GSW_MARKING_PCP_5P3D;
+				break;
+
+			case 7:
+				param->eEgressMarkingModeOverride = GSW_MARKING_DSCP_AF;
+				break;
+			}
+		}
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_FLOW_ENTRY) {
+		param->nFirstFlowEntryIndex = (tbl_prog_ctpport_ingress.val[7] & 0x1FC);
+		param->nNumberOfFlowEntries = (tbl_prog_ctpport_ingress.val[8] & 0x3FC);
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_LOOPBACK_AND_MIRROR) {
+		param->bIngressLoopbackEnable = ((tbl_prog_ctpport_ingress.val[2] & 0x4000) >> 14);
+		param->bEgressLoopbackEnable = ((tbl_prog_ctpport_egress.val[4] & 0x1000) >> 12);
+		param->bIngressMirrorEnable = ((tbl_prog_ctpport_ingress.val[5] & 0x8000) >> 15);
+		param->bEgressMirrorEnable = ((tbl_prog_ctpport_egress.val[5] & 0x8000) >> 15);
+	}
+
+	if (param->eMask & GSW_CTP_PORT_CONFIG_LOOPBACK_AND_MIRROR) {
+		param->bIngressDaSaSwapEnable = ((tbl_prog_ctpport_ingress.val[4] & 0x1000) >> 12);
+		param->bEgressDaSaSwapEnable = ((tbl_prog_ctpport_egress.val[4] & 0x2000) >> 13);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_CtpPortConfigReset(void *cdev, GSW_CTP_portConfig_t *param)
+{
+	pctbl_prog_t tbl_prog_ctpport_ingress;
+	pctbl_prog_t tbl_prog_ctpport_egress;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 FirstIdx, ctp_port;
+	u16 ret;
+	GSW_CTP_portAssignment_t ctp_get;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	/*check based on number of logical port*/
+	if (param->nLogicalPortId >= gswdev->tpnum) {
+		pr_err("param->nLogicalPortId > gswdev->pnum\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*CTP ports has to assigned/mapped to Logical port before calling
+	  CTP port configuration.
+	  GSW_CTP_PortAssignmentGet will get the info on the assignment
+	  Use this info to find whether this CTP port is with in the range
+	  this logical port
+	*/
+	ctp_get.nLogicalPortId = param->nLogicalPortId;
+	ret = GSW_CTP_PortAssignmentGet(cdev, &ctp_get);
+
+	if (ret == GSW_statusErr)
+		goto UNLOCK_AND_RETURN;
+
+	/*IMPORTANT NOTE : :As per the CTP concept  nFirstCtpPortId + nSubIfIdGroup is the expected CTP port*/
+	ctp_port = ctp_get.nFirstCtpPortId + param->nSubIfIdGroup;
+
+	if (ctp_port > gswdev->num_of_ctp) {
+		pr_err("ctp_port %d > gswdev->num_of_ctp\n", ctp_port);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*If not with in the Assigned range Return Error*/
+	if (ctp_port < ctp_get.nFirstCtpPortId ||
+	    ctp_port >= (ctp_get.nFirstCtpPortId + ctp_get.nNumberOfCtpPort)) {
+		pr_err("ERROR :CTP port not with in Allocated range\n");
+		pr_err("Check CTP assignment Get\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*This Mask is for DEBUGGING purpose only
+	  If GSW_CTP_PORT_CONFIG_MASK_FORCE mask is set
+	  It not check index to in-use*/
+	if (!(param->eMask & GSW_CTP_PORT_CONFIG_MASK_FORCE)) {
+		/*Check whether CTP is allocated by GSW_CTP_PortAssignmentAlloc*/
+		if (!gswdev->ctpportconfig_idx[ctp_port].IndexInUse) {
+			pr_err("ERROR :ctp_port %d  Index not in use,CTP not allocated\n", ctp_port);
+			pr_err("ERROR :ctp_port %d  Index can not be deleted", ctp_port);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+	}
+
+	/*Some one is still using this CTP port -configuration
+	  can be deleted only if that some one releases this CTP port*/
+	if (gswdev->ctpportconfig_idx[ctp_port].IndexInUsageCnt) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*Same ctp port idx for ingress and egress ctp port configuration*/
+	memset(&tbl_prog_ctpport_ingress, 0, sizeof(pctbl_prog_t));
+	tbl_prog_ctpport_ingress.table = PCE_IGCTP_INDEX;
+	CLEAR_U16(tbl_prog_ctpport_ingress.pcindex);
+	/*Table Entry address (ctp port ingress Table index) Bit 8:0 in PCE_TBL_ADDR*/
+	tbl_prog_ctpport_ingress.pcindex |= (ctp_port & 0x1FF);
+
+	memset(&tbl_prog_ctpport_egress, 0, sizeof(pctbl_prog_t));
+	tbl_prog_ctpport_egress.table = PCE_EGCTP_INDEX;
+	CLEAR_U16(tbl_prog_ctpport_egress.pcindex);
+	/*Table Entry address (ctp port egress Table index) Bit 8:0 in PCE_TBL_ADDR*/
+	tbl_prog_ctpport_egress.pcindex |= (ctp_port & 0x1FF);
+
+	/*Address-based read for ingress ctp port configuration*/
+	gsw_pce_table_read(cdev, &tbl_prog_ctpport_ingress);
+
+	/*Address-based read for egress ctp port configuration*/
+	gsw_pce_table_read(cdev, &tbl_prog_ctpport_egress);
+
+	param->nBridgePortId = (tbl_prog_ctpport_ingress.val[0] & 0xFF);
+
+	if (gswdev->ctpportconfig_idx[ctp_port].BrdgIdPortAssigned) {
+		if (gswdev->ctpportconfig_idx[ctp_port].BrdgPortId ==
+		    param->nBridgePortId) {
+			/*Release this Bridge port from this CTP Port*/
+			gswdev->brdgeportconfig_idx[param->nBridgePortId].IndexInUsageCnt--;
+			gswdev->ctpportconfig_idx[ctp_port].BrdgIdPortAssigned = 0;
+			gswdev->ctpportconfig_idx[ctp_port].BrdgPortId = 0;
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	param->nIngressExtendedVlanBlockId = (tbl_prog_ctpport_ingress.val[1] & 0x3FF);
+
+	if (gswdev->ctpportconfig_idx[ctp_port].IngressExVlanNonIgmpBlkAssigned) {
+		if (gswdev->ctpportconfig_idx[ctp_port].IngressExVlanNonIgmpBlkId ==
+		    param->nIngressExtendedVlanBlockId) {
+			/*Release this vlan blk from this CTP Port*/
+			FirstIdx = param->nIngressExtendedVlanBlockId;
+			gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUsageCnt--;
+			gswdev->ctpportconfig_idx[ctp_port].IngressExVlanNonIgmpBlkAssigned = 0;
+			gswdev->ctpportconfig_idx[ctp_port].IngressExVlanNonIgmpBlkId = EXVLAN_ENTRY_INVALID;
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	param->nIngressExtendedVlanBlockIdIgmp = (tbl_prog_ctpport_ingress.val[5] & 0x3FF);
+
+	if (gswdev->ctpportconfig_idx[ctp_port].IngressExVlanIgmpBlkAssigned) {
+		if (gswdev->ctpportconfig_idx[ctp_port].IngressExVlanIgmpBlkId ==
+		    param->nIngressExtendedVlanBlockIdIgmp) {
+			/*Release this vlan blk from this CTP Port*/
+			FirstIdx = param->nIngressExtendedVlanBlockIdIgmp;
+			gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUsageCnt--;
+			gswdev->ctpportconfig_idx[ctp_port].IngressExVlanIgmpBlkAssigned = 0;
+			gswdev->ctpportconfig_idx[ctp_port].IngressExVlanIgmpBlkId = EXVLAN_ENTRY_INVALID;
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	param->nEgressExtendedVlanBlockId = (tbl_prog_ctpport_egress.val[1] & 0x3FF);
+
+	if (gswdev->ctpportconfig_idx[ctp_port].EgressExVlanNonIgmpBlkAssigned) {
+		if (gswdev->ctpportconfig_idx[ctp_port].EgressExVlanNonIgmpBlkId ==
+		    param->nEgressExtendedVlanBlockId) {
+			/*Release this vlan blk from this CTP Port*/
+			FirstIdx = param->nEgressExtendedVlanBlockId;
+			gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUsageCnt--;
+			gswdev->ctpportconfig_idx[ctp_port].EgressExVlanNonIgmpBlkAssigned = 0;
+			gswdev->ctpportconfig_idx[ctp_port].EgressExVlanNonIgmpBlkId = EXVLAN_ENTRY_INVALID;
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	param->nEgressExtendedVlanBlockIdIgmp = (tbl_prog_ctpport_egress.val[5] & 0x3FF);
+
+	if (gswdev->ctpportconfig_idx[ctp_port].EgressExVlanIgmpBlkAssigned) {
+		if (gswdev->ctpportconfig_idx[ctp_port].EgressExVlanIgmpBlkId ==
+		    param->nEgressExtendedVlanBlockIdIgmp) {
+			/*Release this vlan blk from this CTP Port*/
+			FirstIdx = param->nEgressExtendedVlanBlockIdIgmp;
+			gswdev->extendvlan_idx.vlan_idx[FirstIdx].IndexInUsageCnt--;
+			gswdev->ctpportconfig_idx[ctp_port].EgressExVlanIgmpBlkAssigned = 0;
+			gswdev->ctpportconfig_idx[ctp_port].EgressExVlanIgmpBlkId = EXVLAN_ENTRY_INVALID;
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	param->nIngressTrafficMeterId = ((tbl_prog_ctpport_ingress.val[3] & 0x7F00) >> 8);
+
+	if (gswdev->ctpportconfig_idx[ctp_port].IngressMeteringAssigned) {
+		if (gswdev->ctpportconfig_idx[ctp_port].IngressTrafficMeterId ==
+		    param->nIngressTrafficMeterId) {
+			/*Release this meter id from this CTP Port*/
+			gswdev->meter_idx[param->nIngressTrafficMeterId].IndexInUsageCnt--;
+			gswdev->ctpportconfig_idx[ctp_port].IngressMeteringAssigned = 0;
+			gswdev->ctpportconfig_idx[ctp_port].IngressTrafficMeterId = 0;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	param->nEgressTrafficMeterId = ((tbl_prog_ctpport_egress.val[3] & 0x7F00) >> 8);
+
+	if (gswdev->ctpportconfig_idx[ctp_port].EgressMeteringAssigned) {
+		if (gswdev->ctpportconfig_idx[ctp_port].EgressTrafficMeterId ==
+		    param->nEgressTrafficMeterId) {
+			/*Release this meter id from this CTP Port*/
+			gswdev->meter_idx[param->nEgressTrafficMeterId].IndexInUsageCnt--;
+			gswdev->ctpportconfig_idx[ctp_port].EgressMeteringAssigned = 0;
+			gswdev->ctpportconfig_idx[ctp_port].EgressTrafficMeterId = 0;
+
+		} else {
+			/*if assigned and idx does not match with recorded idx.
+			 some thing is wrong.This should never happen*/
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	param->sPmapper.nPmapperId = (tbl_prog_ctpport_ingress.val[4] & 0xFF);
+
+	if (gswdev->ctpportconfig_idx[ctp_port].IngressBridgeBypassPmapperAssigned) {
+		/*Release this p-mapper idx from this CTP Port*/
+		gswdev->pmapper_idx[param->sPmapper.nPmapperId].IndexInUse = 0;
+		gswdev->ctpportconfig_idx[ctp_port].IngressBridgeBypassPmapperAssigned = 0;
+		gswdev->ctpportconfig_idx[ctp_port].IngressBridgeBypassPmappperIdx = 0;
+	}
+
+	/*Zero the ingress/egress ctp port table index*/
+	/*Same ctp port idx for ingress and egress ctp port configuration*/
+	memset(&tbl_prog_ctpport_ingress, 0, sizeof(pctbl_prog_t));
+	tbl_prog_ctpport_ingress.table = PCE_IGCTP_INDEX;
+	CLEAR_U16(tbl_prog_ctpport_ingress.pcindex);
+	/*Table Entry address (ctp port ingress Table index) Bit 8:0 in PCE_TBL_ADDR*/
+	tbl_prog_ctpport_ingress.pcindex |= (ctp_port & 0x1FF);
+
+	/*Set Bridge port 127 - The ingress traffic is never assigned to port 127.
+	The packet may have egress bridge port ID 127 if the traffic is ingress loopback traffic,
+	bridge bypass traffic, or mirror copy (either ingress copyor egress copy).*/
+	tbl_prog_ctpport_ingress.val[0] |= (0x7F);
+
+	memset(&tbl_prog_ctpport_egress, 0, sizeof(pctbl_prog_t));
+	tbl_prog_ctpport_egress.table = PCE_EGCTP_INDEX;
+	CLEAR_U16(tbl_prog_ctpport_egress.pcindex);
+	/*Table Entry address (ctp port egress Table index) Bit 8:0 in PCE_TBL_ADDR*/
+	tbl_prog_ctpport_egress.pcindex |= (ctp_port & 0x1FF);
+
+	/*Address-based write for ingress ctp port configuration*/
+	gsw_pce_table_write(cdev, &tbl_prog_ctpport_ingress);
+	/*Address-based write for egress ctp port configuration*/
+	gsw_pce_table_write(cdev, &tbl_prog_ctpport_egress);
+
+	/*Free this ctp port idx*/
+	//gswdev->ctpportconfig_idx[ctp_port].IndexInUse=0;
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_DefaultMacFilterSet(void *cdev, GSW_MACFILTER_default_t *param)
+{
+	u16 i = 0;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	/*   Each bit stands for 1 bridge port. For Falcon-Mx (GSWIP-3.1 integrated),
+	   only index 0-7 is valid. */
+	switch (param->eType) {
+	case GSW_MACFILTERTYPE_SRC:
+		for (i = 0; i <= 7; i++) {
+			gsw_w32(cdev, PCE_SA_FILTER_OFFSET_GET(i),
+				PCE_SA_FILTER_SHIFT,
+				PCE_SA_FILTER_SIZE, param->nPortmap[i]);
+		}
+
+		break;
+
+	case GSW_MACFILTERTYPE_DEST:
+		for (i = 0; i <= 7; i++) {
+			gsw_w32(cdev, PCE_DA_FILTER_OFFSET_GET(i),
+				PCE_DA_FILTER_SHIFT,
+				PCE_DA_FILTER_SIZE, param->nPortmap[i]);
+		}
+
+		break;
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_DefaultMacFilterGet(void *cdev, GSW_MACFILTER_default_t *param)
+{
+	u32 i = 0, value = 0;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	/*   Each bit stands for 1 bridge port. For Falcon-Mx (GSWIP-3.1 integrated),
+	   only index 0-7 is valid. */
+	switch (param->eType) {
+	case GSW_MACFILTERTYPE_SRC:
+		for (i = 0; i <= 7; i++) {
+			gsw_r32(cdev, PCE_SA_FILTER_OFFSET_GET(i),
+				PCE_SA_FILTER_SHIFT,
+				PCE_SA_FILTER_SIZE, &value);
+			param->nPortmap[i] = value;
+		}
+
+		break;
+
+	case GSW_MACFILTERTYPE_DEST:
+		for (i = 0; i <= 7; i++) {
+			gsw_r32(cdev, PCE_DA_FILTER_OFFSET_GET(i),
+				PCE_DA_FILTER_SHIFT,
+				PCE_DA_FILTER_SIZE, &value);
+			param->nPortmap[i] = value;
+		}
+
+		break;
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_QOS_MeterAlloc(void *cdev, GSW_QoS_meterCfg_t *param)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u16 idx = 0, freeidxfound = 0, ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_alloc);
+#endif
+
+	/*If Meter ID is invalid ,find a new meter index
+	  and allocate*/
+
+	if (param->nMeterId == METER_ENTRY_INVALID) {
+		for (idx = 0; idx < gswdev->num_of_meters && !freeidxfound; idx++) {
+			if (!(gswdev->meter_idx[idx].IndexInUse)) {
+				gswdev->meter_idx[idx].IndexInUse = 1;
+				param->nMeterId = idx;
+				freeidxfound = 1;
+			}
+		}
+
+		/*No free Slot return Error*/
+		if (!freeidxfound) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	if (param->nMeterId > gswdev->num_of_meters) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if (param->nMeterId > (METER_TABLE_SIZE - 1)) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*If Meter ID is valid,Check whether it is InUSE
+	  if not InUse,return ERROR*/
+	if (!(gswdev->meter_idx[param->nMeterId].IndexInUse)) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*Change summary of GSW_QoS_MeterCfgSet for GSWIP 3.1
+		1. Meter Color Blind is newly added
+		2. IBS is byte based
+	*/
+	ret = GSW_QoS_MeterCfgSet(cdev, param);
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_alloc);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_QOS_MeterFree(void *cdev, GSW_QoS_meterCfg_t *param)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_free);
+#endif
+
+	if (param->nMeterId > gswdev->num_of_meters) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if (param->nMeterId == METER_ENTRY_INVALID) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	if (param->nMeterId > (METER_TABLE_SIZE - 1)) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*If Meter ID is valid,Check whether it is InUSE
+	  if not InUse,return ERROR*/
+	if (!gswdev->meter_idx[param->nMeterId].IndexInUse) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*If this Meter idx usage count is not zero that means it is still used by some one.
+	  This Meter idx can be freed, only if that some one release this Meter ID*/
+	if (gswdev->meter_idx[param->nMeterId].IndexInUsageCnt) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*Just mark the Meter idx as free*/
+	gswdev->meter_idx[param->nMeterId].IndexInUse = 0;
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_free);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_RMON_ExtendGet(void *cdev, GSW_RMON_extendGet_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 pidx = parm->nPortId, i;
+	u32 value, data0, data1;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	if (parm->nPortId >= gswdev->tpnum) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	memset(parm, 0, sizeof(GSW_RMON_extendGet_t));
+
+	for (i = 0; i < GSW_RMON_EXTEND_NUM; i++) {
+		gsw_w32(cdev, BM_RAM_ADDR_ADDR_OFFSET,
+			BM_RAM_ADDR_ADDR_SHIFT,
+			BM_RAM_ADDR_ADDR_SIZE,
+			(i + REX_TFLOW_CNT_1));
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			if (pidx >= 8)
+				value = (pidx + 8);
+			else
+				value = pidx;
+
+			gsw_w32(cdev, BM_RAM_CTRL_ADDR_OFFSET,
+				BM_RAM_CTRL_ADDR_SHIFT,
+				BM_RAM_CTRL_ADDR_SIZE, value);
+		} else {
+			gsw_w32(cdev, BM_RAM_CTRL_ADDR_OFFSET,
+				BM_RAM_CTRL_ADDR_SHIFT,
+				BM_RAM_CTRL_ADDR_SIZE, pidx);
+		}
+
+		gsw_w32(cdev, BM_RAM_CTRL_OPMOD_OFFSET,
+			BM_RAM_CTRL_OPMOD_SHIFT,
+			BM_RAM_CTRL_OPMOD_SIZE, 0);
+		value = 1;
+		gsw_w32(cdev, BM_RAM_CTRL_BAS_OFFSET,
+			BM_RAM_CTRL_BAS_SHIFT,
+			BM_RAM_CTRL_BAS_SIZE, value);
+		CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET, BM_RAM_CTRL_BAS_SHIFT,
+			   BM_RAM_CTRL_BAS_SHIFT, RETURN_FROM_FUNCTION);
+		gsw_r32(cdev, BM_RAM_VAL_0_VAL0_OFFSET,
+			BM_RAM_VAL_0_VAL0_SHIFT,
+			BM_RAM_VAL_0_VAL0_SIZE, &data0);
+		gsw_r32(cdev, BM_RAM_VAL_1_VAL1_OFFSET,
+			BM_RAM_VAL_1_VAL1_SHIFT,
+			BM_RAM_VAL_1_VAL1_SIZE, &data1);
+		parm->nTrafficFlowCnt[i] = (data1 << 16 | data0);
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_RMON_FlowGet(void *cdev, GSW_RMON_flowGet_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 data0, data1, data2, data3, counterMsb = 0, counterLsb = 0;
+	u32 tflowIndex = 0, ctrlRegData = 0, addrRegData = 0;
+	u8 portType, nBits;  //Number of RMON valid bits.
+	GSW_TflowCmodeConf_t cMode;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	//Given absolute couter index to read.
+	if (parm->bIndex)
+		tflowIndex = parm->nIndex;
+	else {
+		//Compute absolute couter index to read.
+		memset(&cMode, 0, sizeof(GSW_TflowCmodeConf_t));
+		GSW_TflowCountModeGet(cdev, &cMode);
+
+		if (cMode.eCountMode == GSW_TFLOW_CMODE_LOGICAL)
+			nBits = 5;
+		else
+			nBits = (cMode.nBrpLsb | cMode.nCtpLsb); //Only one of is valiad.
+
+		//Is the given port is among configured MSB port group?
+		if ((parm->nPortId >> (9 - nBits)) == cMode.nPortMsb) {
+			//LS (9-nBits) bits of given port become MS bits of counter index to read.
+			counterMsb = ((parm->nPortId) & ((1 << (9 - nBits)) - 1));
+			//LS (nBits) bits of given RMON-Id become LS bits of counter index to read.
+			counterLsb = ((parm->nFlowId) & ((1 << nBits) - 1));
+			//Absolute counter index to read is.
+			tflowIndex = ((counterMsb << nBits) | counterLsb);
+			parm->nIndex = tflowIndex;
+		} else {
+			pr_err("ERR:nPortId's MS %d bits are not matching the group %d\n",
+			       (9 - (nBits - 1)), cMode.nPortMsb);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	//Validate absolute couter index.
+	if (tflowIndex >= PCE_TABLE_SIZE) { //Max index check.
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	//1.Get PCE Rx counters.
+	portType = GSW_RMON_TFLOW_RX;
+	//Populate 'data' register's Port-Offset.
+	FILL_CTRL_REG(addrRegData, BM_RAM_ADDR_RMON_PORT_SHIFT, tflowIndex);
+	//Populate 'data' register's Counter-Offset.
+	//FILL_CTRL_REG(addrRegData, BM_RAM_ADDR_RMON_COUNTER_SHIFT, 0);
+	//Populate 'control' register data.
+	//RMON TFLOW Rx table to read.
+	FILL_CTRL_REG(ctrlRegData, BM_RAM_CTRL_ADDR_SHIFT, portType);
+	//RAM in read mode.
+	//FILL_CTRL_REG(ctrlRegData, BM_RAM_CTRL_OPMOD_SHIFT, 0);
+	//Set access busy bit.
+	FILL_CTRL_REG(ctrlRegData, BM_RAM_CTRL_BAS_SHIFT, 1);
+	//Set RAM address to read.
+	gsw_w32_raw(cdev, BM_RAM_ADDR_REG_OFFSET, addrRegData);
+	//Set RAM table to read.
+	gsw_w32_raw(cdev, BM_RAM_CTRL_REG_OFFSET, ctrlRegData);
+	//Wait untill RAM is ready to read.
+	CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET, BM_RAM_CTRL_BAS_SHIFT,
+		   BM_RAM_CTRL_BAS_SIZE, RETURN_FROM_FUNCTION);
+	gsw_r32_raw(cdev, BM_RAM_VAL_0_VAL0_OFFSET, &data0);
+	gsw_r32_raw(cdev, BM_RAM_VAL_1_VAL1_OFFSET, &data1);
+	parm->nRxPkts = (data1 << 16 | data0);
+
+	//2.Get PCE Tx counters.
+	portType = GSW_RMON_TFLOW_TX;
+	//RMON TFLOW Tx table to read.
+	CLEAR_FILL_CTRL_REG(ctrlRegData, BM_RAM_CTRL_ADDR_SHIFT,
+			    BM_RAM_CTRL_ADDR_SIZE, portType);
+	//64 bit counter mode. It is not supported in HW at this moment.
+	//FILL_CTRL_REG(ctrlRegData, BM_RAM_CTRL_64BIT_OPMOD_SHIFT, 1);
+	//Set RAM address to read.
+	gsw_w32_raw(cdev, BM_RAM_ADDR_REG_OFFSET, addrRegData);
+	//Set RAM table to read.
+	gsw_w32_raw(cdev, BM_RAM_CTRL_REG_OFFSET, ctrlRegData);
+	//Wait untill RAM is ready to read.
+	CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET, BM_RAM_CTRL_BAS_SHIFT,
+		   BM_RAM_CTRL_BAS_SIZE, RETURN_FROM_FUNCTION);
+	gsw_r32_raw(cdev, BM_RAM_VAL_0_VAL0_OFFSET, &data0);
+	gsw_r32_raw(cdev, BM_RAM_VAL_1_VAL1_OFFSET, &data1);
+	parm->nTxPkts = (data1 << 16 | data0);
+	//3.Get PCE-Bypass Tx counters.
+	//Set RAM address to read.
+	addrRegData = addrRegData + 1;
+	gsw_w32_raw(cdev, BM_RAM_ADDR_REG_OFFSET, addrRegData);
+	//Set RAM table to read.
+	gsw_w32_raw(cdev, BM_RAM_CTRL_REG_OFFSET, ctrlRegData);
+	//Wait untill RAM is ready to read.
+	CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET, BM_RAM_CTRL_BAS_SHIFT,
+		   BM_RAM_CTRL_BAS_SIZE, RETURN_FROM_FUNCTION);
+	gsw_r32_raw(cdev, BM_RAM_VAL_0_VAL0_OFFSET, &data2);
+	gsw_r32_raw(cdev, BM_RAM_VAL_1_VAL1_OFFSET, &data3);
+	parm->nTxPceBypassPkts = (data3 << 16 | data2);
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_RmonTflowClear(void *cdev, GSW_RMON_flowGet_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ctrlRegData = 0, addrRegData = 0, tflowIndex = 0;
+	u32 counterMsb = 0, counterLsb = 0;
+	u8 portType, nBits;  //Number of RMON valid bits.
+	GSW_TflowCmodeConf_t cMode;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d\n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	//Given absolute couter index to read.
+	if (parm->bIndex)
+		tflowIndex = parm->nIndex;
+	else {
+		//Compute absolute couter index to read.
+		memset(&cMode, 0, sizeof(GSW_TflowCmodeConf_t));
+		GSW_TflowCountModeGet(cdev, &cMode);
+
+		if (cMode.eCountMode == GSW_TFLOW_CMODE_LOGICAL)
+			nBits = 5;
+		else
+			nBits = (cMode.nBrpLsb | cMode.nCtpLsb); //Only one of is valiad.
+
+		//Is the given port is among configured MSB port group?
+		if ((parm->nPortId >> (9 - nBits)) == cMode.nPortMsb) {
+			//LS (9-nBits) bits of given port become MS bits of counter index to read.
+			counterMsb = ((parm->nPortId) & ((1 << (9 - nBits)) - 1));
+			//LS (nBits) bits of given RMON-Id become LS bits of counter index to read.
+			counterLsb = ((parm->nFlowId) & ((1 << nBits) - 1));
+			//Absolute counter index to read is.
+			tflowIndex = ((counterMsb << nBits) | counterLsb);
+			parm->nIndex = tflowIndex;
+		} else {
+			pr_err("ERR:nPortId's MS %d bits are not matching the group %d\n",
+			       (9 - (nBits - 1)), cMode.nPortMsb);
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	//Validate absolute couter index.
+	if (tflowIndex >= PCE_TABLE_SIZE) { //Max index check.
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	//1.Clear PCE Rx counters.
+	//Populate 'data' register data.
+	portType = GSW_RMON_TFLOW_RX;
+	FILL_CTRL_REG(addrRegData, BM_RAM_ADDR_RMON_PORT_SHIFT, tflowIndex);
+	gsw_w32_raw(cdev, BM_RAM_VAL_0_VAL0_OFFSET, 0);
+	gsw_w32_raw(cdev, BM_RAM_VAL_1_VAL1_OFFSET, 0);
+	//Set RAM address to write.
+	gsw_w32_raw(cdev, BM_RAM_ADDR_REG_OFFSET, addrRegData);
+	//Populate 'control' register data.
+	//RMON TFLOW Rx table to write.
+	FILL_CTRL_REG(ctrlRegData, BM_RAM_CTRL_ADDR_SHIFT, portType);
+	//RAM in write mode.
+	FILL_CTRL_REG(ctrlRegData, BM_RAM_CTRL_OPMOD_SHIFT, 1);
+	//64 bit counter mode.
+	//FILL_CTRL_REG(ctrlRegData, BM_RAM_CTRL_64BIT_OPMOD_SHIFT, 0);
+	//Set access busy bit.
+	FILL_CTRL_REG(ctrlRegData, BM_RAM_CTRL_BAS_SHIFT, 1);
+	//Set RAM table counters to clear.
+	gsw_w32_raw(cdev, BM_RAM_CTRL_REG_OFFSET, ctrlRegData);
+	//Wait untill RAM is ready to write.
+	CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET, BM_RAM_CTRL_BAS_SHIFT,
+		   BM_RAM_CTRL_BAS_SIZE, RETURN_FROM_FUNCTION);
+
+	//2.Clear PCE Tx counters.
+	//Populate 'data' register data.
+	portType = GSW_RMON_TFLOW_TX;
+	//RMON TFLOW Tx table to write.
+	CLEAR_FILL_CTRL_REG(ctrlRegData, BM_RAM_CTRL_ADDR_SHIFT,
+			    BM_RAM_CTRL_ADDR_SIZE, portType);
+	//64 bit counter mode. It is not supported in HW at this moment.
+	//FILL_CTRL_REG(ctrlRegData, BM_RAM_CTRL_64BIT_OPMOD_SHIFT, 1);
+	gsw_w32_raw(cdev, BM_RAM_VAL_0_VAL0_OFFSET, 0);
+	gsw_w32_raw(cdev, BM_RAM_VAL_1_VAL1_OFFSET, 0);
+	//Set RAM address to write.
+	gsw_w32_raw(cdev, BM_RAM_ADDR_REG_OFFSET, addrRegData);
+	//Set RAM table to write.
+	gsw_w32_raw(cdev, BM_RAM_CTRL_REG_OFFSET, ctrlRegData);
+	//Wait untill RAM is ready to write.
+	CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET, BM_RAM_CTRL_BAS_SHIFT,
+		   BM_RAM_CTRL_BAS_SIZE, RETURN_FROM_FUNCTION);
+	//3.Clear PCE-Bypass Tx counters.
+	gsw_w32_raw(cdev, BM_RAM_VAL_0_VAL0_OFFSET, 0);
+	gsw_w32_raw(cdev, BM_RAM_VAL_1_VAL1_OFFSET, 0);
+	//Set RAM address to write.
+	addrRegData = addrRegData + 1;
+	gsw_w32_raw(cdev, BM_RAM_ADDR_REG_OFFSET, addrRegData);
+	//Set RAM table to write.
+	gsw_w32_raw(cdev, BM_RAM_CTRL_REG_OFFSET, ctrlRegData);
+	//Wait untill RAM is ready to write.
+	CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET, BM_RAM_CTRL_BAS_SHIFT,
+		   BM_RAM_CTRL_BAS_SIZE, RETURN_FROM_FUNCTION);
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_TflowCountModeSet(void *cdev, GSW_TflowCmodeConf_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 numValBits = 0, rxTflowReg = 0, txTflowReg = 0, txBpTflowReg = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d\n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	//Validate TFLOW RMON counter type.
+	if (parm->eCountType > GSW_TFLOW_COUNTER_PCE_BP_Tx) {
+		pr_err("ERR:Invalid couter type\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	//Validate TFLOW RMON counter mode type.
+	if (parm->eCountMode > GSW_TFLOW_CMODE_BRIDGE) {
+		pr_err("ERR:Invalid couter mode type\n");
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	//Validate 'n' for CTP or Br port type.
+	if (parm->eCountMode == GSW_TFLOW_CMODE_BRIDGE) {
+		numValBits = parm->nBrpLsb;
+
+		if ((numValBits < GSW_TCM_BRP_VAL_BITS_2) ||
+		    (numValBits > GSW_TCM_BRP_VAL_BITS_6)) {
+			pr_err("ERR:Invalid Br-Port type LSB bits\n");
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	} else if (parm->eCountMode == GSW_TFLOW_CMODE_CTP) {
+		numValBits = parm->nCtpLsb;
+
+		if ((numValBits > GSW_TCM_CTP_VAL_BITS_6)) {
+			pr_err("ERR:Invalid CTP-Port type LSB bits\n");
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+	}
+
+	//Configure registers.
+	switch (parm->eCountMode) {
+	case GSW_TFLOW_CMODE_BRIDGE:
+	case GSW_TFLOW_CMODE_CTP:
+		//1.PCE TFLOW Rx setting.
+		//Populate PCE TFLOW Rx RMON register.
+		//Set 'n' i.e port's LSB bits.
+		FILL_CTRL_REG(rxTflowReg, BM_RXFLOW_RMON_LSB_SHIFT, numValBits);
+		//Set port's MSB bits.
+		FILL_CTRL_REG(rxTflowReg, BM_RXFLOW_RMON_MSB_SHIFT, parm->nPortMsb);
+
+		//2.PCE TFLOW Tx setting.
+		//Populate PCE TFLOW Tx RMON register.
+		//Set 'n' i.e port's LSB bits.
+		FILL_CTRL_REG(txTflowReg, BM_TXFLOW_RMON_LSB_SHIFT, numValBits);
+		//Set port's MSB bits.
+		FILL_CTRL_REG(txTflowReg, BM_TXFLOW_RMON_MSB_SHIFT, parm->nPortMsb);
+
+		//3.PCE-Bypass TFLOW Tx setting.
+		//Populate PCE-Bypass TFLOW Tx RMON register.
+		//Set 'n' i.e port's LSB bits.
+		FILL_CTRL_REG(txBpTflowReg, BM_TXBPFLOW_RMON_LSB_SHIFT, numValBits);
+		//Set port's MSB bits.
+		FILL_CTRL_REG(txBpTflowReg, BM_TXBPFLOW_RMON_MSB_SHIFT, parm->nPortMsb);
+
+	//break; //Fall through to set mode.
+	case GSW_TFLOW_CMODE_LOGICAL:
+		//1.PCE TFLOW Rx setting.
+		//Populate PCE TFLOW Rx RMON register.
+		//Set counter mode.
+		FILL_CTRL_REG(rxTflowReg, BM_RXFLOW_RMON_MD_SHIFT, parm->eCountMode);
+
+		//2.PCE TFLOW Tx setting
+		//Populate PCE TFLOW Tx RMON register.
+		//Set counter mode.
+		FILL_CTRL_REG(txTflowReg, BM_TXFLOW_RMON_MD_SHIFT, parm->eCountMode);
+
+		//3.PCE-Bypass TFLOW Tx setting
+		//Populate PCE-Bypass TFLOW Tx RMON register.
+		//Set counter mode.
+		FILL_CTRL_REG(txBpTflowReg, BM_TXBPFLOW_RMON_MD_SHIFT, parm->eCountMode);
+
+	//break; //Fall through to write into register.
+	case GSW_TFLOW_CMODE_GLOBAL:
+
+		//Write PCE TFLOW Rx RMON register.
+		if ((parm->eCountType == GSW_TFLOW_COUNTER_ALL) ||
+		    (parm->eCountType == GSW_TFLOW_COUNTER_PCE_Rx))
+			gsw_w32_raw(cdev, BM_RXFLOW_RMON_REG_OFFSET, rxTflowReg);
+
+		//Write PCE TFLOW Tx RMON register.
+		if ((parm->eCountType == GSW_TFLOW_COUNTER_ALL) ||
+		    (parm->eCountType == GSW_TFLOW_COUNTER_PCE_Tx))
+			gsw_w32_raw(cdev, BM_TXFLOW_RMON_REG_OFFSET, txTflowReg);
+
+		//Write PCE-Bypass TFLOW Tx RMON register.
+		if ((parm->eCountType == GSW_TFLOW_COUNTER_ALL) ||
+		    (parm->eCountType == GSW_TFLOW_COUNTER_PCE_BP_Tx))
+			gsw_w32_raw(cdev, BM_TXBPFLOW_RMON_REG_OFFSET, txBpTflowReg);
+
+		break;
+
+	default:
+		break;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_TflowCountModeGet(void *cdev, GSW_TflowCmodeConf_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 rxTflowReg = 0, txTflowReg = 0, txBpTflowReg = 0;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d\n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_bm);
+#endif
+
+	switch (parm->eCountType) {
+	case GSW_TFLOW_COUNTER_ALL:
+	case GSW_TFLOW_COUNTER_PCE_Rx:
+		//1.PCE TFLOW Rx config.
+		//Read PCE TFLOW Rx RMON register.
+		gsw_r32_raw(cdev, BM_RXFLOW_RMON_REG_OFFSET, &rxTflowReg);
+		//Populate PCE TFLOW Rx RMON structure.
+		//Get counter mode.
+		GET_VAL_FROM_REG(parm->eCountMode, BM_RXFLOW_RMON_MD_SHIFT, BM_RXFLOW_RMON_MD_SIZE, rxTflowReg);
+
+		//Get port's LSB bits.
+		if (parm->eCountMode == GSW_TFLOW_CMODE_BRIDGE)
+			GET_VAL_FROM_REG(parm->nBrpLsb, BM_RXFLOW_RMON_LSB_SHIFT, BM_RXFLOW_RMON_LSB_SIZE, rxTflowReg);
+
+		if (parm->eCountMode == GSW_TFLOW_CMODE_CTP)
+			GET_VAL_FROM_REG(parm->nCtpLsb, BM_RXFLOW_RMON_LSB_SHIFT, BM_RXFLOW_RMON_LSB_SIZE, rxTflowReg);
+
+		//Get port's MSB bits.
+		GET_VAL_FROM_REG(parm->nPortMsb, BM_RXFLOW_RMON_MSB_SHIFT, BM_RXFLOW_RMON_MSB_SIZE, rxTflowReg);
+		break;
+
+	case GSW_TFLOW_COUNTER_PCE_Tx:
+		//2.PCE TFLOW Tx config
+		//Read PCE TFLOW Tx RMON register.
+		gsw_r32_raw(cdev, BM_TXFLOW_RMON_REG_OFFSET, &txTflowReg);
+		//Populate PCE TFLOW Tx RMON structure.
+		//Get counter mode.
+		GET_VAL_FROM_REG(parm->eCountMode, BM_TXFLOW_RMON_MD_SHIFT, BM_TXFLOW_RMON_MD_SIZE, txTflowReg);
+
+		//Get port's LSB bits.
+		if (parm->eCountMode == GSW_TFLOW_CMODE_BRIDGE)
+			GET_VAL_FROM_REG(parm->nBrpLsb, BM_TXFLOW_RMON_LSB_SHIFT, BM_TXFLOW_RMON_LSB_SIZE, txTflowReg);
+
+		if (parm->eCountMode == GSW_TFLOW_CMODE_CTP)
+			GET_VAL_FROM_REG(parm->nCtpLsb, BM_TXFLOW_RMON_LSB_SHIFT, BM_TXFLOW_RMON_LSB_SIZE, txTflowReg);
+
+		//Get port's MSB bits.
+		GET_VAL_FROM_REG(parm->nPortMsb, BM_TXFLOW_RMON_MSB_SHIFT, BM_TXFLOW_RMON_MSB_SIZE, txTflowReg);
+		break;
+
+	case GSW_TFLOW_COUNTER_PCE_BP_Tx:
+		//3.PCE-Bypass TFLOW Tx config
+		//Write PCE-Bypass TFLOW Tx RMON register.
+		gsw_r32_raw(cdev, BM_TXBPFLOW_RMON_REG_OFFSET, &txBpTflowReg);
+		//Populate PCE-Bypass TFLOW Tx RMON structure.
+		//Get port's LSB bits.
+		GET_VAL_FROM_REG(parm->eCountMode, BM_TXBPFLOW_RMON_MD_SHIFT, BM_TXBPFLOW_RMON_MD_SIZE, txBpTflowReg);
+
+		//Get port's LSB bits.
+		if (parm->eCountMode == GSW_TFLOW_CMODE_BRIDGE)
+			GET_VAL_FROM_REG(parm->nBrpLsb, BM_TXBPFLOW_RMON_LSB_SHIFT, BM_TXBPFLOW_RMON_LSB_SIZE, txBpTflowReg);
+
+		if (parm->eCountMode == GSW_TFLOW_CMODE_CTP)
+			GET_VAL_FROM_REG(parm->nCtpLsb, BM_TXBPFLOW_RMON_LSB_SHIFT, BM_TXBPFLOW_RMON_LSB_SIZE, txBpTflowReg);
+
+		//Get port's MSB bits.
+		GET_VAL_FROM_REG(parm->nPortMsb, BM_TXBPFLOW_RMON_MSB_SHIFT, BM_TXBPFLOW_RMON_MSB_SIZE, txBpTflowReg);
+		break;
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_bm);
+#endif
+	return ret;
+}
+
+GSW_return_t GSW_Reset(void *cdev, GSW_reset_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 value;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	gswdev->rst = 1;
+	gswdev->hwinit = 0;
+	/* Reset the Switch via Switch IP register*/
+	value = 1;
+	gsw_w32(cdev, ETHSW_SWRES_R0_OFFSET,
+		ETHSW_SWRES_R0_SHIFT, ETHSW_SWRES_R0_SIZE, value);
+	ret = CHECK_BUSY(ETHSW_SWRES_R0_OFFSET, ETHSW_SWRES_R0_SHIFT,
+			 ETHSW_SWRES_R0_SIZE, RETURN_ERROR_CODE);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+	return ret;
+
+}
+
+GSW_return_t GSW_VersionGet(void *cdev, GSW_version_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	if (parm->nId == 0) {
+		memcpy(parm->cName, VERSION_NAME, sizeof(VERSION_NAME));
+		memcpy(parm->cVersion, VERSION_NUMBER, sizeof(VERSION_NUMBER));
+	} else if (parm->nId == 1) {
+		memcpy(parm->cName, MICRO_CODE_VERSION_NAME,
+		       sizeof(MICRO_CODE_VERSION_NAME));
+		memcpy(parm->cVersion, MICRO_CODE_VERSION_NUMBER,
+		       sizeof(MICRO_CODE_VERSION_NUMBER));
+	} else {
+		memcpy(parm->cName, "", 0);
+		memcpy(parm->cVersion, "", 0);
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+
+	return ret;
+
+}
+
+static GSW_return_t GSW_Enable_Legacy(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 j;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return  GSW_statusErr;
+	}
+
+
+#if defined(CONFIG_USE_EMULATOR) && defined(__KERNEL__)
+
+	for (j = 0; j < gswdev->tpnum; j++) {
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			gsw_w32(cdev,
+				(MAC_CTRL_0_FDUP_OFFSET + (0xC * j)),
+				MAC_CTRL_0_FDUP_SHIFT, MAC_CTRL_0_FDUP_SIZE, 1);
+			gsw_w32(cdev,
+				(MAC_CTRL_0_GMII_OFFSET + (0xC * j)),
+				MAC_CTRL_0_GMII_SHIFT, MAC_CTRL_0_GMII_SIZE, 2);
+			gsw_w32(cdev,
+				((GSWT_PHY_ADDR_1_SPEED_OFFSET
+				  + (j * 4)) + GSW30_TOP_OFFSET),
+				GSWT_PHY_ADDR_1_SPEED_SHIFT,
+				GSWT_PHY_ADDR_1_SPEED_SIZE, 2);
+			gsw_w32(cdev,
+				((GSWT_PHY_ADDR_1_FDUP_OFFSET
+				  + (j * 4)) + GSW30_TOP_OFFSET),
+				GSWT_PHY_ADDR_1_FDUP_SHIFT,
+				GSWT_PHY_ADDR_1_FDUP_SIZE, 1);
+			gsw_w32(cdev,
+				((GSWT_PHY_ADDR_1_LNKST_OFFSET
+				  + (j * 4)) + GSW30_TOP_OFFSET),
+				GSWT_PHY_ADDR_1_LNKST_SHIFT,
+				GSWT_PHY_ADDR_1_LNKST_SIZE, 1);
+		} else {
+			gsw_w32(cdev,
+				((PHY_ADDR_0_SPEED_OFFSET - j)
+				 + GSW_TREG_OFFSET),
+				PHY_ADDR_0_SPEED_SHIFT,
+				PHY_ADDR_0_SPEED_SIZE, 2);
+			gsw_w32(cdev,
+				((PHY_ADDR_0_FDUP_OFFSET - j)
+				 + GSW_TREG_OFFSET),
+				PHY_ADDR_0_FDUP_SHIFT,
+				PHY_ADDR_0_FDUP_SIZE, 1);
+			gsw_w32(cdev,
+				((PHY_ADDR_0_LNKST_OFFSET - j)
+				 + GSW_TREG_OFFSET),
+				PHY_ADDR_0_LNKST_SHIFT,
+				PHY_ADDR_0_LNKST_SIZE, 1);
+		}
+	}
+
+#endif
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		for (j = 0; j < gswdev->tpnum; j++) {
+			gsw_w32(cdev, (BM_PCFG_CNTEN_OFFSET + (j * 2)),
+				BM_PCFG_CNTEN_SHIFT, BM_PCFG_CNTEN_SIZE, 1);
+			gsw_w32(cdev, (BM_RMON_CTRL_BCAST_CNT_OFFSET + (j * 0x2)),
+				BM_RMON_CTRL_BCAST_CNT_SHIFT, BM_RMON_CTRL_BCAST_CNT_SIZE, 1);
+		}
+
+		if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+			gsw_w32(cdev, PCE_TFCR_NUM_NUM_OFFSET,
+				PCE_TFCR_NUM_NUM_SHIFT,
+				PCE_TFCR_NUM_NUM_SIZE, 0x80);
+		}
+	}
+
+	return GSW_statusOk;
+
+}
+
+GSW_return_t GSW_Enable(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 j;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	for (j = 0; j < gswdev->tpnum; j++) {
+		gsw_w32(cdev,
+			(FDMA_PCTRL_EN_OFFSET + (j * 0x6)),
+			FDMA_PCTRL_EN_SHIFT,
+			FDMA_PCTRL_EN_SIZE, 1);
+		gsw_w32(cdev,
+			(SDMA_PCTRL_PEN_OFFSET + (j * 0x6)),
+			SDMA_PCTRL_PEN_SHIFT,
+			SDMA_PCTRL_PEN_SIZE, 1);
+		/*Enable All RMON Counters*/
+		gsw_w32(cdev,
+			(BM_PCFG_CNTEN_OFFSET + (j * 2)),
+			BM_PCFG_CNTEN_SHIFT,
+			BM_PCFG_CNTEN_SIZE, 1);
+	}
+
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		GSW_Enable_Legacy(cdev);
+	}
+
+#if defined(CONFIG_MAC) && CONFIG_MAC
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+		struct adap_ops *ops = get_adap_ops(gswdev);
+		if (ops == NULL) {
+			pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+		ops->ss_core_en(ops, 1);
+	}
+
+#endif
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+
+	return ret;
+
+}
+
+GSW_return_t GSW_Disable(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u8 j;
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_misc);
+#endif
+
+	/* Disable all physical port  */
+	for (j = 0; j < gswdev->tpnum; j++) {
+		gsw_w32(cdev, (FDMA_PCTRL_EN_OFFSET + (j * 0x6)),
+			FDMA_PCTRL_EN_SHIFT, FDMA_PCTRL_EN_SIZE, 0);
+		gsw_w32(cdev, (SDMA_PCTRL_PEN_OFFSET + (j * 0x6)),
+			SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE, 0);
+	}
+
+	ret = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_misc);
+#endif
+
+	return ret;
+}
+
+/* Freeze switch Ingress traffic */
+GSW_return_t GSW_Freeze(void)
+{
+	struct adap_ops *ops = gsw_get_adap_ops(0);
+
+	if (ops == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	ops->ss_core_en(ops, 0);
+
+	return 0;
+}
+
+/* UnFreeze switch Ingress traffic */
+GSW_return_t GSW_UnFreeze(void)
+{
+	struct adap_ops *ops = gsw_get_adap_ops(0);
+
+	if (ops == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	ops->ss_core_en(ops, 1);
+
+	return 0;
+}
+static GSW_return_t gsw_init_fn_ptrs(struct core_ops *ops)
+{
+
+	/*Switch Operations*/
+	/*RMON operation*/
+	ops->gsw_rmon_ops.RMON_Port_Get 				= GSW_RMON_Port_Get;
+	ops->gsw_rmon_ops.RMON_Mode_Set					= GSW_RMON_Mode_Set;
+	ops->gsw_rmon_ops.RMON_Meter_Get				= GSW_RMON_Meter_Get;
+	ops->gsw_rmon_ops.RMON_Redirect_Get				= GSW_RMON_Redirect_Get;
+	ops->gsw_rmon_ops.RMON_If_Get					= GSW_RMON_If_Get;
+	ops->gsw_rmon_ops.RMON_Route_Get				= GSW_RMON_Route_Get;
+	ops->gsw_rmon_ops.RMON_Clear					= GSW_RMON_Clear;
+	ops->gsw_rmon_ops.RMON_ExtendGet				= GSW_RMON_ExtendGet;
+	ops->gsw_rmon_ops.RMON_TflowGet					= GSW_RMON_FlowGet;
+	ops->gsw_rmon_ops.RMON_TflowClear				= GSW_RmonTflowClear;
+	ops->gsw_rmon_ops.RMON_TflowCountModeSet		= GSW_TflowCountModeSet;
+	ops->gsw_rmon_ops.RMON_TflowCountModeGet		= GSW_TflowCountModeGet;
+
+	/*Switch MAc operations*/
+	ops->gsw_swmac_ops.MAC_TableClear 				= GSW_MAC_TableClear;
+	ops->gsw_swmac_ops.MAC_TableEntryAdd 			= GSW_MAC_TableEntryAdd;
+	ops->gsw_swmac_ops.MAC_TableEntryRead 			= GSW_MAC_TableEntryRead;
+	ops->gsw_swmac_ops.MAC_TableEntryQuery 			= GSW_MAC_TableEntryQuery;
+	ops->gsw_swmac_ops.MAC_TableEntryRemove 		= GSW_MAC_TableEntryRemove;
+	ops->gsw_swmac_ops.MAC_DefaultFilterSet 		= GSW_DefaultMacFilterSet;
+	ops->gsw_swmac_ops.MAC_DefaultFilterGet 		= GSW_DefaultMacFilterGet;
+
+	/*Extended Vlan operations*/
+	ops->gsw_extvlan_ops.ExtendedVlan_Alloc 		= GSW_ExtendedVlanAlloc;
+	ops->gsw_extvlan_ops.ExtendedVlan_Set 			= GSW_ExtendedVlanSet;
+	ops->gsw_extvlan_ops.ExtendedVlan_Get 			= GSW_ExtendedVlanGet;
+	ops->gsw_extvlan_ops.ExtendedVlan_Free 			= GSW_ExtendedVlanFree;
+
+	/*Vlan Filter operations*/
+	ops->gsw_vlanfilter_ops.VlanFilter_Alloc 		= GSW_VlanFilterAlloc;
+	ops->gsw_vlanfilter_ops.VlanFilter_Set 			= GSW_VlanFilterSet;
+	ops->gsw_vlanfilter_ops.VlanFilter_Get 			= GSW_VlanFilterGet;
+	ops->gsw_vlanfilter_ops.VlanFilter_Free 		= GSW_VlanFilterFree;
+
+	/*CTP operations*/
+	ops->gsw_ctp_ops.CTP_PortAssignmentAlloc		= GSW_CTP_PortAssignmentAlloc;
+	ops->gsw_ctp_ops.CTP_PortAssignmentFree 		= GSW_CTP_PortAssignmentFree;
+	ops->gsw_ctp_ops.CTP_PortAssignmentSet 			= GSW_CTP_PortAssignmentSet;
+	ops->gsw_ctp_ops.CTP_PortAssignmentGet 			= GSW_CTP_PortAssignmentGet;
+	ops->gsw_ctp_ops.CTP_PortConfigSet 				= GSW_CtpPortConfigSet;
+	ops->gsw_ctp_ops.CTP_PortConfigGet 				= GSW_CtpPortConfigGet;
+	ops->gsw_ctp_ops.CTP_PortConfigReset 			= GSW_CtpPortConfigReset;
+
+	/*Bridge Port operations*/
+	ops->gsw_brdgport_ops.BridgePort_Alloc			= GSW_BridgePortAlloc;
+	ops->gsw_brdgport_ops.BridgePort_ConfigSet		= GSW_BridgePortConfigSet;
+	ops->gsw_brdgport_ops.BridgePort_ConfigGet		= GSW_BridgePortConfigGet;
+	ops->gsw_brdgport_ops.BridgePort_Free			= GSW_BridgePortFree;
+
+	/*Bridge Operations*/
+	ops->gsw_brdg_ops.Bridge_Alloc					= GSW_BridgeAlloc;
+	ops->gsw_brdg_ops.Bridge_ConfigSet				= GSW_BridgeConfigSet;
+	ops->gsw_brdg_ops.Bridge_ConfigGet				= GSW_BridgeConfigGet;
+	ops->gsw_brdg_ops.Bridge_Free					= GSW_BridgeFree;
+
+	/*TFlow operations*/
+	ops->gsw_tflow_ops.TFLOW_PceRuleDelete			= GSW_PceRuleDelete;
+	ops->gsw_tflow_ops.TFLOW_PceRuleRead			= GSW_PceRuleRead;
+	ops->gsw_tflow_ops.TFLOW_PceRuleWrite			= GSW_PceRuleWrite;
+
+	/*QOS operations*/
+	ops->gsw_qos_ops.QoS_MeterCfgGet				= GSW_QoS_MeterCfgGet;
+	ops->gsw_qos_ops.QoS_MeterCfgSet				= GSW_QoS_MeterCfgSet;
+	ops->gsw_qos_ops.QoS_MeterPortAssign			= GSW_QoS_MeterPortAssign;
+	ops->gsw_qos_ops.QoS_MeterPortDeassign			= GSW_QoS_MeterPortDeassign;
+	ops->gsw_qos_ops.QoS_MeterPortGet				= GSW_QoS_MeterPortGet;
+	ops->gsw_qos_ops.QoS_DSCP_ClassGet				= GSW_QoS_DSCP_ClassGet;
+	ops->gsw_qos_ops.QoS_DSCP_ClassSet				= GSW_QoS_DSCP_ClassSet;
+	ops->gsw_qos_ops.QoS_ClassDSCP_Get				= GSW_QoS_ClassDSCP_Get;
+	ops->gsw_qos_ops.QoS_ClassDSCP_Set				= GSW_QoS_ClassDSCP_Set;
+	ops->gsw_qos_ops.QoS_DSCP_DropPrecedenceCfgGet	= GSW_QoS_DSCP_DropPrecedenceCfgGet;
+	ops->gsw_qos_ops.QoS_DSCP_DropPrecedenceCfgSet	= GSW_QoS_DSCP_DropPrecedenceCfgSet;
+	ops->gsw_qos_ops.QoS_PortRemarkingCfgGet		= GSW_QoS_PortRemarkingCfgGet;
+	ops->gsw_qos_ops.QoS_PortRemarkingCfgSet		= GSW_QoS_PortRemarkingCfgSet;
+	ops->gsw_qos_ops.QoS_ClassPCP_Get				= GSW_QoS_ClassPCP_Get;
+	ops->gsw_qos_ops.QoS_ClassPCP_Set				= GSW_QoS_ClassPCP_Set;
+	ops->gsw_qos_ops.QoS_PCP_ClassGet				= GSW_QoS_PCP_ClassGet;
+	ops->gsw_qos_ops.QoS_PCP_ClassSet				= GSW_QoS_PCP_ClassSet;
+	ops->gsw_qos_ops.QoS_PortCfgGet					= GSW_QoS_PortCfgGet;
+	ops->gsw_qos_ops.QoS_PortCfgSet					= GSW_QoS_PortCfgSet;
+	ops->gsw_qos_ops.QoS_QueuePortGet				= GSW_QoS_QueuePortGet;
+	ops->gsw_qos_ops.QoS_QueuePortSet				= GSW_QoS_QueuePortSet;
+	ops->gsw_qos_ops.QoS_SchedulerCfgGet			= GSW_QoS_SchedulerCfgGet;
+	ops->gsw_qos_ops.QoS_SchedulerCfgSet			= GSW_QoS_SchedulerCfgSet;
+	ops->gsw_qos_ops.QoS_ShaperCfgGet				= GSW_QoS_ShaperCfgGet;
+	ops->gsw_qos_ops.QoS_ShaperCfgSet				= GSW_QoS_ShaperCfgSet;
+	ops->gsw_qos_ops.QoS_ShaperQueueAssign			= GSW_QoS_ShaperQueueAssign;
+	ops->gsw_qos_ops.QoS_ShaperQueueDeassign		= GSW_QoS_ShaperQueueDeassign;
+	ops->gsw_qos_ops.QoS_ShaperQueueGet				= GSW_QoS_ShaperQueueGet;
+	ops->gsw_qos_ops.QoS_StormCfgSet				= GSW_QoS_StormCfgSet;
+	ops->gsw_qos_ops.QoS_StormCfgGet				= GSW_QoS_StormCfgGet;
+	ops->gsw_qos_ops.QoS_WredCfgGet					= GSW_QoS_WredCfgGet;
+	ops->gsw_qos_ops.QoS_WredCfgSet					= GSW_QoS_WredCfgSet;
+	ops->gsw_qos_ops.QoS_WredQueueCfgGet			= GSW_QoS_WredQueueCfgGet;
+	ops->gsw_qos_ops.QoS_WredQueueCfgSet			= GSW_QoS_WredQueueCfgSet;
+	ops->gsw_qos_ops.QoS_WredPortCfgGet				= GSW_QoS_WredPortCfgGet;
+	ops->gsw_qos_ops.QoS_WredPortCfgSet				= GSW_QoS_WredPortCfgSet;
+	ops->gsw_qos_ops.QoS_FlowctrlCfgGet				= GSW_QoS_FlowctrlCfgGet;
+	ops->gsw_qos_ops.QoS_FlowctrlCfgSet				= GSW_QoS_FlowctrlCfgSet;
+	ops->gsw_qos_ops.QoS_FlowctrlPortCfgGet			= GSW_QoS_FlowctrlPortCfgGet;
+	ops->gsw_qos_ops.QoS_FlowctrlPortCfgSet			= GSW_QoS_FlowctrlPortCfgSet;
+	ops->gsw_qos_ops.QoS_QueueBufferReserveCfgGet	= GSW_QoS_QueueBufferReserveCfgGet;
+	ops->gsw_qos_ops.QoS_QueueBufferReserveCfgSet	= GSW_QoS_QueueBufferReserveCfgSet;
+	ops->gsw_qos_ops.QoS_Meter_Act					= GSW_QoS_Meter_Act;
+	ops->gsw_qos_ops.QOS_ColorMarkingTableGet		= GSW_QOS_ColorMarkingTableSet;
+	ops->gsw_qos_ops.QOS_ColorMarkingTableSet		= GSW_QOS_ColorMarkingTableGet;
+	ops->gsw_qos_ops.QOS_ColorReMarkingTableSet		= GSW_QOS_ColorReMarkingTableSet;
+	ops->gsw_qos_ops.QOS_ColorReMarkingTableGet		= GSW_QOS_ColorReMarkingTableGet;
+	ops->gsw_qos_ops.QOS_MeterAlloc					= GSW_QOS_MeterAlloc;
+	ops->gsw_qos_ops.QOS_MeterFree					= GSW_QOS_MeterFree;
+	ops->gsw_qos_ops.QOS_Dscp2PcpTableSet			= GSW_QOS_Dscp2PcpTableSet;
+	ops->gsw_qos_ops.QOS_Dscp2PcpTableGet			= GSW_QOS_Dscp2PcpTableGet;
+	ops->gsw_qos_ops.QOS_PmapperTableSet			= GSW_QOS_PmapperTableSet;
+	ops->gsw_qos_ops.QOS_PmapperTableGet			= GSW_QOS_PmapperTableGet;
+	ops->gsw_qos_ops.QoS_SVLAN_ClassPCP_PortGet		= GSW_QoS_SVLAN_ClassPCP_PortGet;
+	ops->gsw_qos_ops.QoS_SVLAN_ClassPCP_PortSet		= GSW_QoS_SVLAN_ClassPCP_PortSet;
+	ops->gsw_qos_ops.QoS_SVLAN_PCP_ClassGet			= GSW_QoS_SVLAN_PCP_ClassGet;
+	ops->gsw_qos_ops.QoS_SVLAN_PCP_ClassSet			= GSW_QoS_SVLAN_PCP_ClassSet;
+
+	/*STP operations*/
+	ops->gsw_stp_ops.STP_BPDU_RuleGet				= GSW_STP_BPDU_RuleGet;
+	ops->gsw_stp_ops.STP_BPDU_RuleSet				= GSW_STP_BPDU_RuleSet;
+	ops->gsw_stp_ops.STP_PortCfgGet					= GSW_STP_PortCfgGet;
+	ops->gsw_stp_ops.STP_PortCfgSet					= GSW_STP_PortCfgSet;
+
+	/*8021x operations*/
+	ops->gsw_8021x_ops.EAPOL_RuleGet				= GSW_8021X_EAPOL_RuleGet;
+	ops->gsw_8021x_ops.EAPOL_RuleGet_RuleSet		= GSW_8021X_EAPOL_RuleSet;
+	ops->gsw_8021x_ops.EAPOL_RuleGet_PortCfgGet		= GSW_8021X_PortCfgGet;
+	ops->gsw_8021x_ops.EAPOL_RuleGet_PortCfgSet		= GSW_8021X_PortCfgSet;
+
+	/*multicast operations*/
+	ops->gsw_multicast_ops.Multicast_RouterPortAdd	= GSW_MulticastRouterPortAdd;
+	ops->gsw_multicast_ops.Multicast_RouterPortRead	= GSW_MulticastRouterPortRead;
+	ops->gsw_multicast_ops.Multicast_RouterPortRemove = GSW_MulticastRouterPortRemove;
+	ops->gsw_multicast_ops.Multicast_SnoopCfgGet	= GSW_MulticastSnoopCfgGet;
+	ops->gsw_multicast_ops.Multicast_SnoopCfgSet	= GSW_MulticastSnoopCfgSet;
+	ops->gsw_multicast_ops.Multicast_TableEntryAdd	= GSW_MulticastTableEntryAdd;
+	ops->gsw_multicast_ops.Multicast_TableEntryRead	= GSW_MulticastTableEntryRead;
+	ops->gsw_multicast_ops.Multicast_TableEntryRemove = GSW_MulticastTableEntryRemove;
+
+	/*Trunking operations*/
+	ops->gsw_trunking_ops.Trunking_CfgGet			= GSW_TrunkingCfgGet;
+	ops->gsw_trunking_ops.Trunking_CfgSet			= GSW_TrunkingCfgSet;
+	ops->gsw_trunking_ops.Trunking_PortCfgGet		= GSW_TrunkingPortCfgGet;
+	ops->gsw_trunking_ops.Trunking_PortCfgSet		= GSW_TrunkingPortCfgSet;
+
+	/*WOL operations*/
+	ops->gsw_wol_ops.WoL_CfgGet						= GSW_WoL_CfgGet;
+	ops->gsw_wol_ops.WoL_CfgSet						= GSW_WoL_CfgSet;
+	ops->gsw_wol_ops.WoL_PortCfgGet					= GSW_WoL_PortCfgGet;
+	ops->gsw_wol_ops.WoL_PortCfgSet					= GSW_WoL_PortCfgSet;
+
+	/*Common switch operations*/
+	ops->gsw_common_ops.RegisterGet					= GSW_RegisterGet;
+	ops->gsw_common_ops.RegisterSet					= GSW_RegisterSet;
+	ops->gsw_common_ops.IrqGet						= GSW_IrqGet;
+	ops->gsw_common_ops.IrqMaskGet					= GSW_IrqMaskGet;
+	ops->gsw_common_ops.IrqMaskSet					= GSW_IrqMaskSet;
+	ops->gsw_common_ops.IrqStatusClear				= GSW_IrqStatusClear;
+	ops->gsw_common_ops.Enable						= GSW_Enable;
+	ops->gsw_common_ops.Reset						= GSW_Reset;
+	ops->gsw_common_ops.Disable						= GSW_Disable;
+	ops->gsw_common_ops.VersionGet					= GSW_VersionGet;
+	ops->gsw_common_ops.CapGet						= GSW_CapGet;
+	ops->gsw_common_ops.CfgGet						= GSW_CfgGet;
+	ops->gsw_common_ops.CfgSet						= GSW_CfgSet;
+	ops->gsw_common_ops.HW_Init						= GSW_HW_Init;
+	ops->gsw_common_ops.PortLinkCfgGet				= GSW_PortLinkCfgGet;
+	ops->gsw_common_ops.PortLinkCfgSet				= GSW_PortLinkCfgSet;
+	ops->gsw_common_ops.PortPHY_AddrGet				= GSW_PortPHY_AddrGet;
+	ops->gsw_common_ops.PortPHY_Query				= GSW_PortPHY_Query;
+	ops->gsw_common_ops.PortRGMII_ClkCfgGet			= GSW_PortRGMII_ClkCfgGet;
+	ops->gsw_common_ops.PortRGMII_ClkCfgSet			= GSW_PortRGMII_ClkCfgSet;
+	ops->gsw_common_ops.PortRedirectGet				= GSW_PortRedirectGet;
+	ops->gsw_common_ops.PortRedirectSet				= GSW_PortRedirectSet;
+	ops->gsw_common_ops.CPU_PortCfgGet				= GSW_CPU_PortCfgGet;
+	ops->gsw_common_ops.CPU_PortCfgSet				= GSW_CPU_PortCfgSet;
+	ops->gsw_common_ops.CPU_PortExtendCfgGet		= GSW_CPU_PortExtendCfgGet;
+	ops->gsw_common_ops.CPU_PortExtendCfgSet		= GSW_CPU_PortExtendCfgSet;
+	ops->gsw_common_ops.MonitorPortCfgGet			= GSW_MonitorPortCfgGet;
+	ops->gsw_common_ops.MonitorPortCfgSet			= GSW_MonitorPortCfgSet;
+	ops->gsw_common_ops.Timestamp_TimerSet			= GSW_TimestampTimerSet;
+	ops->gsw_common_ops.Timestamp_TimerGet			= GSW_TimestampTimerGet;
+	ops->gsw_common_ops.Timestamp_PortRead			= GSW_TimestampPortRead;
+	ops->gsw_common_ops.PortCfgGet					= GSW_PortCfgGet;
+	ops->gsw_common_ops.PortCfgSet					= GSW_PortCfgSet;
+	ops->gsw_common_ops.MDIO_CfgGet					= GSW_MDIO_CfgGet;
+	ops->gsw_common_ops.MDIO_CfgSet					= GSW_MDIO_CfgSet;
+	ops->gsw_common_ops.MDIO_DataRead				= GSW_MDIO_DataRead;
+	ops->gsw_common_ops.MDIO_DataWrite				= GSW_MDIO_DataWrite;
+	ops->gsw_common_ops.MmdDataRead					= GSW_MmdDataRead;
+	ops->gsw_common_ops.MmdDataWrite				= GSW_MmdDataWrite;
+
+
+	/*PMAC operations*/
+	ops->gsw_pmac_ops.Pmac_CountGet					= GSW_PMAC_CountGet;
+	ops->gsw_pmac_ops.Pmac_Gbl_CfgSet				= GSW_PMAC_GLBL_CfgSet;
+	ops->gsw_pmac_ops.Pmac_Gbl_CfgGet				= GSW_PMAC_GLBL_CfgGet;
+	ops->gsw_pmac_ops.Pmac_Bm_CfgSet				= GSW_PMAC_BM_CfgSet;
+	ops->gsw_pmac_ops.Pmac_Bm_CfgGet				= GSW_PMAC_BM_CfgGet;
+	ops->gsw_pmac_ops.Pmac_Ig_CfgSet				= GSW_PMAC_IG_CfgSet;
+	ops->gsw_pmac_ops.Pmac_Ig_CfgGet				= GSW_PMAC_IG_CfgGet;
+	ops->gsw_pmac_ops.Pmac_Eg_CfgSet				= GSW_PMAC_EG_CfgSet;
+	ops->gsw_pmac_ops.Pmac_Eg_CfgGet				= GSW_PMAC_EG_CfgGet;
+
+	/*VLAN operation*/
+	ops->gsw_vlan_ops.VLAN_Member_Init				= GSW_VLAN_Member_Init;
+	ops->gsw_vlan_ops.VLAN_IdCreate					= GSW_VLAN_IdCreate;
+	ops->gsw_vlan_ops.VLAN_IdDelete					= GSW_VLAN_IdDelete;
+	ops->gsw_vlan_ops.VLAN_IdGet					= GSW_VLAN_IdGet;
+	ops->gsw_vlan_ops.VLAN_PortCfgGet				= GSW_VLAN_PortCfgGet;
+	ops->gsw_vlan_ops.VLAN_PortCfgSet				= GSW_VLAN_PortCfgSet;
+	ops->gsw_vlan_ops.VLAN_PortMemberAdd			= GSW_VLAN_PortMemberAdd;
+	ops->gsw_vlan_ops.VLAN_PortMemberRead			= GSW_VLAN_PortMemberRead;
+	ops->gsw_vlan_ops.VLAN_PortMemberRemove			= GSW_VLAN_PortMemberRemove;
+	ops->gsw_vlan_ops.VLAN_ReservedAdd				= GSW_VLAN_ReservedAdd;
+	ops->gsw_vlan_ops.VLAN_ReservedRemove			= GSW_VLAN_ReservedRemove;
+	ops->gsw_vlan_ops.VLAN_PCE_EG_CfgSet			= GSW_PCE_EG_VLAN_CfgSet;
+	ops->gsw_vlan_ops.VLAN_PCE_EG_CfgGet			= GSW_PCE_EG_VLAN_CfgGet;
+	ops->gsw_vlan_ops.VLAN_PCE_EG_EntryWrite		= GSW_PCE_EG_VLAN_EntryWrite;
+	ops->gsw_vlan_ops.VLAN_PCE_EG_EntryRead			= GSW_PCE_EG_VLAN_EntryRead;
+	ops->gsw_vlan_ops.SVLAN_CfgGet					= GSW_SVLAN_CfgGet;
+	ops->gsw_vlan_ops.SVLAN_CfgSet					= GSW_SVLAN_CfgSet;
+	ops->gsw_vlan_ops.SVLAN_PortCfgGet				= GSW_SVLAN_PortCfgGet;
+	ops->gsw_vlan_ops.SVLAN_PortCfgSet				= GSW_SVLAN_PortCfgSet;
+
+#ifdef __KERNEL__
+	/*PAE operation*/
+	ops->gsw_pae_ops.ROUTE_SessionEntryAdd			= GSW_ROUTE_SessionEntryAdd;
+	ops->gsw_pae_ops.ROUTE_SessionEntryDel			= GSW_ROUTE_SessionEntryDel;
+	ops->gsw_pae_ops.ROUTE_SessionEntryRead			= GSW_ROUTE_SessionEntryRead;
+	ops->gsw_pae_ops.ROUTE_TunnelEntryAdd			= GSW_ROUTE_TunnelEntryAdd;
+	ops->gsw_pae_ops.ROUTE_TunnelEntryRead			= GSW_ROUTE_TunnelEntryRead;
+	ops->gsw_pae_ops.ROUTE_TunnelEntryDel			= GSW_ROUTE_TunnelEntryDel;
+	ops->gsw_pae_ops.ROUTE_L2NATCfgWrite			= GSW_ROUTE_L2NATCfgWrite;
+	ops->gsw_pae_ops.ROUTE_L2NATCfgRead				= GSW_ROUTE_L2NATCfgRead;
+	ops->gsw_pae_ops.ROUTE_SessHitOp				= GSW_ROUTE_SessHitOp;
+	ops->gsw_pae_ops.ROUTE_SessDestModify			= GSW_ROUTE_SessDestModify;
+#endif
+
+	/*Debug operation*/
+	ops->gsw_debug_ops.DEBUG_CtpTableStatus			= GSW_Debug_CtpTableStatus;
+	ops->gsw_debug_ops.DEBUG_BrgPortTableStatus		= GSW_Debug_BrgPortTableStatus;
+	ops->gsw_debug_ops.DEBUG_BrgTableStatus			= GSW_Debug_BrgTableStatus;
+	ops->gsw_debug_ops.DEBUG_ExvlanTableStatus		= GSW_Debug_ExvlanTableStatus;
+	ops->gsw_debug_ops.DEBUG_VlanFilterTableStatus	= GSW_Debug_VlanFilterTableStatus;
+	ops->gsw_debug_ops.DEBUG_MeterTableStatus		= GSW_Debug_MeterTableStatus;
+	ops->gsw_debug_ops.DEBUG_Dscp2PcpTableStatus	= GSW_Debug_Dscp2PcpTableStatus;
+	ops->gsw_debug_ops.DEBUG_PmapperTableStatus		= GSW_Debug_PmapperTableStatus;
+	ops->gsw_debug_ops.DEBUG_PmacEg					= GSW_Debug_PmacEgTable;
+	ops->gsw_debug_ops.DEBUG_PmacIg					= GSW_Debug_PmacIgTable;
+	ops->gsw_debug_ops.DEBUG_PmacBp					= GSW_Debug_PmacBpTable;
+	ops->gsw_debug_ops.DEBUG_Def_PceQmap			= GSW_Debug_PceQTable;
+	ops->gsw_debug_ops.DEBUG_Def_PceBypQmap			= GSW_Debug_PceBypassTable;
+	ops->gsw_debug_ops.DEBUG_GetLpStatistics		= GSW_Debug_GetLpStatistics;
+	ops->gsw_debug_ops.DEBUG_GetCtpStatistics 		= GSW_Debug_GetCtpStatistics;
+	ops->gsw_debug_ops.Xgmac						= GSW_XgmacCfg;
+	ops->gsw_debug_ops.Gswss						= GSW_GswssCfg;
+	ops->gsw_debug_ops.Lmac							= GSW_LmacCfg;
+	ops->gsw_debug_ops.DEBUG_PrintPceIrqList		= GSW_Debug_PrintPceIrqList;
+	ops->gsw_debug_ops.Macsec				        = GSW_MacsecCfg;
+	ops->gsw_debug_ops.DEBUG_RMON_Port_Get			= GSW_Debug_RMON_Port_Get;
+	ops->gsw_debug_ops.DumpMem				= GSW_DumpTable;
+
+	/*IRQ Operation*/
+	ops->gsw_irq_ops.IRQ_Register					= GSW_Irq_register;
+	ops->gsw_irq_ops.IRQ_UnRegister					= GSW_Irq_unregister;
+	ops->gsw_irq_ops.IRQ_Enable						= GSW_Irq_enable;
+	ops->gsw_irq_ops.IRQ_Disable					= GSW_Irq_disable;
+
+	return GSW_statusOk;
+}
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
new file mode 100644
index 000000000000..f70743523d40
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
@@ -0,0 +1,1009 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+
+#ifndef _LTQ_FLOW_CORE_H_
+#define _LTQ_FLOW_CORE_H_
+
+
+#ifdef __KERNEL__
+#include <net/switch_api/gsw_flow_ops.h>
+#else
+#include <gsw_flow_ops.h>
+#endif
+
+#define	PCE_ASSERT(t)	if ((t)) { \
+		printk("%s:%s:%d (" # t ")\n", __FILE__, __func__, __LINE__); \
+		return -1; }
+
+#ifndef GSW_RETURN_PCE
+#define GSW_RETURN_PCE	\
+	{	\
+		printk("ERROR:\n\tFile %s\n\tLine %d\n", __FILE__, __LINE__);	\
+		return -1; \
+	}
+#endif
+
+/* Below are two macros
+For FILL_CTRL_REG make sure init 'outVal' to zeor before filling
+Where as CLEAR_FILL_CTRL_REG takes care of clear then fill.
+*/
+//Set the value at given offset.
+#define FILL_CTRL_REG(outVal, shift, inVal)	\
+	outVal = (outVal | (inVal << shift))
+//Clear first then set value at given offset.
+#define CLEAR_FILL_CTRL_REG(outVal, shift, size, inVal)	\
+	outVal = ((outVal & (~(((1 << size)-1) << shift))) |\
+		  ((inVal & ((1 << size)-1)) << shift))
+//Get the value at given offset.
+#define GET_VAL_FROM_REG(outVal, shift, size, inVal)	\
+	outVal = ((inVal >> shift) & ((1 << size)-1))
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(arr)	(sizeof(arr)/sizeof((arr)[0]))
+#endif
+
+#define MAX_BUSY_RETRY	1000
+#define RETURN_ERROR_CODE		0
+#define RETURN_FROM_FUNCTION	1
+
+#define CHECK_BUSY(reg, shift, size, action) ({					\
+		int retCode = GSW_statusOk;										\
+		do{ 															\
+			u32 busyRetry=MAX_BUSY_RETRY, value=0;						\
+			do{															\
+				gsw_r32(cdev, reg, shift, size, &value);				\
+			}while (value && --busyRetry);								\
+			if(value && !busyRetry)										\
+			{															\
+				pr_err("ERROR: Hardware busy for too long\n");			\
+				pr_err("%s %s %d (Register=0x%x)\n",__FILE__, __func__, __LINE__,reg);\
+				if(RETURN_FROM_FUNCTION == action)						\
+					return GSW_statusErr;								\
+				retCode = GSW_statusErr;    							\
+			}															\
+		}while(0);														\
+		retCode;														\
+	})																\
+
+#ifdef __KERNEL__
+
+#define CHECK_BUSY_MDIO(reg, shift, size, action) ({			\
+		int retCode = GSW_statusOk; 									\
+		do{ 															\
+			u32 value=0;												\
+			do{ 														\
+				udelay(1);												\
+				gsw_r32(cdev, reg, shift, size, &value);				\
+			}while (value);												\
+		}while(0);														\
+		retCode;														\
+	})																\
+
+#endif
+
+#if defined(WIN_PC_MODE) && WIN_PC_MODE
+
+#define CHECK_BUSY_MDIO(reg, shift, size, action) ({			\
+		int retCode = GSW_statusOk; 									\
+		do{ 															\
+			u32 value=0;												\
+			do{ 														\
+				gsw_r32(cdev, reg, shift, size, &value);				\
+			}while (value);												\
+		}while(0);														\
+		retCode;														\
+	})																\
+
+#endif
+
+
+#define PORT_STATE_LISTENING 0
+#define PS_RENABLE_TDISABLE	1
+#define PS_RDISABLE_TENABLE	2
+#define PORT_STATE_DISABLE  3
+#define PORT_STATE_LEARNING 4
+#define PORT_STATE_FORWARDING 7
+#define REX_TFLOW_CNT_1	0x28
+
+
+/*GSWIP 3.1 --------------------------*/
+#define MAX_PORT_NUMBER 128
+#define DSCP2PCP_TABLE_SIZE         64
+#define EXVLAN_TABLE_SIZE           1024
+#define VLAN_FILTER_TABLE_SIZE      1024
+#define BRDG_CONF_TABLE_SIZE        64
+#define CTP_PORTCONF_TABLE_SIZE     288
+#define BRDG_PORTCONF_TABLE_SIZE    128
+#define METER_TABLE_SIZE            128
+#define SHAPER_TABLE_SIZE           32
+#define PMAPPER_TABLE_SIZE          32
+#define CLEAR_U16(var) var &= ((u16)~(0xFFFF))
+/*-------------------------------------*/
+
+#define PCE_INNER_PCP_DFL_ENTRIES 8
+#define PCE_INNER_PCP_MAX_ENTRIES 16
+
+#define VLAN_ACTIVE_TABLE_SIZE 64
+/* #define MAC_TABLE_SIZE 2048 */
+#define MC_PC_SIZE 64
+#define GSW_2X_SOC_CPU_PORT 6
+#define GSW_3X_SOC_CPU_PORT 0
+#define LTQ_SOC_CAP_SEGMENT 256
+#define VRX_PLATFORM_CAP_FID 64
+#define RMON_COUNTER_OFFSET 64
+/*Applicable only for GSWIP 3.1*/
+#define RMON_COUNTER_OFFSET_GSWIP3_1 22
+#define RMON_TFLOW_DIR_MAX 2
+#define GSW_TREG_OFFSET 0xC40
+#define MAX_PACKET_LENGTH 9600
+#define V31_MAX_PACKET_LENGTH 10000
+#define PCE_PKG_LNG_TBL_SIZE 16
+#define PCE_DASA_MAC_TBL_SIZE 64
+#define PCE_APPL_TBL_SIZE 64
+#define PCE_FLAGS_TBL_SIZE 32
+#define PCE_PAYLOAD_TBL_SIZE 64
+#define IP_DASA_PC_MSIZE 16
+#define IP_DASA_PC_LSIZE 64
+#define PCE_PTCL_TBL_SIZE 32
+#define PCE_PPPOE_TBL_SIZE 16
+#define PCE_VLAN_ACT_TBL_SIZE 64
+#define PCE_TABLE_SIZE 512
+/*256 -- GSWIP3.0*/ /* 64 -- GSWIP2.2*/
+#define PCE_MICRO_TABLE_SIZE 256
+/* Pore redirect PCE rules set or port 0 (30), port 1 (31),*/
+/* port 2 (32), port 3(33), port 4(34) and port 5(35) */
+#define PRD_PRULE_INDEX 30
+#define EAPOL_PCE_RULE_INDEX	60
+#define BPDU_PCE_RULE_INDEX 61
+#define MPCE_RULES_INDEX	10
+#define LTQ_GSWIP_2_0 0x100
+#define LTQ_GSWIP_2_1 0x021
+#define LTQ_GSWIP_2_2 0x122
+#define LTQ_GSWIP_2_2_ETC 0x023
+#define LTQ_GSWIP_3_0 0x030
+#define LTQ_GSWIP_3_1 0x031
+
+#define IS_VRSN_30_31(ver) \
+	((ver == LTQ_GSWIP_3_0) || (ver == LTQ_GSWIP_3_1))
+
+#define IS_VRSN_31(ver) \
+	((ver == LTQ_GSWIP_3_1))
+
+#define IS_VRSN_NOT_31(ver) \
+	((ver != LTQ_GSWIP_3_1))
+
+/*PHY Reg 0x4 */
+#define PHY_AN_ADV_10HDX 0x20
+#define PHY_AN_ADV_10FDX 0x40
+#define PHY_AN_ADV_100HDX 0x80
+#define PHY_AN_ADV_100FDX 0x100
+/*PHY Reg 0x9 */
+#define PHY_AN_ADV_1000HDX 0x100
+#define PHY_AN_ADV_1000FDX 0x200
+
+#define DEFAULT_AGING_TIMEOUT	300
+/* Define Aging Counter Mantissa Value */
+#define AGETIMER_1_DAY 0xFB75
+#define AGETIMER_1_HOUR 0xA7BA
+#define AGETIMER_300_SEC 0xDF84
+#define AGETIMER_10_SEC 0x784
+#define AGETIMER_1_SEC 0xBF
+
+/* Define Duplex Mode */
+#define DUPLEX_AUTO 0
+#define DUPLEX_EN 1
+#define DUPLEX_DIS 3
+
+#define INSTR 0
+#define IPV6 1
+#define LENACCU 2
+
+/*GSWIP 3.1 related Macro defines*/
+
+
+
+/* parser's microcode output field type */
+enum {
+	OUT_MAC0 = 0,
+	OUT_MAC1,
+	OUT_MAC2,
+	OUT_MAC3,
+	OUT_MAC4,
+	OUT_MAC5,
+	OUT_ITAG0,
+	OUT_ITAG1,
+	OUT_ITAG2,
+	OUT_ITAG3,
+	OUT_1VTAG0, /* 10 */
+	OUT_1VTAG1,
+	OUT_2VTAG0,
+	OUT_2VTAG1,
+	OUT_3VTAG0,
+	OUT_3VTAG1,
+	OUT_4VTAG0,
+	OUT_4VTAG1,
+	OUT_ETYPE,
+	OUT_PPPOE0,
+	OUT_PPPOE1, /* 20 */
+	OUT_PPPOE3,
+	OUT_PPP,
+	OUT_RES,
+	OUT_1IP0,
+	OUT_1IP1,
+	OUT_1IP2,
+	OUT_1IP3,
+	OUT_1IP4,
+	OUT_1IP5,
+	OUT_1IP6, /* 30 */
+	OUT_1IP7,
+	OUT_1IP8,
+	OUT_1IP9,
+	OUT_1IP10,
+	OUT_1IP11,
+	OUT_1IP12,
+	OUT_1IP13,
+	OUT_1IP14,
+	OUT_1IP15,
+	OUT_1IP16, /* 40 */
+	OUT_1IP17,
+	OUT_1IP18,
+	OUT_1IP19,
+	OUT_2IP0,
+	OUT_2IP1,
+	OUT_2IP2,
+	OUT_2IP3,
+	OUT_2IP4,
+	OUT_2IP5,
+	OUT_2IP6, /* 50 */
+	OUT_2IP7,
+	OUT_2IP8,
+	OUT_2IP9,
+	OUT_2IP10,
+	OUT_2IP11,
+	OUT_2IP12,
+	OUT_2IP13,
+	OUT_2IP14,
+	OUT_2IP15,
+	OUT_2IP16, /* 60 */
+	OUT_2IP17,
+	OUT_2IP18,
+	OUT_2IP19,
+	OUT_APP0,
+	OUT_APP1,
+	OUT_APP2,
+	OUT_APP3,
+	OUT_APP4,
+	OUT_APP5,
+	OUT_APP6, /* 70 */
+	OUT_APP7,
+	OUT_APP8,
+	OUT_APP9,
+	OUT_1PL,
+	OUT_2PL,
+	OUT_1LNH,
+	OUT_2LNH = 77,
+	OUT_NONE = 127
+};
+
+/* parser's microcode flag type */
+enum {
+	FLAG_NO = 0,
+	FLAG_END,
+	FLAG_CAPWAP,
+	FLAG_GRE,
+	FLAG_LEN,
+	FLAG_GREK,
+	FLAG_NN1,
+	FLAG_NN2,
+	FLAG_ITAG,
+	FLAG_1VLAN,
+	FLAG_2VLAN,  /* 10 */
+	FLAG_3VLAN,
+	FLAG_4VLAN,
+	FLAG_SNAP,
+	FLAG_PPPOES,
+	FLAG_1IPV4,
+	FLAG_1IPV6,
+	FLAG_2IPV4,
+	FLAG_2IPV6,
+	FLAG_ROUTEXP,
+	FLAG_TCP,  /* 20 */
+	FLAG_1UDP,
+	FLAG_IGMP,
+	FLAG_IPV4OPT,
+	FLAG_1IPV6EXT,
+	FLAG_TCPACK,
+	FLAG_IPFRAG,
+	FLAG_EAPOL,
+	FLAG_2IPV6EXT,
+	FLAG_2UDP,
+	FLAG_L2TPNEXP,  /* 30 */
+	FLAG_LROEXP,
+	FLAG_L2TP,
+	FLAG_GRE_VLAN1,
+	FLAG_GRE_VLAN2,
+	FLAG_GRE_PPPOE,
+	FLAG_NN13,
+	FLAG_NN14,
+	FLAG_NN15,
+	FLAG_NN16,
+	FLAG_NN17, /* 40 */
+	FLAG_NN18,
+	FLAG_NN19,
+	FLAG_NN20,
+	FLAG_NN21,
+	FLAG_NN22,
+	FLAG_NN23,
+	FLAG_NN24,
+	FLAG_NN25,
+	FLAG_NN26,
+	FLAG_NN27, /* 50 */
+	FLAG_NN28,
+	FLAG_NN29,
+	FLAG_NN30,
+	FLAG_NN31,
+	FLAG_NN32,
+	FLAG_NN33,
+	FLAG_NN34,
+	FLAG_NN35,
+	FLAG_NN36,
+	FLAG_NN37, /* 60 */
+	FLAG_NN38,
+	FLAG_NN39,
+	FLAG_NN40,
+};
+
+/* GSWIP_2.X*/
+enum {
+	GOUT_MAC0 = 0,
+	GOUT_MAC1,
+	GOUT_MAC2,
+	GOUT_MAC3,
+	GOUT_MAC4,
+	GOUT_MAC5,
+	GOUT_ETHTYP,
+	GOUT_VTAG0,
+	GOUT_VTAG1,
+	GOUT_ITAG0,
+	GOUT_ITAG1,	/*10 */
+	GOUT_ITAG2,
+	GOUT_ITAG3,
+	GOUT_IP0,
+	GOUT_IP1,
+	GOUT_IP2,
+	GOUT_IP3,
+	GOUT_SIP0,
+	GOUT_SIP1,
+	GOUT_SIP2,
+	GOUT_SIP3,	/*20*/
+	GOUT_SIP4,
+	GOUT_SIP5,
+	GOUT_SIP6,
+	GOUT_SIP7,
+	GOUT_DIP0,
+	GOUT_DIP1,
+	GOUT_DIP2,
+	GOUT_DIP3,
+	GOUT_DIP4,
+	GOUT_DIP5,	/*30*/
+	GOUT_DIP6,
+	GOUT_DIP7,
+	GOUT_SESID,
+	GOUT_PROT,
+	GOUT_APP0,
+	GOUT_APP1,
+	GOUT_IGMP0,
+	GOUT_IGMP1,
+	GOUT_IPOFF,	/*39*/
+	GOUT_NONE	=	63,
+};
+
+/* parser's microcode flag type */
+enum {
+	GFLAG_ITAG = 0,
+	GFLAG_VLAN,
+	GFLAG_SNAP,
+	GFLAG_PPPOE,
+	GFLAG_IPV6,
+	GFLAG_IPV6FL,
+	GFLAG_IPV4,
+	GFLAG_IGMP,
+	GFLAG_TU,
+	GFLAG_HOP,
+	GFLAG_NN1,	/*10 */
+	GFLAG_NN2,
+	GFLAG_END,
+	GFLAG_NO,	/*13*/
+};
+
+typedef struct {
+	u16 val_3;
+	u16 val_2;
+	u16 val_1;
+	u16 val_0;
+} pce_uc_row_t;
+
+
+typedef enum {
+	/** Parser microcode table */
+	PMAC_BPMAP_INDEX = 0x00,
+	PMAC_IGCFG_INDEX = 0x01,
+	PMAC_EGCFG_INDEX = 0x02,
+} pm_tbl_cmds_t;
+
+/** Description */
+typedef enum {
+	PMAC_OPMOD_READ = 0,
+	PMAC_OPMOD_WRITE = 1,
+} pm_opcode_t;
+
+typedef pce_uc_row_t PCE_MICROCODE[PCE_MICRO_TABLE_SIZE];
+/** Provides the address of the configured/fetched lookup table. */
+typedef enum {
+	/** Parser microcode table */
+	PCE_PARS_INDEX = 0x00,
+	PCE_ACTVLAN_INDEX = 0x01,
+	PCE_VLANMAP_INDEX = 0x02,
+	PCE_PPPOE_INDEX = 0x03,
+	PCE_PROTOCOL_INDEX = 0x04,
+	PCE_APPLICATION_INDEX	= 0x05,
+	PCE_IP_DASA_MSB_INDEX	= 0x06,
+	PCE_IP_DASA_LSB_INDEX	= 0x07,
+	PCE_PACKET_INDEX = 0x08,
+	PCE_PCP_INDEX = 0x09,
+	PCE_DSCP_INDEX = 0x0A,
+	PCE_MAC_BRIDGE_INDEX	= 0x0B,
+	PCE_MAC_DASA_INDEX = 0x0C,
+	PCE_MULTICAST_SW_INDEX = 0x0D,
+	PCE_MULTICAST_HW_INDEX = 0x0E,
+	PCE_TFLOW_INDEX = 0x0F,
+	PCE_REMARKING_INDEX = 0x10,
+	PCE_QUEUE_MAP_INDEX = 0x11,
+	PCE_METER_INS_0_INDEX	= 0x12,
+	PCE_METER_INS_1_INDEX	= 0x13,
+	PCE_IPDALSB_INDEX = 0x14,
+	PCE_IPSALSB_INDEX = 0x15,
+	PCE_MACDA_INDEX = 0x16,
+	PCE_MACSA_INDEX = 0x17,
+	PCE_PARSER_FLAGS_INDEX = 0x18,
+	PCE_PARS_INDIVIDUAL_INDEX	= 0x19,
+	PCE_SPCP_INDEX = 0x1A,
+	PCE_MSTP_INDEX = 0x1B,
+	PCE_EGREMARK_INDEX = 0x1C,
+	PCE_PAYLOAD_INDEX = 0x1D,
+	PCE_EG_VLAN_INDEX = 0x1E,
+} ptbl_cmds_t;
+
+/*GSWIP 3.1 related defines*/
+#define PMAPPER_ENTRY_INVALID 0xFFFF
+#define EXVLAN_ENTRY_INVALID 0xFFFF
+#define VLANFILTER_ENTRY_INVALID 0xFFFF
+#define BRDG_CONF_ENTRY_INVALID 0xFFFF
+#define BRDG_PORTCONF_ENTRY_INVALID 0xFFFF
+#define METER_ENTRY_INVALID 0xFFFF
+
+typedef enum {
+	PCE_VLANFILTER_INDEX = 0x2,
+	PCE_DSCP2PCP_INDEX = 0xC,
+	PCE_IGCTP_INDEX = 0x12,
+	PCE_EGCTP_INDEX = 0x13,
+	PCE_IGBGP_INDEX = 0x14,
+	PCE_EGBGP_INDEX = 0x15,
+	PCE_BRGCFG_INDEX = 0x19,
+	PCE_MAMRK_INDEX = 0x1B,
+	PCE_REMARK_INDEX = 0x1C,
+	PCE_EXTVLAN_INDEX = 0x1E,
+	PCE_PMAP_INDEX = 0x1F
+} ptbl_3_1_cmds_t;
+
+/** Description */
+typedef enum {
+	PCE_OP_MODE_ADRD = 0,
+	PCE_OP_MODE_ADWR = 1,
+	PCE_OP_MODE_KSRD = 2,
+	PCE_OP_MODE_KSWR = 3
+} ptbl_opcode_t;
+
+typedef enum {
+	LTQ_FLOW_DEV_INT	= 0,
+	LTQ_FLOW_DEV_INT_R	= 1,
+	LTQ_FLOW_DEV_MAX
+} gsw_devtype_t;
+
+typedef struct {
+	u16 pkg_lng;
+	u16 pkg_lng_rng;
+}	pce_pkt_length_t;
+
+typedef struct {
+	u8 mac[6];
+	u16 mac_mask;
+}	pce_sa_prog_t;
+
+typedef struct {
+	u8 mac[6];
+	u16 mac_mask;
+}	pce_da_prog_t;
+
+typedef struct {
+	u16 appl_data;
+	u16 mask_range;
+	u8 mask_range_type;
+} app_tbl_t;
+
+typedef struct {
+	u16 parser_flag_data;
+	u16 mask_value;
+	u8 valid;
+} flag_tbl_t;
+
+typedef struct {
+	u16 payload_data;
+	u16 mask_range;
+	u8 mask_range_type: 1;
+	u8 valid: 1;
+} payload_tbl_t;
+
+/* IP DA/SA MSB Table */
+typedef struct {
+	u8 imsb[8];
+	u16 mask[4];
+	u16 nmask; //Not in use.
+	ltq_bool_t valid;
+} pce_dasa_msb_t;
+
+/* IP DA/SA LSB Table */
+typedef struct {
+	u8 ilsb[8];
+	u16	mask[4];
+	u16 nmask; //Not in use.
+	ltq_bool_t valid;
+} pce_dasa_lsb_t;
+
+/* programme the Protocol Table */
+typedef struct {
+	u16 ethertype;
+	u16 emask;
+} prtcol_tbl_t;
+
+/* PPPoE Table  */
+typedef struct {
+	u16	sess_id;
+} pce_ppoe_tbl_t;
+
+typedef struct {
+	u16 pkt_lng_idx: 8;
+	u16 dst_mac_addr_idx: 8;
+	u16 src_mac_addr_idx: 8;
+	u16 dst_appl_fld_idx: 8;
+	u16 src_appl_fld_idx: 8;
+	u16 dip_msb_idx: 8;
+	u16 dip_lsb_idx: 8;
+	u16 sip_msb_idx: 8;
+	u16 sip_lsb_idx: 8;
+	u16 inr_dip_msb_idx: 8;
+	u16 inr_dip_lsb_idx: 8;
+	u16 inr_sip_msb_idx: 8;
+	u16 inr_sip_lsb_idx: 8;
+	u16 ip_prot_idx: 8;
+	u16 ethertype_idx: 8;
+	u16 pppoe_idx: 8;
+	u16 vlan_idx: 8;
+	u16 svlan_idx: 8;
+	u16 payload1_idx: 8;
+	u16 payload2_idx: 8;
+	u16 ppp_prot_idx: 8;
+	u16 parse_lsb_idx: 8;
+	u16 parse_msb_idx: 8;
+	u16 parse1_lsb_idx: 8;
+	u16 parse1_msb_idx: 8;
+} pce_table_t;
+
+typedef struct {
+	/* table reference counter */
+	u16 pkg_lng_tbl_cnt[PCE_PKG_LNG_TBL_SIZE];
+	u16 sa_mac_tbl_cnt[PCE_DASA_MAC_TBL_SIZE];
+	u16 da_mac_tbl_cnt[PCE_DASA_MAC_TBL_SIZE];
+	u16 appl_tbl_cnt[PCE_APPL_TBL_SIZE];
+	u16 flags_tbl_cnt[PCE_FLAGS_TBL_SIZE];
+	u16 payload_tbl_cnt[PCE_PAYLOAD_TBL_SIZE];
+	u16 ipmsbtcnt[IP_DASA_PC_MSIZE];
+	u16 iplsbtcnt[IP_DASA_PC_LSIZE];
+	u16 ptcl_tbl_cnt[PCE_PTCL_TBL_SIZE];
+	u16 pppoe_tbl_cnt[PCE_PPPOE_TBL_SIZE];
+	u16 vlan_act_tbl_cnt[PCE_VLAN_ACT_TBL_SIZE];
+	/* cached tables */
+	pce_pkt_length_t pkg_lng_tbl[PCE_PKG_LNG_TBL_SIZE];
+	pce_sa_prog_t sa_mac_tbl[PCE_DASA_MAC_TBL_SIZE];
+	pce_da_prog_t da_mac_tbl[PCE_DASA_MAC_TBL_SIZE];
+	app_tbl_t appl_tbl[PCE_APPL_TBL_SIZE];
+	flag_tbl_t flags_tbl[PCE_FLAGS_TBL_SIZE];
+	payload_tbl_t payload_tbl[PCE_PAYLOAD_TBL_SIZE];
+	pce_dasa_msb_t ip_dasa_msb_tbl[IP_DASA_PC_MSIZE];
+	pce_dasa_lsb_t ip_dasa_lsb_tbl[IP_DASA_PC_LSIZE];
+	prtcol_tbl_t ptcl_tbl[PCE_PTCL_TBL_SIZE];
+	pce_ppoe_tbl_t pppoe_tbl[PCE_PPPOE_TBL_SIZE];
+} pcetbl_prog_t /*pce_table_handle_t*/;
+
+typedef struct {
+	/* Parameter for the sub-tables */
+	pcetbl_prog_t pce_sub_tbl;
+	pce_table_t pce_tbl[PCE_TABLE_SIZE];
+	GSW_PCE_action_t	pce_act[PCE_TABLE_SIZE];
+	u8 ptblused[PCE_TABLE_SIZE];
+} ltq_pce_table_t;
+
+typedef struct {
+	GSW_capType_t captype;
+	/* Description String */
+	char desci[GSW_CAP_STRING_LEN];
+} gsw_capdesc_t;
+
+typedef struct {
+	GSW_STP_PortState_t psstate /*ifx_stp_state*/;
+	GSW_8021X_portState_t	ps8021x /*ifx_8021_state*/;
+	u8	pen_reg;
+	u8	pstate_reg;
+	u8	lrnlim;
+} pstpstate_t;
+
+typedef struct {
+	/* Port Enable */
+	ltq_bool_t penable;
+	/* Learning Limit Action */
+	/*	ltq_bool_t laction; */
+	/* Automatic MAC address table learning locking */
+	/*	ltq_bool_t lplock; */
+	/* Automatic MAC address table learning limitation */
+	u16 llimit;
+	/* Port State */
+	u16 ptstate;
+	/* Port State for STP */
+	GSW_STP_PortState_t	pcstate;
+	/* Port State for 8021.x */
+	GSW_8021X_portState_t	p8021xs;
+} port_config_t;
+
+typedef struct {
+	/* 8021x Port Forwarding State */
+	GSW_portForward_t sfport;
+	/* STP port State */
+	GSW_portForward_t spstate;
+	/* 8021X Forwarding Port ID*/
+	u8	fpid8021x;
+	/* STP Port ID */
+	u16	stppid;
+} stp8021x_t;
+
+typedef struct {
+	ltq_bool_t	valid;
+	u16 vid;
+	u32 fid;
+	u16 pm;
+	u16 tm;
+	ltq_bool_t	reserved;
+} avlan_tbl_t;
+
+typedef struct {
+	u16 smsbindex;
+	u16 dmsbindex;
+	u16 slsbindex;
+	u16 dlsbindex;
+	u16 pmap;
+	u16 subifid;
+	u8 fid;
+	u16 mcmode;
+	ltq_bool_t valid;
+	ltq_bool_t exclude;
+} mcsw_table_t;
+
+
+typedef struct {
+	u16	igmode;
+	ltq_bool_t igv3;
+	u16	igfport;
+	u8	igfpid;
+	ltq_bool_t igxvlan;
+	u8	igcos;
+	mcsw_table_t mctable[MC_PC_SIZE];
+	u16	igrport;
+	u8	itblsize;
+} gsw_igmp_t;
+
+typedef struct {
+	u16 VlanBlockId;
+	u8  IndexInUse;
+	u16 IndexInUsageCnt;
+	u8  Dscp2PcpPointerAssigned;
+	u16 Dscp2PcpPointer;
+	u8  MeterAssigned;
+	u16 MeterId;
+} vlan_entry_idx;
+
+typedef struct {
+	vlan_entry_idx vlan_idx[EXVLAN_TABLE_SIZE];
+	u16 nUsedEntry;
+} gsw_extendvlan_t;
+
+typedef struct {
+	u8 IndexInUse;
+	u16 IndexInUsageCnt;
+} gsw_dscp2pcp_t;
+
+typedef struct {
+	u8 IndexInUse;
+	u16 IndexInUsageCnt;
+	u8 BroadcastMeteringAssigned;
+	u16 BroadcastMeteringId;
+	u8 MulticastMeteringAssigned;
+	u16 MulticastMeteringId;
+	u8 UnknownUniCastMeteringAssigned;
+	u16 UnknownUniCastMeteringId;
+	u8 UnknownMultiIpMeteringAssigned;
+	u16 UnknownMultiIpMeteringId;
+	u8 UnknownMultiNonIpMeteringAssigned;
+	u16 UnknownMultiNonIpMeteringId;
+} gsw_brdgconfig_t;
+
+typedef struct {
+	u8 IndexInUse;
+	u16 IndexInUsageCnt;
+	u8 BrdgIdAssigned;
+	u16 BrdgId;
+	u8 IngressExVlanBlkAssigned;
+	u16 IngressExVlanBlkId;
+	u8 EgressExVlanBlkAssigned;
+	u16 EgressExVlanBlkId;
+	u8 IngressMeteringAssigned;
+	u16 IngressTrafficMeterId;
+	u8 EgressMeteringAssigned;
+	u16 EgressTrafficMeterId;
+	u8 BroadcastMeteringAssigned;
+	u16 BroadcastMeteringId;
+	u8 MulticastMeteringAssigned;
+	u16 MulticastMeteringId;
+	u8 UnknownUniCastMeteringAssigned;
+	u16 UnknownUniCastMeteringId;
+	u8 UnknownMultiIpMeteringAssigned;
+	u16 UnknownMultiIpMeteringId;
+	u8 UnknownMultiNonIpMeteringAssigned;
+	u16 UnknownMultiNonIpMeteringId;
+	u8 PmapperAssigned;
+	u16 PmappperIdx;
+	u8 IngressVlanFilterAssigned;
+	u16 IngressVlanFilterBlkId;
+	u8 EgressVlanFilter1Assigned;
+	u16 EgressVlanFilter1BlkId;
+	u8 EgressVlanFilter2Assigned;
+	u16 EgressVlanFilter2BlkId;
+	GSW_STP_PortState_t	StpState;
+	GSW_8021X_portState_t P8021xState;
+	u16 LearningLimit;
+} gsw_brdgportconfig_t;
+
+typedef struct {
+	u8 IndexInUse;
+	u16 IndexInUsageCnt;
+	u16 AssociatedLogicalPort;
+	u8 BrdgIdPortAssigned;
+	u16 BrdgPortId;
+	u8 IngressExVlanNonIgmpBlkAssigned;
+	u16 IngressExVlanNonIgmpBlkId;
+	u8 IngressExVlanIgmpBlkAssigned;
+	u16 IngressExVlanIgmpBlkId;
+	u8 IngressMeteringAssigned;
+	u16 IngressTrafficMeterId;
+	u8 IngressBridgeBypassPmapperAssigned;
+	u16 IngressBridgeBypassPmappperIdx;
+	u8 EgressExVlanNonIgmpBlkAssigned;
+	u16 EgressExVlanNonIgmpBlkId;
+	u8 EgressExVlanIgmpBlkAssigned;
+	u16 EgressExVlanIgmpBlkId;
+	u8 EgressMeteringAssigned;
+	u16 EgressTrafficMeterId;
+	u8 IngressTflowAssigned;
+	u16 IngressTflowFirstIdx;
+	u16 IngressTflowNumberOfEntrys;
+} gsw_ctpportconfig_t;
+
+typedef struct {
+	u8 IndexInUse;
+	u16 IndexInUsageCnt;
+} gsw_pmapper_t;
+
+typedef struct {
+	u8 IndexInUse;
+	u16 IndexInUsageCnt;
+} gsw_meter_t;
+
+typedef struct {
+	u8 usageCount;
+} gsw_shaper_t;
+
+
+typedef struct {
+	u16 FilterBlockId;
+	u8  IndexInUse;
+	u16 IndexInUsageCnt;
+	u8 	DiscardUntagged;
+	u8	DiscardUnMatchedTagged;
+	GSW_VlanFilterTciMask_t FilterMask;
+	/*Not available for Falcon-10G*/
+	u8	UseDefaultPortVid;
+} vlanfilter_entry_idx;
+
+typedef struct {
+	vlanfilter_entry_idx filter_idx[VLAN_FILTER_TABLE_SIZE];
+	u16 nUsedEntry;
+} gsw_vlanfilter_t;
+
+typedef struct {
+	u16 num_key;
+	u16 num_mask;
+	u16 num_val;
+} gsw_pce_tbl_info_t;
+
+typedef struct {
+	const u32 *key;
+	const u32 *mask;
+	const u32 *value;
+} gsw_pce_tbl_reg_t;
+
+/*Switch IRQ related structures*/
+typedef struct gsw_pce_irq gsw_pce_irq;
+struct gsw_pce_irq {
+	gsw_pce_irq *pNext;
+	char Port_ier_enabled;
+	unsigned short P_IER_MASK;
+	char Event_ier_enable;
+	unsigned short E_IER_MASK;
+	unsigned short P_ISR_MASK;
+	unsigned short E_ISR_MASK;
+	void *call_back;
+	void *param;
+} ;
+
+struct pce_irq_linklist {
+	gsw_pce_irq	*first_ptr;
+	gsw_pce_irq	*last_ptr;
+};
+
+typedef struct {
+	gsw_devtype_t	sdev;
+	port_config_t pconfig[MAX_PORT_NUMBER];
+	avlan_tbl_t avtable[VLAN_ACTIVE_TABLE_SIZE];
+	stp8021x_t stpconfig;
+	gsw_igmp_t iflag;
+	ltq_pce_table_t phandler;
+	gsw_dscp2pcp_t dscp2pcp_idx[DSCP2PCP_TABLE_SIZE];
+	gsw_extendvlan_t extendvlan_idx;
+	gsw_vlanfilter_t vlanfilter_idx;
+	gsw_brdgconfig_t brdgeconfig_idx[BRDG_CONF_TABLE_SIZE];
+	gsw_brdgportconfig_t brdgeportconfig_idx[BRDG_PORTCONF_TABLE_SIZE];
+	gsw_ctpportconfig_t ctpportconfig_idx[CTP_PORTCONF_TABLE_SIZE];
+	gsw_meter_t meter_idx[METER_TABLE_SIZE];
+	gsw_shaper_t shaper_idx[SHAPER_TABLE_SIZE];
+	gsw_pmapper_t pmapper_idx[PMAPPER_TABLE_SIZE];
+	void *raldev;
+	/*platform device struct*/
+	void *pdev;
+	u16 pnum;
+	u16 tpnum;					/* Total number of ports including vitual ports*/
+	u16 mpnum; 					/* ManagementPortNumber */
+	u32 matimer;
+	ltq_bool_t rst;
+	ltq_bool_t hwinit;
+	u16 vlan_rd_index; 			/* read VLAN table index */
+	u16 mac_rd_index; 			/* read mac table index */
+	u8 mhw_rinx;
+	u8 msw_rinx;
+	u8 cport;
+	u8 gsw_dev;
+
+	u16 mrtpcnt;			 	/* multicast router port count */
+	u16 meter_cnt;
+	u16 num_of_queues; 			/* Number of priority queues . */
+	u16 num_of_meters;  		/* Number of traffic meters */
+	u16 num_of_shapers; 		/* Number of traffic shapers */
+	u16 num_of_pppoe;			/* PPPoE table size  */
+	u16 avlantsz; 				/* Active VLAN table size */
+	u16 ip_pkt_lnt_size;	 	/* IP packet length table size */
+	u16 prot_table_size;	 	/* Protocol table size */
+	u16 mac_dasa_table_size; 	/* MAC DA/SA table size */
+	u16 app_table_size;			/* Application table size */
+	u16 idsmtblsize;			/* IP DA/SA MSB table size */
+	u16 idsltblsize;			/* IP DA/SA LSB table size*/
+	u16 mctblsize;				/* Multicast table size */
+	u16 tftblsize;				/* Flow Aggregation table size */
+	u16 mactblsize;				/* MAC bridging table size */
+	u16 num_of_pmac;			/* Number of PMAC */
+	u16 pdtblsize;				/* Payload Table Size  */
+	u16 num_of_ifrmon;			/* Interface RMON Counter Table Size */
+	u16 num_of_egvlan;			/* Egress VLAN Treatment Table Size */
+	u16 num_of_rt_smac;			/* Routing MAC Table Size for Source MAC */
+	u16 num_of_rt_dmac;			/* Routing MAC Table Size for Destination MAC */
+	u16 num_of_rt_ppoe;			/* Routing PPPoE Table Size  */
+	u16 num_of_rt_nat;			/* Routing Session Table Size */
+	u16 num_of_rt_mtu;			/* Routing MTU Table Size */
+	u16 num_of_rt_tunnel;		/* Routing Tunnel Table Size  */
+	u16 num_of_rt_rtp;			/* Routing RTP Table Size */
+
+	u16 num_of_bridge;			/*Number of Bridge - Applicable for 3.1*/
+	u16 num_of_bridge_port;		/*Number of Bridge Port - Applicable for 3.1*/
+	u16 num_of_ctp;				/*Number of CTP port - Applicable for 3.1 */
+	u16 num_of_extendvlan;		/*Number of extended VLAN tagging operation index in table  - Applicable for 3.1 */
+	u16 num_of_vlanfilter;		/*Number of VLAN Filter index in table  - Applicable for 3.1 */
+	u16 num_of_pmapper;			/*Number of pmapper index in table  - Applicable for 3.1
+								  p-mapper total entry 2336/73=32 number of index (i.e) each pmapper idx
+								  has 73 entries*/
+	u16 mcsthw_snoop;			/*Multicast HW snooping feature */
+
+
+	u16 gipver;
+	void *gswl_base;			/*Base address GSWIP-L */
+	void *gswr_base; 		 	/*Base address GSWIP-R */
+	void *gsw_base;  			/*Base address GSWITCH */
+
+#ifdef __KERNEL__
+	spinlock_t lock_pce;
+	spinlock_t lock_bm;
+	spinlock_t lock_pmac;
+	spinlock_t lock_misc;
+	spinlock_t lock_pae;
+	spinlock_t lock_alloc;
+	spinlock_t lock_free;
+	spinlock_t lock_irq;
+	spinlock_t lock_mdio;
+	spinlock_t lock_mmd;
+	struct tasklet_struct gswip_tasklet;
+#endif
+
+	u16 num_of_pce_tbl;
+	const gsw_pce_tbl_info_t *pce_tbl_info;
+	gsw_pce_tbl_reg_t pce_tbl_reg;
+	/*IRQ*/
+	struct pce_irq_linklist *PceIrqList;
+	u32  irq_num;
+	/**Switch Opertations**/
+	struct core_ops ops;
+} ethsw_api_dev_t;
+
+
+
+
+u8 find_active_vlan_index(void *cdev, u16 vid);
+int find_msb_tbl_entry(pcetbl_prog_t *ptbl,
+		       pce_dasa_msb_t *parm);
+int pce_dasa_msb_tbl_write(void *cdev, pcetbl_prog_t *ptbl,
+			   pce_dasa_msb_t *parm);
+int find_dasa_tbl_entry(pcetbl_prog_t *ptbl,
+			pce_dasa_lsb_t *parm);
+int pce_dasa_lsb_tbl_write(void *cdev, pcetbl_prog_t *ptbl,
+			   pce_dasa_lsb_t *parm);
+int pce_table_init(ltq_pce_table_t *pchndl);
+int ip_dasa_msb_tbl_del(void *cdev, pcetbl_prog_t *ptbl, u32 index);
+int ip_dasa_lsb_tbl_del(void *cdev, pcetbl_prog_t *ptbl, u32 index);
+int ipdsmsb_tblidx_del(pcetbl_prog_t *ptbl, u32 index);
+int gavlan_tbl_index(pcetbl_prog_t *ptbl, u8 index);
+int pce_pattern_delete(void *cdev, ltq_pce_table_t *pthandle, u32 index);
+int ipdslsb_tblidx_del(pcetbl_prog_t *ptbl, u32 index);
+int pce_action_delete(void *cdev, ltq_pce_table_t *pthandle, u32 index);
+int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle,
+		  GSW_PCE_rule_t *parm);
+int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle,
+		   GSW_PCE_rule_t *parm);
+int gsw_pce_table_key_write(void *cdev, pctbl_prog_t *ptdata);
+int gsw_pce_table_key_read(void *cdev, pctbl_prog_t *ptdata);
+GSW_return_t GSW_Freeze(void);
+GSW_return_t GSW_UnFreeze(void);
+
+#endif    /* _LTQ_FLOW_CORE_H_ */
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
new file mode 100644
index 000000000000..65b30c4e19dc
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_pce.c
@@ -0,0 +1,4661 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+
+
+#include <gsw_init.h>
+
+#define PCE_MC_M3(val, msk, ns, out, len, type, flags, ipv4_len) \
+	{ val, msk, (ns << 8 | out << 0),\
+		(len | type << 5 | flags << 8 | ipv4_len << 7)}
+
+const PCE_MICROCODE pce_mc_max_ifx_tag_m_31 = {/* V31_01 */
+	PCE_MC_M3(0x88C3, 0xFFFF, 1, OUT_ITAG0, 4, INSTR, FLAG_ITAG, 0),
+	PCE_MC_M3(0x8100, 0xFFFF, 4, OUT_1VTAG0, 2, INSTR, FLAG_1VLAN, 0),
+	PCE_MC_M3(0x88A8, 0xFFFF, 4, OUT_1VTAG0, 2, INSTR, FLAG_1VLAN, 0),
+	PCE_MC_M3(0x0000, 0x0000, 12, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x8100, 0xFFFF, 7, OUT_2VTAG0, 2, INSTR, FLAG_2VLAN, 0),
+	PCE_MC_M3(0x88A8, 0xFFFF, 7, OUT_2VTAG0, 2, INSTR, FLAG_2VLAN, 0),
+	PCE_MC_M3(0x0000, 0x0000, 12, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x8100, 0xFFFF, 10, OUT_3VTAG0, 2, INSTR, FLAG_3VLAN, 0),
+	PCE_MC_M3(0x88A8, 0xFFFF, 10, OUT_3VTAG0, 2, INSTR, FLAG_3VLAN, 0),
+	PCE_MC_M3(0x0000, 0x0000, 12, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x8100, 0xFFFF, 10, OUT_NONE, 2, INSTR, FLAG_ROUTEXP, 0),
+	PCE_MC_M3(0x88A8, 0xFFFF, 10, OUT_NONE, 2, INSTR, FLAG_ROUTEXP, 0),
+	PCE_MC_M3(0x0000, 0xF800, 14, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 20, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0600, 0x0600, 20, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 16, OUT_ETYPE, 1, INSTR, FLAG_LEN, 0),
+	PCE_MC_M3(0xAAAA, 0xFFFF, 18, OUT_APP0, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 81, OUT_APP0, 2, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0300, 0xFF00, 20, OUT_APP1, 2, INSTR, FLAG_SNAP, 0),
+	PCE_MC_M3(0x0000, 0x0000, 81, OUT_APP1, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x8864, 0xFFFF, 25, OUT_ETYPE, 4, INSTR, FLAG_PPPOES, 0),
+	PCE_MC_M3(0x0800, 0xFFFF, 28, OUT_ETYPE, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x86DD, 0xFFFF, 35, OUT_ETYPE, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x888E, 0xFFFF, 79, OUT_ETYPE, 1, INSTR, FLAG_EAPOL, 0),
+	PCE_MC_M3(0x0000, 0x0000, 80, OUT_ETYPE, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0021, 0xFFFF, 28, OUT_PPP, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0057, 0xFFFF, 35, OUT_PPP, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 80, OUT_PPP, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 29, OUT_1IP0, 4, INSTR, FLAG_1IPV4, 1),
+	PCE_MC_M3(0x0011, 0x00FF, 77, OUT_1IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0006, 0x00FF, 74, OUT_1IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0002, 0x00FF, 78, OUT_1IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0029, 0x00FF, 59, OUT_1IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0004, 0x00FF, 54, OUT_1IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 80, OUT_1IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 36, OUT_1IP0, 3, INSTR, FLAG_1IPV6, 0),
+	PCE_MC_M3(0x1100, 0xFF00, 77, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0600, 0xFF00, 74, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0400, 0xFF00, 54, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x2900, 0xFF00, 59, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0xFF00, 44, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x2B00, 0xFF00, 44, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x3C00, 0xFF00, 44, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 80, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x00F8, 46, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 80, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0xFF00, 44, OUT_1LNH, 1, IPV6, FLAG_1IPV6EXT, 0),
+	PCE_MC_M3(0x2B00, 0xFF00, 44, OUT_1LNH, 1, IPV6, FLAG_1IPV6EXT, 0),
+	PCE_MC_M3(0x3C00, 0xFF00, 44, OUT_1LNH, 1, IPV6, FLAG_1IPV6EXT, 0),
+	PCE_MC_M3(0x1100, 0xFF00, 77, OUT_1LNH, 1, IPV6, FLAG_1IPV6EXT, 0),
+	PCE_MC_M3(0x0600, 0xFF00, 74, OUT_1LNH, 1, IPV6, FLAG_1IPV6EXT, 0),
+	PCE_MC_M3(0x0400, 0xFF00, 54, OUT_1LNH, 1, IPV6, FLAG_1IPV6EXT, 0),
+	PCE_MC_M3(0x2900, 0xFF00, 59, OUT_1LNH, 1, IPV6, FLAG_1IPV6EXT, 0),
+	PCE_MC_M3(0x0000, 0x0000, 80, OUT_1LNH, 1, IPV6, FLAG_1IPV6EXT, 0),
+	PCE_MC_M3(0x0000, 0x0000, 55, OUT_2IP0, 4, INSTR, FLAG_2IPV4, 1),
+	PCE_MC_M3(0x0011, 0x00FF, 77, OUT_2IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0006, 0x00FF, 74, OUT_2IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0002, 0x00FF, 78, OUT_2IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 80, OUT_2IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 60, OUT_2IP0, 3, INSTR, FLAG_2IPV6, 0),
+	PCE_MC_M3(0x1100, 0xFF00, 77, OUT_2IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0600, 0xFF00, 74, OUT_2IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0xFF00, 66, OUT_2IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x2B00, 0xFF00, 66, OUT_2IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x3C00, 0xFF00, 66, OUT_2IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 80, OUT_2IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x00F8, 68, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 80, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0xFF00, 66, OUT_2LNH, 1, IPV6, FLAG_2IPV6EXT, 0),
+	PCE_MC_M3(0x2B00, 0xFF00, 66, OUT_2LNH, 1, IPV6, FLAG_2IPV6EXT, 0),
+	PCE_MC_M3(0x3C00, 0xFF00, 66, OUT_2LNH, 1, IPV6, FLAG_2IPV6EXT, 0),
+	PCE_MC_M3(0x1100, 0xFF00, 77, OUT_2LNH, 1, IPV6, FLAG_2IPV6EXT, 0),
+	PCE_MC_M3(0x0600, 0xFF00, 74, OUT_2LNH, 1, IPV6, FLAG_2IPV6EXT, 0),
+	PCE_MC_M3(0x0000, 0x0000, 80, OUT_2LNH, 1, IPV6, FLAG_2IPV6EXT, 0),
+	PCE_MC_M3(0x0000, 0x0000, 75, OUT_APP0, 6, INSTR, FLAG_TCP, 0),
+	PCE_MC_M3(0x0010, 0x0010, 81, OUT_APP6, 4, INSTR, FLAG_TCPACK, 0),
+	PCE_MC_M3(0x0000, 0x0010, 81, OUT_APP6, 4, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 81, OUT_APP0, 4, INSTR, FLAG_1UDP, 0),
+	PCE_MC_M3(0x0000, 0x0000, 81, OUT_APP0, 4, INSTR, FLAG_IGMP, 0),
+	PCE_MC_M3(0x0000, 0x0000, 80, OUT_NONE, 0, INSTR, FLAG_EAPOL, 0),
+	PCE_MC_M3(0x0000, 0x0000, 81, OUT_APP0, 2, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 82, OUT_1PL, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_2PL, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 83, OUT_NONE, 0, INSTR, FLAG_END, 0),
+};
+
+const PCE_MICROCODE pce_mc_max_ifx_tag_m_30 = {/* V30_13 */
+	PCE_MC_M3(0x88C3, 0xFFFF, 1, OUT_ITAG0, 4, INSTR, FLAG_ITAG, 0),
+	PCE_MC_M3(0x8100, 0xFFFF, 4, OUT_1VTAG0, 2, INSTR, FLAG_1VLAN, 0),
+	PCE_MC_M3(0x88A8, 0xFFFF, 4, OUT_1VTAG0, 2, INSTR, FLAG_1VLAN, 0),
+	PCE_MC_M3(0x0000, 0x0000, 15, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x8100, 0xFFFF, 7, OUT_2VTAG0, 2, INSTR, FLAG_2VLAN, 0),
+	PCE_MC_M3(0x88A8, 0xFFFF, 7, OUT_2VTAG0, 2, INSTR, FLAG_2VLAN, 0),
+	PCE_MC_M3(0x0000, 0x0000, 15, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x8100, 0xFFFF, 10, OUT_3VTAG0, 2, INSTR, FLAG_3VLAN, 0),
+	PCE_MC_M3(0x88A8, 0xFFFF, 10, OUT_3VTAG0, 2, INSTR, FLAG_3VLAN, 0),
+	PCE_MC_M3(0x0000, 0x0000, 15, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x8100, 0xFFFF, 13, OUT_4VTAG0, 2, INSTR, FLAG_4VLAN, 0),
+	PCE_MC_M3(0x88A8, 0xFFFF, 13, OUT_4VTAG0, 2, INSTR, FLAG_4VLAN, 0),
+	PCE_MC_M3(0x0000, 0x0000, 15, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x8100, 0xFFFF, 13, OUT_NONE, 2, INSTR, FLAG_ROUTEXP, 0),
+	PCE_MC_M3(0x88A8, 0xFFFF, 13, OUT_NONE, 2, INSTR, FLAG_ROUTEXP, 0),
+	PCE_MC_M3(0x0000, 0xF800, 17, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 23, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0600, 0x0600, 23, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 19, OUT_ETYPE, 1, INSTR, FLAG_LEN, 0),
+	PCE_MC_M3(0xAAAA, 0xFFFF, 21, OUT_APP0, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 181, OUT_APP0, 2, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0300, 0xFF00, 23, OUT_APP1, 2, INSTR, FLAG_SNAP, 0),
+	PCE_MC_M3(0x0000, 0x0000, 181, OUT_APP1, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x8864, 0xFFFF, 28, OUT_ETYPE, 4, INSTR, FLAG_PPPOES, 0),
+	PCE_MC_M3(0x0800, 0xFFFF, 31, OUT_ETYPE, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x86DD, 0xFFFF, 54, OUT_ETYPE, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x888E, 0xFFFF, 180, OUT_ETYPE, 1, INSTR, FLAG_EAPOL, 0),
+	PCE_MC_M3(0x0000, 0x0000, 180, OUT_ETYPE, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0021, 0xFFFF, 31, OUT_PPP, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0057, 0xFFFF, 54, OUT_PPP, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 180, OUT_PPP, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x4000, 0xF000, 33, OUT_NONE, 0, INSTR, FLAG_1IPV4, 1),
+	PCE_MC_M3(0x0000, 0x0000, 180, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0500, 0x0F00, 36, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 35, OUT_NONE, 0, INSTR, FLAG_IPV4OPT, 0),
+	PCE_MC_M3(0x0000, 0x0000, 36, OUT_NONE, 0, INSTR, FLAG_LROEXP, 0),
+	PCE_MC_M3(0x0003, 0x0003, 38, OUT_1IP0, 3, INSTR, FLAG_LROEXP, 0),
+	PCE_MC_M3(0x0000, 0x0000, 38, OUT_1IP0, 3, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x3FFF, 40, OUT_1IP3, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 40, OUT_1IP3, 1, INSTR, FLAG_IPFRAG, 0),
+	PCE_MC_M3(0x0000, 0xFE00, 41, OUT_NONE, 0, INSTR, FLAG_ROUTEXP, 0),
+	PCE_MC_M3(0x0011, 0x00FF, 118, OUT_1IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0006, 0x00FF, 106, OUT_1IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0002, 0x00FF, 123, OUT_1IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0029, 0x00FF, 90, OUT_1IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0004, 0x00FF, 80, OUT_1IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x002F, 0x00FF, 140, OUT_1IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0032, 0x00FF, 49, OUT_1IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 180, OUT_1IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 50, OUT_APP0, 4, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x4000, 0xF000, 52, OUT_NONE, 6, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 53, OUT_NONE, 10, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_1PL, 2, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_1PL, 2, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x6000, 0xF000, 56, OUT_NONE, 0, INSTR, FLAG_1IPV6, 0),
+	PCE_MC_M3(0x0000, 0x0000, 180, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0030, 0x0030, 58, OUT_1IP0, 3, INSTR, FLAG_LROEXP, 0),
+	PCE_MC_M3(0x0000, 0x0000, 58, OUT_1IP0, 3, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x00FE, 59, OUT_NONE, 0, INSTR, FLAG_ROUTEXP, 0),
+	PCE_MC_M3(0x1100, 0xFF00, 118, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0600, 0xFF00, 106, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 62, OUT_NONE, 0, INSTR, FLAG_LROEXP, 0),
+	PCE_MC_M3(0x0400, 0xFF00, 80, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x2900, 0xFF00, 90, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x2F00, 0xFF00, 140, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x3200, 0xFF00, 49, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0xFF00, 70, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x2B00, 0xFF00, 70, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x3C00, 0xFF00, 70, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 180, OUT_1IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x00F8, 72, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 180, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0xFF00, 70, OUT_1LNH, 1, IPV6, FLAG_1IPV6EXT, 0),
+	PCE_MC_M3(0x2B00, 0xFF00, 70, OUT_1LNH, 1, IPV6, FLAG_1IPV6EXT, 0),
+	PCE_MC_M3(0x3C00, 0xFF00, 70, OUT_1LNH, 1, IPV6, FLAG_1IPV6EXT, 0),
+	PCE_MC_M3(0x1100, 0xFF00, 118, OUT_1LNH, 1, IPV6, FLAG_1IPV6EXT, 0),
+	PCE_MC_M3(0x0600, 0xFF00, 106, OUT_1LNH, 1, IPV6, FLAG_1IPV6EXT, 0),
+	PCE_MC_M3(0x0400, 0xFF00, 80, OUT_1LNH, 1, IPV6, FLAG_1IPV6EXT, 0),
+	PCE_MC_M3(0x2900, 0xFF00, 90, OUT_1LNH, 1, IPV6, FLAG_1IPV6EXT, 0),
+	PCE_MC_M3(0x0000, 0x0000, 180, OUT_1LNH, 1, IPV6, FLAG_1IPV6EXT, 0),
+	PCE_MC_M3(0x0000, 0x0000, 81, OUT_NONE, 0, INSTR, FLAG_2IPV4, 1),
+	PCE_MC_M3(0x0500, 0x0F00, 83, OUT_2IP0, 3, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 84, OUT_2IP0, 3, INSTR, FLAG_IPV4OPT, 0),
+	PCE_MC_M3(0x0000, 0x3FFF, 85, OUT_2IP3, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 85, OUT_2IP3, 1, INSTR, FLAG_IPFRAG, 0),
+	PCE_MC_M3(0x0000, 0xFE00, 86, OUT_NONE, 0, INSTR, FLAG_ROUTEXP, 0),
+	PCE_MC_M3(0x0011, 0x00FF, 122, OUT_2IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0006, 0x00FF, 106, OUT_2IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0002, 0x00FF, 123, OUT_2IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 180, OUT_2IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 91, OUT_2IP0, 3, INSTR, FLAG_2IPV6, 0),
+	PCE_MC_M3(0x0000, 0x00FE, 92, OUT_NONE, 0, INSTR, FLAG_ROUTEXP, 0),
+	PCE_MC_M3(0x1100, 0xFF00, 122, OUT_2IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0600, 0xFF00, 106, OUT_2IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0xFF00, 98, OUT_2IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x2B00, 0xFF00, 98, OUT_2IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x3C00, 0xFF00, 98, OUT_2IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 180, OUT_2IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x00F8, 100, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 180, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0xFF00, 98, OUT_2LNH, 1, IPV6, FLAG_2IPV6EXT, 0),
+	PCE_MC_M3(0x2B00, 0xFF00, 98, OUT_2LNH, 1, IPV6, FLAG_2IPV6EXT, 0),
+	PCE_MC_M3(0x3C00, 0xFF00, 98, OUT_2LNH, 1, IPV6, FLAG_2IPV6EXT, 0),
+	PCE_MC_M3(0x1100, 0xFF00, 122, OUT_2LNH, 1, IPV6, FLAG_2IPV6EXT, 0),
+	PCE_MC_M3(0x0600, 0xFF00, 106, OUT_2LNH, 1, IPV6, FLAG_2IPV6EXT, 0),
+	PCE_MC_M3(0x0000, 0x0000, 180, OUT_2LNH, 1, IPV6, FLAG_2IPV6EXT, 0),
+	PCE_MC_M3(0x0000, 0x0000, 107, OUT_APP0, 6, INSTR, FLAG_TCP, 0),
+	PCE_MC_M3(0x0040, 0x0040, 108, OUT_NONE, 0, INSTR, FLAG_LROEXP, 0),
+	PCE_MC_M3(0x0080, 0x0080, 109, OUT_NONE, 0, INSTR, FLAG_LROEXP, 0),
+	PCE_MC_M3(0x0020, 0x0020, 110, OUT_NONE, 0, INSTR, FLAG_LROEXP, 0),
+	PCE_MC_M3(0x0008, 0x0008, 111, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0001, 0x0001, 112, OUT_NONE, 0, INSTR, FLAG_ROUTEXP, 0),
+	PCE_MC_M3(0x0001, 0x0001, 113, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0004, 0x0004, 114, OUT_NONE, 0, INSTR, FLAG_ROUTEXP, 0),
+	PCE_MC_M3(0x0004, 0x0004, 115, OUT_NONE, 0, INSTR, FLAG_LROEXP, 0),
+	PCE_MC_M3(0x0002, 0x0002, 116, OUT_NONE, 0, INSTR, FLAG_LROEXP, 0),
+	PCE_MC_M3(0x0010, 0x0010, 183, OUT_APP6, 4, INSTR, FLAG_TCPACK, 0),
+	PCE_MC_M3(0x0000, 0x0010, 183, OUT_APP6, 4, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 119, OUT_APP0, 1, INSTR, FLAG_1UDP, 0),
+	PCE_MC_M3(0x06A5, 0xFFFF, 124, OUT_APP1, 3, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x147F, 0xFFFF, 136, OUT_APP1, 3, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 181, OUT_APP1, 3, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 181, OUT_APP0, 4, INSTR, FLAG_2UDP, 0),
+	PCE_MC_M3(0x0000, 0x0000, 181, OUT_APP0, 4, INSTR, FLAG_IGMP, 0),
+	PCE_MC_M3(0x0000, 0xCA00, 131, OUT_NONE, 3, INSTR, FLAG_L2TP, 0),
+	PCE_MC_M3(0x4000, 0xCA00, 131, OUT_NONE, 4, INSTR, FLAG_L2TP, 0),
+	PCE_MC_M3(0x0200, 0xCA00, 129, OUT_NONE, 3, INSTR, FLAG_L2TP, 0),
+	PCE_MC_M3(0x4200, 0xCA00, 129, OUT_NONE, 4, INSTR, FLAG_L2TP, 0),
+	PCE_MC_M3(0x0000, 0x0000, 181, OUT_NONE, 0, INSTR, FLAG_L2TP, 0),
+	PCE_MC_M3(0x0000, 0xFFFF, 131, OUT_NONE, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 181, OUT_NONE, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0xFF03, 0xFFFF, 133, OUT_NONE, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 181, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0021, 0xFFFF, 80, OUT_NONE, 1, INSTR, FLAG_L2TPNEXP, 0),
+	PCE_MC_M3(0x0057, 0xFFFF, 90, OUT_NONE, 1, INSTR, FLAG_L2TPNEXP, 0),
+	PCE_MC_M3(0x0000, 0x0000, 181, OUT_NONE, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0010, 0x00F8, 138, OUT_NONE, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 181, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x01F8, 181, OUT_NONE, 0, INSTR, FLAG_CAPWAP, 0),
+	PCE_MC_M3(0x0000, 0x0000, 181, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x2000, 0xFFFF, 143, OUT_NONE, 1, INSTR, FLAG_GREK, 0),
+	PCE_MC_M3(0x0000, 0xFFFF, 161, OUT_NONE, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 180, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x6558, 0xFFFF, 147, OUT_NONE, 1, INSTR, FLAG_GRE, 0),
+	PCE_MC_M3(0x0800, 0xFFFF, 159, OUT_NONE, 1, INSTR, FLAG_GRE, 0),
+	PCE_MC_M3(0x86DD, 0xFFFF, 160, OUT_NONE, 1, INSTR, FLAG_GRE, 0),
+	PCE_MC_M3(0x0000, 0x0000, 180, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 148, OUT_1PL, 2, INSTR, FLAG_L2TPNEXP, 0),
+	PCE_MC_M3(0x0000, 0x0000, 149, OUT_NONE, 6, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x8100, 0xFFFF, 151, OUT_NONE, 2, INSTR, FLAG_GRE_VLAN1, 0),
+	PCE_MC_M3(0x0000, 0x0000, 152, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x8100, 0xFFFF, 152, OUT_NONE, 2, INSTR, FLAG_GRE_VLAN2, 0),
+	PCE_MC_M3(0x8864, 0xFFFF, 156, OUT_NONE, 4, INSTR, FLAG_GRE_PPPOE, 0),
+	PCE_MC_M3(0x0800, 0xFFFF, 165, OUT_NONE, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x86DD, 0xFFFF, 174, OUT_NONE, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0021, 0xFFFF, 165, OUT_NONE, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0057, 0xFFFF, 174, OUT_NONE, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 165, OUT_1PL, 2, INSTR, FLAG_L2TPNEXP, 0),
+	PCE_MC_M3(0x0000, 0x0000, 174, OUT_1PL, 2, INSTR, FLAG_L2TPNEXP, 0),
+	PCE_MC_M3(0x6558, 0xFFFF, 148, OUT_NONE, 1, INSTR, FLAG_GRE, 0),
+	PCE_MC_M3(0x0800, 0xFFFF, 165, OUT_NONE, 1, INSTR, FLAG_GRE, 0),
+	PCE_MC_M3(0x86DD, 0xFFFF, 174, OUT_NONE, 1, INSTR, FLAG_GRE, 0),
+	PCE_MC_M3(0x0000, 0x0000, 180, OUT_NONE, 0, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 166, OUT_NONE, 0, INSTR, FLAG_2IPV4, 1),
+	PCE_MC_M3(0x0500, 0x0F00, 168, OUT_2IP0, 3, INSTR, FLAG_L2TPNEXP, 0),
+	PCE_MC_M3(0x0000, 0x0000, 169, OUT_2IP0, 3, INSTR, FLAG_IPV4OPT, 0),
+	PCE_MC_M3(0x0000, 0x3FFF, 170, OUT_2IP3, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 170, OUT_2IP3, 1, INSTR, FLAG_IPFRAG, 0),
+	PCE_MC_M3(0x0000, 0xFE00, 171, OUT_NONE, 0, INSTR, FLAG_ROUTEXP, 0),
+	PCE_MC_M3(0x0011, 0x00FF, 179, OUT_2IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0006, 0x00FF, 106, OUT_2IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_2IP4, 6, LENACCU, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 175, OUT_2IP0, 3, INSTR, FLAG_2IPV6, 0),
+	PCE_MC_M3(0x0000, 0x00FE, 176, OUT_NONE, 0, INSTR, FLAG_ROUTEXP, 0),
+	PCE_MC_M3(0x1100, 0xFF00, 179, OUT_2IP3, 17, INSTR, FLAG_L2TPNEXP, 0),
+	PCE_MC_M3(0x0600, 0xFF00, 106, OUT_2IP3, 17, INSTR, FLAG_L2TPNEXP, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_2IP3, 17, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_APP0, 4, INSTR, FLAG_2UDP, 0),
+	PCE_MC_M3(0x0000, 0x0000, 181, OUT_APP0, 2, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 182, OUT_1PL, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_2PL, 1, INSTR, FLAG_NO, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+	PCE_MC_M3(0x0000, 0x0000, 183, OUT_NONE, 0, INSTR, FLAG_END, 0),
+};
+
+
+#define PCE_MC_M(val, msk, ns, out, len, type, flags, ipv4_len) \
+	{ val, msk, (ns<<10 | out<<4 | len>>1),\
+		(len&1)<<15 | type<<13 | flags<<9 | ipv4_len<<8 }
+const PCE_MICROCODE pce_mc_max_ifx_tag_m = {
+	/*-----------------------------------------------------------------*/
+	/**   value    mask   ns  out_fields   L  type   flags   ipv4_len **/
+	/*-----------------------------------------------------------------*/
+	PCE_MC_M(0x88c3, 0xFFFF, 1, GOUT_ITAG0, 4, INSTR, GFLAG_ITAG, 0),
+	PCE_MC_M(0x8100, 0xFFFF, 2, GOUT_VTAG0, 2, INSTR, GFLAG_VLAN, 0),
+	PCE_MC_M(0x88A8, 0xFFFF, 1, GOUT_VTAG0, 2, INSTR, GFLAG_VLAN, 0),
+	PCE_MC_M(0x8100, 0xFFFF, 1, GOUT_VTAG0, 2, INSTR, GFLAG_VLAN, 0),
+	PCE_MC_M(0x8864, 0xFFFF, 17, GOUT_ETHTYP, 1, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0800, 0xFFFF, 21, GOUT_ETHTYP,	1, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x86DD, 0xFFFF, 22, GOUT_ETHTYP,	1, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x8863, 0xFFFF, 16, GOUT_ETHTYP, 1, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0xF800, 10, GOUT_NONE, 0, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0x0000, 40, GOUT_ETHTYP,	1, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0600, 0x0600, 40, GOUT_ETHTYP,	1, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0x0000, 12, GOUT_NONE, 1, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0xAAAA, 0xFFFF, 14, GOUT_NONE, 1, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0300, 0xFF00, 41, GOUT_NONE,	0, INSTR, GFLAG_SNAP, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_DIP7,	3, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0x0000, 18, GOUT_DIP7, 3, INSTR, GFLAG_PPPOE, 0),
+	PCE_MC_M(0x0021, 0xFFFF, 21, GOUT_NONE,	1, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0057, 0xFFFF, 22, GOUT_NONE,	1, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0x0000, 40, GOUT_NONE,	0, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x4000, 0xF000, 24, GOUT_IP0,	4, INSTR, GFLAG_IPV4, 1),
+	PCE_MC_M(0x6000, 0xF000, 27, GOUT_IP0,	3, INSTR, GFLAG_IPV6, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0x0000, 25, GOUT_IP3,	2, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0x0000, 26, GOUT_SIP0,	4, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0x0000, 40, GOUT_NONE,	0, LENACCU, GFLAG_NO, 0),
+	PCE_MC_M(0x1100, 0xFF00, 39, GOUT_PROT,	1, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0600, 0xFF00, 39, GOUT_PROT,	1, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0xFF00, 33, GOUT_IP3,	17, INSTR, GFLAG_HOP, 0),
+	PCE_MC_M(0x2B00, 0xFF00, 33, GOUT_IP3,	17, INSTR, GFLAG_NN1, 0),
+	PCE_MC_M(0x3C00, 0xFF00, 33, GOUT_IP3,	17, INSTR, GFLAG_NN2, 0),
+	PCE_MC_M(0x0000, 0x0000, 39, GOUT_PROT,	1, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0x00E0, 35, GOUT_NONE, 0, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0x0000, 40, GOUT_NONE, 0, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0xFF00, 33, GOUT_NONE,	0, IPV6,  GFLAG_HOP, 0),
+	PCE_MC_M(0x2B00, 0xFF00, 33, GOUT_NONE,	0, IPV6,  GFLAG_NN1, 0),
+	PCE_MC_M(0x3C00, 0xFF00, 33, GOUT_NONE,	0, IPV6,  GFLAG_NN2, 0),
+	PCE_MC_M(0x0000, 0x0000, 40, GOUT_PROT,	1, IPV6,  GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0x0000, 40, GOUT_SIP0,	16, INSTR, GFLAG_NO, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_APP0,	4, INSTR, GFLAG_IGMP, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+	PCE_MC_M(0x0000, 0x0000, 41, GOUT_NONE,	0, INSTR, GFLAG_END, 0),
+};
+
+/* find a matched entry if already written or empty entry and fill */
+static int tbl_write(void *tstart, u16 *rcnt, void *parm, u32 tsize, u32 tnum)
+{
+	int i;
+
+	/* search if the entry is already available and can be re-used */
+	for (i = 0; i < tnum; i++) {
+		if (rcnt[i] > 0) {
+			/* entry is used, check if the entry content fits */
+			if (memcmp(((char *)tstart) + i * tsize, parm, (u8)tsize) == 0) {
+				rcnt[i]++;
+				//pr_err("Using existing entry at %d\n", i);
+				return i;
+			}
+		}
+	}
+
+	/* find an empty entry and add information */
+	for (i = 0; i < tnum; i++) {
+		if (rcnt[i] == 0) {
+			memcpy(((char *)tstart) + i * tsize, parm, (u8)tsize);
+			rcnt[i]++;
+			//pr_err("Created new entry at %d\n", i);
+			return i;
+		}
+	}
+
+	/* table is full, return an error */
+	pr_err("ERROR:\n\tFile %s\n\tLine %d\n", __FILE__, __LINE__);
+	return -1;
+}
+
+static int tbl_idx_delete(u16 *rcnt, u32 index, u32 tsize)
+{
+	PCE_ASSERT(index >= tsize);
+
+	if (rcnt[index] > 0)
+		rcnt[index]--;
+
+	return GSW_statusOk;
+}
+
+/* Packet Length Table write same for both 3.0 and 3.1*/
+static int pce_tm_pkg_lng_tbl_write(void *cdev,
+				    pcetbl_prog_t *pthandle, pce_pkt_length_t *parm)
+{
+	int status;
+	pctbl_prog_t ptbl;
+	int pcindex;
+	pcindex = tbl_write(pthandle->pkg_lng_tbl,
+			    pthandle->pkg_lng_tbl_cnt,
+			    parm, sizeof(pce_pkt_length_t), PCE_PKG_LNG_TBL_SIZE);
+	PCE_ASSERT(pcindex < 0);
+	memset(&ptbl, 0, sizeof(pctbl_prog_t));
+	ptbl.table	= PCE_PACKET_INDEX;
+	ptbl.pcindex = pcindex;
+	ptbl.key[0]	= parm->pkg_lng;
+	ptbl.mask[0] = parm->pkg_lng_rng;
+	ptbl.valid	= 1;
+	status = gsw_pce_table_write(cdev, &ptbl);
+
+	if (status == GSW_statusOk)
+		return pcindex;
+	else
+		return status;
+}
+
+/* Packet Length Table delete */
+static int pce_tm_pkg_lng_tbl_delete(void *cdev,
+				     pcetbl_prog_t *pthandle, u32 index)
+{
+	int status;
+	pctbl_prog_t ptbl;
+	PCE_ASSERT(index >= PCE_PKG_LNG_TBL_SIZE);
+
+	if (pthandle->pkg_lng_tbl_cnt[index] > 0)
+		pthandle->pkg_lng_tbl_cnt[index]--;
+
+	if (pthandle->pkg_lng_tbl_cnt[index] == 0) {
+		memset((((char *)pthandle->pkg_lng_tbl)
+			+ (index * sizeof(pce_pkt_length_t))),
+		       0, sizeof(pce_pkt_length_t));
+		/* initialize the data structure before using it */
+		memset(&ptbl, 0, sizeof(pctbl_prog_t));
+		ptbl.table = PCE_PACKET_INDEX;
+		ptbl.pcindex = index;
+		status = gsw_pce_table_write(cdev, &ptbl);
+
+		if (status == GSW_statusErr)
+			return status;
+	}
+
+	return GSW_statusOk;
+}
+
+/* Packet Length Table read */
+static int pce_tm_pkg_lng_tbl_read(pcetbl_prog_t *pthandle,
+				   int index, pce_pkt_length_t *parm)
+{
+	PCE_ASSERT(index >= PCE_PKG_LNG_TBL_SIZE);
+	memcpy(parm, &pthandle->pkg_lng_tbl[index], sizeof(pce_pkt_length_t));
+	return GSW_statusOk;
+}
+
+/* MAC DA Table index write */
+static int pce_da_mac_tbl_write(void *cdev,
+				pcetbl_prog_t *pthandle, pce_da_prog_t *parm)
+{
+	pctbl_prog_t ptbl;
+	int pcindex;
+	pcindex = tbl_write(pthandle->da_mac_tbl,
+			    pthandle->da_mac_tbl_cnt, parm,
+			    sizeof(pce_da_prog_t), PCE_DASA_MAC_TBL_SIZE);
+	PCE_ASSERT(pcindex < 0);
+	memset(&ptbl, 0, sizeof(pctbl_prog_t));
+	ptbl.table = PCE_MACDA_INDEX;
+	ptbl.pcindex = pcindex;
+	ptbl.key[0]	= (parm->mac[4] << 8 | parm->mac[5]);
+	ptbl.key[1]	= (parm->mac[2] << 8 | parm->mac[3]);
+	ptbl.key[2]	= (parm->mac[0] << 8 | parm->mac[1]);
+	ptbl.mask[0] = parm->mac_mask;
+	ptbl.valid	= 1;
+	gsw_pce_table_write(cdev, &ptbl);
+	return pcindex;
+}
+
+/* MAC SA Table index write */
+static int pce_sa_mac_tbl_write(void *cdev,
+				pcetbl_prog_t *pthandle, pce_sa_prog_t *parm)
+{
+	pctbl_prog_t ptbl;
+	int pcindex;
+	pcindex = tbl_write(pthandle->sa_mac_tbl,
+			    pthandle->sa_mac_tbl_cnt, parm,
+			    sizeof(pce_sa_prog_t), PCE_DASA_MAC_TBL_SIZE);
+	PCE_ASSERT(pcindex < 0);
+	memset(&ptbl, 0, sizeof(pctbl_prog_t));
+	ptbl.table = PCE_MACSA_INDEX;
+	ptbl.pcindex = pcindex;
+	ptbl.key[0]	= (parm->mac[4] << 8 | parm->mac[5]);
+	ptbl.key[1]	= (parm->mac[2] << 8 | parm->mac[3]);
+	ptbl.key[2]	= (parm->mac[0] << 8 | parm->mac[1]);
+	ptbl.mask[0] = parm->mac_mask;
+	ptbl.valid	= 1;
+	gsw_pce_table_write(cdev, &ptbl);
+	return pcindex;
+}
+
+/* MAC SA Table delete */
+static int pce_tm_sa_mac_tbl_delete(void *cdev,
+				    pcetbl_prog_t *pthandle, u32 index)
+{
+	pctbl_prog_t ptbl;
+	PCE_ASSERT(index >= PCE_DASA_MAC_TBL_SIZE);
+
+	if (pthandle->sa_mac_tbl_cnt[index] > 0)
+		pthandle->sa_mac_tbl_cnt[index]--;
+
+	if (pthandle->sa_mac_tbl_cnt[index] == 0) {
+		memset((((char *)pthandle->sa_mac_tbl)
+			+ (index * sizeof(pce_sa_prog_t))),
+		       0, sizeof(pce_sa_prog_t));
+		/* initialize the data structure before using it */
+		memset(&ptbl, 0, sizeof(pctbl_prog_t));
+		ptbl.table				= PCE_MACSA_INDEX;
+		ptbl.pcindex	= index;
+		gsw_pce_table_write(cdev, &ptbl);
+	}
+
+	return GSW_statusOk;
+}
+
+/* MAC DA Table delete */
+static int pce_tm_da_mac_tbl_delete(void *cdev,
+				    pcetbl_prog_t *pthandle, u32 index)
+{
+	pctbl_prog_t ptbl;
+	PCE_ASSERT(index >= PCE_DASA_MAC_TBL_SIZE);
+
+	if (pthandle->da_mac_tbl_cnt[index] > 0)
+		pthandle->da_mac_tbl_cnt[index]--;
+
+	if (pthandle->da_mac_tbl_cnt[index] == 0) {
+		memset((((char *)pthandle->da_mac_tbl)
+			+ (index * sizeof(pce_da_prog_t))),
+		       0, sizeof(pce_sa_prog_t));
+		/* initialize the data structure before using it */
+		memset(&ptbl, 0, sizeof(pctbl_prog_t));
+		ptbl.table				= PCE_MACDA_INDEX;
+		ptbl.pcindex	= index;
+		gsw_pce_table_write(cdev, &ptbl);
+	}
+
+	return GSW_statusOk;
+}
+
+/* MAC DA Table Read */
+static int pce_tm_da_mac_tbl_read(pcetbl_prog_t *pthandle,
+				  int index, pce_da_prog_t *parm)
+{
+	PCE_ASSERT(index >= PCE_DASA_MAC_TBL_SIZE);
+	memcpy(parm, &pthandle->da_mac_tbl[index], sizeof(pce_da_prog_t));
+	return GSW_statusOk;
+}
+
+/* MAC SA Table Read */
+static int pce_tm_sa_mac_tbl_read(pcetbl_prog_t *pthandle,
+				  int index, pce_sa_prog_t *parm)
+{
+	PCE_ASSERT(index >= PCE_DASA_MAC_TBL_SIZE);
+	memcpy(parm, &pthandle->sa_mac_tbl[index], sizeof(pce_sa_prog_t));
+	return GSW_statusOk;
+}
+
+/* Application Table write */
+static int pce_appl_tbl_write(void *cdev,
+			      pcetbl_prog_t *pthandle, app_tbl_t *parm)
+{
+	pctbl_prog_t ptbl;
+	int pcindex;
+	pcindex = tbl_write(pthandle->appl_tbl, pthandle->appl_tbl_cnt, parm,
+			    sizeof(app_tbl_t), PCE_APPL_TBL_SIZE);
+	PCE_ASSERT(pcindex < 0);
+	memset(&ptbl, 0, sizeof(pctbl_prog_t));
+	ptbl.table = PCE_APPLICATION_INDEX;
+	ptbl.pcindex = pcindex;
+	ptbl.key[0]	= parm->appl_data;
+	ptbl.mask[0] = parm->mask_range;
+	ptbl.type = parm->mask_range_type;
+	ptbl.valid = 1;
+	gsw_pce_table_write(cdev, &ptbl);
+	return pcindex;
+}
+
+/* Flags Table write */
+static int pce_flags_tbl_write(void *cdev,
+			       pcetbl_prog_t *pthandle, flag_tbl_t *parm)
+{
+	pctbl_prog_t ptbl;
+	int pcindex, i;
+	u8 mask_section, key_section, bit_pos;
+	u16 column[4] = {0};
+	u16 key_val = parm->parser_flag_data;
+	u16 bit_mask = parm->mask_value;
+	pcindex = tbl_write(pthandle->flags_tbl,
+			    pthandle->flags_tbl_cnt, parm,
+			    sizeof(flag_tbl_t), PCE_FLAGS_TBL_SIZE);
+	PCE_ASSERT(pcindex < 0);
+	memset(&ptbl, 0, sizeof(pctbl_prog_t));
+	ptbl.table = PCE_PARSER_FLAGS_INDEX;
+	ptbl.pcindex = pcindex;
+
+	for (i = 0; i < 4; i++) {
+		mask_section = ((bit_mask >> (i * 4)) & 0xF);
+		key_section = ((key_val >> (i * 4)) & 0xF);
+		bit_pos = key_section;
+		column[i] = (1 << bit_pos);
+
+		if ((mask_section & 0x1) == 1) {
+			bit_pos = key_section & 0xe;
+			column[i] |= (1 << bit_pos);
+			bit_pos = (key_section | 0x1);
+			column[i] |= (1 << bit_pos);
+		}
+
+		if (((mask_section >> 1) & 0x1) == 1) {
+			bit_pos = key_section & 0xd;
+			column[i] |= (1 << bit_pos);
+			bit_pos = (key_section | 0x2);
+			column[i] |= (1 << bit_pos);
+		}
+
+		if (((mask_section >> 0) & 0x3) == 0x3) {
+			bit_pos = key_section & 0xc;
+			column[i] |= (1 << bit_pos);
+			bit_pos = (key_section | 0x3);
+			column[i] |= (1 << bit_pos);
+		}
+
+		if (((mask_section >> 2) & 0x1) == 0x1) {
+			bit_pos = key_section & 0xb;
+			column[i] |= (1 << bit_pos);
+			bit_pos = (key_section | 0x4);
+			column[i] |= (1 << bit_pos);
+		}
+
+		if (((mask_section >> 0) & 0x5) == 0x5) {
+			bit_pos = key_section & 0xa;
+			column[i] |= (1 << bit_pos);
+			bit_pos = (key_section | 0x5);
+			column[i] |= (1 << bit_pos);
+		}
+
+		if (((mask_section >> 1) & 0x3) == 0x3) {
+			bit_pos = key_section & 0x9;
+			column[i] |= (1 << bit_pos);
+			bit_pos = (key_section | 0x6);
+			column[i] |= (1 << bit_pos);
+		}
+
+		if (((mask_section >> 0) & 0x7) == 0x7) {
+			bit_pos = key_section & 0x8;
+			column[i] |= (1 << bit_pos);
+			bit_pos = (key_section | 0x7);
+			column[i] |= (1 << bit_pos);
+		}
+
+		if (((mask_section >> 3) & 0x1) == 0x1) {
+			bit_pos = key_section & 0x7;
+			column[i] |= (1 << bit_pos);
+			bit_pos = (key_section | 0x8);
+			column[i] |= (1 << bit_pos);
+		}
+
+		if (((mask_section >> 0) & 0x9) == 0x9) {
+			bit_pos = key_section & 0x6;
+			column[i] |= (1 << bit_pos);
+			bit_pos = (key_section | 0x9);
+			column[i] |= (1 << bit_pos);
+		}
+
+		if (((mask_section >> 0) & 0xa) == 0xa) {
+			bit_pos = key_section & 0x5;
+			column[i] |= (1 << bit_pos);
+			bit_pos = (key_section | 0xa);
+			column[i] |= (1 << bit_pos);
+		}
+
+		if (((mask_section >> 2) & 0x3) == 0x3) {
+			bit_pos = key_section & 0x3;
+			column[i] |= (1 << bit_pos);
+			bit_pos = (key_section | 0xc);
+			column[i] |= (1 << bit_pos);
+		}
+
+		if (((mask_section >> 0) & 0xb) == 0xb) {
+			bit_pos = key_section & 0x4;
+			column[i] |= (1 << bit_pos);
+			bit_pos = (key_section | 0xb);
+			column[i] |= (1 << bit_pos);
+		}
+
+		if (((mask_section >> 0) & 0xd) == 0xd) {
+			bit_pos = key_section & 0x2;
+			column[i] |= (1 << bit_pos);
+			bit_pos = (key_section | 0xd);
+			column[i] |= (1 << bit_pos);
+		}
+
+		if (((mask_section >> 1) & 0x7) == 0x7) {
+			bit_pos = key_section & 0x1;
+			column[i] |= (1 << bit_pos);
+			bit_pos = (key_section | 0xe);
+			column[i] |= (1 << bit_pos);
+		}
+
+		if (((mask_section >> 0) & 0xf) == 0xf) {
+			bit_pos = key_section & 0x0;
+			column[i] |= (1 << bit_pos);
+			bit_pos = (key_section | 0xf);
+			column[i] |= (1 << bit_pos);
+		}
+	}
+
+	for (i = 0; i < 4; i++)
+		ptbl.key[i] = column[i];
+
+	ptbl.valid = 1;
+	ptbl.kformat = 1;
+	gsw_pce_table_write(cdev, &ptbl);
+	gsw_w32(cdev, PCE_TBL_CTRL_KEYFORM_OFFSET,
+		PCE_TBL_CTRL_KEYFORM_SHIFT, PCE_TBL_CTRL_KEYFORM_SIZE, 0);
+
+	return pcindex;
+}
+
+/* Payload Table write */
+static int pce_payload_tbl_write(void *cdev,
+				 pcetbl_prog_t *pthandle, payload_tbl_t *parm)
+{
+	pctbl_prog_t ptbl;
+	int pcindex;
+	pcindex = tbl_write(pthandle->payload_tbl,
+			    pthandle->payload_tbl_cnt, parm,
+			    sizeof(payload_tbl_t), PCE_PAYLOAD_TBL_SIZE);
+	PCE_ASSERT(pcindex < 0);
+	memset(&ptbl, 0, sizeof(pctbl_prog_t));
+	ptbl.table	= PCE_PAYLOAD_INDEX;
+	ptbl.pcindex	= pcindex;
+	ptbl.key[0]	= parm->payload_data;
+	ptbl.mask[0] = parm->mask_range;
+	ptbl.type		= parm->mask_range_type;
+	ptbl.valid	= 1;
+	gsw_pce_table_write(cdev, &ptbl);
+	return pcindex;
+}
+
+/* Application Table Delete */
+static int pce_tm_appl_tbl_delete(void *cdev,
+				  pcetbl_prog_t *pthandle, u32 index)
+{
+	pctbl_prog_t ptbl;
+	PCE_ASSERT(index >= PCE_APPL_TBL_SIZE);
+
+	if (pthandle->appl_tbl_cnt[index] > 0)
+		pthandle->appl_tbl_cnt[index]--;
+
+	if (pthandle->appl_tbl_cnt[index] == 0) {
+		memset((((char *)pthandle->appl_tbl)
+			+ (index * sizeof(app_tbl_t))),
+		       0, sizeof(app_tbl_t));
+		memset(&ptbl, 0, sizeof(pctbl_prog_t));
+		memset(&ptbl, 0, sizeof(pctbl_prog_t));
+		ptbl.table	= PCE_APPLICATION_INDEX;
+		ptbl.pcindex = index;
+		gsw_pce_table_write(cdev, &ptbl);
+	}
+
+	return GSW_statusOk;
+}
+
+/* Flags Table Delete */
+static int pce_tm_flags_tbl_delete(void *cdev,
+				   pcetbl_prog_t *pthandle, u32 index)
+{
+	pctbl_prog_t ptbl;
+	PCE_ASSERT(index >= PCE_FLAGS_TBL_SIZE);
+
+	if (pthandle->flags_tbl_cnt[index] > 0)
+		pthandle->flags_tbl_cnt[index]--;
+
+	if (pthandle->flags_tbl_cnt[index] == 0) {
+		memset((((char *)pthandle->flags_tbl)
+			+ (index * sizeof(flag_tbl_t))),
+		       0, sizeof(flag_tbl_t));
+		memset(&ptbl, 0, sizeof(pctbl_prog_t));
+		ptbl.table	= PCE_PARSER_FLAGS_INDEX;
+		ptbl.pcindex = index;
+		gsw_pce_table_write(cdev, &ptbl);
+	}
+
+	return GSW_statusOk;
+}
+
+/* Payload Table Delete */
+static int pce_tm_payload_tbl_delete(void *cdev,
+				     pcetbl_prog_t *pthandle, u32 index)
+{
+	pctbl_prog_t ptbl;
+
+	PCE_ASSERT(index >= PCE_PAYLOAD_TBL_SIZE);
+
+	if (pthandle->payload_tbl_cnt[index] > 0)
+		pthandle->payload_tbl_cnt[index]--;
+
+	if (pthandle->payload_tbl_cnt[index] == 0) {
+		memset((((char *)pthandle->payload_tbl)
+			+ (index * sizeof(payload_tbl_t))),
+		       0, sizeof(payload_tbl_t));
+		memset(&ptbl, 0, sizeof(pctbl_prog_t));
+		memset(&ptbl, 0, sizeof(pctbl_prog_t));
+		ptbl.table	= PCE_PAYLOAD_INDEX;
+		ptbl.pcindex = index;
+		gsw_pce_table_write(cdev, &ptbl);
+	}
+
+	return GSW_statusOk;
+}
+/* Application Table Read */
+static int pce_tm_appl_tbl_read(pcetbl_prog_t *pthandle,
+				int index, app_tbl_t *parm)
+{
+	PCE_ASSERT(index >= PCE_APPL_TBL_SIZE);
+	memcpy(parm, &pthandle->appl_tbl[index], sizeof(app_tbl_t));
+	return GSW_statusOk;
+}
+
+/* Flags Table Read */
+static int pce_tm_flags_tbl_read(pcetbl_prog_t *pthandle,
+				 int index, flag_tbl_t *parm)
+{
+	PCE_ASSERT(index >= PCE_FLAGS_TBL_SIZE);
+	memcpy(parm, &pthandle->flags_tbl[index], sizeof(flag_tbl_t));
+	return GSW_statusOk;
+}
+
+/* Payload Table Read */
+static int pce_tm_payload_tbl_read(pcetbl_prog_t *pthandle,
+				   int index, payload_tbl_t *parm)
+{
+	PCE_ASSERT(index >= PCE_PAYLOAD_TBL_SIZE);
+	memcpy(parm, &pthandle->payload_tbl[index], sizeof(payload_tbl_t));
+	return GSW_statusOk;
+}
+
+/* IP DA/SA msb Table write */
+int pce_dasa_msb_tbl_write(void *cdev,
+			   pcetbl_prog_t *pthandle, pce_dasa_msb_t *parm)
+{
+	pctbl_prog_t ptbl;
+	int pcindex, i;
+	pcindex = tbl_write(pthandle->ip_dasa_msb_tbl, pthandle->ipmsbtcnt, parm,
+			    sizeof(pce_dasa_msb_t), IP_DASA_PC_MSIZE);
+
+	if (pcindex < 0)
+		return pcindex;
+
+	memset(&ptbl, 0, sizeof(pctbl_prog_t));
+	ptbl.table = PCE_IP_DASA_MSB_INDEX;
+	ptbl.pcindex = pcindex;
+
+	for (i = 0; i < 4; i++)
+		ptbl.key[i] = ((parm->imsb[((i * 2) + 1)] << 8) | parm->imsb[(i * 2)]);
+
+	ptbl.mask[0] = parm->mask[0];
+	ptbl.mask[1] = parm->mask[1];
+	ptbl.mask[2] = parm->mask[2];
+	ptbl.mask[3] = parm->mask[3];
+	ptbl.valid = 1;
+	gsw_pce_table_write(cdev, &ptbl);
+	return pcindex;
+}
+
+/* IP DA/SA msb Table delete */
+int ip_dasa_msb_tbl_del(void *cdev,
+			pcetbl_prog_t *pthandle, u32 index)
+{
+	pctbl_prog_t ptbl;
+	PCE_ASSERT(index >= IP_DASA_PC_MSIZE);
+
+	if (pthandle->ipmsbtcnt[index] > 0)
+		pthandle->ipmsbtcnt[index]--;
+
+	if (pthandle->ipmsbtcnt[index] == 0) {
+		memset((((char *)pthandle->ip_dasa_msb_tbl)
+			+ (index * sizeof(pce_dasa_msb_t))), 0, sizeof(pce_dasa_msb_t));
+		memset(&ptbl, 0, sizeof(pctbl_prog_t));
+		ptbl.table = PCE_IP_DASA_MSB_INDEX;
+		ptbl.pcindex = index;
+		gsw_pce_table_write(cdev, &ptbl);
+	}
+
+	return GSW_statusOk;
+}
+
+/* IP DA/SA msb Table read */
+static int pce_dasa_msb_tbl_read(pcetbl_prog_t *pthandle,
+				 int index, pce_dasa_msb_t *parm)
+{
+	PCE_ASSERT(index >= IP_DASA_PC_MSIZE);
+	memcpy(parm, &pthandle->ip_dasa_msb_tbl[index], sizeof(pce_dasa_msb_t));
+	return GSW_statusOk;
+}
+
+static int get_tbl_index(void *tstart, void *parm,
+			 u32 tsize, u32 tnum)
+{
+	int i;
+
+	/* search if the entry is already available and can be re-used */
+	for (i = 0; i < tnum; i++) {
+		/* entry is used, check if the entry content fits */
+		if (memcmp(((char *)tstart)
+			   + i * tsize, parm, (u8)tsize) == 0)
+			return i;
+	}
+
+	return 0xFF;
+}
+
+/* Static Function Declaration */
+int find_dasa_tbl_entry(pcetbl_prog_t *pthandle,
+			pce_dasa_lsb_t *parm)
+{
+	return get_tbl_index(pthandle->ip_dasa_lsb_tbl, parm,
+			     sizeof(pce_dasa_lsb_t), IP_DASA_PC_LSIZE);
+}
+
+/* Static Function Declaration */
+int find_msb_tbl_entry(pcetbl_prog_t *pthandle,
+		       pce_dasa_msb_t *parm)
+{
+	return get_tbl_index(pthandle->ip_dasa_msb_tbl, parm,
+			     sizeof(pce_dasa_msb_t), IP_DASA_PC_MSIZE);
+}
+
+/* IP DA/SA lsb Table Write */
+int pce_dasa_lsb_tbl_write(void *cdev,
+			   pcetbl_prog_t *pthandle, pce_dasa_lsb_t *parm)
+{
+	pctbl_prog_t ptbl;
+	int pcindex, i;
+	pcindex = tbl_write(pthandle->ip_dasa_lsb_tbl, pthandle->iplsbtcnt, parm,
+			    sizeof(pce_dasa_lsb_t), IP_DASA_PC_LSIZE);
+	PCE_ASSERT(pcindex < 0);
+	memset(&ptbl, 0, sizeof(pctbl_prog_t));
+	ptbl.table = PCE_IP_DASA_LSB_INDEX;
+	ptbl.pcindex = pcindex;
+
+	for (i = 0; i < 4; i++)
+		ptbl.key[i]	= ((parm->ilsb[((i * 2) + 1)] << 8)
+				   | parm->ilsb[(i * 2)]);
+
+	ptbl.mask[0] = parm->mask[0];
+	ptbl.mask[1] = parm->mask[1];
+	ptbl.mask[2] = parm->mask[2];
+	ptbl.mask[3] = parm->mask[3];
+	ptbl.valid = 1;
+	gsw_pce_table_write(cdev, &ptbl);
+	return pcindex;
+}
+
+/* IP DA/SA lsb Table delete */
+int ip_dasa_lsb_tbl_del(void *cdev,
+			pcetbl_prog_t *pthandle, u32 index)
+{
+	pctbl_prog_t ptbl;
+	PCE_ASSERT(index >= IP_DASA_PC_LSIZE);
+
+	if (pthandle->iplsbtcnt[index] > 0)
+		pthandle->iplsbtcnt[index]--;
+
+	if (pthandle->iplsbtcnt[index] == 0) {
+		memset((((char *)pthandle->ip_dasa_lsb_tbl)
+			+ (index * sizeof(pce_dasa_lsb_t))), 0, sizeof(pce_dasa_lsb_t));
+		memset(&ptbl, 0, sizeof(pctbl_prog_t));
+		ptbl.table = PCE_IP_DASA_LSB_INDEX;
+		ptbl.pcindex = index;
+		gsw_pce_table_write(cdev, &ptbl);
+	}
+
+	return GSW_statusOk;
+}
+
+/* IP DA/SA lsb Table index delete */
+int ipdslsb_tblidx_del(pcetbl_prog_t *pthandle,
+		       u32 index)
+{
+	return tbl_idx_delete(pthandle->iplsbtcnt,
+			      index, IP_DASA_PC_LSIZE);
+}
+
+/* IP DA/SA msb Table index delete */
+int ipdsmsb_tblidx_del(pcetbl_prog_t *pthandle,
+		       u32 index)
+{
+	return tbl_idx_delete(pthandle->ipmsbtcnt,
+			      index, IP_DASA_PC_MSIZE);
+}
+
+/* IP DA/SA lsb Table read */
+int pce_dasa_lsb_tbl_read(pcetbl_prog_t *pthandle,
+			  int index, pce_dasa_lsb_t *parm)
+{
+	PCE_ASSERT(index >= IP_DASA_PC_LSIZE);
+	memcpy(parm, &pthandle->ip_dasa_lsb_tbl[index], sizeof(pce_dasa_lsb_t));
+	return GSW_statusOk;
+}
+
+/* Protocal Table write */
+static int pce_ptcl_tbl_write(void *cdev,
+			      pcetbl_prog_t *pthandle, prtcol_tbl_t *parm)
+{
+	pctbl_prog_t ptbl;
+	int pcindex;
+	pcindex = tbl_write(pthandle->ptcl_tbl,
+			    pthandle->ptcl_tbl_cnt, parm,
+			    sizeof(prtcol_tbl_t), PCE_PTCL_TBL_SIZE);
+	PCE_ASSERT(pcindex < 0);
+	memset(&ptbl, 0, sizeof(pctbl_prog_t));
+	ptbl.table		= PCE_PROTOCOL_INDEX;
+	ptbl.pcindex = pcindex;
+	ptbl.key[0]		= parm->ethertype;
+	ptbl.mask[0]	= parm->emask;
+	ptbl.valid		= 1;
+	gsw_pce_table_write(cdev, &ptbl);
+	return pcindex;
+}
+/* Get the vlan flow table index*/
+int gavlan_tbl_index(pcetbl_prog_t *pthandle, u8 index)
+{
+	PCE_ASSERT(index >= PCE_VLAN_ACT_TBL_SIZE);
+
+	if (pthandle->vlan_act_tbl_cnt[index] == 0)
+		return GSW_statusOk;
+	else
+		return -1;
+}
+
+/* Protocal Table delete */
+static int pce_tm_ptcl_tbl_delete(void *cdev,
+				  pcetbl_prog_t *pthandle, u32 index)
+{
+	pctbl_prog_t ptbl;
+	PCE_ASSERT(index >= PCE_PTCL_TBL_SIZE);
+
+	if (pthandle->ptcl_tbl_cnt[index] > 0)
+		pthandle->ptcl_tbl_cnt[index]--;
+
+	if (pthandle->ptcl_tbl_cnt[index] == 0) {
+		memset((((char *)pthandle->ptcl_tbl)
+			+ (index * sizeof(prtcol_tbl_t))),
+		       0, sizeof(prtcol_tbl_t));
+		memset(&ptbl, 0, sizeof(pctbl_prog_t));
+		ptbl.table		= PCE_PROTOCOL_INDEX;
+		ptbl.pcindex = index;
+		gsw_pce_table_write(cdev, &ptbl);
+	}
+
+	return GSW_statusOk;
+}
+
+/* Protocal Table Read */
+static int pce_tm_ptcl_tbl_read(pcetbl_prog_t *pthandle,
+				int index, prtcol_tbl_t *parm)
+{
+	PCE_ASSERT(index >= PCE_PTCL_TBL_SIZE);
+	memcpy(parm, &pthandle->ptcl_tbl[index], sizeof(prtcol_tbl_t));
+	return GSW_statusOk;
+}
+
+/* PPPoE Table Write */
+static int pce_tm_pppoe_tbl_write(void *cdev,
+				  pcetbl_prog_t *pthandle, pce_ppoe_tbl_t *parm)
+{
+	pctbl_prog_t ptbl;
+	int pcindex;
+	pcindex = tbl_write(pthandle->pppoe_tbl,
+			    pthandle->pppoe_tbl_cnt,
+			    parm,	sizeof(pce_ppoe_tbl_t), PCE_PPPOE_TBL_SIZE);
+
+	if (pcindex < 0)
+		return pcindex;
+
+	/* initialize the data structure before using it */
+	memset(&ptbl, 0, sizeof(pctbl_prog_t));
+	ptbl.table		= PCE_PPPOE_INDEX;
+	ptbl.pcindex = pcindex;
+	ptbl.key[0]		= parm->sess_id;
+	ptbl.valid		= 1;
+	gsw_pce_table_write(cdev, &ptbl);
+	return pcindex;
+}
+
+/* PPPoE Table Delete */
+static int pce_tm_pppoe_tbl_delete(void *cdev,
+				   pcetbl_prog_t *pthandle, u32 index)
+{
+	pctbl_prog_t ptbl;
+	PCE_ASSERT(index >= PCE_PPPOE_TBL_SIZE);
+
+	if (pthandle->pppoe_tbl_cnt[index] > 0)
+		pthandle->pppoe_tbl_cnt[index]--;
+
+	if (pthandle->pppoe_tbl_cnt[index] == 0) {
+		memset((((char *)pthandle->pppoe_tbl)
+			+ (index * sizeof(pce_ppoe_tbl_t))),
+		       0, sizeof(pce_ppoe_tbl_t));
+		memset(&ptbl, 0, sizeof(pctbl_prog_t));
+		ptbl.table		= PCE_PPPOE_INDEX;
+		ptbl.pcindex = index;
+		gsw_pce_table_write(cdev, &ptbl);
+	}
+
+	return GSW_statusOk;
+}
+
+/* PPPoE Table Read */
+static int pce_tm_pppoe_tbl_read(pcetbl_prog_t *pthandle,
+				 int index, pce_ppoe_tbl_t *parm)
+{
+	PCE_ASSERT(index >= PCE_PPPOE_TBL_SIZE);
+	memcpy(parm, &pthandle->pppoe_tbl[index], sizeof(pce_ppoe_tbl_t));
+	return GSW_statusOk;
+}
+
+/* VLAN Table Delete */
+static int pce_tm_vlan_act_tbl_delete(void *cdev,
+				      pcetbl_prog_t *pthandle, u32 index)
+{
+	PCE_ASSERT(index >= PCE_VLAN_ACT_TBL_SIZE);
+
+	if (pthandle->vlan_act_tbl_cnt[index] > 0)
+		pthandle->vlan_act_tbl_cnt[index]--;
+
+	return GSW_statusOk;
+}
+
+static u32 act_vlan_id_create(void *cdev, u16 vid,
+			      int range_flag, u16 range_val)
+{
+	pctbl_prog_t ptbl;
+	u32	index, vid_index = 0x7F;
+
+	for (index = 0; index < PCE_VLAN_ACT_TBL_SIZE; index++) {
+		memset(&ptbl, 0, sizeof(pctbl_prog_t));
+		ptbl.table		= PCE_ACTVLAN_INDEX;
+		ptbl.pcindex = index;
+		gsw_pce_table_read(cdev, &ptbl);
+
+		if (ptbl.valid == 0) {
+			ptbl.pcindex	= index;
+			vid_index				= index;
+			ptbl.table	= PCE_ACTVLAN_INDEX;
+			ptbl.key[0]	= vid;
+
+			if (range_flag)
+				ptbl.mask[0]	= range_val;
+			else
+				ptbl.mask[0]	= 0;
+
+			ptbl.valid	= 1;
+			ptbl.type		= range_flag;
+			gsw_pce_table_write(cdev, &ptbl);
+			break;
+		}
+	}
+
+	return vid_index;
+}
+
+static int pce_vid_index(void *cdev,
+			 pcetbl_prog_t *pthandle, u16 vid)
+{
+	pctbl_prog_t pcetable_vlan;
+	int	index, vid_index = 0x7F;
+
+	for (index = 0; index < PCE_VLAN_ACT_TBL_SIZE; index++) {
+		memset(&pcetable_vlan, 0, sizeof(pctbl_prog_t));
+		pcetable_vlan.table	= PCE_ACTVLAN_INDEX;
+		pcetable_vlan.pcindex	= index;
+		gsw_pce_table_read(cdev, &pcetable_vlan);
+
+		if (pcetable_vlan.valid == 1) {
+			if (pcetable_vlan.key[0] == vid) {
+				vid_index = index;
+				pthandle->vlan_act_tbl_cnt[index]++;
+				break;
+			}
+		}
+	}
+
+	return vid_index;
+}
+
+static int pce_vlan_id_fid_index(void *cdev,
+				 pcetbl_prog_t *pthandle, avlan_tbl_t *vatable)
+{
+	pctbl_prog_t pcetable_vlan;
+	int	index, vid_index = 0x7F;
+
+	for (index = 0; index < PCE_VLAN_ACT_TBL_SIZE; index++) {
+		memset(&pcetable_vlan, 0, sizeof(pctbl_prog_t));
+		pcetable_vlan.table = PCE_ACTVLAN_INDEX;
+		pcetable_vlan.pcindex	= index;
+		gsw_pce_table_read(cdev, &pcetable_vlan);
+
+		if (pcetable_vlan.valid	== 1) {
+			if (pcetable_vlan.key[0]	== vatable->vid) {
+				vid_index	= index;
+				vatable->fid	= (pcetable_vlan.val[0] & 0xFF);
+				pthandle->vlan_act_tbl_cnt[index]++;
+				break;
+			}
+		}
+	}
+
+	return vid_index;
+}
+
+/* PCE Table Init routine */
+int pce_table_init(ltq_pce_table_t *ptable)
+{
+	int i;
+	PCE_ASSERT(ptable == NULL);
+	memset(&ptable->pce_sub_tbl, 0, sizeof(pcetbl_prog_t));
+	memset(&ptable->pce_tbl, 0, sizeof(pce_table_t));
+	memset(&ptable->pce_act, 0, sizeof(GSW_PCE_action_t));
+
+	for (i = 0; i < PCE_TABLE_SIZE; i++)
+		ptable->ptblused[i] = 0;
+
+	return GSW_statusOk;
+}
+
+/* PCE Table Micro Code Init routine */
+int gsw_pmicro_code_init(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t tbl_entry;
+	u16 i, j;
+	u8 Gl_Mod_Size = 0;
+	u32 no_ports = 0;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+	if (IS_VRSN_31(gswdev->gipver))
+		no_ports = gswdev->tpnum;
+	else
+		no_ports = gswdev->pnum;
+
+	printk("Enter PCE micro-code init\n");
+
+	/* Disable all physical port  */
+	for (j = 0; j < no_ports; j++) {
+		gsw_w32(cdev, (FDMA_PCTRL_EN_OFFSET + (j * 0x6)),
+			FDMA_PCTRL_EN_SHIFT, FDMA_PCTRL_EN_SIZE, 0);
+		gsw_w32(cdev, (SDMA_PCTRL_PEN_OFFSET + (j * 0x6)),
+			SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE, 0);
+	}
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		/*GSWIP 3.0*/
+		gsw_w32(cdev, (GSWT_GCTRL_SE_OFFSET + 0xF00),
+			GSWT_GCTRL_SE_SHIFT, GSWT_GCTRL_SE_SIZE, 1);
+		/*Micro code set invalid*/
+		gsw_w32(cdev, PCE_GCTRL_0_MC_VALID_OFFSET,
+			PCE_GCTRL_0_MC_VALID_SHIFT, PCE_GCTRL_0_MC_VALID_SIZE, 0x0);
+
+		/* Download the microcode  */
+		for (i = 0; i < 256 /*PCE_MICRO_TABLE_SIZE*/; i++) {
+			memset(&tbl_entry, 0, sizeof(pctbl_prog_t));
+			tbl_entry.val[3] = pce_mc_max_ifx_tag_m_30[i].val_3;
+			tbl_entry.val[2] = pce_mc_max_ifx_tag_m_30[i].val_2;
+			tbl_entry.val[1] = pce_mc_max_ifx_tag_m_30[i].val_1;
+			tbl_entry.val[0] = pce_mc_max_ifx_tag_m_30[i].val_0;
+			tbl_entry.pcindex = i;
+			tbl_entry.table = PCE_PARS_INDEX;
+			gsw_pce_table_write(cdev, &tbl_entry);
+			//pr_err("%d\t%x\t%x\t%x\t%x\n",i, tbl_entry.val[0], tbl_entry.val[1], tbl_entry.val[2], tbl_entry.val[3]);
+		}
+	} else if (IS_VRSN_31(gswdev->gipver)) {
+		/*GSWIP 3.1*/
+		/*Micro code set invalid*/
+		gsw_w32(cdev, PCE_GCTRL_0_MC_VALID_OFFSET,
+			PCE_GCTRL_0_MC_VALID_SHIFT, PCE_GCTRL_0_MC_VALID_SIZE, 0x0);
+
+		/* Download the microcode  */
+		for (i = 0; i < 256 /*PCE_MICRO_TABLE_SIZE*/; i++) {
+			memset(&tbl_entry, 0, sizeof(pctbl_prog_t));
+			tbl_entry.val[3] = pce_mc_max_ifx_tag_m_31[i].val_3;
+			tbl_entry.val[2] = pce_mc_max_ifx_tag_m_31[i].val_2;
+			tbl_entry.val[1] = pce_mc_max_ifx_tag_m_31[i].val_1;
+			tbl_entry.val[0] = pce_mc_max_ifx_tag_m_31[i].val_0;
+			tbl_entry.pcindex = i;
+			tbl_entry.table = PCE_PARS_INDEX;
+			gsw_pce_table_write(cdev, &tbl_entry);
+			//pr_err("%d\t%x\t%x\t%x\t%x\n",i, tbl_entry.val[0], tbl_entry.val[1], tbl_entry.val[2], tbl_entry.val[3]);
+		}
+
+	} else {
+		/*GSWIP 2.2*/
+		gsw_w32(cdev, (GLOB_CTRL_SE_OFFSET + 0xC40),
+			GLOB_CTRL_SE_SHIFT, GLOB_CTRL_SE_SIZE, 1);
+		/*Micro code set invalid*/
+		gsw_w32(cdev, PCE_GCTRL_0_MC_VALID_OFFSET,
+			PCE_GCTRL_0_MC_VALID_SHIFT, PCE_GCTRL_0_MC_VALID_SIZE, 0x0);
+
+		/* Download the microcode  */
+		for (i = 0; i < 64 /* PCE_MICRO_TABLE_SIZE */; i++) {
+			memset(&tbl_entry, 0, sizeof(tbl_entry));
+			tbl_entry.val[3] = pce_mc_max_ifx_tag_m[i].val_3;
+			tbl_entry.val[2] = pce_mc_max_ifx_tag_m[i].val_2;
+			tbl_entry.val[1] = pce_mc_max_ifx_tag_m[i].val_1;
+			tbl_entry.val[0] = pce_mc_max_ifx_tag_m[i].val_0;
+			tbl_entry.pcindex = i;
+			tbl_entry.table = PCE_PARS_INDEX;
+			gsw_pce_table_write(cdev, &tbl_entry);
+		}
+
+		gsw_w32(cdev, PCE_PMAP_2_DMCPMAP_OFFSET,
+			PCE_PMAP_2_DMCPMAP_SHIFT, PCE_PMAP_2_DMCPMAP_SIZE, 0x7F);
+		gsw_w32(cdev, PCE_PMAP_3_UUCMAP_OFFSET,
+			PCE_PMAP_3_UUCMAP_SHIFT, PCE_PMAP_3_UUCMAP_SIZE, 0x7F);
+	}
+
+	/*Micro code set valid*/
+	gsw_w32(cdev, PCE_GCTRL_0_MC_VALID_OFFSET,
+		PCE_GCTRL_0_MC_VALID_SHIFT, PCE_GCTRL_0_MC_VALID_SIZE, 0x1);
+
+	/* Enable RMON Counter for all ports */
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		for (j = 0; j < gswdev->pnum; j++) {
+			gsw_w32(cdev, (BM_PCFG_CNTEN_OFFSET + (j * 0x2)),
+				BM_PCFG_CNTEN_SHIFT, BM_PCFG_CNTEN_SIZE, 1);
+		}
+
+		for (j = 0; j < gswdev->pnum; j++) {
+			gsw_w32(cdev, (BM_RMON_CTRL_BCAST_CNT_OFFSET + (j * 0x2)),
+				BM_RMON_CTRL_BCAST_CNT_SHIFT, BM_RMON_CTRL_BCAST_CNT_SIZE, 1);
+		}
+	}
+
+	if ((gswdev->gipver == LTQ_GSWIP_2_2) ||
+	    (gswdev->gipver == LTQ_GSWIP_3_0) ||
+	    (IS_VRSN_31(gswdev->gipver)))
+		Gl_Mod_Size = BM_QUEUE_GCTRL_GL_MOD_SIZE2;
+	else
+		Gl_Mod_Size = BM_QUEUE_GCTRL_GL_MOD_SIZE;
+
+	gsw_w32(cdev, BM_QUEUE_GCTRL_GL_MOD_OFFSET, BM_QUEUE_GCTRL_GL_MOD_SHIFT,
+		Gl_Mod_Size, 0);
+
+	pr_err("Exit PCE micro-code init\n");
+	return GSW_statusOk;
+}
+
+int pce_action_delete(void *cdev, ltq_pce_table_t *pthandle, u32 index)
+{
+	pctbl_prog_t ptbl;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	PCE_ASSERT(index >= PCE_TABLE_SIZE);
+	memset(&ptbl, 0, sizeof(pctbl_prog_t));
+	memset(&pthandle->pce_act[index], 0, sizeof(GSW_PCE_action_t));
+	/* Remove rule action from HW */
+	ptbl.pcindex = index;
+	/* Traffic-Flow table type */
+	ptbl.table = PCE_TFLOW_INDEX;
+	//pr_err("\n Before pce table read in %s 0x%x", __func__, cdev);
+	gsw_pce_table_read(cdev, &ptbl);
+
+	if (ptbl.valid == 1) {
+		if (((ptbl.val[0] >> 1) & 0x1)  && (gswdev->gipver == LTQ_GSWIP_3_0)) {
+			u32 index = (ptbl.val[2] & 0x3F);
+			pr_err("\n VLAN action delete at % index in %s", index, __func__);
+
+			if (pthandle->pce_sub_tbl.vlan_act_tbl_cnt[index] > 0)
+				pthandle->pce_sub_tbl.vlan_act_tbl_cnt[index]--;
+		}
+	}
+
+	memset(&ptbl, 0, sizeof(pctbl_prog_t));
+	/* Remove rule action from HW */
+	ptbl.pcindex = index;
+	/* Traffic-Flow table type */
+	ptbl.table = PCE_TFLOW_INDEX;
+	ptbl.valid = 0; //Mark entry as invalid.
+	//pr_err("\n Before pce table write in %s 0x%x", __func__, cdev);
+	gsw_pce_table_write(cdev, &ptbl);
+	return GSW_statusOk;
+}
+
+#define IFX_PCE_TM_IDX_DELETE(x, y, z) { if (x != y) \
+			if (0 != z(cdev, &pthandle->pce_sub_tbl, y)) \
+				GSW_RETURN_PCE; }
+
+int pce_pattern_delete(void *cdev, ltq_pce_table_t *pthandle, u32 index)
+{
+	pce_table_t  *ptable;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	PCE_ASSERT(index >= PCE_TABLE_SIZE);
+
+	/* Check if an entry is currently programmed and remove it. */
+	if (pthandle->ptblused[index] == 0)
+		return GSW_statusOk;
+
+	ptable = &(pthandle->pce_tbl[index]);
+	/* Packet length */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->pkt_lng_idx,
+			      pce_tm_pkg_lng_tbl_delete)
+	/* Destination MAC address */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->dst_mac_addr_idx,
+			      pce_tm_da_mac_tbl_delete)
+	/* Source MAC address */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->src_mac_addr_idx,
+			      pce_tm_sa_mac_tbl_delete)
+	/* Destination Application field */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->dst_appl_fld_idx,
+			      pce_tm_appl_tbl_delete)
+	/* Source Application field */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->src_appl_fld_idx,
+			      pce_tm_appl_tbl_delete)
+	/* Parer flags field */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->parse_lsb_idx,
+			      pce_tm_flags_tbl_delete)
+	/* Parer flags field */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->parse_msb_idx,
+			      pce_tm_flags_tbl_delete)
+	/* Parer flags field */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->parse1_lsb_idx,
+			      pce_tm_flags_tbl_delete)
+	/* Parer flags field */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->parse1_msb_idx,
+			      pce_tm_flags_tbl_delete)
+	/* Payload1 field */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->payload1_idx,
+			      pce_tm_payload_tbl_delete)
+	/* payload2 field */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->payload2_idx,
+			      pce_tm_payload_tbl_delete)
+	/* DIP MSB */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->dip_msb_idx,
+			      ip_dasa_msb_tbl_del)
+	/* Inner DIP MSB */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->inr_dip_msb_idx,
+			      ip_dasa_msb_tbl_del)
+	/* DIP LSB */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->dip_lsb_idx,
+			      ip_dasa_lsb_tbl_del)
+	/* Inner DIP LSB */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->inr_dip_lsb_idx,
+			      ip_dasa_lsb_tbl_del)
+	/* SIP MSB */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->sip_msb_idx,
+			      ip_dasa_msb_tbl_del)
+	/* Inner SIP MSB */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->inr_sip_msb_idx,
+			      ip_dasa_msb_tbl_del)
+	/* SIP LSB */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->sip_lsb_idx,
+			      ip_dasa_lsb_tbl_del)
+	/* Inner SIP LSB */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->inr_sip_lsb_idx,
+			      ip_dasa_lsb_tbl_del)
+	/* IP protocol */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->ip_prot_idx,
+			      pce_tm_ptcl_tbl_delete)
+	/* Ethertype */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->ethertype_idx,
+			      pce_tm_ptcl_tbl_delete)
+	/*  PPP Protocol */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->ppp_prot_idx,
+			      pce_tm_ptcl_tbl_delete)
+	/* PPPoE */
+	IFX_PCE_TM_IDX_DELETE(0xFF, ptable->pppoe_idx,
+			      pce_tm_pppoe_tbl_delete)
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		/* VLAN */
+		IFX_PCE_TM_IDX_DELETE(0x7F, ptable->vlan_idx,
+				      pce_tm_vlan_act_tbl_delete)
+		/* SVLAN */
+		IFX_PCE_TM_IDX_DELETE(0x7F, ptable->svlan_idx,
+				      pce_tm_vlan_act_tbl_delete)
+	}
+
+	/* Mark this TFLOW entry as unused */
+	pthandle->ptblused[index] = 0;
+	/* Mark all tables in TFLOW to invalid */
+	memset(ptable, 0xFF, sizeof(pce_table_t));
+	/* Delete the action for this rule */
+	pce_action_delete(cdev, pthandle, index);
+	//Delete the associated counters if any.
+
+	return GSW_statusOk;
+}
+
+int pce_rule_read(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32   i, j, idx = parm->pattern.nIndex;
+	pce_table_t  *ptable;
+	static pctbl_prog_t ptbl;
+	PCE_ASSERT(idx >= PCE_TABLE_SIZE);
+	/* Initialize to zero */
+	memset(parm, 0, sizeof(GSW_PCE_rule_t));
+	memset(&ptbl, 0, sizeof(pctbl_prog_t));
+	parm->pattern.nIndex = idx; //Table entry to read
+
+	if (pthandle->ptblused[idx] == 0)
+		return GSW_statusOk; //Return if entry is not in use
+	else
+		parm->pattern.bEnable = 1;
+
+	ptbl.table = PCE_TFLOW_INDEX; //TFLOW table type to read
+	ptbl.pcindex = idx; //Table entry to read
+	gsw_pce_table_read(cdev, &ptbl); //Read given entry
+
+	/* Exclude flags */
+	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		if ((ptbl.key[15] >> 0) & 0x1)
+			parm->pattern.bDstMAC_Exclude = 1;
+
+		if ((ptbl.key[15] >> 1) & 0x1)
+			parm->pattern.bCTAG_PCP_DEI_Exclude = 1;
+
+		if ((ptbl.key[15] >> 2) & 0x1)
+			parm->pattern.bSTAG_PCP_DEI_Exclude = 1;
+
+		if ((ptbl.key[15] >> 3) & 0x1)
+			parm->pattern.bDSCP_Exclude = 1;
+
+		if ((ptbl.key[15] >> 4) & 0x1)
+			parm->pattern.bPktLng_Exclude = 1;
+
+		if ((ptbl.key[15] >> 5) & 0x1)
+			parm->pattern.bSessionId_Exclude = 1;
+
+		if ((ptbl.key[15] >> 6) & 0x1)
+			parm->pattern.bSLANVid_Exclude = 1;
+
+		if ((ptbl.key[15] >> 7) & 0x1)
+			parm->pattern.bPPP_Protocol_Exclude = 1;
+
+		if ((ptbl.key[15] >> 8) & 0x1)
+			parm->pattern.bInnerDSCP_Exclude = 1;
+
+		if ((ptbl.key[15] >> 9) & 0x1)
+			parm->pattern.bInnerSrcIP_Exclude = 1;
+
+		if ((ptbl.key[15] >> 10) & 0x1)
+			parm->pattern.bInnerDstIP_Exclude = 1;
+
+		if ((ptbl.key[15] >> 11) & 0x1)
+			parm->pattern.bParserFlagLSB_Exclude = 1;
+
+		if ((ptbl.key[15] >> 12) & 0x1)
+			parm->pattern.bParserFlagMSB_Exclude = 1;
+
+		if ((ptbl.key[15] >> 13) & 0x1)
+			parm->pattern.bPayload1_Exclude = 1;
+
+		if ((ptbl.key[15] >> 14) & 0x1)
+			parm->pattern.bPayload2_Exclude = 1;
+
+		if ((ptbl.key[15] >> 15) & 0x1)
+			parm->pattern.bSubIfId_Exclude = 1;
+
+		if (IS_VRSN_31(gswdev->gipver)) {
+			if ((ptbl.key[14] >> 5) & 0x1)
+				parm->pattern.bParserFlag1LSB_Exclude = 1;
+
+			if ((ptbl.key[14] >> 6) & 0x1)
+				parm->pattern.bParserFlag1MSB_Exclude = 1;
+		}
+
+		if ((ptbl.key[14] >> 7) & 0x1)
+			parm->pattern.bPortId_Exclude = 1;
+
+		if ((ptbl.key[14] >> 8) & 0x1)
+			parm->pattern.bVid_Exclude = 1;
+
+		if ((ptbl.key[14] >> 9) & 0x1)
+			parm->pattern.bEtherType_Exclude = 1;
+
+		if ((ptbl.key[14] >> 10) & 0x1)
+			parm->pattern.bProtocol_Exclude = 1;
+
+		if ((ptbl.key[14] >> 11) & 0x1)
+			parm->pattern.bSrcIP_Exclude = 1;
+
+		if ((ptbl.key[14] >> 12) & 0x1)
+			parm->pattern.bDstIP_Exclude = 1;
+
+		if ((ptbl.key[14] >> 13) & 0x1)
+			parm->pattern.bAppMSB_Exclude = 1;
+
+		if ((ptbl.key[14] >> 14) & 0x1)
+			parm->pattern.bAppLSB_Exclude = 1;
+
+		if ((ptbl.key[14] >> 15) & 0x1)
+			parm->pattern.bSrcMAC_Exclude = 1;
+
+		/*Sub -Interface id 3.0*/
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			if ((ptbl.key[14] & 0x1F) != 0x1F) { //Is pattern enabled?
+				parm->pattern.nSubIfId = ptbl.key[14] & 0xF;
+				parm->pattern.bSubIfIdEnable = 1;
+			}
+		}
+
+		/*Sub -Interface id 3.1*/
+		if (IS_VRSN_31(gswdev->gipver)) {
+			if ((ptbl.key[17] & 0x1FF) != 0x1FF) {  //Is pattern enabled?
+				parm->pattern.nSubIfId = ptbl.key[17] & 0xFF;
+				parm->pattern.bSubIfIdEnable = 1;
+
+				if ((ptbl.key[17] >> 9) & 0x1)
+					parm->pattern.eSubIfIdType =
+						GSW_PCE_SUBIFID_TYPE_BRIDGEPORT;
+				else
+					parm->pattern.eSubIfIdType = GSW_PCE_SUBIFID_TYPE_GROUP;
+			}
+
+			/* CPU injected traffic flag */
+			if (((ptbl.key[17] >> 10) & 0x3) != 3) {
+				parm->pattern.bInsertionFlag_Enable = 1;
+				parm->pattern.nInsertionFlag = ((ptbl.key[17] >> 10) & 0x3);
+			}
+		}
+	}
+
+	/* Port ID field value */
+	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		if ((ptbl.key[0] & 0x1F) != 0x1F) { //Is pattern enabled?
+			parm->pattern.nPortId = ptbl.key[0] & 0xF;
+			parm->pattern.bPortIdEnable = 1;
+		}
+	} else if (gswdev->gipver == LTQ_GSWIP_2_2) {
+		if ((ptbl.key[0] & 0xF) != 0xF) { //Is pattern enabled?
+			parm->pattern.nPortId = ptbl.key[0] & 0x7;
+			parm->pattern.bPortIdEnable = 1;
+		}
+	}
+
+	/* Outer DSCP field value */
+	if (((ptbl.key[6] >> 8) & 0x7F) != 0x7F) { //Is pattern enabled?
+		parm->pattern.nDSCP = (ptbl.key[6] >> 8) & 0x3F;
+		parm->pattern.bDSCP_Enable = 1;
+	}
+
+	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		/* Inner DSCP field value */
+		if (((ptbl.key[9] >> 8) & 0x7F) != 0x7F) { //Is pattern enabled?
+			parm->pattern.nInnerDSCP = (ptbl.key[9] >> 8) & 0x3F;
+			parm->pattern.bInner_DSCP_Enable = 1;
+		}
+
+		/* Port filer type action value */
+		parm->action.ePortFilterType_Action = (ptbl.val[7] >> 1) & 0x3F;
+
+		if (parm->action.ePortFilterType_Action == 4)
+			parm->action.ePortFilterType_Action = GSW_PCE_PORT_FILTER_ACTION_3;
+		else if (parm->action.ePortFilterType_Action == 8)
+			parm->action.ePortFilterType_Action = GSW_PCE_PORT_FILTER_ACTION_4;
+		else if (parm->action.ePortFilterType_Action == 16)
+			parm->action.ePortFilterType_Action = GSW_PCE_PORT_FILTER_ACTION_5;
+		else if (parm->action.ePortFilterType_Action == 32)
+			parm->action.ePortFilterType_Action = GSW_PCE_PORT_FILTER_ACTION_6;
+
+		//GEt the port-member map.
+		if (parm->action.ePortFilterType_Action) {
+			for (i = 0; i <= 7; i++)
+				parm->action.nForwardPortMap[i] = ptbl.val[i + 10];
+		}
+
+		/* Processing path type action value */
+		if (ptbl.val[8] & 0x1)
+			parm->action.eProcessPath_Action = (ptbl.val[8] >> 1) & 0x3;
+
+		/* L3 Routing type action value */
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+				parm->action.bRtCtrlEna_Action = ptbl.val[9] & 0x1;
+				parm->action.bRtAccelEna_Action = (ptbl.val[9] >> 1) & 0x1;
+				parm->action.bRtInnerIPasKey_Action = (ptbl.val[9] >> 2) & 0x1;
+
+				if ((ptbl.val[9] >> 3) & 0x1)
+					parm->action.bRtSrcIpMaskCmp_Action = 0;
+				else
+					parm->action.bRtSrcIpMaskCmp_Action = 1;
+
+				if ((ptbl.val[9] >> 4) & 0x1)
+					parm->action.bRtDstIpMaskCmp_Action = 0;
+				else
+					parm->action.bRtDstIpMaskCmp_Action = 1;
+
+				if ((ptbl.val[9] >> 5) & 0x1)
+					parm->action.bRtSrcPortMaskCmp_Action = 0;
+				else
+					parm->action.bRtSrcPortMaskCmp_Action = 1;
+
+				if ((ptbl.val[9] >> 6) & 0x1)
+					parm->action.bRtDstPortMaskCmp_Action = 0;
+				else
+					parm->action.bRtDstPortMaskCmp_Action = 1;
+
+				if (((ptbl.val[9] >> 8) & 0xFF) != 0xFF) {
+					parm->action.bRoutExtId_Action = 1;
+					parm->action.nRoutExtId = (ptbl.val[9] >> 8) & 0xFF;
+				}
+			}
+
+			/* Flow ID action value */
+			if ((ptbl.val[4] >> 4) & 0x1) {
+				parm->action.bFlowID_Action = 1;
+				parm->action.nFlowID = ptbl.val[1];
+			}
+		}
+
+		/* Trunk port, port link selection action value */
+		parm->action.bPortLinkSelection = (ptbl.val[5] >> 1) & 0x1;
+		parm->action.bPortTrunkAction = (ptbl.val[5] >> 0) & 0x1;
+
+		/* Cross VLAN action value */
+		if ((ptbl.val[0] >> 4) & 0x1) {
+			if ((ptbl.val[3] >> 15) & 0x1)
+				parm->action.eVLAN_CrossAction =
+					GSW_PCE_ACTION_CROSS_VLAN_CROSS;
+			else
+				parm->action.eVLAN_CrossAction =
+					GSW_PCE_ACTION_CROSS_VLAN_REGULAR;
+		}
+
+		/* Applicable for 3.0*/
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			parm->action.bPortBitMapMuxControl = (ptbl.val[6] >> 0) & 0x1;
+
+			if (parm->action.bPortBitMapMuxControl)
+				parm->action.nForwardPortMap[0] = ptbl.val[1];
+
+			if (((ptbl.val[5] >> 2) & 0x1) 	&& ((ptbl.val[0] >> 1) & 0x1))
+				parm->action.bCVLAN_Ignore_Control = 1;
+
+			if ((ptbl.val[0] >> 1) & 0x1) {
+				parm->action.eSVLAN_Action = 1;
+				parm->action.nSVLAN_Id = (ptbl.val[6] >> 4) & 0xFFF;
+				//parm->action.nFId = ((ptbl.val[2] >> 8) & 0xFF);
+			}
+
+			if ((ptbl.val[0] >> 1) & 0x1) { //Govind - 3.0 same flag for both eVLAN_Action n eSVLAN_Action?
+				parm->action.eVLAN_Action = 1;
+				parm->action.nVLAN_Id = (ptbl.val[5] >> 4) & 0xFFF;
+				parm->action.nFId = ((ptbl.val[2] >> 8) & 0xFF);
+			}
+		}
+
+		//Extended VLAN tagging action.
+		if (IS_VRSN_31(gswdev->gipver)) {
+			if ((ptbl.val[6] >> 3) & 0x1) {
+				parm->action.bExtendedVlanEnable = 1; //Enable extended VLAN tagging.
+				parm->action.nExtendedVlanBlockId = (ptbl.val[6] >> 4) & 0x3FF;
+			}
+		}
+
+		/* Applicable for 3.0*/
+		if (IS_VRSN_NOT_31(gswdev->gipver)) {
+			if ((ptbl.val[0] >> 12) & 0x1) {
+				parm->action.bRMON_Action = 1;
+				parm->action.nRMON_Id = (((ptbl.val[4] >> 8) & 0x1F) - 1);
+			}
+
+			if ((ptbl.val[0] >> 11) & 0x1) {
+				parm->action.eMeterAction = (ptbl.val[3] >> 6) & 0x3;
+				parm->action.nMeterId = ptbl.val[3] & 0x1F;
+			}
+
+			if (!((ptbl.val[3] >> 13) & 0x1))
+				parm->action.bRemarkClass = 1;
+
+			if (!((ptbl.val[3] >> 12) & 0x1))
+				parm->action.bRemarkDSCP = 1;
+
+			if (!((ptbl.val[6] >> 2) & 0x1))
+				parm->action.bRemarkSTAG_DEI = 1;
+
+			if (!((ptbl.val[6] >> 1) & 0x1))
+				parm->action.bRemarkSTAG_PCP = 1;
+
+			if (!((ptbl.val[3] >> 14) & 0x1))
+				parm->action.bRemarkPCP = 1;
+
+			if ((ptbl.val[0] >> 3) & 0x1)
+				parm->action.bRemarkAction = 1;
+
+			if ((ptbl.val[0] >> 6) & 0x1) {
+				if ((ptbl.val[4] >> 14) & 0x1)
+					parm->action.eCritFrameAction =
+						GSW_PCE_ACTION_CRITICAL_FRAME_CRITICAL;
+				else
+					parm->action.eCritFrameAction =
+						GSW_PCE_ACTION_CRITICAL_FRAME_REGULAR;
+			}
+		}
+
+		/* RMON counter action value */
+		if (IS_VRSN_31(gswdev->gipver)) {
+			if ((ptbl.val[4] >> 4) & 0x1) {
+				parm->action.bRMON_Action = parm->action.bFlowID_Action = 1;
+				parm->action.nRMON_Id = parm->action.nFlowID =
+								ptbl.val[1] & 0xFF;
+			}
+
+			/* Metering and counter action value */
+			if ((ptbl.val[0] >> 11) & 0x1) {
+				if ((ptbl.val[3] >> 7) & 0x1) {
+					parm->action.eMeterAction = GSW_PCE_ACTION_METER_1;
+					parm->action.nMeterId = ptbl.val[3] & 0x7F;
+				} else {
+					parm->action.eMeterAction = GSW_PCE_ACTION_METER_REGULAR;
+				}
+			}
+
+			/* FID action control */
+			if ((ptbl.val[5] >> 3) & 0x1) {
+				parm->action.bFidEnable = 1;
+				parm->action.nFId = (ptbl.val[2] >> 8) & 0x3F;
+			}
+		}
+
+		/* Applicable for 3.0*/
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			if (ptbl.val[0] & 0x1) { //If port-map action set.
+				if (ptbl.val[1] == 0x0) { //If port-map IDs not set.
+					if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
+						//If port-map type is 'tflow'.
+						parm->action.ePortMapAction =
+							GSW_PCE_ACTION_PORTMAP_DISCARD;
+					} else if (((ptbl.val[4] >> 2) & 0x3) == 0x0) {
+						//If port-map type is 'default'.
+						parm->action.ePortMapAction =
+							GSW_PCE_ACTION_PORTMAP_REGULAR;
+					}
+				} else if (ptbl.val[1] != 0x0) { //If port-map IDs set.
+					parm->action.nForwardPortMap[0] = ptbl.val[1];
+
+					if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
+						//If port-map type is 'tflow'.
+						parm->action.ePortMapAction =
+							GSW_PCE_ACTION_PORTMAP_ALTERNATIVE;
+					} else if ((((ptbl.val[4] >> 2) & 0x3) == 0x1)) {
+						//If port-map type is 'MC router'.
+						parm->action.ePortMapAction =
+							GSW_PCE_ACTION_PORTMAP_CPU;
+					}
+				}
+			}
+		}
+
+		/* Applicable for 3.1*/
+		if (IS_VRSN_31(gswdev->gipver)) {
+			if (ptbl.val[0] & 0x1) { //If port-map action set.
+				if (!(ptbl.val[10]) && !(ptbl.val[11]) && !(ptbl.val[12]) &&
+				    !(ptbl.val[13]) && !(ptbl.val[14]) && !(ptbl.val[15]) &&
+				    !(ptbl.val[16]) && !(ptbl.val[17])) {
+					//If port-map IDs not set.
+					if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
+						//If port-map type is 'tflow'.
+						parm->action.ePortMapAction =
+							GSW_PCE_ACTION_PORTMAP_DISCARD;
+					} else if (((ptbl.val[4] >> 2) & 0x3) == 0x0) {
+						//If port-map type is 'default'.
+						parm->action.ePortMapAction =
+							GSW_PCE_ACTION_PORTMAP_REGULAR;
+					}
+				} else if (((ptbl.val[10]) || (ptbl.val[11]) || (ptbl.val[12])) &&
+					   ((ptbl.val[13]) || (ptbl.val[14]) || (ptbl.val[15])) &&
+					   ((ptbl.val[16]) || (ptbl.val[17]))) {
+					/* It is 'traffic-flow' portmap type */
+					for (i = 0; i <= 7; i++)
+						parm->action.nForwardPortMap[i] = ptbl.val[i + 10];
+
+					if (((ptbl.val[4] >> 2) & 0x3) == 0x3) {
+						//If port-map type is 'tflow'.
+						parm->action.ePortMapAction =
+							GSW_PCE_ACTION_PORTMAP_ALTERNATIVE;
+					} else if (((ptbl.val[4] >> 2) & 0x3) == 0x1) {
+						//If port-map type is 'MC router'.
+						parm->action.ePortMapAction =
+							GSW_PCE_ACTION_PORTMAP_CPU;
+					}
+				}
+			}
+		}
+
+		/* Color action */
+		if (IS_VRSN_31(gswdev->gipver)) {
+			if ((ptbl.val[0] >> 6) & 0x1) {
+				if ((ptbl.val[2] & 0x7) < 4) {
+					parm->action.eColorFrameAction =
+						GSW_PCE_ACTION_COLOR_FRAME_NO_CHANGE;
+				} else {
+					parm->action.eColorFrameAction = (ptbl.val[2] & 0x7) - 2;
+				}
+			}
+		}
+
+		/* TS action control */
+		if ((ptbl.val[0] >> 7) & 0x1) {
+			if ((ptbl.val[4] >> 15) & 0x1) {
+				parm->action.eTimestampAction = GSW_PCE_ACTION_TIMESTAMP_STORED;
+				parm->action.nRecordId = ((ptbl.val[8] >> 4) & 0xFFF);
+			} else
+				parm->action.eTimestampAction = GSW_PCE_ACTION_TIMESTAMP_REGULAR;
+
+		} else
+			parm->action.eTimestampAction = GSW_PCE_ACTION_TIMESTAMP_DISABLE;
+
+		/* Cross state action control */
+		if ((ptbl.val[0] >> 5) & 0x1) {
+			if ((ptbl.val[4] >> 13) & 0x1)
+				parm->action.eCrossStateAction =
+					GSW_PCE_ACTION_CROSS_STATE_CROSS;
+			else
+				parm->action.eCrossStateAction =
+					GSW_PCE_ACTION_CROSS_STATE_REGULAR;
+		} else
+			parm->action.eCrossStateAction = GSW_PCE_ACTION_CROSS_STATE_DISABLE;
+
+		/* Interrupt Request Queue action control */
+		if ((ptbl.val[0] >> 8) & 0x1) {
+			if ((ptbl.val[0] >> 15) & 0x1)
+				parm->action.eIrqAction = GSW_PCE_ACTION_IRQ_EVENT;
+			else
+				parm->action.eIrqAction = GSW_PCE_ACTION_IRQ_REGULAR;
+		} else
+			parm->action.eIrqAction = GSW_PCE_ACTION_IRQ_DISABLE;
+
+		/* MAC learning action control */
+		if ((ptbl.val[0] >> 9) & 0x1) {
+			if (((ptbl.val[4]) & 0x3) == 0)
+				parm->action.eLearningAction = GSW_PCE_ACTION_LEARNING_REGULAR;
+			else if (((ptbl.val[4]) & 0x3) == 1)
+				parm->action.eLearningAction = GSW_PCE_ACTION_LEARNING_DISABLE;
+			else
+				parm->action.eLearningAction = (ptbl.val[4]) & 0x3;
+		}
+
+		/* IGMP snooping action control */
+		if ((ptbl.val[0] >> 10) & 0x1)
+			parm->action.eSnoopingTypeAction = ((ptbl.val[4] >> 5) & 0x7) + 1;
+
+		/* Traffic class action control */
+		if ((ptbl.val[0] >> 2) & 1) {
+			if ((ptbl.val[0] >> 14) & 1) {
+				parm->action.eTrafficClassAction =
+					GSW_PCE_ACTION_TRAFFIC_CLASS_ALTERNATIVE;
+				parm->action.nTrafficClassAlternate = (ptbl.val[3] >> 8) & 0xF;
+			} else
+				parm->action.eTrafficClassAction =
+					GSW_PCE_ACTION_TRAFFIC_CLASS_REGULAR;
+		}
+	}
+
+	/* Inner CoS & DEI field value for 3.0 */
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (((ptbl.key[6]) & 0xF) != 0xF) {
+			parm->pattern.nPCP = (ptbl.key[6]) & 0x7;
+			parm->pattern.bPCP_Enable = 1;
+		}
+	}
+
+	/* Inner CoS & DEI field value for 3.1 */
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if (((ptbl.key[6]) & 0x1F) != 0x1F) { //Is pattern enabled?
+			parm->pattern.nPCP = (ptbl.key[6]) & 0xF;
+			parm->pattern.bPCP_Enable = 1;
+		}
+	}
+
+	/* Outer CoS & DEI field value */
+	if (((ptbl.key[8]) & 0x1F) != 0x1F) { //Is pattern enabled?
+		parm->pattern.nSTAG_PCP_DEI = (ptbl.key[8]) & 0xF;
+		parm->pattern.bSTAG_PCP_DEI_Enable = 1;
+	}
+
+	/* Packet length field table */
+	ptable = &(pthandle->pce_tbl[idx]);
+
+	if (ptable->pkt_lng_idx != 0xFF) { //Is table enabled?
+		pce_pkt_length_t pkg_lng_tbl;
+		memset(&pkg_lng_tbl, 0, sizeof(pce_pkt_length_t));
+		/* Packet length used */
+		parm->pattern.bPktLngEnable = 1;
+
+		if (0 != pce_tm_pkg_lng_tbl_read(&pthandle->pce_sub_tbl,
+						 ptable->pkt_lng_idx, &pkg_lng_tbl))
+			GSW_RETURN_PCE;
+
+		/* Packet length */
+		parm->pattern.nPktLng = pkg_lng_tbl.pkg_lng;
+		/* Packet length Range */
+		parm->pattern.nPktLngRange = pkg_lng_tbl.pkg_lng_rng;
+	}
+
+	/* DMAC field table */
+	if (ptable->dst_mac_addr_idx != 0xFF) { //Is table enabled?
+		pce_da_prog_t da_mac_tbl;
+		memset(&da_mac_tbl, 0, sizeof(pce_da_prog_t));
+
+		if (0 != pce_tm_da_mac_tbl_read(&pthandle->pce_sub_tbl,
+						ptable->dst_mac_addr_idx, &da_mac_tbl))
+			GSW_RETURN_PCE;
+
+		/* Destination MAC address used */
+		parm->pattern.bMAC_DstEnable = 1;
+
+		/* Destination MAC address */
+		for (i = 0; i < 6; i++)
+			parm->pattern.nMAC_Dst[i] = da_mac_tbl.mac[i];
+
+		/* Destination MAC address mask */
+		parm->pattern.nMAC_DstMask = da_mac_tbl.mac_mask;
+	}
+
+	/* SMAC field table */
+	if (ptable->src_mac_addr_idx != 0xFF) { //Is table enabled?
+		pce_sa_prog_t sa_mac_tbl;
+		memset(&sa_mac_tbl, 0, sizeof(pce_sa_prog_t));
+
+		if (0 != pce_tm_sa_mac_tbl_read(&pthandle->pce_sub_tbl,
+						ptable->src_mac_addr_idx, &sa_mac_tbl))
+			GSW_RETURN_PCE;
+
+		/* Destination MAC address used */
+		parm->pattern.bMAC_SrcEnable = 1;
+
+		/* Destination MAC address */
+		for (i = 0; i < 6; i++)
+			parm->pattern.nMAC_Src[i] = sa_mac_tbl.mac[i];
+
+		/* Destination MAC address mask */
+		parm->pattern.nMAC_SrcMask = sa_mac_tbl.mac_mask;
+	}
+
+	/* Payload1 field table */
+	if (ptable->payload1_idx != 0xFF) { //Is table enabled?
+		payload_tbl_t payload_tbl;
+		memset(&payload_tbl, 0, sizeof(payload_tbl_t));
+
+		if (0 != pce_tm_payload_tbl_read(&pthandle->pce_sub_tbl,
+						 ptable->payload1_idx, &payload_tbl))
+			GSW_RETURN_PCE;
+
+		/* Destination Application used */
+		parm->pattern.bPayload1_SrcEnable = 1;
+		/* Destination Application field */
+		parm->pattern.nPayload1 = payload_tbl.payload_data;
+		/* Payload  mask/range used */
+		parm->pattern.bPayload1MaskRange_Select = payload_tbl.mask_range_type;
+		/* Payload  mask/range */
+		parm->pattern.nPayload1_Mask = payload_tbl.mask_range;
+	}
+
+	/* Payload2 field table */
+	if (ptable->payload2_idx != 0xFF) { //Is table enabled?
+		payload_tbl_t payload_tbl;
+		memset(&payload_tbl, 0, sizeof(payload_tbl_t));
+
+		if (0 != pce_tm_payload_tbl_read(&pthandle->pce_sub_tbl,
+						 ptable->payload2_idx, &payload_tbl))
+			GSW_RETURN_PCE;
+
+		/* Destination Application used */
+		parm->pattern.bPayload2_SrcEnable = 1;
+		/* Destination Application field */
+		parm->pattern.nPayload2 = payload_tbl.payload_data;
+		/* Payload  mask/range used */
+		parm->pattern.bPayload2MaskRange_Select = payload_tbl.mask_range_type;
+		/* Payload  mask/range */
+		parm->pattern.nPayload2_Mask = payload_tbl.mask_range;
+	}
+
+	/* Application field table */
+	if (ptable->dst_appl_fld_idx != 0xFF) { //Is table enabled?
+		app_tbl_t appl_tbl;
+		memset(&appl_tbl, 0, sizeof(app_tbl_t));
+
+		if (0 != pce_tm_appl_tbl_read(&pthandle->pce_sub_tbl,
+					      ptable->dst_appl_fld_idx, &appl_tbl))
+			GSW_RETURN_PCE;
+
+		/* Destination Application used */
+		parm->pattern.bAppDataMSB_Enable = 1;
+		/* Destination Application field */
+		parm->pattern.nAppDataMSB = appl_tbl.appl_data;
+		/* Destination Application mask/range used */
+		parm->pattern.bAppMaskRangeMSB_Select = appl_tbl.mask_range_type;
+		/* Destination Application mask/range */
+		parm->pattern.nAppMaskRangeMSB = appl_tbl.mask_range;
+	}
+
+	/* Application field table */
+	if (ptable->src_appl_fld_idx != 0xFF) { //Is table enabled?
+		app_tbl_t appl_tbl;
+		memset(&appl_tbl, 0, sizeof(app_tbl_t));
+
+		if (0 != pce_tm_appl_tbl_read(&pthandle->pce_sub_tbl,
+					      ptable->src_appl_fld_idx, &appl_tbl))
+			GSW_RETURN_PCE;
+
+		/* Source Application used */
+		parm->pattern.bAppDataLSB_Enable = 1;
+		/* Source Application field */
+		parm->pattern.nAppDataLSB = appl_tbl.appl_data;
+		/* Destination Application mask/range used */
+		parm->pattern.bAppMaskRangeLSB_Select = appl_tbl.mask_range_type;
+		/* Source Application mask/range */
+		parm->pattern.nAppMaskRangeLSB = appl_tbl.mask_range;
+	}
+
+	/* Parser flags field table */
+	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		if (ptable->parse_lsb_idx != 0xFF) { //Is table enabled?
+			flag_tbl_t flags_tbl;
+			memset(&flags_tbl, 0, sizeof(flag_tbl_t));
+
+			if (0 != pce_tm_flags_tbl_read(&pthandle->pce_sub_tbl,
+						       ptable->parse_lsb_idx, &flags_tbl))
+				GSW_RETURN_PCE;
+
+			parm->pattern.bParserFlagLSB_Enable = 1;
+			parm->pattern.nParserFlagLSB = flags_tbl.parser_flag_data;
+			parm->pattern.nParserFlagLSB_Mask = flags_tbl.mask_value;
+		}
+
+		if (ptable->parse_msb_idx != 0xFF) { //Is table enabled?
+			flag_tbl_t flags_tbl;
+			memset(&flags_tbl, 0, sizeof(flag_tbl_t));
+
+			if (0 != pce_tm_flags_tbl_read(&pthandle->pce_sub_tbl,
+						       ptable->parse_msb_idx, &flags_tbl))
+				GSW_RETURN_PCE;
+
+			parm->pattern.bParserFlagMSB_Enable = 1;
+			parm->pattern.nParserFlagMSB = flags_tbl.parser_flag_data;
+			parm->pattern.nParserFlagMSB_Mask = flags_tbl.mask_value;
+		}
+
+		/* Parser flags field table extend */
+		if (IS_VRSN_31(gswdev->gipver)) {
+			if (ptable->parse1_lsb_idx != 0xFF) { //Is table enabled?
+				flag_tbl_t flags_tbl;
+				memset(&flags_tbl, 0, sizeof(flag_tbl_t));
+
+				if (0 != pce_tm_flags_tbl_read(&pthandle->pce_sub_tbl,
+							       ptable->parse1_lsb_idx, &flags_tbl))
+					GSW_RETURN_PCE;
+
+				parm->pattern.bParserFlag1LSB_Enable = 1;
+				parm->pattern.nParserFlag1LSB = flags_tbl.parser_flag_data;
+				parm->pattern.nParserFlag1LSB_Mask = flags_tbl.mask_value;
+			}
+
+			if (ptable->parse1_msb_idx != 0xFF) { //Is table enabled?
+				flag_tbl_t flags_tbl;
+				memset(&flags_tbl, 0, sizeof(flag_tbl_t));
+
+				if (0 != pce_tm_flags_tbl_read(&pthandle->pce_sub_tbl,
+							       ptable->parse1_msb_idx, &flags_tbl))
+					GSW_RETURN_PCE;
+
+				parm->pattern.bParserFlag1MSB_Enable = 1;
+				parm->pattern.nParserFlag1MSB = flags_tbl.parser_flag_data;
+				parm->pattern.nParserFlag1MSB_Mask = flags_tbl.mask_value;
+			}
+		}
+	}
+
+	/* Inner DIP n SIP field table */
+	if ((gswdev->gipver == LTQ_GSWIP_3_0) ||
+	    (IS_VRSN_31(gswdev->gipver))) {
+		/* DIP field table */
+		if ((ptable->inr_dip_msb_idx != 0xFF)
+		    && (ptable->inr_dip_lsb_idx != 0xFF)) { //IPv6
+			pce_dasa_msb_t dasa_tbl;
+			pce_dasa_lsb_t dasa_tbl_lsb;
+			int i, j;
+			memset(&dasa_tbl, 0, sizeof(pce_dasa_msb_t));
+			memset(&dasa_tbl_lsb, 0, sizeof(pce_dasa_lsb_t));
+			/* Inner DIP MS8B used */
+			parm->pattern.eInnerDstIP_Select = GSW_PCE_IP_V6;
+
+			if (0 != pce_dasa_msb_tbl_read(&pthandle->pce_sub_tbl,
+						       ptable->inr_dip_msb_idx, &dasa_tbl))
+				GSW_RETURN_PCE;
+
+			/* Populate inner DIP MS8B */
+			for (i = 0, j = 7; i < 4; i++, j -= 2)
+				parm->pattern.nInnerDstIP.nIPv6[i]	=
+					(((dasa_tbl.imsb[j] & 0xFF) << 8)
+					 | (dasa_tbl.imsb[j - 1] & 0xFF));
+
+			/* Inner DIP MS8B nibble mask */
+			for (i = 0; i < 4; i++) {
+				for (j = 0; j < 4; j++) {
+					if (((dasa_tbl.mask[i] >> (j * 4)) & 0xF) == 0xF)
+						parm->pattern.nInnerDstIP_Mask |=
+							(1 << ((i * 4) + j + 16));
+				}
+			}
+
+			/* Inner DIP LS8B used */
+			parm->pattern.eInnerDstIP_Select = GSW_PCE_IP_V6;
+
+			if (0 != pce_dasa_lsb_tbl_read(&pthandle->pce_sub_tbl,
+						       ptable->inr_dip_lsb_idx, &dasa_tbl_lsb))
+				GSW_RETURN_PCE;
+
+			/* Populate inner DIP LS8B */
+			for (i = 0, j = 7; i < 4; i++, j -= 2)
+				parm->pattern.nInnerDstIP.nIPv6[i + 4]	=
+					(((dasa_tbl_lsb.ilsb[j] & 0xFF) << 8)
+					 | (dasa_tbl_lsb.ilsb[j - 1] & 0xFF));
+
+			/* Inner DIP LS8B nibble mask */
+			for (i = 0; i < 4; i++) {
+				for (j = 0; j < 4; j++) {
+					if (((dasa_tbl_lsb.mask[i] >> (j * 4)) & 0xF) == 0xF)
+						parm->pattern.nInnerDstIP_Mask |=
+							(1 << ((i * 4) + j));
+				}
+			}
+		} else if (ptable->inr_dip_lsb_idx != 0xFF) { //IPv4
+			pce_dasa_lsb_t dasa_tbl;
+			memset(&dasa_tbl, 0, sizeof(pce_dasa_lsb_t));
+			/*Inner DIP used */
+			parm->pattern.eInnerDstIP_Select = GSW_PCE_IP_V4;
+
+			if (0 != pce_dasa_lsb_tbl_read(&pthandle->pce_sub_tbl,
+						       ptable->inr_dip_lsb_idx, &dasa_tbl))
+				GSW_RETURN_PCE;
+
+			/* Inner DIP used */
+			parm->pattern.nInnerDstIP.nIPv4 = (dasa_tbl.ilsb[0]
+							   | (dasa_tbl.ilsb[1] << 8)
+							   | (dasa_tbl.ilsb[2] << 16)
+							   | (dasa_tbl.ilsb[3] << 24));
+
+			/* Inner DIP nibble mask */
+			for (i = 0; i < 2; i++) {
+				for (j = 0; j < 4; j++) {
+					if (((dasa_tbl.mask[i] >> (j * 4)) & 0xF) == 0xF)
+						parm->pattern.nInnerDstIP_Mask |=
+							(1 << ((i * 4) + j));
+				}
+			}
+
+			parm->pattern.nInnerDstIP_Mask |= 0xFF00;
+		}
+
+		/* SIP field table */
+		if ((ptable->inr_sip_msb_idx != 0xFF)
+		    && (ptable->inr_sip_lsb_idx != 0xFF)) { //IPv6
+			pce_dasa_msb_t dasa_tbl;
+			pce_dasa_lsb_t dasa_tbl_lsb;
+			int i, j;
+			memset(&dasa_tbl, 0, sizeof(pce_dasa_msb_t));
+			memset(&dasa_tbl_lsb, 0, sizeof(pce_dasa_lsb_t));
+			/* Inner SIP MS8B used */
+			parm->pattern.eInnerSrcIP_Select = GSW_PCE_IP_V6;
+
+			if (0 != pce_dasa_msb_tbl_read(&pthandle->pce_sub_tbl,
+						       ptable->inr_sip_msb_idx, &dasa_tbl))
+				GSW_RETURN_PCE;
+
+			/* Populate inner SIP MS8B */
+			for (i = 0, j = 7; i < 4; i++, j -= 2)
+				parm->pattern.nInnerSrcIP.nIPv6[i]	=
+					(((dasa_tbl.imsb[j] & 0xFF) << 8)
+					 | (dasa_tbl.imsb[j - 1] & 0xFF));
+
+			/* Inner SIP MS8B nibble mask */
+			for (i = 0; i < 4; i++) {
+				for (j = 0; j < 4; j++) {
+					if (((dasa_tbl.mask[i] >> (j * 4)) & 0xF) == 0xF)
+						parm->pattern.nInnerSrcIP_Mask |=
+							(1 << ((i * 4) + j + 16));
+				}
+			}
+
+			/* Inner SIP LS8B used */
+			parm->pattern.eInnerSrcIP_Select = GSW_PCE_IP_V6;
+
+			if (0 != pce_dasa_lsb_tbl_read(&pthandle->pce_sub_tbl,
+						       ptable->inr_sip_lsb_idx, &dasa_tbl_lsb))
+				GSW_RETURN_PCE;
+
+			/* Populate inner SIP LS8B */
+			for (i = 0, j = 7; i < 4; i++, j -= 2)
+				parm->pattern.nInnerSrcIP.nIPv6[i + 4]	=
+					(((dasa_tbl_lsb.ilsb[j] & 0xFF) << 8)
+					 | (dasa_tbl_lsb.ilsb[j - 1] & 0xFF));
+
+			/* Inner DIP LS8B nibble mask */
+			for (i = 0; i < 4; i++) {
+				for (j = 0; j < 4; j++) {
+					if (((dasa_tbl_lsb.mask[i] >> (j * 4)) & 0xF) == 0xF)
+						parm->pattern.nInnerSrcIP_Mask |=
+							(1 << ((i * 4) + j));
+				}
+			}
+		} else if (ptable->inr_sip_lsb_idx != 0xFF) { //IPv4
+			pce_dasa_lsb_t dasa_tbl;
+			memset(&dasa_tbl, 0, sizeof(pce_dasa_lsb_t));
+			/* Inner SIP used */
+			parm->pattern.eInnerSrcIP_Select = GSW_PCE_IP_V4;
+
+			if (0 != pce_dasa_lsb_tbl_read(&pthandle->pce_sub_tbl,
+						       ptable->inr_sip_lsb_idx, &dasa_tbl))
+				GSW_RETURN_PCE;
+
+			/* Populate inner SIP */
+			parm->pattern.nInnerSrcIP.nIPv4 =
+				(dasa_tbl.ilsb[0]
+				 | (dasa_tbl.ilsb[1] << 8)
+				 | (dasa_tbl.ilsb[2] << 16)
+				 | (dasa_tbl.ilsb[3] << 24));
+
+			/* Inner SIP nibble mask */
+			for (i = 0; i < 2; i++) {
+				for (j = 0; j < 4; j++) {
+					if (((dasa_tbl.mask[i] >> (j * 4)) & 0xF) == 0xF)
+						parm->pattern.nInnerSrcIP_Mask |=
+							(1 << ((i * 4) + j));
+				}
+			}
+
+			parm->pattern.nInnerSrcIP_Mask |= 0xFF00;
+		}
+	} /*LTQ_GSWIP_3_0*/
+
+	/* Outer DIP n SIP field table */
+	/* DIP field table */
+	if ((ptable->dip_msb_idx != 0xFF)
+	    && (ptable->dip_lsb_idx != 0xFF)) { //IPv6
+		pce_dasa_msb_t dasa_tbl;
+		pce_dasa_lsb_t dasa_tbl_lsb;
+		int i, j;
+		memset(&dasa_tbl, 0, sizeof(pce_dasa_msb_t));
+		memset(&dasa_tbl_lsb, 0, sizeof(pce_dasa_lsb_t));
+		/* DIP MS8B used */
+		parm->pattern.eDstIP_Select = GSW_PCE_IP_V6;
+
+		if (0 != pce_dasa_msb_tbl_read(&pthandle->pce_sub_tbl,
+					       ptable->dip_msb_idx, &dasa_tbl))
+			GSW_RETURN_PCE;
+
+		/* Populate DIP MS8B used */
+		for (i = 0, j = 7; i < 4; i++, j -= 2)
+			parm->pattern.nDstIP.nIPv6[i]	=
+				(((dasa_tbl.imsb[j] & 0xFF) << 8)
+				 | (dasa_tbl.imsb[j - 1] & 0xFF));
+
+		/* DIP MS8B nibble mask */
+		if ((gswdev->gipver == LTQ_GSWIP_3_0) ||
+		    (IS_VRSN_31(gswdev->gipver))) {
+			for (i = 0; i < 4; i++) {
+				for (j = 0; j < 4; j++) {
+					if (((dasa_tbl.mask[i] >> (j * 4)) & 0xF) == 0xF)
+						parm->pattern.nDstIP_Mask |=
+							(1 << ((i * 4) + j + 16));
+				}
+			}
+		} else if (gswdev->gipver == LTQ_GSWIP_2_2)
+			parm->pattern.nDstIP_Mask = dasa_tbl.mask[0] << 16;
+
+		/* DIP LS8B used */
+		parm->pattern.eDstIP_Select = GSW_PCE_IP_V6;
+
+		if (0 != pce_dasa_lsb_tbl_read(&pthandle->pce_sub_tbl,
+					       ptable->dip_lsb_idx, &dasa_tbl_lsb))
+			GSW_RETURN_PCE;
+
+		/* Populate DIP LS8B used */
+		for (i = 0, j = 7; i < 4; i++, j -= 2)
+			parm->pattern.nDstIP.nIPv6[i + 4]	=
+				(((dasa_tbl_lsb.ilsb[j] & 0xFF) << 8)
+				 | (dasa_tbl_lsb.ilsb[j - 1] & 0xFF));
+
+		/* Inner DIP LS8B nibble mask */
+		if ((gswdev->gipver == LTQ_GSWIP_3_0) ||
+		    (IS_VRSN_31(gswdev->gipver))) {
+			for (i = 0; i < 4; i++) {
+				for (j = 0; j < 4; j++) {
+					if (((dasa_tbl_lsb.mask[i] >> (j * 4)) & 0xF) == 0xF)
+						parm->pattern.nDstIP_Mask |=
+							(1 << ((i * 4) + j));
+				}
+			}
+		} else if (gswdev->gipver == LTQ_GSWIP_2_2)
+			parm->pattern.nDstIP_Mask |= dasa_tbl_lsb.mask[0];
+	} else if (ptable->dip_lsb_idx != 0xFF) {  //IPv4
+		pce_dasa_lsb_t dasa_tbl;
+		memset(&dasa_tbl, 0, sizeof(pce_dasa_lsb_t));
+		/* DIP used */
+		parm->pattern.eDstIP_Select = GSW_PCE_IP_V4;
+
+		if (0 != pce_dasa_lsb_tbl_read(&pthandle->pce_sub_tbl,
+					       ptable->dip_lsb_idx, &dasa_tbl))
+			GSW_RETURN_PCE;
+
+		/* Populate DIP */
+		parm->pattern.nDstIP.nIPv4 =
+			(dasa_tbl.ilsb[0]
+			 | (dasa_tbl.ilsb[1] << 8)
+			 | (dasa_tbl.ilsb[2] << 16)
+			 | (dasa_tbl.ilsb[3] << 24));
+
+		/* DIP nibble mask */
+		if ((gswdev->gipver == LTQ_GSWIP_3_0) ||
+		    (IS_VRSN_31(gswdev->gipver))) {
+			for (i = 0; i < 2; i++) {
+				for (j = 0; j < 4; j++) {
+					if (((dasa_tbl.mask[i] >> (j * 4)) & 0xF) == 0xF)
+						parm->pattern.nDstIP_Mask |= (1 << ((i * 4) + j));
+				}
+			}
+
+			parm->pattern.nDstIP_Mask |= 0xFF00;
+		} else if (gswdev->gipver == LTQ_GSWIP_2_2)
+			parm->pattern.nDstIP_Mask = dasa_tbl.mask[0];
+	}
+
+	/* SIP field table */
+	if ((ptable->sip_msb_idx != 0xFF)
+	    && (ptable->sip_lsb_idx != 0xFF)) { //IPv6
+		pce_dasa_msb_t dasa_tbl;
+		pce_dasa_lsb_t dasa_tbl_lsb;
+		int i, j;
+		memset(&dasa_tbl, 0, sizeof(pce_dasa_msb_t));
+		memset(&dasa_tbl_lsb, 0, sizeof(pce_dasa_lsb_t));
+		/* SIP MS8B used */
+		parm->pattern.eSrcIP_Select = GSW_PCE_IP_V6;
+
+		if (0 != pce_dasa_msb_tbl_read(&pthandle->pce_sub_tbl,
+					       ptable->sip_msb_idx, &dasa_tbl))
+			GSW_RETURN_PCE;
+
+		/* Populate SIP MS8B */
+		for (i = 0, j = 7; i < 4; i++, j -= 2)
+			parm->pattern.nSrcIP.nIPv6[i]	=
+				(((dasa_tbl.imsb[j] & 0xFF) << 8)
+				 | (dasa_tbl.imsb[j - 1] & 0xFF));
+
+		/* Inner DIP MS8B nibble mask */
+		if ((gswdev->gipver == LTQ_GSWIP_3_0) ||
+		    (IS_VRSN_31(gswdev->gipver))) {
+			for (i = 0; i < 4; i++) {
+				for (j = 0; j < 4; j++) {
+					if (((dasa_tbl.mask[i] >> (j * 4)) & 0xF) == 0xF)
+						parm->pattern.nSrcIP_Mask |=
+							(1 << ((i * 4) + j + 16));
+				}
+			}
+		} else if (gswdev->gipver == LTQ_GSWIP_2_2)
+			parm->pattern.nSrcIP_Mask = dasa_tbl.mask[0] << 16;
+
+		/* SIP LS8B used */
+		parm->pattern.eSrcIP_Select = GSW_PCE_IP_V6;
+
+		if (0 != pce_dasa_lsb_tbl_read(&pthandle->pce_sub_tbl,
+					       ptable->sip_lsb_idx, &dasa_tbl_lsb))
+			GSW_RETURN_PCE;
+
+		/* Populate SIP LS8B */
+		for (i = 0, j = 7; i < 4; i++, j -= 2)
+			parm->pattern.nSrcIP.nIPv6[i + 4]	=
+				(((dasa_tbl_lsb.ilsb[j] & 0xFF) << 8)
+				 | (dasa_tbl_lsb.ilsb[j - 1] & 0xFF));
+
+		/* Inner DIP LS8B nibble mask */
+		if ((gswdev->gipver == LTQ_GSWIP_3_0) ||
+		    (IS_VRSN_31(gswdev->gipver))) {
+			for (i = 0; i < 4; i++) {
+				for (j = 0; j < 4; j++) {
+					if (((dasa_tbl_lsb.mask[i] >> (j * 4)) & 0xF) == 0xF)
+						parm->pattern.nSrcIP_Mask |=
+							(1 << ((i * 4) + j));
+				}
+			}
+		} else if (gswdev->gipver == LTQ_GSWIP_2_2)
+			parm->pattern.nSrcIP_Mask |= dasa_tbl_lsb.mask[0];
+	} else if (ptable->sip_lsb_idx != 0xFF) { //IPv4
+		pce_dasa_lsb_t dasa_tbl;
+		memset(&dasa_tbl, 0, sizeof(pce_dasa_lsb_t));
+		/* SIP used */
+		parm->pattern.eSrcIP_Select = GSW_PCE_IP_V4;
+
+		if (0 != pce_dasa_lsb_tbl_read(&pthandle->pce_sub_tbl,
+					       ptable->sip_lsb_idx, &dasa_tbl))
+			GSW_RETURN_PCE;
+
+		/* Populate SIP used */
+		parm->pattern.nSrcIP.nIPv4 = (dasa_tbl.ilsb[0]
+					      | (dasa_tbl.ilsb[1] << 8)
+					      | (dasa_tbl.ilsb[2] << 16)
+					      | (dasa_tbl.ilsb[3] << 24));
+
+		/* SIP nibble mask */
+		if ((gswdev->gipver == LTQ_GSWIP_3_0) ||
+		    (IS_VRSN_31(gswdev->gipver))) {
+			for (i = 0; i < 2; i++) {
+				for (j = 0; j < 4; j++) {
+					if (((dasa_tbl.mask[i] >> (j * 4)) & 0xF) == 0xF)
+						parm->pattern.nSrcIP_Mask |= (1 << ((i * 4) + j));
+				}
+			}
+
+			parm->pattern.nSrcIP_Mask |= 0xFF00;
+		} else if (gswdev->gipver == LTQ_GSWIP_2_2)
+			parm->pattern.nSrcIP_Mask = dasa_tbl.mask[0];
+	}
+
+	/* Protocol field table */
+	if (ptable->ethertype_idx != 0xFF) {
+		prtcol_tbl_t   pctl_tbl;
+		memset(&pctl_tbl, 0, sizeof(prtcol_tbl_t));
+		/* Ethertype used */
+		parm->pattern.bEtherTypeEnable = 1;
+
+		if (0 != pce_tm_ptcl_tbl_read(&pthandle->pce_sub_tbl,
+					      ptable->ethertype_idx, &pctl_tbl))
+			GSW_RETURN_PCE;
+
+		/* Ethertype */
+		parm->pattern.nEtherType = pctl_tbl.ethertype;
+		/* Ethertype Mask */
+		parm->pattern.nEtherTypeMask = pctl_tbl.emask;
+	}
+
+	/* Protocol field table */
+	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		if (ptable->ppp_prot_idx != 0xFF) {
+			prtcol_tbl_t   pctl_tbl;
+			memset(&pctl_tbl, 0, sizeof(prtcol_tbl_t));
+			/* Ethertype used */
+			parm->pattern.bPPP_ProtocolEnable = 1;
+
+			if (0 != pce_tm_ptcl_tbl_read(&pthandle->pce_sub_tbl,
+						      ptable->ppp_prot_idx, &pctl_tbl))
+				GSW_RETURN_PCE;
+
+			/* Ethertype */
+			parm->pattern.nPPP_Protocol = pctl_tbl.ethertype;
+			/* Ethertype Mask */
+			parm->pattern.nPPP_ProtocolMask =
+				pctl_tbl.emask;
+		}
+	}
+
+	/* Protocol field table */
+	if (ptable->ip_prot_idx != 0xFF) {
+		prtcol_tbl_t   pctl_tbl;
+		memset(&pctl_tbl, 0, sizeof(prtcol_tbl_t));
+
+		/* IP protocol used */
+		if (0 != pce_tm_ptcl_tbl_read(&pthandle->pce_sub_tbl,
+					      ptable->ip_prot_idx, &pctl_tbl))
+			GSW_RETURN_PCE;
+
+		if ((pctl_tbl.ethertype & 0xFF) == 0xFF)
+			parm->pattern.bProtocolEnable = 0;
+		else
+			parm->pattern.bProtocolEnable = 1;
+
+		if (((pctl_tbl.ethertype >> 8) & 0xFF) == 0xFF)
+			parm->pattern.bInnerProtocolEnable = 0;
+		else
+			parm->pattern.bInnerProtocolEnable = 1;
+
+		/* IP protocol */
+		parm->pattern.nProtocol = pctl_tbl.ethertype & 0xFF;
+		/* IP protocol Mask */
+		parm->pattern.nProtocolMask = pctl_tbl.emask & 0x3;
+		/* IP protocol */
+		parm->pattern.nInnerProtocol =
+			(pctl_tbl.ethertype >> 8) & 0xFF;
+		/* IP protocol Mask */
+		parm->pattern.nInnerProtocolMask =
+			(pctl_tbl.emask >> 2) & 0x3;
+	}
+
+	/* PPPoE sessio ID field table */
+	if (ptable->pppoe_idx != 0xFF) {
+		pce_ppoe_tbl_t pppoe_tbl;
+		memset(&pppoe_tbl, 0, sizeof(pce_ppoe_tbl_t));
+		/* PPPoE used */
+		parm->pattern.bSessionIdEnable = 1;
+
+		if (0 != pce_tm_pppoe_tbl_read(&pthandle->pce_sub_tbl,
+					       ptable->pppoe_idx, &pppoe_tbl))
+			GSW_RETURN_PCE;
+
+		/* PPPoE */
+		parm->pattern.nSessionId = pppoe_tbl.sess_id;
+	}
+
+	/* VLAN-ID field table */
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		/* Inner VLAN-ID field table */
+		if (ptable->vlan_idx != 0x7F) {
+			pctbl_prog_t pcetable_vlan;
+			memset(&pcetable_vlan, 0, sizeof(pctbl_prog_t));
+			/* VLAN used */
+			parm->pattern.bVid = 1;
+			pcetable_vlan.table = PCE_ACTVLAN_INDEX;
+			/*index of the VLAN ID configuration */
+			pcetable_vlan.pcindex = ptable->vlan_idx;
+			/* ptbl.key[0] = parm->nVId; */
+			gsw_pce_table_read(cdev, &pcetable_vlan);
+
+			if (pcetable_vlan.valid == 1)
+				parm->pattern.nVid = pcetable_vlan.key[0] & 0xFFF;
+		}
+
+		/* Outer VLAN-ID field table */
+		if (ptable->svlan_idx != 0x7F) {
+			pctbl_prog_t pcetable_vlan;
+			memset(&pcetable_vlan, 0, sizeof(pctbl_prog_t));
+			/* VLAN used */
+			parm->pattern.bSLAN_Vid = 1;
+			pcetable_vlan.table = PCE_ACTVLAN_INDEX;
+			/*index of the VLAN ID configuration */
+			pcetable_vlan.pcindex = ptable->svlan_idx;
+			/* ptbl.key[0] = parm->nVId; */
+			gsw_pce_table_read(cdev, &pcetable_vlan);
+
+			if (pcetable_vlan.valid == 1)
+				parm->pattern.nSLAN_Vid = pcetable_vlan.key[0] & 0xFFF;
+		}
+	}
+
+	/* VLAN-ID field table */
+	if (IS_VRSN_31(gswdev->gipver)) {
+		/*Inner vlan -CTAG VLAN index*/
+		if ((ptbl.key[20] & 0x1FFF) != 0x1FFF) {
+			parm->pattern.bVid = 1;
+			parm->pattern.nVid = ptbl.key[20] & 0xFFF;
+			parm->pattern.bVid_Original = (ptbl.key[20] >> 15) & 1;
+
+			if ((ptbl.key[21] & 0xFFF) != 0) {
+				parm->pattern.bVidRange_Select = 1;
+				parm->pattern.nVidRange = ptbl.key[21] & 0xFFF;
+			}
+		}
+
+		/*Outer vlan -STAG VLAN index*/
+		if ((ptbl.key[18] & 0x1FFF) != 0x1FFF) {
+			parm->pattern.bSLAN_Vid = 1;
+			parm->pattern.nSLAN_Vid = ptbl.key[18] & 0xFFF;
+			parm->pattern.bOuterVid_Original = (ptbl.key[18] >> 15) & 1;
+
+			if ((ptbl.key[19] & 0xFFF) != 0) {
+				parm->pattern.bSVidRange_Select = 1;
+				parm->pattern.nOuterVidRange = ptbl.key[19] & 0xFFF;
+			}
+		}
+	}
+
+	/* OAM and Extraction flags field table */
+	if (((ptbl.val[8] >> 3) & 0x1) || ((ptbl.val[7] >> 8) & 0x1)) {
+		/*OAM flag*/
+		if ((ptbl.val[8] >> 3) & 0x1) {
+			parm->action.bOamEnable = 1;
+			/*OAM and extraction packet control*/
+			parm->action.nRecordId = ((ptbl.val[8] >> 4) & 0xFFF);
+		}
+
+		/*Extraction flag*/
+		if ((ptbl.val[7] >> 8) & 0x1) {
+			parm->action.bExtractEnable = 1;
+		}
+	}
+
+	return GSW_statusOk;
+}
+
+int pce_rule_write(void *cdev, ltq_pce_table_t *pthandle, GSW_PCE_rule_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	static pctbl_prog_t ptbl;
+	u32 idx = parm->pattern.nIndex;
+	pce_table_t  *ptable;
+	GSW_PCE_action_t *paction;
+	static GSW_PCE_rule_t	key_current;
+	int	tindex, i, reg_val = 0;
+	signed int status;
+
+	PCE_ASSERT(idx >= PCE_TABLE_SIZE);
+
+	if (parm->pattern.bEnable == 0) {
+		/* Entry to delete. */
+		return pce_pattern_delete(cdev, pthandle, idx);
+	}
+
+	/* Read the rule at given index to check if it is indeed same as current */
+	key_current.pattern.nIndex = idx;
+
+	if (pce_rule_read(cdev, pthandle, &key_current) != 0)
+		GSW_RETURN_PCE;
+
+	/* Check if rule already exists */
+	if (!memcmp(&key_current, parm, sizeof(GSW_PCE_rule_t))) {
+		pr_err("\n Rule already exists\n");
+		return GSW_statusOk;
+	}
+
+	/* Init the TFOW table entry to zero */
+	memset(&ptbl, 0, sizeof(pctbl_prog_t));
+	gsw_r32(cdev, PCE_GCTRL_1_VLANMD_OFFSET,
+		PCE_GCTRL_1_VLANMD_SHIFT,
+		PCE_GCTRL_1_VLANMD_SIZE, &reg_val);
+
+	/* Clean the old entry before adding the new one. */
+	if (pthandle->ptblused[idx] != 0) {
+		if (pce_pattern_delete(cdev, pthandle, idx) != 0)
+			GSW_RETURN_PCE;
+	}
+
+	/* Mark the entry as used */
+	pthandle->ptblused[idx] = 1;
+	/* Other tables to refer for this TFLOW entry */
+	ptable = &(pthandle->pce_tbl[idx]);
+
+	/* Populate 'match' parameter values */
+	/* Pattern field - PortID value */
+	if (parm->pattern.bPortIdEnable == 1)
+		ptbl.key[0] = (parm->pattern.nPortId & 0x0F);
+	else
+		ptbl.key[0] = 0xFF; //Mark as don't care.
+
+	/* Pattern field - DSCP value */
+	if (parm->pattern.bDSCP_Enable == 1)
+		ptbl.key[6] |= ((parm->pattern.nDSCP & 0x3F) << 8);
+	else
+		ptbl.key[6] |= (0x7F << 8); //Mark as don't care.
+
+	/* Pattern field - Inner DSCP value */
+	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		if (parm->pattern.bInner_DSCP_Enable == 1)
+			ptbl.key[9] |= ((parm->pattern.nInnerDSCP & 0x3F) << 8);
+		else
+			ptbl.key[9] |= (0x7F << 8); //Mark as don't care.
+	}
+
+	/* Pattern field - inner PCP n DEI value */
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if (parm->pattern.bPCP_Enable == 1)
+			ptbl.key[6] |= (parm->pattern.nPCP & 0xF);
+		else
+			ptbl.key[6] |= 0x1F; //Mark as don't care.
+	} else {
+		if (parm->pattern.bPCP_Enable == 1)
+			ptbl.key[6] |= (parm->pattern.nPCP & 0x7);
+		else
+			ptbl.key[6] |= 0xF; //Mark as don't care.
+	}
+
+	/* Pattern field - outer PCP n DEI value */
+	if (parm->pattern.bSTAG_PCP_DEI_Enable == 1) {
+		/* PCP value */
+		ptbl.key[8] |= (parm->pattern.nSTAG_PCP_DEI & 0xF);
+	} else {
+		ptbl.key[8] |= 0x1F; //Mark as don't care.
+	}
+
+	/* Pattern field - Packet length field table */
+	if (parm->pattern.bPktLngEnable == 1) {
+		pce_pkt_length_t   pkg_lng;
+		/* Packet length */
+		pkg_lng.pkg_lng = parm->pattern.nPktLng;
+		/* Packet length range, in number of bytes */
+		pkg_lng.pkg_lng_rng = parm->pattern.nPktLngRange;
+		tindex = pce_tm_pkg_lng_tbl_write(cdev, &pthandle->pce_sub_tbl,
+						  &pkg_lng);
+
+		if (tindex < 0)
+			return tindex;
+
+		ptable->pkt_lng_idx = tindex;
+	} else {
+		ptable->pkt_lng_idx =  0xFF; //Mark as don't care.
+	}
+
+	ptbl.key[7] |= ptable->pkt_lng_idx;
+
+	/* Pattern field - Destination MAC address field table */
+	if (parm->pattern.bMAC_DstEnable == 1) {
+		pce_da_prog_t  da_mac_tbl;
+
+		for (i = 0; i < 6; i++)
+			da_mac_tbl.mac[i] = parm->pattern.nMAC_Dst[i];
+
+		da_mac_tbl.mac_mask = parm->pattern.nMAC_DstMask;
+		tindex = pce_da_mac_tbl_write(cdev, &pthandle->pce_sub_tbl,
+					      &da_mac_tbl);
+
+		if (tindex < 0)
+			return tindex;
+
+		ptable->dst_mac_addr_idx = tindex;
+	} else {
+		ptable->dst_mac_addr_idx = 0xFF; //Mark as don't care.
+	}
+
+	ptbl.key[5] |= (ptable->dst_mac_addr_idx << 8);
+
+	/* Pattern field - Source MAC address field table */
+	if (parm->pattern.bMAC_SrcEnable == 1) {
+		pce_sa_prog_t  sa_mac_tbl;
+
+		for (i = 0; i < 6; i++)
+			sa_mac_tbl.mac[i] = parm->pattern.nMAC_Src[i];
+
+		/* Source MAC address mask */
+		sa_mac_tbl.mac_mask = parm->pattern.nMAC_SrcMask;
+		tindex = pce_sa_mac_tbl_write(cdev, &pthandle->pce_sub_tbl,
+					      &sa_mac_tbl);
+
+		if (tindex < 0)
+			return tindex;
+
+		ptable->src_mac_addr_idx = tindex;
+	}  else {
+		ptable->src_mac_addr_idx = 0xFF; //Mark as don't care.
+	}
+
+	ptbl.key[5] |= ptable->src_mac_addr_idx;
+
+	/* Pattern field - Parser Flags field table */
+	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		/* Parser flags 15:0 */
+		if (parm->pattern.bParserFlagLSB_Enable == 1) {
+			flag_tbl_t   flags_tbl;
+			memset(&flags_tbl, 0, sizeof(flag_tbl_t));
+			flags_tbl.parser_flag_data = parm->pattern.nParserFlagLSB;
+			flags_tbl.mask_value = parm->pattern.nParserFlagLSB_Mask;
+			flags_tbl.valid = 1;
+			tindex = pce_flags_tbl_write(cdev, &pthandle->pce_sub_tbl,
+						     &flags_tbl);
+
+			if (tindex < 0)
+				return tindex;
+
+			ptable->parse_lsb_idx = tindex;
+		} else {
+			ptable->parse_lsb_idx = 0xFF; //Mark as don't care.
+		}
+
+		ptbl.key[12] |= ptable->parse_lsb_idx;
+
+		/* Parser flags 47:32 */
+		if (IS_VRSN_31(gswdev->gipver)) {
+			if (parm->pattern.bParserFlag1LSB_Enable == 1) {
+				flag_tbl_t   flags_tbl;
+				memset(&flags_tbl, 0, sizeof(flag_tbl_t));
+				flags_tbl.parser_flag_data = parm->pattern.nParserFlag1LSB;
+				flags_tbl.mask_value = parm->pattern.nParserFlag1LSB_Mask;
+				flags_tbl.valid = 1;
+				tindex = pce_flags_tbl_write(cdev, &pthandle->pce_sub_tbl,
+							     &flags_tbl);
+
+				if (tindex < 0)
+					return tindex;
+
+				ptable->parse1_lsb_idx = tindex;
+			} else {
+				ptable->parse1_lsb_idx = 0xFF; //Mark as don't care.
+			}
+
+			ptbl.key[16] |= ptable->parse1_lsb_idx;
+		}
+
+		/* Parser flags 31:16 */
+		if (parm->pattern.bParserFlagMSB_Enable == 1) {
+			flag_tbl_t   flags_tbl;
+			memset(&flags_tbl, 0, sizeof(flag_tbl_t));
+			flags_tbl.parser_flag_data = parm->pattern.nParserFlagMSB;
+			flags_tbl.mask_value = parm->pattern.nParserFlagMSB_Mask;
+			flags_tbl.valid = 1;
+			tindex = pce_flags_tbl_write(cdev, &pthandle->pce_sub_tbl,
+						     &flags_tbl);
+
+			if (tindex < 0)
+				return tindex;
+
+			ptable->parse_msb_idx = tindex;
+		} else {
+			ptable->parse_msb_idx = 0xFF; //Mark as don't care.
+		}
+
+		ptbl.key[12] |= (ptable->parse_msb_idx << 8);
+
+		/* Parser flags 63:48 */
+		if (IS_VRSN_31(gswdev->gipver)) {
+			if (parm->pattern.bParserFlag1MSB_Enable == 1) {
+				flag_tbl_t   flags_tbl;
+				memset(&flags_tbl, 0, sizeof(flag_tbl_t));
+				flags_tbl.parser_flag_data = parm->pattern.nParserFlag1MSB;
+				flags_tbl.mask_value = parm->pattern.nParserFlag1MSB_Mask;
+				flags_tbl.valid = 1;
+				tindex = pce_flags_tbl_write(cdev, &pthandle->pce_sub_tbl,
+							     &flags_tbl);
+
+				if (tindex < 0)
+					return tindex;
+
+				ptable->parse1_msb_idx = tindex;
+			} else {
+				ptable->parse1_msb_idx = 0xFF; //Mark as don't care.
+			}
+
+			ptbl.key[16] |= (ptable->parse1_msb_idx << 8);
+		}
+
+		/* Pattern field - Payload1 used */
+		if (parm->pattern.bPayload1_SrcEnable == 1) {
+			payload_tbl_t   payload_tbl;
+			memset(&payload_tbl, 0, sizeof(payload_tbl_t));
+			payload_tbl.mask_range_type =
+				parm->pattern.bPayload1MaskRange_Select;
+			payload_tbl.payload_data = parm->pattern.nPayload1;
+			payload_tbl.mask_range = parm->pattern.nPayload1_Mask;
+			payload_tbl.valid = 1;
+			tindex = pce_payload_tbl_write(cdev, &pthandle->pce_sub_tbl,
+						       &payload_tbl);
+
+			if (tindex < 0)
+				return tindex;
+
+			ptable->payload1_idx = tindex;
+		} else {
+			ptable->payload1_idx = 0xFF; //Mark as don't care.
+		}
+
+		ptbl.key[13] |= ptable->payload1_idx;
+
+		/* Pattern field - Payload2 used */
+		if (parm->pattern.bPayload2_SrcEnable == 1) {
+			payload_tbl_t   payload_tbl;
+			memset(&payload_tbl, 0, sizeof(payload_tbl_t));
+			payload_tbl.mask_range_type =
+				parm->pattern.bPayload2MaskRange_Select;
+			payload_tbl.payload_data = parm->pattern.nPayload2;
+			/* Destination Application mask/range */
+			payload_tbl.mask_range = parm->pattern.nPayload2_Mask;
+			payload_tbl.valid = 1;
+			tindex = pce_payload_tbl_write(cdev, &pthandle->pce_sub_tbl,
+						       &payload_tbl);
+
+			if (tindex < 0)
+				return tindex;
+
+			ptable->payload2_idx = tindex;
+		} else {
+			ptable->payload2_idx = 0xFF; //Mark as don't care.
+		}
+
+		ptbl.key[13] |= (ptable->payload2_idx << 8);
+	}
+
+	/* Pattern field - Destination Application used */
+	if (parm->pattern.bAppDataMSB_Enable == 1) {
+		app_tbl_t   appl_tbl;
+		appl_tbl.mask_range_type = parm->pattern.bAppMaskRangeMSB_Select;
+		/* Destination Application field */
+		appl_tbl.appl_data = parm->pattern.nAppDataMSB;
+		/* Destination Application mask/range */
+		appl_tbl.mask_range = parm->pattern.nAppMaskRangeMSB;
+		tindex = pce_appl_tbl_write(cdev, &pthandle->pce_sub_tbl, &appl_tbl);
+
+		if (tindex < 0)
+			return tindex;
+
+		ptable->dst_appl_fld_idx = tindex;
+	} else {
+		ptable->dst_appl_fld_idx = 0xFF; //Mark as don't care.
+	}
+
+	ptbl.key[4] |= ptable->dst_appl_fld_idx;
+
+	/* Pattern field - Source Application field used */
+	if (parm->pattern.bAppDataLSB_Enable == 1) {
+		app_tbl_t   appl_tbl;
+		appl_tbl.mask_range_type = parm->pattern.bAppMaskRangeLSB_Select;
+		/* Source Application field */
+		appl_tbl.appl_data = parm->pattern.nAppDataLSB;
+		/* Source Application mask/range */
+		appl_tbl.mask_range = parm->pattern.nAppMaskRangeLSB;
+		tindex = pce_appl_tbl_write(cdev, &pthandle->pce_sub_tbl, &appl_tbl);
+
+		if (tindex < 0)
+			return tindex;
+
+		ptable->src_appl_fld_idx = tindex;
+	} else {
+		ptable->src_appl_fld_idx = 0xFF; //Mark as don't care.
+	}
+
+	ptbl.key[4] |= (ptable->src_appl_fld_idx << 8);
+
+	/* Pattern field - outer DIP field table */
+	ptable->dip_msb_idx = 0xFF; //Mark as don't care.
+	ptable->dip_lsb_idx = 0xFF; //Mark as don't care.
+
+	/* DIP MSB used - IPv6 bits 127:64 */
+	if (parm->pattern.eDstIP_Select == GSW_PCE_IP_V6) {
+		pce_dasa_msb_t  mtbl;
+		pce_dasa_lsb_t  ltbl;
+		int	j;
+		u16 maskNibble;
+		memset(&mtbl, 0, sizeof(pce_dasa_msb_t));
+		memset(&ltbl, 0, sizeof(pce_dasa_lsb_t));
+
+		/* First, search for DIP in the DA/SA table (DIP MSB) */
+		for (i = 0, j = 7; i < 4; i++, j -= 2) {
+			mtbl.imsb[j - 1] = (parm->pattern.nDstIP.nIPv6[i] & 0xFF);
+			mtbl.imsb[j] = ((parm->pattern.nDstIP.nIPv6[i] >> 8) & 0xFF);
+		}
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+			//mtbl.nmask = (u16)((parm->pattern.nDstIP_Mask >> 16) & 0xFFFF);
+			for (i = 0; i < 4; i++) {
+				maskNibble = ((parm->pattern.nDstIP_Mask >> ((i * 4) + 16)) & 0xF);
+
+				for (j = 0; j < 4; j++) {
+					if ((maskNibble >> j) & 0x1)
+						mtbl.mask[i] |= (0xF << (j * 4));
+				}
+			}
+		} else {
+			mtbl.mask[0] = (u16)((parm->pattern.nDstIP_Mask >> 16) & 0xFFFF);
+		}
+
+		mtbl.valid = 1;
+		tindex = pce_dasa_msb_tbl_write(cdev, &pthandle->pce_sub_tbl, &mtbl);
+
+		if (tindex < 0) {
+			pr_err("%s:%s:%d(DASA Table full)\n",
+			       __FILE__, __func__, __LINE__);
+			return -1;
+		}
+
+		ptable->dip_msb_idx = tindex;
+
+		/* DIP LSB used - IPv6 bits 63:0 */
+		/* First, search for DIP in the DA/SA table (DIP LSB) */
+		for (i = 0, j = 7; i < 4; i++, j -= 2) {
+			ltbl.ilsb[j - 1] = (parm->pattern.nDstIP.nIPv6[i + 4] & 0xFF);
+			ltbl.ilsb[j] = ((parm->pattern.nDstIP.nIPv6[i + 4] >> 8) & 0xFF);
+		}
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+			//ltbl.nmask = (u16)(parm->pattern.nDstIP_Mask & 0xFFFF);
+			for (i = 0; i < 4; i++) {
+				maskNibble = ((parm->pattern.nDstIP_Mask >> (i * 4)) & 0xF);
+
+				for (j = 0; j < 4; j++) {
+					if ((maskNibble >> j) & 0x1)
+						ltbl.mask[i] |= (0xF << (j * 4));
+				}
+			}
+		} else {
+			ltbl.mask[0] = (u16)(parm->pattern.nDstIP_Mask & 0xFFFF);
+		}
+
+		ltbl.valid = 1;
+		tindex = pce_dasa_lsb_tbl_write(cdev, &pthandle->pce_sub_tbl, &ltbl);
+
+		if (tindex < 0) {
+			pr_err("%s:%s:%d (DASA Table full)\n",
+			       __FILE__, __func__, __LINE__);
+			return -1;
+		}
+
+		ptable->dip_lsb_idx = tindex;
+	} else  if (parm->pattern.eDstIP_Select == GSW_PCE_IP_V4) {
+		/* DIP LSB used - IPv4 bits 31:0 */
+		pce_dasa_lsb_t  ltbl;
+		memset(&ltbl, 0, sizeof(pce_dasa_lsb_t));
+
+		/* First, search for DIP in the DA/SA table (DIP LSB) */
+		for (i = 0; i < 4; i++)
+			ltbl.ilsb[i] = ((parm->pattern.nDstIP.nIPv4 >> (i * 8)) & 0xFF);
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+			int j;
+			u16 maskNibble;
+
+			//ltbl.nmask = (u16)(parm->pattern.nDstIP_Mask) & 0xFFFF;
+			for (i = 0; i < 2; i++) {
+				maskNibble = ((parm->pattern.nDstIP_Mask >> (i * 4)) & 0xF);
+
+				for (j = 0; j < 4; j++) {
+					if ((maskNibble >> j) & 0x1)
+						ltbl.mask[i] |= (0xF << (j * 4));
+				}
+			}
+
+			//Mask out the bits 63:32 always for IPv4.
+			ltbl.mask[3] = ltbl.mask[2] = 0xFFFF;
+		} else {
+			/* DIP LSB Nibble Mask */
+			ltbl.mask[0] = (u16)(parm->pattern.nDstIP_Mask | 0xFF00) & 0xFFFF;
+		}
+
+		ltbl.valid = 1;
+		tindex = pce_dasa_lsb_tbl_write(cdev, &pthandle->pce_sub_tbl, &ltbl);
+
+		if (tindex < 0) {
+			pr_err("%s:%s:%d (DASA Table full)\n",
+			       __FILE__, __func__, __LINE__);
+			return -1;
+		}
+
+		ptable->dip_lsb_idx = tindex;
+
+	}
+
+	ptbl.key[3] |= (ptable->dip_msb_idx << 8);
+	ptbl.key[3] |= ptable->dip_lsb_idx;
+
+	/* Pattern field - SIP field table */
+	ptable->sip_msb_idx = 0xFF; //Mark as don't care.
+	ptable->sip_lsb_idx = 0xFF; //Mark as don't care.
+
+	/* SIP MSB used - IPv6 bits 127:64 */
+	if (parm->pattern.eSrcIP_Select == GSW_PCE_IP_V6) {
+		pce_dasa_msb_t  mtbl;
+		pce_dasa_lsb_t  ltbl;
+		int	j;
+		u16 maskNibble;
+		memset(&mtbl, 0, sizeof(pce_dasa_msb_t));
+		memset(&ltbl, 0, sizeof(pce_dasa_lsb_t));
+
+		/* First, search for DIP in the DA/SA table (DIP MSB) */
+		for (i = 0, j = 7; i < 4; i++, j -= 2) {
+			mtbl.imsb[j - 1] = (parm->pattern.nSrcIP.nIPv6[i] & 0xFF);
+			mtbl.imsb[j]	= ((parm->pattern.nSrcIP.nIPv6[i] >> 8) & 0xFF);
+		}
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+			//mtbl.nmask = (u16)((parm->pattern.nSrcIP_Mask >> 16) & 0xFFFF);
+			for (i = 0; i < 4; i++) {
+				maskNibble = ((parm->pattern.nSrcIP_Mask >> ((i * 4) + 16)) & 0xF);
+
+				for (j = 0; j < 4; j++) {
+					if ((maskNibble >> j) & 0x1)
+						mtbl.mask[i] |= (0xF << (j * 4));
+				}
+			}
+		} else {
+			mtbl.mask[0] = (u16)((parm->pattern.nSrcIP_Mask >> 16) & 0xFFFF);
+		}
+
+		mtbl.valid = 1;
+		tindex = pce_dasa_msb_tbl_write(cdev, &pthandle->pce_sub_tbl, &mtbl);
+
+		if (tindex < 0) {
+			pr_err("%s:%s:%d (DASA Table full)\n",
+			       __FILE__, __func__, __LINE__);
+			return -1;
+		}
+
+		ptable->sip_msb_idx = tindex;
+
+		/* SIP LSB used - IPv6 bits 63:0 */
+		/* First, search for DIP in the DA/SA table (DIP LSB) */
+		for (i = 0, j = 7; i < 4; i++, j -= 2) {
+			ltbl.ilsb[j - 1] = (parm->pattern.nSrcIP.nIPv6[i + 4] & 0xFF);
+			ltbl.ilsb[j] = ((parm->pattern.nSrcIP.nIPv6[i + 4] >> 8) & 0xFF);
+		}
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+			//ltbl.nmask = (u16)(parm->pattern.nSrcIP_Mask & 0xFFFF);
+			for (i = 0; i < 4; i++) {
+				maskNibble = ((parm->pattern.nSrcIP_Mask >> (i * 4)) & 0xF);
+
+				for (j = 0; j < 4; j++) {
+					if ((maskNibble >> j) & 0x1)
+						ltbl.mask[i] |= (0xF << (j * 4));
+				}
+			}
+		} else {
+			ltbl.mask[0] = (u16)(parm->pattern.nSrcIP_Mask & 0xFFFF);
+		}
+
+		ltbl.valid = 1;
+		tindex = pce_dasa_lsb_tbl_write(cdev, &pthandle->pce_sub_tbl, &ltbl);
+
+		if (tindex < 0) {
+			pr_err("%s:%s:%d (DASA Table full)\n",
+			       __FILE__, __func__, __LINE__);
+			return -1;
+		}
+
+		ptable->sip_lsb_idx = tindex;
+
+	} else  if (parm->pattern.eSrcIP_Select == GSW_PCE_IP_V4) {
+		/* SIP LSB used - IPv4 bits 31:0 */
+		pce_dasa_lsb_t  ltbl;
+		memset(&ltbl, 0, sizeof(pce_dasa_lsb_t));
+
+		/* Second, search for SIP in the DA/SA table (SIP LSB) */
+		for (i = 0; i < 4; i++)
+			ltbl.ilsb[i] = ((parm->pattern.nSrcIP.nIPv4 >> (i * 8)) & 0xFF);
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+			int j;
+			u16 maskNibble;
+
+			//ltbl.nmask = (u16)(parm->pattern.nSrcIP_Mask) & 0xFFFF;
+			for (i = 0; i < 2; i++) {
+				maskNibble = ((parm->pattern.nSrcIP_Mask >> (i * 4)) & 0xF);
+
+				for (j = 0; j < 4; j++) {
+					if ((maskNibble >> j) & 0x1)
+						ltbl.mask[i] |= (0xF << (j * 4));
+				}
+			}
+
+			//Mask out the bits 63:32 always for IPv4.
+			ltbl.mask[3] = ltbl.mask[2] = 0xFFFF;
+		} else {
+			/* DIP LSB Nibble Mask */
+			ltbl.mask[0] = (u16)(parm->pattern.nSrcIP_Mask | 0xFF00) & 0xFFFF;
+		}
+
+		ltbl.valid = 1;
+		tindex = pce_dasa_lsb_tbl_write(cdev, &pthandle->pce_sub_tbl, &ltbl);
+
+		if (tindex < 0) {
+			pr_err("%s:%s:%d (DASA Table full)\n",
+			       __FILE__, __func__, __LINE__);
+			return -1;
+		}
+
+		ptable->sip_lsb_idx = tindex;
+	}
+
+	ptbl.key[2] |= (ptable->sip_msb_idx << 8);
+	ptbl.key[2] |= ptable->sip_lsb_idx;
+
+	/* Pattern field - inner DIP field table */
+	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		ptable->inr_dip_msb_idx = 0xFF; //Mark as don't care.
+		ptable->inr_dip_lsb_idx = 0xFF; //Mark as don't care.
+
+		/* DIP MSB used - IPv6 bits 127:64 */
+		if (parm->pattern.eInnerDstIP_Select == GSW_PCE_IP_V6) {
+			pce_dasa_msb_t  mtbl;
+			pce_dasa_lsb_t  ltbl;
+			int	j;
+			u16 maskNibble;
+			memset(&mtbl, 0, sizeof(pce_dasa_msb_t));
+			memset(&ltbl, 0, sizeof(pce_dasa_lsb_t));
+
+			/* First, search for DIP in the DA/SA table (DIP MSB) */
+			for (i = 0, j = 7; i < 4; i++, j -= 2) {
+				mtbl.imsb[j - 1] = (parm->pattern.nInnerDstIP.nIPv6[i] & 0xFF);
+				mtbl.imsb[j] = ((parm->pattern.nInnerDstIP.nIPv6[i] >> 8) &
+						0xFF);
+			}
+
+			for (i = 0; i < 4; i++) {
+				maskNibble = ((parm->pattern.nInnerDstIP_Mask >> ((i * 4) + 16)) & 0xF);
+
+				for (j = 0; j < 4; j++) {
+					if ((maskNibble >> j) & 0x1)
+						mtbl.mask[i] |= (0xF << (j * 4));
+				}
+			}
+
+			//mtbl.nmask = (u16)((parm->pattern.nInnerDstIP_Mask >> 16) & 0xFFFF);
+			mtbl.valid = 1;
+			tindex = pce_dasa_msb_tbl_write(cdev, &pthandle->pce_sub_tbl,
+							&mtbl);
+
+			if (tindex < 0) {
+				pr_err("%s:%s:%d (DASA Table full)\n",
+				       __FILE__, __func__, __LINE__);
+				return -1;
+			}
+
+			ptable->inr_dip_msb_idx = tindex;
+
+			/* DIP LSB used - IPv6 bits 63:0 */
+			/* First, search for DIP in the DA/SA table (DIP LSB) */
+			for (i = 0, j = 7; i < 4; i++, j -= 2) {
+				ltbl.ilsb[j - 1] = (parm->pattern.nInnerDstIP.nIPv6[i + 4] & 0xFF);
+				ltbl.ilsb[j] = ((parm->pattern.nInnerDstIP.nIPv6[i + 4] >> 8) &
+						0xFF);
+			}
+
+			for (i = 0; i < 4; i++) {
+				maskNibble = ((parm->pattern.nInnerDstIP_Mask >> (i * 4)) & 0xF);
+
+				for (j = 0; j < 4; j++) {
+					if ((maskNibble >> j) & 0x1)
+						ltbl.mask[i] |= (0xF << (j * 4));
+				}
+			}
+
+			//ltbl.nmask = (u16)(parm->pattern.nInnerDstIP_Mask & 0xFFFF);
+			ltbl.valid = 1;
+			tindex = pce_dasa_lsb_tbl_write(cdev, &pthandle->pce_sub_tbl,
+							&ltbl);
+
+			if (tindex < 0) {
+				pr_err("%s:%s:%d (DASA Table full)\n",
+				       __FILE__, __func__, __LINE__);
+				return -1;
+			}
+
+			ptable->inr_dip_lsb_idx = tindex;
+		} else  if (parm->pattern.eInnerDstIP_Select == GSW_PCE_IP_V4) {
+			/* DIP LSB used - IPv4 bits 31:0 */
+			pce_dasa_lsb_t  ltbl;
+			int j;
+			u16 maskNibble;
+			memset(&ltbl, 0, sizeof(pce_dasa_lsb_t));
+
+			/* First, search for DIP in the DA/SA table (DIP LSB) */
+			for (i = 0; i < 4; i++)
+				ltbl.ilsb[i] = ((parm->pattern.nInnerDstIP.nIPv4 >> (i * 8)) &
+						0xFF);
+
+			for (i = 0; i < 2; i++) {
+				maskNibble = ((parm->pattern.nInnerDstIP_Mask >> (i * 4)) & 0xF);
+
+				for (j = 0; j < 4; j++) {
+					if ((maskNibble >> j) & 0x1)
+						ltbl.mask[i] |= (0xF << (j * 4));
+				}
+			}
+
+			//Mask out the bits 63:32 always for IPv4.
+			ltbl.mask[3] = ltbl.mask[2] = 0xFFFF;
+			//ltbl.nmask = (u16)(parm->pattern.nInnerDstIP_Mask & 0xFFFF);
+			ltbl.valid = 1;
+			tindex = pce_dasa_lsb_tbl_write(cdev, &pthandle->pce_sub_tbl,
+							&ltbl);
+
+			if (tindex < 0) {
+				pr_err("%s:%s:%d (DASA Table full)\n",
+				       __FILE__, __func__, __LINE__);
+				return -1;
+			}
+
+			ptable->inr_dip_lsb_idx = tindex;
+		}
+
+		ptbl.key[11] |= (ptable->inr_dip_msb_idx << 8);
+		ptbl.key[11] |= ptable->inr_dip_lsb_idx;
+
+		/* Pattern field - inner SIP field table */
+		ptable->inr_sip_msb_idx = 0xFF; //Mark as don't care.
+		ptable->inr_sip_lsb_idx = 0xFF; //Mark as don't care.
+
+		/* SIP MSB used - IPv6 bits 127:64 */
+		if (parm->pattern.eInnerSrcIP_Select == GSW_PCE_IP_V6) {
+			pce_dasa_msb_t  mtbl;
+			pce_dasa_lsb_t  ltbl;
+			int	j;
+			u16 maskNibble;
+			memset(&mtbl, 0, sizeof(pce_dasa_msb_t));
+			memset(&ltbl, 0, sizeof(pce_dasa_lsb_t));
+
+			/* First, search for DIP in the DA/SA table (DIP MSB) */
+			for (i = 0, j = 7; i < 4; i++, j -= 2) {
+				mtbl.imsb[j - 1] = (parm->pattern.nInnerSrcIP.nIPv6[i] & 0xFF);
+				mtbl.imsb[j] = ((parm->pattern.nInnerSrcIP.nIPv6[i] >> 8) &
+						0xFF);
+			}
+
+			for (i = 0; i < 4; i++) {
+				maskNibble = ((parm->pattern.nInnerSrcIP_Mask >> ((i * 4) + 16)) & 0xF);
+
+				for (j = 0; j < 4; j++) {
+					if ((maskNibble >> j) & 0x1)
+						mtbl.mask[i] |= (0xF << (j * 4));
+				}
+			}
+
+			//mtbl.nmask = (u16)((parm->pattern.nInnerSrcIP_Mask >> 16) & 0xFFFF);
+			mtbl.valid = 1;
+			tindex = pce_dasa_msb_tbl_write(cdev, &pthandle->pce_sub_tbl,
+							&mtbl);
+
+			if (tindex < 0) {
+				pr_err("%s:%s:%d (DASA Table full)\n",
+				       __FILE__, __func__, __LINE__);
+				return -1;
+			}
+
+			ptable->inr_sip_msb_idx = tindex;
+
+			/* SIP LSB used - IPv6 bits 63:0 */
+			/* First, search for DIP in the DA/SA table (DIP LSB) */
+			for (i = 0, j = 7; i < 4; i++, j -= 2) {
+				ltbl.ilsb[j - 1] = (parm->pattern.nInnerSrcIP.nIPv6[i + 4] & 0xFF);
+				ltbl.ilsb[j] = ((parm->pattern.nInnerSrcIP.nIPv6[i + 4] >> 8)	&
+						0xFF);
+			}
+
+			for (i = 0; i < 4; i++) {
+				maskNibble = ((parm->pattern.nInnerSrcIP_Mask >> (i * 4)) & 0xF);
+
+				for (j = 0; j < 4; j++) {
+					if ((maskNibble >> j) & 0x1)
+						ltbl.mask[i] |= (0xF << (j * 4));
+				}
+			}
+
+			//ltbl.nmask = (u16)(parm->pattern.nInnerSrcIP_Mask & 0xFFFF);
+			ltbl.valid = 1;
+			tindex = pce_dasa_lsb_tbl_write(cdev, &pthandle->pce_sub_tbl,
+							&ltbl);
+
+			if (tindex < 0) {
+				pr_err("%s:%s:%d (DASA Table full)\n",
+				       __FILE__, __func__, __LINE__);
+				return -1;
+			}
+
+			ptable->inr_sip_lsb_idx = tindex;
+		} else  if (parm->pattern.eInnerSrcIP_Select == GSW_PCE_IP_V4) {
+			/* SIP LSB used - IPv4 bits 31:0 */
+			pce_dasa_lsb_t  ltbl;
+			int j;
+			u16 maskNibble;
+			memset(&ltbl, 0, sizeof(pce_dasa_lsb_t));
+
+			/* Second, search for SIP in the DA/SA table (SIP LSB) */
+			for (i = 0; i < 4; i++)
+				ltbl.ilsb[i] = ((parm->pattern.nInnerSrcIP.nIPv4 >> (i * 8)) &
+						0xFF);
+
+			for (i = 0; i < 2; i++) {
+				maskNibble = ((parm->pattern.nInnerSrcIP_Mask >> (i * 4)) & 0xF);
+
+				for (j = 0; j < 4; j++) {
+					if ((maskNibble >> j) & 0x1)
+						ltbl.mask[i] |= (0xF << (j * 4));
+				}
+			}
+
+			//Mask out the bits 63:32 always for IPv4.
+			ltbl.mask[3] = ltbl.mask[2] = 0xFFFF;
+			//ltbl.nmask = (u16)(parm->pattern.nInnerSrcIP_Mask & 0xFFFF);
+			ltbl.valid = 1;
+			tindex = pce_dasa_lsb_tbl_write(cdev, &pthandle->pce_sub_tbl,
+							&ltbl);
+
+			if (tindex < 0) {
+				pr_err("%s:%s:%d (DASA Table full)\n",
+				       __FILE__, __func__, __LINE__);
+				return -1;
+			}
+
+			ptable->inr_sip_lsb_idx = tindex;
+		}
+
+		ptbl.key[10] |= (ptable->inr_sip_msb_idx << 8);
+		ptbl.key[10] |= ptable->inr_sip_lsb_idx;
+	}
+
+	/* Pattern field - Ethertype field table */
+	if (parm->pattern.bEtherTypeEnable == 1) {
+		prtcol_tbl_t   pctl_tbl;
+		memset(&pctl_tbl, 0, sizeof(prtcol_tbl_t));
+		pctl_tbl.ethertype = parm->pattern.nEtherType;
+		pctl_tbl.emask = parm->pattern.nEtherTypeMask;
+		tindex = pce_ptcl_tbl_write(cdev, &pthandle->pce_sub_tbl, &pctl_tbl);
+
+		if (tindex < 0)
+			return tindex;
+
+		ptable->ethertype_idx = tindex;
+	} else {
+		ptable->ethertype_idx = 0xFF; //Mark as don't care.
+	}
+
+	ptbl.key[1] |= ptable->ethertype_idx;
+
+	/* Pattern field - PPP Protocol table */
+	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		if (parm->pattern.bPPP_ProtocolEnable == 1) {
+			prtcol_tbl_t   pctl_tbl;
+			memset(&pctl_tbl, 0, sizeof(prtcol_tbl_t));
+			pctl_tbl.ethertype = parm->pattern.nPPP_Protocol;
+			pctl_tbl.emask = parm->pattern.nPPP_ProtocolMask;
+			tindex = pce_ptcl_tbl_write(cdev, &pthandle->pce_sub_tbl,
+						    &pctl_tbl);
+
+			if (tindex < 0)
+				return tindex;
+
+			ptable->ppp_prot_idx = tindex;
+		} else {
+			ptable->ppp_prot_idx = 0xFF; //Mark as don't care.
+		}
+
+		ptbl.key[9] |= ptable->ppp_prot_idx;
+	}
+
+	/* Pattern field - Both outer n inner IP protocol table */
+	if ((parm->pattern.bProtocolEnable == 1) &&
+	    (parm->pattern.bInnerProtocolEnable == 1)) {
+		prtcol_tbl_t   pctl_tbl;
+		memset(&pctl_tbl, 0, sizeof(prtcol_tbl_t));
+		pctl_tbl.ethertype = (parm->pattern.nProtocol & 0xFF);
+		pctl_tbl.ethertype |= ((parm->pattern.nInnerProtocol & 0xFF) << 8);
+		pctl_tbl.emask = (parm->pattern.nProtocolMask  & 0x3);
+		pctl_tbl.emask |= ((parm->pattern.nInnerProtocolMask  & 0x3) << 2);
+		tindex = pce_ptcl_tbl_write(cdev, &pthandle->pce_sub_tbl, &pctl_tbl);
+
+		if (tindex < 0)
+			return tindex;
+
+		ptable->ip_prot_idx = tindex;
+	} else if (parm->pattern.bInnerProtocolEnable == 1) {
+		/* Only inner IP protocol table */
+		prtcol_tbl_t   pctl_tbl;
+		memset(&pctl_tbl, 0, sizeof(prtcol_tbl_t));
+		pctl_tbl.ethertype = (0xFF);
+		pctl_tbl.ethertype |= ((parm->pattern.nInnerProtocol & 0xFF) << 8);
+		pctl_tbl.emask = 0x3; //Mask out outer Proto value.
+		pctl_tbl.emask |= ((parm->pattern.nInnerProtocolMask  & 0x3) << 2);
+		tindex = pce_ptcl_tbl_write(cdev,
+					    &pthandle->pce_sub_tbl, &pctl_tbl);
+
+		if (tindex < 0)
+			return tindex;
+
+		ptable->ip_prot_idx = tindex;
+	} else if (parm->pattern.bProtocolEnable == 1) {
+		/* Only outer IP protocol table */
+		prtcol_tbl_t   pctl_tbl;
+		memset(&pctl_tbl, 0, sizeof(prtcol_tbl_t));
+		pctl_tbl.ethertype = (parm->pattern.nProtocol & 0xFF);
+		pctl_tbl.ethertype |= (0xFF << 8);
+		pctl_tbl.emask = (parm->pattern.nProtocolMask  & 0x3);
+		pctl_tbl.emask |= (0x3 << 2); //Mask out inner Proto value.
+		tindex = pce_ptcl_tbl_write(cdev, &pthandle->pce_sub_tbl, &pctl_tbl);
+
+		if (tindex < 0)
+			return tindex;
+
+		ptable->ip_prot_idx = tindex;
+	} else {
+		ptable->ip_prot_idx = 0xFF; //Mark as don't care.
+	}
+
+	ptbl.key[1] |= (ptable->ip_prot_idx << 8);
+
+	/* Pattern field -  PPPoE table */
+	if (parm->pattern.bSessionIdEnable == 1) {
+		pce_ppoe_tbl_t  pppoe_tbl;
+		pppoe_tbl.sess_id = parm->pattern.nSessionId;
+		tindex = pce_tm_pppoe_tbl_write(cdev, &pthandle->pce_sub_tbl,
+						&pppoe_tbl);
+
+		if (tindex < 0)
+			return tindex;
+
+		ptable->pppoe_idx = tindex;
+	} else {
+		ptable->pppoe_idx = 0xFF; //Mark as don't care.
+	}
+
+	ptbl.key[7] |= (ptable->pppoe_idx << 8);
+
+	/* Pattern field - VID value */
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		tindex = 0x7F; //Mark as don't care.
+
+		/* Pattern field - inner VID */
+		if (parm->pattern.bVid == 1) {
+			tindex = pce_vid_index(cdev,
+					       &pthandle->pce_sub_tbl, parm->pattern.nVid);
+
+			if (reg_val == 1) {  /*ETC*/
+				if (tindex == 0x7F)
+					tindex = act_vlan_id_create(cdev,
+								    parm->pattern.nVid,
+								    parm->pattern.bVidRange_Select,
+								    parm->pattern.nVidRange);
+			} else {
+				if (tindex == 0x7F) {
+					pr_err("%s:%s:%d (Create VID before use it)\n",
+					       __FILE__, __func__, __LINE__);
+					return -1;
+				}
+			}
+		}
+
+		ptable->vlan_idx = tindex;
+		ptbl.key[0] &= ~(0xFF << 8);
+		ptbl.key[0] |= (ptable->vlan_idx << 8);
+
+		/* Pattern field - outer VID */
+		tindex = 0x7F; //Mark as don't care.
+
+		/* ETC */
+		if (reg_val == 1) {
+			if (parm->pattern.bSLAN_Vid == 1) {
+				tindex = pce_vid_index(cdev,
+						       &pthandle->pce_sub_tbl,
+						       parm->pattern.nSLAN_Vid);
+
+				if (tindex == 0x7F)
+					tindex = act_vlan_id_create(cdev,
+								    parm->pattern.nSLAN_Vid, 0, 0);
+			}
+
+			ptable->svlan_idx = tindex;
+			ptbl.key[8] &= ~(0xFF << 8);
+			ptbl.key[8] |= (ptable->svlan_idx << 8);
+		}
+	}
+
+	/* Pattern field - VID value */
+	if (IS_VRSN_31(gswdev->gipver)) {
+		/* Pattern field - inner VID */
+		if (parm->pattern.bVid == 1) {
+			ptbl.key[20] |= (parm->pattern.nVid & 0x0FFF);
+			ptbl.key[20] |= (parm->pattern.bVid_Original << 15);
+
+			if (parm->pattern.bVidRange_Select)
+				ptbl.key[21] |= (parm->pattern.nVidRange & 0xFFF);
+		} else {
+			ptbl.key[20] |= 0x1FFF; //Mark as don't care.
+		}
+
+		/* Pattern field - outer VID */
+		if (parm->pattern.bSLAN_Vid == 1) {
+			ptbl.key[18] |= (parm->pattern.nSLAN_Vid & 0x0FFF);
+			ptbl.key[18] |= (parm->pattern.bOuterVid_Original << 15);
+
+			if (parm->pattern.bSVidRange_Select)
+				ptbl.key[19] |= (parm->pattern.nOuterVidRange & 0xFFF);
+		} else {
+			ptbl.key[18] |= 0x1FFF; //Mark as don't care.
+		}
+	}
+
+	/* Pattern field - Sub-IF ID value */
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (parm->pattern.bSubIfIdEnable == 1)
+			ptbl.key[14] |= (parm->pattern.nSubIfId & 0xF);
+		else
+			ptbl.key[14] |= 0x1F; //Mark as don't care.
+	}
+
+	/* Pattern field - Sub-IF ID value */
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if (parm->pattern.bSubIfIdEnable == 1) {
+			ptbl.key[17] |= (parm->pattern.nSubIfId & 0x0FF);
+
+			switch (parm->pattern.eSubIfIdType) {
+			case GSW_PCE_SUBIFID_TYPE_BRIDGEPORT:
+				ptbl.key[17] |= (0x1 << 9);
+				break;
+
+			default:
+				break;
+			}
+		} else {
+			ptbl.key[17] |= 0x1FF; //Mark as don't care.
+		}
+
+		/* Pattern field - 'INS' falg value */
+		if (parm->pattern.bInsertionFlag_Enable == 1) {
+			if ((parm->pattern.nInsertionFlag) & 0x3) {
+				ptbl.key[17] |= (((parm->pattern.nInsertionFlag) & 0x3) << 10);
+			}
+		} else {
+			ptbl.key[17] |= (3 << 10); //Don't care condition.
+		}
+
+		/* Pattern field - Exclude bits */
+		if (parm->pattern.bParserFlag1LSB_Exclude == 1)
+			ptbl.key[14] |= (1 << 5);
+
+		if (parm->pattern.bParserFlag1MSB_Exclude == 1)
+			ptbl.key[14] |= (1 << 6);
+	}
+
+	/* Pattern field - Exclude bits */
+	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		if (parm->pattern.bPortId_Exclude == 1)
+			ptbl.key[14] |= (1 << 7);
+
+		if (parm->pattern.bVid_Exclude == 1)
+			ptbl.key[14] |= (1 << 8);
+
+		if (parm->pattern.bEtherType_Exclude == 1)
+			ptbl.key[14] |= (1 << 9);
+
+		if (parm->pattern.bProtocol_Exclude == 1)
+			ptbl.key[14] |= (1 << 10);
+
+		if (parm->pattern.bSrcIP_Exclude == 1)
+			ptbl.key[14] |= (1 << 11);
+
+		if (parm->pattern.bDstIP_Exclude == 1)
+			ptbl.key[14] |= (1 << 12);
+
+		/* source port */
+		if (parm->pattern.bAppMSB_Exclude == 1)
+			ptbl.key[14] |= (1 << 13);
+
+		if (parm->pattern.bAppLSB_Exclude == 1)
+			ptbl.key[14] |= (1 << 14);
+
+		if (parm->pattern.bSrcMAC_Exclude == 1)
+			ptbl.key[14] |= (1 << 15);
+
+		if (parm->pattern.bDstMAC_Exclude == 1)
+			ptbl.key[15] |= (1 << 0);
+
+		if (parm->pattern.bCTAG_PCP_DEI_Exclude == 1)
+			ptbl.key[15] |= (1 << 1);
+
+		if (parm->pattern.bSTAG_PCP_DEI_Exclude == 1)
+			ptbl.key[15] |= (1 << 2);
+
+		if (parm->pattern.bDSCP_Exclude == 1)
+			ptbl.key[15] |= (1 << 3);
+
+		if (parm->pattern.bPktLng_Exclude == 1)
+			ptbl.key[15] |= (1 << 4);
+
+		if (parm->pattern.bSessionId_Exclude == 1)
+			ptbl.key[15] |= (1 << 5);
+
+		if (parm->pattern.bSLANVid_Exclude == 1)
+			ptbl.key[15] |= (1 << 6);
+
+		if (parm->pattern.bPPP_Protocol_Exclude == 1)
+			ptbl.key[15] |= (1 << 7);
+
+		if (parm->pattern.bInnerDSCP_Exclude == 1)
+			ptbl.key[15] |= (1 << 8);
+
+		if (parm->pattern.bInnerSrcIP_Exclude == 1)
+			ptbl.key[15] |= (1 << 9);
+
+		if (parm->pattern.bInnerDstIP_Exclude == 1)
+			ptbl.key[15] |= (1 << 10);
+
+		if (parm->pattern.bParserFlagLSB_Exclude == 1)
+			ptbl.key[15] |= (1 << 11);
+
+		if (parm->pattern.bParserFlagMSB_Exclude == 1)
+			ptbl.key[15] |= (1 << 12);
+
+		if (parm->pattern.bPayload1_Exclude == 1)
+			ptbl.key[15] |= (1 << 13);
+
+		if (parm->pattern.bPayload2_Exclude == 1)
+			ptbl.key[15] |= (1 << 14);
+
+		if (parm->pattern.bSubIfId_Exclude == 1)
+			ptbl.key[15] |= (1 << 15);
+	}
+
+	/* Populate 'action' parameter values */
+	paction = &(pthandle->pce_act[idx]);
+	memcpy(paction, &parm->action, sizeof(GSW_PCE_action_t));
+
+	/* Port forwarding action */
+	if (paction->ePortMapAction != GSW_PCE_ACTION_PORTMAP_DISABLE) {
+		if (paction->eSnoopingTypeAction == GSW_PCE_ACTION_IGMP_SNOOP_DISABLE) {
+			ptbl.val[0] |= 1; //Enable port-map action.
+			ptbl.val[4] |= (0x3 << 2); //Set to 'traffic-flow' portmap MUX control.
+
+			switch (paction->ePortMapAction) {
+			case GSW_PCE_ACTION_PORTMAP_REGULAR:
+				ptbl.val[4] &= ~(0x3 << 2); //Set to 'default' portmap MUX control.
+				break;
+
+			case GSW_PCE_ACTION_PORTMAP_DISCARD:
+				break;
+
+			case GSW_PCE_ACTION_PORTMAP_CPU:
+			case GSW_PCE_ACTION_PORTMAP_ALTERNATIVE:
+				if (gswdev->gipver == LTQ_GSWIP_3_0) {
+					/* CPU port-map */ //Govind - Need to test for 3.0 with MC router.
+					ptbl.val[1] = (paction->nForwardPortMap[0] & 0xFFFF);
+				}
+
+				if (IS_VRSN_31(gswdev->gipver)) {
+					for (i = 0; i <= 7; i++)
+						ptbl.val[i + 10] = (paction->nForwardPortMap[i]);
+				}
+
+				//If CPU type set to 'MC router' portmap MUX control.
+				if (paction->ePortMapAction == GSW_PCE_ACTION_PORTMAP_CPU) {
+					ptbl.val[4] &= ~(0x3 << 2);
+					ptbl.val[4] |= (0x1 << 2); //Govind - why CPU type to MC router?
+				}
+
+				break;
+
+			/* To fix compilation warnings*/
+			default:
+				break;
+			}
+		} else {
+			switch (paction->eSnoopingTypeAction) {
+			case GSW_PCE_ACTION_IGMP_SNOOP_REPORT:
+			case GSW_PCE_ACTION_IGMP_SNOOP_LEAVE:
+				ptbl.val[0] |= 1;
+				ptbl.val[4] &= ~(0x3 << 2);
+				//Set to 'MC router' portmap MUX control.
+				ptbl.val[4] |= (0x1 << 2);
+				break;
+
+			default:
+				ptbl.val[0] |= 1;
+				//Set to 'default' portmap MUX control.
+				ptbl.val[4] &= ~(0x3 << 2);
+				break;
+			}
+		}
+	} else {
+		/* Disable port map action */
+		ptbl.val[0] &= ~1;
+
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			ptbl.val[1] = 0xFFFF;
+		}
+
+		//Govind - But why do we need to do below?
+		if (IS_VRSN_31(gswdev->gipver)) {
+			for (i = 0; i <= 7; i++)
+				ptbl.val[i + 10] = 0xFFFF;
+		}
+
+		ptbl.val[4] &= ~(0x3 << 2);
+	}
+
+	/* Flow-ID action */
+	/* In 3.0, bFlowID_Action and ePortMapAction should be exclusively */
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		if (paction->bFlowID_Action != 0) {
+			if (paction->ePortMapAction == GSW_PCE_ACTION_PORTMAP_DISABLE) {
+				/* Enable flow ID action */
+				ptbl.val[4] |= (0x1 << 4);
+				ptbl.val[1] = paction->nFlowID & 0xFFFF;
+			} else {
+				pr_err("%s:%s:%d (Portmap & FlowID can be used exclusively)\n",
+				       __FILE__, __func__, __LINE__);
+				return -1;
+			}
+		}
+	}
+
+	/* Inner and outer VLAN action */
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		tindex = 0x7F;
+		ptbl.val[2] = 0;
+		ptbl.val[0] &= ~(1 << 13);
+
+		if (paction->eVLAN_Action != GSW_PCE_ACTION_VLAN_DISABLE) {
+			ptbl.val[0] |= (1 << 1);
+
+			if (paction->eVLAN_Action == GSW_PCE_ACTION_VLAN_ALTERNATIVE) {
+				if (reg_val == 1) {
+					/*ETC */
+					ptbl.val[5] |= ((paction->nVLAN_Id & 0xFFF) << 4);
+					ptbl.val[2] |= ((paction->nFId & 0xFF) << 8);
+					/* Alternative CTAG VLAN ID and FID */
+					ptbl.val[5] |= (1 << 3);
+					ptbl.val[0] |= (1 << 13);
+				} else {
+					avlan_tbl_t vatable;
+					memset(&vatable, 0, sizeof(avlan_tbl_t));
+					vatable.vid = paction->nVLAN_Id;
+					tindex = pce_vlan_id_fid_index(cdev,
+								       &pthandle->pce_sub_tbl, &vatable);
+
+					if (tindex != 0x7F) {
+						ptbl.val[2] = (tindex & 0xFF);
+						ptbl.val[2] |= ((vatable.fid & 0xFF) << 8);
+						ptbl.val[0] |= (1 << 13);
+					}
+				}
+			}
+		}
+
+		/* ETC */
+		if (reg_val == 1) {
+			ptbl.val[6] = 0;
+
+			if (paction->eSVLAN_Action != GSW_PCE_ACTION_VLAN_DISABLE) {
+				ptbl.val[0] |= (1 << 1);
+				/*  Default CTAG VLAN ID and FID */
+				ptbl.val[6] &= ~(1 << 3);
+
+				if (paction->eSVLAN_Action == GSW_PCE_ACTION_VLAN_ALTERNATIVE) {
+					ptbl.val[6] |= ((paction->nSVLAN_Id & 0xFFF) << 4);
+					ptbl.val[0] |= (1 << 13);
+					ptbl.val[6] |= (1 << 3);
+				}
+			}
+		}
+	}
+
+	//Extended VLAN tagging action.
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if (paction->bExtendedVlanEnable) {
+			ptbl.val[0] |= (1 << 1); //Enable VLAN action.
+			ptbl.val[6] |= (1 << 3); //Enable extended VLAN tagging.
+			ptbl.val[6] |= ((paction->nExtendedVlanBlockId & 0x3FF) << 4);
+		}
+	}
+
+	/* Traffic class action */
+	if (paction->eTrafficClassAction != GSW_PCE_ACTION_TRAFFIC_CLASS_DISABLE) {
+		ptbl.val[0] |= (1 << 2);
+
+		switch (paction->eTrafficClassAction) {
+		case GSW_PCE_ACTION_TRAFFIC_CLASS_ALTERNATIVE:
+			ptbl.val[0] |= (1 << 14);
+			ptbl.val[3] |= (paction->nTrafficClassAlternate & 0xF) << 8;
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	/* Cross VLAN action */
+	if (paction->eVLAN_CrossAction != GSW_PCE_ACTION_CROSS_VLAN_DISABLE) {
+		ptbl.val[0] |= (1 << 4);
+
+		if (paction->eVLAN_CrossAction == GSW_PCE_ACTION_CROSS_VLAN_CROSS)
+			ptbl.val[3] |= (1 << 15);
+	}
+
+	/* Cross state action */
+	if (paction->eCrossStateAction != GSW_PCE_ACTION_CROSS_STATE_DISABLE) {
+		ptbl.val[0] |= (1 << 5);
+
+		if (paction->eCrossStateAction == GSW_PCE_ACTION_CROSS_STATE_CROSS)
+			ptbl.val[4] |= (1 << 13);
+	}
+
+	/* Critical frame action */
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (paction->eCritFrameAction !=
+		    GSW_PCE_ACTION_CRITICAL_FRAME_DISABLE) {
+			ptbl.val[0] |= (1 << 6);
+
+			if (paction->eCritFrameAction ==
+			    GSW_PCE_ACTION_CRITICAL_FRAME_CRITICAL)
+				ptbl.val[4] |= (1 << 14);
+		}
+	}
+
+	/* Color action */
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if (paction->eColorFrameAction != GSW_PCE_ACTION_COLOR_FRAME_DISABLE) {
+			ptbl.val[0] |= (1 << 6);
+
+			switch (paction->eColorFrameAction) {
+			case GSW_PCE_ACTION_COLOR_FRAME_CRITICAL:
+				ptbl.val[2] |= 0x4;
+				break;
+
+			case GSW_PCE_ACTION_COLOR_FRAME_GREEN:
+				ptbl.val[2] |= 0x5;
+				break;
+
+			case GSW_PCE_ACTION_COLOR_FRAME_YELLOW:
+				ptbl.val[2] |= 0x6;
+				break;
+
+			case GSW_PCE_ACTION_COLOR_FRAME_RED:
+				ptbl.val[2] |= 0x7;
+				break;
+
+			default:/*GSW_PCE_ACTION_COLOR_FRAME_NO_CHANGE*/
+				break;
+			}
+		}
+	}
+
+	/* Time stamp action */
+	if (paction->eTimestampAction != GSW_PCE_ACTION_TIMESTAMP_DISABLE) {
+		ptbl.val[0] |= (1 << 7);
+
+		if (paction->eTimestampAction == GSW_PCE_ACTION_TIMESTAMP_STORED) {
+			ptbl.val[4] |= (1 << 15);
+			ptbl.val[8] |= ((paction->nRecordId & 0xFFF) << 4);
+		}
+	}
+
+	/* Interrupt action */
+	if (paction->eIrqAction != GSW_PCE_ACTION_IRQ_DISABLE) {
+		ptbl.val[0] |= (1 << 8);
+
+		if (paction->eIrqAction == GSW_PCE_ACTION_IRQ_EVENT)
+			ptbl.val[0] |= (1 << 15);
+	}
+
+	/* MAC Learning action */
+	if (paction->eLearningAction != GSW_PCE_ACTION_LEARNING_DISABLE) {
+		ptbl.val[0] |= (1 << 9);
+
+		switch (paction->eLearningAction) {
+		case GSW_PCE_ACTION_LEARNING_REGULAR:
+			//ptbl.val[4] &= ~(0x3);
+			break;
+
+		case GSW_PCE_ACTION_LEARNING_FORCE_NOT:
+			ptbl.val[4] |= 0x2;
+			break;
+
+		case GSW_PCE_ACTION_LEARNING_FORCE:
+			ptbl.val[4] |= 0x3;
+			break;
+
+		default:
+			ptbl.val[4] |= 0x1;
+			break;
+		}
+	}
+
+	/* IGMP Snooping action. */
+	if (paction->eSnoopingTypeAction != GSW_PCE_ACTION_IGMP_SNOOP_DISABLE) {
+		ptbl.val[0] |= (1 << 10);
+
+		switch (paction->eSnoopingTypeAction) {
+		case GSW_PCE_ACTION_IGMP_SNOOP_REGULAR:
+			//ptbl.val[4] |= (0 << 5);
+			break;
+
+		case GSW_PCE_ACTION_IGMP_SNOOP_REPORT:
+			ptbl.val[4] |= (1 << 5);
+			break;
+
+		case GSW_PCE_ACTION_IGMP_SNOOP_LEAVE:
+			ptbl.val[4] |= (2 << 5);
+			break;
+
+		case GSW_PCE_ACTION_IGMP_SNOOP_AD:
+			ptbl.val[4] |= (3 << 5);
+			break;
+
+		case GSW_PCE_ACTION_IGMP_SNOOP_QUERY:
+			ptbl.val[4] |= (4 << 5);
+			break;
+
+		case GSW_PCE_ACTION_IGMP_SNOOP_QUERY_GROUP:
+			ptbl.val[4] |= (5 << 5);
+			break;
+
+		case GSW_PCE_ACTION_IGMP_SNOOP_QUERY_NO_ROUTER:
+			ptbl.val[4] |= (6 << 5);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	/* Metering action */
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (paction->eMeterAction != GSW_PCE_ACTION_METER_DISABLE) {
+			ptbl.val[0] |= (1 << 11);
+			ptbl.val[3] |= (paction->nMeterId & 0x1F);
+
+			switch (paction->eMeterAction) {
+			case GSW_PCE_ACTION_METER_REGULAR:
+				ptbl.val[3] |= 0 << 6;
+				break;
+
+			case GSW_PCE_ACTION_METER_1:
+				ptbl.val[3] |= 1 << 6;
+				break;
+
+			/*case GSW_PCE_ACTION_METER_2:
+				ptbl.val[3] |= 2 << 6;
+				break;*/
+			case GSW_PCE_ACTION_METER_1_2:
+				ptbl.val[3] |= 3 << 6;
+				break;
+
+			case GSW_PCE_ACTION_METER_DISABLE:
+				break;
+			}
+		} else {
+			ptbl.val[3] |= 0x1F;
+		}
+	}
+
+	/* Metering action */
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if (paction->eMeterAction != GSW_PCE_ACTION_METER_DISABLE) {
+			ptbl.val[0] |= (1 << 11);
+
+			switch (paction->eMeterAction) {
+			case GSW_PCE_ACTION_METER_1:
+				ptbl.val[3] |= 1 << 7;
+				ptbl.val[3] |= (paction->nMeterId & 0x7F);
+				break;
+
+			default:
+				break;
+			}
+		}
+
+		/* FID action */
+		if (paction->bFidEnable == 1) {
+			ptbl.val[5] |= (1 << 3);
+			ptbl.val[2] |= ((paction->nFId) & 0x3F) << 8;
+		}
+	}
+
+	/* RMON action */
+	if (IS_VRSN_NOT_31(gswdev->gipver)) {
+		if (paction->bRMON_Action != 0) {
+			ptbl.val[0] |= (1 << 12);
+			ptbl.val[4] &= ~(0x1F << 8);
+
+			if (paction->nRMON_Id < 24)  {
+				ptbl.val[4] |= ((paction->nRMON_Id + 1) << 8);
+			} else  {
+				return -1;
+			}
+		} else {
+			ptbl.val[0] &= ~(1 << 12);
+			ptbl.val[4] &= ~(0x1F << 8);
+		}
+	}
+
+	/* RMON or Flow-ID action. */
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if ((paction->bFlowID_Action != 0) && (paction->bRMON_Action != 0)) {
+			if (paction->nFlowID != paction->nRMON_Id) {
+				pr_err("RMON counter ID & FlowID should be equal.\n");
+				return -1;
+			}
+		}
+
+		if (paction->bFlowID_Action != 0) {
+			if (!(paction->nFlowID)) {
+				pr_err("Flow-ID zero is reserved.\n");
+				return -1;
+			}
+
+			ptbl.val[4] |= (0x1 << 4);
+			ptbl.val[1] = paction->nFlowID & 0xFF;
+		}
+
+		if (paction->bRMON_Action != 0) {
+			if (!(paction->nRMON_Id)) {
+				pr_err("RMON-ID zero is reserved.\n");
+				return -1;
+			}
+
+			ptbl.val[4] |= (1 << 4);
+			ptbl.val[1] = paction->nRMON_Id & 0xFF;
+		}
+	}
+
+	/* Remarking action. */
+	if (gswdev->gipver == LTQ_GSWIP_3_0) {
+		ptbl.val[3] |= (0x7 << 12);
+
+		if (paction->bRemarkDSCP == 1)
+			ptbl.val[3] &= ~(1 << 12);
+		else
+			ptbl.val[3] |= (1 << 12);
+
+		if (paction->bRemarkClass == 1)
+			ptbl.val[3] &= ~(1 << 13);
+		else
+			ptbl.val[3] |= (1 << 13);
+
+		if (paction->bRemarkPCP == 1)
+			ptbl.val[3] &= ~(1 << 14);
+		else
+			ptbl.val[3] |= (1 << 14);
+
+		/* ETC */
+		if (paction->bRemarkSTAG_PCP == 1)
+			ptbl.val[6] &= ~(1 << 1);
+		else
+			ptbl.val[6] |= (1 << 1);
+
+		if (paction->bRemarkSTAG_DEI == 1)
+			ptbl.val[6] &= ~(1 << 2);
+		else
+			ptbl.val[6] |= (1 << 2);
+
+		if (paction->bPortBitMapMuxControl == 1) {
+			ptbl.val[6] |= (1 << 0);
+			ptbl.val[1] = paction->nForwardPortMap[0];
+		} else
+			ptbl.val[6] &= ~(1 << 0);
+
+		/* Remarking action enable */
+		if (paction->bRemarkAction != 0)
+			ptbl.val[0] |= (1 << 3);
+		else
+			ptbl.val[0] &= ~(1 << 3);
+
+		/*	CVLAN Ignore action */
+		if (paction->bCVLAN_Ignore_Control == 1) {
+			ptbl.val[5] |= (1 << 2);
+			ptbl.val[0] |= (1 << 1); //Govind - why set this bit?
+		}	else {
+			ptbl.val[5] &= ~(1 << 2);
+		}
+	}
+
+	/* Trunking action enable */
+	if (paction->bPortTrunkAction == 1)
+		ptbl.val[5] |= (1 << 0);
+
+	/* Port link selection control */
+	if (paction->bPortLinkSelection == 1)
+		ptbl.val[5] |= (1 << 1);
+
+	/* IGMP snoop control */
+	if (gswdev->gipver == LTQ_GSWIP_3_0 || IS_VRSN_31(gswdev->gipver)) {
+		if (paction->ePortFilterType_Action !=
+		    GSW_PCE_PORT_FILTER_ACTION_UNUSED) {
+			if (paction->ePortMapAction == GSW_PCE_ACTION_PORTMAP_DISABLE) {
+				ptbl.val[7] &= ~(0x3F << 1);
+
+				switch (paction->ePortFilterType_Action) {
+				case GSW_PCE_PORT_FILTER_ACTION_1:
+					ptbl.val[7] |= (1 << 1);
+					break;
+
+				case GSW_PCE_PORT_FILTER_ACTION_2:
+					ptbl.val[7] |= (1 << 2);
+					break;
+
+				case GSW_PCE_PORT_FILTER_ACTION_3:
+					ptbl.val[7] |= (1 << 3);
+					break;
+
+				case GSW_PCE_PORT_FILTER_ACTION_4:
+					ptbl.val[7] |= (1 << 4);
+					break;
+
+				case GSW_PCE_PORT_FILTER_ACTION_5:
+					ptbl.val[7] |= (1 << 5);
+					break;
+
+				case GSW_PCE_PORT_FILTER_ACTION_6:
+					ptbl.val[7] |= (1 << 6);
+					break;
+
+				default:
+					break;
+				}
+
+				if (gswdev->gipver == LTQ_GSWIP_3_0) {
+					ptbl.val[1] = (paction->nForwardPortMap[0] & 0xFFFF);
+				}
+
+				//Port-member map.
+				if (IS_VRSN_31(gswdev->gipver)) {
+					for (i = 0; i <= 7; i++)
+						ptbl.val[i + 10] = paction->nForwardPortMap[i];
+				}
+			}
+		}
+
+		/* Processing path action */
+		if (paction->eProcessPath_Action != GSW_PCE_PROCESSING_PATH_UNUSED) {
+			ptbl.val[8] |= (1 << 0);
+
+			switch (paction->eProcessPath_Action) {
+			case GSW_PCE_PROCESSING_PATH_1:
+				ptbl.val[8] |= (1 << 1);
+				break;
+
+			case GSW_PCE_PROCESSING_PATH_2:
+				ptbl.val[8] |= (1 << 2);
+				break;
+
+			case GSW_PCE_PROCESSING_PATH_BOTH:
+				ptbl.val[8] |= (3 << 1);
+				break;
+
+			default:
+				break;
+			}
+		}
+
+		/* Routing action */
+		if (gswdev->gipver == LTQ_GSWIP_3_0) {
+			if (gswdev->sdev == LTQ_FLOW_DEV_INT_R) {
+				if (paction->bRoutExtId_Action == 1)
+					ptbl.val[9] |= ((paction->nRoutExtId & 0xFF) << 8);
+				else
+					ptbl.val[9] |= (0xFF << 8);
+
+				if (paction->bRtDstPortMaskCmp_Action == 1)
+					ptbl.val[9] &= ~(1 << 6);
+				else
+					ptbl.val[9] |= (1 << 6);
+
+				if (paction->bRtSrcPortMaskCmp_Action == 1)
+					ptbl.val[9] &= ~(1 << 5);
+				else
+					ptbl.val[9] |= (1 << 5);
+
+				if (paction->bRtDstIpMaskCmp_Action == 1)
+					ptbl.val[9] &= ~(1 << 4);
+				else
+					ptbl.val[9] |= (1 << 4);
+
+				if (paction->bRtSrcIpMaskCmp_Action == 1)
+					ptbl.val[9] &= ~(1 << 3);
+				else
+					ptbl.val[9] |= (1 << 3);
+
+				if (paction->bRtInnerIPasKey_Action == 1)
+					ptbl.val[9] |= (1 << 2);
+				else
+					ptbl.val[9] &= ~(1 << 2);
+
+				if (paction->bRtAccelEna_Action == 1)
+					ptbl.val[9] |= (1 << 1);
+				else
+					ptbl.val[9] &= ~(1 << 1);
+
+				if (paction->bRtCtrlEna_Action == 1)
+					ptbl.val[9] |= (1 << 0);
+				else
+					ptbl.val[9] &= ~(1 << 0);
+			}
+		}
+	}
+
+	/* OAM and packet extraction to CPU action */
+	if (IS_VRSN_31(gswdev->gipver)) {
+		if ((paction->bExtractEnable == 1) || (paction->bOamEnable == 1)) {
+			ptbl.val[8] |= (1 << 0);
+
+			if (paction->bExtractEnable == 1) {
+				ptbl.val[7] |= (1 << 8); /* Extraction flag */
+			}
+
+			if (paction->bOamEnable == 1) {
+				ptbl.val[8] |= (1 << 3); /* OAM flag*/
+				/*OAM and extraction packet control*/
+				ptbl.val[8] |= ((paction->nRecordId & 0xFFF) << 4);
+			}
+		}
+	}
+
+	ptbl.pcindex = idx;
+	ptbl.table = PCE_TFLOW_INDEX;
+	ptbl.valid = 1;
+
+	status = gsw_pce_table_write(cdev, &ptbl);
+
+	if (status == GSW_statusOk)
+		return GSW_statusOk;
+	else
+		return status;
+
+	return GSW_statusOk;
+}
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_gphy_fw.c b/drivers/net/ethernet/lantiq/switch-api/gsw_gphy_fw.c
new file mode 100644
index 000000000000..8937438a5811
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_gphy_fw.c
@@ -0,0 +1,1377 @@
+/******************************************************************************
+
+                         Copyright (c) 2012, 2014, 2015
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/pm.h>
+#include <linux/export.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/vmalloc.h>
+#include <linux/dma-mapping.h>
+#include <linux/firmware.h>
+#include <asm/uaccess.h>
+#include <linux/mm.h>
+#include <asm/reboot.h>
+#include <linux/kthread.h>
+#include <lantiq_soc.h>
+//#include <ifx_ethsw_kernel_api.h>
+//#include <switch-api/lantiq_ethsw_api.h>
+//#include "gsw_init.h"
+#include <xway/switch-api/lantiq_gsw_api.h>
+#include <net/switch-api/gsw_dev.h>
+
+static struct proc_dir_entry *g_proc_gphy_dir;
+
+static int dev_id;
+static struct device_node *gphy_node;
+static struct device *gphy_dev;
+const char *g_gphy_fw_mode = NULL;
+static int g_no_phys, pw_save_mode;
+static dma_addr_t g_dev_addr = 0;
+static dma_addr_t f_dev_addr = 0;
+static void *g_fw_addr;
+static void *f_fw_addr;
+#define XWAY_GPHY_FW_ALIGN	(16 * 1024)
+#define XWAY_GPHY_FW_ALIGN_MASK (XWAY_GPHY_FW_ALIGN - 1)
+static u8 *g_gphy_fw_dma = NULL;
+static u8 *f_gphy_fw_dma = NULL;
+#define	IH_MAGIC_NO	0x27051956	/* Image Magic Number		*/
+#define IH_NMLEN		32	/* Image Name Length		*/
+#define VERSIONLEN	16
+
+/** image header format */
+typedef struct gphy_image_header {
+	uint32_t	immagic;	 /* Magic Number	*/
+	uint32_t	imhcrc;	 /* CRC Checksum	*/
+	uint32_t	imtime;	/* Timestamp	*/
+	uint32_t	imsize;	/* Data Size		*/
+	uint32_t	imload;	/* Load  Address		*/
+	uint32_t	imep;		/* Entry Point */
+	uint32_t	imdcrc;	/* Data CRC Checksum	*/
+	uint8_t		imos;		/* OS */
+	uint8_t		imarch;	/* architecture of CPU */
+	uint8_t		imtype;	/* Type of image	*/
+	uint8_t		imcomp;	/* type of Compression */
+	uint8_t		imname[IH_NMLEN];	/* Image Name		*/
+#ifdef CONFIG_LANTIQ_IMAGE_EXTRA_CHECKS
+	uint8_t     ihvendor[IH_NMLEN]; /* 32 char Vendor Name String */
+	uint8_t     ihboard[IH_NMLEN]; /* 32 char Board Name String */
+	uint8_t     ihboardVer[VERSIONLEN]; /* Board Version 16 char str */
+	uint8_t     ihchip[IH_NMLEN]; /* 32 char Chip Name String */
+	uint8_t     ihchipVer[VERSIONLEN]; /* Chip Version16 char string */
+	uint8_t     ihswVer[VERSIONLEN]; /* Software Version-16 char string*/
+#endif /* CONFIG_LANTIQ_IMAGE_EXTRA_CHECKS */
+} gphy_image_header_t;
+struct core_ops *ops;
+struct task_struct *gphy_pw_id;
+static int gphy_pw_save_thread(void *arg);
+/* Signal Related */
+wait_queue_head_t gphy_pw_wait;
+unsigned int phy_port_nos[6];
+unsigned int phy_fw_type[6];
+static unsigned int on_interval = 4;
+static unsigned int off_interval = 5;
+#define NUM_OF_PORTS 6
+static int gphy_link_status[NUM_OF_PORTS] = {0};
+static int gphy_power_down[NUM_OF_PORTS] = {0};
+static unsigned int power_down_cnt[NUM_OF_PORTS] = {0};
+static int ssd_err_mode = 0;
+static unsigned int ssd_interval = 4;
+/*#define PHY_SSD_ERROR	0 */
+#if defined(PHY_SSD_ERROR) && PHY_SSD_ERROR
+struct task_struct *gphy_ssd_id;
+wait_queue_head_t gphy_ssd_wait;
+static int gphy_ssd_err_thread(void *arg);
+static unsigned int ssd_cnt[NUM_OF_PORTS] = {0};
+#endif /* PHY_SSD_ERROR */
+
+/* reset request register */
+#define RCU_RST_REQ		0x0010
+
+/* reboot bit */
+#define RCU_RD_GPHY0_XRX200	BIT(31)
+#define RCU_RD_SRST		BIT(30)
+#define RCU_RD_GPHY1_XRX200	BIT(29)
+/* vr9 gphy registers */
+#define RCU_GFS_ADD0_XRX200	0x0020
+#define RCU_GFS_ADD1_XRX200	0x0068
+
+/* xRX300 gphy registers */
+#define RCU_GFS_ADD0_XRX300	0x0020
+#define RCU_GFS_ADD1_XRX300	0x0058
+#define RCU_GFS_ADD2_XRX300	0x00AC
+
+/* xRX330 gphy registers */
+#define RCU_GFS_ADD0_XRX330	0x0020
+#define RCU_GFS_ADD1_XRX330	0x0058
+#define RCU_GFS_ADD2_XRX330	0x00AC
+#define RCU_GFS_ADD3_XRX330	0x0264
+
+/* xRX300 bits */
+#define RCU_RD_GPHY0_XRX300	BIT(31)
+#define RCU_RD_GPHY1_XRX300	BIT(29)
+#define RCU_RD_GPHY2_XRX300	BIT(28)
+
+/* xRX330 bits */
+#define RCU_RD_GPHY0_XRX330	BIT(31)
+#define RCU_RD_GPHY1_XRX330	BIT(29)
+#define RCU_RD_GPHY2_XRX330	BIT(28)
+#define RCU_RD_GPHY3_XRX330	BIT(10)
+
+
+/* xRX500 gphy (GSW-R) registers */
+#define GSW_L_TOP_BASE 0xBC003C00
+
+/* xRX500 gphy (GSW-L) registers */
+#define GPHY2_LBADR_XRX500	0x0228
+#define GPHY2_MBADR_XRX500	0x022C
+#define GPHY3_LBADR_XRX500	0x0238
+#define GPHY3_MBADR_XRX500	0x023c
+#define GPHY4_LBADR_XRX500	0x0248
+#define GPHY4_MBADR_XRX500	0x024C
+#define GPHY5_LBADR_XRX500	0x0258
+#define GPHY5_MBADR_XRX500	0x025C
+#define GPHYF_LBADR_XRX500	0x0268
+#define GPHYF_MBADR_XRX500	0x026C
+
+/* xRX500 bits */
+#define RCU_RD_GPHY2_XRX500	BIT(29)
+#define RCU_RD_GPHY3_XRX500	BIT(28)
+#define RCU_RD_GPHY4_XRX500	BIT(26)
+#define RCU_RD_GPHY5_XRX500	BIT(25)
+#define RCU_RD_GPHYF_XRX500	BIT(31)
+
+/* xRX300 gphy registers */
+/*#define RCU_GFS_ADD0_XRX300	0x0020
+#define RCU_GFS_ADD1_XRX300	0x0058
+#define RCU_GFS_ADD2_XRX300	0x00AC
+*/
+/* xRX330 gphy registers */
+/*#define RCU_GFS_ADD0_XRX330	0x0020
+#define RCU_GFS_ADD1_XRX330	0x0058
+#define RCU_GFS_ADD2_XRX330	0x00AC
+#define RCU_GFS_ADD3_XRX330	0x0264
+*/
+/* reset / boot a gphy */
+static struct ltq_xrx200_gphy_reset {
+	u32 rd;
+	u32 addr;
+} xrx200_gphy[] = {
+	{RCU_RD_GPHY0_XRX200, RCU_GFS_ADD0_XRX200},
+	{RCU_RD_GPHY1_XRX200, RCU_GFS_ADD1_XRX200},
+};
+
+/* reset / boot a gphy */
+static struct ltq_xrx300_gphy_reset {
+	u32 rd;
+	u32 addr;
+} xrx300_gphy[] = {
+	{RCU_RD_GPHY0_XRX300, RCU_GFS_ADD0_XRX300},
+	{RCU_RD_GPHY1_XRX300, RCU_GFS_ADD1_XRX300},
+	{RCU_RD_GPHY2_XRX300, RCU_GFS_ADD2_XRX300},
+};
+
+/* reset / boot a gphy */
+static struct ltq_xrx330_gphy_reset {
+	u32 rd;
+	u32 addr;
+} xrx330_gphy[] = {
+	{RCU_RD_GPHY0_XRX330, RCU_GFS_ADD0_XRX330},
+	{RCU_RD_GPHY1_XRX330, RCU_GFS_ADD1_XRX330},
+	{RCU_RD_GPHY2_XRX330, RCU_GFS_ADD2_XRX330},
+	{RCU_RD_GPHY3_XRX330, RCU_GFS_ADD3_XRX330},
+};
+
+/* reset / boot a gphy */
+static struct ltq_xrx500_gphy_reset {
+	u32 rd;
+	u32 addr;
+} xrx500_gphy[] = {
+	{RCU_RD_GPHY2_XRX500, GPHY2_LBADR_XRX500},
+	{RCU_RD_GPHY3_XRX500, GPHY3_LBADR_XRX500},
+	{RCU_RD_GPHY4_XRX500, GPHY4_LBADR_XRX500},
+	{RCU_RD_GPHY5_XRX500, GPHY5_LBADR_XRX500},
+	{RCU_RD_GPHYF_XRX500, GPHYF_LBADR_XRX500},
+};
+
+void gsw_reg_w32(uint32_t val, uint32_t reg_off)
+{
+	ltq_w32(val, (GSW_L_TOP_BASE + reg_off));
+}
+#define LTQ_DRV_MODULE_NAME	"gsw_xrx_gphy"
+#define LTQ_PHY_DRV_VERSION	"3.0.0"
+static char version[] = LTQ_DRV_MODULE_NAME ": V" LTQ_PHY_DRV_VERSION "";
+
+/* Proc File  */
+static int proc_file_create(void);
+static void proc_file_delete(void);
+static int proc_read_ver(struct seq_file *, void *);
+static int proc_read_phy_fw(struct seq_file *, void *);
+static ssize_t proc_write_phy_fw(struct file *, const char __user *, size_t, loff_t *);
+static int proc_read_ver_open(struct inode *, struct file *);
+static int proc_read_phy_fw_open(struct inode *, struct file *);
+
+static int proc_read_phy_off_open(struct inode *, struct file *);
+static int proc_read_phy_on_open(struct inode *, struct file *);
+static int proc_read_phy_on(struct seq_file *, void *);
+static int proc_read_phy_off(struct seq_file *, void *);
+static ssize_t proc_write_phy_on(struct file *, const char __user *, size_t, loff_t *);
+static ssize_t proc_write_phy_off(struct file *, const char __user *, size_t, loff_t *);
+static void gsw_mdio_data_write(unsigned int phyAddr, unsigned int regAddr, unsigned int data);
+
+
+//For VRX220 SW control PHY LED
+#include <linux/sched.h>
+#include <linux/of_gpio.h>
+struct task_struct *gphy_rmon_poll_thread_id;
+#define LED_OFF	0
+#define LED_ON		1
+#define LED_FLASH	2
+#define GPIO_VRX200_OFFSET  200
+enum gphy_gpio_mapping {
+	GPHY_2_GPIO = 33 + GPIO_VRX200_OFFSET,
+	GPHY_3_GPIO = 11 + GPIO_VRX200_OFFSET,
+	GPHY_4_GPIO = 12 + GPIO_VRX200_OFFSET,
+	GPHY_5_GPIO = 15 + GPIO_VRX200_OFFSET,
+};
+int gphy_led_state[NUM_OF_PORTS] = {0, 0, 0, 0, 0, 0};	/* 0: OFF, 1: ON, 2: flash */
+int gphy_led_status_on[NUM_OF_PORTS] = {0, 0, 0, 0, 0, 0};
+//end For VRX220 SW control PHY LED
+
+static unsigned short gsw_mdio_data_read(unsigned int phyAddr, unsigned int regAddr);
+#if defined(PHY_SSD_ERROR) && PHY_SSD_ERROR
+static unsigned short gsw_mmd_data_read(unsigned int phyAddr, unsigned int regAddr);
+#endif /* PHY_SSD_ERROR  */
+static dma_addr_t xway_gphy_load(unsigned char *pData);
+static int ltq_gphy_firmware_config(void);
+static int ltq_mix_firmware_config(u8 *fw_ptr, int);
+static struct file_operations file_phy_fw_fops = {
+	.owner      = THIS_MODULE,
+	.open       = proc_read_phy_fw_open,
+	.read       = seq_read,
+	.write      = proc_write_phy_fw,
+	.llseek     = seq_lseek,
+	.release    = single_release,
+};
+
+static int proc_read_phy_fw_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_phy_fw, NULL);
+}
+
+unsigned int found_magic = 0, found_img = 0, first_block = 0, fw_len = 0, rcv_size = 0, second_block = 0;
+int fmode = 0, update_ge = 0, update_fe = 0;
+static ssize_t proc_write_phy_fw(struct file *file, const char __user *buf, size_t count, loff_t *data)
+{
+	gphy_image_header_t header;
+	int len = 0;
+	char local_buf[4096] = {0};
+	memset(&header, 0, sizeof(gphy_image_header_t));
+	len = sizeof(local_buf) < count ? sizeof(local_buf) - 1 : count;
+	len = len - copy_from_user((local_buf), buf, len);
+
+	if (!found_img) {
+		memcpy(&header, (local_buf + (found_magic * sizeof(gphy_image_header_t))), sizeof(gphy_image_header_t));
+
+		if (header.immagic == IH_MAGIC_NO) {
+			found_magic++;
+			first_block = 0;
+			second_block = 0;
+			fmode = 0;
+			update_ge = 0;
+			update_fe = 0;
+		}
+	}
+
+	if (!found_img) {
+		if (strcmp(g_gphy_fw_mode, "11G-FW") == 0) {
+			/*			dev_info(gphy_dev, "%s: header:%s, size:%d  \n", __func__,header.imname, header.imsize);*/
+			if (((strncmp(header.imname, "VR9 V1.1 GPHY GE", sizeof(header.imname)) == 0)	\
+			     || (strncmp(header.imname, "AR10 V1.1 GPHY GE", sizeof(header.imname)) == 0))	\
+			    && (dev_id == 0)) {
+				first_block = 1;
+				fw_len = header.imsize;
+				found_img = 1;
+				fmode = 1;
+				dev_info(gphy_dev, "%s:   Found:%s  FW \n", __func__, header.imname);
+			} else if (((strncmp(header.imname, "VR9 V1.2 GPHY GE", sizeof(header.imname)) == 0)	\
+				    || (strncmp(header.imname, "AR10 V1.2 GPHY GE", sizeof(header.imname)) == 0))	\
+				   && (dev_id == 1))	{
+				first_block = 1;
+				fw_len = header.imsize;
+				found_img = 1;
+				fmode = 1;
+				dev_info(gphy_dev, "%s:   Found:%s  FW \n", __func__, header.imname);
+			} else if ((strncmp(header.imname, "GRX500 V1.1 GPHY BE", sizeof(header.imname)) == 0)	\
+				   && (dev_id == 1))	{
+				first_block = 1;
+				fw_len = header.imsize;
+				found_img = 1;
+				fmode = 1;
+				dev_info(gphy_dev, "%s:   Found:%s  FW \n", __func__, header.imname);
+			}
+		} else if (strcmp(g_gphy_fw_mode, "22F-FW") == 0) {
+			if (((strncmp(header.imname, "VR9 V1.1 GPHY FE", sizeof(header.imname)) == 0)	\
+			     || (strncmp(header.imname, "AR10 V1.1 GPHY FE", sizeof(header.imname)) == 0))	\
+			    && (dev_id == 0)) {
+				first_block = 1;
+				fw_len = header.imsize;
+				found_img = 1;
+				fmode = 2;
+				dev_info(gphy_dev, "%s:   Found:%s  FW \n", __func__, header.imname);
+			} else if (((strncmp(header.imname, "VR9 V1.2 GPHY FE", sizeof(header.imname)) == 0)	\
+				    || (strncmp(header.imname, "AR10 V1.2 GPHY FE", sizeof(header.imname)) == 0))	\
+				   && (dev_id == 1)) {
+				first_block = 1;
+				fw_len = header.imsize;
+				found_img = 1;
+				fmode = 2;
+				dev_info(gphy_dev, "%s:  Found:%s  FW \n", __func__, header.imname);
+			}
+		} else if (strcmp(g_gphy_fw_mode, "11G22F-FW") == 0) {
+			dev_info(gphy_dev, "%s: header:%s, size:%d  \n", __func__, header.imname, header.imsize);
+
+			if (((strncmp(header.imname, "VR9 V1.2 GPHY GE", sizeof(header.imname)) == 0)	\
+			     || (strncmp(header.imname, "AR10 V1.2 GPHY GE", sizeof(header.imname)) == 0))	\
+			    && (dev_id == 1))	{
+				first_block = 1;
+				fw_len = header.imsize;
+				found_img = 1;
+				fmode = 1;
+				dev_info(gphy_dev, "%s:   Found:%s  FW \n", __func__, header.imname);
+			}
+
+			if (((strncmp(header.imname, "VR9 V1.2 GPHY FE", sizeof(header.imname)) == 0)	\
+			     || (strncmp(header.imname, "AR10 V1.2 GPHY FE", sizeof(header.imname)) == 0))	\
+			    && (dev_id == 1)) {
+				first_block = 1;
+				fw_len = header.imsize;
+				found_img = 1;
+				fmode = 2;
+				dev_info(gphy_dev, "%s:  Found:%s  FW \n", __func__, header.imname);
+			}
+		}
+	}
+
+	if ((strcmp(g_gphy_fw_mode, "11G-FW") == 0) || (strcmp(g_gphy_fw_mode, "22F-FW") == 0)) {
+		if ((first_block == 1) && (!second_block) && found_img) {
+			g_gphy_fw_dma = (u8 *) kmalloc(fw_len * sizeof(unsigned char), GFP_KERNEL);
+			memset(g_gphy_fw_dma, 0, fw_len);
+			rcv_size = (len - (found_magic * sizeof(gphy_image_header_t)));
+			memcpy(g_gphy_fw_dma, local_buf + (found_magic * sizeof(gphy_image_header_t)), rcv_size);
+			second_block = 1;
+		} else if ((second_block == 1) && found_img) {
+			if (rcv_size < (fw_len)) {
+				if ((rcv_size + len) >= fw_len) {
+					memcpy(g_gphy_fw_dma + rcv_size, local_buf, (fw_len - rcv_size));
+					first_block = 0;
+					found_img = 0;
+					second_block = 0;
+					found_magic = 0;
+					ltq_gphy_firmware_config();
+				} else {
+					memcpy(g_gphy_fw_dma + rcv_size, local_buf, (len));
+					rcv_size += len;
+				}
+			} else {
+				first_block = 0;
+				found_img = 0;
+				second_block = 0;
+				found_magic = 0;
+				ltq_gphy_firmware_config();
+			}
+		}
+	} else if (strcmp(g_gphy_fw_mode, "11G22F-FW") == 0) {
+		if ((first_block == 1) && (!second_block) && found_img) {
+			if (fmode == 1) {
+				g_gphy_fw_dma = (u8 *) kmalloc(fw_len * sizeof(unsigned char), GFP_KERNEL);
+
+				if (g_gphy_fw_dma == NULL)
+					return -1;
+
+				memset(g_gphy_fw_dma, 0, fw_len);
+				rcv_size = (len - (found_magic * sizeof(gphy_image_header_t)));
+				memcpy(g_gphy_fw_dma, local_buf + (found_magic * sizeof(gphy_image_header_t)), rcv_size);
+			}
+
+			if (fmode == 2) {
+				f_gphy_fw_dma = (u8 *) kmalloc(fw_len * sizeof(unsigned char), GFP_KERNEL);
+
+				if (f_gphy_fw_dma == NULL)
+					return -1;
+
+				memset(f_gphy_fw_dma, 0, fw_len);
+				rcv_size = (len - (found_magic * sizeof(gphy_image_header_t)));
+				memcpy(f_gphy_fw_dma, local_buf + (found_magic * sizeof(gphy_image_header_t)), rcv_size);
+			}
+
+			second_block = 1;
+		} else if ((second_block == 1) && found_img) {
+			if (rcv_size < (fw_len)) {
+				if ((rcv_size + len) >= fw_len) {
+					if (fmode == 1) {
+						if ((len <= 4096) && (len > 64)) {
+							update_ge = 1;
+							memcpy(g_gphy_fw_dma + rcv_size, local_buf, (fw_len - rcv_size));
+							rcv_size = (len - (found_magic * sizeof(gphy_image_header_t)));
+							memcpy(&header, (local_buf + (found_magic * sizeof(gphy_image_header_t))), sizeof(gphy_image_header_t));
+						}
+					}
+
+					if (fmode == 2) {
+						if ((len <= 4096) && (len > 64)) {
+							update_fe = 1;
+							memcpy(f_gphy_fw_dma + rcv_size, local_buf, (fw_len - rcv_size));
+							rcv_size = (len - (found_magic * sizeof(gphy_image_header_t)));
+							memcpy(&header, (local_buf + (found_magic * sizeof(gphy_image_header_t))), sizeof(gphy_image_header_t));
+						}
+					}
+
+					if (((strncmp(header.imname, "VR9 V1.2 GPHY GE", sizeof(header.imname)) == 0)	\
+					     || (strncmp(header.imname, "AR10 V1.2 GPHY GE", sizeof(header.imname)) == 0))	\
+					    && (dev_id == 1))	{
+						first_block = 1;
+						fw_len = header.imsize;
+						found_img = 1;
+						fmode = 1;
+						dev_info(gphy_dev, "%s:   Found:%s  FW \n", __func__, header.imname);
+						g_gphy_fw_dma = (u8 *) kmalloc(fw_len * sizeof(unsigned char), GFP_KERNEL);
+
+						if (g_gphy_fw_dma == NULL) {
+							pr_err("ERROR: Line: %d: %s:   Found:%s  FW \n", __LINE__, __func__, header.imname);
+							return -1;
+						}
+
+						memset(g_gphy_fw_dma, 0, fw_len);
+						found_magic++;
+						rcv_size = (len - (found_magic * sizeof(gphy_image_header_t)));
+						memcpy(g_gphy_fw_dma, local_buf + (found_magic * sizeof(gphy_image_header_t)), rcv_size);
+					}
+
+					if (((strncmp(header.imname, "VR9 V1.2 GPHY FE", sizeof(header.imname)) == 0)	\
+					     || (strncmp(header.imname, "AR10 V1.2 GPHY FE", sizeof(header.imname)) == 0))	\
+					    && (dev_id == 1)) {
+						first_block = 1;
+						fw_len = header.imsize;
+						found_img = 1;
+						fmode = 2;
+						found_magic++;
+						dev_info(gphy_dev, "%s:  Found:%s  FW \n", __func__, header.imname);
+						f_gphy_fw_dma = (u8 *) kmalloc(fw_len * sizeof(unsigned char), GFP_KERNEL);
+
+						if (f_gphy_fw_dma == NULL) {
+							pr_err("ERROR: Line: %d: %s:   Found:%s  FW \n", __LINE__, __func__, header.imname);
+							return -1;
+						}
+
+						memset(f_gphy_fw_dma, 0, fw_len);
+						rcv_size = (len - (found_magic * sizeof(gphy_image_header_t)));
+						memcpy(f_gphy_fw_dma, local_buf + (found_magic * sizeof(gphy_image_header_t)), rcv_size);
+					}
+
+					if (update_ge == 1) {
+						if (g_gphy_fw_dma) {
+							ltq_mix_firmware_config(g_gphy_fw_dma, 1);
+							update_ge = 0;
+						}
+					}
+
+					if (update_fe == 1) {
+						if (f_gphy_fw_dma) {
+							ltq_mix_firmware_config(f_gphy_fw_dma, 2);
+							update_fe = 0;
+						}
+					}
+				} else {
+					if (fmode == 1) {
+						memcpy(g_gphy_fw_dma + rcv_size, local_buf, (len));
+					}
+
+					if (fmode == 2) {
+						memcpy(f_gphy_fw_dma + rcv_size, local_buf, (len));
+					}
+
+					rcv_size += len;
+				}
+			} else {
+				first_block = 0;
+				found_img = 0;
+				second_block = 0;
+				found_magic = 0;
+
+				if (update_ge == 1) {
+					if (g_gphy_fw_dma)
+						ltq_mix_firmware_config(g_gphy_fw_dma, 1);
+				}
+
+				if (update_fe == 1) {
+					if (f_gphy_fw_dma)
+						ltq_mix_firmware_config(f_gphy_fw_dma, 2);
+				}
+			}
+		}
+	}
+
+	return len;
+}
+
+static int proc_read_phy_fw(struct seq_file *seq, void *v)
+{
+	return 0;
+}
+/*
+static void space_ignore(char **p, int *len)
+{
+	while ( *len && (**p <= ' ' || **p == ':' || **p == '.' || **p == ',') ) {
+		(*p)++;
+		(*len)--;
+	}
+}
+*/
+static int get_number(char **p, int *len, int is_hex)
+{
+	int ret = 0, n = 0;
+
+	if ((*p)[0] == '0' && (*p)[1] == 'x') {
+		is_hex = 1;
+		(*p) += 2;
+		(*len) -= 2;
+	}
+
+	if (is_hex) {
+		while (*len && ((**p >= '0' && **p <= '9')	\
+				|| (**p >= 'a' && **p <= 'f') || (**p >= 'A' && **p <= 'F'))) {
+			if (**p >= '0' && **p <= '9')
+				n = **p - '0';
+			else if (**p >= 'a' && **p <= 'f')
+				n = **p - 'a' + 10;
+			else if (**p >= 'A' && **p <= 'F')
+				n = **p - 'A' + 10;
+
+			ret = (ret << 4) | n;
+			(*p)++;
+			(*len)--;
+		}
+	} else {
+		while (*len && **p >= '0' && **p <= '9') {
+			n = **p - '0';
+			ret = ret * 10 + n;
+			(*p)++;
+			(*len)--;
+		}
+	}
+
+	return ret;
+}
+
+#if defined(PHY_SSD_ERROR) && PHY_SSD_ERROR
+static int proc_read_phy_ssd_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_phy_on, NULL);
+}
+
+static ssize_t proc_write_phy_ssd(struct file *file, const char __user *buf, size_t count, loff_t *data)
+{
+	int len, rlen, num;
+	char local_buf[512] = {0};
+	char *p;
+	len = sizeof(local_buf) < count ? sizeof(local_buf) - 1 : count;
+	rlen = len - copy_from_user((local_buf), buf, len);
+
+	while (rlen && local_buf[rlen - 1] <= ' ')
+		rlen--;
+
+	local_buf[rlen] = 0;
+
+	for (p = local_buf; *p && *p <= ' '; p++, rlen--);
+
+	if (!*p)
+		return 0;
+
+	num = get_number(&p, &rlen, 0);
+	ssd_interval = (num < 2) ? 1 : num;
+	return len;
+}
+static struct file_operations file_phy_ssd_fops = {
+	.owner      = THIS_MODULE,
+	.open       = proc_read_phy_ssd_open,
+	.read       = seq_read,
+	.write      = proc_write_phy_ssd,
+	.llseek     = seq_lseek,
+	.release    = single_release,
+};
+#endif /* PHY_SSD_ERROR */
+
+static struct file_operations file_phy_on_fops = {
+	.owner      = THIS_MODULE,
+	.open       = proc_read_phy_on_open,
+	.read       = seq_read,
+	.write      = proc_write_phy_on,
+	.llseek     = seq_lseek,
+	.release    = single_release,
+};
+
+static ssize_t proc_write_phy_on(struct file *file, const char __user *buf, size_t count, loff_t *data)
+{
+	int len, rlen, num;
+	char local_buf[512] = {0};
+	char *p;
+	len = sizeof(local_buf) < count ? sizeof(local_buf) - 1 : count;
+	rlen = len - copy_from_user((local_buf), buf, len);
+
+	while (rlen && local_buf[rlen - 1] <= ' ')
+		rlen--;
+
+	local_buf[rlen] = 0;
+
+	for (p = local_buf; *p && *p <= ' '; p++, rlen--);
+
+	if (!*p)
+		return 0;
+
+	num = get_number(&p, &rlen, 0);
+	on_interval = (num < 4) ? 3 : num;
+	return len;
+}
+
+static int proc_read_phy_on_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_phy_on, NULL);
+}
+
+static int proc_read_phy_on(struct seq_file *seq, void *v)
+{
+	return 0;
+}
+
+static struct file_operations file_phy_off_fops = {
+	.owner      = THIS_MODULE,
+	.open       = proc_read_phy_off_open,
+	.read       = seq_read,
+	.write      = proc_write_phy_off,
+	.llseek     = seq_lseek,
+	.release    = single_release,
+};
+
+static ssize_t proc_write_phy_off(struct file *file, const char __user *buf, size_t count, loff_t *data)
+{
+	int len, rlen, num;
+	char local_buf[512] = {0};
+	char *p;
+	len = sizeof(local_buf) < count ? sizeof(local_buf) - 1 : count;
+	rlen = len - copy_from_user((local_buf), buf, len);
+
+	while (rlen && local_buf[rlen - 1] <= ' ')
+		rlen--;
+
+	local_buf[rlen] = 0;
+
+	for (p = local_buf; *p && *p <= ' '; p++, rlen--);
+
+	if (!*p)
+		return 0;
+
+	num = get_number(&p, &rlen, 0);
+	off_interval = (num < 4) ? 5 : num;
+	return len;
+}
+static int proc_read_phy_off_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_phy_off, NULL);
+}
+static int proc_read_phy_off(struct seq_file *seq, void *v)
+{
+	return 0;
+}
+static struct file_operations file_ver_fops = {
+	.owner	= THIS_MODULE,
+	.open	= proc_read_ver_open,
+	.read	= seq_read,
+	.llseek	= seq_lseek,
+	.release	= single_release,
+};
+
+static int proc_read_ver_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_ver, NULL);
+}
+
+static int proc_read_ver(struct seq_file *seq, void *v)
+{
+	seq_printf(seq, "LTQ GPHY driver %s, version %s, on:%d, off:%d, pw_mode:%d, ssd_interval:%d\n",	\
+		   g_gphy_fw_mode, version, on_interval, off_interval, pw_save_mode, ssd_interval);
+	return 0;
+}
+
+static int proc_file_create(void)
+{
+	struct proc_dir_entry *entry;
+
+	g_proc_gphy_dir = proc_mkdir("driver/ltq_gphy", NULL);
+
+	if (!g_proc_gphy_dir)
+		return -ENOMEM;
+
+	entry  = proc_create("version", S_IRUGO, g_proc_gphy_dir, &file_ver_fops);
+
+	if (!entry)
+		goto Err0;
+
+	entry = proc_create("phyfirmware", S_IRUGO | S_IWUSR, g_proc_gphy_dir, &file_phy_fw_fops);
+
+	if (!entry)
+		goto Err2;
+
+	entry = proc_create("on_delay", S_IRUGO | S_IWUSR, g_proc_gphy_dir, &file_phy_on_fops);
+
+	if (!entry)
+		goto Err3;
+
+	entry = proc_create("off_delay", S_IRUGO | S_IWUSR, g_proc_gphy_dir, &file_phy_off_fops);
+
+	if (!entry)
+		goto Err4;
+
+#if defined(PHY_SSD_ERROR) && PHY_SSD_ERROR
+	entry = proc_create("ssd_delay", S_IRUGO | S_IWUSR, g_proc_gphy_dir, &file_phy_ssd_fops);
+
+	if (!entry)
+		goto Err5;
+
+#endif /* PHY_SSD_ERROR */
+	return 0;
+#if defined(PHY_SSD_ERROR) && PHY_SSD_ERROR
+Err5:
+	remove_proc_entry("off_delay", g_proc_gphy_dir);
+#endif /* PHY_SSD_ERROR */
+Err4:
+	remove_proc_entry("on_delay", g_proc_gphy_dir);
+Err3:
+	remove_proc_entry("phyfirmware", g_proc_gphy_dir);
+Err2:
+	remove_proc_entry("version", g_proc_gphy_dir);
+Err0:
+	remove_proc_entry("driver/ltq_gphy", NULL);
+	return -ENOMEM;
+}
+
+static void proc_file_delete(void)
+{
+	if (!g_proc_gphy_dir)
+		return;
+
+	remove_proc_entry("version", g_proc_gphy_dir);
+	remove_proc_entry("phyfirmware", g_proc_gphy_dir);
+	remove_proc_entry("driver/ltq_gphy", NULL);
+}
+
+static dma_addr_t xway_gphy_load(unsigned char *pData)
+{
+	dma_addr_t dev_addr = 0;
+	void *fw_addr;
+	size_t size;
+	/*
+	 * GPHY cores need the firmware code in a persistent and contiguous
+	 * memory area with a 16 kB boundary aligned start address
+	 */
+	size = fw_len + XWAY_GPHY_FW_ALIGN;
+
+	if (g_fw_addr) {
+		dma_free_coherent(gphy_dev, size, g_fw_addr, g_dev_addr);
+		g_fw_addr = NULL;
+	}
+
+	fw_addr = dma_alloc_coherent(gphy_dev, size, &dev_addr, GFP_KERNEL);
+
+	if (fw_addr) {
+		fw_addr = PTR_ALIGN(fw_addr, XWAY_GPHY_FW_ALIGN);
+		dev_addr = ALIGN(dev_addr, XWAY_GPHY_FW_ALIGN);
+		memcpy(fw_addr, pData, fw_len);
+		g_fw_addr = fw_addr;
+		g_dev_addr = dev_addr;
+	} else {
+		dev_err(gphy_dev, "failed to alloc firmware memory\n");
+	}
+
+	return dev_addr;
+}
+
+static dma_addr_t xway_fphy_load(unsigned char *pData)
+{
+	dma_addr_t dev_addr = 0;
+	void *fw_addr;
+	size_t size;
+	/*
+	 * GPHY cores need the firmware code in a persistent and contiguous
+	 * memory area with a 16 kB boundary aligned start address
+	 */
+	size = fw_len + XWAY_GPHY_FW_ALIGN;
+
+	if (f_fw_addr) {
+		dma_free_coherent(gphy_dev, size, f_fw_addr, f_dev_addr);
+		f_fw_addr = NULL;
+	}
+
+	fw_addr = dma_alloc_coherent(gphy_dev, size, &dev_addr, GFP_KERNEL);
+
+	if (fw_addr) {
+		fw_addr = PTR_ALIGN(fw_addr, XWAY_GPHY_FW_ALIGN);
+		dev_addr = ALIGN(dev_addr, XWAY_GPHY_FW_ALIGN);
+		memcpy(fw_addr, pData, fw_len);
+		f_fw_addr = fw_addr;
+		f_dev_addr = dev_addr;
+	} else {
+		dev_err(gphy_dev, "failed to alloc firmware memory\n");
+	}
+
+	return dev_addr;
+}
+
+/* reset and boot a gphy. these phys only exist on xrx200 SoC */
+int xway_gphy_rcu_config(unsigned int id, dma_addr_t dev_addr)
+{
+	if (of_machine_is_compatible("lantiq,vr9") || of_machine_is_compatible("lantiq,xrx220")) {
+		struct clk *clk;
+		clk = clk_get_sys("1f203000.rcu", "gphy");
+
+		if (IS_ERR(clk))
+			return PTR_ERR(clk);
+
+		clk_enable(clk);
+	}
+
+	if (of_machine_is_compatible("lantiq,vr9") || of_machine_is_compatible("lantiq,xrx220")) {
+		if (id > 1) {
+			dev_info(gphy_dev, "%u is an invalid gphy id\n", id);
+			return -EINVAL;
+		}
+
+		ltq_rcu_w32_mask(0, xrx200_gphy[id].rd, RCU_RST_REQ);
+		ltq_rcu_w32(dev_addr, xrx200_gphy[id].addr);
+		ltq_rcu_w32_mask(xrx200_gphy[id].rd, 0,  RCU_RST_REQ);
+		dev_info(gphy_dev, "booting GPHY%u firmware at %X for VR9\n", id, dev_addr);
+	} else if (of_machine_is_compatible("lantiq,ar10")) {
+		if (id > 2) {
+			dev_info(gphy_dev, "%u is an invalid gphy id\n", id);
+			return -EINVAL;
+		}
+
+		ltq_rcu_w32_mask(0, xrx300_gphy[id].rd, RCU_RST_REQ);
+		ltq_rcu_w32(dev_addr, xrx300_gphy[id].addr);
+		ltq_rcu_w32_mask(xrx300_gphy[id].rd, 0,  RCU_RST_REQ);
+		dev_info(gphy_dev, "booting GPHY%u firmware at %X for AR10\n", id, dev_addr);
+	} else if (of_machine_is_compatible("lantiq,grx390")) {
+		if (id > 3) {
+			dev_info(gphy_dev, "%u is an invalid gphy id\n", id);
+			return -EINVAL;
+		}
+
+		ltq_rcu_w32_mask(0, xrx330_gphy[id].rd, RCU_RST_REQ);
+		ltq_rcu_w32(dev_addr, xrx330_gphy[id].addr);
+		ltq_rcu_w32_mask(xrx330_gphy[id].rd, 0,  RCU_RST_REQ);
+		dev_info(gphy_dev, "booting GPHY%u firmware at %X for GRX390\n", id, dev_addr);
+	} else if (of_machine_is_compatible("lantiq,grx500")) {
+		if (id > 4) {
+			dev_info(gphy_dev, "%u is an invalid gphy id\n", id);
+			return -EINVAL;
+		}
+
+		ltq_rcu_w32_mask(0, xrx500_gphy[id].rd, RCU_RST_REQ);
+		gsw_reg_w32((dev_addr & 0xFFFF), xrx500_gphy[id].addr);
+		gsw_reg_w32(((dev_addr >> 16) & 0xFFFF), (xrx500_gphy[id].addr + 4));
+		ltq_rcu_w32_mask(xrx500_gphy[id].rd, 0,  RCU_RST_REQ);
+		dev_info(gphy_dev, "booting GPHY%u firmware at %X for GRX500\n", id, dev_addr);
+	}
+
+	return 0;
+}
+
+static int ltq_gphy_firmware_config()
+{
+	int i;
+	dma_addr_t data_ptr;
+	data_ptr = xway_gphy_load(g_gphy_fw_dma);
+
+	if (g_gphy_fw_dma)
+		kfree(g_gphy_fw_dma);
+
+	if (!data_ptr)
+		return -ENOMEM;
+
+	for (i = 0; i < g_no_phys; i++)
+		xway_gphy_rcu_config(i, data_ptr);
+
+	pr_err("%s: fw_mode:%s, no of phys:%d,data_ptr:%X\n", __func__, g_gphy_fw_mode, g_no_phys, data_ptr);
+	return 0;
+}
+
+static int ltq_mix_firmware_config(u8 *fw_ptr, int mix_mode)
+{
+	int i;
+	dma_addr_t data_ptr = 0;
+
+	if (mix_mode == 1)
+		data_ptr = xway_gphy_load(fw_ptr);
+
+	if (mix_mode == 2)
+		data_ptr = xway_fphy_load(fw_ptr);
+
+	if (fw_ptr)
+		kfree(fw_ptr);
+
+	if (!data_ptr)
+		return -ENOMEM;
+
+	for (i = 0; i < g_no_phys; i++) {
+		if ((mix_mode == 1) && (phy_fw_type[i] == 1))
+			xway_gphy_rcu_config(i, data_ptr);
+
+		if ((mix_mode == 2) && (phy_fw_type[i] == 2))
+			xway_gphy_rcu_config(i, data_ptr);
+	}
+
+	pr_err("%s: fw_mode:%s, no of phys:%d,data_ptr:%X,mix_mode:%d \n", __func__, g_gphy_fw_mode, g_no_phys, data_ptr, mix_mode);
+	return 0;
+}
+
+static void gsw_mdio_data_write(unsigned int phyAddr, unsigned int regAddr, unsigned int data)
+{
+	GSW_MDIO_data_t mdio_data;
+	memset(&mdio_data, 0, sizeof(GSW_MDIO_data_t));
+	mdio_data.nAddressDev = phyAddr;
+	mdio_data.nAddressReg = regAddr;
+	mdio_data.nData = data;
+	ops->gsw_common_ops.MDIO_DataWrite(ops, (unsigned int)&mdio_data);
+	return ;
+}
+
+static unsigned short gsw_mdio_data_read(unsigned int phyAddr, unsigned int regAddr)
+{
+	GSW_MDIO_data_t mdio_data;
+	memset(&mdio_data, 0, sizeof(GSW_MDIO_data_t));
+	mdio_data.nAddressDev = phyAddr;
+	mdio_data.nAddressReg = regAddr;
+	ops->gsw_common_ops.MDIO_DataRead(ops, (unsigned int)&mdio_data);
+	return (mdio_data.nData);
+}
+
+#if defined(PHY_SSD_ERROR) && PHY_SSD_ERROR
+static unsigned short gsw_mmd_data_read(unsigned int phyAddr, unsigned int regAddr)
+{
+	GSW_MMD_data_t mmd_data;
+	memset(&mmd_data, 0, sizeof(GSW_MMD_data_t));
+	mmd_data.nAddressDev = phyAddr;
+	mmd_data.nAddressReg = regAddr;
+	ops->gsw_common_ops.MmdDataRead(ops, (unsigned int)&mmd_data);
+	return (mmd_data.nData);
+}
+#endif /* PHY_SSD_ERROR */
+
+static int gphy_pw_save_thread(void *arg)
+{
+	allow_signal(SIGKILL);
+
+	while (!kthread_should_stop()) {
+		u8 index;
+		GSW_portLinkCfg_t param;
+		memset(&param, 0, sizeof(GSW_portLinkCfg_t));
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		if (signal_pending(current))
+			break;
+
+		/* Get the port Link Status  */
+		for (index = 0; index < NUM_OF_PORTS; index++) {
+			if ((gphy_power_down[index] == 1) && (gphy_link_status[index] == 0)) {
+				u16 reg0_val;
+				reg0_val = gsw_mdio_data_read(index, 0x0);
+				reg0_val &= ~(0x800);
+				gsw_mdio_data_write(index, 0x0, reg0_val);
+			}
+		}
+
+		interruptible_sleep_on_timeout(&gphy_pw_wait, (on_interval * HZ));
+
+		for (index = 0; index < NUM_OF_PORTS; index++) {
+			param.nPortId = index;
+			ops->gsw_common_ops.PortLinkCfgGet(ops, (unsigned int)&param);
+
+			if (param.eLink == 0) {
+				gphy_link_status[index] = 1;
+				power_down_cnt[index] = 0;
+			} else {
+				gphy_link_status[index] = 0;
+				power_down_cnt[index]++;
+
+				if ((power_down_cnt[index] % 6) != 0) {
+					u16 reg0_val;
+					reg0_val = gsw_mdio_data_read(index, 0x0);
+					reg0_val |= (0x800);
+					gsw_mdio_data_write(index, 0x0, reg0_val);
+				}
+
+				gphy_power_down[index] = 1;
+			}
+		}
+
+		/*poll again  once configured time is up */
+		interruptible_sleep_on_timeout(&gphy_pw_wait, (off_interval * HZ));
+	}
+
+	return 0;
+}
+#if defined(PHY_SSD_ERROR) && PHY_SSD_ERROR
+static int gphy_ssd_err_thread(void *arg)
+{
+	allow_signal(SIGKILL);
+
+	while (!kthread_should_stop()) {
+		u8 index;
+		GSW_portLinkCfg_t param;
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		if (signal_pending(current))
+			break;
+
+		/* Get the port Link Status  */
+		for (index = 0; index < NUM_OF_PORTS; index++) {
+			memset(&param, 0, sizeof(GSW_portLinkCfg_t));
+			param.nPortId = index;
+			ops->gsw_common_ops.PortLinkCfgGet(ops, (unsigned int)&param);
+
+			if ((param.eLink == 0) && (gphy_link_status[index] == 0)) {
+				gphy_link_status[index] = 1;
+				ssd_cnt[index] = 0;
+			} else {
+				gphy_link_status[index] = 0;
+				ssd_cnt[index] = 0;
+			}
+		}
+
+		for (index = 0; index < NUM_OF_PORTS; index++) {
+			if ((gphy_link_status[index] == 1)) {
+				u16 reg0_val;
+				ssd_cnt[index]++;
+
+				if ((ssd_cnt[index] % 3) == 0) {
+					ssd_cnt[index] = 0;
+					reg0_val = gsw_mmd_data_read(index, 0x1F07be);
+
+					if ((reg0_val >> 1) & 0x1) {
+						u16 reg1_val;
+						reg1_val = gsw_mdio_data_read(index, 0x0);
+						reg1_val |= (1 << 9);
+						gsw_mdio_data_write(index, 0x0, reg1_val);
+					}
+				}
+			}
+		}
+
+		interruptible_sleep_on_timeout(&gphy_ssd_wait, (ssd_interval * HZ));
+	}
+
+	return 0;
+}
+#endif /* PHY_SSD_ERROR */
+//For VRX220 SW control PHY LED
+/* Switches on the LED */
+/* Input:   port
+ *		:	on_off */
+/* Process: Use the GPIO to ON/OFF the LED
+*/
+void gphy_data_led_on_off(int port, int on_off)
+{
+	u32 gpio_pin = GPHY_2_GPIO;
+
+	switch (port) {
+	case 2:
+		gpio_pin = GPHY_2_GPIO;
+		break;
+
+	case 3:
+		gpio_pin = GPHY_3_GPIO;
+		break;
+
+	case 4:
+		gpio_pin = GPHY_4_GPIO;
+		break;
+
+	case 5:
+		gpio_pin = GPHY_5_GPIO;
+		break;
+	}
+
+	if (on_off) {
+		gpio_set_value(gpio_pin, 1);
+	} else {
+		gpio_set_value(gpio_pin, 0);
+	}
+}
+
+static int gphy_rmon_poll_thread(void *arg)
+{
+	int port;
+	int port_rx[NUM_OF_PORTS];
+	int port_rx_prev[NUM_OF_PORTS] = {0, 0, 0, 0, 0, 0};
+	int port_tx[NUM_OF_PORTS];
+	int port_tx_prev[NUM_OF_PORTS] = {0, 0, 0, 0, 0, 0};
+	GSW_RMON_Port_cnt_t param;
+	GSW_portLinkCfg_t param_link;
+	printk(KERN_INFO "start %p ..\n", current);
+	allow_signal(SIGKILL);
+
+	while (!kthread_should_stop()) {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		if (signal_pending(current))
+			break;
+
+		ops = gsw_get_swcore_ops(0);
+
+		if (!ops) {
+			pr_err("%s: Open SWAPI device FAILED!\n", __func__);
+			return -EIO;
+		}
+
+		for (port = 2; port < NUM_OF_PORTS; port++) {
+			memset(&param, 0, sizeof(GSW_RMON_Port_cnt_t));
+			memset(&param_link, 0, sizeof(GSW_portLinkCfg_t));
+			param.nPortId = port;
+			param_link.nPortId = port;
+			ops->gsw_rmon_ops.RMON_Port_Get(ops, (unsigned int)&param);
+			port_rx[port] = param.nRxGoodPkts;
+			port_tx[port] = param.nTxGoodPkts;
+
+			if ((port_rx[port] != port_rx_prev[port]) || (port_tx[port] != port_tx_prev[port])) {
+				if (gphy_led_status_on[port] == 0) {
+					gphy_led_status_on[port] = 1;
+					gphy_data_led_on_off(port, LED_ON);
+				} else {
+					gphy_led_status_on[port] = 0;
+					gphy_data_led_on_off(port, LED_OFF);
+				}
+
+				port_rx_prev[port] = port_rx[port];
+				port_tx_prev[port] = port_tx[port];
+			} else {
+				ops->gsw_common_ops.PortLinkCfgGet(ops, (unsigned int)&param_link);
+
+				if (param_link.eLink == 0) {
+					gphy_led_status_on[port] = 1;
+					gphy_data_led_on_off(port, LED_ON);
+				} else {
+					gphy_led_status_on[port] = 0;
+					gphy_data_led_on_off(port, LED_OFF);
+				}
+			}
+		}
+
+		msleep(30);
+	}
+
+	return 0;
+}
+
+int AR10_F2_GPHY_LED_init(void)
+{
+	if (!gpio_request(GPHY_2_GPIO, "SW-LED"))
+		gpio_direction_output(GPHY_2_GPIO, 1);  //set gpio direction as  output
+	else
+		printk(KERN_EMERG "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
+
+	if (!gpio_request(GPHY_3_GPIO, "SW-LED"))
+		gpio_direction_output(GPHY_3_GPIO, 1);  //set gpio direction as  output
+	else
+		return 1;
+
+	if (!gpio_request(GPHY_4_GPIO, "SW-LED"))
+		gpio_direction_output(GPHY_4_GPIO, 1);  //set gpio direction as  output
+	else
+		return 1;
+
+	if (!gpio_request(GPHY_5_GPIO, "SW-LED"))
+		gpio_direction_output(GPHY_5_GPIO, 1);  //set gpio direction as  output
+	else
+		return 1;
+
+	gphy_rmon_poll_thread_id = kthread_create(gphy_rmon_poll_thread, NULL, \
+				   "gphy_rmon_poll_thread");
+
+	if (!IS_ERR(gphy_rmon_poll_thread_id)) {
+		printk(KERN_EMERG "GPHY RMON poll thread created..\n");
+		wake_up_process(gphy_rmon_poll_thread_id);
+	}
+
+	return 0;
+}
+//end For VRX220 SW control PHY LED
+
+static int __init gphy_driver_init(struct platform_device *pdev)
+{
+	const __be32 *no_phys;
+	gphy_dev = &pdev->dev;
+	gphy_node = pdev->dev.of_node;
+
+	off_interval = 5;
+	on_interval = 3;
+	pw_save_mode = 0;
+	ssd_err_mode = 0;
+#if defined(PHY_SSD_ERROR) && PHY_SSD_ERROR
+	ssd_err_mode = 1;
+	ssd_interval = 4;
+#endif /* PHY_SSD_ERROR */
+	dev_id = 0;
+
+	if (of_property_read_string(pdev->dev.of_node, "fw-mode", &g_gphy_fw_mode)) {
+		pr_err("%s:%s:%d (failed to read  firmware mode)\n", __FILE__, __func__, __LINE__);
+		/*		dev_err(&pdev->dev, "failed to read  firmware mode\n");*/
+		return 0;
+	}
+
+	no_phys = of_get_property(gphy_node, "no_of_phys", NULL);
+
+	if (!no_phys) {
+		pr_err("%s:%s:%d (failed to get maximum number of internal gphys ports)\n", __FILE__, __func__, __LINE__);
+		/*		dev_err(&pdev->dev, "failed to get maximum number of internal gphys ports\n");*/
+		return 0;
+	}
+
+	g_no_phys = (*no_phys);
+
+	if (of_machine_is_compatible("lantiq,vr9") || of_machine_is_compatible("lantiq,xrx220")) {
+//		int type = ltq_get_soc_type();
+//		if (type == SOC_TYPE_VR9) /*SOC_TYPE_VR9_2*/
+//			dev_id = 0;
+//		else
+		dev_id = 1;
+	} else if (of_machine_is_compatible("lantiq,ar10")) {
+		dev_id = 1;
+		no_phys = of_get_property(gphy_node, "pw_save_mode", NULL);
+
+		if (no_phys)
+			pw_save_mode = (*no_phys);
+	} else if (of_machine_is_compatible("lantiq,grx390")) {
+		dev_id = 1;
+		no_phys = of_get_property(gphy_node, "pw_save_mode", NULL);
+
+		if (no_phys)
+			pw_save_mode = (*no_phys);
+	} else if (of_machine_is_compatible("lantiq,grx500")) {
+		dev_id = 1;
+	}
+
+	if (of_machine_is_compatible("lantiq,xrx220")) {
+		int i;
+		of_property_read_u32_array(gphy_node, "phy_port_nos", phy_port_nos, g_no_phys);
+		of_property_read_u32_array(gphy_node, "phy_fw_type", phy_fw_type, g_no_phys);
+
+		for (i = 0; i < g_no_phys; i++) {
+			pr_err("phy_port_nos[%d]:%d, phy_fw_type[%d]:%d\n", i, phy_port_nos[i], i, phy_fw_type[i]);
+		}
+	}
+
+	proc_file_create();
+	pr_err("%s: fw_mode:%s, no of phys:%d, mode:%d\n", \
+	       __func__, g_gphy_fw_mode, g_no_phys, pw_save_mode);
+
+	if (of_machine_is_compatible("lantiq,grx390")) {
+		if ((pw_save_mode == 1) || (ssd_err_mode == 1)) {
+			ops = gsw_get_swcore_ops(0);
+
+			if (!ops) {
+				pr_err("%s: Open SWAPI device FAILED!\n", __func__);
+				return -EIO;
+			}
+
+			if (pw_save_mode == 1) {
+				init_waitqueue_head(&gphy_pw_wait);
+				gphy_pw_id = kthread_create(gphy_pw_save_thread, NULL, "gphy_pw_save");
+
+				if (!IS_ERR(gphy_pw_id))
+					wake_up_process(gphy_pw_id);
+			}
+
+#if defined(PHY_SSD_ERROR) && PHY_SSD_ERROR
+
+			if (ssd_err_mode == 1) {
+				init_waitqueue_head(&gphy_ssd_wait);
+				gphy_ssd_id = kthread_create(gphy_ssd_err_thread, NULL, "gphy_ssd_wait");
+
+				if (!IS_ERR(gphy_ssd_id))
+					wake_up_process(gphy_ssd_id);
+			}
+
+#endif /* PHY_SSD_ERROR */
+		}
+	}
+
+	//For VRX220 SW control PHY LED
+	if (of_machine_is_compatible("lantiq,xrx220"))
+		AR10_F2_GPHY_LED_init();
+
+	return 0;
+}
+
+static int __init gphy_driver_exit(struct platform_device *pdev)
+{
+	proc_file_delete();
+
+	if (pw_save_mode == 1)
+		ops = NULL;
+
+	return 0;
+}
+
+static int xway_gphy_fw_probe(struct platform_device *pdev)
+{
+	gphy_driver_init(pdev);
+	return 0;
+}
+
+static int xway_gphy_fw_remove(struct platform_device *pdev)
+{
+	gphy_driver_exit(pdev);
+	return 0;
+}
+
+static const struct of_device_id xway_gphy_fw_match[] = {
+	{ .compatible = "lantiq,xway-phy-fw" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, xway_gphy_fw_match);
+
+static struct platform_driver xway_gphy_driver = {
+	.probe = xway_gphy_fw_probe,
+	.remove = xway_gphy_fw_remove,
+	.driver = {
+		.name = "gphy-fw",
+		.owner = THIS_MODULE,
+		.of_match_table = xway_gphy_fw_match,
+	},
+};
+
+module_platform_driver(xway_gphy_driver);
+
+MODULE_AUTHOR("Reddy Mallikarjuna <reddy.mallikarjun@lantiq.com>");
+MODULE_DESCRIPTION("Lantiq GPHY PHY Firmware Loader");
+MODULE_LICENSE("GPL");
+
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_init.c b/drivers/net/ethernet/lantiq/switch-api/gsw_init.c
new file mode 100644
index 000000000000..c22ac4bcb440
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_init.c
@@ -0,0 +1,1258 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+#ifdef __KERNEL__
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h> /* printk() */
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/export.h>
+#include <linux/clk.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/version.h>
+
+#ifndef CONFIG_X86_INTEL_CE2700
+
+#include <lantiq.h>
+#include <lantiq_soc.h>
+#else
+#include <linux/netip_subsystem.h>
+#include <linux/avalanche/generic/modphy_mrpc_api.h>
+extern int DWC_ETH_QOS_mdio_read_direct(int bus_number, bool c45, int phyaddr, int mmd, int phyreg, int *phydata);
+extern int DWC_ETH_QOS_mdio_write_direct(int bus_number, bool c45, int phyaddr, int mmd, int phyreg, int phydata);
+
+#define MDIO_ADDR_LANTIQ 31
+#define C45_ENABLED 0
+#define MMD_DISABLED 32
+#define MDIO_BUS_NUMBER_0 0
+
+/* netip-subsystem gpio value set register*/
+#define DATA_OUT_SET_REG_OFFSET 0x14
+/* netip-subsystem gpio value clear register*/
+#define DATA_OUT_CLEAR_REG_OFFSET 0x18
+/* netip-subsystem gpio directio set register*/
+#define OE_SET_REG_OFFSET 0x20
+
+#define NETSS_GPIO_17 (1 << 17)
+#define NETSS_GPIO_19 (1 << 19)
+
+#endif /*CONFIG_X86_INTEL_CE2700*/
+
+
+#define sw_w32(x, y)	ltq_w32((x), (addr_gswl + (y)))
+#define sw_r32(x)			ltq_r32(addr_gswl + (x))
+
+#define gsw1_w32(x, y)	ltq_w32((x), ((y)))
+#define gsw1_r32(x)			ltq_r32((x))
+
+
+void __iomem		*addr_gswl;
+void __iomem		*addr_gswr;
+void __iomem		*addr_gsw;
+
+#endif /* KERNEL_MODE */
+
+#if defined(WIN_PC_MODE) && WIN_PC_MODE
+void 		*addr_gswl;
+void 		*addr_gswr;
+void 		*addr_gsw;
+#endif
+
+#include <gsw_init.h>
+
+#if defined(UART_INTERFACE) && UART_INTERFACE
+static int uart_reg_rd(u32 regaddr, u32 *data);
+static int uart_reg_wr(u32 regaddr, u32 data);
+#endif /* UART_INTERFACE */
+
+#define GSW_API_MAJOR_NUMBER	81
+#define LTQ_INT_GSWITCH			0
+#define LTQ_EXT_GSWITCH			1
+
+static const u16 gsw_ops_type[] = {
+	GSW_RMON_MAGIC,
+	GSW_MAC_MAGIC,
+	GSW_EXVLAN_MAGIC,
+	GSW_VLANFILTER_MAGIC,
+	GSW_CTP_MAGIC,
+	GSW_BRDGPORT_MAGIC,
+	GSW_BRDG_MAGIC,
+	GSW_TFLOW_MAGIC,
+	GSW_QOS_MAGIC,
+	GSW_STP_MAGIC,
+	GSW_EAPOL_MAGIC,
+	GSW_MULTICAST_MAGIC,
+	GSW_TRUNKING_MAGIC,
+	GSW_WOL_MAGIC,
+	GSW_VLAN_MAGIC,
+	GSW_PMAC_MAGIC,
+	GSW_COMMON_MAGIC,
+	GSW_ROUTE_MAGIC,
+	GSW_DEBUG_MAGIC,
+	GSW_IRQ_MAGIC
+};
+
+
+extern ltq_lowlevel_fkts_t ltq_flow_fkt_tbl;
+#ifdef __KERNEL__
+extern ltq_lowlevel_fkts_t ltq_rt_fkt_tbl;
+#endif
+
+ioctl_wrapper_init_t ioctlinit;
+ioctl_wrapper_ctx_t *pioctlctl = NULL;
+ethsw_api_dev_t *pEDev0 = NULL, *pEDev1 = NULL;
+struct ltq_lowlevel_fkts_t	 *ioct_cmd_start_node = NULL;
+
+#if defined(WIN_PC_MODE) && WIN_PC_MODE
+struct core_ops *gsw_get_swcore_ops(u32 devid)
+{
+	if (devid == 0)
+		return (&pEDev0->ops);
+
+	if (devid == 1)
+		return (&pEDev1->ops);
+}
+
+#endif
+
+static void insert_ioctl_type(ltq_lowlevel_fkts_t ops_content, struct fkts_linklist *node)
+{
+	ltq_lowlevel_fkts_t	*current_ptr;
+
+#ifdef __KERNEL__
+	current_ptr = (ltq_lowlevel_fkts_t *)kmalloc(sizeof(ltq_lowlevel_fkts_t), GFP_KERNEL);
+#else
+	current_ptr = (ltq_lowlevel_fkts_t *)malloc(sizeof(ltq_lowlevel_fkts_t));
+#endif
+
+	if (current_ptr == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return;
+	}
+
+	//printk("ltq_lowlevel_fkts_t ptr =%x\n",(unsigned int)current_ptr);
+	current_ptr->pNext = NULL;
+	current_ptr->nType = ops_content.nType;
+	current_ptr->nNumFkts = (ops_content.nNumFkts + 1);
+	current_ptr->pFkts = ops_content.pFkts;
+
+	if (node->first_ptr != NULL) {
+		node->last_ptr->pNext = current_ptr;
+		node->last_ptr = current_ptr;
+	} else {
+		node->first_ptr = node->last_ptr = current_ptr;
+	}
+}
+
+static void gsw_delete_ioctl_cmd_linklist(ltq_lowlevel_fkts_t *first_node)
+{
+	ltq_lowlevel_fkts_t *free_node, *last_node;
+	last_node = first_node;
+
+	while (last_node != NULL) {
+		free_node = last_node;
+		last_node = last_node->pNext;
+#ifdef __KERNEL__
+		kfree(free_node);
+#else
+		free(free_node);
+#endif
+	}
+}
+
+static ltq_lowlevel_fkts_t *gsw_create_ioctl_cmd_linklist(struct core_ops *ops)
+{
+	struct fkts_linklist *node;
+	ltq_lowlevel_fkts_t *first_node;
+	ltq_lowlevel_fkts_t ops_content;
+	u16 i, num_of_types = 0;
+#ifdef __KERNEL__
+	node = (struct fkts_linklist *)kmalloc(sizeof(struct fkts_linklist), GFP_KERNEL);
+#else
+	node = (struct fkts_linklist *)malloc(sizeof(struct fkts_linklist));
+#endif
+
+	if (node == NULL)
+		return (ltq_lowlevel_fkts_t *)node;
+
+	node->first_ptr = NULL;
+	node->last_ptr = NULL;
+
+	num_of_types = (sizeof(gsw_ops_type) / sizeof(gsw_ops_type[0]));
+
+	for (i = 0; i < num_of_types; i++) {
+		switch (gsw_ops_type[i]) {
+		case GSW_RMON_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of rmon =%x\n",(unsigned int)&ops->gsw_rmon_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_rmon_ops;
+			ops_content.nType = GSW_RMON_MAGIC;
+			//printk("size of pdata_t.ops.gsw_rmon_ops = %x\n",(sizeof(ops->gsw_rmon_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_rmon_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_MAC_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of mac =%x\n",(unsigned int)&ops->gsw_swmac_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_swmac_ops;
+			ops_content.nType = GSW_MAC_MAGIC;
+			//printk("size of pdata_t.ops.gsw_mac_ops = %x\n",(sizeof(ops->gsw_swmac_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_swmac_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_EXVLAN_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_extvlan_ops =%x\n",(unsigned int)&ops->gsw_extvlan_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_extvlan_ops;
+			ops_content.nType = GSW_EXVLAN_MAGIC;
+			//printk("size of pdata_t.ops.gsw_extvlan_ops = %x\n",(sizeof(ops->gsw_extvlan_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_extvlan_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_VLANFILTER_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_vlanfilter_ops =%x\n",(unsigned int)&ops->gsw_vlanfilter_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_vlanfilter_ops;
+			ops_content.nType = GSW_VLANFILTER_MAGIC;
+			//printk("size of pdata_t.ops.gsw_vlanfilter_ops = %x\n",(sizeof(ops->gsw_vlanfilter_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_vlanfilter_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_CTP_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_ctp_ops =%x\n",(unsigned int)&ops->gsw_ctp_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_ctp_ops;
+			ops_content.nType = GSW_CTP_MAGIC;
+			//printk("size of pdata_t.ops.gsw_ctp_ops = %x\n",(sizeof(ops->gsw_ctp_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_ctp_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_BRDGPORT_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_brdgport_ops =%x\n",(unsigned int)&ops->gsw_brdgport_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_brdgport_ops;
+			ops_content.nType = GSW_BRDGPORT_MAGIC;
+			//printk("size of pdata_t.ops.gsw_brdgport_ops = %x\n",(sizeof(ops->gsw_brdgport_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_brdgport_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_BRDG_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_brdg_ops =%x\n",(unsigned int)&ops->gsw_brdg_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_brdg_ops;
+			ops_content.nType = GSW_BRDG_MAGIC;
+			//printk("size of pdata_t.ops.gsw_brdg_ops = %x\n",(sizeof(ops->gsw_brdg_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_brdg_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_TFLOW_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_tflow_ops =%x\n",(unsigned int)&ops->gsw_tflow_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_tflow_ops;
+			ops_content.nType = GSW_TFLOW_MAGIC;
+			//printk("size of pdata_t.ops.gsw_tflow_ops = %x\n",(sizeof(ops->gsw_tflow_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_tflow_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_QOS_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_qos_ops =%x\n",(unsigned int)&ops->gsw_qos_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_qos_ops;
+			ops_content.nType = GSW_QOS_MAGIC;
+			//printk("size of pdata_t.ops.gsw_qos_ops = %x\n",(sizeof(ops->gsw_qos_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_qos_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_STP_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_stp_ops =%x\n",(unsigned int)&ops->gsw_stp_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_stp_ops;
+			ops_content.nType = GSW_STP_MAGIC;
+			//printk("size of pdata_t.ops.gsw_stp_ops = %x\n",(sizeof(ops->gsw_stp_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_stp_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_EAPOL_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_8021x_ops =%x\n",(unsigned int)&ops->gsw_8021x_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_8021x_ops;
+			ops_content.nType = GSW_EAPOL_MAGIC;
+			//printk("size of pdata_t.ops.gsw_8021x_ops = %x\n",(sizeof(ops->gsw_8021x_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_8021x_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_MULTICAST_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_multicast_ops =%x\n",(unsigned int)&ops->gsw_multicast_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_multicast_ops;
+			ops_content.nType = GSW_MULTICAST_MAGIC;
+			//printk("size of pdata_t.ops.gsw_multicast_ops = %x\n",(sizeof(ops->gsw_multicast_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_multicast_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_TRUNKING_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_trunking_ops =%x\n",(unsigned int)&ops->gsw_trunking_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_trunking_ops;
+			ops_content.nType = GSW_TRUNKING_MAGIC;
+			//printk("size of pdata_t.ops.gsw_trunking_ops = %x\n",(sizeof(ops->gsw_trunking_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_trunking_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_WOL_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_wol_ops =%x\n",(unsigned int)&ops->gsw_wol_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_wol_ops;
+			ops_content.nType = GSW_WOL_MAGIC;
+			//printk("size of pdata_t.ops.gsw_wol_ops = %x\n",(sizeof(ops->gsw_wol_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_wol_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_VLAN_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_vlan_ops =%x\n",(unsigned int)&ops->gsw_vlan_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_vlan_ops;
+			ops_content.nType = GSW_VLAN_MAGIC;
+			//printk("size of pdata_t.ops.gsw_vlan_ops = %x\n",(sizeof(ops->gsw_vlan_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_vlan_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_PMAC_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_pmac_ops =%x\n",(unsigned int)&ops->gsw_pmac_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_pmac_ops;
+			ops_content.nType = GSW_PMAC_MAGIC;
+			//printk("size of pdata_t.ops.gsw_pmac_ops = %x\n",(sizeof(ops->gsw_pmac_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_pmac_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_ROUTE_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_pae_ops =%x\n",(unsigned int)&ops->gsw_pae_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_pae_ops;
+			ops_content.nType = GSW_ROUTE_MAGIC;
+			//printk("size of pdata_t.ops.gsw_pae_ops = %x\n",(sizeof(ops->gsw_pae_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_pae_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_COMMON_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_common_ops =%x\n",(unsigned int)&ops->gsw_common_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_common_ops;
+			ops_content.nType = GSW_COMMON_MAGIC;
+			//printk("size of pdata_t.ops.gsw_common_ops = %x\n",(sizeof(ops->gsw_common_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_common_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_DEBUG_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_debug_ops =%x....\n",(unsigned int)&ops->gsw_debug_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_debug_ops;
+			ops_content.nType = GSW_DEBUG_MAGIC;
+			//printk("size of pdata_t.ops.gsw_debug_ops = %x\n",(sizeof(ops->gsw_debug_ops)/sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_debug_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+		case GSW_IRQ_MAGIC:
+			ops_content.pNext = NULL;
+			//printk("address of gsw_debug_ops =%x....\n",(unsigned int)&ops->gsw_debug_ops);
+			ops_content.pFkts = (LTQ_ll_fkt *)&ops->gsw_irq_ops;
+			ops_content.nType = GSW_IRQ_MAGIC;
+			//printk("size of pdata_t.ops.gsw_irq_ops = %x\n", (sizeof(ops->gsw_irq_ops) / sizeof(ops_content.pFkts[0])));
+			ops_content.nNumFkts = (sizeof(ops->gsw_irq_ops) / sizeof(ops_content.pFkts[0]));
+			insert_ioctl_type(ops_content, node);
+			break;
+
+
+		default:
+			break;
+		}
+	}
+
+	first_node = node->first_ptr;
+#ifdef __KERNEL__
+	kfree(node);
+#else
+	free(node);
+#endif
+	return first_node;
+}
+
+#ifdef __KERNEL__
+void gsw_r32_raw(void *cdev, short offset, u32 *value)
+{
+	ethsw_api_dev_t *pethdev = GSW_PDATA_GET(cdev);
+
+	if (pethdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return;
+	}
+
+	*value = gsw1_r32((volatile void *)pethdev->gsw_base + (offset * 4));
+}
+
+void gsw_w32_raw(void *cdev, short offset, u32 value)
+{
+	ethsw_api_dev_t *pethdev = GSW_PDATA_GET(cdev);
+
+	if (pethdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return;
+	}
+
+	gsw1_w32(value, (volatile void *)(pethdev->gsw_base + (offset * 4)));
+}
+
+#endif
+
+#ifdef CONFIG_X86_INTEL_CE2700
+
+int GSW_SMDIO_DataRead(void *cdev, GSW_MDIO_data_t *pPar)
+{
+	u32 data;
+	int ret;
+
+	ret = DWC_ETH_QOS_mdio_read_direct(MDIO_BUS_NUMBER_0, C45_ENABLED,
+					   MDIO_ADDR_LANTIQ, MMD_DISABLED, pPar->nAddressReg & 0x1F, &data);
+	pPar->nData = data & 0xFFFF;
+	return ret;
+}
+
+int GSW_SMDIO_DataWrite(void *cdev, GSW_MDIO_data_t *pPar)
+{
+	return DWC_ETH_QOS_mdio_write_direct(MDIO_BUS_NUMBER_0, C45_ENABLED,
+					     MDIO_ADDR_LANTIQ, MMD_DISABLED, pPar->nAddressReg & 0x1F, pPar->nData & 0xFFFF);
+}
+
+/** read the gswitch register */
+void gsw_r32(void *cdev, short offset, short shift, short size, u32 *value)
+{
+	u32 rvalue, mask;
+	ethsw_api_dev_t *pethdev = GSW_PDATA_GET(cdev);
+
+	GSW_MDIO_data_t mdio_data;
+	mdio_data.nAddressDev = 0x1F;
+	mdio_data.nAddressReg = 0x1F;
+
+	if ((offset & 0xD000) == 0xD000)
+		mdio_data.nData = (offset);
+	else
+		mdio_data.nData = (offset | 0xE000);
+
+	GSW_SMDIO_DataWrite(cdev, &mdio_data);
+	mdio_data.nAddressDev = 0x1F;
+	mdio_data.nAddressReg = 0x00;
+	mdio_data.nData = 0;
+	GSW_SMDIO_DataRead(cdev, &mdio_data);
+	rvalue = mdio_data.nData;
+
+	mask = (1 << size) - 1;
+	rvalue = (rvalue >> shift);
+	*value = (rvalue & mask);
+}
+
+/** read and update the GSWIP register */
+void gsw_w32(void *cdev, short offset, short shift, short size, u32 value)
+{
+	u32 rvalue, mask;
+	ethsw_api_dev_t *pethdev = GSW_PDATA_GET(cdev);
+
+	if (pethdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return;
+	}
+
+	GSW_MDIO_data_t mdio_data;
+	mdio_data.nAddressDev = 0x1F;
+	mdio_data.nAddressReg = 0x1F;
+
+	if ((offset & 0xD000) == 0xD000)
+		mdio_data.nData = (offset);
+	else
+		mdio_data.nData = (offset | 0xE000);
+
+	GSW_SMDIO_DataWrite(cdev, &mdio_data);
+
+	if (size != 16) {
+		mdio_data.nAddressDev = 0x1F;
+		mdio_data.nAddressReg = 0x00;
+		mdio_data.nData = 0;
+		GSW_SMDIO_DataRead(cdev, &mdio_data);
+		rvalue = mdio_data.nData;
+
+		/* Prepare the mask	*/
+		mask = (1 << size) - 1 ;
+		mask = (mask << shift);
+		/* Shift the value to the right place and mask the rest of the bit*/
+		value = (value << shift) & mask;
+		/*  Mask out the bit field from the read register and place in the new value */
+		value = (rvalue & ~mask) | value ;
+
+		mdio_data.nAddressDev = 0x1F;
+		mdio_data.nAddressReg = 0x1F;
+
+		if ((offset & 0xD000) == 0xD000)
+			mdio_data.nData = (offset);
+		else
+			mdio_data.nData = (offset | 0xE000);
+
+		GSW_SMDIO_DataWrite(cdev, &mdio_data);
+	}
+
+	mdio_data.nAddressDev = 0x1F;
+	mdio_data.nAddressReg = 0x0;
+	mdio_data.nData = value;
+	GSW_SMDIO_DataWrite(cdev, &mdio_data);
+}
+
+#else /* If not CONFIG_X86_INTEL_CE2700*/
+
+#if defined(UART_INTERFACE) && UART_INTERFACE
+/* UART inetrface suppot function */
+static int uart_reg_rd(u32 regaddr, u32 *data)
+{
+	/* Add customer UART routines*/
+	/* pseudo function */
+	pc_uart_dataread(regaddr, data);
+	return 1;
+}
+static int uart_reg_wr(u32 regaddr, u32 data)
+{
+	/* Add customer UART routines*/
+	/* pseudo function */
+	pc_uart_datawrite(regaddr, data);
+	return 1;
+}
+#endif /* UART_INTERFACE */
+
+/** read the gswitch register */
+void gsw_r32(void *cdev, short offset, short shift, short size, u32 *value)
+{
+	u32 rvalue, mask;
+	ethsw_api_dev_t *pethdev = GSW_PDATA_GET(cdev);
+
+	if (pethdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return;
+	}
+
+	if (pethdev->gsw_base != 0) {
+#if defined(UART_INTERFACE) && UART_INTERFACE
+		u32 ro;
+		ro = (uintptr_t)(pethdev->gsw_base + (offset * 4));
+		uart_reg_rd(ro, &rvalue);
+#else
+		rvalue = gsw1_r32((volatile void *)(pethdev->gsw_base + (offset * 4)));
+#endif /* UART_INTERFACE */
+		mask = (1 << size) - 1;
+		rvalue = (rvalue >> shift);
+		*value = (rvalue & mask);
+	} else {
+		pr_err("%s:%s:%d,(ERROR)\n", __FILE__, __func__, __LINE__);
+	}
+}
+
+/** read and update the GSWIP register */
+void gsw_w32(void *cdev, short offset, short shift, short size, u32 value)
+{
+	u32 rvalue, mask;
+	ethsw_api_dev_t *pethdev = GSW_PDATA_GET(cdev);
+
+	if (pethdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return;
+	}
+
+
+	if (pethdev->gsw_base != 0) {
+
+#if defined(UART_INTERFACE) && UART_INTERFACE
+		u32 ro;
+		ro = (uintptr_t)(pethdev->gsw_base + (offset * 4));
+		uart_reg_rd(ro, &rvalue);
+#else
+		rvalue = gsw1_r32((volatile void *)(pethdev->gsw_base + (offset * 4)));
+#endif /* UART_INTERFACE */
+		mask = (1 << size) - 1;
+		mask = (mask << shift);
+		value = ((value << shift) & mask);
+		value = ((rvalue & ~mask) | value);
+#if defined(UART_INTERFACE) && UART_INTERFACE
+		uart_reg_wr(ro, value);
+#else
+		gsw1_w32(value, ((volatile void *)pethdev->gsw_base + (offset * 4)));
+#endif /* UART_INTERFACE */
+	} else {
+		pr_err("%s:%s:%d,(ERROR)\n", __FILE__, __func__, __LINE__);
+	}
+}
+
+#endif
+
+#ifdef CONFIG_X86_INTEL_CE2700
+void inline gsw_p7_netss_write(void *base, unsigned int off, unsigned int val)
+{
+	*((volatile unsigned long *)(base + off)) = cpu_to_be32(val);
+}
+
+void gsw_p7_netss_unmap(void *base)
+{
+	iounmap(base);
+}
+
+void *gsw_p7_netss_map(netss_dev_t netss_subdevice)
+{
+	int ret;
+	netss_dev_info_t pbase;
+	volatile void *vbase = NULL;
+
+	if (!netss_driver_ready()) {
+		pr_err("%s:%s:%d (Netss Driver Not Ready)\n",
+		       __FILE__, __func__, __LINE__);
+		return NULL;
+	}
+
+	if (netss_device_get_info(netss_subdevice, &pbase)) {
+		pr_err("%s:%s:%d (Netss Get Info Failed)\n",
+		       __FILE__, __func__, __LINE__);
+		return NULL;
+	}
+
+	vbase = ioremap_nocache(pbase.base, pbase.size);
+
+	if (!vbase) {
+		pr_err("%s:%s:%d (Virt_base Is Null)\n",
+		       __FILE__, __func__, __LINE__);
+		return NULL;
+	}
+
+	return vbase;
+}
+
+int gsw_p7_reset_modphy_lane(void)
+{
+
+#ifndef EXT_SWITCH_SGMII0
+	ModphyController_e client = MODPHY_SGMII1_2_5G_CLIENT_ID;
+#else
+	ModphyController_e client = MODPHY_SGMII0_2_5G_CLIENT_ID;
+#endif
+	modphy_reset_client(client);
+
+	return 0;
+}
+
+int gsw_p7_power_on(void)
+{
+	void *netss_gpio_base = NULL;
+
+	netss_gpio_base = gsw_p7_netss_map(NETSS_DEV_GPIO);
+
+	if (!netss_gpio_base) {
+		pr_err("%s:%s:%d (Gpio Base Map Failed)\n",
+		       __FILE__, __func__, __LINE__);
+		return -1;
+	}
+
+	/* set power gpio to output and value 1*/
+	gsw_p7_netss_write(netss_gpio_base, OE_SET_REG_OFFSET, NETSS_GPIO_17);
+	gsw_p7_netss_write(netss_gpio_base, DATA_OUT_SET_REG_OFFSET,
+			   NETSS_GPIO_17);
+	mdelay(200);
+	/* set reset gpio to output*/
+	gsw_p7_netss_write(netss_gpio_base, OE_SET_REG_OFFSET, NETSS_GPIO_19);
+
+	/* set reset gpio value to 0*/
+	gsw_p7_netss_write(netss_gpio_base, DATA_OUT_CLEAR_REG_OFFSET,
+			   NETSS_GPIO_19);
+	mdelay(200);
+	/* set reset gpio value to 1*/
+	gsw_p7_netss_write(netss_gpio_base, DATA_OUT_SET_REG_OFFSET,
+			   NETSS_GPIO_19);
+	mdelay(1000);
+
+	gsw_p7_netss_unmap(netss_gpio_base);
+
+	return 0;
+}
+
+int ltq_ethsw_api_register_p7(struct platform_device *pdev)
+{
+	int result;
+	ethsw_core_init_t core_init;
+	ethsw_api_dev_t *pethdev;
+	ioctl_wrapper_ctx_t *iowrap;
+	ioctl_wrapper_init_t iowrapinit;
+
+	/* Switch memory not mapped*/
+	addr_gsw = 0;
+
+	/* Enable Switch Power  */
+	if (gsw_p7_power_on()) {
+		pr_err("%s:%s:%d (Switch Power On Failed)\n",
+		       __FILE__, __func__, __LINE__);
+		return -1;
+	}
+
+	/* Init FLOW Switch Core Layer */
+	core_init.sdev = LTQ_FLOW_DEV_INT;
+	core_init.gsw_base_addr = addr_gsw;
+	/*	core_init.pDev = pRALDev; */
+	pethdev = ethsw_api_core_init(&core_init);
+
+	if (pethdev == NULL) {
+		pr_err("%s:%s:%d (Init Failed)\n",
+		       __FILE__, __func__, __LINE__);
+		return -1;
+	}
+
+	pethdev->cport = GSW_2X_SOC_CPU_PORT;
+	pethdev->gsw_base = addr_gsw;
+	iowrapinit.pLlTable = &ltq_flow_fkt_tbl;
+	iowrapinit.default_handler = NULL;
+	iowrap = ioctl_wrapper_init(&iowrapinit);
+
+	if (iowrap == NULL) {
+		pr_err("%s:%s:%d (WrapperInit Failed)\n",
+		       __FILE__, __func__, __LINE__);
+		return -1;
+	}
+
+	/* add Internal switch */
+	ioctl_wrapper_dev_add(iowrap, pethdev, LTQ_INT_GSWITCH);
+
+	if (gsw_p7_reset_modphy_lane()) {
+		pr_err("%s:%s:%d (Reset Modphy Lane Failed)\n",
+		       __FILE__, __func__, __LINE__);
+		return -1;
+	}
+
+	/* Register Char Device */
+	result = gsw_api_drv_register(GSW_API_MAJOR_NUMBER);
+
+	if (result != 0) {
+		pr_err("%s:%s:%d (Register Char Device Failed)\n",
+		       __FILE__, __func__, __LINE__);
+		return result;
+	}
+
+	return 0;
+}
+
+#endif /*CONFIG_X86_INTEL_CE2700*/
+
+
+#if defined(WIN_PC_MODE) && WIN_PC_MODE
+
+int ethsw_swapi_register(void)
+{
+	int ret;
+	ethsw_core_init_t core_init;
+
+	/* Find and map our resources */
+	/* Switch device index */
+	addr_gswl = (void *)0x50000;
+
+	/* Init FLOW Switch Core Layer */
+	memset(&core_init, 0, sizeof(ethsw_core_init_t));
+	core_init.sdev = LTQ_FLOW_DEV_INT;
+	core_init.gsw_base_addr = addr_gswl;
+	pEDev0 = ethsw_api_core_init(&core_init);
+
+	if (pEDev0 == NULL) {
+		printf("%s:%s:%d (Init Failed)\n",
+		       __FILE__, __func__, __LINE__);
+		return -1;
+	}
+
+	pEDev0->cport = GSW_3X_SOC_CPU_PORT;
+	pEDev0->gsw_dev = LTQ_FLOW_DEV_INT;
+	pEDev0->gswl_base = addr_gswl;
+	pEDev0->gsw_base = addr_gswl;
+
+#if defined(GSW_IOCTL_SUPPORT) && GSW_IOCTL_SUPPORT
+	ioct_cmd_start_node = gsw_create_ioctl_cmd_linklist(&pEDev0->ops);
+	ioctlinit.pLlTable = ioct_cmd_start_node;
+	ioctlinit.default_handler = NULL;
+	pioctlctl = ioctl_wrapper_init(&ioctlinit);
+
+	if (pioctlctl == NULL) {
+		printf("%s:%s:%d (WrapperInit Failed)\n",
+		       __FILE__, __func__, __LINE__);
+		return -1;
+	}
+
+	/* add Internal switch */
+	if (pioctlctl && pEDev0)
+		ioctl_wrapper_dev_add(pioctlctl, pEDev0, LTQ_INT_GSWITCH);
+
+#endif /* GSW_IOCTL_SUPPORT */
+	return 0;
+}
+
+int ethsw_swapi_unregister(void)
+{
+	//ethsw_api_core_exit(pEDev0);
+#if defined(GSW_IOCTL_SUPPORT) && GSW_IOCTL_SUPPORT
+	gsw_api_ioctl_wrapper_cleanup();
+#endif /* GSW_IOCTL_SUPPORT */
+	return 0;
+}
+
+/*
+static int __init gsw_swapi_init(void *)
+*/
+int gsw_swapi_init()
+{
+	ethsw_swapi_register();
+	return 0;
+}
+
+/*
+static void __exit ltq_etshw_api_exit(void)
+*/
+static void gsw_swapi_exit(void)
+{
+	ethsw_swapi_unregister();
+}
+
+#endif /*WIN_PC_MODE*/
+
+#ifdef __KERNEL__
+
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+int ltq_gsw_api_register(struct platform_device *pdev)
+{
+	int result;
+	struct resource *memres;
+	ethsw_core_init_t core_init;
+	struct clk *clk;
+	struct gswss *gswdev = dev_get_drvdata(pdev->dev.parent);
+	u32 device_id = pdev->dev.parent->id;
+
+	/*Initialize global array*/
+	gswdev->core_dev = pdev;
+
+	memset(&core_init, 0, sizeof(ethsw_core_init_t));
+	printk("GSWIP devid = %d\n", device_id);
+
+	if (device_id < 0 || device_id >= 2)
+		return -EINVAL;
+
+	/* Find and map our resources */
+	memres = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (memres == NULL) {
+		pr_err("%s:%s:%d (Failed)\n", __FILE__, __func__, __LINE__);
+		/*		dev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");*/
+		return -ENOENT;
+	}
+
+	printk("memres->start = 0x%08x memres->end = 0x%08x\n", memres->start, memres->end);
+
+	/*Enable Switch Power  */
+	clk = devm_clk_get(&pdev->dev, "gate");
+
+	if (IS_ERR(clk))
+		panic("Failed to get switch clock");
+
+	clk_prepare_enable(clk);
+
+	if (device_id == 0) {
+		addr_gswl = devm_ioremap_resource(&pdev->dev, memres);
+		printk("addr_gswl = 0x%08x\n", (unsigned int)addr_gswl);
+
+		if (IS_ERR(addr_gswl))
+			return PTR_ERR(addr_gswl);
+
+		pr_err("%s:%s:%d (Register l base:0x%08x)\n",
+		       __FILE__, __func__, __LINE__, (u32)addr_gswl);
+	}
+
+	if (device_id == 1) {
+		addr_gswr = devm_ioremap_resource(&pdev->dev, memres);
+		printk("addr_gswr = 0x%08x\n", (unsigned int)addr_gswr);
+
+		if (IS_ERR(addr_gswr))
+			return PTR_ERR(addr_gswr);
+
+		pr_err("%s:%s:%d (Register r base:0x%08x)\n",
+		       __FILE__, __func__, __LINE__, (u32)addr_gswr);
+	}
+
+	/* Register Char Device */
+	if (device_id == 0) {
+		result = gsw_api_drv_register(GSW_API_MAJOR_NUMBER);
+
+		if (result != 0) {
+			pr_err("%s:%s:%d (Reg Char Device Failed)\n",
+			       __FILE__, __func__, __LINE__);
+			return result;
+		}
+	}
+
+
+	if (device_id == 0) {
+		/* Init FLOW Switch Core Layer */
+		core_init.sdev = LTQ_FLOW_DEV_INT;
+		core_init.gsw_base_addr = addr_gswl;
+		core_init.pdev = (void *)pdev;
+		printk("addr_gswl = 0x%08x\n", (unsigned int)addr_gswl);
+
+		pEDev0 = ethsw_api_core_init(&core_init);
+
+		if (pEDev0 == NULL) {
+			pr_err("%s:%s:%d (Init Failed)\n",
+			       __FILE__, __func__, __LINE__);
+			return -1;
+		}
+
+		pEDev0->cport = GSW_3X_SOC_CPU_PORT;
+		pEDev0->gsw_dev = LTQ_FLOW_DEV_INT;
+		pEDev0->gswl_base = addr_gswl;
+		pEDev0->gsw_base = addr_gswl;
+	}
+
+	if (device_id == 1) {
+		/* Init FLOW Switch Core Layer */
+		core_init.sdev = LTQ_FLOW_DEV_INT_R;
+		core_init.gsw_base_addr = addr_gswr;
+		core_init.pdev = (void *)pdev;
+		pEDev1 = ethsw_api_core_init(&core_init);
+
+		if (pEDev1 == NULL) {
+			pr_err("%s:%s:%d (Init Failed)\n",
+			       __FILE__, __func__, __LINE__);
+			return -1;
+		}
+
+		pEDev1->cport = GSW_3X_SOC_CPU_PORT;
+		pEDev1->gsw_dev = LTQ_FLOW_DEV_INT_R;
+		pEDev1->gswr_base = addr_gswr;
+		pEDev1->gsw_base = addr_gswr;
+	}
+
+	if (device_id == 0) {
+		ioct_cmd_start_node = gsw_create_ioctl_cmd_linklist(&pEDev0->ops);
+		ioctlinit.pLlTable = ioct_cmd_start_node;
+		ioctlinit.default_handler = NULL;
+		pioctlctl = ioctl_wrapper_init(&ioctlinit);
+
+		if (pioctlctl == NULL) {
+			pr_err("%s:%s:%d (WrapperInit Failed)\n",
+			       __FILE__, __func__, __LINE__);
+			return -1;
+		}
+	}
+
+	/* add Internal switch */
+	if ((device_id == 0) && pioctlctl && pEDev0)
+		ioctl_wrapper_dev_add(pioctlctl, &pEDev0->ops, LTQ_INT_GSWITCH);
+
+	/* add Internal switch */
+	if ((device_id == 1) && pioctlctl && pEDev1)
+		ioctl_wrapper_dev_add(pioctlctl, &pEDev1->ops, LTQ_EXT_GSWITCH);
+
+	return 0;
+}
+#endif /* CONFIG_SOC_GRX500 */
+
+int ltq_ethsw_api_register(struct platform_device *pdev)
+{
+	int result;
+	struct resource *res;
+	ethsw_core_init_t core_init;
+	ethsw_api_dev_t *pethdev;
+	ioctl_wrapper_ctx_t *iowrap;
+	ioctl_wrapper_init_t iowrapinit;
+	struct clk *clk;
+
+	/* Find and map our resources */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (res == NULL) {
+		pr_err("%s:%s:%d (Get IORESOURCE_MEM Failed)\n",
+		       __FILE__, __func__, __LINE__);
+		/*		dev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");*/
+		return -ENOENT;
+	}
+
+	addr_gsw = devm_ioremap_resource(&pdev->dev, res);
+
+	if (IS_ERR(addr_gsw))
+		return PTR_ERR(addr_gsw);
+
+	/* Register Char Device */
+	result = gsw_api_drv_register(GSW_API_MAJOR_NUMBER);
+
+	if (result != 0) {
+		pr_err("%s:%s:%d (Register Char Device Failed)\n",
+		       __FILE__, __func__, __LINE__);
+		return result;
+	}
+
+	/*Enable Switch Power  */
+	clk = clk_get_sys("1e108000.eth", NULL);
+	clk_enable(clk);
+
+	/* Init FLOW Switch Core Layer */
+	core_init.pdev = NULL;
+	core_init.sdev = LTQ_FLOW_DEV_INT;
+	core_init.gsw_base_addr = addr_gsw;
+	/*	core_init.pDev = pRALDev; */
+	pethdev = ethsw_api_core_init(&core_init);
+
+	if (pethdev == NULL) {
+		pr_err("%s:%s:%d (Init Failed)\n",
+		       __FILE__, __func__, __LINE__);
+		return -1;
+	}
+
+	pethdev->cport = GSW_2X_SOC_CPU_PORT;
+	pethdev->gsw_base = addr_gsw;
+	iowrapinit.pLlTable = &ltq_flow_fkt_tbl;
+	iowrapinit.default_handler = NULL;
+	iowrap = ioctl_wrapper_init(&iowrapinit);
+
+	if (iowrap == NULL) {
+		pr_err("%s:%s:%d (WrapperInit Failed)\n",
+		       __FILE__, __func__, __LINE__);
+		return -1;
+	}
+
+	/* add Internal switch */
+	ioctl_wrapper_dev_add(iowrap, pethdev, LTQ_INT_GSWITCH);
+	return 0;
+}
+
+int ltq_ethsw_api_unregister(void)
+{
+	/* Free the device data block */
+	gsw_api_drv_unregister(GSW_API_MAJOR_NUMBER);
+	gsw_corecleanup();
+	gsw_delete_ioctl_cmd_linklist(ioct_cmd_start_node);
+	gsw_api_ioctl_wrapper_cleanup();
+	return 0;
+}
+
+/*ltq_ethsw_api_init   the init function, called when the module is loaded.*/
+/*	Returns zero if successfully loaded, nonzero otherwise.*/
+static int __init ltq_ethsw_api_init(struct platform_device *pdev)
+{
+	/* Print Version Number */
+#ifdef CONFIG_SOC_GRX500
+	/*	if (of_machine_is_compatible("lantiq,grx500")) { */
+	ltq_gsw_api_register(pdev);
+#endif
+	/*	} else { */
+#ifdef CONFIG_SOC_XWAY
+	ltq_ethsw_api_register(pdev);
+#endif
+
+#ifdef CONFIG_X86_INTEL_CE2700
+	ltq_ethsw_api_register_p7(pdev);
+#endif
+	/*	} */
+	return 0;
+}
+
+/*ltq_etshw_api_exit  the exit function, called when the module is removed.*/
+static void __exit ltq_etshw_api_exit(void)
+{
+	ltq_ethsw_api_unregister();
+}
+
+static int ltq_switch_api_probe(struct platform_device *pdev)
+{
+	printk("::::::: SWAPI Reached :::::: \n");
+	ltq_ethsw_api_init(pdev);
+	return 0;
+}
+
+static int ltq_switch_api_remove(struct platform_device *pdev)
+{
+	ltq_etshw_api_exit();
+	return 0;
+}
+
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+
+static void __iomem		*gswl_addr;
+static void __iomem		*gswr_addr;
+/** read and update the GSWIP register */
+static void ltq_gsw_w32(short offset, short shift, short size, u32 value)
+{
+	u32 rvalue, mask;
+
+	if (gswl_addr != 0) {
+		rvalue = gsw1_r32(gswl_addr + (offset * 4));
+		mask = (1 << size) - 1;
+		mask = (mask << shift);
+		value = ((value << shift) & mask);
+		value = ((rvalue & ~mask) | value);
+		/*		pr_info("writing %x to the address = %x \n", value, (u32) (gswl_addr + (offset * 4)));*/
+		gsw1_w32(value, (gswl_addr + (offset * 4)));
+	} else {
+		pr_err("%s:%s:%d,(ERROR)\n", __FILE__, __func__, __LINE__);
+	}
+}
+
+static void ltq_gsw_r_w32(short offset, short shift, short size, u32 value)
+{
+	u32 rvalue, mask;
+
+	if (gswr_addr != 0) {
+		rvalue = gsw1_r32(gswr_addr + (offset * 4));
+		mask = (1 << size) - 1;
+		mask = (mask << shift);
+		value = ((value << shift) & mask);
+		value = ((rvalue & ~mask) | value);
+		/*		pr_info("writing %x to the address = %x \n", value, (u32) (gswr_addr + (offset * 4)));*/
+		gsw1_w32(value, (gswr_addr + (offset * 4)));
+	} else {
+		pr_err("%s:%s:%d,(ERROR)\n", __FILE__, __func__, __LINE__);
+	}
+}
+void gsw_api_disable_switch_ports(void)
+{
+	int pidx;
+	gswl_addr = (void __iomem *)(KSEG1 | 0x1c000000);
+	gswr_addr = (void __iomem *)(KSEG1 | 0x1a000000);
+
+	for (pidx = 2; pidx < 6; pidx++) {
+		/* Set SDMA_PCTRL_PEN PORT disable */
+		ltq_gsw_w32((SDMA_PCTRL_PEN_OFFSET + (6 * pidx)),
+			    SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE, 0);
+		/* Set FDMA_PCTRL_EN PORT disable */
+		ltq_gsw_w32((FDMA_PCTRL_EN_OFFSET + (0x6 * pidx)),
+			    FDMA_PCTRL_EN_SHIFT, FDMA_PCTRL_EN_SIZE, 0);
+	}
+
+	for (pidx = 0; pidx < 16; pidx++) {
+		/* Set SDMA_PCTRL_PEN PORT disable */
+		ltq_gsw_r_w32((SDMA_PCTRL_PEN_OFFSET + (6 * pidx)),
+			      SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE, 0);
+		/* Set FDMA_PCTRL_EN PORT disable */
+		ltq_gsw_r_w32((FDMA_PCTRL_EN_OFFSET + (0x6 * pidx)),
+			      FDMA_PCTRL_EN_SHIFT, FDMA_PCTRL_EN_SIZE, 0);
+	}
+}
+EXPORT_SYMBOL(gsw_api_disable_switch_ports);
+
+static const struct of_device_id ltq_switch_api_match[] = {
+	{ .compatible = "intel,falconmx-gswapi" },
+	{},
+};
+
+#endif /* CONFIG_SOC_GRX500  */
+
+#ifdef CONFIG_SOC_XWAY
+
+static const struct of_device_id ltq_switch_api_match[] = {
+	{ .compatible = "lantiq,xway-gsw2x" },
+	{},
+};
+
+#endif /* CONFIG_SOC_XWAY */
+
+#ifdef CONFIG_X86_INTEL_CE2700
+
+static const struct of_device_id ltq_switch_api_match[] = {
+	{ .compatible = "lantiq,xway-gsw2x" },
+	{},
+};
+
+#endif /* CONFIG_X86_INTEL_CE2700 */
+
+MODULE_DEVICE_TABLE(of, ltq_switch_api_match);
+
+static struct platform_driver ltq_switch_api = {
+	.probe = ltq_switch_api_probe,
+	.remove = ltq_switch_api_remove,
+	.driver = {
+		.name = "gsw_core",
+		.of_match_table = ltq_switch_api_match,
+		.owner = THIS_MODULE,
+	},
+};
+
+
+#ifdef CONFIG_X86_INTEL_CE2700
+
+static struct platform_device *ltq_switch_api_dev;
+
+static int __init ltq_ethsw_api_init_p7(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&ltq_switch_api);
+
+	if (ret < 0) {
+		pr_err("%s:%s:%d switch_api driver register failed\n",
+		       __FILE__, __func__, __LINE__);
+		return ret;
+	}
+
+	ltq_switch_api_dev =
+		platform_device_register_simple("xway-gsw2xapi", -1, NULL, 0);
+
+	if (IS_ERR(ltq_switch_api_dev)) {
+		pr_err("%s:%s:%d switch_api device register failed\n",
+		       __FILE__, __func__, __LINE__);
+		platform_driver_unregister(&ltq_switch_api);
+		return PTR_ERR(ltq_switch_api_dev);
+	}
+
+	return 0;
+}
+
+static void __exit ltq_ethsw_api_exit_p7(void)
+{
+	platform_device_unregister(ltq_switch_api_dev);
+	platform_driver_unregister(&ltq_switch_api);
+}
+
+module_init(ltq_ethsw_api_init_p7);
+module_exit(ltq_ethsw_api_exit_p7);
+
+#else
+
+module_platform_driver(ltq_switch_api);
+
+#endif /*CONFIG_X86_INTEL_CE2700*/
+
+MODULE_AUTHOR("LANTIQ");
+MODULE_DESCRIPTION("LTQ ETHSW API");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(GSW_API_DRV_VERSION);
+
+#endif
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_init.h b/drivers/net/ethernet/lantiq/switch-api/gsw_init.h
new file mode 100644
index 000000000000..220c6d6f3553
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_init.h
@@ -0,0 +1,269 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+#ifndef _ETHSW_INIT_H_
+#define _ETHSW_INIT_H_
+
+#define SWAPI_DRV_VERSION "3.0.1"
+
+/* Switch Features  */
+#define CONFIG_LTQ_STP		1
+#define CONFIG_LTQ_8021X	1
+#define CONFIG_LTQ_MULTICAST 1
+#define CONFIG_LTQ_QOS		1
+#define CONFIG_LTQ_VLAN		1
+#define CONFIG_LTQ_WOL		1
+#define CONFIG_LTQ_PMAC		1
+#define CONFIG_LTQ_RMON		1
+
+
+#define CONFIG_MAC  1
+
+/* User configuration options */
+
+#define SMDIO_INTERFACE 0
+#define GSW_IOCTL_SUPPORT 1
+#if defined(WIN_PC_MODE) && WIN_PC_MODE
+#define CONFIG_SOC_GRX500 0
+#define KSEG1 0
+#endif
+
+#define ENABLE_MICROCODE 0
+#define PTR_TO_INT_CAST void *
+
+#ifdef __KERNEL__
+#else
+#define printk	printf
+#define pr_err	printf
+#define pr_info printf
+#endif
+
+
+
+#ifdef __KERNEL__
+//#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+//#include <asm/delay.h> */
+#include <linux/delay.h>
+#include <linux/slab.h>
+
+#ifndef CONFIG_X86_INTEL_CE2700
+#include <net/switch_api/lantiq_gsw_api.h>
+#else
+#include <net/switch_api/lantiq_gsw_api.h>
+#endif /* CONFIG_X86_INTEL_CE2700 */
+
+#include <net/switch_api/gsw_dev.h>
+#include <linux/netdevice.h>
+#include <net/lantiq_cbm_api.h>
+#include <net/switch_api/gsw_tbl_rw.h>
+
+/*#include <xway/switch-api/lantiq_gsw_routing.h>*/
+/*#include <xway/switch-api/gsw_types.h>*/
+
+#define LTQ_GSW_DEV_MAX 2
+#endif /* KERNEL_MODE */
+
+#if defined(WIN_PC_MODE) && WIN_PC_MODE
+#include <stdio.h>
+#include <stdlib.h>
+#include <memory.h>
+#include <string.h>
+#include <malloc.h>
+#include <conio.h>
+#include <signal.h>
+#include <tchar.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <ctype.h>
+#include <stdint.h>
+//#include <sys/ioctl.h>
+#endif
+
+/* IOCTL handling incase the OS is not supporetd */
+#if defined(WIN_PC_MODE) && WIN_PC_MODE
+#define LTQ_GSW_DEV_MAX			1
+#define NRBITS	8
+#define TYPEBITS	8
+#define SIZEBITS	13
+#define DIRBITS	3
+#define NRMASK	((1 << NRBITS)-1)
+#define TYPEMASK	((1 << TYPEBITS)-1)
+#define SIZEMASK	((1 << SIZEBITS)-1)
+#define XSIZEMASK	((1 << (SIZEBITS+1))-1)
+#define DIRMASK	((1 << DIRBITS)-1)
+#define NRSHIFT     0
+#define TYPESHIFT	(NRSHIFT + NRBITS)
+#define SIZESHIFT	(TYPESHIFT + TYPEBITS)
+#define DIRSHIFT	(SIZESHIFT + SIZEBITS)
+#define NN	1U
+#define RD	2U
+#define WR	4U
+#define IOC(dir, type, nr, size) \
+	(((dir)  << DIRSHIFT) | \
+	 ((type) << TYPESHIFT) | \
+	 ((nr)   << NRSHIFT) | \
+	 ((size) << SIZESHIFT))
+#define IO(type, nr)	IOC(NN, (type), (nr), 0)
+#define IOR(type, nr, size)	IOC(RD, (type), (nr), sizeof(size))
+#define IOW(type, nr, size)	IOC(WR, (type), (nr), sizeof(size))
+#define IOWR(type, nr, size)	IOC(RD | WR, (type), (nr), sizeof(size))
+#define IO_TYPE(nr)	(((nr) >> TYPESHIFT) & TYPEMASK)
+#define NR(nr)	(((nr) >> NRSHIFT) & NRMASK)
+#define SIZE(nr)   \
+	((((((nr) >> DIRSHIFT) & DIRMASK) & (WR|RD)) == 0) ? \
+	 0 : (((nr) >> SIZESHIFT) & XSIZEMASK))
+#define _IO	IO
+#define _IOW IOWR
+#define _IOR IOR
+#define _IOWR IOWR
+#define _IOC_TYPE IO_TYPE
+#define _IOC_NR NR
+#define _IOC_SIZE	SIZE
+/* GSW Specific Include files */
+#include <lantiq_gsw_api.h>
+#include <gsw_tbl_rw.h>
+
+#endif /* WIN_PC_MODE */
+
+
+/*include*/
+#include <gsw_ioctl_wrapper.h>
+#include <gsw_flow_core.h>
+#include <gsw_ll_func.h>
+#include <gsw_reg.h>
+#include <gsw_reg_top.h>
+#include <gsw30_reg_top.h>
+
+
+
+#if defined(CONFIG_SOC_GRX500) && CONFIG_SOC_GRX500
+#include <gsw_pae.h>
+#endif
+
+#define GSWIP_GET_BITS(x, msb, lsb)	\
+	(((x) & ((1 << ((msb) + 1)) - 1)) >> (lsb))
+#define GSWIP_SET_BITS(x, msb, lsb, value)	\
+	(((x) & ~(((1 << ((msb) + 1)) - 1) ^ ((1 << (lsb)) - 1)))	\
+	 | (((value) & ((1 << (1 + (msb) - (lsb))) - 1)) << (lsb)))
+
+#define GSW_API_MODULE_NAME "GSW SWITCH API"
+#define GSW_API_DRV_VERSION "3.0.2"
+#define MICRO_CODE_VERSION "212"
+
+
+typedef struct {
+	void *ecdev;
+	void *pdev;
+	gsw_devtype_t sdev;
+	void *gsw_base_addr;
+} ethsw_core_init_t;
+
+void gsw_r32(void *cdev, short offset, short shift, short size, u32 *value);
+void gsw_w32(void *cdev, short offset, short shift, short size, u32 value);
+void *ethsw_api_core_init(ethsw_core_init_t *pinit);
+void gsw_corecleanup(void);
+int	gsw_pmicro_code_init(void *cdev);
+int gsw_swapi_init(void);
+
+#if defined(WIN_PC_MODE) && WIN_PC_MODE
+struct core_ops *gsw_get_swcore_ops(u32 devid);
+#endif
+
+
+#if defined(UART_INTERFACE) && UART_INTERFACE
+int pc_uart_dataread(u32 Offset, u32 *value);
+int pc_uart_datawrite(u32 Offset, u32 value);
+int pc_uart_dataread_32(u32 Offset, u32 *value);
+int pc_uart_datawrite_32(u32 Offset, u32 value);
+#endif /* UART_INTERFACE */
+
+#ifdef __KERNEL__
+void gsw_r32_raw(void *cdev, short offset, u32 *value);
+void gsw_w32_raw(void *cdev, short offset, u32 value);
+#endif
+
+static inline u32 gsw_field_r32(u32 rval, short shift, short size)
+{
+	return (rval >> shift) & ((1 << size) - 1);
+}
+
+static inline u32 gsw_field_w32(u32 rval, short shift, short size, u32 val)
+{
+	u32 mask;
+
+	mask = ((1 << size) - 1) << shift;
+	val = (val << shift)&mask;
+	return (rval & ~mask) | val;
+}
+
+#if defined(WIN_PC_MODE) && WIN_PC_MODE
+static inline void gsw_r32_raw(void *cdev, short offset, u32 *value)
+{
+	ethsw_api_dev_t *pethdev = (ethsw_api_dev_t *)cdev;
+#if defined(UART_INTERFACE) && UART_INTERFACE
+	pc_uart_dataread((uintptr_t)pethdev->gsw_base + (offset * 4), value);
+#endif /* UART_INTERFACE */
+}
+
+static inline void gsw_w32_raw(void *cdev, short offset, u32 value)
+{
+	ethsw_api_dev_t *pethdev = (ethsw_api_dev_t *)cdev;
+#if defined(UART_INTERFACE) && UART_INTERFACE
+	pc_uart_datawrite((uintptr_t)pethdev->gsw_base + (offset * 4), value);
+#endif
+}
+#endif
+
+static inline ethsw_api_dev_t *GSW_PDATA_GET(void *pdev)
+{
+	struct core_ops *gsw_ops;
+	ethsw_api_dev_t *pdata = NULL;
+
+	if (pdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return pdata;
+	}
+
+#ifdef __KERNEL__
+	gsw_ops = (struct core_ops *)pdev;
+
+	if (gsw_ops == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return pdata;
+	}
+
+	pdata = container_of(gsw_ops, ethsw_api_dev_t, ops);
+#else
+	pdata = (ethsw_api_dev_t *)pdev;
+#endif
+	return pdata;
+}
+
+#if defined(WIN_PC_MODE) && WIN_PC_MODE
+struct core_ops *gsw_get_swcore_ops(u32 devid);
+#endif
+
+typedef enum {
+	IRQ_REGISTER 		= 0,
+	IRQ_UNREGISTER 		= 1,
+	IRQ_ENABLE 			= 2,
+	IRQ_DISABLE 		= 3,
+} IRQ_TYPE;
+
+
+
+#endif    /* _ETHSW_INIT_H_ */
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_ioctl_wrapper.c b/drivers/net/ethernet/lantiq/switch-api/gsw_ioctl_wrapper.c
new file mode 100644
index 000000000000..65ffaaa6ce0f
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_ioctl_wrapper.c
@@ -0,0 +1,473 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+
+
+#include <gsw_init.h>
+
+ioctl_wrapper_ctx_t *ioctlwrapctx = NULL;
+
+#define ETHSW_API_DEV_NAME "switch_api"
+
+#ifdef __KERNEL__
+#include <linux/uaccess.h>
+static int gsw_api_open(struct inode *inode, struct file *filp);
+static int gsw_api_release(struct inode *inode, struct file *filp);
+static long gsw_api_ioctl(struct file *filp, u32 cmd, unsigned long arg);
+#endif
+
+ioctl_cmd_handle_t *gsw_api_alloc_cmd_handle(void)
+{
+#ifdef __KERNEL__
+	gfp_t flags;
+#endif
+	ioctl_cmd_handle_t *cmd_handle;
+
+	if (!ioctlwrapctx) {
+		pr_err("ioctlwrapctx not initilized\n");
+		return NULL;
+	}
+
+#ifdef __KERNEL__
+
+	if (in_atomic() || in_interrupt())
+		flags = GFP_ATOMIC;
+	else
+		flags = GFP_KERNEL;
+
+	cmd_handle = kmalloc(sizeof(ioctl_cmd_handle_t), flags);
+#else
+	cmd_handle = malloc(sizeof(ioctl_cmd_handle_t));
+#endif
+
+	if (cmd_handle) {
+		cmd_handle->pLlTable = ioctlwrapctx->pIoctlHandle->pLlTable;
+		cmd_handle->default_handler = ioctlwrapctx->pIoctlHandle->default_handler;
+	}
+
+	return cmd_handle;
+}
+
+
+/** searching for Switch API IOCTL  command */
+int gsw_command_search(void *phandle, u32 command,
+		       u32 arg, ethsw_api_type_t apitype)
+{
+	int retvalue;
+	ioctl_cmd_handle_t *pdrv = (ioctl_cmd_handle_t *) phandle;
+	const ltq_lowlevel_fkts_t *pLlTable = pdrv->pLlTable;
+	/*  attempt to acquire the semaphore ...*/
+
+	/* This table contains the low-level function for the */
+	/* IOCTL	commands with the same MAGIC-Type numer. */
+	while (pLlTable != NULL) {
+		if (_IOC_TYPE(command) == pLlTable->nType) {
+			LTQ_ll_fkt fkt;
+			u32 size;
+			u32 cmdnr = _IOC_NR(command);
+
+			/* Number out of range. No function available */
+			/* for	this command number. */
+			if (cmdnr >= pLlTable->nNumFkts) {
+				pr_err("pLlTable->nNumFkts =%d,cmdnr=%d\n", pLlTable->nNumFkts, cmdnr);
+				pr_err("gsw_command_search :Number out of range. No function available\n");
+				goto fail;
+			}
+
+			fkt = (LTQ_ll_fkt)pLlTable->pFkts[cmdnr];
+
+			/* No low-level function given for this command. */
+			if (fkt == NULL) {
+				pr_err("ERROR %s[%d]: cmdnr=%d, nNumFkts=%d\n",
+				       __func__, __LINE__, cmdnr, pLlTable->nNumFkts);
+				goto fail;
+			}
+
+			/* Copy parameter from userspace. */
+			size = _IOC_SIZE(command);
+
+			/* Local temporary buffer to store the parameter is to small. */
+			if (size > PARAM_BUFFER_SIZE) {
+				pr_err("ERROR %s[%d]: cmdnr=%d, nNumFkts=%d\n",
+				       __func__, __LINE__, cmdnr, pLlTable->nNumFkts);
+				goto fail;
+			}
+
+			if (apitype == ETHSW_API_USERAPP) {
+#ifdef __KERNEL__
+				copy_from_user((void *)(pdrv->paramBuffer),
+					       (const void __user *)arg, (unsigned long)size);
+				/* Now call the low-level function with the right low-level context */
+				/* handle and the local copy of the parameter structure of 'arg'. */
+
+
+				/*Calling function pointer*/
+				retvalue = fkt(pdrv->pLlHandle,
+					       (u32)pdrv->paramBuffer);
+
+				/* Copy parameter to userspace. */
+				/* Only copy back to userspace if really required */
+				if (_IOC_DIR(command) & _IOC_READ) {
+					copy_to_user((void __user *)arg,
+						     (const void *)(pdrv->paramBuffer),
+						     (unsigned long)size);
+				}
+
+#endif
+			} else {
+				memcpy((void *)(pdrv->paramBuffer),
+				       (const void *) arg, (unsigned long)size);
+
+
+				/*Calling function pointer*/
+				retvalue = fkt(pdrv->pLlHandle,
+					       (u32)pdrv->paramBuffer);
+
+				memcpy((void *)arg,
+				       (const void *)(pdrv->paramBuffer),
+				       (unsigned long)size);
+
+			}
+
+			/*	pr_err(" %s[%d]: cmdnr=%d, nNumFkts=%d, retvalue:%d\n",*/
+			/*__func__, __LINE__, cmdnr, pLlTable->nNumFkts, retvalue);*/
+			return retvalue;
+		}
+
+		/* If command was not found in the current table index, */
+		/* look for the next linked table. Search till it is found */
+		/* or we run out of tables.*/
+		pLlTable = pLlTable->pNext;
+	}
+
+	if (pdrv->default_handler != NULL) {
+		retvalue = pdrv->default_handler(pdrv->pLlHandle, command, arg);
+		/*pr_err(" %s[%d]:  retvalue:%d\n", __func__, __LINE__, retvalue);*/
+		return retvalue;
+	}
+
+fail:
+	/*  release the given semaphore */
+//	up(&swapi_sem);
+	/* No supported command low-level function found.*/
+	return -1;
+}
+/**The driver callbacks that will be registered with the kernel*/
+/*static*/
+#ifdef __KERNEL__
+const struct file_operations swapi_fops = {
+owner:
+	THIS_MODULE,
+unlocked_ioctl :
+	gsw_api_ioctl,
+open :
+	gsw_api_open,
+release :
+	gsw_api_release
+};
+
+static long gsw_api_ioctl(struct file *filp, u32 cmd, unsigned long arg)
+{
+	dev_minor_num_t *p;
+	int ret;
+	ioctl_wrapper_ctx_t *pdev;
+	ioctl_cmd_handle_t *cmd_handle;
+
+	if (!ioctlwrapctx) {
+		pr_err("ioctlwrapctx not initilized\n");
+		return -1;
+	}
+
+	p = filp->private_data;
+	pdev = ioctlwrapctx;
+	cmd_handle = gsw_api_alloc_cmd_handle();
+
+	if (!cmd_handle) return -1;
+
+	if (!p->minor_number) {
+		if (pdev->bInternalSwitch == 1)
+			cmd_handle->pLlHandle = pdev->pEthSWDev[0];
+		else {
+			pr_err("%s[%d]: Not support internal switch\n\n",
+			       __func__, __LINE__);
+			kfree(cmd_handle);
+			return -1;
+		}
+	} else {
+		if (p->minor_number <= pdev->nExternalSwitchNum) {
+			cmd_handle->pLlHandle = pdev->pEthSWDev[p->minor_number];
+		} else {
+			pr_err("(Not support external switch number: %d) %s:%s:%d\n",
+			       p->minor_number, __FILE__, __func__, __LINE__);
+			kfree(cmd_handle);
+			return -1;
+		}
+	}
+
+	ret = gsw_command_search(cmd_handle, cmd,
+				 arg, ETHSW_API_USERAPP);
+	kfree(cmd_handle);
+	return ret;
+}
+
+static int gsw_api_open(struct inode *inode, struct file *filp)
+{
+	u32 minornum, majornum;
+	dev_minor_num_t *p;
+
+	minornum = MINOR(inode->i_rdev);
+	majornum = MAJOR(inode->i_rdev);
+	p = kmalloc(sizeof(dev_minor_num_t), GFP_KERNEL);
+
+	if (!p) {
+		pr_err("%s[%d]: memory allocation failed !!\n",
+		       __func__, __LINE__);
+		return -ENOMEM;
+	}
+
+	p->minor_number = minornum;
+	filp->private_data = p;
+	return 0;
+}
+
+static int gsw_api_release(struct inode *inode,
+			   struct file *filp)
+{
+	if (filp->private_data) {
+		kfree(filp->private_data);
+		filp->private_data = NULL;
+	}
+
+	return 0;
+}
+
+int gsw_api_drv_register(u32 major)
+{
+	int result;
+	result = register_chrdev(major, ETHSW_API_DEV_NAME, &swapi_fops);
+
+	if (result < 0) {
+		pr_err("SWAPI: Register Char Dev failed with %d !!!\n", result);
+		return result;
+	}
+
+	pr_info("SWAPI: Registered char device [%s] with major no [%d]\n",
+		ETHSW_API_DEV_NAME, major);
+	return 0;
+}
+
+int gsw_api_drv_unregister(u32 major)
+{
+	unregister_chrdev(major, ETHSW_API_DEV_NAME);
+	return 0;
+}
+
+#endif /*KERNAL Mode*/
+
+void *ioctl_wrapper_init(ioctl_wrapper_init_t *pinit)
+{
+	u8 i;
+	ioctl_wrapper_ctx_t *pdev;
+#ifdef __KERNEL__
+	pdev = (ioctl_wrapper_ctx_t *)kmalloc(sizeof(ioctl_wrapper_ctx_t), GFP_KERNEL);
+#else
+	pdev = (ioctl_wrapper_ctx_t *)malloc(sizeof(ioctl_wrapper_ctx_t));
+#endif
+
+	if (!pdev) {
+		pr_err("%s memory allocation failed !!\n", __func__);
+		return pdev;
+	}
+
+	pdev->bInternalSwitch = 0;  /* internal switch, the value is 0 */
+	pdev->nExternalSwitchNum = 0;
+#ifdef __KERNEL__
+	pdev->pIoctlHandle = (ioctl_cmd_handle_t *)kmalloc(sizeof(ioctl_cmd_handle_t), GFP_KERNEL);
+#else
+	pdev->pIoctlHandle = (ioctl_cmd_handle_t *)malloc(sizeof(ioctl_cmd_handle_t));
+#endif
+
+	if (!pdev->pIoctlHandle) {
+		pr_err("%s memory allocation failed !!\n", __func__);
+
+		if (pdev)
+#ifdef __KERNEL__
+			kfree(pdev);
+
+#else
+			free(pdev);
+#endif
+		return NULL; /*pdev->pIoctlHandle;*/
+	}
+
+	pdev->pIoctlHandle->pLlTable = pinit->pLlTable;
+	pdev->pIoctlHandle->default_handler = pinit->default_handler;
+
+	for (i = 0; i < LTQ_GSW_DEV_MAX; i++)
+		pdev->pEthSWDev[i] = NULL;
+
+	ioctlwrapctx = pdev;
+	return pdev;
+}
+
+int ioctl_wrapper_dev_add(ioctl_wrapper_ctx_t *pioctldev,
+			  void *pcoredev, u8 mnum)
+{
+	if (mnum >= LTQ_GSW_DEV_MAX) {
+		pr_err("(Device number: %d) %s:%s:%d\n", mnum,
+		       __FILE__, __func__, __LINE__);
+		return -1;
+	}
+
+	pioctldev->pEthSWDev[mnum] = pcoredev;
+
+	if (!mnum)
+		pioctldev->bInternalSwitch = 1;
+	else /* other than 0 means external switch */
+		pioctldev->nExternalSwitchNum++;
+
+	return 0;
+}
+
+int gsw_api_ioctl_wrapper_cleanup(void)
+{
+	ioctl_wrapper_ctx_t *pdev = ioctlwrapctx;
+
+	if (pdev != NULL) {
+		ioctlwrapctx = NULL;
+
+		if (pdev->pIoctlHandle != NULL) {
+#ifdef __KERNEL__
+			kfree(pdev->pIoctlHandle);
+#else
+			free(pdev->pIoctlHandle);
+#endif
+			pdev->pIoctlHandle = NULL;
+		}
+
+#ifdef __KERNEL__
+		kfree(pdev);
+#else
+		free(pdev);
+#endif
+
+		pdev = NULL;
+	}
+
+	return 0;
+}
+
+GSW_API_HANDLE gsw_api_kopen(char *name)
+{
+	ioctl_wrapper_ctx_t *pdev;
+	void *pLlHandle;
+	/* process /dev/switch/minor string */
+	char *needle = "/";
+	char *buf = strstr(name, needle);
+
+	if (!ioctlwrapctx) {
+		pr_err("ioctlwrapctx not initilized\n");
+		return 0;
+	}
+
+	pdev = ioctlwrapctx;
+	name = buf + strlen(needle); /* pointer to dev */
+
+	if (name != NULL) {
+		buf = strstr(name, needle);
+	}
+
+	name = buf + strlen(needle); /* pointer to switch */
+
+	if (name != NULL) {
+		buf = strstr(name, needle);
+	}
+
+	name = buf + strlen(needle); /* pointer to minor */
+
+	if (name == NULL)
+		return 0;
+
+	if (!strcmp(name, "0")) {
+		if (pdev->bInternalSwitch == 1)
+			pLlHandle = pdev->pEthSWDev[0];
+		else {
+			pr_err("\nNot support internal switch\n\n");
+			return 0;
+		}
+	} else if (!strcmp(name, "1")) {
+		pLlHandle = pdev->pEthSWDev[1];
+	} else {
+		pr_err("\nNot support external switch number = %s\n\n", name);
+		return 0;
+	}
+
+	return (GSW_API_HANDLE)pLlHandle;
+}
+#ifdef __KERNEL__
+EXPORT_SYMBOL(gsw_api_kopen);
+#endif
+
+int gsw_api_kioctl(GSW_API_HANDLE handle, u32 command, u32 arg)
+{
+	ioctl_wrapper_ctx_t *pdev = NULL;
+	ioctl_cmd_handle_t *cmd_handle;
+	int ret;
+
+	if (!ioctlwrapctx) {
+		pr_err("ioctlwrapctx not initilized\n");
+		return -1;
+	}
+
+	pdev = ioctlwrapctx;
+	cmd_handle = gsw_api_alloc_cmd_handle();
+
+	if (!cmd_handle) {
+		printk("ERROR :Wrong cmd_handle ,gsw_api_alloc_cmd_handle return -1\n");
+		return -1;
+	}
+
+	if (handle == (GSW_API_HANDLE)pdev->pEthSWDev[0]) {
+		cmd_handle->pLlHandle = pdev->pEthSWDev[0];
+	} else if (handle == (GSW_API_HANDLE)pdev->pEthSWDev[1]) {
+		cmd_handle->pLlHandle = pdev->pEthSWDev[1];
+	}	else {
+		pr_err("ERROR:Provided wrong address ( Address:0x%08x) %s:%s:%d\n",
+		       handle, __FILE__, __func__, __LINE__);
+#ifdef __KERNEL__
+		kfree(cmd_handle);
+#else
+		free(cmd_handle);
+#endif
+		return -1;
+	}
+
+	ret = gsw_command_search(cmd_handle, command, arg, ETHSW_API_KERNEL);
+
+#ifdef __KERNEL__
+	kfree(cmd_handle);
+#else
+	free(cmd_handle);
+#endif
+
+	return ret;
+}
+#ifdef __KERNEL__
+EXPORT_SYMBOL(gsw_api_kioctl);
+#endif
+int gsw_api_kclose(GSW_API_HANDLE handle)
+{
+	/* Nothing to do for kernel API's */
+	return 0;
+}
+#ifdef __KERNEL__
+EXPORT_SYMBOL(gsw_api_kclose);
+#endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_ioctl_wrapper.h b/drivers/net/ethernet/lantiq/switch-api/gsw_ioctl_wrapper.h
new file mode 100644
index 000000000000..c2021ca556e7
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_ioctl_wrapper.h
@@ -0,0 +1,103 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+
+
+#ifndef _LTQ_ETHSW_API_LINUX_H_
+#define _LTQ_ETHSW_API_LINUX_H_
+
+#define PARAM_BUFFER_SIZE			2048
+typedef enum {
+	ETHSW_API_USERAPP = 0,
+	ETHSW_API_KERNEL,
+} ethsw_api_type_t;
+
+
+/* general declaration fits for all low-level functions. */
+typedef int (*LTQ_ll_fkt)(void *, u32);
+typedef struct ltq_lowlevel_fkts_t ltq_lowlevel_fkts_t;
+/* Switch API low-level function tables to map all supported IOCTL commands */
+struct ltq_lowlevel_fkts_t {
+	/*Some device have multiple tables to split the generic
+	switch API features and the device specific switch API features.
+	Additional tables, if exist,	can be found under this next pointer.
+	Every table comes along with a different 'nType'
+	parameter to differentiate.*/
+	ltq_lowlevel_fkts_t	*pNext;
+	/* IOCTL type of all commands listed in the table. */
+	u16 nType;
+	/* Number of low-level functions listed in the table. */
+	u32 nNumFkts;
+	/* Pointer to the first entry of the ioctl number table.
+	This table is used to check if the given ioctl command fits
+	the the found low-level function pointer under 'pFkts'.*/
+	/* u32	*pIoctlCmds;*/
+	/* Pointer to the first entry of the function table.
+	Table size is given by the parameter 'nNumFkts'. */
+	LTQ_ll_fkt	*pFkts;
+};
+/* function type declaration for the default IOCTL low-level function in
+   case the command cannot be found in the low-level function table,
+	or in case no low-level function table is provided.. */
+typedef int (*ioctl_default_fkt)(void *, int, int);
+/*typedef*/
+typedef struct {
+	ltq_lowlevel_fkts_t *pLlTable;
+	void *pLlHandle;
+	char paramBuffer[PARAM_BUFFER_SIZE];
+	/** Default callback handler. This handler is called	\
+	in case the command cannot be found in the low-level	\
+	function table, or in case no low-level function table is provided.
+	Provide a 'NULL' pointer in case no default handler is provided. */
+	ioctl_default_fkt default_handler;
+} ioctl_cmd_handle_t;
+
+/*typedef*/
+typedef struct {
+	ltq_bool_t	bInternalSwitch;
+	/** Number of similar Low Level External Switch Devices */
+	u8 nExternalSwitchNum;
+	ioctl_cmd_handle_t *pIoctlHandle;
+	/** Array of pEthSWDev pointers associated with this driver context */
+	void *pEthSWDev[LTQ_GSW_DEV_MAX];
+} ioctl_wrapper_ctx_t;
+
+/*typedef*/
+typedef struct {
+	ltq_lowlevel_fkts_t	*pLlTable;
+	/** Default callback handler. This handler is called in case the command
+	    cannot be found in the low-level function table, or in case no low-level
+	    function table is provided.
+	    Provide a 'NULL' pointer in case no default handler is provided. */
+	ioctl_default_fkt		default_handler;
+} ioctl_wrapper_init_t;
+
+/*typedef*/
+typedef struct {
+	u8				minor_number;
+} dev_minor_num_t;
+
+struct fkts_linklist {
+	ltq_lowlevel_fkts_t	*first_ptr;
+	ltq_lowlevel_fkts_t	*last_ptr;
+};
+
+
+int gsw_api_drv_register(u32 major);
+int gsw_api_drv_unregister(u32 major);
+void	*ioctl_wrapper_init(ioctl_wrapper_init_t *pinit);
+int ioctl_wrapper_dev_add(ioctl_wrapper_ctx_t *pioctldev,
+			  void *pcoredev, u8 mnum);
+int gsw_api_ioctl_wrapper_cleanup(void);
+
+
+
+#endif    /* _LTQ_ETHSW_API_LINUX_H_ */
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_irq.c b/drivers/net/ethernet/lantiq/switch-api/gsw_irq.c
new file mode 100644
index 000000000000..8b6b988d8b47
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_irq.c
@@ -0,0 +1,746 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+For licensing information, see the file 'LICENSE' in the root folder of
+this software module.
+******************************************************************************/
+
+#include <gsw_init.h>
+
+typedef void (*gsw_call_back)(void *param);
+
+extern ethsw_api_dev_t *ecoredev[LTQ_FLOW_DEV_MAX];
+
+GSW_return_t  GSW_Debug_PrintPceIrqList(void *cdev)
+{
+	gsw_pce_irq *irq;
+	unsigned int i = 0;
+	unsigned int port = 0;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	irq = gswdev->PceIrqList->first_ptr;
+	printk("\n");
+
+	while (irq != NULL) {
+		printk("PCE Node %d:\n", i);
+		printk("Irq address          = 0x%x\n", (u32)irq);
+		printk("Next Irq Address     = 0x%x\n\n", (u32)irq->pNext);
+
+		if (irq->Port_ier_enabled)
+			printk("\tPort IER			= ENABLED\n");
+		else
+			printk("\tPort IER			= DISABLED\n");
+
+		for (i = 0; i < 12; i++) {
+			if (irq->P_IER_MASK & (1 << i)) {
+				port = i;
+				break;
+			}
+		}
+
+		printk("\tP_IER_MASK			= %u (port no)\n", port);
+
+		if (irq->Event_ier_enable)
+			printk("\tEvent IER			= ENABLED\n");
+		else
+			printk("\tEvent IER			= DISABLED\n");
+
+		switch (irq->E_IER_MASK) {
+		case PCE_MAC_TABLE_CHANGE:
+			printk("\tE_IER_MASK			= PCE_MAC_TABLE_CHANGE\n");
+			break;
+
+		case PCE_FLOW_TABLE_RULE_MATCHED:
+			printk("\tE_IER_MASK			= PCE_FLOW_TABLE_RULE_MATCHED\n");
+			break;
+
+		case PCE_CLASSIFICATION_PHASE_2:
+			printk("\tE_IER_MASK			= PCE_CLASSIFICATION_PHASE_2\n");
+			break;
+
+		case PCE_CLASSIFICATION_PHASE_1:
+			printk("\tE_IER_MASK			= PCE_CLASSIFICATION_PHASE_1\n");
+			break;
+
+		case PCE_CLASSIFICATION_PHASE_0:
+			printk("\tE_IER_MASK			= PCE_CLASSIFICATION_PHASE_0\n");
+			break;
+
+		case PCE_PARSER_READY:
+			printk("\tE_IER_MASK			= PCE_PARSER_READY\n");
+			break;
+
+		case PCE_IGMP_TABLE_FULL:
+			printk("\tE_IER_MASK			= PCE_IGMP_TABLE_FULL\n");
+			break;
+
+		case PCE_MAC_TABLE_FULL:
+			printk("\tE_IER_MASK			= PCE_MAC_TABLE_FULL\n");
+			break;
+		}
+
+		printk("\tP_ISR_MASK			= %u\n", irq->P_ISR_MASK);
+		printk("\tE_ISR_MASK			= %u\n", irq->E_ISR_MASK);
+		printk("\tcall_back				= 0x%x\n", (u32)irq->call_back);
+		printk("\n");
+		irq = irq->pNext;
+		i++;
+	}
+
+	return GSW_statusOk;
+}
+
+static unsigned int PortIrq_Match(gsw_pce_irq *p1,
+				  gsw_pce_irq *p2)
+{
+	if (p1->P_IER_MASK == p2->P_IER_MASK &&
+	    p1->P_ISR_MASK == p2->P_ISR_MASK)
+		return 1;
+	else
+		return 0;
+}
+
+static unsigned int EventIrq_Match(gsw_pce_irq *p1,
+				   gsw_pce_irq *p2)
+{
+	if (p1->E_IER_MASK == p2->E_IER_MASK &&
+	    p1->E_ISR_MASK == p2->E_ISR_MASK)
+		return 1;
+	else
+		return 0;
+}
+
+static GSW_return_t pce_irq_add(void *cdev, gsw_pce_irq pce_irg,
+				struct pce_irq_linklist *node)
+{
+	gsw_pce_irq	*register_irq = NULL;
+	gsw_pce_irq *irq = NULL;
+	irq = node->first_ptr;
+
+	while (irq != NULL) {
+		if (PortIrq_Match(&pce_irg, irq) &&
+		    EventIrq_Match(&pce_irg, irq)) {
+			pr_err("ERROR : Invalid operation , IRQ already registered %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+		irq = irq->pNext;
+	}
+
+#ifdef __KERNEL__
+	register_irq = (gsw_pce_irq *)kmalloc(sizeof(gsw_pce_irq), GFP_KERNEL);
+	memset(register_irq, 0, sizeof(gsw_pce_irq));
+#else
+	register_irq = (gsw_pce_irq *)malloc(sizeof(gsw_pce_irq));
+	memset(register_irq, 0, sizeof(gsw_pce_irq));
+#endif
+
+	register_irq->pNext			=	NULL;
+	register_irq->Port_ier_enabled	=	0;
+	register_irq->P_IER_MASK	=	pce_irg.P_IER_MASK;
+	register_irq->Event_ier_enable	=	0;
+	register_irq->E_IER_MASK	=	pce_irg.E_IER_MASK;
+	register_irq->P_ISR_MASK	=	pce_irg.P_ISR_MASK;
+	register_irq->E_ISR_MASK	=	pce_irg.E_ISR_MASK;
+	register_irq->call_back		=	pce_irg.call_back;
+	register_irq->param			=	pce_irg.param;
+
+	if (node->first_ptr != NULL) {
+		node->last_ptr->pNext = register_irq;
+		node->last_ptr = register_irq;
+	} else {
+		node->first_ptr = node->last_ptr = register_irq;
+	}
+
+	return GSW_statusOk;
+}
+
+static GSW_return_t pce_irq_del(void *cdev, gsw_pce_irq pce_irg,
+				struct pce_irq_linklist *node)
+{
+	gsw_pce_irq *prv_irq = NULL, *delete_irq = NULL;
+	u32 p_ierq = 0;
+	delete_irq = node->first_ptr;
+
+	while (delete_irq != NULL) {
+		if (PortIrq_Match(&pce_irg, delete_irq) &&
+		    EventIrq_Match(&pce_irg, delete_irq)) {
+
+			gsw_r32(cdev, PCE_IER_0_OFFSET,
+				delete_irq->P_IER_MASK,
+				1, &p_ierq);
+
+			/*Check only Port IER*/
+			if (p_ierq) {
+				pr_err("ERROR : Can not Un-Register IRQ, disable IRQ first %s:%s:%d\n",
+				       __FILE__, __func__, __LINE__);
+				return -1;
+			}
+
+			if (node->first_ptr == delete_irq &&
+			    node->last_ptr == delete_irq) {
+				node->first_ptr = delete_irq->pNext;
+				node->last_ptr = delete_irq->pNext;
+			} else if (node->first_ptr == delete_irq) {
+				node->first_ptr = delete_irq->pNext;
+			} else if (node->last_ptr == delete_irq) {
+				node->last_ptr = prv_irq;
+				prv_irq->pNext = delete_irq->pNext;
+			} else {
+				prv_irq->pNext = delete_irq->pNext;
+			}
+
+#ifdef __KERNEL__
+			kfree(delete_irq);
+#else
+			free(delete_irq);
+#endif
+			return GSW_statusOk;
+		}
+
+		prv_irq = delete_irq;
+		delete_irq = delete_irq->pNext;
+	}
+
+	pr_err("ERROR : Invalid operation , IRQ not registered %s:%s:%d\n",
+	       __FILE__, __func__, __LINE__);
+	return GSW_statusErr;
+}
+
+static GSW_return_t pce_irq_enable(void *cdev, gsw_pce_irq pce_irg,
+				   struct pce_irq_linklist *node)
+{
+	u32 p_ierq = 0, e_ierq = 0, irq_registered = 0;
+	gsw_pce_irq *irq = NULL;
+
+	irq = node->first_ptr;
+
+	while (irq != NULL) {
+		p_ierq = 0;
+		e_ierq = 0;
+
+		if (PortIrq_Match(&pce_irg, irq))
+			p_ierq = 1;
+
+		if (EventIrq_Match(&pce_irg, irq))
+			e_ierq = 1;
+
+		if (p_ierq && e_ierq &&
+		    pce_irg.P_IER_MASK != PCE_INVALID_PORT_IERQ &&
+		    pce_irg.E_IER_MASK != PCE_INVALID_EVENT_IERQ) {
+			/*If both Port IER and Event IER found
+				in the IRQ register list*/
+			irq->Port_ier_enabled = 1;
+			gsw_w32(cdev, PCE_IER_0_OFFSET,
+				irq->P_IER_MASK, 1, 1);
+
+			irq->Event_ier_enable = 1;
+			gsw_w32(cdev, PCE_IER_1_OFFSET,
+				irq->E_IER_MASK, 1, 1);
+
+			return 1;
+		} else if (pce_irg.P_IER_MASK == PCE_INVALID_PORT_IERQ
+			   && e_ierq) {
+			/*if only Event IER in
+			  the IRQ register list*/
+			irq->Event_ier_enable = 1;
+			gsw_w32(cdev, PCE_IER_1_OFFSET,
+				irq->E_IER_MASK, 1, 1);
+			irq_registered = 1;
+		} else if (pce_irg.E_IER_MASK == PCE_INVALID_EVENT_IERQ
+			   && p_ierq) {
+			/*if only Port IER in
+			  the IRQ register list*/
+			irq->Port_ier_enabled = 1;
+			gsw_w32(cdev, PCE_IER_0_OFFSET,
+				irq->P_IER_MASK, 1, 1);
+			irq_registered = 1;
+		}
+
+		irq = irq->pNext;
+	}
+
+	if (!irq_registered) {
+		pr_err("ERROR : Invalid operation , IRQ not registered %s:%s:%d\n",
+		       __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	return GSW_statusOk;
+}
+
+static GSW_return_t pce_irq_disable(void *cdev, gsw_pce_irq pce_irg,
+				    struct pce_irq_linklist *node)
+{
+	u32 p_ierq = 0, e_ierq = 0;
+	gsw_pce_irq *irq = NULL;
+	irq = node->first_ptr;
+
+	if (pce_irg.P_IER_MASK == PCE_INVALID_PORT_IERQ) {
+		p_ierq = 1;
+		irq = NULL;
+	} else {
+		irq = node->first_ptr;
+	}
+
+	while (irq != NULL) {
+		if (PortIrq_Match(&pce_irg, irq)) {
+			irq->Port_ier_enabled = 0;
+			gsw_w32(cdev, PCE_IER_0_OFFSET,
+				irq->P_IER_MASK, 1, 0);
+			p_ierq = 1;
+		}
+
+		irq = irq->pNext;
+	}
+
+	if (!p_ierq) {
+		pr_err("ERROR : Invalid operation , PORT not registered %s:%s:%d\n",
+		       __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (pce_irg.E_IER_MASK == PCE_INVALID_EVENT_IERQ) {
+		e_ierq = 1;
+		irq = NULL;
+	} else {
+		irq = node->first_ptr;
+	}
+
+	while (irq != NULL) {
+		if (EventIrq_Match(&pce_irg, irq)) {
+			irq->Event_ier_enable = 0;
+			gsw_w32(cdev, PCE_IER_1_OFFSET,
+				irq->E_IER_MASK, 1, 0);
+			e_ierq = 1;
+		}
+
+		irq = irq->pNext;
+	}
+
+	if (!e_ierq) {
+		pr_err("ERROR : Invalid operation , EVENT not registered %s:%s:%d\n",
+		       __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	return GSW_statusOk;
+}
+
+static GSW_return_t pce_irq_config(void *cdev, GSW_Irq_Op_t *irq, IRQ_TYPE IrqType)
+{
+	gsw_pce_irq pce_irg;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (irq->portid > gswdev->tpnum &&
+	    irq->portid != PCE_INVALID_PORT_IERQ) {
+		pr_err("ERROR : PortId %d is not with in GSWIP capabilty %s:%s:%d\n",
+		       irq->portid, __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	} else if (irq->portid == PCE_INVALID_PORT_IERQ) {
+		pce_irg.P_IER_MASK 	= PCE_INVALID_PORT_IERQ;
+	} else {
+		pce_irg.P_IER_MASK 	= PCE_IER_0_PORT_MASK_GET(irq->portid);
+		pce_irg.P_ISR_MASK 	= PCE_ISR_0_PORT_MASK_GET(irq->portid);
+	}
+
+	switch (irq->event) {
+	case PCE_MAC_TABLE_CHANGE:
+		pce_irg.E_IER_MASK = PCE_IER_1_CHG_SHIFT;
+		pce_irg.E_ISR_MASK = PCE_ISR_1_CHG_SHIFT;
+		break;
+
+	case PCE_FLOW_TABLE_RULE_MATCHED:
+		pce_irg.E_IER_MASK = PCE_IER_1_FLOWINT_SHIFT;
+		pce_irg.E_ISR_MASK = PCE_ISR_1_FLOWINT_SHIFT;
+		break;
+
+	case PCE_CLASSIFICATION_PHASE_2:
+		pce_irg.E_IER_MASK = PCE_IER_1_CPH2_SHIFT;
+		pce_irg.E_ISR_MASK = PCE_ISR_1_CPH2_SHIFT;
+		break;
+
+	case PCE_CLASSIFICATION_PHASE_1:
+		pce_irg.E_IER_MASK = PCE_IER_1_CPH1_SHIFT;
+		pce_irg.E_ISR_MASK = PCE_ISR_1_CPH1_SHIFT;
+		break;
+
+	case PCE_CLASSIFICATION_PHASE_0:
+		pce_irg.E_IER_MASK = PCE_IER_1_CPH0_SHIFT;
+		pce_irg.E_ISR_MASK = PCE_ISR_1_CPH0_SHIFT;
+		break;
+
+	case PCE_PARSER_READY:
+		pce_irg.E_IER_MASK = PCE_IER_1_PRDY_SHIFT;
+		pce_irg.E_ISR_MASK = PCE_ISR_1_PRDY_SHIFT;
+		break;
+
+	case PCE_IGMP_TABLE_FULL:
+		pce_irg.E_IER_MASK = PCE_IER_1_IGTF_SHIFT;
+		pce_irg.E_ISR_MASK = PCE_ISR_1_IGTF_SHIFT;
+		break;
+
+	case PCE_MAC_TABLE_FULL:
+		pce_irg.E_IER_MASK = PCE_IER_1_MTF_SHIFT;
+		pce_irg.E_ISR_MASK = PCE_ISR_1_MTF_SHIFT;
+		break;
+
+	case PCE_INVALID_EVENT_IERQ:
+		pce_irg.E_IER_MASK = PCE_INVALID_EVENT_IERQ;
+		break;
+
+	default:
+		pr_err("ERROR : Invalid pce blk event ENUM = %d %s:%s:%d\n",
+		       irq->event, __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	switch (IrqType)	{
+	case IRQ_REGISTER:
+		if (irq->event == PCE_INVALID_EVENT_IERQ) {
+			pr_err("ERROR : PCE_INVALID_EVENT_IERQ %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+		if (irq->portid == PCE_INVALID_PORT_IERQ) {
+			pr_err("ERROR : PCE PCE_INVALID_PORT_IERQ %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+		if (irq->call_back != NULL) {
+			pce_irg.call_back	= irq->call_back;
+			pce_irg.param		= irq->param;
+		} else {
+			pr_err("ERROR : callback handle is NULL %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+		pce_irq_add(cdev, pce_irg, gswdev->PceIrqList);
+		break;
+
+	case IRQ_UNREGISTER:
+		if (irq->event == PCE_INVALID_EVENT_IERQ) {
+			pr_err("ERROR : PCE_INVALID_EVENT_IERQ %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+		if (irq->portid == PCE_INVALID_PORT_IERQ) {
+			pr_err("ERROR : PCE PCE_INVALID_PORT_IERQ %s:%s:%d\n",
+			       __FILE__, __func__, __LINE__);
+			return GSW_statusErr;
+		}
+
+		pce_irq_del(cdev, pce_irg, gswdev->PceIrqList);
+		break;
+
+	case IRQ_ENABLE:
+		pce_irq_enable(cdev, pce_irg, gswdev->PceIrqList);
+		break;
+
+	case IRQ_DISABLE:
+		pce_irq_disable(cdev, pce_irg, gswdev->PceIrqList);
+		break;
+
+	default:
+		pr_err("invalid irq type %s:%s:%d\n",
+		       __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	return GSW_statusOk;
+}
+
+static GSW_return_t swcore_irq_config(void *cdev, GSW_Irq_Op_t *irq, IRQ_TYPE IrqType)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_irq);
+#endif
+
+	switch (irq->blk) {
+	case BM:
+		pr_err("BM BLK IRQ not supported %s:%s:%d\n",
+		       __FILE__, __func__, __LINE__);
+		break;
+
+	case SDMA:
+		pr_err("SDMA IRQ not supported %s:%s:%d\n",
+		       __FILE__, __func__, __LINE__);
+		break;
+
+	case FDMA:
+		pr_err("FDMA IRQ not supported %s:%s:%d\n",
+		       __FILE__, __func__, __LINE__);
+		break;
+
+	case PMAC:
+		pr_err("PMAC IRQ not supported %s:%s:%d\n",
+		       __FILE__, __func__, __LINE__);
+		break;
+
+	case PCE:
+		printk("Switch Core PCE BLK %s:%s:%d\n"
+		       , __FILE__, __func__, __LINE__);
+		pce_irq_config(cdev, irq, IrqType);
+		break;
+
+	default:
+		pr_err("invalid Switch IRQ Blk %s:%s:%d\n",
+		       __FILE__, __func__, __LINE__);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	ret = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_irq);
+#endif
+	return ret;
+}
+
+void GSW_Irq_tasklet(unsigned long prvdata)
+{
+	gsw_pce_irq *pceirq = NULL;
+	gsw_call_back callback;
+	u32 p_isr = 0, e_isr = 0;
+	ethsw_api_dev_t *cdev = (ethsw_api_dev_t *)prvdata;
+	u32 pce_event = 0;
+
+	if (cdev) {
+
+		/*PCE IRQ*/
+		/* Read PCE ETHSW_ISR if anything is set ,
+			disable the global PCEINT IER
+			and Service PCE register IRQ list and Enable back
+			global PCEINT IER */
+		/*Global PCE ISR is read only,Hardware Status*/
+		gsw_r32(cdev, ETHSW_ISR_PCEINT_OFFSET,
+			ETHSW_ISR_PCEINT_SHIFT, ETHSW_ISR_PCEINT_SIZE,
+			&pce_event);
+
+		if (pce_event) {
+			/*Disable PCE Global IER*/
+			gsw_w32(cdev, ETHSW_IER_PCEIE_OFFSET,
+				ETHSW_IER_PCEIE_SHIFT, ETHSW_IER_PCEIE_SIZE, 0);
+
+			/*PCE : Service registered IRQ list*/
+			if (cdev->PceIrqList)
+				pceirq = cdev->PceIrqList->first_ptr;
+
+			while (pceirq != NULL) {
+				callback = NULL;
+
+				if (pceirq->Port_ier_enabled &&
+				    pceirq->Event_ier_enable) {
+					/*Check for Pending Interrupt*/
+					gsw_r32(cdev, PCE_ISR_0_OFFSET,
+						pceirq->P_ISR_MASK,
+						1, &p_isr);
+					gsw_r32(cdev, PCE_ISR_1_OFFSET,
+						pceirq->E_ISR_MASK,
+						1, &e_isr);
+
+					if (p_isr && e_isr) {
+						/*Clear only the Event
+						ISR (lhsc)-> cleared by writting 1.
+						PORT ISR cleared by Hardware (Read Only)*/
+						gsw_w32(cdev, PCE_ISR_1_OFFSET,
+							pceirq->P_ISR_MASK, 1, 1);
+
+						callback = pceirq->call_back;
+
+						/*Call back Service*/
+						if (callback)
+							callback(pceirq->param);
+					}
+				}
+
+				pceirq = pceirq->pNext;
+			}
+
+			/*Enable PCE Global IER*/
+			gsw_w32(cdev, ETHSW_IER_PCEIE_OFFSET,
+				ETHSW_IER_PCEIE_SHIFT, ETHSW_IER_PCEIE_SIZE, 1);
+		}
+
+
+		/*BM : Service registered IRQ list*/
+		/*yet to be done*/
+
+		/*SDMA : Service registered IRQ list*/
+		/*yet to be done*/
+
+		/*FDMA : Service registered IRQ list*/
+		/*yet to be done*/
+
+		/*PMAC : Service registered IRQ list*/
+		/*yet to be done*/
+
+	}
+}
+
+
+#ifdef __KERNEL__
+static irqreturn_t GSW_ISR(int irq, void *dev_id)
+{
+	struct core_ops *sw_ops;
+	ethsw_api_dev_t *gswdev;
+	u32 dev;
+
+	for (dev = 0; dev < LTQ_FLOW_DEV_MAX; dev++) {
+		sw_ops = NULL;
+		gswdev = NULL;
+		sw_ops = gsw_get_swcore_ops(dev);
+
+		if (sw_ops) {
+			gswdev = GSW_PDATA_GET(sw_ops);
+
+			if (gswdev) {
+				printk("\tSwitch IRQ tasklet for device %d\n", dev);
+				tasklet_schedule(&gswdev->gswip_tasklet);
+			}
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+#endif
+
+
+GSW_return_t GSW_Irq_init(void *cdev)
+{
+
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	/*GSWIP PCE BLK IRQ Pointer*/
+#ifdef __KERNEL__
+	gswdev->PceIrqList =
+		(struct pce_irq_linklist *)kmalloc(sizeof(struct pce_irq_linklist), GFP_KERNEL);
+#else
+	gswdev->PceIrqList =
+		(struct pce_irq_linklist *)malloc(sizeof(struct pce_irq_linklist));
+#endif
+
+	gswdev->PceIrqList->first_ptr = NULL;
+	gswdev->PceIrqList->last_ptr = NULL;
+
+	/*Enable PCE Global IER*/
+	gsw_w32(cdev, ETHSW_IER_PCEIE_OFFSET,
+		ETHSW_IER_PCEIE_SHIFT, ETHSW_IER_PCEIE_SIZE, 1);
+	/*Enable BM Global IER*/
+	/*yet to be done*/
+	/*Enable SDMA Global IER*/
+	/*yet to be done*/
+	/*Enable FDMA Global IER*/
+	/*yet to be done*/
+	/*Enable PMAC Global IER*/
+	/*yet to be done*/
+
+#ifdef __KERNEL__
+
+	ret = request_irq(gswdev->irq_num, GSW_ISR, 0, "gswip", NULL);
+
+	if (ret) {
+		pr_err("Switch irq request error %s:%s:%d", __FILE__, __func__, __LINE__);
+		return ret;
+	}
+
+	tasklet_init(&gswdev->gswip_tasklet,
+		     GSW_Irq_tasklet,
+		     (unsigned long)gswdev);
+#endif
+
+	return GSW_statusOk;
+}
+
+GSW_return_t GSW_Irq_deinit(void *cdev)
+{
+
+	gsw_pce_irq *irq = NULL;
+	gsw_pce_irq *free_irq = NULL;
+	ethsw_api_dev_t *gswdev = (ethsw_api_dev_t *)cdev;
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	/*Free PCE Irq list*/
+	if (gswdev->PceIrqList) {
+		irq = gswdev->PceIrqList->first_ptr;
+
+		while (irq != NULL) {
+			free_irq = irq;
+			irq = irq->pNext;
+#ifdef __KERNEL__
+			kfree(free_irq);
+#else
+			free(free_irq);
+#endif
+		}
+
+		/*Free PCE Irq blk*/
+#ifdef __KERNEL__
+		kfree(gswdev->PceIrqList);
+#else
+		free(gswdev->PceIrqList);
+#endif
+	}
+
+	return GSW_statusOk;
+}
+
+
+
+GSW_return_t GSW_Irq_register(void *cdev, GSW_Irq_Op_t *irq)
+{
+	return swcore_irq_config(cdev, irq, IRQ_REGISTER);
+}
+
+GSW_return_t GSW_Irq_unregister(void *cdev, GSW_Irq_Op_t *irq)
+{
+	return swcore_irq_config(cdev, irq, IRQ_UNREGISTER);
+}
+
+GSW_return_t GSW_Irq_enable(void *cdev, GSW_Irq_Op_t *irq)
+{
+	return swcore_irq_config(cdev, irq, IRQ_ENABLE);
+}
+
+GSW_return_t GSW_Irq_disable(void *cdev, GSW_Irq_Op_t *irq)
+{
+	return swcore_irq_config(cdev, irq, IRQ_DISABLE);
+}
+
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_ll_func.h b/drivers/net/ethernet/lantiq/switch-api/gsw_ll_func.h
new file mode 100644
index 000000000000..f42c937d0dfc
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_ll_func.h
@@ -0,0 +1,3452 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+#ifndef _LTQ_ETHSW_FLOW_LL_H_
+#define _LTQ_ETHSW_FLOW_LL_H_
+
+/* Group definitions for Doxygen */
+/** \defgroup FLOW_LL Ethernet Switch Application Kernel Interface
+    This chapter describes the entire interface to access and
+    configure the services of the switch module in OS kernel space.*/
+/*@{*/
+/** \defgroup FLOW_LL_BRIDGE Ethernet Bridging Functions
+    Ethernet bridging (or switching) is the basic task of the device. It
+    provides individual configurations per port and standard global
+    switch features.
+*/
+/** \defgroup FLOW_LL_CLASSUNIT Packet Classification Engine
+    Configures and controls the classification unit of the XWAY VRX200
+    and XWAY GRX200 Family hardware.
+*/
+/** \defgroup FLOW_LL_DEBUG Debug Features
+    XWAY VRX200 and XWAY GRX200 Family specific features for system
+    integration and debug sessions.
+*/
+/** \defgroup FLOW_LL_IRQ Interrupt Handling
+    Configure XWAY VRX200 and XWAY GRX200 Family specific hardware
+    support to generate interrupts
+    and read out the interrupt sources.
+*/
+/** \defgroup FLOW_LL_MULTICAST Multicast Functions
+    IGMP/MLD snooping configuration and support for IGMPv1, IGMPv2, IGMPv3,
+    MLDv1, and MLDv2.
+*/
+/** \defgroup FLOW_LL_OAM Operation, Administration, and Management Functions
+    This chapter summarizes the functions that are provided to monitor the
+    data traffic passing through the device.
+*/
+/** \defgroup FLOW_LL_QOS Quality of Service Functions
+    Switch and port configuration for Quality of Service (QoS).
+*/
+/** \defgroup FLOW_LL_VLAN VLAN Functions
+    This chapter describes VLAN bridging functionality. This includes support for
+    Customer VLAN Tags (CTAG VLAN) and also Service VLAN Tags (STAG VLAN/SVLAN).
+*/
+/** \defgroup GSWIP_ROUTE Operation, Administration, and Management Functions
+    This chapter summarizes the functions that are provided to monitor the
+    data traffic passing through the device.
+*/
+/*@}*/
+
+/* ------------------------------------------------------------------------- */
+/*                       Function Declaration                                */
+/* ------------------------------------------------------------------------- */
+
+/** \addtogroup FLOW_LL_BRIDGE */
+/*@{*/
+/**
+   This is the switch API low-level function for
+   the \ref GSW_8021X_EAPOL_RULE_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_8021X_EAPOL_Rule_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_8021X_EAPOL_RuleGet(void *cdev,
+				     GSW_8021X_EAPOL_Rule_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_8021X_EAPOL_RULE_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_8021X_EAPOL_Rule_t.
+
+	\remarks The function returns an error code in case an error occurs.
+			The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_8021X_EAPOL_RuleSet(void *cdev,
+				     GSW_8021X_EAPOL_Rule_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_8021X_PORT_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to a
+      802.1x port authorized state port
+      configuration \ref GSW_8021X_portCfg_t
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_8021X_PortCfgGet(void *cdev,
+				  GSW_8021X_portCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_8021X_PORT_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to a
+      802.1x port authorized state port
+      configuration \ref GSW_8021X_portCfg_t
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_8021X_PortCfgSet(void *cdev,
+				  GSW_8021X_portCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MAC_TABLE_CLEAR command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MAC_TableClear(void *cdev);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MAC_TABLE_ENTRY_ADD command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to a MAC table entry
+   \ref GSW_MAC_tableAdd_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MAC_TableEntryAdd(void *cdev,
+				   GSW_MAC_tableAdd_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MAC_TABLE_ENTRY_QUERY command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to a MAC table entry
+   \ref GSW_MAC_tableQuery_t structure that is filled out by the switch
+   implementation.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MAC_TableEntryQuery(void *cdev,
+				     GSW_MAC_tableQuery_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MAC_TABLE_ENTRY_READ command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to a MAC table entry
+   \ref GSW_MAC_tableRead_t structure that is filled out by the switch
+   implementation.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MAC_TableEntryRead(void *cdev,
+				    GSW_MAC_tableRead_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MAC_TABLE_ENTRY_REMOVE command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to a MAC table entry
+   \ref GSW_MAC_tableRemove_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MAC_TableEntryRemove(void *cdev,
+				      GSW_MAC_tableRemove_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_STP_BPDU_RULE_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_STP_BPDU_Rule_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_STP_BPDU_RuleGet(void *cdev,
+				  GSW_STP_BPDU_Rule_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_STP_BPDU_RULE_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_STP_BPDU_Rule_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_STP_BPDU_RuleSet(void *cdev,
+				  GSW_STP_BPDU_Rule_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_STP_PORT_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_STP_portCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_STP_PortCfgGet(void *cdev,
+				GSW_STP_portCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_STP_PORT_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_STP_portCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_STP_PortCfgSet(void *cdev,
+				GSW_STP_portCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_TRUNKING_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to a
+      configuration \ref GSW_trunkingCfg_t
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_TrunkingCfgGet(void *cdev,
+				GSW_trunkingCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_TRUNKING_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to a
+      configuration \ref GSW_trunkingCfg_t
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_TrunkingCfgSet(void *cdev,
+				GSW_trunkingCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_TRUNKING_PORT_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to a
+      configuration \ref GSW_trunkingPortCfg_t
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_TrunkingPortCfgGet(void *cdev,
+				    GSW_trunkingPortCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_TRUNKING_PORT_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to a
+      configuration \ref GSW_trunkingPortCfg_t
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_TrunkingPortCfgSet(void *cdev,
+				    GSW_trunkingPortCfg_t *parm);
+
+/*@}*/ /* FLOW_LL_BRIDGE */
+/** \addtogroup FLOW_LL_VLAN */
+/*@{*/
+/**
+   This is the switch API low-level function for
+   the \ref GSW_SVLAN_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_SVLAN_cfg_t
+      structure element.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_SVLAN_CfgGet(void *cdev,
+			      GSW_SVLAN_cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_SVLAN_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_SVLAN_cfg_t
+      structure element.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_SVLAN_CfgSet(void *cdev,
+			      GSW_SVLAN_cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_SVLAN_PORT_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an
+      \ref GSW_SVLAN_portCfg_t structure element. Based on the parameter
+      'nPortId', the switch API implementation fills out the remaining structure
+      elements.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_SVLAN_PortCfgGet(void *cdev,
+				  GSW_SVLAN_portCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_SVLAN_PORT_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_SVLAN_portCfg_t
+      structure element.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_SVLAN_PortCfgSet(void *cdev,
+				  GSW_SVLAN_portCfg_t *parm);
+/**
+   This is the switch API low-level function for
+   the \ref GSW_VLAN_MEMBER_INIT command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_VLAN_memberInit_t structure element.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_VLAN_Member_Init(void *cdev,
+				  GSW_VLAN_memberInit_t *parm);
+/**
+   This is the switch API low-level function for
+   the \ref GSW_VLAN_ID_CREATE command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_VLAN_IdCreate_t structure element.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_VLAN_IdCreate(void *cdev,
+			       GSW_VLAN_IdCreate_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_VLAN_ID_DELETE command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_VLAN_IdDelete_t structure element.
+
+	\remarks A VLAN ID can only be removed in case it was created by
+		\ref GSW_VLAN_ID_CREATE and is currently not assigned
+		to any Ethernet port (done using \ref GSW_VLAN_PORT_MEMBER_ADD).
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_VLAN_IdDelete(void *cdev,
+			       GSW_VLAN_IdDelete_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_VLAN_ID_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_VLAN_IdGet_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_VLAN_IdGet(void *cdev,
+			    GSW_VLAN_IdGet_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_VLAN_PORT_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an
+      \ref GSW_VLAN_portCfg_t structure element. Based on the parameter
+      'nPortId', the switch API implementation fills out the remaining structure
+      elements.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_VLAN_PortCfgGet(void *cdev,
+				 GSW_VLAN_portCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_VLAN_PORT_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_VLAN_portCfg_t
+      structure element.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_VLAN_PortCfgSet(void *cdev,
+				 GSW_VLAN_portCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_VLAN_PORT_MEMBER_ADD command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_VLAN_portMemberAdd_t structure element.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_VLAN_PortMemberAdd(void *cdev,
+				    GSW_VLAN_portMemberAdd_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_VLAN_PORT_MEMBER_READ command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_VLAN_portMemberRead_t structure element.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_VLAN_PortMemberRead(void *cdev,
+				     GSW_VLAN_portMemberRead_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_VLAN_PORT_MEMBER_REMOVE command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_VLAN_portMemberRemove_t structure element.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_VLAN_PortMemberRemove(void *cdev,
+				       GSW_VLAN_portMemberRemove_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_VLAN_RESERVED_ADD command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_VLAN_reserved_t structure element.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_VLAN_ReservedAdd(void *cdev,
+				  GSW_VLAN_reserved_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_VLAN_RESERVED_REMOVE command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_VLAN_reserved_t structure element.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_VLAN_ReservedRemove(void *cdev,
+				     GSW_VLAN_reserved_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PCE_EG_VLAN_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_PCE_EgVLAN_Cfg_t structure element.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PCE_EG_VLAN_CfgSet(void *cdev,
+				    GSW_PCE_EgVLAN_Cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PCE_EG_VLAN_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_PCE_EgVLAN_Cfg_t structure element.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PCE_EG_VLAN_CfgGet(void *cdev,
+				    GSW_PCE_EgVLAN_Cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PCE_EG_VLAN_ENTRY_WRITE command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_PCE_EgVLAN_Entry_t structure element.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PCE_EG_VLAN_EntryWrite(void *cdev,
+					GSW_PCE_EgVLAN_Entry_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PCE_EG_VLAN_ENTRY_READ command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_PCE_EgVLAN_Entry_t structure element.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PCE_EG_VLAN_EntryRead(void *cdev,
+				       GSW_PCE_EgVLAN_Entry_t *parm);
+
+/*@}*/ /* FLOW_LL_VLAN */
+/** \addtogroup FLOW_LL_QOS */
+/*@{*/
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_CLASS_DSCP_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the DSCP mapping parameter
+		\ref GSW_QoS_ClassDSCP_Cfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_ClassDSCP_Get(void *cdev,
+				   GSW_QoS_ClassDSCP_Cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_CLASS_DSCP_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the DSCP mapping parameter
+   \ref GSW_QoS_ClassDSCP_Cfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_ClassDSCP_Set(void *cdev,
+				   GSW_QoS_ClassDSCP_Cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_CLASS_PCP_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the PCP priority mapping parameter
+   \ref GSW_QoS_ClassPCP_Cfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_ClassPCP_Get(void *cdev,
+				  GSW_QoS_ClassPCP_Cfg_t *parm);
+
+/**
+	This is the switch API low-level function for
+	the \ref GSW_QOS_CLASS_PCP_SET command.
+
+	\param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the PCP priority mapping parameter
+   \ref GSW_QoS_ClassPCP_Cfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_ClassPCP_Set(void *cdev,
+				  GSW_QoS_ClassPCP_Cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_DSCP_CLASS_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the QoS filter parameters
+   \ref GSW_QoS_DSCP_ClassCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_DSCP_ClassGet(void *cdev,
+				   GSW_QoS_DSCP_ClassCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_DSCP_CLASS_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the QoS filter parameters
+   \ref GSW_QoS_DSCP_ClassCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_DSCP_ClassSet(void *cdev,
+				   GSW_QoS_DSCP_ClassCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the QoS
+   DSCP drop precedence parameters
+   \ref GSW_QoS_DSCP_DropPrecedenceCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_DSCP_DropPrecedenceCfgGet(void *cdev,
+		GSW_QoS_DSCP_DropPrecedenceCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the QoS
+   DSCP drop precedence parameters
+   \ref GSW_QoS_DSCP_DropPrecedenceCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_DSCP_DropPrecedenceCfgSet(void *cdev,
+		GSW_QoS_DSCP_DropPrecedenceCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_FLOWCTRL_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_FlowCtrlCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_FlowctrlCfgGet(void *cdev,
+				    GSW_QoS_FlowCtrlCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_FLOWCTRL_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_FlowCtrlCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_FlowctrlCfgSet(void *cdev,
+				    GSW_QoS_FlowCtrlCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_FLOWCTRL_PORT_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_FlowCtrlPortCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_FlowctrlPortCfgGet(void *cdev,
+					GSW_QoS_FlowCtrlPortCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_FLOWCTRL_PORT_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_FlowCtrlPortCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_FlowctrlPortCfgSet(void *cdev,
+					GSW_QoS_FlowCtrlPortCfg_t *parm);
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_METER_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_meterCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_MeterCfgGet(void *cdev,
+				 GSW_QoS_meterCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_METER_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_meterCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_MeterCfgSet(void *cdev,
+				 GSW_QoS_meterCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_METER_PORT_ASSIGN command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_meterPort_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_MeterPortAssign(void *cdev,
+				     GSW_QoS_meterPort_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_METER_PORT_DEASSIGN command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_meterPort_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_MeterPortDeassign(void *cdev,
+				       GSW_QoS_meterPort_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_METER_PORT_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_meterPortGet_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_MeterPortGet(void *cdev,
+				  GSW_QoS_meterPortGet_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_PCP_CLASS_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the QoS filter parameters
+   \ref GSW_QoS_PCP_ClassCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_PCP_ClassGet(void *cdev,
+				  GSW_QoS_PCP_ClassCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_PCP_CLASS_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the QoS filter parameters
+   \ref GSW_QoS_PCP_ClassCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_PCP_ClassSet(void *cdev,
+				  GSW_QoS_PCP_ClassCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_PORT_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to a
+      QOS port priority control configuration \ref GSW_QoS_portCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_PortCfgGet(void *cdev,
+				GSW_QoS_portCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_PORT_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to a
+      QOS port priority control configuration \ref GSW_QoS_portCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_PortCfgSet(void *cdev,
+				GSW_QoS_portCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_PORT_REMARKING_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the QoS filter parameters
+   \ref GSW_QoS_portRemarkingCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_PortRemarkingCfgGet(void *cdev,
+		GSW_QoS_portRemarkingCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_PORT_REMARKING_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the remarking configuration
+   \ref GSW_QoS_portRemarkingCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_PortRemarkingCfgSet(void *cdev,
+		GSW_QoS_portRemarkingCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_QueueBufferReserveCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_QueueBufferReserveCfgGet(void *cdev,
+		GSW_QoS_QueueBufferReserveCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_QueueBufferReserveCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_QueueBufferReserveCfgSet(void *cdev,
+		GSW_QoS_QueueBufferReserveCfg_t *parm);
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_QUEUE_PORT_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_queuePort_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_QueuePortGet(void *cdev,
+				  GSW_QoS_queuePort_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_QUEUE_PORT_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_queuePort_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_QueuePortSet(void *cdev,
+				  GSW_QoS_queuePort_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_SVLAN_CLASS_PCP_PORT_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the PCP priority mapping parameter
+   \ref GSW_QoS_SVLAN_ClassPCP_PortCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_SVLAN_ClassPCP_PortGet(void *cdev,
+		GSW_QoS_SVLAN_ClassPCP_PortCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_SVLAN_CLASS_PCP_PORT_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the PCP priority mapping parameter
+   \ref GSW_QoS_SVLAN_ClassPCP_PortCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_SVLAN_ClassPCP_PortSet(void *cdev,
+		GSW_QoS_SVLAN_ClassPCP_PortCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_SVLAN_PCP_CLASS_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the QoS filter parameters
+   \ref GSW_QoS_SVLAN_PCP_ClassCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_SVLAN_PCP_ClassGet(void *cdev,
+					GSW_QoS_SVLAN_PCP_ClassCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_SVLAN_PCP_CLASS_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the QoS filter parameters
+   \ref GSW_QoS_SVLAN_PCP_ClassCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_SVLAN_PCP_ClassSet(void *cdev,
+					GSW_QoS_SVLAN_PCP_ClassCfg_t *parm);
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_SCHEDULER_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_schedulerCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_SchedulerCfgGet(void *cdev,
+				     GSW_QoS_schedulerCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_SCHEDULER_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_schedulerCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_SchedulerCfgSet(void *cdev,
+				     GSW_QoS_schedulerCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_SHAPER_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_ShaperCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_ShaperCfgGet(void *cdev,
+				  GSW_QoS_ShaperCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_SHAPER_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_ShaperCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_ShaperCfgSet(void *cdev,
+				  GSW_QoS_ShaperCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_SHAPER_QUEUE_ASSIGN command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_ShaperQueue_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_ShaperQueueAssign(void *cdev,
+				       GSW_QoS_ShaperQueue_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_SHAPER_QUEUE_DEASSIGN command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_ShaperQueue_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_ShaperQueueDeassign(void *cdev,
+		GSW_QoS_ShaperQueue_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_SHAPER_QUEUE_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_ShaperQueueGet_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_ShaperQueueGet(void *cdev,
+				    GSW_QoS_ShaperQueueGet_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_STORM_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_stormCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_StormCfgGet(void *cdev, GSW_QoS_stormCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_STORM_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_stormCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_StormCfgSet(void *cdev, GSW_QoS_stormCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_WRED_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_WRED_Cfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_WredCfgGet(void *cdev, GSW_QoS_WRED_Cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_WRED_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_WRED_Cfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_WredCfgSet(void *cdev, GSW_QoS_WRED_Cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_WRED_PORT_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_WRED_PortCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_WredPortCfgGet(void *cdev,
+				    GSW_QoS_WRED_PortCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_WRED_PORT_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_WRED_PortCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_WredPortCfgSet(void *cdev,
+				    GSW_QoS_WRED_PortCfg_t *parm);
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_WRED_QUEUE_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_WRED_QueueCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_WredQueueCfgGet(void *cdev,
+				     GSW_QoS_WRED_QueueCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_WRED_QUEUE_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the parameters
+   structure \ref GSW_QoS_WRED_QueueCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_WredQueueCfgSet(void *cdev,
+				     GSW_QoS_WRED_QueueCfg_t *parm);
+
+/*@}*/ /* FLOW_LL_QOS */
+/** \addtogroup FLOW_LL_MULTICAST */
+/*@{*/
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MULTICAST_ROUTER_PORT_ADD command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_multicastRouter_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MulticastRouterPortAdd(void *cdev,
+					GSW_multicastRouter_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MULTICAST_ROUTER_PORT_READ command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_multicastRouterRead_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+   (e.g. Ethernet port parameter out of range)
+*/
+GSW_return_t GSW_MulticastRouterPortRead(void *cdev,
+		GSW_multicastRouterRead_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MULTICAST_ROUTER_PORT_REMOVE command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_multicastRouter_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+   (e.g. Ethernet port parameter out of range)
+*/
+GSW_return_t GSW_MulticastRouterPortRemove(void *cdev,
+		GSW_multicastRouter_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MULTICAST_SNOOP_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the
+   multicast configuration \ref GSW_multicastSnoopCfg_t.
+
+   \remarks IGMP/MLD snooping is disabled when
+   'eIGMP_Mode = GSW_MULTICAST_SNOOP_MODE_SNOOPFORWARD'.
+   Then all other structure parameters are unused.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MulticastSnoopCfgGet(void *cdev,
+				      GSW_multicastSnoopCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MULTICAST_SNOOP_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to the
+   multicast configuration \ref GSW_multicastSnoopCfg_t.
+
+   \remarks IGMP/MLD snooping is disabled when
+   'eIGMP_Mode = GSW_MULTICAST_SNOOP_MODE_SNOOPFORWARD'.
+   Then all other structure parameters are unused.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MulticastSnoopCfgSet(void *cdev,
+				      GSW_multicastSnoopCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MULTICAST_TABLE_ENTRY_ADD command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer
+      to \ref GSW_multicastTable_t.
+
+	\remarks The Source IP parameter is ignored in case IGMPv3 support is
+		not enabled in the hardware.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MulticastTableEntryAdd(void *cdev,
+					GSW_multicastTable_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MULTICAST_TABLE_ENTRY_READ command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer
+      to \ref GSW_multicastTableRead_t.
+
+	\remarks The 'bInitial' parameter is reset during the read operation.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MulticastTableEntryRead(void *cdev,
+		GSW_multicastTableRead_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MULTICAST_TABLE_ENTRY_REMOVE command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer
+      to \ref GSW_multicastTable_t.
+
+	\remarks The Source IP parameter is ignored in case
+	IGMPv3 support is not enabled in the hardware.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MulticastTableEntryRemove(void *cdev,
+		GSW_multicastTable_t *parm);
+
+/*@}*/ /* FLOW_LL_MULTICAST */
+/** \addtogroup FLOW_LL_OAM */
+/*@{*/
+/**
+   This is the switch API low-level function for
+   the \ref GSW_CPU_PORT_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this specialinstance of the device.
+   \param parm Pointer to
+      an \ref GSW_CPU_PortCfg_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_CPU_PortCfgGet(void *cdev, GSW_CPU_PortCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_CPU_PORT_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_CPU_PortCfg_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_CPU_PortCfgSet(void *cdev, GSW_CPU_PortCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_CPU_PORT_EXTEND_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_CPU_PortExtendCfg_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+GSW_return_t GSW_CPU_PortExtendCfgGet(void *cdev,
+				      GSW_CPU_PortExtendCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_CPU_PORT_EXTEND_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_CPU_PortExtendCfg_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_CPU_PortExtendCfgSet(void *cdev,
+				      GSW_CPU_PortExtendCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_CAP_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to pre-allocated capability
+      list structure \ref GSW_cap_t.
+      The switch API implementation fills out the structure with the supported
+      features, based on the provided 'nCapType' parameter.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+GSW_return_t GSW_CapGet(void *cdev, GSW_cap_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_cfg_t structure.
+      The structure is filled out by the switch implementation.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_CfgGet(void *cdev, GSW_cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_cfg_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_CfgSet(void *cdev, GSW_cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_DISABLE command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_Disable(void *cdev);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_ENABLE command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_Enable(void *cdev);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_HW_INIT command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to pre-allocated initialization structure
+   \ref GSW_HW_Init_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_HW_Init(void *cdev, GSW_HW_Init_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MDIO_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_MDIO_cfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MDIO_CfgGet(void *cdev, GSW_MDIO_cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MDIO_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_MDIO_cfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MDIO_CfgSet(void *cdev, GSW_MDIO_cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MDIO_DATA_READ command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_MDIO_data_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MDIO_DataRead(void *cdev, GSW_MDIO_data_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MDIO_DATA_WRITE command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_MDIO_data_t.
+
+	\remarks The function returns an error code in case an error occurs.
+			The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+GSW_return_t GSW_MDIO_DataWrite(void *cdev, GSW_MDIO_data_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MMD_DATA_READ command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_MMD_data_t.
+
+	\remarks The function returns an error code in case an error occurs.
+			The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MmdDataRead(void *cdev, GSW_MMD_data_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MMD_DATA_WRITE command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_MMD_data_t.
+
+	\remarks The function returns an error code in case an error occurs.
+			The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MmdDataWrite(void *cdev, GSW_MMD_data_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the GSW_XGMAC_CFG command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_MAC_cfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+			The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_XgmacCfg(void *cdev, GSW_MAC_cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the GSW_GSWSS_CFG command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_MAC_cfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+			The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_GswssCfg(void *cdev, GSW_MAC_cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the GSW_LMAC_CFG command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_MAC_cfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+			The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_LmacCfg(void *cdev, GSW_MAC_cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the GSW_MACSEC_CFG command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_MAC_cfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+			The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MacsecCfg(void *cdev, GSW_MAC_cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the GSW_DUMP_MEM command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_debug_t.
+
+	\remarks The function returns an error code in case an error occurs.
+			The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_DumpTable(void *cdev, GSW_table_t *parm);
+
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MONITOR_PORT_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_monitorPortCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MonitorPortCfgGet(void *cdev, GSW_monitorPortCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_MONITOR_PORT_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_monitorPortCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_MonitorPortCfgSet(void *cdev, GSW_monitorPortCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PORT_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to a port configuration
+   \ref GSW_portCfg_t structure to fill out by the driver.
+   The parameter 'nPortId' tells the driver which port parameter is requested.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PortCfgGet(void *cdev, GSW_portCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PORT_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_portCfg_t structure
+   to configure the switch port hardware.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PortCfgSet(void *cdev, GSW_portCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PORT_LINK_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_portLinkCfg_t structure to read out the port status.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PortLinkCfgGet(void *cdev, GSW_portLinkCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PORT_LINK_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_portLinkCfg_t structure to set the port configuration.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PortLinkCfgSet(void *cdev, GSW_portLinkCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PORT_PHY_ADDR_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_portPHY_Addr_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PortPHY_AddrGet(void *cdev, GSW_portPHY_Addr_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PORT_PHY_QUERY command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_portPHY_Query_t structure to set the port configuration.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PortPHY_Query(void *cdev, GSW_portPHY_Query_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PORT_RGMII_CLK_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_portRGMII_ClkCfg_t structure to set the port configuration.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PortRGMII_ClkCfgGet(void *cdev, GSW_portRGMII_ClkCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PORT_RGMII_CLK_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_portRGMII_ClkCfg_t structure to set the port configuration.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PortRGMII_ClkCfgSet(void *cdev, GSW_portRGMII_ClkCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PORT_REDIRECT_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_portRedirectCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+	\remarks Not all hardware platforms support this feature. The function
+		returns an error if this feature is not supported.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PortRedirectGet(void *cdev, GSW_portRedirectCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PORT_REDIRECT_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_portRedirectCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+	\remarks Not all hardware platforms support this feature. The function
+		returns an error if this feature is not supported.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PortRedirectSet(void *cdev, GSW_portRedirectCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_RMON_CLEAR command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm  Pointer to a pre-allocated
+   \ref GSW_RMON_clear_t structure. The structure element 'nPortId' is
+   an input parameter stating on which port to clear all RMON counters.
+
+   \remarks The function returns an error in case the given 'nPortId' is
+   out of range.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_RMON_Clear(void *cdev, GSW_RMON_clear_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_RMON_TFLOW_CLEAR command.
+
+   \param cdev This parameter is a pointer to the device context which contains
+   all information related to this special instance of the device.
+
+   \param parm  Pointer to a pre-allocated \ref GSW_RMON_extendGet_t structure.
+   The structure element 'nPortId' is an input parameter stating on which
+   TFLOW's index to clear RMON counters.
+   By default it clears at index 0.
+
+   \remarks The function returns an error in case the given 'nPortId' is
+   out of range.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_RmonTflowClear(void *cdev, GSW_RMON_flowGet_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_TFLOW_COUNT_MODE_SET command.
+
+   \param cdev This parameter is a pointer to the device context which contains
+   all information related to this special instance of the device.
+
+   \param parm  Pointer to a pre-allocated \ref GSW_TflowCmodeConf_t structure.
+   The structure element 'eCountType' is the optional input parameter
+   stating on to which PCE counting mode config to set.
+   By default it sets all PCE Rx/Tx/Bp-Tx configs to same value.
+
+   \remarks The function return an error as it validates all input params except
+   'nPortId' and returns an error if fails.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_TflowCountModeSet(void *cdev, GSW_TflowCmodeConf_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_TFLOW_COUNT_MODE_GET command.
+
+   \param cdev This parameter is a pointer to the device context which contains
+   all information related to this special instance of the device.
+   \param parm  Pointer to a pre-allocated \ref GSW_TflowCmodeConf_t structure.
+   The structure element 'eCountType' is the only and optional input parameter
+   stating on to which PCE counting mode config to get.
+   By default it gets PCE Rx config register.
+
+   \remarks The function does validate input params.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_TflowCountModeGet(void *cdev, GSW_TflowCmodeConf_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_RMON_PORT_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm  Pointer to pre-allocated
+   \ref GSW_RMON_Port_cnt_t structure. The structure element 'nPortId' is
+   an input parameter that describes from which port to read the RMON counter.
+   All remaining structure elements are filled with the counter values.
+
+   \remarks The function returns an error in case the given 'nPortId' is
+   out of range.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_RMON_Port_Get(void *cdev, GSW_RMON_Port_cnt_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_VERSION_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm* The parameter points to a
+   \ref GSW_version_t structure.
+
+   \return Returns value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+GSW_return_t GSW_VersionGet(void *cdev, GSW_version_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_WOL_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_WoL_Cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_WoL_CfgGet(void *cdev, GSW_WoL_Cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_WOL_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_WoL_Cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_WoL_CfgSet(void *cdev, GSW_WoL_Cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_WOL_PORT_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_WoL_PortCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_WoL_PortCfgGet(void *cdev, GSW_WoL_PortCfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_WOL_PORT_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_WoL_PortCfg_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_WoL_PortCfgSet(void *cdev, GSW_WoL_PortCfg_t *parm);
+
+/*@}*/ /* FLOW_LL_OAM */
+/** \addtogroup FLOW_LL_DEBUG */
+/*@{*/
+/**
+   This is the switch API low-level function for
+   the \ref GSW_REGISTER_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_register_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_RegisterGet(void *cdev, GSW_register_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_REGISTER_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_register_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_RegisterSet(void *cdev, GSW_register_t *parm);
+
+/*@}*/ /* FLOW_LL_DEBUG */
+/** \addtogroup FLOW_LL_IRQ */
+/*@{*/
+/**
+   This is the switch API low-level function for
+   the \ref GSW_IRQ_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_irq_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+GSW_return_t GSW_IrqGet(void *cdev, GSW_irq_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_IRQ_MASK_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_irq_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+GSW_return_t GSW_IrqMaskGet(void *cdev, GSW_irq_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_IRQ_MASK_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_irq_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+GSW_return_t GSW_IrqMaskSet(void *cdev, GSW_irq_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_IRQ_STATUS_CLEAR command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_irq_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+GSW_return_t GSW_IrqStatusClear(void *cdev, GSW_irq_t *parm);
+
+/*@}*/ /* FLOW_LL_IRQ */
+/** \addtogroup FLOW_LL_CLASSUNIT */
+/*@{*/
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PCE_RULE_DELETE command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_PCE_ruleDelete_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PceRuleDelete(void *cdev, GSW_PCE_ruleDelete_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PCE_RULE_READ command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_PCE_rule_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PceRuleRead(void *cdev, GSW_PCE_rule_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PCE_RULE_WRITE command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to \ref GSW_PCE_rule_t.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PceRuleWrite(void *cdev, GSW_PCE_rule_t *parm);
+
+/*@}*/ /* FLOW_LL_CLASSUNIT */
+/** \addtogroup FLOW_LL_OAM */
+/*@{*/
+/**
+   This is the switch API low-level function for
+   the \ref GSW_RMON_EXTEND_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm  Pointer to a pre-allocated
+   \ref GSW_RMON_extendGet_t structure. The structure element 'nPortId' is
+   an input parameter that describes from which port to read the RMON counter.
+   All remaining structure elements are filled with the counter values.
+   The counter assignment needs to be done during the flow definition,
+   for example in \ref GSW_PCE_RULE_WRITE.
+
+	\remarks The function returns an error in case the given 'nPortId' is
+		out of range.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_RMON_ExtendGet(void *cdev, GSW_RMON_extendGet_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_RMON_FLOW_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm  Pointer to a pre-allocated
+   \ref GSW_RMON_flowGet_t structure. The structure element 'nIndex' is
+   an input parameter that describes index of RMON counter to read.
+   All remaining structure elements are filled with the counter values.
+   The counter assignment needs to be done during the flow definition,
+   for example in \ref GSW_PCE_RULE_WRITE.
+
+	\remarks The function returns an error in case the given 'nPortId' is
+		out of range.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_RMON_FlowGet(void *cdev, GSW_RMON_flowGet_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_RESET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_reset_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+   \remarks Not supported for all devices
+*/
+GSW_return_t GSW_Reset(void *cdev, GSW_reset_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_TIMESTAMP_PORT_READ command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to
+      an \ref GSW_TIMESTAMP_PortRead_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_TimestampPortRead(void *cdev, GSW_TIMESTAMP_PortRead_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_TIMESTAMP_TIMER_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_TIMESTAMP_Timer_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_TimestampTimerGet(void *cdev, GSW_TIMESTAMP_Timer_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_TIMESTAMP_TIMER_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_TIMESTAMP_Timer_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_TimestampTimerSet(void *cdev, GSW_TIMESTAMP_Timer_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_QOS_METER_ACT command (GSWIP-3.0 only).
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_QoS_mtrAction_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_QoS_Meter_Act(void *cdev, GSW_QoS_mtrAction_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_RMON_MODE_SET command (GSWIP-3.0 only)
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_RMON_mode_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_RMON_Mode_Set(void *cdev, GSW_RMON_mode_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_RMON_METER_GET command (GSWIP-3.0 only)
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_RMON_Meter_cnt_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_RMON_Meter_Get(void *cdev, GSW_RMON_Meter_cnt_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_RMON_REDIRECT_GET command (GSWIP-3.0 only)
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_RMON_Redirect_cnt_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_RMON_Redirect_Get(void *cdev, GSW_RMON_Redirect_cnt_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_RMON_IF_GET command (GSWIP-3.0 only)
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_RMON_If_cnt_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_RMON_If_Get(void *cdev, GSW_RMON_If_cnt_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_RMON_ROUTE_GET command (GSWIP-3.0 only)
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_RMON_Route_cnt_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_RMON_Route_Get(void *cdev, GSW_RMON_Route_cnt_t *parm);
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PMAC_IG_COUNT_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_PMAC_Ig_Cnt_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PMAC_CountGet(void *cdev, GSW_PMAC_Cnt_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PMAC_EG_COUNT_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_PMAC_Eg_Cnt_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+/*GSW_return_t GSW_PMAC_EG_CountGet(void *cdev, GSW_PMAC_Eg_Cnt_t *parm);*/
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PMAC_BM_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_PMAC_BM_Cfg_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PMAC_BM_CfgSet(void *cdev, GSW_PMAC_BM_Cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PMAC_BM_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_PMAC_BM_Cfg_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PMAC_BM_CfgGet(void *cdev, GSW_PMAC_BM_Cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PMAC_IG_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_PMAC_Ig_Cfg_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PMAC_IG_CfgSet(void *cdev, GSW_PMAC_Ig_Cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PMAC_EG_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_PMAC_Ig_Cfg_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PMAC_IG_CfgGet(void *cdev, GSW_PMAC_Ig_Cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PMAC_EG_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_PMAC_Eg_Cfg_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PMAC_EG_CfgSet(void *cdev, GSW_PMAC_Eg_Cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PMAC_EG_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_PMAC_Eg_Cfg_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PMAC_EG_CfgGet(void *cdev, GSW_PMAC_Eg_Cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PMAC_GLBL_CFG_SET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_PMAC_Glbl_Cfg_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PMAC_GLBL_CfgSet(void *cdev, GSW_PMAC_Glbl_Cfg_t *parm);
+
+/**
+   This is the switch API low-level function for
+   the \ref GSW_PMAC_GLBL_CFG_GET command.
+
+   \param cdev This parameter is a pointer to the device context
+   which contains all information related to this special
+   instance of the device.
+   \param parm Pointer to an \ref GSW_PMAC_Glbl_Cfg_t structure.
+
+	\remarks The function returns an error code in case an error occurs.
+		The error code is described in \ref GSW_status_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+GSW_return_t GSW_PMAC_GLBL_CfgGet(void *cdev, GSW_PMAC_Glbl_Cfg_t *parm);
+
+
+/*GSWIP 3.1 New API*/
+GSW_return_t GSW_QOS_ColorMarkingTableSet(void *cdev, GSW_QoS_colorMarkingEntry_t *parm);
+GSW_return_t GSW_QOS_ColorMarkingTableGet(void *cdev, GSW_QoS_colorMarkingEntry_t *parm);
+GSW_return_t GSW_QOS_ColorReMarkingTableSet(void *cdev, GSW_QoS_colorRemarkingEntry_t *parm);
+GSW_return_t GSW_QOS_ColorReMarkingTableGet(void *cdev, GSW_QoS_colorRemarkingEntry_t *parm);
+GSW_return_t GSW_QOS_Dscp2PcpTableSet(void *cdev, GSW_DSCP2PCP_map_t *parm) ;
+GSW_return_t GSW_QOS_Dscp2PcpTableGet(void *cdev, GSW_DSCP2PCP_map_t *parm);
+GSW_return_t GSW_QOS_PmapperTableSet(void *cdev, GSW_PMAPPER_t *parm);
+GSW_return_t GSW_QOS_PmapperTableGet(void *cdev, GSW_PMAPPER_t *parm);
+GSW_return_t GSW_QOS_MeterAlloc(void *cdev, GSW_QoS_meterCfg_t *parm);
+GSW_return_t GSW_QOS_MeterFree(void *cdev, GSW_QoS_meterCfg_t *parm);
+
+GSW_return_t GSW_ExtendedVlanAlloc(void *cdev, GSW_EXTENDEDVLAN_alloc_t *parm);
+GSW_return_t GSW_ExtendedVlanSet(void *cdev, GSW_EXTENDEDVLAN_config_t *parm);
+GSW_return_t GSW_ExtendedVlanGet(void *cdev, GSW_EXTENDEDVLAN_config_t *parm);
+GSW_return_t GSW_ExtendedVlanFree(void *cdev, GSW_EXTENDEDVLAN_alloc_t *parm);
+
+GSW_return_t GSW_VlanFilterAlloc(void *cdev, GSW_VLANFILTER_alloc_t *param);
+GSW_return_t GSW_VlanFilterSet(void *cdev, GSW_VLANFILTER_config_t *parm);
+GSW_return_t GSW_VlanFilterGet(void *cdev, GSW_VLANFILTER_config_t *parm);
+GSW_return_t GSW_VlanFilterFree(void *cdev, GSW_VLANFILTER_alloc_t *parm);
+
+GSW_return_t GSW_BridgeAlloc(void *cdev, GSW_BRIDGE_alloc_t *param);
+GSW_return_t GSW_BridgeConfigSet(void *cdev, GSW_BRIDGE_config_t *parm);
+GSW_return_t GSW_BridgeConfigGet(void *cdev, GSW_BRIDGE_config_t *parm);
+GSW_return_t GSW_BridgeFree(void *cdev, GSW_BRIDGE_alloc_t *parm);
+
+GSW_return_t GSW_BridgePortAlloc(void *cdev, GSW_BRIDGE_portAlloc_t *param);
+GSW_return_t GSW_BridgePortConfigSet(void *cdev, GSW_BRIDGE_portConfig_t *parm);
+GSW_return_t GSW_BridgePortConfigGet(void *cdev, GSW_BRIDGE_portConfig_t *parm);
+GSW_return_t GSW_BridgePortFree(void *cdev, GSW_BRIDGE_portAlloc_t *parm);
+
+GSW_return_t GSW_CTP_PortAssignmentSet(void *cdev, GSW_CTP_portAssignment_t *parm);
+GSW_return_t GSW_CTP_PortAssignmentGet(void *cdev, GSW_CTP_portAssignment_t *parm);
+GSW_return_t GSW_CTP_PortAssignmentAlloc(void *cdev, GSW_CTP_portAssignment_t *parm);
+GSW_return_t GSW_CTP_PortAssignmentFree(void *cdev, GSW_CTP_portAssignment_t *parm);
+GSW_return_t GSW_CtpPortConfigSet(void *cdev, GSW_CTP_portConfig_t *parm);
+GSW_return_t GSW_CtpPortConfigGet(void *cdev, GSW_CTP_portConfig_t *parm);
+GSW_return_t GSW_CtpPortConfigReset(void *cdev, GSW_CTP_portConfig_t *parm);
+
+GSW_return_t GSW_DefaultMacFilterSet(void *cdev, GSW_MACFILTER_default_t *parm);
+GSW_return_t GSW_DefaultMacFilterGet(void *cdev, GSW_MACFILTER_default_t *parm);
+
+GSW_return_t GSW_Debug_CtpTableStatus(void *cdev, GSW_debug_t *parm);
+GSW_return_t GSW_Debug_BrgPortTableStatus(void *cdev, GSW_debug_t *parm);
+GSW_return_t GSW_Debug_BrgTableStatus(void *cdev, GSW_debug_t *parm);
+GSW_return_t GSW_Debug_ExvlanTableStatus(void *cdev, GSW_debug_t *parm);
+GSW_return_t GSW_Debug_VlanFilterTableStatus(void *cdev, GSW_debug_t *parm);
+GSW_return_t GSW_Debug_MeterTableStatus(void *cdev, GSW_debug_t *parm);
+GSW_return_t GSW_Debug_Dscp2PcpTableStatus(void *cdev, GSW_debug_t *parm);
+GSW_return_t GSW_Debug_PmapperTableStatus(void *cdev, GSW_debug_t *parm);
+GSW_return_t GSW_Debug_PmacBpTable(void *cdev, GSW_debug_t *parm);
+GSW_return_t GSW_Debug_PmacEgTable(void *cdev, GSW_debug_t *parm);
+GSW_return_t GSW_Debug_PmacIgTable(void *cdev, GSW_debug_t *parm);
+GSW_return_t GSW_Debug_PceBypassTable(void *cdev, GSW_debug_t *parm);
+GSW_return_t GSW_Debug_PceQTable(void *cdev, GSW_debug_t *parm);
+GSW_return_t GSW_Debug_GetLpStatistics(void *cdev, GSW_debug_t *parm);
+GSW_return_t GSW_Debug_GetCtpStatistics(void *cdev, GSW_debug_t *parm);
+GSW_return_t  GSW_Debug_PrintPceIrqList(void *cdev);
+GSW_return_t GSW_Debug_RMON_Port_Get(void *cdev, GSW_Debug_RMON_Port_cnt_t *parm);
+
+
+
+GSW_return_t GSW_Irq_register(void *cdev, GSW_Irq_Op_t *irq);
+GSW_return_t GSW_Irq_unregister(void *cdev, GSW_Irq_Op_t *irq);
+GSW_return_t GSW_Irq_enable(void *cdev, GSW_Irq_Op_t *irq);
+GSW_return_t GSW_Irq_disable(void *cdev, GSW_Irq_Op_t *irq);
+
+GSW_return_t GSW_Irq_init(void *cdev);
+GSW_return_t GSW_Irq_deinit(void *cdev);
+
+void GSW_Irq_tasklet(unsigned long prvdata);
+
+
+
+
+
+
+/*@}*/ /* FLOW_LL_OAM */
+#ifdef __KERNEL__
+/** \addtogroup GSWIP_ROUTE */
+/*@{*/
+/**
+   \brief This function creates a Routing Session entry
+   in the Routing-Session table.
+   The pattern part describes the five tuple serving
+   as input key on which hash computation should be
+   done on an incoming packet to which the dedicated
+   actions should be applied.
+   A rule can be deleted using the command
+   \ref GSW_ROUTE_SessionEntryDel or read using
+   the command \ref GSW_ROUTE_SessionEntryRead.
+   \param[in] cdev device context
+   \param[in, out] pRtEntry Pointer to Routing Entry
+   structure \ref GSW_ROUTE_Entry_t. The nHashVal is optional
+   and can be supplied (-1). The nPrio field is carrying the
+   priority information - 1 (Priority session), 0  (Normal session).
+   Upon return of API, nHashVal and nRtIndex carries back
+   computed hash value and Index location. In case of swap
+   of an existent session by a high priority new session,
+   the existing session that got removed from acceleration
+   is returned back in routeEntry struct member. The swap
+   done is informed through nFag member carrying special value(1).
+   \return Return value as follows:
+   - Routing session index number >=0 : if successful
+   - An error code < 0 in case an error occurs. There has
+   to be detailed error codes covering the maximum reasons :
+   - E.g. Collision List is full, RT_Table full, PPPoE_table
+   full, MTU table full etc.
+*/
+int GSW_ROUTE_SessionEntryAdd(void *cdev, GSW_ROUTE_Entry_t *pRtEntry);
+
+/**
+   \brief This function deletes a Routing Session
+   entry at specififed index in the Routing-Session table.
+   A rule can be created using the command
+   \ref GSW_ROUTE_SessionEntryAdd
+   \param[in] cdev device context
+   \param[in] pRtEntry Routing Session Entry carrying
+   mandatory nRtIndex value.
+   \return Return value as follows:
+   - GSW_SUCCESS : if successful
+   - An error code < 0 in case an error occurs.
+*/
+int GSW_ROUTE_SessionEntryDel(void *cdev, GSW_ROUTE_Entry_t *pRtEntry);
+
+/**
+   \brief This function reads a session entry in the
+   Routing session table at an specified index. The index
+   must be valid entry of the routing index table.
+   \param[in] cdev device context.
+   \param[in,out] pRtEntry  Pointer to Routing Session
+   Entry structure \ref GSW_ROUTE_Entry_t.
+   \return Return value as follows:
+   - GSW_SUCCESS: if successful
+   - An error code < 0, in case an error occurs
+*/
+int GSW_ROUTE_SessionEntryRead(void *cdev, GSW_ROUTE_Entry_t *pRtEntry);
+
+/**
+   \brief This function creates a tunnel entry in the
+   Tunnel table. For complete configuration of tunnel,
+   it is a multi-step config. Besides tunnel entry creation
+   in tunnel table, it should also be programmed in
+   RoutingSession table.
+   A configured tunnel entry can be read using the command
+   \ref GSW_ROUTE_TunnelEntryRead
+   \param[in] cdev device context
+   \param[in] pTunnel Pointer to Tunnel structure
+   \ref GSW_ROUTE_Tunnel_Entry_t.
+   \return Return value as follows:
+   - Tunnel Entry index number >=0 : if successful
+   (Number of Tunnels supported are 16 so return value is 0..15 range)
+   - An error code < 0 in case an error occurs
+*/
+int GSW_ROUTE_TunnelEntryAdd(void *cdev, GSW_ROUTE_Tunnel_Entry_t *pTunnel);
+
+/**
+   \brief This function deletes a tunnel entry in the
+   Tunnel table.
+   \param[in] cdev device context
+   \param[in] nTunIdx number, where the Tunnel entry is
+   stored in the Tunnel Table.
+   \return Return value as follows:
+   - Tunnel Entry index number >=0 : if successful
+   - An error code < 0 in case an error occurs
+*/
+int GSW_ROUTE_TunnelEntryDel(void *cdev, GSW_ROUTE_Tunnel_Entry_t *pTunnel);
+
+/**
+   \brief This function reads a tunnel entry in the Tunnel
+   table at an specified index. The index must be valid
+   entry of the Tunnel index table.
+   \param[in] cdev device context.
+   \param[out] pTunnel Pointer to Tunnel structure
+   \ref GSW_ROUTE_Tunnel_Entry_t.
+   \return Return value as follows:
+   - GSW_SUCCESS: if successful
+   - An error code in case an error occurs
+*/
+int GSW_ROUTE_TunnelEntryRead(void *cdev, GSW_ROUTE_Tunnel_Entry_t *pTunnel);
+
+/**
+   \brief This function configures a Source L2NAT on an egress port.
+   A configured tunnel entry can be read using the command
+   \ref GSW_ROUTE_TunnelEntryRead
+   \param[in] cdev device context
+   \param[in] pL2NatCfg Pointer to Tunnel structure
+   \ref GSW_ROUTE_EgPort_L2NAT_Cfg_t.
+
+   \return Return value as follows:
+   - Tunnel Entry index number >=0 : if successful
+   - An error code < 0 in case an error occurs
+*/
+int GSW_ROUTE_L2NATCfgWrite(void *cdev,
+			    GSW_ROUTE_EgPort_L2NAT_Cfg_t *pL2NatCfg);
+
+/**
+   \brief This function reads currently configured L2NAT entry in
+   the Tunnel table for the specified port. The port
+   number must be a valid number.
+   \param[in] cdev device context.
+   \param[in,out] pL2NatCfg Pointer to L2NAT Config structure
+   \ref GSW_ROUTE_EgPort_L2NAT_Cfg_t. The port number must
+   be filled in this structure.
+   \return Return value as follows:
+   - GSW_SUCCESS: if successful
+   - An error code in case an error occurs
+*/
+int GSW_ROUTE_L2NATCfgRead(void *cdev,
+			   GSW_ROUTE_EgPort_L2NAT_Cfg_t *pL2NatCfg);
+
+/**
+   \brief This function reads or reads-n-clears Session Hit
+   Sttaus for the specified index.
+   \param[in] cdev device context.
+   \param[in,out] pHitOp Pointer to Session-Hit structure
+   \ref GSW_ROUTE_Session_Hit_t. The index number must be
+   filled in this structure.
+   \return Return value as follows:
+   - 0: Showing Session is not Hit.
+   - 1: Showing Session is Hit.
+   - (-1): In case of any error in reading or writing Session Hit Status.
+   - An error code in case an error occurs
+*/
+int GSW_ROUTE_SessHitOp(void *cdev, GSW_ROUTE_Session_Hit_t *pHitOp);
+
+/**
+   \brief This function modifies the destination ports of Routing Session.
+   \param[in] cdev device context.
+   \param[in,out] pDestCfg Pointer to destination structure
+   \ref GSW_ROUTE_Session_Dest_t.
+   \return Return value as follows:
+   - GSW_SUCCESS : if successful.
+   - An error code in case an error occurs
+*/
+int GSW_ROUTE_SessDestModify(void *cdev, GSW_ROUTE_Session_Dest_t *pDestCfg);
+
+/*@}*/ /* GSWIP_ROUTE */
+#endif
+#endif /* _LTQ_ETHSW_FLOW_LL_H_ */
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_ll_table.c b/drivers/net/ethernet/lantiq/switch-api/gsw_ll_table.c
new file mode 100644
index 000000000000..c13a50e6e48f
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_ll_table.c
@@ -0,0 +1,545 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+
+#include <gsw_init.h>
+
+#ifdef GSW_SW_FKT
+#undef GSW_SW_FKT
+#endif /* GSW_SW_FKT */
+
+#define GSW_SW_FKT(x, y) x ? (LTQ_ll_fkt)y : NULL
+
+#ifdef CONFIG_LTQ_8021X
+#undef CONFIG_LTQ_8021X
+#define CONFIG_LTQ_8021X		1
+#else
+#define CONFIG_LTQ_8021X		0
+#endif
+#ifdef CONFIG_LTQ_MULTICAST
+#undef CONFIG_LTQ_MULTICAST
+#define CONFIG_LTQ_MULTICAST	1
+#else
+#define CONFIG_LTQ_MULTICAST	0
+#endif
+#ifdef CONFIG_LTQ_QOS
+#undef CONFIG_LTQ_QOS
+#define CONFIG_LTQ_QOS			1
+#else
+#define CONFIG_LTQ_QOS			0
+#endif
+#ifdef CONFIG_LTQ_STP
+#undef CONFIG_LTQ_STP
+#define CONFIG_LTQ_STP			1
+#else
+#define CONFIG_LTQ_STP			0
+#endif
+#ifdef CONFIG_LTQ_VLAN
+#undef CONFIG_LTQ_VLAN
+#define CONFIG_LTQ_VLAN			1
+#else
+#define CONFIG_LTQ_VLAN			0
+#endif
+#ifdef CONFIG_LTQ_WOL
+#undef CONFIG_LTQ_WOL
+#define CONFIG_LTQ_WOL			1
+#else
+#define CONFIG_LTQ_WOL			0
+#endif
+
+#ifdef CONFIG_LTQ_PMAC
+#undef CONFIG_LTQ_PMAC
+#define CONFIG_LTQ_PMAC			1
+#else
+#define CONFIG_LTQ_PMAC			0
+#endif
+//#define CONFIG_LTQ_PMAC			1
+#ifdef CONFIG_LTQ_RMON
+#undef CONFIG_LTQ_RMON
+#define CONFIG_LTQ_RMON			1
+#else
+#define CONFIG_LTQ_RMON			0
+#endif
+//#define CONFIG_LTQ_RMON			1
+LTQ_ll_fkt ltq_fkt_ptr_tbl[] = {
+	/* 0x00 */
+	(LTQ_ll_fkt) NULL,
+	/* Command: GSW_MAC_TABLE_ENTRY_READ ; Index: 0x01 */
+	(LTQ_ll_fkt) GSW_MAC_TableEntryRead,
+	/* Command: GSW_MAC_TABLE_ENTRY_QUERY ; Index: 0x02 */
+	(LTQ_ll_fkt) GSW_MAC_TableEntryQuery,
+	/* Command: GSW_MAC_TABLE_ENTRY_ADD ; Index: 0x03 */
+	(LTQ_ll_fkt) GSW_MAC_TableEntryAdd,
+	/* Command: GSW_MAC_TABLE_ENTRY_REMOVE ; Index: 0x04 */
+	(LTQ_ll_fkt) GSW_MAC_TableEntryRemove,
+	/* Command: GSW_MAC_TABLE_CLEAR ; Index: 0x05 */
+	(LTQ_ll_fkt) GSW_MAC_TableClear,
+	/* Command: GSW_STP_PORT_CFG_SET ; Index: 0x06 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_STP, GSW_STP_PortCfgSet),
+	/* Command: GSW_STP_PORT_CFG_GET ; Index: 0x07 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_STP, GSW_STP_PortCfgGet),
+	/* Command: GSW_STP_BPDU_RULE_SET ; Index: 0x08 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_STP, GSW_STP_BPDU_RuleSet),
+	/* Command: GSW_STP_BPDU_RULE_GET ; Index: 0x09 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_STP, GSW_STP_BPDU_RuleGet),
+	/* Command: GSW_8021X_EAPOL_RULE_GET ; Index: 0x0A */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_8021X, GSW_8021X_EAPOL_RuleGet),
+	/* Command: GSW_8021X_EAPOL_RULE_SET ; Index: 0x0B */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_8021X, GSW_8021X_EAPOL_RuleSet),
+	/* Command: GSW_8021X_PORT_CFG_GET ; Index: 0x0C */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_8021X, GSW_8021X_PortCfgGet),
+	/* Command: GSW_8021X_PORT_CFG_SET ; Index: 0x0D */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_8021X, GSW_8021X_PortCfgSet),
+	/* Command: GSW_VLAN_RESERVED_ADD ; Index: 0x0E */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_VLAN_ReservedAdd),
+	/* Command: GSW_VLAN_RESERVED_REMOVE ; Index: 0x0F */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_VLAN_ReservedRemove),
+	/* Command: GSW_VLAN_PORT_CFG_GET ; Index: 0x10 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_VLAN_PortCfgGet),
+	/* Command: GSW_VLAN_PORT_CFG_SET ; Index: 0x11 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_VLAN_PortCfgSet),
+	/* Command: GSW_VLAN_ID_CREATE ; Index: 0x12 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_VLAN_IdCreate),
+	/* Command: GSW_VLAN_ID_DELETE ; Index: 0x13 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_VLAN_IdDelete),
+	/* Command: GSW_VLAN_PORT_MEMBER_ADD ; Index: 0x14 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_VLAN_PortMemberAdd),
+	/* Command: GSW_VLAN_PORT_MEMBER_REMOVE ; Index: 0x15 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_VLAN_PortMemberRemove),
+	/* Command: GSW_VLAN_PORT_MEMBER_READ ; Index: 0x16 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_VLAN_PortMemberRead),
+	/* Command: GSW_VLAN_ID_GET ; Index: 0x17 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_VLAN_IdGet),
+	/* Command: GSW_QOS_PORT_CFG_SET ; Index: 0x18 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_PortCfgSet),
+	/* Command: GSW_QOS_PORT_CFG_GET ; Index: 0x19 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_PortCfgGet),
+	/* Command: GSW_QOS_DSCP_CLASS_SET ; Index: 0x1A */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_DSCP_ClassSet),
+	/* Command: GSW_QOS_DSCP_CLASS_GET ; Index: 0x1B */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_DSCP_ClassGet),
+	/* Command: GSW_QOS_PCP_CLASS_SET ; Index: 0x1C */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_PCP_ClassSet),
+	/* Command: GSW_QOS_PCP_CLASS_GET ; Index: 0x1D */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_PCP_ClassGet),
+	/* Command: GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_SET ; Index: 0x1E */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_DSCP_DropPrecedenceCfgSet),
+	/* Command: GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_GET ; Index: 0x1F */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_DSCP_DropPrecedenceCfgGet),
+	/* Command: GSW_QOS_PORT_REMARKING_CFG_SET ; Index: 0x20 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_PortRemarkingCfgSet),
+	/* Command: GSW_QOS_PORT_REMARKING_CFG_GET ; Index: 0x21 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_PortRemarkingCfgGet),
+	/* Command: GSW_QOS_CLASS_DSCP_SET ; Index: 0x22 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_ClassDSCP_Set),
+	/* Command: GSW_QOS_CLASS_DSCP_GET ; Index: 0x23 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_ClassDSCP_Get),
+	/* Command: GSW_QOS_CLASS_PCP_SET ; Index: 0x24 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_ClassPCP_Set),
+	/* Command: GSW_QOS_CLASS_PCP_GET ; Index: 0x25 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_ClassPCP_Get),
+	/* Command: GSW_QOS_SHAPER_CFG_SET ; Index: 0x26 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_ShaperCfgSet),
+	/* Command: GSW_QOS_SHAPER_CFG_GET ; Index: 0x27 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_ShaperCfgGet),
+	/* Command: GSW_QOS_SHAPER_QUEUE_ASSIGN ; Index: 0x28 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_ShaperQueueAssign),
+	/* Command: GSW_QOS_SHAPER_QUEUE_DEASSIGN ; Index: 0x29 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_ShaperQueueDeassign),
+	/* Command: GSW_QOS_SHAPER_QUEUE_GET ; Index: 0x2A */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_ShaperQueueGet),
+	/* Command: GSW_QOS_WRED_CFG_SET ; Index: 0x2B */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_WredCfgSet),
+	/* Command: GSW_QOS_WRED_CFG_GET ; Index: 0x2C */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_WredCfgGet),
+	/* Command: GSW_QOS_WRED_QUEUE_CFG_SET ; Index: 0x2D */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_WredQueueCfgSet),
+	/* Command: GSW_QOS_WRED_QUEUE_CFG_GET ; Index: 0x2E */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_WredQueueCfgGet),
+	/* Command: GSW_QOS_METER_CFG_SET ; Index: 0x2F */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_MeterCfgSet),
+	/* Command: GSW_QOS_METER_CFG_GET ; Index: 0x30 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_MeterCfgGet),
+	/* Command: GSW_QOS_METER_PORT_ASSIGN ; Index: 0x31 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_MeterPortAssign),
+	/* Command: GSW_QOS_METER_PORT_DEASSIGN ; Index: 0x32 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_MeterPortDeassign),
+	/* Command: GSW_QOS_METER_PORT_GET ; Index: 0x33 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_MeterPortGet),
+	/* Command: GSW_QOS_STORM_CFG_SET ; Index: 0x34 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_StormCfgSet),
+	/* Command: GSW_QOS_STORM_CFG_GET ; Index: 0x35 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_StormCfgGet),
+	/* Command: GSW_QOS_SCHEDULER_CFG_SET ; Index: 0x36 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_SchedulerCfgSet),
+	/* Command: GSW_QOS_SCHEDULER_CFG_GET ; Index: 0x37 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_SchedulerCfgGet),
+	/* Command: GSW_QOS_QUEUE_PORT_SET ; Index: 0x38 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_QueuePortSet),
+	/* Command: GSW_QOS_QUEUE_PORT_GET ; Index: 0x39 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_QueuePortGet),
+	/* Command: GSW_MULTICAST_SNOOP_CFG_SET ; Index: 0x3A */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_MULTICAST, GSW_MulticastSnoopCfgSet),
+	/* Command: GSW_MULTICAST_SNOOP_CFG_GET ; Index: 0x3B */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_MULTICAST, GSW_MulticastSnoopCfgGet),
+	/* Command: GSW_MULTICAST_ROUTER_PORT_ADD ; Index: 0x3C */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_MULTICAST, GSW_MulticastRouterPortAdd),
+	/* Command: GSW_MULTICAST_ROUTER_PORT_REMOVE ; Index: 0x3D */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_MULTICAST, GSW_MulticastRouterPortRemove),
+	/* Command: GSW_MULTICAST_ROUTER_PORT_READ ; Index: 0x3E */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_MULTICAST, GSW_MulticastRouterPortRead),
+	/* Command: GSW_MULTICAST_TABLE_ENTRY_ADD ; Index: 0x3F */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_MULTICAST, GSW_MulticastTableEntryAdd),
+	/* Command: GSW_MULTICAST_TABLE_ENTRY_REMOVE ; Index: 0x40 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_MULTICAST, GSW_MulticastTableEntryRemove),
+	/* Command: GSW_MULTICAST_TABLE_ENTRY_READ ; Index: 0x41 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_MULTICAST, GSW_MulticastTableEntryRead),
+	/* Command: GSW_HW_INIT ; Index: 0x42 */
+	(LTQ_ll_fkt) GSW_HW_Init,
+	/* Command: GSW_VERSION_GET ; Index: 0x43 */
+	(LTQ_ll_fkt) GSW_VersionGet,
+	/* Command: GSW_CAP_GET ; Index: 0x44 */
+	(LTQ_ll_fkt) GSW_CapGet,
+	/* Command: GSW_CFG_SET ; Index: 0x45 */
+	(LTQ_ll_fkt) GSW_CfgSet,
+	/* Command: GSW_CFG_GET ; Index: 0x46 */
+	(LTQ_ll_fkt) GSW_CfgGet,
+	/* Command: GSW_ENABLE ; Index: 0x47 */
+	(LTQ_ll_fkt) GSW_Enable,
+	/* Command: GSW_DISABLE ; Index: 0x48 */
+	(LTQ_ll_fkt) GSW_Disable,
+	/* Command: GSW_PORT_CFG_GET ; Index: 0x49 */
+	(LTQ_ll_fkt) GSW_PortCfgGet,
+	/* Command: GSW_PORT_CFG_SET ; Index: 0x4A */
+	(LTQ_ll_fkt) GSW_PortCfgSet,
+	/* Command: GSW_CPU_PORT_CFG_SET ; Index: 0x4B */
+	(LTQ_ll_fkt) GSW_CPU_PortCfgSet,
+	/* Command: GSW_CPU_PORT_CFG_GET ; Index: 0x4C */
+	(LTQ_ll_fkt) GSW_CPU_PortCfgGet,
+	/* Command: GSW_CPU_PORT_EXTEND_CFG_SET ; Index: 0x4D */
+	(LTQ_ll_fkt) GSW_CPU_PortExtendCfgSet,
+	/* Command: GSW_CPU_PORT_EXTEND_CFG_GET ; Index: 0x4E */
+	(LTQ_ll_fkt) GSW_CPU_PortExtendCfgGet,
+	/* Command: GSW_PORT_LINK_CFG_GET ; Index: 0x4F */
+	(LTQ_ll_fkt) GSW_PortLinkCfgGet,
+	/* Command: GSW_PORT_LINK_CFG_SET ; Index: 0x50 */
+	(LTQ_ll_fkt) GSW_PortLinkCfgSet,
+	/* Command: GSW_PORT_RGMII_CLK_CFG_SET ; Index: 0x51 */
+	(LTQ_ll_fkt) GSW_PortRGMII_ClkCfgSet,
+	/* Command: GSW_PORT_RGMII_CLK_CFG_GET ; Index: 0x52 */
+	(LTQ_ll_fkt) GSW_PortRGMII_ClkCfgGet,
+	/* Command: GSW_PORT_PHY_QUERY ; Index: 0x53 */
+	(LTQ_ll_fkt) GSW_PortPHY_Query,
+	/* Command: GSW_PORT_PHY_ADDR_GET ; Index: 0x54 */
+	(LTQ_ll_fkt) GSW_PortPHY_AddrGet,
+	/* Command: GSW_PORT_REDIRECT_GET ; Index: 0x55 */
+	(LTQ_ll_fkt) GSW_PortRedirectGet,
+	/* Command: GSW_PORT_REDIRECT_SET ; Index: 0x56 */
+	(LTQ_ll_fkt) GSW_PortRedirectSet,
+	/* Command: GSW_MONITOR_PORT_CFG_GET ; Index: 0x57 */
+	(LTQ_ll_fkt) GSW_MonitorPortCfgGet,
+	/* Command: GSW_MONITOR_PORT_CFG_SET ; Index: 0x58 */
+	(LTQ_ll_fkt) GSW_MonitorPortCfgSet,
+	/* Command: GSW_RMON_PORT_GET ; Index: 0x59 */
+	(LTQ_ll_fkt) GSW_RMON_Port_Get,
+	/* Command: GSW_RMON_CLEAR ; Index: 0x5A */
+	(LTQ_ll_fkt) GSW_RMON_Clear,
+	/* Command: GSW_MDIO_CFG_GET ; Index: 0x5B */
+	(LTQ_ll_fkt) GSW_MDIO_CfgGet,
+	/* Command: GSW_MDIO_CFG_SET ; Index: 0x5C */
+	(LTQ_ll_fkt) GSW_MDIO_CfgSet,
+	/* Command: GSW_MDIO_DATA_READ ; Index: 0x5D */
+	(LTQ_ll_fkt) GSW_MDIO_DataRead,
+	/* Command: GSW_MDIO_DATA_WRITE ; Index: 0x5E */
+	(LTQ_ll_fkt) GSW_MDIO_DataWrite,
+	/* Command: GSW_MMD_DATA_READ ; Index: 0x5F */
+	(LTQ_ll_fkt) GSW_MmdDataRead,
+	/* Command: GSW_MMD_DATA_WRITE ; Index: 0x60 */
+	(LTQ_ll_fkt) GSW_MmdDataWrite,
+	/* Command: GSW_WOL_CFG_SET ; Index: 0x61 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_WOL, GSW_WoL_CfgSet),
+	/* Command: GSW_WOL_CFG_GET ; Index: 0x62 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_WOL, GSW_WoL_CfgGet),
+	/* Command: GSW_WOL_PORT_CFG_SET ; Index: 0x63 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_WOL, GSW_WoL_PortCfgSet),
+	/* Command: GSW_WOL_PORT_CFG_GET ; Index: 0x64 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_WOL, GSW_WoL_PortCfgGet),
+	/* Command: GSW_TRUNKING_CFG_GET ; Index: 0x65 */
+	(LTQ_ll_fkt) GSW_TrunkingCfgGet,
+	/* Command: GSW_TRUNKING_CFG_SET ; Index: 0x66 */
+	(LTQ_ll_fkt) GSW_TrunkingCfgSet,
+	/* Command: GSW_TRUNKING_PORT_CFG_GET ; Index: 0x67 */
+	(LTQ_ll_fkt) GSW_TrunkingPortCfgGet,
+	/* Command: GSW_TRUNKING_PORT_CFG_SET ; Index: 0x68 */
+	(LTQ_ll_fkt) GSW_TrunkingPortCfgSet,
+	/* Command: GSW_QOS_WRED_PORT_CFG_SET ; Index: 0x69 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_WredPortCfgSet),
+	/* Command: GSW_QOS_WRED_PORT_CFG_GET ; Index: 0x6a */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_WredPortCfgGet),
+	/* Command: GSW_QOS_FLOWCTRL_CFG_SET ; Index: 0x6b */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_FlowctrlCfgSet),
+	/* Command: GSW_QOS_FLOWCTRL_CFG_GET ; Index: 0x6c */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_FlowctrlCfgGet),
+	/* Command: GSW_QOS_FLOWCTRL_PORT_CFG_SET ; Index: 0x6d */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_FlowctrlPortCfgSet),
+	/* Command: GSW_QOS_FLOWCTRL_PORT_CFG_GET ; Index: 0x6e */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_FlowctrlPortCfgGet),
+	/* Command: GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_SET ; Index: 0x6f */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_QueueBufferReserveCfgSet),
+	/* Command: GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_GET ; Index: 0x70 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_QueueBufferReserveCfgGet),
+	/* Command: GSW_SVLAN_CFG_GET ; Index: 0x71 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_SVLAN_CfgGet),
+	/* Command: GSW_SVLAN_CFG_SET ; Index: 0x72 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_SVLAN_CfgSet),
+	/* Command: GSW_SVLAN_PORT_CFG_GET ; Index: 0x73 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_SVLAN_PortCfgGet),
+	/* Command: GSW_SVLAN_PORT_CFG_SET ; Index: 0x74 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_SVLAN_PortCfgSet),
+	/* Command: GSW_QOS_SVLAN_CLASS_PCP_PORT_SET ; Index: 0x75 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_QoS_SVLAN_ClassPCP_PortSet),
+	/* Command: GSW_QOS_SVLAN_CLASS_PCP_PORT_GET ; Index: 0x76 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_QoS_SVLAN_ClassPCP_PortGet),
+	/* Command: GSW_QOS_SVLAN_PCP_CLASS_SET ; Index: 0x77 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_QoS_SVLAN_PCP_ClassSet),
+	/* Command: GSW_QOS_SVLAN_PCP_CLASS_GET ; Index: 0x78 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_QoS_SVLAN_PCP_ClassGet),
+	/* Command: GSW_VLAN_MEMBER_INIT ; Index: 0x79 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_VLAN_Member_Init),
+	/* Command: GSW_PCE_EG_VLAN_CFG_SET ; Index: 0x7A */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_PCE_EG_VLAN_CfgSet),
+	/* Command: GSW_PCE_EG_VLAN_CFG_GET ; Index: 0x7B */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_PCE_EG_VLAN_CfgGet),
+	/* Command: GSW_PCE_EG_VLAN_ENTRY_WRITE ; Index: 0x7C */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_PCE_EG_VLAN_EntryWrite),
+	/* Command: GSW_PCE_EG_VLAN_ENTRY_READ ; Index: 0x7D */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_VLAN, GSW_PCE_EG_VLAN_EntryRead),
+	/* Command: GSW_QOS_METER_ACT ; Index: 0x7E */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_QOS, GSW_QoS_Meter_Act),
+	(LTQ_ll_fkt) NULL,  /* Index: 0x7F */
+	(LTQ_ll_fkt) NULL, /* Index: 0x80 */
+	(LTQ_ll_fkt) NULL, /* Index: 0x81 */
+	(LTQ_ll_fkt) NULL, /* Index: 0x82 */
+	(LTQ_ll_fkt) NULL, /* Index: 0x83 */
+	(LTQ_ll_fkt) NULL, /* Index: 0x84 */
+	(LTQ_ll_fkt) NULL, /* Index: 0x85 */
+	(LTQ_ll_fkt) NULL, /* Index: 0x86 */
+	(LTQ_ll_fkt) NULL, /* Index: 0x87 */
+	(LTQ_ll_fkt) NULL, /* Index: 0x88 */
+	(LTQ_ll_fkt) NULL, /* Index: 0x89 */
+	(LTQ_ll_fkt) NULL, /* Index: 0x8a */
+	(LTQ_ll_fkt) NULL, /* Index: 0x8b */
+	(LTQ_ll_fkt) NULL, /* Index: 0x8c */
+	(LTQ_ll_fkt) NULL, /* Index: 0x8d */
+	(LTQ_ll_fkt) NULL, /* Index: 0x8e */
+	(LTQ_ll_fkt) NULL, /* Index: 0x8f */
+	/* Command: GSW_RMON_MODE_SET ; Index: 0x90 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_RMON, GSW_RMON_Mode_Set),
+	/* Command: GSW_RMON_IF_GET ; Index: 0x91 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_RMON, GSW_RMON_If_Get),
+	/* Command: GSW_RMON_REDIRECT_GET ; Index: 0x92 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_RMON, GSW_RMON_Redirect_Get),
+	/* Command: GSW_RMON_ROUTE_GET ; Index: 0x93 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_RMON, GSW_RMON_Route_Get),
+	/* Command: GSW_RMON_METER_GET ; Index: 0x94 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_RMON, GSW_RMON_Meter_Get),
+	/* Command: GSW_PMAC_BM_CFG_SET ; Index: 0x95 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_PMAC, GSW_PMAC_BM_CfgSet),
+	/* Command: GSW_PMAC_BM_CFG_GET ; Index: 0x96 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_PMAC, GSW_PMAC_BM_CfgGet),
+	/* Command: GSW_PMAC_IG_CFG_SET ; Index: 0x97 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_PMAC, GSW_PMAC_IG_CfgSet),
+	/* Command: GSW_PMAC_IG_CFG_GET ; Index: 0x98 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_PMAC, GSW_PMAC_IG_CfgGet),
+	/* Command: GSW_PMAC_EG_CFG_SET ; Index: 0x99 */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_PMAC, GSW_PMAC_EG_CfgSet),
+	/* Command: GSW_PMAC_EG_CFG_GET ; Index: 0x9a */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_PMAC, GSW_PMAC_EG_CfgGet),
+	/* Command: GSW_PMAC_COUNT_GET ; Index: 0x9b */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_PMAC, GSW_PMAC_CountGet),
+	/* Command: GSW_PMAC_GLBL_CFG_SET ; Index: 0x9c */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_PMAC, GSW_PMAC_GLBL_CfgSet),
+	/* Command: GSW_PMAC_GLBL_CFG_GET ; Index: 0x9d */
+	(LTQ_ll_fkt) GSW_SW_FKT(CONFIG_LTQ_PMAC, GSW_PMAC_GLBL_CfgGet),
+	(LTQ_ll_fkt) NULL,  /* Index: 0x9E */
+	(LTQ_ll_fkt) NULL, /* Index: 0x9F */
+	/*Applicable only for GSWIP 3.1*/
+	/* Command: GSW_CTP_PORT_ASSIGNMENT_SET ; Index: 0xA0 */
+	(LTQ_ll_fkt) GSW_CTP_PortAssignmentSet,
+	/* Command: GSW_CTP_PORT_ASSIGNMENT_GET ; Index: 0xA1 */
+	(LTQ_ll_fkt) GSW_CTP_PortAssignmentGet,
+	/* Command: GSW_BRIDGE_CONFIG_SET ; Index: 0xA2 */
+	(LTQ_ll_fkt) GSW_BridgeConfigSet,
+	/* Command: GSW_BRIDGE_FREE ; Index: 0xA3 */
+	(LTQ_ll_fkt) GSW_BridgeFree,
+	/* Command: GSW_BRIDGE_CONFIG_GET ; Index: 0xA4 */
+	(LTQ_ll_fkt) GSW_BridgeConfigGet,
+	/* Command: GSW_BRIDGE_PORT_CONFIG_SET ; Index: 0xA5 */
+	(LTQ_ll_fkt) GSW_BridgePortConfigSet,
+	/* Command: GSW_BRIDGE_PORT_FREE ; Index: 0xA6 */
+	(LTQ_ll_fkt) GSW_BridgePortFree,
+	/* Command: GSW_BRIDGE_PORT_CONFIG_GET ; Index: 0xA7 */
+	(LTQ_ll_fkt) GSW_BridgePortConfigGet,
+	/* Command: GSW_CTP_PORT_CONFIG_SET ; Index: 0xA8 */
+	(LTQ_ll_fkt) GSW_CtpPortConfigSet,
+	/* Command: GSW_CTP_PORT_CONFIG_GET ; Index: 0xA9 */
+	(LTQ_ll_fkt) GSW_CtpPortConfigGet,
+	/* Command: GSW_EXTENDEDVLAN_SET ; Index: 0xAA */
+	(LTQ_ll_fkt) GSW_ExtendedVlanSet,
+	/* Command: GSW_EXTENDEDVLAN_FREE ; Index: 0xAB */
+	(LTQ_ll_fkt) GSW_ExtendedVlanFree,
+	/* Command: GSW_EXTENDEDVLAN_GET ; Index: 0xAC */
+	(LTQ_ll_fkt) GSW_ExtendedVlanGet,
+	/* Command: GSW_VLANFILTER_SET ; Index: 0xAD */
+	(LTQ_ll_fkt) GSW_VlanFilterSet,
+	/* Command: GSW_VLANFILTER_FREE ; Index: 0xAE */
+	(LTQ_ll_fkt) GSW_VlanFilterFree,
+	/* Command: GSW_VLANFILTER_GET ; Index: 0xAF */
+	(LTQ_ll_fkt) GSW_VlanFilterGet,
+	/* Command: GSW_QOS_METER_ALLOC ; Index: 0xB0 */
+	(LTQ_ll_fkt) GSW_QOS_MeterAlloc,
+	/* Command: GSW_QOS_METER_FREE ; Index: 0xB1 */
+	(LTQ_ll_fkt) GSW_QOS_MeterFree,
+	/* Command: GSW_QOS_COLOR_MARKING_TABLE_SET ; Index: 0xB2 */
+	(LTQ_ll_fkt) GSW_QOS_ColorMarkingTableSet,
+	/* Command: GSW_QOS_COLOR_MARKING_TABLE_GET ; Index: 0xB3 */
+	(LTQ_ll_fkt) GSW_QOS_ColorMarkingTableGet,
+	/* Command: GSW_QOS_COLOR_REMARKING_TABLE_SET ; Index: 0xB4 */
+	(LTQ_ll_fkt) GSW_QOS_ColorReMarkingTableSet,
+	/* Command: GSW_QOS_COLOR_REMARKING_TABLE_GET ; Index: 0xB5 */
+	(LTQ_ll_fkt) GSW_QOS_ColorReMarkingTableGet,
+	/* Command: GSW_DSCP2PCP_MAP_SET ; Index: 0xB6 */
+	(LTQ_ll_fkt) GSW_QOS_Dscp2PcpTableSet,
+	/* Command: GSW_DSCP2PCP_MAP_GET ; Index: 0xB7 */
+	(LTQ_ll_fkt) GSW_QOS_Dscp2PcpTableGet,
+	/* Command: GSW_PMAPPER_SET ; Index: 0xB8 */
+	(LTQ_ll_fkt) GSW_QOS_PmapperTableSet,
+	/* Command: GSW_PMAPPER_GET ; Index: 0xB9 */
+	(LTQ_ll_fkt) GSW_QOS_PmapperTableGet,
+	/* Command: GSW_DEFAUL_MAC_FILTER_SET ; Index: 0xBA */
+	(LTQ_ll_fkt) GSW_DefaultMacFilterSet,
+	/* Command: GSW_DEFAUL_MAC_FILTER_GET ; Index: 0xBB */
+	(LTQ_ll_fkt) GSW_DefaultMacFilterGet,
+	/* Command: GSW_CTP_PORT_CONFIG_RESET ; Index: 0xBC */
+	(LTQ_ll_fkt) GSW_CtpPortConfigReset,
+	/* Command: GSW_RMON_TFLOW_CLEAR ; Index: 0xBD */
+	(LTQ_ll_fkt) GSW_RmonTflowClear,
+	/* Command: GSW_TFLOW_COUNT_MODE_SET ; Index: 0xBE */
+	(LTQ_ll_fkt) GSW_TflowCountModeSet,
+	/* Command: GSW_TFLOW_COUNT_MODE_GET ; Index: 0xBF */
+	(LTQ_ll_fkt) GSW_TflowCountModeGet,
+	/* Command: GSW_TFLOW_COUNT_MODE_GET ; Index: 0xC0 */
+	(LTQ_ll_fkt) GSW_CTP_PortAssignmentAlloc,
+	/* Command: GSW_TFLOW_COUNT_MODE_GET ; Index: 0xC1 */
+	(LTQ_ll_fkt) GSW_CTP_PortAssignmentFree,
+	/* Command: GSW_EXTENDEDVLAN_ALLOC ; Index: 0xC2 */
+	(LTQ_ll_fkt) GSW_ExtendedVlanAlloc,
+	/* Command: GSW_VLANFILTER_ALLOC ; Index: 0xC3 */
+	(LTQ_ll_fkt) GSW_VlanFilterAlloc,
+	/* Command: GSW_BRIDGE_ALLOC ; Index: 0xC4 */
+	(LTQ_ll_fkt) GSW_BridgeAlloc,
+	/* Command: GSW_BRIDGE_PORT_ALLOC ; Index: 0xC5 */
+	(LTQ_ll_fkt) GSW_BridgePortAlloc,
+	/* Command: GSW_XGMAC_CFG ; Index: 0xC6 */
+	(LTQ_ll_fkt) GSW_XgmacCfg,
+	/* Command: GSW_GSWSS_CFG ; Index: 0xC7 */
+	(LTQ_ll_fkt) GSW_GswssCfg,
+	/* Command: GSW_LMAC_CFG ; Index: 0xC8 */
+	(LTQ_ll_fkt) GSW_LmacCfg,
+	/* Command: GSW_MACSEC_CFG ; Index: 0xC9 */
+	(LTQ_ll_fkt) GSW_MacsecCfg,
+	/* Command: GSW_DUMP_MEM ; Index: 0xCA */
+	(LTQ_ll_fkt) GSW_DumpTable,
+};
+
+ltq_lowlevel_fkts_t GSW_FLOW_fkt_tbl = {
+	NULL, /* pNext */
+	(u16) GSW_MAGIC, /* nType */
+	198, /* nNumFkts */
+	ltq_fkt_ptr_tbl /* pFkts */
+};
+
+LTQ_ll_fkt gsw_flow_fkt_ptr_tbl[] = {
+	/* 0x00 */
+	(LTQ_ll_fkt) NULL,
+	/* Command: GSW_REGISTER_SET ; Index: 0x01 */
+	(LTQ_ll_fkt) GSW_RegisterSet,
+	/* Command: GSW_REGISTER_GET ; Index: 0x02 */
+	(LTQ_ll_fkt) GSW_RegisterGet,
+	/* Command: GSW_IRQ_MASK_GET ; Index: 0x03 */
+	(LTQ_ll_fkt) GSW_IrqMaskGet,
+	/* Command: GSW_IRQ_MASK_SET ; Index: 0x04 */
+	(LTQ_ll_fkt) GSW_IrqMaskSet,
+	/* Command: GSW_IRQ_GET ; Index: 0x05 */
+	(LTQ_ll_fkt) GSW_IrqGet,
+	/* Command: GSW_IRQ_STATUS_CLEAR ; Index: 0x06 */
+	(LTQ_ll_fkt) GSW_IrqStatusClear,
+	/* Command: GSW_PCE_RULE_WRITE ; Index: 0x07 */
+	(LTQ_ll_fkt) GSW_PceRuleWrite,
+	/* Command: GSW_PCE_RULE_READ ; Index: 0x08 */
+	(LTQ_ll_fkt) GSW_PceRuleRead,
+	/* Command: GSW_PCE_RULE_DELETE ; Index: 0x09 */
+	(LTQ_ll_fkt) GSW_PceRuleDelete,
+	/* Command: GSW_RESET ; Index: 0x0A */
+	(LTQ_ll_fkt) GSW_Reset,
+	/* Command: GSW_RMON_EXTEND_GET ; Index: 0x0B */
+	(LTQ_ll_fkt) GSW_RMON_ExtendGet,
+	/* Command: GSW_TIMESTAMP_TIMER_SET ; Index: 0x0C */
+	(LTQ_ll_fkt) GSW_TimestampTimerSet,
+	/* Command: GSW_TIMESTAMP_TIMER_GET ; Index: 0x0D */
+	(LTQ_ll_fkt) GSW_TimestampTimerGet,
+	/* Command: GSW_TIMESTAMP_PORT_READ ; Index: 0x0E */
+	(LTQ_ll_fkt) GSW_TimestampPortRead,
+	/* Command: GSW_RMON_FLOW_GET ; Index: 0x0F */
+	(LTQ_ll_fkt) GSW_RMON_FlowGet,
+};
+
+ltq_lowlevel_fkts_t ltq_flow_fkt_tbl = {
+	&GSW_FLOW_fkt_tbl, /* pNext */
+	(u16) GSW_FLOW_MAGIC, /* nType */
+	16, /* nNumFkts */
+	gsw_flow_fkt_ptr_tbl /* pFkts */
+};
+
+#ifdef __KERNEL__
+LTQ_ll_fkt gsw_rt_fkt_ptr_tbl[] = {
+	/* 0x00 */
+	(LTQ_ll_fkt) NULL,
+	/* Command: GSW_ROUTE_ENTRY_ADD ; Index: 0x01 */
+	(LTQ_ll_fkt) GSW_ROUTE_SessionEntryAdd,
+	/* Command: GSW_ROUTE_ENTRY_DELETE ; Index: 0x02 */
+	(LTQ_ll_fkt) GSW_ROUTE_SessionEntryDel,
+	/* Command: GSW_ROUTE_ENTRY_READ ; Index: 0x03 */
+	(LTQ_ll_fkt) GSW_ROUTE_SessionEntryRead,
+	/* Command: GSW_ROUTE_TUNNEL_ENTRY_ADD ; Index: 0x04 */
+	(LTQ_ll_fkt) GSW_ROUTE_TunnelEntryAdd,
+	/* Command: GSW_ROUTE_TUNNEL_ENTRY_DELETE ; Index: 0x05 */
+	(LTQ_ll_fkt) GSW_ROUTE_TunnelEntryDel,
+	/* Command: GSW_ROUTE_TUNNEL_ENTRY_READ ; Index: 0x06 */
+	(LTQ_ll_fkt) GSW_ROUTE_TunnelEntryRead,
+	/* Command: GSW_ROUTE_L2NAT_CFG_WRITE ; Index: 0x07 */
+	(LTQ_ll_fkt) GSW_ROUTE_L2NATCfgWrite,
+	/* Command: GSW_ROUTE_L2NAT_CFG_READ ; Index: 0x08 */
+	(LTQ_ll_fkt) GSW_ROUTE_L2NATCfgRead,
+	/* Command: GSW_ROUTE_SESSION_HIT_OP ; Index: 0x09 */
+	(LTQ_ll_fkt) GSW_ROUTE_SessHitOp,
+	/* Command: GSW_ROUTE_SESSION_DEST_MOD ; Index: 0x0A */
+	(LTQ_ll_fkt) GSW_ROUTE_SessDestModify,
+};
+
+ltq_lowlevel_fkts_t ltq_rt_fkt_tbl = {
+	&ltq_flow_fkt_tbl, /* pNext */
+	(u16) GSW_ROUTE_MAGIC, /* nType */
+	11, /* nNumFkts */
+	gsw_rt_fkt_ptr_tbl /* pFkts */
+};
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_pae.c b/drivers/net/ethernet/lantiq/switch-api/gsw_pae.c
new file mode 100644
index 000000000000..ad825e4aa5ce
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_pae.c
@@ -0,0 +1,2290 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+
+#include "gsw_init.h"
+
+ltq_rt_table_t *rthandler = NULL;
+
+#define	RT_ASSERT(t)	{if ((t)) {\
+			return -1; }	}
+
+#define RT_DEBUG 0
+
+/* Static Function Declaration */
+static int rt_tbl_write(void *tstart, u16 *rcnt,
+			void *rpar, u32 ts, u32 tentry)
+{
+	int i;
+
+	/* search if the entry is already available and can be re-used */
+	for (i = 0; i < tentry; i++) {
+		/* entry is used, check if the entry content fits */
+		if (rcnt[i] > 0) {
+			if (memcmp((((char *)tstart) + i * ts),
+				   rpar, (u8)ts) == 0) {
+				rcnt[i]++;
+				return i;
+			}
+		}
+	}
+
+	/* find an empty entry and add information */
+	for (i = 0; i < tentry; i++) {
+		if (rcnt[i] == 0) {
+			memcpy((((char *)tstart) + i * ts), rpar, (u8)ts);
+			rcnt[i]++;
+			return i;
+		}
+	}
+
+	/* table is full, return an error */
+	return -1;
+}
+
+static int sw_ip_tbl_write(void *tstart, u16 *rcnt,
+			   void *rpar, u32 ts, u32 tnum, int start)
+{
+	int i = 0;
+
+	/* search if the entry is already available and can be re-used */
+	if (start == 0) {
+		for (i = 0; i < tnum; i++) {
+			if ((rcnt[i] > 0)) {
+				if (memcmp((((char *)tstart) + i * ts),
+					   rpar, (u8)ts) == 0) {
+					rcnt[i]++;
+					return i;
+				}
+			}
+		}
+
+		/* find an empty entry and add information */
+		for (i = 0; i < tnum;) {
+			char *abc = ((char *)tstart + (i * sizeof(riptbl_t)));
+			riptbl_t *itbl = (riptbl_t *)abc;
+
+			if (((i % 4) == 0) && (itbl->itype == GSW_RT_IP_V6)
+			    && (itbl->valid == 1)) {
+				i += 4;
+			} else {
+				if (rcnt[i] == 0) {
+					memcpy((((char *)tstart) + i * ts),
+					       rpar, (u8)ts);
+					rcnt[i]++;
+					return i;
+				} else {
+					i++;
+				}
+			}
+		}
+	} else if (start == 1) {
+		for (i = 0; i < tnum; i += 4) {
+			/* entry is used, check if the entry content fits */
+			if (rcnt[i] > 0) {
+				if (memcmp((((char *)tstart) + i * ts),
+					   rpar, (u8)ts) == 0) {
+					rcnt[i]++;
+					return i;
+				}
+			}
+		}
+
+		/* find an empty entry and add information */
+		for (i = 0; i < tnum; i += 4) {
+			if (rcnt[i] == 0 && rcnt[i + 1] == 0
+			    && rcnt[i + 2] == 0 && rcnt[i + 3] == 0) {
+				memcpy((((char *)tstart) + i * ts),
+				       rpar, (u8)ts);
+				rcnt[i]++;
+				return i;
+			}
+		}
+	}
+
+	/* table is full, return an error */
+	return -1;
+}
+
+static int sw_mac_tbl_write(void *tstart, u16 *rcnt,
+			    void *rpar, u32 ts, u32 tentry)
+{
+	int i;
+
+	/* search if the entry is already available and can be re-used */
+	for (i = 1; i < tentry; i++) {
+		if (rcnt[i] > 0) {
+			/* entry is used, check if the entry content fits */
+			if (memcmp((((char *)tstart) + i * ts),
+				   rpar, (u8)ts) == 0) {
+				rcnt[i]++;
+				return i;
+			}
+		}
+	}
+
+	/* find an empty entry and add information */
+	for (i = 1; i < tentry; i++) {
+		if (rcnt[i] == 0) {
+			memcpy((((char *)tstart) + i * ts), rpar, (u8)ts);
+			rcnt[i]++;
+			return i;
+		}
+	}
+
+	/* table is full, return an error */
+	return -1;
+}
+
+static int get_rt_tbl_index(void *tstart, void *rpar,
+			    u32 ts, u32 tentry)
+{
+	int i;
+
+	/* search if the entry is already available and can be re-used */
+	for (i = 0; i < tentry; i++) {
+		/* entry is used, check if the entry content fits */
+		if (memcmp(((char *)tstart) + i * ts, rpar, (u8)ts) == 0)
+			return i;
+	}
+
+	return 0x7FFF;
+}
+
+/* Static Function Declaration */
+int find_ip_tbl_entry(rt_table_handle_t *tm, riptbl_t *rpar)
+{
+	return get_rt_tbl_index(tm->rt_ip_tbl, rpar,
+				sizeof(riptbl_t), RT_IP_TBL_SIZE);
+}
+
+static int rt_iptable_rd(void *cdev,
+			 int index, riptbl_t *rpar)
+{
+	/*ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);*/
+	pctbl_prog_t ptable;
+	int i;
+	memset(&ptable, 0, sizeof(ptable));
+	ptable.table	= PCE_R_IP_INDEX;
+	ptable.pcindex	= index;
+	ptable.op_mode = OPMOD_IPv4_READ;
+	route_table_read(cdev, &ptable);
+
+	if ((ptable.val[8] >> 15) & 0x1) {
+		rpar->itype = GSW_RT_IP_V6;
+
+		for (i = 0; i < 8; i++)
+			rpar->iaddr.i6addr[i] = (ptable.val[i] & 0xFFFF);
+	} else {
+		rpar->itype = GSW_RT_IP_V4;
+		rpar->iaddr.i4addr[0] = (ptable.val[0] & 0xFF);
+		rpar->iaddr.i4addr[1] = ((ptable.val[0] >> 8) & 0xFF);
+		rpar->iaddr.i4addr[2] = (ptable.val[1] & 0xFF);
+		rpar->iaddr.i4addr[3] = ((ptable.val[1] >> 8) & 0xFF);
+	}
+
+	return GSW_statusOk;
+}
+
+static int rt_iptable_wr(void *cdev,
+			 int index, riptbl_t *rpar)
+{
+	/*ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);*/
+	pctbl_prog_t ptable;
+	int i, j;
+	memset(&ptable, 0, sizeof(ptable));
+	ptable.table	= PCE_R_IP_INDEX;
+	ptable.pcindex	= index;
+
+	if (rpar->itype == GSW_RT_IP_V4) {
+		ptable.op_mode = OPMOD_IPv4_WRITE;
+		ptable.val[0] = ((rpar->iaddr.i4addr[0])
+				 | (rpar->iaddr.i4addr[1] << 8));
+		ptable.val[1] = ((rpar->iaddr.i4addr[2])
+				 | (rpar->iaddr.i4addr[3] << 8));
+		ptable.val[8] &= ~(1 << 15);
+	} else if (rpar->itype == GSW_RT_IP_V6) {
+		ptable.pcindex = index & 0xFFFC;
+		ptable.op_mode = OPMOD_IPv4_WRITE;
+
+		for (i = 0, j = 7; i < 8; i++, j--)
+			ptable.val[i] = (rpar->iaddr.i6addr[j] & 0xFFFF);
+
+		ptable.val[8] &= ~(1 << 15);
+		ptable.val[8] |= (1 << 15);
+	}
+
+	route_table_write(cdev, &ptable);
+	return GSW_statusOk;
+}
+
+/* Routing IP Table */
+static int rt_ip_tbl_write(void *cdev,
+			   rt_table_handle_t *rtbl, riptbl_t *rpar)
+{
+	int pcindex = -1;
+
+	if (rpar->itype == GSW_RT_IP_V4) {
+		pcindex = sw_ip_tbl_write(rtbl->rt_ip_tbl,
+					  rtbl->rt_ip_tbl_cnt, rpar,
+					  sizeof(riptbl_t), RT_IP_TBL_SIZE, 0);
+	} else if (rpar->itype == GSW_RT_IP_V6) {
+		pcindex = sw_ip_tbl_write(rtbl->rt_ip_tbl,
+					  rtbl->rt_ip_tbl_cnt, rpar,
+					  sizeof(riptbl_t), RT_IP_TBL_SIZE, 1);
+	}
+
+	if (pcindex < 0)
+		return -1;
+
+	rt_iptable_wr(cdev, pcindex, rpar);
+	return pcindex;
+}
+
+/* IP DA/SA lsb Table delete */
+static int rt_ip_tbl_delete(void *cdev,
+			    rt_table_handle_t *rtbl, int index)
+{
+	pctbl_prog_t ptable;
+
+	RT_ASSERT(index >= RT_IP_TBL_SIZE);
+
+	if (rtbl->rt_ip_tbl_cnt[index] > 0)
+		rtbl->rt_ip_tbl_cnt[index]--;
+
+	if (rtbl->rt_ip_tbl_cnt[index] == 0) {
+		memset((((char *)rtbl->rt_ip_tbl) + (index * sizeof(riptbl_t))),
+		       0, sizeof(riptbl_t));
+		memset(&ptable, 0, sizeof(pctbl_prog_t));
+		ptable.table = PCE_R_IP_INDEX;
+		ptable.op_mode = OPMOD_IPv4_WRITE;
+		ptable.pcindex = index;
+		route_table_write(cdev, &ptable);
+	}
+
+	return 0;
+}
+
+static int rt_mtutable_wr(void *cdev, u16 index,
+			  rt_mtu_tbl_t *rpar)
+{
+	/*ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);*/
+	pctbl_prog_t ptable;
+	memset(&ptable, 0, sizeof(ptable));
+	ptable.table = PCE_R_MTU_INDEX;
+	ptable.pcindex = index;
+	ptable.op_mode = OPMOD_ADDRESS_WRITE;
+	ptable.val[0] = rpar->mtsize;
+	route_table_write(cdev, &ptable);
+	return GSW_statusOk;
+}
+
+/* MTU Table Write */
+static int rt_mtu_tbl_write(void *cdev,
+			    rt_table_handle_t *rtbl, rt_mtu_tbl_t *rpar)
+{
+	int pcindex;
+	pcindex = rt_tbl_write(rtbl->rt_mtu_tbl, rtbl->rt_mtu_tbl_cnt,
+			       rpar,	sizeof(rt_mtu_tbl_t), RT_MTU_TBL_SIZE);
+
+	if (pcindex < 0)
+		return -1;
+
+	rt_mtutable_wr(cdev, pcindex, rpar);
+	return pcindex;
+}
+
+/* MTU Table Delete */
+static int rt_mtu_tbl_delete(void *cdev,
+			     rt_table_handle_t *rtbl, u32 index)
+{
+	pctbl_prog_t ptable;
+
+	RT_ASSERT(index >= RT_MTU_TBL_SIZE);
+
+	if (rtbl->rt_mtu_tbl_cnt[index] > 0)
+		rtbl->rt_mtu_tbl_cnt[index]--;
+
+	if (rtbl->rt_mtu_tbl_cnt[index] == 0) {
+		memset((((char *)rtbl->rt_mtu_tbl) +
+			(index * sizeof(rt_mtu_tbl_t))),
+		       0, sizeof(rt_mtu_tbl_t));
+		memset(&ptable, 0, sizeof(pctbl_prog_t));
+		ptable.table = PCE_R_MTU_INDEX;
+		ptable.op_mode = OPMOD_ADDRESS_WRITE;
+		ptable.pcindex = index;
+		route_table_write(cdev, &ptable);
+	}
+
+	return 0;
+}
+
+static int rt_mtutable_rd(void *cdev,
+			  u16 index, rt_mtu_tbl_t *rpar)
+{
+	/*ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);*/
+	pctbl_prog_t ptable;
+	memset(&ptable, 0, sizeof(ptable));
+	ptable.table	= PCE_R_MTU_INDEX;
+	ptable.pcindex	= index;
+	ptable.op_mode = OPMOD_ADDRESS_READ;
+	route_table_read(cdev, &ptable);
+	rpar->mtsize = ptable.val[0] & 0x3FFF;
+	return GSW_statusOk;
+}
+
+static int rt_mactable_wr(void *cdev, int index,
+			  rt_mac_tbl_t *rpar)
+{
+	/*ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);*/
+	pctbl_prog_t ptable;
+	memset(&ptable, 0, sizeof(ptable));
+	ptable.table	= PCE_R_MAC_INDEX;
+	ptable.pcindex	= index;
+	ptable.op_mode = OPMOD_ADDRESS_WRITE;
+	ptable.val[0] = rpar->mdata[4] << 8 | rpar->mdata[5];
+	ptable.val[1] = rpar->mdata[2] << 8 | rpar->mdata[3];
+	ptable.val[2] = rpar->mdata[0] << 8 | rpar->mdata[1];
+	route_table_write(cdev, &ptable);
+	return GSW_statusOk;
+}
+
+/* MAC DA/SA Table index write */
+static int rt_mac_tbl_write(void *cdev,
+			    rt_table_handle_t *rtbl, rt_mac_tbl_t *rpar)
+{
+	int pcindex;
+
+	pcindex = sw_mac_tbl_write(rtbl->rt_mac_tbl,
+				   rtbl->rt_mac_tbl_cnt, rpar,
+				   sizeof(rt_mac_tbl_t), RT_MAC_TBL_SIZE);
+
+	if (pcindex < 0)
+		return -1;
+
+	rt_mactable_wr(cdev, pcindex, rpar);
+	return pcindex;
+}
+
+/* MAC DA/SA Table delete */
+static int rt_mac_tbl_delete(void *cdev,
+			     rt_table_handle_t *rtbl, u32 index)
+{
+	pctbl_prog_t ptable;
+
+	RT_ASSERT(index >= RT_MAC_TBL_SIZE);
+
+	if (rtbl->rt_mac_tbl_cnt[index] > 0)
+		rtbl->rt_mac_tbl_cnt[index]--;
+
+	if (rtbl->rt_mac_tbl_cnt[index] == 0) {
+		memset((((char *)rtbl->rt_mac_tbl) +
+			(index * sizeof(rt_mac_tbl_t))),
+		       0, sizeof(rt_mac_tbl_t));
+		/* initialize the data structure before using it */
+		memset(&ptable, 0, sizeof(pctbl_prog_t));
+		ptable.table = PCE_R_MAC_INDEX;
+		ptable.op_mode = OPMOD_ADDRESS_WRITE;
+		ptable.pcindex = index;
+		route_table_write(cdev, &ptable);
+	}
+
+	return 0;
+}
+
+static int rt_mactable_rd(void *cdev,
+			  int index, rt_mac_tbl_t *rpar)
+{
+	/*ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);*/
+	pctbl_prog_t ptable;
+	memset(&ptable, 0, sizeof(ptable));
+	ptable.table	= PCE_R_MAC_INDEX;
+	ptable.pcindex	= index;
+	ptable.op_mode = OPMOD_ADDRESS_READ;
+	route_table_read(cdev, &ptable);
+	rpar->mdata[0] = ptable.val[2] >> 8;
+	rpar->mdata[1] = ptable.val[2] & 0xFF;
+	rpar->mdata[2] = ptable.val[1] >> 8;
+	rpar->mdata[3] = ptable.val[1] & 0xFF;
+	rpar->mdata[4] = ptable.val[0] >> 8;
+	rpar->mdata[5] = ptable.val[0] & 0xFF;
+	return GSW_statusOk;
+}
+
+static int rt_ppoetable_rd(void *cdev,
+			   int index, rt_ppoe_tbl_t *rpar)
+{
+	/*ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);*/
+	pctbl_prog_t ptable;
+
+	memset(&ptable, 0, sizeof(ptable));
+	ptable.table	= PCE_R_PPPOE_INDEX;
+	ptable.pcindex	= index;
+	ptable.op_mode = OPMOD_ADDRESS_READ;
+	route_table_read(cdev, &ptable);
+	rpar->psesid = ptable.val[0];
+	return GSW_statusOk;
+}
+
+static int rt_ppoetable_wr(void *cdev,
+			   int index, rt_ppoe_tbl_t *rpar)
+{
+	/*ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);*/
+	pctbl_prog_t ptable;
+
+	memset(&ptable, 0, sizeof(ptable));
+	ptable.table = PCE_R_PPPOE_INDEX;
+	ptable.pcindex = index;
+	ptable.op_mode = OPMOD_ADDRESS_WRITE;
+	ptable.val[0]	= rpar->psesid;
+	ptable.valid = 1;
+	route_table_write(cdev, &ptable);
+	return GSW_statusOk;
+}
+
+/* PPPoE Table Write */
+static int rt_pppoe_tbl_write(void *cdev,
+			      rt_table_handle_t *rtbl, rt_ppoe_tbl_t *rpar)
+{
+	int pcindex;
+	pcindex = rt_tbl_write(rtbl->rt_ppoe_tbl,
+			       rtbl->rt_ppoe_tbl_cnt,
+			       rpar,	sizeof(rt_ppoe_tbl_t), RT_PPPOE_TBL_SIZE);
+
+	if (pcindex < 0)
+		return -1;
+
+	rt_ppoetable_wr(cdev, pcindex, rpar);
+	return pcindex;
+}
+
+/* PPPoE Table Delete */
+static int rt_pppoe_tbl_delete(void *cdev,
+			       rt_table_handle_t *rtbl, u32 index)
+{
+	pctbl_prog_t ptable;
+
+	RT_ASSERT(index >= RT_PPPOE_TBL_SIZE);
+
+	if (rtbl->rt_ppoe_tbl_cnt[index] > 0)
+		rtbl->rt_ppoe_tbl_cnt[index]--;
+
+	if (rtbl->rt_ppoe_tbl_cnt[index] == 0) {
+		memset((((char *)rtbl->rt_ppoe_tbl) +
+			(index * sizeof(rt_ppoe_tbl_t))),
+		       0, sizeof(rt_ppoe_tbl_t));
+		memset(&ptable, 0, sizeof(pctbl_prog_t));
+		ptable.table = PCE_R_PPPOE_INDEX;
+		ptable.op_mode = OPMOD_ADDRESS_WRITE;
+		ptable.pcindex	= index;
+		route_table_write(cdev, &ptable);
+	}
+
+	return 0;
+}
+
+static int rt_rtptable_cnt_clr(void *cdev, int index)
+{
+	/*ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);*/
+	pctbl_prog_t ptable;
+
+	memset(&ptable, 0, sizeof(ptable));
+	ptable.table = PCE_R_RTP_INDEX;
+	ptable.pcindex = index;
+	ptable.op_mode = OPMOD_ADDRESS_WRITE;
+	ptable.val[0] = 0;
+	ptable.val[1] = 0;
+	route_table_write(cdev, &ptable);
+	return GSW_statusOk;
+}
+
+static int rt_rtptable_rd(void *cdev, int index,
+			  rt_rtp_tbl_t *rtptableentry)
+{
+	/*ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);*/
+	pctbl_prog_t ptable;
+
+	memset(&ptable, 0, sizeof(ptable));
+	ptable.table	= PCE_R_RTP_INDEX;
+	ptable.pcindex	= index;
+	ptable.op_mode = OPMOD_ADDRESS_READ;
+	route_table_read(cdev, &ptable);
+	rtptableentry->rtpseqnum = ptable.val[1]; //swapped in hw implementation
+	rtptableentry->rtpsespcnt = ptable.val[0]; //swapped in hw impementation
+	return GSW_statusOk;
+}
+
+int calhash(const u8 *data, size_t len)
+{
+	int crc = 0, i;
+
+	if (len)
+		do {
+			crc ^= ((*data) << 8);
+			data++;
+
+			for (i = 0; i < 8; i++) {
+				if (crc & 0x8000)
+					crc = (crc << 1) ^ 0x1021;
+				else
+					crc <<= 1;
+
+				crc = crc & 0xFFFF;
+			}
+		} while (--len);
+
+	return crc;
+}
+
+int pae_hash_index(GSW_ROUTE_Entry_t *rpar)
+{
+	u8 hdata[13] = {0};
+	int i, j, hashc;
+
+	if (rpar->routeEntry.pattern.eIpType == GSW_RT_IP_V4) {
+		for (i = 0; i < 4; i++)
+			hdata[i] =
+				((rpar->routeEntry.pattern.nSrcIP.nIPv4 >>
+				  ((3 - i) * 8)) & 0xFF);
+
+		for (i = 0; i < 4; i++)
+			hdata[i + 4] =
+				((rpar->routeEntry.pattern.nDstIP.nIPv4 >>
+				  ((3 - i) * 8)) & 0xFF);
+	} else if (rpar->routeEntry.pattern.eIpType == GSW_RT_IP_V6) {
+		u32 ip6data[4];
+		u32 xdata;
+
+		for (i = 0, j = 0; i < 4; i++, j += 2) {
+			ip6data[i] =
+				((rpar->routeEntry.pattern.nSrcIP.nIPv6[j] << 16) |
+				 ((rpar->routeEntry.pattern.nSrcIP.nIPv6[j + 1])));
+		}
+
+		xdata = (ip6data[0] ^ ip6data[1] ^ ip6data[2] ^ ip6data[3]);
+
+		for (i = 0; i < 4; i++)
+			hdata[i] = ((xdata >> ((3 - i) * 8)) & 0xFF);
+
+		for (i = 0, j = 0; i < 4; i++, j += 2) {
+			ip6data[i] =
+				((rpar->routeEntry.pattern.nDstIP.nIPv6[j] << 16) |
+				 ((rpar->routeEntry.pattern.nDstIP.nIPv6[j + 1])));
+		}
+
+		xdata = (ip6data[0] ^ ip6data[1] ^ ip6data[2] ^ ip6data[3]);
+
+		for (i = 0; i < 4; i++)
+			hdata[i + 4] = ((xdata >> ((3 - i) * 8)) & 0xFF);
+	}
+
+	for (i = 0; i < 2; i++)
+		hdata[i + 8] =
+			((rpar->routeEntry.pattern.nSrcPort >> ((1 - i) * 8)) & 0xFF);
+
+	for (i = 0; i < 2; i++)
+		hdata[i + 10] =
+			((rpar->routeEntry.pattern.nDstPort >> ((1 - i) * 8)) & 0xFF);
+
+	hdata[12] = rpar->routeEntry.pattern.nRoutExtId & 0xFF;
+
+	hashc = calhash(hdata, sizeof(hdata));
+	return hashc & 0xFFF;
+}
+
+int rt_free_entry(void *cdev, int free_index)
+{
+	int temp1, temp2;
+	pctbl_prog_t ptable;
+	memset(&ptable, 0, sizeof(pctbl_prog_t));
+	rthandler->rstbl.node[free_index].fflag = 1;
+	rthandler->rstbl.nfentries++;
+
+	if ((rthandler->rstbl.node[free_index].pprt == -1) &&
+	    (rthandler->rstbl.node[free_index].nptr != -1)) {
+		temp2 = rthandler->rstbl.node[free_index].nptr;
+		rthandler->rstbl.node[temp2].pprt = -1;
+	} else if ((rthandler->rstbl.node[free_index].pprt != -1)
+		   && (rthandler->rstbl.node[free_index].nptr == -1)) {
+		temp1 = rthandler->rstbl.node[free_index].pprt;
+		rthandler->rstbl.node[temp1].nptr = -1;
+		rthandler->rstbl.hw_table[temp1].hwnextptr = temp1;
+//		rthandler->rstbl.hw_table[temp1].hwvalid = 1;
+		memset(&ptable, 0, sizeof(pctbl_prog_t));
+		ptable.table	= PCE_R_SESSION_INDEX;
+		ptable.pcindex	= temp1;
+		ptable.op_mode = OPMOD_ADDRESS_READ;
+		route_table_read(cdev, &ptable);
+
+		ptable.table	= PCE_R_SESSION_INDEX;
+		ptable.pcindex = temp1;
+		ptable.valid = 1;
+		ptable.key[5] = rthandler->rstbl.hw_table[temp1].hwnextptr;
+		ptable.key[4] &= ~(1 << 15);
+		ptable.key[4] |= ((rthandler->rstbl.hw_table[temp1].hwvalid) << 15);
+		ptable.op_mode = OPMOD_RT_SESSION_NEXT;
+		route_table_write(cdev, &ptable);
+	} else if ((rthandler->rstbl.node[free_index].pprt != -1)
+		   && (rthandler->rstbl.node[free_index].nptr != -1)) {
+		temp1 = rthandler->rstbl.node[free_index].pprt;
+		temp2 = rthandler->rstbl.node[free_index].nptr;
+		rthandler->rstbl.node[temp2].pprt = temp1;
+		rthandler->rstbl.node[temp1].nptr = temp2;
+		rthandler->rstbl.hw_table[temp1].hwnextptr = temp2;
+//		rthandler->rstbl.hw_table[temp1].hwvalid = 1;
+		memset(&ptable, 0, sizeof(pctbl_prog_t));
+		ptable.table	= PCE_R_SESSION_INDEX;
+		ptable.pcindex	= temp1;
+		ptable.op_mode = OPMOD_ADDRESS_READ;
+		route_table_read(cdev, &ptable);
+
+		ptable.table	= PCE_R_SESSION_INDEX;
+		ptable.pcindex = temp1;
+		ptable.valid = 1;
+		ptable.key[5] = rthandler->rstbl.hw_table[temp1].hwnextptr;
+		ptable.key[4] &= ~(1 << 15);
+		ptable.key[4] |= ((rthandler->rstbl.hw_table[temp1].hwvalid) << 15);
+		ptable.op_mode = OPMOD_RT_SESSION_NEXT;
+		route_table_write(cdev, &ptable);
+	}
+
+	if (rthandler->rstbl.nfentries <= 1) {
+		rthandler->rstbl.ffptr = free_index;
+		rthandler->rstbl.lfptr = free_index;
+		rthandler->rstbl.node[free_index].nptr = -1;
+		rthandler->rstbl.node[free_index].pprt = -1;
+	} else {
+		temp1 = rthandler->rstbl.lfptr;
+		rthandler->rstbl.lfptr = free_index;
+		rthandler->rstbl.node[free_index].pprt = temp1;
+		rthandler->rstbl.node[temp1].nptr = free_index;
+		rthandler->rstbl.node[free_index].nptr = -1;
+	}
+
+	rthandler->rstbl.hw_table[free_index].hwnextptr = free_index;
+	rthandler->rstbl.hw_table[free_index].hwvalid = 0;
+	memset(&ptable, 0, sizeof(pctbl_prog_t));
+	memset(&ptable, 0, sizeof(pctbl_prog_t));
+	ptable.table	= PCE_R_SESSION_INDEX;
+	ptable.pcindex	= free_index;
+	ptable.op_mode = OPMOD_ADDRESS_READ;
+	route_table_read(cdev, &ptable);
+	ptable.table	= PCE_R_SESSION_INDEX;
+	ptable.pcindex = free_index;
+	ptable.valid = 0;
+	ptable.key[5] = rthandler->rstbl.hw_table[free_index].hwnextptr;
+	ptable.key[4] &= ~(1 << 15);
+	ptable.key[4] |= ((rthandler->rstbl.hw_table[free_index].hwvalid) << 15);
+	ptable.op_mode = OPMOD_RT_SESSION_NEXT;
+	route_table_write(cdev, &ptable);
+	return GSW_statusOk;
+}
+
+int GSW_ROUTE_SessionEntryAdd(void *cdev, GSW_ROUTE_Entry_t *rpar)
+{
+	ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t ptable;
+	int hindex, tab_index, i, index, retval = GSW_statusErr;
+	int sindex, dindex, aindex, smindex, dmindex, ppindex, tuindex, rrindex, mtindex = 0xFF;
+	riptbl_t  dstip, srcip;
+	rt_mtu_tbl_t mtval;
+
+	if (ethdev == NULL) {
+		pr_err("%s:%s:%d \n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&ethdev->lock_pae);
+#endif
+
+
+	if ((ethdev->gipver == LTQ_GSWIP_3_0)	&& ((ethdev->gsw_dev == LTQ_FLOW_DEV_INT_R))) {
+		if (rpar->nHashVal < 0) {
+			/* calculate hash index */
+			hindex = pae_hash_index(rpar);
+		} else {
+			hindex = rpar->nHashVal;
+		}
+
+		index = hindex;
+		memset(&ptable, 0, sizeof(pctbl_prog_t));
+		tab_index = 0x7FFF;
+		sindex = tab_index;
+		dindex = tab_index;
+		aindex = tab_index;
+
+		if (rpar->routeEntry.pattern.eIpType == GSW_RT_IP_V4) {
+			memset(&dstip, 0, sizeof(riptbl_t));
+			memset(&srcip, 0, sizeof(riptbl_t));
+			dstip.itype = GSW_RT_IP_V4;
+			srcip.itype = GSW_RT_IP_V4;
+
+			for (i = 0; i < 4; i++) {
+				dstip.iaddr.i4addr[i] =
+					((rpar->routeEntry.pattern.nDstIP.nIPv4 >> (i * 8)) & 0xFF);
+				srcip.iaddr.i4addr[i] =
+					((rpar->routeEntry.pattern.nSrcIP.nIPv4 >> (i * 8)) & 0xFF);
+			}
+
+			dstip.valid = 1;
+			tab_index = rt_ip_tbl_write(cdev, &rthandler->rt_sub_tbl, &dstip);
+
+			if (tab_index < 0) {
+				retval = GSW_ROUTE_ERROR_IP_FULL;
+				goto UNLOCK_AND_RETURN;
+			} else {
+				sindex = tab_index;
+			}
+
+			ptable.key[0] = (tab_index & 0x7FF);
+
+			srcip.valid = 1;
+			tab_index = rt_ip_tbl_write(cdev, &rthandler->rt_sub_tbl, &srcip);
+
+			if (tab_index < 0) {
+				retval = GSW_ROUTE_ERROR_IP_FULL;
+				goto errexit1;
+			} else {
+				dindex = tab_index;
+			}
+
+			ptable.key[1] = (tab_index & 0x7FF);
+		} else if (rpar->routeEntry.pattern.eIpType == GSW_RT_IP_V6) {
+			memset(&dstip, 0, sizeof(riptbl_t));
+			memset(&srcip, 0, sizeof(riptbl_t));
+			dstip.itype = GSW_RT_IP_V6;
+			srcip.itype = GSW_RT_IP_V6;
+
+			for (i = 0;  i < 8; i++) {
+				dstip.iaddr.i6addr[i] = (rpar->routeEntry.pattern.nDstIP.nIPv6[i]);
+				srcip.iaddr.i6addr[i] = (rpar->routeEntry.pattern.nSrcIP.nIPv6[i]);
+			}
+
+			dstip.valid = 1;
+			tab_index = rt_ip_tbl_write(cdev, &rthandler->rt_sub_tbl, &dstip);
+
+			if (tab_index < 0) {
+				retval = GSW_ROUTE_ERROR_IP_FULL;
+				goto UNLOCK_AND_RETURN;
+			} else {
+				sindex = tab_index;
+			}
+
+			ptable.key[0] = (tab_index & 0x7FF);
+			srcip.valid = 1;
+			tab_index = rt_ip_tbl_write(cdev, &rthandler->rt_sub_tbl, &srcip);
+
+			if (tab_index < 0) {
+				retval = GSW_ROUTE_ERROR_IP_FULL;
+				goto errexit1;
+			} else {
+				dindex = tab_index;
+			}
+
+			ptable.key[1] = (tab_index & 0x7FF);
+		} else {
+			ptable.key[0] = (tab_index & 0x7FF);
+			ptable.key[1] = (tab_index & 0x7FF);
+		}
+
+		ptable.key[2] = rpar->routeEntry.pattern.nDstPort;
+		ptable.key[3] = rpar->routeEntry.pattern.nSrcPort;
+		ptable.key[4] = rpar->routeEntry.pattern.nRoutExtId & 0xFF;
+		/* Destination Port Map  */
+		ptable.val[0] = (rpar->routeEntry.action.nDstPortMap & 0xFFFF);
+		/*Destination Sub-Interface ID*/
+		ptable.val[1] = ((rpar->routeEntry.action.nDstSubIfId & 0x1FFF) << 3);
+
+		/* New IP Address Index */
+		tab_index = 0x7FFF;
+
+		if (rpar->routeEntry.action.eIpType == GSW_RT_IP_V4) {
+			memset(&dstip, 0, sizeof(riptbl_t));
+			dstip.itype = GSW_RT_IP_V4;
+
+			for (i = 0; i < 4; i++)
+				dstip.iaddr.i4addr[i] =
+					((rpar->routeEntry.action.nNATIPaddr.nIPv4 >> (i * 8)) & 0xFF);
+
+			dstip.valid = 1;
+			tab_index = rt_ip_tbl_write(cdev, &rthandler->rt_sub_tbl, &dstip);
+
+			if (tab_index < 0) {
+				retval = GSW_ROUTE_ERROR_IP_FULL;
+				goto errexit2;
+			} else {
+				aindex = tab_index;
+			}
+		} else if (rpar->routeEntry.action.eIpType == GSW_RT_IP_V6) {
+			memset(&dstip, 0, sizeof(riptbl_t));
+			dstip.itype = GSW_RT_IP_V6;
+
+			for (i = 0; i < 8; i++)
+				dstip.iaddr.i6addr[i] = (rpar->routeEntry.action.nNATIPaddr.nIPv6[i]);
+
+			dstip.valid = 1;
+			tab_index = rt_ip_tbl_write(cdev, &rthandler->rt_sub_tbl, &dstip);
+
+			if (tab_index < 0) {
+				retval = GSW_ROUTE_ERROR_IP_FULL;
+				goto errexit2;
+			} else {
+				aindex = tab_index;
+			}
+		}
+
+		ptable.val[2] = tab_index & 0x7FF;
+
+		/* New UDP/TCP Port */
+		ptable.val[3] = rpar->routeEntry.action.nTcpUdpPort;
+
+		/* MTU Index */
+		memset(&mtval, 0, sizeof(rt_mtu_tbl_t));
+		/*Programme +1 for MTU value, due to < MTU check in HW instead of <= MTU*/
+		mtval.mtsize = (rpar->routeEntry.action.nMTUvalue + 1);
+		mtval.valid = 1;
+		mtval.mtsize = (rpar->routeEntry.action.nMTUvalue + 1);
+		tab_index = rt_mtu_tbl_write(cdev, &rthandler->rt_sub_tbl, &mtval);
+
+		if (tab_index < 0) {
+			retval = GSW_ROUTE_ERROR_MTU_FULL;
+			goto errexit3;
+		} else {
+			mtindex = tab_index;
+		}
+
+		ptable.val[4] |= (tab_index & 0x7);
+
+		/* New Source MAC Address Index */
+		if (rpar->routeEntry.action.bMAC_SrcEnable == 1) {
+			rt_mac_tbl_t src_mac_tbl;
+			memset(&src_mac_tbl, 0, sizeof(rt_mac_tbl_t));
+
+			/* Destination MAC address */
+			for (i = 0; i < 6; i++)
+				src_mac_tbl.mdata[i] =
+					rpar->routeEntry.action.nSrcMAC[i];
+
+			src_mac_tbl.valid = 1;
+			tab_index = rt_mac_tbl_write(cdev, &rthandler->rt_sub_tbl, &src_mac_tbl);
+
+			if (tab_index < 0) {
+				retval = GSW_ROUTE_ERROR_MAC_FULL;
+				goto errexit4;
+			} else {
+				smindex = tab_index;
+			}
+
+			ptable.val[4] |= ((tab_index & 0x3FF) << 8);
+		} else {
+			ptable.val[4] |= (0 << 8);
+			smindex = 0;
+		}
+
+		/* New Destination MAC Address Index */
+		if (rpar->routeEntry.action.bMAC_DstEnable == 1) {
+			rt_mac_tbl_t dst_mac_tbl;
+			memset(&dst_mac_tbl, 0, sizeof(rt_mac_tbl_t));
+
+			/* Destination MAC address */
+			for (i = 0; i < 6; i++)
+				dst_mac_tbl.mdata[i] =
+					rpar->routeEntry.action.nDstMAC[i];
+
+			dst_mac_tbl.valid = 1;
+			tab_index = rt_mac_tbl_write(cdev, &rthandler->rt_sub_tbl, &dst_mac_tbl);
+
+			if (tab_index < 0) {
+				retval = GSW_ROUTE_ERROR_MAC_FULL;
+				goto errexit5;
+			} else {
+				dmindex = tab_index;
+			}
+
+			ptable.val[5] = ((tab_index) & 0x3FF);
+		} else {
+			ptable.val[5] = 0;
+			dmindex = 0;
+		}
+
+		ptable.val[8] |= rpar->routeEntry.action.nFID & 0x3F;
+		ptable.val[8] |= ((rpar->routeEntry.action.nFlowId & 0xFF) << 8);
+
+		if (rpar->routeEntry.action.bInnerDSCPRemark == 1)
+			ptable.val[9] |= rpar->routeEntry.action.nDSCP & 0x3F;
+
+		if (rpar->routeEntry.action.bTCremarking == 1)
+			ptable.val[9] |= ((rpar->routeEntry.action.nTrafficClass & 0xF) << 8);
+
+		/*ptable.val[10] = rpar->routeEntry.action.nSessionCtrs & 0xFFFF;*/
+		/*ptable.val[11] = (rpar->routeEntry.action.nSessionCtrs >> 16) & 0xFFFF;*/
+
+		ptable.val[10] = 0;
+		ptable.val[11] = 0;
+
+		if (rpar->routeEntry.action.eSessDirection == 1)
+			ptable.val[12] |= (1 << 0);
+		else
+			ptable.val[12] &= ~(1 << 0);
+
+		if (rpar->routeEntry.action.bPPPoEmode == 1) {
+			/* New PPPoE Index Index */
+			rt_ppoe_tbl_t sesid;
+			sesid.psesid = rpar->routeEntry.action.nPPPoESessId;
+			tab_index = rt_pppoe_tbl_write(cdev, &rthandler->rt_sub_tbl, &sesid);
+
+			if (tab_index < 0) {
+				retval = GSW_ROUTE_ERROR_PPPOE_FULL;
+				goto errexit6;
+			} else {
+				ppindex = tab_index;
+			}
+
+			ptable.val[6] |= (tab_index & 0xF);
+			ptable.val[12] |= (1 << 1);
+		} else {
+			ptable.val[12] &= ~(1 << 1);
+			ptable.val[6] |= 0;
+			ppindex = 0xFF;
+		}
+
+		if (rpar->routeEntry.action.bRTPMeasEna == 1) {
+			/*  Routing RTP Table Index */
+			rt_rtp_tbl_t rtp_tbl;
+			memset(&rtp_tbl, 0, sizeof(rt_rtp_tbl_t));
+
+			ptable.val[7] |= ((rpar->routeEntry.action.nRTPSeqNumber & 0x3F) << 8);
+			rt_rtptable_cnt_clr(cdev, (rpar->routeEntry.action.nRTPSeqNumber & 0x3F));
+
+			ptable.val[12] |= (1 << 11);
+		} else {
+			ptable.val[12] &= ~(1 << 11);
+			ptable.val[7] |= (0x3F << 8);
+			rrindex = 0x3F;
+		}
+
+		switch (rpar->routeEntry.action.eSessRoutingMode) {
+			ptable.val[12] &= ~(3 << 2);
+
+		case GSW_ROUTE_MODE_NULL:
+			ptable.val[12] |= (0 << 2);
+			break;
+
+		case GSW_ROUTE_MODE_ROUTING:
+			ptable.val[12] |= (1 << 2);
+			break;
+
+		case GSW_ROUTE_MODE_NAT:
+			ptable.val[12] |= (2 << 2);
+			break;
+
+		case GSW_ROUTE_MODE_NAPT:
+			ptable.val[12] |= (3 << 2);
+			break;
+
+		default:
+			ptable.val[12] |= (0 << 2);
+		}
+
+		/* Tunnel Index */
+		if (rpar->routeEntry.action.bTunnel_Enable == 1) {
+			ptable.val[12] &= ~(3 << 4);
+
+			switch (rpar->routeEntry.action.eTunType) {
+			case GSW_ROUTE_TUNL_NULL:
+				ptable.val[12] |= (0 << 4);
+				break;
+
+			case GSW_ROUTE_TUNL_6RD:
+				ptable.val[12] |= (1 << 4);
+				break;
+
+			case GSW_ROUTE_TUNL_DSLITE:
+				ptable.val[12] |= (2 << 4);
+				break;
+
+			case GSW_ROUTE_TUNL_L2TP:
+				if (rpar->routeEntry.pattern.eIpType == GSW_RT_IP_V4) {
+					ptable.val[12] |= (2 << 4);
+				} else if (rpar->routeEntry.pattern.eIpType == GSW_RT_IP_V6) {
+					ptable.val[12] |= (1 << 4);
+				}
+
+				break;
+
+			case GSW_ROUTE_TUNL_IPSEC:
+				ptable.val[12] |= (3 << 4);
+				break;
+
+			default:
+				ptable.val[12] |= (0 << 4);
+			}
+
+			ptable.val[6] |=
+				((rpar->routeEntry.action.nTunnelIndex & 0xF) << 8);
+			tuindex = rpar->routeEntry.action.nTunnelIndex;
+		} else {
+			ptable.val[6] |= (0 << 8);
+			tuindex = 0xFF;
+		}
+
+		switch (rpar->routeEntry.action.eOutDSCPAction) {
+			ptable.val[12] &= ~(3 << 6);
+
+		case GSW_ROUTE_OUT_DSCP_NULL:
+			ptable.val[12] |= (0 << 6);
+			break;
+
+		case GSW_ROUTE_OUT_DSCP_INNER:
+			ptable.val[12] |= (1 << 6);
+			break;
+
+		case GSW_ROUTE_OUT_DSCP_SESSION:
+			ptable.val[12] |= (2 << 6);
+			break;
+
+		case GSW_ROUTE_OUT_DSCP_RES:
+			ptable.val[12] |= (3 << 6);
+			break;
+
+		default:
+			ptable.val[12] |= (0 << 6);
+		}
+
+		if (rpar->routeEntry.action.bInnerDSCPRemark == 1)
+			ptable.val[12] |= (1 << 8);
+		else
+			ptable.val[12] &= ~(1 << 8);
+
+		if (rpar->routeEntry.action.bTCremarking == 1)
+			ptable.val[12] |= (1 << 9);
+		else
+			ptable.val[12] &= ~(1 << 9);
+
+		if (rpar->routeEntry.action.bMeterAssign == 1) {
+			ptable.val[12] |= (1 << 10);
+			ptable.val[7] = rpar->routeEntry.action.nMeterId & 0x3F;
+		} else
+			ptable.val[12] &= ~(1 << 10);
+
+		if (rpar->routeEntry.action.bTTLDecrement == 1)
+			ptable.val[12] |= (1 << 12);
+		else
+			ptable.val[12] &= ~(1 << 12);
+
+		if (rpar->routeEntry.action.bHitStatus == 1)
+			ptable.val[12] |= (1 << 15);
+		else
+			ptable.val[12] &= ~(1 << 15);
+
+		{
+			int  step = 0, success = 0;
+start:
+
+			if (rthandler->rstbl.node[index].vflag == 1) {
+				/* If entry is  valid , check its next */
+				/* entry in the search link list*/
+				if (rthandler->rstbl.node[index].nptr == -1) {
+					/* This entry is the last node of the */
+					/* search link list*/
+					if (rthandler->rstbl.nfentries == 0) {
+						/* if no free entry, cannot add this session. */
+						if (rpar->bPrio == 1) {
+							retval = GSW_ROUTE_F_SWAP_OUT_ERR /*GSW_ROUTE_F_SWAP_OUT*/;
+							goto errexit;
+						} else {
+							retval = GSW_ROUTE_ERROR_RT_SESS_FULL;
+							goto errexit;
+						}
+					} else {
+						int temp;
+						success = 1;
+						/* Get free entry from the head of the free link list , add this session. */
+						rthandler->rstbl.node[hindex].nventries++;
+						temp = index;
+						index = rthandler->rstbl.ffptr;
+						rthandler->rstbl.node[index].hval = hindex; /* Store the hash value*/
+						rthandler->rstbl.node[index].vflag = 1;
+						/* TODO: Session info add for a index */
+						rthandler->rstbl.nfentries--;
+						rthandler->rstbl.nuentries++;
+						rthandler->rstbl.ffptr = rthandler->rstbl.node[index].nptr;
+						rthandler->rstbl.node[index].fflag = 0;
+						rthandler->rstbl.node[index].prio = rpar->bPrio;
+						rthandler->rstbl.node[temp].nptr = index;
+						rthandler->rstbl.node[index].pprt = temp;
+						rthandler->rstbl.node[index].nptr = -1;
+						/* Update the HW table */
+						/* Add this session to hardware table. It is last node of*/
+						/* this search link list. */
+						rthandler->rstbl.hw_table[index].hwvalid = 1;
+						rthandler->rstbl.hw_table[index].hwnextptr = index;
+						ptable.table = PCE_R_SESSION_INDEX;
+						ptable.pcindex = index;
+						ptable.valid = rthandler->rstbl.hw_table[index].hwvalid;
+						ptable.key[5] = rthandler->rstbl.hw_table[index].hwnextptr;
+						ptable.key[4] &= ~(1 << 15);
+						ptable.key[4] |= ((rthandler->rstbl.hw_table[index].hwvalid) << 15);
+						ptable.op_mode = OPMOD_ADDRESS_WRITE;
+						route_table_write(cdev, &ptable);
+						rpar->nRtIndex = index;
+						/* Update the HW temp entry table */
+						/* Link previous entry to this new entry. */
+						/*rthandler->rstbl.hw_table[temp].hwvalid = 1;*/
+						rthandler->rstbl.hw_table[temp].hwnextptr = index;
+						memset(&ptable, 0, sizeof(pctbl_prog_t));
+						ptable.table	= PCE_R_SESSION_INDEX;
+						ptable.pcindex	= temp;
+						ptable.op_mode = OPMOD_ADDRESS_READ;
+						route_table_read(cdev, &ptable);
+
+						ptable.table	= PCE_R_SESSION_INDEX;
+						ptable.pcindex = temp; //rthandler->rstbl.hw_table[temp].hwnextptr;
+						ptable.valid = rthandler->rstbl.hw_table[temp].hwvalid;
+						ptable.key[5] = rthandler->rstbl.hw_table[temp].hwnextptr;
+						ptable.key[4] &= ~(1 << 15);
+						ptable.key[4] |= ((rthandler->rstbl.hw_table[temp].hwvalid) << 15);
+						ptable.op_mode = OPMOD_RT_SESSION_NEXT;
+						route_table_write(cdev, &ptable);
+
+						if (index == -1)
+							pr_err(" *SW BUG*** %s:%s:%d \n", __FILE__, __func__, __LINE__);
+
+						/*					rpar->nRtIndex = index;*/
+						retval = success;
+						goto UNLOCK_AND_RETURN;
+					}
+				} else {
+					/* Move to the next node of the search link list until the last node*/
+					/*or search step is greater than 15.*/
+					step++;
+
+					if (step >= 15) {
+						if (rpar->bPrio == 1) {
+							retval = GSW_ROUTE_F_SWAP_OUT_ERR /*GSW_ROUTE_F_SWAP_OUT*/;
+							goto errexit;
+						} else {
+							retval = GSW_ROUTE_ERROR_RT_COLL_FULL;
+							goto errexit;
+						}
+					} else {
+						index = rthandler->rstbl.node[index].nptr;
+						goto start;
+					}
+				}
+			} else {
+				success = 1;
+				/* If entry is not valid, can add the new session to this entry. */
+				rthandler->rstbl.node[hindex].nventries++;
+				rthandler->rstbl.node[index].hval = hindex; /* Store the hash value*/
+				rthandler->rstbl.node[index].vflag = 1;
+				rthandler->rstbl.node[index].prio = rpar->bPrio;
+				rthandler->rstbl.nuentries++;
+
+				/* TODO: Add Pattern */
+				if (rthandler->rstbl.node[index].fflag == 1) {
+					/* If this entry is free entry, */
+					/* remove it from free link list. */
+					rthandler->rstbl.node[index].fflag = 0;
+					rthandler->rstbl.nfentries--;
+
+					if (index == rthandler->rstbl.ffptr) {
+						rthandler->rstbl.ffptr = rthandler->rstbl.node[index].nptr;
+					} else {
+						if (index == rthandler->rstbl.lfptr) {
+							rthandler->rstbl.lfptr = rthandler->rstbl.node[index].pprt;
+						} else {
+							int temp1, temp2;
+							temp1 = rthandler->rstbl.node[index].pprt;
+							temp2 = rthandler->rstbl.node[index].nptr;
+							rthandler->rstbl.node[temp2].pprt = temp1;
+							rthandler->rstbl.node[temp1].nptr = temp2;
+						}
+					}
+
+					/* This entry is the single node for this hash. */
+					rthandler->rstbl.node[index].pprt = -1;
+					rthandler->rstbl.node[index].nptr = -1;
+					/*	Update the hardware data structure. This is the single node for */
+					/*	this search link list add this session to hardware table. */
+					/*	It is last node of this search link list. */
+					rthandler->rstbl.hw_table[index].hwvalid = 1;
+					rthandler->rstbl.hw_table[index].hwnextptr = index;
+					/* TODO: Session update*/
+					ptable.table	= PCE_R_SESSION_INDEX;
+					ptable.pcindex	= index;
+					ptable.valid = rthandler->rstbl.hw_table[index].hwvalid;
+					ptable.key[5] = rthandler->rstbl.hw_table[index].hwnextptr;
+					ptable.key[4] &= ~(1 << 15);
+					/*ptable.key[4] |= ((rpar->routeEntry.pattern.bValid & 1) << 15); */
+					ptable.key[4] |= ((rthandler->rstbl.hw_table[index].hwvalid) << 15);
+					ptable.op_mode = OPMOD_ADDRESS_WRITE;
+					route_table_write(cdev, &ptable);
+
+					if (index == -1)
+						pr_err(" *SW BUG*** %s:%s:%d \n", __FILE__, __func__, __LINE__);
+
+					rpar->nRtIndex = index;
+					retval = success;
+					goto UNLOCK_AND_RETURN;
+				} else {
+					/* If this entry is not free entry, just update hardware data structure */
+					/*to add this session.Next pointer in hardware will be unchanged since */
+					/*there are more entries in this search link list. */
+					/* Update the HW table */
+					/* Add this session to hardware table. It is last node */
+					/* of this search link list. */
+					rthandler->rstbl.hw_table[index].hwvalid = 1;
+					/*rthandler->rstbl.hw_table[index].hwnextptr = unchanged */;
+					/* TODO*/
+					ptable.table	= PCE_R_SESSION_INDEX;
+					ptable.pcindex	= index;
+					ptable.valid = rthandler->rstbl.hw_table[index].hwvalid;
+					ptable.key[5] = rthandler->rstbl.hw_table[index].hwnextptr;
+					ptable.key[4] &= ~(1 << 15);
+					ptable.key[4] |= ((rthandler->rstbl.hw_table[index].hwvalid) << 15);
+					ptable.op_mode = OPMOD_ADDRESS_WRITE;
+					route_table_write(cdev, &ptable);
+
+					if (index == -1)
+						pr_err(" * SW BUG*** %s:%s:%d \n", __FILE__, __func__, __LINE__);
+
+					rpar->nRtIndex = index;
+					retval = success;
+					goto UNLOCK_AND_RETURN;
+				}
+			}
+		}
+		retval = GSW_statusOk;
+		goto UNLOCK_AND_RETURN;
+
+errexit:
+
+		if (ppindex != 0xFF)
+			rt_pppoe_tbl_delete(cdev, &rthandler->rt_sub_tbl, ppindex);
+
+errexit6:
+
+		if (dmindex != 0x0)
+			rt_mac_tbl_delete(cdev, &rthandler->rt_sub_tbl, dmindex);
+
+errexit5:
+
+		if (smindex != 0x0)
+			rt_mac_tbl_delete(cdev, &rthandler->rt_sub_tbl, smindex);
+
+errexit4:
+
+		if (mtindex != 0xFF)
+			rt_mtu_tbl_delete(cdev, &rthandler->rt_sub_tbl, mtindex);
+
+errexit3:
+
+		if (aindex != 0x7FFF)
+			rt_ip_tbl_delete(cdev, &rthandler->rt_sub_tbl, aindex);
+
+errexit2:
+
+		if (dindex != 0x7FFF)
+			rt_ip_tbl_delete(cdev, &rthandler->rt_sub_tbl, dindex);
+
+errexit1:
+
+		if (sindex != 0x7FFF)
+			rt_ip_tbl_delete(cdev, &rthandler->rt_sub_tbl, sindex);
+
+		retval = GSW_statusOk;
+	} else {
+		retval = GSW_statusErr;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&ethdev->lock_pae);
+#endif
+	return retval;
+
+}
+
+int GSW_ROUTE_SessionEntryDel(void *cdev, GSW_ROUTE_Entry_t *rpar)
+{
+	ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);
+	int hindex,  index;
+	int retval = 0;
+
+	if (ethdev == NULL) {
+		pr_err("%s:%s:%d \n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&ethdev->lock_pae);
+#endif
+
+	if ((ethdev->gipver == LTQ_GSWIP_3_0)
+	    && ((ethdev->gsw_dev == LTQ_FLOW_DEV_INT_R))) {
+		pctbl_prog_t ptable;
+		memset(&ptable, 0, sizeof(pctbl_prog_t));
+		index = rpar->nRtIndex;
+
+		if ((index < 0) || (index >= 4096)) {
+			retval = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		hindex = rthandler->rstbl.node[index].hval;
+
+		if (rthandler->rstbl.node[index].vflag == 1) {
+			rthandler->rstbl.node[index].vflag = 0;
+
+			if (rthandler->rstbl.node[hindex].nventries == 0)
+				pr_err(" ****SW BUG ****: %s:%s:%d, hindex:%d, index:%d\n", __FILE__, __func__,
+				       __LINE__, hindex, index);
+
+			rthandler->rstbl.node[hindex].nventries--;
+			rthandler->rstbl.nuentries--;
+			rthandler->rstbl.node[index].vflag = 0;
+			rthandler->rstbl.node[index].prio = 0;
+			/*			rthandler->rstbl.node[index].fflag = 0;*/
+			/* Update the HW table*/
+			rthandler->rstbl.hw_table[index].hwvalid = 0;
+			/*	rthandler->rstbl.hw_table[index].hwnextptr = unchanged; */
+			ptable.table = PCE_R_SESSION_INDEX;
+			ptable.pcindex = index;
+			ptable.op_mode = OPMOD_ADDRESS_READ;
+			route_table_read(cdev, &ptable);
+
+			if (((ptable.key[4] >> 15) & 1) == 1) {
+				pctbl_prog_t rptable;
+				int pcindex;
+				memset(&rptable, 0, sizeof(pctbl_prog_t));
+				rptable.table	= PCE_R_SESSION_INDEX;
+				rptable.pcindex	= index;
+				rptable.op_mode = OPMOD_ADDRESS_WRITE;
+				rptable.valid = 0;
+				rptable.key[5] = rthandler->rstbl.hw_table[index].hwnextptr;
+				/*rptable.key[4] &= ~((rthandler->rstbl.hw_table[temp].hwvalid) << 15);*/
+				route_table_write(cdev, &rptable);
+				pcindex = (ptable.key[0] & 0xFFF);
+
+				if (pcindex != 0xFFF)
+					rt_ip_tbl_delete(cdev, &rthandler->rt_sub_tbl, pcindex);
+
+				pcindex = (ptable.key[1] & 0x7FF);
+
+				if (pcindex != 0xFFF)
+					rt_ip_tbl_delete(cdev, &rthandler->rt_sub_tbl, pcindex);
+
+				pcindex = (ptable.val[2] & 0xFFF);
+
+				if (pcindex != 0xFFF)
+					rt_ip_tbl_delete(cdev, &rthandler->rt_sub_tbl, pcindex);
+
+				pcindex = (ptable.val[4] & 0x7);
+
+				if (pcindex != 0xF)
+					rt_mtu_tbl_delete(cdev, &rthandler->rt_sub_tbl, pcindex);
+
+				pcindex = ((ptable.val[4] >> 8) & 0xFF);
+
+				if (pcindex != 0x0)
+					rt_mac_tbl_delete(cdev, &rthandler->rt_sub_tbl, pcindex);
+
+				pcindex = (ptable.val[5] & 0x1FF);
+
+				if (pcindex != 0x0)
+					rt_mac_tbl_delete(cdev, &rthandler->rt_sub_tbl, pcindex);
+
+				if ((ptable.val[12] >> 1) & 0x1) {
+					pcindex = (ptable.val[6] & 0xF);
+					rt_pppoe_tbl_delete(cdev, &rthandler->rt_sub_tbl, pcindex);
+				}
+			}
+
+			if ((rthandler->rstbl.node[hindex].nventries == 0) && (rthandler->rstbl.node[hindex].vflag == 0)) {
+				rt_free_entry(cdev, hindex);
+			}
+
+			if ((rthandler->rstbl.node[index].nventries == 0) && (index != hindex)) {
+				rt_free_entry(cdev, index);
+			}
+		} else {
+			pr_err(" No entry in the HW:%s:%s:%d, hindex:%d\n", __FILE__, __func__,
+			       __LINE__, rthandler->rstbl.node[index].hval);
+		}
+	} else {
+		retval = GSW_statusErr;
+	}
+
+	retval = GSW_statusOk;
+
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&ethdev->lock_pae);
+#endif
+	return retval;
+}
+
+int GSW_ROUTE_SessionEntryRead(void *cdev,
+			       GSW_ROUTE_Entry_t *rpar)
+{
+	ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);
+	u16 index;
+	int i, retval = 0;
+
+	if (ethdev == NULL) {
+		pr_err("%s:%s:%d \n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&ethdev->lock_pae);
+#endif
+
+	if ((ethdev->gipver == LTQ_GSWIP_3_0)
+	    && ((ethdev->gsw_dev == LTQ_FLOW_DEV_INT_R))) {
+		pctbl_prog_t ptable;
+		int hindex, rindex;
+		riptbl_t  iptbl;
+		rt_mtu_tbl_t mvalue;
+		rt_mac_tbl_t mentry;
+		memset(&ptable, 0, sizeof(pctbl_prog_t));
+		memset(&iptbl, 0, sizeof(riptbl_t));
+		memset(&mvalue, 0, sizeof(rt_mtu_tbl_t));
+
+		ptable.table	= PCE_R_SESSION_INDEX;
+		ptable.pcindex	= rpar->nRtIndex;
+		ptable.op_mode = OPMOD_ADDRESS_READ;
+		route_table_read(cdev, &ptable);
+		rindex = rpar->nRtIndex;
+		hindex = rthandler->rstbl.node[rindex].hval;
+#if defined(RT_DEBUG) && RT_DEBUG
+		pr_err("%s:%s:%d rindex:%d,hindex:%d,\
+		\nrthandler->rstbl.node[rindex].vflag:%d, \
+		\nrthandler->rstbl.node[rindex].fflag:%d, \
+		\nrthandler->rstbl.node[rindex].nventries:%d \
+		\nrthandler->rstbl.ffptr:%d \
+		\nrthandler->rstbl.nfentries:%d, \
+		\nrthandler->rstbl.nuentries:%d, \
+		\nrthandler->rstbl.node[rindex].nptr:%d, \
+		\nrthandler->rstbl.node[rindex].pprt:%d, \
+		\nrthandler->rstbl.lfptr:%d \
+		\nrthandler->rstbl.hw_table[rindex].hwnextptr:%d \
+		\nrthandler->rstbl.hw_table[rindex].hwvalid:%d \n", __FILE__, __func__, __LINE__, rindex, hindex, \
+		       rthandler->rstbl.node[rindex].vflag, \
+		       rthandler->rstbl.node[rindex].fflag, \
+		       rthandler->rstbl.node[rindex].nventries, \
+		       rthandler->rstbl.ffptr, \
+		       rthandler->rstbl.nfentries, \
+		       rthandler->rstbl.nuentries, \
+		       rthandler->rstbl.node[rindex].nptr, \
+		       rthandler->rstbl.node[rindex].pprt, \
+		       rthandler->rstbl.lfptr, \
+		       rthandler->rstbl.hw_table[rindex].hwnextptr, \
+		       rthandler->rstbl.hw_table[rindex].hwvalid);
+#endif /* RT_DEBUG */
+
+		if (((ptable.key[4] >> 15) & 1) == 1) {
+			index = (ptable.key[0] & 0x7FF);
+
+			if (index != 0x7ff)
+				rt_iptable_rd(cdev, index, &iptbl);
+
+			rpar->routeEntry.pattern.eIpType = iptbl.itype;
+
+			if (rpar->routeEntry.pattern.eIpType ==
+			    GSW_RT_IP_V6) {
+				for (i = 0;  i < 8; i++)
+					rpar->routeEntry.pattern.nDstIP.nIPv6[i] =
+						(iptbl.iaddr.i6addr[7 - i] & 0xFFFF);
+			}	else if (rpar->routeEntry.pattern.eIpType ==
+					 GSW_RT_IP_V4) {
+				rpar->routeEntry.pattern.nDstIP.nIPv4 =
+					(iptbl.iaddr.i4addr[0] |
+					 (iptbl.iaddr.i4addr[1] << 8) |
+					 (iptbl.iaddr.i4addr[2] << 16) |
+					 (iptbl.iaddr.i4addr[3] << 24));
+			}
+
+			memset(&iptbl, 0, sizeof(riptbl_t));
+			index = (ptable.key[1] & 0x7FF);
+
+			if (index != 0x7ff)
+				rt_iptable_rd(cdev, index, &iptbl);
+
+			rpar->routeEntry.pattern.eIpType = iptbl.itype;
+
+			if (rpar->routeEntry.pattern.eIpType ==
+			    GSW_RT_IP_V6) {
+				for (i = 0;  i < 8; i++)
+					rpar->routeEntry.pattern.nSrcIP.nIPv6[i] =
+						(iptbl.iaddr.i6addr[7 - i] & 0xFFFF);
+			} else {
+				rpar->routeEntry.pattern.nSrcIP.nIPv4 =
+					(iptbl.iaddr.i4addr[0] |
+					 (iptbl.iaddr.i4addr[1] << 8) |
+					 (iptbl.iaddr.i4addr[2] << 16) |
+					 (iptbl.iaddr.i4addr[3] << 24));
+			}
+
+			rpar->routeEntry.pattern.nDstPort = (ptable.key[2]);
+			rpar->routeEntry.pattern.nSrcPort = (ptable.key[3]);
+			rpar->routeEntry.pattern.nRoutExtId =
+				(ptable.key[4] & 0xFF);
+			rpar->routeEntry.pattern.bValid =
+				((ptable.key[4] >> 15) & 0x1);
+
+			rpar->routeEntry.action.nDstPortMap = (ptable.val[0]);
+			rpar->routeEntry.action.nDstSubIfId =
+				((ptable.val[1] >> 3) & 0x1FFF);
+
+			memset(&iptbl, 0, sizeof(riptbl_t));
+			index = (ptable.val[2] & 0x7FF);
+
+			if (index != 0x7ff)
+				rt_iptable_rd(cdev, index, &iptbl);
+
+			rpar->routeEntry.action.eIpType = iptbl.itype;
+
+			if (rpar->routeEntry.action.eIpType == GSW_RT_IP_V6) {
+				for (i = 0;  i < 8; i++)
+					rpar->routeEntry.action.nNATIPaddr.nIPv6[i] =
+						(iptbl.iaddr.i6addr[7 - i] & 0xFFFF);
+			} else if (rpar->routeEntry.action.eIpType ==
+				   GSW_RT_IP_V4) {
+				rpar->routeEntry.action.nNATIPaddr.nIPv4 =
+					(iptbl.iaddr.i4addr[0] |
+					 (iptbl.iaddr.i4addr[1] << 8) |
+					 (iptbl.iaddr.i4addr[2] << 16) |
+					 (iptbl.iaddr.i4addr[3] << 24));
+			}
+
+			rpar->routeEntry.action.nTcpUdpPort = (ptable.val[3]);
+
+			index = (ptable.val[4] & 0x7);
+			rt_mtutable_rd(cdev, index, &mvalue);
+			rpar->routeEntry.action.nMTUvalue = mvalue.mtsize;
+
+			memset(&mentry, 0, sizeof(rt_mac_tbl_t));
+			index = ((ptable.val[4] >> 8) & 0xFF);
+
+			if (index != 0) {
+				rt_mactable_rd(cdev, index, &mentry);
+
+				for (i = 0; i < 6; i++)
+					rpar->routeEntry.action.nSrcMAC[i] =
+						mentry.mdata[i];
+
+				rpar->routeEntry.action.bMAC_SrcEnable = 1;
+			}
+
+			index = ((ptable.val[5]) & 0x1FF);
+			memset(&mentry, 0, sizeof(rt_mac_tbl_t));
+
+			if (index != 0) {
+				rt_mactable_rd(cdev, index, &mentry);
+
+				for (i = 0; i < 6; i++)
+					rpar->routeEntry.action.nDstMAC[i] =
+						mentry.mdata[i];
+
+				rpar->routeEntry.action.bMAC_DstEnable = 1;
+			}
+
+			rpar->routeEntry.action.nFID = (ptable.val[8] & 0x3F);
+			rpar->routeEntry.action.nFlowId =
+				((ptable.val[8] >> 8) & 0xFF);
+			rpar->routeEntry.action.nDSCP =
+				(ptable.val[9] & 0x3F);
+			rpar->routeEntry.action.nTrafficClass =
+				((ptable.val[9] >> 8) & 0x3F);
+			rpar->routeEntry.action.nSessionCtrs =
+				(ptable.val[10]);
+			rpar->routeEntry.action.nSessionCtrs |=
+				((ptable.val[11] << 16));
+
+			if ((ptable.val[12] >> 0) & 0x1)
+				rpar->routeEntry.action.eSessDirection =
+					GSW_ROUTE_DIRECTION_UPSTREAM;
+			else
+				rpar->routeEntry.action.eSessDirection =
+					GSW_ROUTE_DIRECTION_DNSTREAM;
+
+			if ((ptable.val[12] >> 1) & 0x1) {
+				rt_ppoe_tbl_t sesid;
+				index = (ptable.val[6] & 0xF);
+				rt_ppoetable_rd(cdev, index, &sesid);
+				rpar->routeEntry.action.nPPPoESessId =
+					sesid.psesid;
+				rpar->routeEntry.action.bPPPoEmode = 1;
+			} else
+				rpar->routeEntry.action.bPPPoEmode = 0;
+
+			switch ((ptable.val[12] >> 2) & 0x3) {
+			case 0:
+				rpar->routeEntry.action.eSessRoutingMode =
+					GSW_ROUTE_MODE_NULL;
+				break;
+
+			case 1:
+				rpar->routeEntry.action.eSessRoutingMode =
+					GSW_ROUTE_MODE_ROUTING;
+				break;
+
+			case 2:
+				rpar->routeEntry.action.eSessRoutingMode =
+					GSW_ROUTE_MODE_NAT;
+				break;
+
+			case 3:
+				rpar->routeEntry.action.eSessRoutingMode =
+					GSW_ROUTE_MODE_NAPT;
+				break;
+			}
+
+			switch ((ptable.val[12] >> 4) & 0x3) {
+			case 0:
+				rpar->routeEntry.action.eTunType =
+					GSW_ROUTE_TUNL_NULL;
+				break;
+
+			case 1:
+				rpar->routeEntry.action.eTunType =
+					GSW_ROUTE_TUNL_6RD;
+				break;
+
+			case 2:
+				rpar->routeEntry.action.eTunType =
+					GSW_ROUTE_TUNL_DSLITE;
+				break;
+
+			case 3:
+				rpar->routeEntry.action.eTunType =
+					GSW_ROUTE_TUNL_IPSEC;
+				break;
+			}
+
+			rpar->routeEntry.action.nTunnelIndex =
+				((ptable.val[6] >> 8) & 0xF);
+
+			switch ((ptable.val[12] >> 6) & 0x3) {
+			case 0:
+				rpar->routeEntry.action.eOutDSCPAction =
+					GSW_ROUTE_OUT_DSCP_NULL;
+				break;
+
+			case 1:
+				rpar->routeEntry.action.eOutDSCPAction =
+					GSW_ROUTE_OUT_DSCP_INNER;
+				break;
+
+			case 2:
+				rpar->routeEntry.action.eOutDSCPAction =
+					GSW_ROUTE_OUT_DSCP_SESSION;
+				break;
+
+			case 3:
+				rpar->routeEntry.action.eOutDSCPAction =
+					GSW_ROUTE_OUT_DSCP_RES;
+				break;
+			}
+
+			if ((ptable.val[12] >> 8) & 0x1)
+				rpar->routeEntry.action.bInnerDSCPRemark = 1;
+			else
+				rpar->routeEntry.action.bInnerDSCPRemark = 0;
+
+			if ((ptable.val[12] >> 9) & 0x1)
+				rpar->routeEntry.action.bTCremarking = 1;
+			else
+				rpar->routeEntry.action.bTCremarking = 0;
+
+			if ((ptable.val[12] >> 10) & 0x1) {
+				rpar->routeEntry.action.bMeterAssign = 1;
+				rpar->routeEntry.action.nMeterId =
+					ptable.val[7] & 0x3F;
+			} else
+				rpar->routeEntry.action.bMeterAssign = 0;
+
+			if ((ptable.val[12] >> 11) & 0x1) {
+				rt_rtp_tbl_t rtp_tbl;
+				index = ((ptable.val[7] >> 8) & 0x3F);
+				rt_rtptable_rd(cdev, index, &rtp_tbl);
+				rpar->routeEntry.action.nRTPSeqNumber =
+					rtp_tbl.rtpseqnum;
+				rpar->routeEntry.action.nRTPSessionPktCnt =
+					rtp_tbl.rtpsespcnt;
+				rpar->routeEntry.action.bRTPMeasEna = 1;
+			} else {
+				rpar->routeEntry.action.bRTPMeasEna = 0;
+			}
+
+			if ((ptable.val[12] >> 12) & 0x1)
+				rpar->routeEntry.action.bTTLDecrement = 1;
+			else
+				rpar->routeEntry.action.bTTLDecrement = 0;
+
+			if ((ptable.val[12] >> 15) & 0x1)
+				rpar->routeEntry.action.bHitStatus = 1;
+			else
+				rpar->routeEntry.action.bHitStatus = 0;
+		}
+	} else {
+		retval = GSW_statusErr;
+	}
+
+	retval = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&ethdev->lock_pae);
+#endif
+	return retval;
+}
+
+int GSW_ROUTE_TunnelEntryAdd(void *cdev,
+			     GSW_ROUTE_Tunnel_Entry_t *rpar)
+{
+	ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);
+	int i, j, retval = 0;
+
+	if (ethdev == NULL) {
+		pr_err("%s:%s:%d \n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&ethdev->lock_pae);
+#endif
+
+	if ((ethdev->gipver == LTQ_GSWIP_3_0)
+	    && ((ethdev->gsw_dev == LTQ_FLOW_DEV_INT_R))) {
+		pctbl_prog_t ptable;
+		u16 data[20] = { 0 };
+
+		if (rpar->tunnelEntry.eTunnelType == GSW_ROUTE_TUNL_6RD) {
+			data[0] = 0x0045;
+			data[1] = 0x5678;
+			data[2] = 0x90ab;
+			data[3] = 0x0000;
+			data[4] = 0x293f;
+			data[5] = 0x3344;
+			data[6] =
+				((rpar->tunnelEntry.t.tun6RD.nSrcIP4Addr.nIPv4 >> 24)
+				 & 0xFF);
+			data[6] |=
+				(((rpar->tunnelEntry.t.tun6RD.nSrcIP4Addr.nIPv4 >> 16)
+				  & 0xFF) << 8);
+			data[7] =
+				((rpar->tunnelEntry.t.tun6RD.nSrcIP4Addr.nIPv4 >> 8)
+				 & 0xFF);
+			data[7] |=
+				((rpar->tunnelEntry.t.tun6RD.nSrcIP4Addr.nIPv4
+				  & 0xFF) << 8);
+			data[8] =
+				((rpar->tunnelEntry.t.tun6RD.nDstIP4Addr.nIPv4 >> 24)
+				 & 0xFF);
+			data[8] |=
+				(((rpar->tunnelEntry.t.tun6RD.nDstIP4Addr.nIPv4 >> 16)
+				  & 0xFF) << 8);
+			data[9] =
+				((rpar->tunnelEntry.t.tun6RD.nDstIP4Addr.nIPv4 >> 8)
+				 & 0xFF);
+			data[9] |=
+				((rpar->tunnelEntry.t.tun6RD.nDstIP4Addr.nIPv4
+				  & 0xFF) << 8);
+		} else if (rpar->tunnelEntry.eTunnelType ==
+			   GSW_ROUTE_TUNL_DSLITE) {
+			data[0] = 0x0060;
+			data[1] = 0x0000;
+			data[2] = 0x0000;
+			data[3] = 0xff04;
+
+			for (i = 0; i < 8; i++) {
+				data[i + 4] =
+					((rpar->tunnelEntry.t.tunDSlite.nSrcIP6Addr.nIPv6[i] >> 8)
+					 & 0xFF);
+				data[i + 4] |=
+					((rpar->tunnelEntry.t.tunDSlite.nSrcIP6Addr.nIPv6[i]
+					  & 0xFF) << 8);
+			}
+
+			for (i = 0; i < 8; i++) {
+				data[i + 12] =
+					((rpar->tunnelEntry.t.tunDSlite.nDstIP6Addr.nIPv6[i] >> 8)
+					 & 0xFF);
+				data[i + 12] |=
+					((rpar->tunnelEntry.t.tunDSlite.nDstIP6Addr.nIPv6[i]
+					  & 0xFF) << 8);
+			}
+		} else if (rpar->tunnelEntry.eTunnelType ==
+			   GSW_ROUTE_TUNL_L2TP) {
+			data[1] =
+				(rpar->tunnelEntry.t.nTunL2TP & 0xFFFF);
+			data[0] =
+				((rpar->tunnelEntry.t.nTunL2TP >> 16) & 0xFFFF);
+		} else if (rpar->tunnelEntry.eTunnelType ==
+			   GSW_ROUTE_TUNL_IPSEC) {
+			data[1] = (rpar->tunnelEntry.t.nTunIPsec & 0xFFFF);
+			data[0] =
+				((rpar->tunnelEntry.t.nTunIPsec >> 16) & 0xFFFF);
+		}
+
+		for (j = 0; j < 5; j++) {
+			memset(&ptable, 0, sizeof(pctbl_prog_t));
+
+			for (i = 0; i < 4; i++)
+				ptable.val[i] = data[(j * 4) + i];
+
+			ptable.table = PCE_R_TUNNEL_INDEX;
+			ptable.pcindex = ((rpar->nTunIndex * 5) + j);
+			ptable.valid = 1;
+			ptable.op_mode = OPMOD_ADDRESS_WRITE;
+			route_table_write(cdev, &ptable);
+		}
+	} else {
+		retval = GSW_statusErr;
+	}
+
+	retval = GSW_statusOk;
+
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&ethdev->lock_pae);
+#endif
+	return retval;
+}
+
+int GSW_ROUTE_TunnelEntryRead(void *cdev,
+			      GSW_ROUTE_Tunnel_Entry_t *rpar)
+{
+	ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);
+	int retval = 0;
+
+	if (ethdev == NULL) {
+		pr_err("%s:%s:%d \n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&ethdev->lock_pae);
+#endif
+
+	if ((ethdev->gipver == LTQ_GSWIP_3_0)
+	    && ((ethdev->gsw_dev == LTQ_FLOW_DEV_INT_R))) {
+		pctbl_prog_t ptable;
+		int i, j;
+		u16 data[20] = { 0 };
+
+		for (j = 0; j < 5; j++) {
+			memset(&ptable, 0, sizeof(pctbl_prog_t));
+			ptable.table	= PCE_R_TUNNEL_INDEX;
+			ptable.pcindex	= ((rpar->nTunIndex * 5) + j);
+			ptable.op_mode = OPMOD_ADDRESS_READ;
+			route_table_read(cdev, &ptable);
+
+			for (i = 0; i < 4; i++)
+				data[(j * 4) + i] = ptable.val[i];
+		}
+
+		if (rpar->tunnelEntry.eTunnelType ==
+		    GSW_ROUTE_TUNL_6RD) {
+			rpar->tunnelEntry.t.tun6RD.nSrcIP4Addr.nIPv4 =
+				((data[6] << 16) | (data[7]));
+			rpar->tunnelEntry.t.tun6RD.nDstIP4Addr.nIPv4 =
+				((data[8] << 16) | (data[9]));
+		} else if (rpar->tunnelEntry.eTunnelType ==
+			   GSW_ROUTE_TUNL_DSLITE) {
+			for (i = 0; i < 8; i++)
+				rpar->tunnelEntry.t.tunDSlite.nSrcIP6Addr.nIPv6[i] =
+					data[i + 4];
+
+			for (i = 0; i < 8; i++)
+				rpar->tunnelEntry.t.tunDSlite.nDstIP6Addr.nIPv6[i] =
+					data[i + 12];
+		} else if (rpar->tunnelEntry.eTunnelType ==
+			   GSW_ROUTE_TUNL_L2TP) {
+			rpar->tunnelEntry.t.nTunIPsec =
+				((data[0] << 16) | data[1]);
+		} else if (rpar->tunnelEntry.eTunnelType ==
+			   GSW_ROUTE_TUNL_IPSEC) {
+			rpar->tunnelEntry.t.nTunIPsec =
+				((data[0] << 16) | data[1]);
+		}
+	} else {
+		retval = GSW_statusErr;
+	}
+
+	retval = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&ethdev->lock_pae);
+#endif
+	return retval;
+
+}
+
+int GSW_ROUTE_TunnelEntryDel(void *cdev,
+			     GSW_ROUTE_Tunnel_Entry_t *rpar)
+{
+	ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);
+	int retval = 0;
+
+	if (ethdev == NULL) {
+		pr_err("%s:%s:%d \n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&ethdev->lock_pae);
+#endif
+
+	if ((ethdev->gipver == LTQ_GSWIP_3_0)
+	    && ((ethdev->gsw_dev == LTQ_FLOW_DEV_INT_R))) {
+		pctbl_prog_t ptable;
+		int j;
+
+		for (j = 0; j < 5; j++) {
+			memset(&ptable, 0, sizeof(pctbl_prog_t));
+			ptable.table = PCE_R_TUNNEL_INDEX;
+			ptable.pcindex = ((rpar->nTunIndex * 5) + j);
+			ptable.op_mode = OPMOD_ADDRESS_WRITE;
+			route_table_write(cdev, &ptable);
+		}
+	} else {
+		retval = GSW_statusErr;
+	}
+
+	retval = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&ethdev->lock_pae);
+#endif
+	return retval;
+}
+
+int GSW_ROUTE_L2NATCfgWrite(void *cdev,
+			    GSW_ROUTE_EgPort_L2NAT_Cfg_t *rpar)
+{
+	ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);
+	int retval = 0;
+
+	if (ethdev == NULL) {
+		pr_err("%s:%s:%d \n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&ethdev->lock_pae);
+#endif
+
+	if ((ethdev->gipver == LTQ_GSWIP_3_0)
+	    && ((ethdev->gsw_dev == LTQ_FLOW_DEV_INT_R))) {
+		u16 data;
+
+		if (rpar->nEgPortId >= ethdev->tpnum) {
+			retval = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		gsw_w32(cdev,
+			(PCE_PCTRL_2_L2NAT_OFFSET + (rpar->nEgPortId * 0xA)),
+			PCE_PCTRL_2_L2NAT_SHIFT,
+			PCE_PCTRL_2_L2NAT_SIZE, rpar->bL2NATEna);
+
+		data = rpar->nNatMAC[4] << 8 | rpar->nNatMAC[5];
+		gsw_w32(cdev,
+			(PCE_L2NAT_MAC0_MAC0_OFFSET + (rpar->nEgPortId * 0x10)),
+			PCE_L2NAT_MAC0_MAC0_SHIFT,
+			PCE_L2NAT_MAC0_MAC0_SIZE, data);
+
+		data = rpar->nNatMAC[2] << 8 | rpar->nNatMAC[3];
+		gsw_w32(cdev,
+			(PCE_L2NAT_MAC1_MAC1_OFFSET + (rpar->nEgPortId * 0x10)),
+			PCE_L2NAT_MAC1_MAC1_SHIFT,
+			PCE_L2NAT_MAC1_MAC1_SIZE, data);
+
+		data = rpar->nNatMAC[0] << 8 | rpar->nNatMAC[1];
+		gsw_w32(cdev,
+			(PCE_L2NAT_MAC2_MAC2_OFFSET + (rpar->nEgPortId * 0x10)),
+			PCE_L2NAT_MAC2_MAC2_SHIFT,
+			PCE_L2NAT_MAC2_MAC2_SIZE, data);
+	} else {
+		retval = GSW_statusErr;
+	}
+
+	retval = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&ethdev->lock_pae);
+#endif
+	return retval;
+
+}
+
+int GSW_ROUTE_L2NATCfgRead(void *cdev,
+			   GSW_ROUTE_EgPort_L2NAT_Cfg_t *rpar)
+{
+	ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);
+	int retval = 0;
+
+	if (ethdev == NULL) {
+		pr_err("%s:%s:%d \n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&ethdev->lock_pae);
+#endif
+
+	if ((ethdev->gipver == LTQ_GSWIP_3_0)
+	    && ((ethdev->gsw_dev == LTQ_FLOW_DEV_INT_R))) {
+		u32 data;
+
+		if (rpar->nEgPortId >= ethdev->tpnum) {
+			retval = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		gsw_r32(cdev,
+			(PCE_PCTRL_2_L2NAT_OFFSET + (rpar->nEgPortId * 0xA)),
+			PCE_PCTRL_2_L2NAT_SHIFT,
+			PCE_PCTRL_2_L2NAT_SIZE, &rpar->bL2NATEna);
+
+		gsw_r32(cdev,
+			(PCE_L2NAT_MAC0_MAC0_OFFSET + (rpar->nEgPortId * 0x10)),
+			PCE_L2NAT_MAC0_MAC0_SHIFT,
+			PCE_L2NAT_MAC0_MAC0_SIZE, &data);
+		rpar->nNatMAC[5] = (data & 0xFF);
+		rpar->nNatMAC[4] = ((data >> 8) & 0xFF);
+
+		gsw_r32(cdev,
+			(PCE_L2NAT_MAC1_MAC1_OFFSET + (rpar->nEgPortId * 0x10)),
+			PCE_L2NAT_MAC1_MAC1_SHIFT,
+			PCE_L2NAT_MAC1_MAC1_SIZE, &data);
+		rpar->nNatMAC[3] = (data & 0xFF);
+		rpar->nNatMAC[2] = ((data >> 8) & 0xFF);
+
+		gsw_r32(cdev,
+			(PCE_L2NAT_MAC2_MAC2_OFFSET + (rpar->nEgPortId * 0x10)),
+			PCE_L2NAT_MAC2_MAC2_SHIFT,
+			PCE_L2NAT_MAC2_MAC2_SIZE, &data);
+		rpar->nNatMAC[1] = (data & 0xFF);
+		rpar->nNatMAC[0] = ((data >> 8) & 0xFF);
+	} else {
+		retval = GSW_statusErr;
+	}
+
+	retval = GSW_statusOk;
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&ethdev->lock_pae);
+#endif
+	return retval;
+
+}
+
+int GSW_ROUTE_SessHitOp(void *cdev,
+			GSW_ROUTE_Session_Hit_t *rpar)
+{
+	ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);
+	int retval = 0;
+
+	if (ethdev == NULL) {
+		pr_err("%s:%s:%d \n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&ethdev->lock_pae);
+#endif
+
+	if ((ethdev->gipver == LTQ_GSWIP_3_0)
+	    && ((ethdev->gsw_dev == LTQ_FLOW_DEV_INT_R))) {
+		pctbl_prog_t ptable;
+		memset(&ptable, 0, sizeof(pctbl_prog_t));
+		ptable.table = PCE_R_SESSION_INDEX;
+		ptable.pcindex = rpar->nRtIndex;
+		ptable.op_mode = OPMOD_ADDRESS_READ;
+		route_table_read(cdev, &ptable);
+
+		if (((ptable.key[4] >> 15) & 1) == 1) {
+			switch (rpar->eHitOper) {
+			case GSW_ROUTE_HIT_READ:
+				if ((ptable.val[12] >> 15) & 0x1)
+					rpar->bHitStatus = 1;
+				else
+					rpar->bHitStatus = 0;
+
+				break;
+
+			case GSW_ROUTE_HIT_CLEAR:
+				ptable.val[12] &= ~(1 << 15);
+				ptable.table = PCE_R_SESSION_INDEX;
+				ptable.pcindex = rpar->nRtIndex;
+				ptable.op_mode = OPMOD_RT_SESSION_HIT_STATUS;
+				route_table_write(cdev, &ptable);
+				break;
+
+			case GSW_ROUTE_HIT_N_CNTR_READ:
+				if ((ptable.val[12] >> 15) & 0x1)
+					rpar->bHitStatus = 1;
+				else
+					rpar->bHitStatus = 0;
+
+				rpar->nSessCntr = (ptable.val[10]);
+				rpar->nSessCntr |= ((ptable.val[11] << 16));
+				break;
+
+			case GSW_ROUTE_HIT_N_CNTR_CLEAR:
+				if ((ptable.val[12] >> 15) & 0x1)
+					rpar->bHitStatus = 1;
+				else
+					rpar->bHitStatus = 0;
+
+				ptable.val[12] &= ~(1 << 15);
+				rpar->nSessCntr = (ptable.val[10]);
+				rpar->nSessCntr |= ((ptable.val[11] << 16));
+				ptable.val[10] = 0;
+				ptable.val[11] = 0;
+				ptable.table = PCE_R_SESSION_INDEX;
+				ptable.pcindex = rpar->nRtIndex;
+				ptable.op_mode = OPMOD_RT_SESSION_WRITE;
+				route_table_write(cdev, &ptable);
+				break;
+			}
+		}
+	} else {
+		retval = GSW_statusErr;
+	}
+
+	retval = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&ethdev->lock_pae);
+#endif
+	return retval;
+}
+
+int GSW_ROUTE_SessDestModify(void *cdev,
+			     GSW_ROUTE_Session_Dest_t *rpar)
+{
+	ethsw_api_dev_t *ethdev = GSW_PDATA_GET(cdev);
+	int retval = 0;
+
+
+	if (ethdev == NULL) {
+		pr_err("%s:%s:%d \n", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&ethdev->lock_pae);
+#endif
+
+	if ((ethdev->gipver == LTQ_GSWIP_3_0)
+	    && ((ethdev->gsw_dev == LTQ_FLOW_DEV_INT_R))) {
+		pctbl_prog_t ptable;
+		memset(&ptable, 0, sizeof(pctbl_prog_t));
+		ptable.table = PCE_R_SESSION_INDEX;
+		ptable.pcindex = rpar->nRtIdx;
+		ptable.op_mode = OPMOD_ADDRESS_READ;
+		route_table_read(cdev, &ptable);
+
+		if (((ptable.key[4] >> 15) & 1) == 1) {
+			/* Destination Port Map  */
+			ptable.val[0] = (rpar->nDstPortMap & 0xFFFF);
+			/*Destination Sub-Interface ID*/
+			ptable.val[1] = ((rpar->nDstSubIfId & 0x1FFF) << 3);
+			ptable.table = PCE_R_SESSION_INDEX;
+			ptable.pcindex = rpar->nRtIdx;
+			ptable.op_mode = OPMOD_ADDRESS_WRITE;
+			route_table_write(cdev, &ptable);
+		}
+	} else {
+		retval = GSW_statusErr;
+	}
+
+	retval = GSW_statusOk;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&ethdev->lock_pae);
+#endif
+	return retval;
+}
+
+/* RT Table Init routine */
+int rt_table_init()
+{
+	int index;
+	PCE_ASSERT(rthandler == NULL);
+	memset(&rthandler->rt_sub_tbl, 0, sizeof(rt_table_handle_t));
+	memset(&rthandler->rstbl, 0, sizeof(rt_session_tbl_t));
+	rthandler->rstbl.nfentries = 4096;
+	rthandler->rstbl.nuentries = 0;
+	rthandler->rstbl.ffptr = 0;
+	rthandler->rstbl.lfptr = 4095;
+
+	for (index = 0; index < rthandler->rstbl.nfentries; index++) {
+		rthandler->rstbl.node[index].vflag = 0;
+		rthandler->rstbl.node[index].pprt = (index == 0) ? (-1) : (index - 1);
+		rthandler->rstbl.node[index].nptr = (index == 4095) ? (-1) : (index + 1);
+		rthandler->rstbl.node[index].nventries = 0;
+		rthandler->rstbl.node[index].fflag = 1;
+		rthandler->rstbl.node[index].prio = 0;
+		rthandler->rstbl.node[index].hval = 0;
+
+		rthandler->rstbl.hw_table[index].hwvalid = 0;
+		rthandler->rstbl.hw_table[index].hwnextptr = index;
+	}
+
+	return GSW_statusOk;
+}
+
+int gsw_r_init()
+{
+	int index;
+
+	/*	rthandler = (ltq_rt_table_t *) kmalloc(sizeof(ltq_rt_table_t),*/
+	/*		GFP_KERNEL);*/
+	if (rthandler)
+		kfree(rthandler);
+
+	rthandler = kmalloc(sizeof(ltq_rt_table_t), GFP_KERNEL);
+	PCE_ASSERT(rthandler == NULL);
+	memset(&rthandler->rt_sub_tbl, 0, sizeof(rt_table_handle_t));
+	memset(&rthandler->rstbl, 0, sizeof(rt_session_tbl_t));
+	rthandler->rstbl.nfentries = 4096;
+	rthandler->rstbl.nuentries = 0;
+	rthandler->rstbl.ffptr = 0;
+	rthandler->rstbl.lfptr = 4095;
+
+	for (index = 0; index < rthandler->rstbl.nfentries; index++) {
+		rthandler->rstbl.node[index].vflag = 0;
+		rthandler->rstbl.node[index].pprt = (index == 0) ? (-1) : (index - 1);
+		rthandler->rstbl.node[index].nptr = (index == 4095) ? (-1) : (index + 1);
+		rthandler->rstbl.node[index].nventries = 0;
+		rthandler->rstbl.node[index].fflag = 1;
+		rthandler->rstbl.node[index].prio = 0;
+		rthandler->rstbl.node[index].hval = 0;
+		rthandler->rstbl.hw_table[index].hwvalid = 0;
+		rthandler->rstbl.hw_table[index].hwnextptr = index;
+	}
+
+	return GSW_statusOk;
+}
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_pae.h b/drivers/net/ethernet/lantiq/switch-api/gsw_pae.h
new file mode 100644
index 000000000000..00c7184492aa
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_pae.h
@@ -0,0 +1,148 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+
+#ifndef _GSW_ROUTER_H_
+#define _GSW_ROUTER_H_
+
+#define RT_SESSION_TABLE_SIZE 4096
+#define	RT_IP_TBL_SIZE	2048
+#define	RT_MAC_TBL_SIZE	512
+#define	RT_PPPOE_TBL_SIZE	16
+#define	RT_TUNNEL_TBL_SIZE	16
+#define	RT_RTP_TBL_SIZE	64
+#define	RT_MTU_TBL_SIZE	8
+
+/** Provides the address of the configured/fetched lookup table. */
+typedef enum {
+	/** Parser microcode table */
+	PCE_R_SESSION_INDEX	= 0x00,
+	PCE_R_IP_INDEX			= 0x01,
+	PCE_R_MAC_INDEX			= 0x02,
+	PCE_R_PPPOE_INDEX		= 0x03,
+	PCE_R_TUNNEL_INDEX	= 0x04,
+	PCE_R_RTP_INDEX			= 0x05,
+	PCE_R_MTU_INDEX			= 0x06,
+} routing_table_address_t;
+
+/** Description */
+typedef enum {
+	OPMOD_ADDRESS_READ	=	0,
+	OPMOD_ADDRESS_WRITE	=	1,
+	OPMOD_KEY_READ	=	2,
+	OPMOD_KEY_WRITE	=	3,
+} rt_opmod_access_t;
+
+/** Description */
+typedef enum {
+	OPMOD_RT_SESSION_READ = 0,
+	OPMOD_RT_SESSION_WRITE = 1,
+	OPMOD_RT_SESSION_NEXT = 2,
+	OPMOD_RT_SESSION_HIT_STATUS = 3,
+} rt_opmod_session_t;
+
+typedef enum {
+	OPMOD_IPv4_READ = 0,
+	OPMOD_IPv4_WRITE = 1,
+	/*OPMOD_IPv6_READ = 2,*/
+	/*OPMOD_IPv6_WRITE = 3,*/
+} ip_opmod_access_t;
+
+typedef struct {
+	union {
+		u8 i4addr[4];
+		u16 i6addr[8];
+	} iaddr;
+	u8 itype: 2;
+	u8 valid: 1;
+} riptbl_t;
+
+typedef struct  {
+	u8 mdata[6];
+	ltq_bool_t valid;
+} rt_mac_tbl_t;
+
+/* RT PPPoE Table  */
+typedef struct {
+	u16	psesid;
+	ltq_bool_t valid;
+} rt_ppoe_tbl_t;
+
+/* RT PPPoE Table  */
+typedef struct {
+	u16	mtsize;
+	ltq_bool_t valid;
+} rt_mtu_tbl_t;
+
+typedef struct {
+	u16 rtpseqnum;
+	u16 rtpsespcnt;
+} rt_rtp_tbl_t;
+
+typedef struct {
+	ltq_bool_t hwvalid;
+	int hwnextptr;
+	/* GSW_ROUTE_session_t HWSession;*/
+} rt_hw_tbl_t;
+
+typedef struct {
+	ltq_bool_t vflag;
+	ltq_bool_t fflag;
+	ltq_bool_t prio;
+	u8 nventries;
+	int pprt;
+	int nptr;
+	int hval;
+	/* GSW_ROUTE_Session_pattern_t    pattern; */
+} rt_ses_nod_tbl_t;
+
+typedef struct {
+	int nfentries;
+	int ffptr;
+	int lfptr;
+	int nuentries;
+	rt_ses_nod_tbl_t node[RT_SESSION_TABLE_SIZE];
+	rt_hw_tbl_t hw_table[RT_SESSION_TABLE_SIZE];
+} rt_session_tbl_t;
+
+typedef struct {
+	/* Routing IP Table */
+	u16 rt_ip_tbl_cnt[RT_IP_TBL_SIZE];
+	riptbl_t rt_ip_tbl[RT_IP_TBL_SIZE];
+	/* table reference counter */
+	u16 rt_mac_tbl_cnt[RT_MAC_TBL_SIZE];
+	/* Routing MAC Table */
+	rt_mac_tbl_t rt_mac_tbl[RT_MAC_TBL_SIZE];
+	/* table reference counter */
+	u16 rt_ppoe_tbl_cnt[RT_PPPOE_TBL_SIZE];
+	/* Routing MAC Table */
+	rt_ppoe_tbl_t rt_ppoe_tbl[RT_PPPOE_TBL_SIZE];
+	/* table reference counter */
+	u16 rt_mtu_tbl_cnt[RT_MTU_TBL_SIZE];
+	/* Routing MAC Table */
+	rt_mtu_tbl_t rt_mtu_tbl[RT_MTU_TBL_SIZE];
+	/* table reference counter */
+	/*	u16 rt_rtp_tbl_cnt[RT_RTP_TBL_SIZE]; */
+	/* Routing MAC Table */
+	/*	rt_rtp_tbl_t rt_rtp_tbl[RT_RTP_TBL_SIZE]; */
+} rt_table_handle_t;
+
+
+typedef struct {
+	/* Parameter for the sub-tables */
+	rt_table_handle_t rt_sub_tbl;
+	rt_session_tbl_t rstbl;
+} ltq_rt_table_t;
+
+int rt_table_init(void);
+int gsw_r_init(void);
+
+#endif /* _GSW_ROUTER_H_ */
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_reg.h b/drivers/net/ethernet/lantiq/switch-api/gsw_reg.h
new file mode 100644
index 000000000000..7bdbdb5570ca
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_reg.h
@@ -0,0 +1,4410 @@
+/******************************************************************************
+
+                         Copyright (c) 2012, 2014, 2015
+                            Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+#ifndef _LTQ_GSWITCH_REG_H_
+#define _LTQ_GSWITCH_REG_H_
+/* --------------------------------------------------- */
+/* Register: 'Ethernet Switch ResetControl Register' */
+/* Bit: 'R1' */
+/* Description: 'GSWIP Software Reset' */
+#define ETHSW_SWRES_R1_OFFSET	0x000
+#define ETHSW_SWRES_R1_SHIFT	1
+#define ETHSW_SWRES_R1_SIZE		1
+/* Bit: 'R0' */
+/* Description: 'GSWIP Hardware Reset' */
+#define ETHSW_SWRES_R0_OFFSET	0x000
+#define ETHSW_SWRES_R0_SHIFT	0
+#define ETHSW_SWRES_R0_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Ethernet Switch Clock ControlRegister ' */
+/* Bit: 'CORACT_OVR' */
+/* Description: 'Core Active Override' */
+#define ETHSW_CLK_CORACT_OVR_OFFSET	0x001
+#define ETHSW_CLK_CORACT_OVR_SHIFT	1
+#define ETHSW_CLK_CORACT_OVR_SIZE		1
+/* Bit: 'LNKDWN_OVR' */
+/* Description: 'Link Down Override' */
+#define ETHSW_CLK_LNKDWN_OVR_OFFSET	0x001
+#define ETHSW_CLK_LNKDWN_OVR_SHIFT	0
+#define ETHSW_CLK_LNKDWN_OVR_SIZE		1
+/* --------------------------------------- */
+/* Register: 'Ethernet Switch SharedSegment Buffer Mode Register' */
+/* Bit: 'ADDE' */
+/* Description: 'Memory Address' */
+#define ETHSW_SSB_MODE_ADDE_OFFSET	0x003
+#define ETHSW_SSB_MODE_ADDE_SHIFT		2
+#define ETHSW_SSB_MODE_ADDE_SIZE		4
+/* Bit: 'MODE' */
+/* Description: 'Memory Access Mode' */
+#define ETHSW_SSB_MODE_MODE_OFFSET	0x003
+#define ETHSW_SSB_MODE_MODE_SHIFT		0
+#define ETHSW_SSB_MODE_MODE_SIZE		2
+/* ----------------------------------------- */
+/* Register: 'Ethernet Switch SharedSegment Buffer Address Register' */
+/* Bit: 'ADDE' */
+/* Description: 'Memory Address' */
+#define ETHSW_SSB_ADDR_ADDE_OFFSET	0x004
+#define ETHSW_SSB_ADDR_ADDE_SHIFT		0
+#define ETHSW_SSB_ADDR_ADDE_SIZE		16
+/* ------------------------------------------	*/
+/* Register: 'Ethernet Switch SharedSegment Buffer Data Register' */
+/* Bit: 'DATA' */
+/* Description: 'Data Value' */
+#define ETHSW_SSB_DATA_DATA_OFFSET	0x005
+#define ETHSW_SSB_DATA_DATA_SHIFT		0
+#define ETHSW_SSB_DATA_DATA_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Ethernet Switch CapabilityRegister 0' */
+/* Bit: 'SPEED' */
+/* Description: 'Clock frequency' */
+#define ETHSW_CAP_0_SPEED_OFFSET	0x006
+#define ETHSW_CAP_0_SPEED_SHIFT		0
+#define ETHSW_CAP_0_SPEED_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Ethernet Switch CapabilityRegister 1' */
+/* Bit: 'GMAC' */
+/* Description: 'MAC operation mode' */
+#define ETHSW_CAP_1_GMAC_OFFSET	0x007
+#define ETHSW_CAP_1_GMAC_SHIFT	15
+#define ETHSW_CAP_1_GMAC_SIZE		1
+/* Bit: 'QUEUE' */
+/* Description: 'Number of queues' */
+#define ETHSW_CAP_1_QUEUE_OFFSET	0x007
+#define ETHSW_CAP_1_QUEUE_SHIFT		8
+#define ETHSW_CAP_1_QUEUE_SIZE		7
+/* Bit: 'VPORTS' */
+/* Description: 'Number of virtual ports' */
+#define ETHSW_CAP_1_VPORTS_OFFSET	0x007
+#define ETHSW_CAP_1_VPORTS_SHIFT	4
+#define ETHSW_CAP_1_VPORTS_SIZE		4
+/* Bit: 'PPORTS' */
+/* Description: 'Number of physical ports' */
+#define ETHSW_CAP_1_PPORTS_OFFSET	0x007
+#define ETHSW_CAP_1_PPORTS_SHIFT	0
+#define ETHSW_CAP_1_PPORTS_SIZE		4
+/* ---------------------------------------------------*/
+/* Register: 'Ethernet Switch CapabilityRegister 2' */
+/* Bit: 'PACKETS' */
+/* Description: 'Number of packets' */
+#define ETHSW_CAP_2_PACKETS_OFFSET	0x008
+#define ETHSW_CAP_2_PACKETS_SHIFT		0
+#define ETHSW_CAP_2_PACKETS_SIZE		11
+/* ---------------------------------------------------*/
+/* Register: 'Ethernet Switch CapabilityRegister 3' */
+/* Bit: 'METERS' */
+/* Description: 'Number of traffic meters' */
+#define ETHSW_CAP_3_METERS_OFFSET	0x009
+#define ETHSW_CAP_3_METERS_SHIFT	8
+#define ETHSW_CAP_3_METERS_SIZE		8
+/* Bit: 'SHAPERS' */
+/* Description: 'Number of traffic shapers' */
+#define ETHSW_CAP_3_SHAPERS_OFFSET	0x009
+#define ETHSW_CAP_3_SHAPERS_SHIFT		0
+#define ETHSW_CAP_3_SHAPERS_SIZE		8
+/* --------------------------------------------------- */
+/* Register: 'Ethernet Switch CapabilityRegister 4' */
+/* Bit: 'PPPOE' */
+/* Description: 'PPPoE table size' */
+#define ETHSW_CAP_4_PPPOE_OFFSET	0x00A
+#define ETHSW_CAP_4_PPPOE_SHIFT		8
+#define ETHSW_CAP_4_PPPOE_SIZE		8
+/* Bit: 'VLAN' */
+/* Description: 'Active VLAN table size' */
+#define ETHSW_CAP_4_VLAN_OFFSET	0x00A
+#define ETHSW_CAP_4_VLAN_SHIFT	0
+#define ETHSW_CAP_4_VLAN_SIZE		8
+/* --------------------------------------------------- */
+/* Register: 'Ethernet Switch CapabilityRegister 5' */
+/* Bit: 'IPPLEN' */
+/* Description: 'IP packet length table size' */
+#define ETHSW_CAP_5_IPPLEN_OFFSET	0x00B
+#define ETHSW_CAP_5_IPPLEN_SHIFT	8
+#define ETHSW_CAP_5_IPPLEN_SIZE		8
+/* Bit: 'PROT' */
+/* Description: 'Protocol table size' */
+#define ETHSW_CAP_5_PROT_OFFSET	0x00B
+#define ETHSW_CAP_5_PROT_SHIFT	0
+#define ETHSW_CAP_5_PROT_SIZE		8
+/* --------------------------------------------------- */
+/* Register: 'Ethernet Switch CapabilityRegister 6' */
+/* Bit: 'MACDASA' */
+/* Description: 'MAC DA/SA table size' */
+#define ETHSW_CAP_6_MACDASA_OFFSET	0x00C
+#define ETHSW_CAP_6_MACDASA_SHIFT		8
+#define ETHSW_CAP_6_MACDASA_SIZE		8
+/* Bit: 'APPL' */
+/* Description: 'Application table size' */
+#define ETHSW_CAP_6_APPL_OFFSET	0x00C
+#define ETHSW_CAP_6_APPL_SHIFT	0
+#define ETHSW_CAP_6_APPL_SIZE		8
+/* ---------------------------------------------------*/
+/* Register: 'Ethernet Switch CapabilityRegister 7' */
+/* Bit: 'IPDASAM' */
+/* Description: 'IP DA/SA MSB table size' */
+#define ETHSW_CAP_7_IPDASAM_OFFSET	0x00D
+#define ETHSW_CAP_7_IPDASAM_SHIFT		8
+#define ETHSW_CAP_7_IPDASAM_SIZE		8
+/* Bit: 'IPDASAL' */
+/* Description: 'IP DA/SA LSB table size' */
+#define ETHSW_CAP_7_IPDASAL_OFFSET	0x00D
+#define ETHSW_CAP_7_IPDASAL_SHIFT		0
+#define ETHSW_CAP_7_IPDASAL_SIZE		8
+/* --------------------------------------------------- */
+/* Register: 'Ethernet Switch CapabilityRegister 8' */
+/* Bit: 'MCAST' */
+/* Description: 'Multicast table size' 3.0 size 8 3.1 size 13*/
+#define ETHSW_CAP_8_MCAST_OFFSET	0x00E
+#define ETHSW_CAP_8_MCAST_SHIFT		0
+#define ETHSW_CAP_8_MCAST_SIZE		13
+/* --------------------------------------------------- */
+/* Register: 'Ethernet Switch CapabilityRegister 9' */
+/** Bit: 'FLAGG'  (LTQ_GSWIP_3_0) */
+/* Description: 'Flow Aggregation table size' */
+#define ETHSW_CAP_9_FLAGG_OFFSET	0x00F
+#define ETHSW_CAP_9_FLAGG_SHIFT		0
+#define ETHSW_CAP_9_FLAGG_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'Ethernet Switch CapabilityRegister 10' */
+/* Bit: 'MACBT' */
+/* Description: 'MAC bridging table size' */
+#define ETHSW_CAP_10_MACBT_OFFSET	0x010
+#define ETHSW_CAP_10_MACBT_SHIFT	0
+#define ETHSW_CAP_10_MACBT_SIZE		13
+/* --------------------------------------------------- */
+/* Register: 'Ethernet Switch CapabilityRegister 11' */
+/* Bit: 'BSIZEL' */
+/* Description: 'Packet buffer size (lower part, in byte)' */
+#define ETHSW_CAP_11_BSIZEL_OFFSET	0x011
+#define ETHSW_CAP_11_BSIZEL_SHIFT		0
+#define ETHSW_CAP_11_BSIZEL_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Ethernet Switch CapabilityRegister 12' */
+/* Bit: 'BSIZEH' */
+/* Description: 'Packet buffer size (higher part, in byte)' */
+#define ETHSW_CAP_12_BSIZEH_OFFSET	0x012
+#define ETHSW_CAP_12_BSIZEH_SHIFT		0
+#define ETHSW_CAP_12_BSIZEH_SIZE		3
+/* --------------------------------------------------- */
+/* Register: 'Ethernet Switch VersionRegister' */
+/* Bit: 'MOD_ID' */
+/* Description: 'Module Identification' */
+#define ETHSW_VERSION_MOD_ID_OFFSET	0x013
+#define ETHSW_VERSION_MOD_ID_SHIFT	8
+#define ETHSW_VERSION_MOD_ID_SIZE		8
+/* Bit: 'REV_ID' */
+/* Description: 'Hardware Revision Identification' */
+#define ETHSW_VERSION_REV_ID_OFFSET	0x013
+#define ETHSW_VERSION_REV_ID_SHIFT	0
+#define ETHSW_VERSION_REV_ID_SIZE		8
+/* --------------------------------------------------- */
+/* Register: 'Interrupt Enable Register' */
+/* Bit: 'FDMAIE' */
+/* Description: 'Fetch DMA Interrupt Enable' */
+#define ETHSW_IER_FDMAIE_OFFSET	0x014
+#define ETHSW_IER_FDMAIE_SHIFT	4
+#define ETHSW_IER_FDMAIE_SIZE		1
+/* Bit: 'SDMAIE' */
+/* Description: 'Store DMA Interrupt Enable' */
+#define ETHSW_IER_SDMAIE_OFFSET	0x014
+#define ETHSW_IER_SDMAIE_SHIFT	3
+#define ETHSW_IER_SDMAIE_SIZE		1
+/* Bit: 'MACIE' */
+/* Description: 'Ethernet MAC Interrupt Enable' */
+#define ETHSW_IER_MACIE_OFFSET	0x014
+#define ETHSW_IER_MACIE_SHIFT		2
+#define ETHSW_IER_MACIE_SIZE		1
+/* Bit: 'PCEIE' */
+/* Description: 'Parser and Classification Engine Interrupt Enable' */
+#define ETHSW_IER_PCEIE_OFFSET	0x014
+#define ETHSW_IER_PCEIE_SHIFT		1
+#define ETHSW_IER_PCEIE_SIZE		1
+/* Bit: 'BMIE' */
+/* Description: 'Buffer Manager Interrupt Enable' */
+#define ETHSW_IER_BMIE_OFFSET	0x014
+#define ETHSW_IER_BMIE_SHIFT	0
+#define ETHSW_IER_BMIE_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Interrupt Status Register' */
+/* Bit: 'FDMAINT' */
+/* Description: 'Fetch DMA Interrupt' */
+#define ETHSW_ISR_FDMAINT_OFFSET	0x015
+#define ETHSW_ISR_FDMAINT_SHIFT		4
+#define ETHSW_ISR_FDMAINT_SIZE		1
+/* Bit: 'SDMAINT' */
+/* Description: 'Store DMA Interrupt' */
+#define ETHSW_ISR_SDMAINT_OFFSET	0x015
+#define ETHSW_ISR_SDMAINT_SHIFT		3
+#define ETHSW_ISR_SDMAINT_SIZE		1
+/* Bit: 'MACINT' */
+/* Description: 'Ethernet MAC Interrupt' */
+#define ETHSW_ISR_MACINT_OFFSET	0x015
+#define ETHSW_ISR_MACINT_SHIFT	2
+#define ETHSW_ISR_MACINT_SIZE		1
+/* Bit: 'PCEINT' */
+/* Description: 'Parser and Classification Engine Interrupt' */
+#define ETHSW_ISR_PCEINT_OFFSET	0x015
+#define ETHSW_ISR_PCEINT_SHIFT	1
+#define ETHSW_ISR_PCEINT_SIZE		1
+/* Bit: 'BMINT' */
+/* Description: 'Buffer Manager Interrupt' */
+#define ETHSW_ISR_BMINT_OFFSET	0x015
+#define ETHSW_ISR_BMINT_SHIFT		0
+#define ETHSW_ISR_BMINT_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Ethernet Switch CapabilityRegister 13 (LTQ_GSWIP_3_0)' */
+/* Bit: 'PMAC' */
+/* Description: 'Number of PMAC' */
+#define ETHSW_CAP_13_PMAC_OFFSET	0x016
+#define ETHSW_CAP_13_PMAC_SHIFT	12
+#define ETHSW_CAP_13_PMAC_SIZE		4
+/* Bit: 'PAYLOAD' */
+/* Description: 'Payload Table Size (2**PAYLOAD)' */
+#define ETHSW_CAP_13_PAYLOAD_OFFSET	0x016
+#define ETHSW_CAP_13_PAYLOAD_SHIFT		8
+#define ETHSW_CAP_13_PAYLOAD_SIZE		4
+/* Bit: 'INTRMON' */
+/* Description: 'Interface RMON Counter Table Size(2**INTRMON)' */
+#define ETHSW_CAP_13_INTRMON_OFFSET	0x016
+#define ETHSW_CAP_13_INTRMON_SHIFT		4
+#define ETHSW_CAP_13_INTRMON_SIZE		4
+/* Bit: 'EVLAN' */
+/* Description: 'Egress VLAN Treatment Table Size (2**EVLAN) for GSWIP 3.0
+				 Extended VLAN Tagging Operation table Size (2**EVLAN) for
+				 GSWIP 3.1' */
+#define ETHSW_CAP_13_EVLAN_OFFSET	0x016
+#define ETHSW_CAP_13_EVLAN_SHIFT		0
+#define ETHSW_CAP_13_EVLAN_SIZE		4
+/* ---------------------------------------------------*/
+/* Register: 'Ethernet Switch CapabilityRegister 14 (LTQ_GSWIP_3_0)' */
+/* Bit: 'SMAC' */
+/* Description: 'Routing MAC Table Size for Source MAC (2**SMAC.)' */
+#define ETHSW_CAP_14_SMAC_OFFSET	0x017
+#define ETHSW_CAP_14_SMAC_SHIFT	12
+#define ETHSW_CAP_14_SMAC_SIZE		4
+/* Bit: 'DMAC' */
+/* Description: 'Routing MAC Table Size for Destination MAC (2**DMAC)' */
+#define ETHSW_CAP_14_DMAC_OFFSET	0x017
+#define ETHSW_CAP_14_DMAC_SHIFT	8
+#define ETHSW_CAP_14_DMAC_SIZE		4
+/* Bit: 'PPPoE' */
+/* Description: 'Routing PPPoE Table Size(2**PPPoE)' */
+#define ETHSW_CAP_14_PPPoE_OFFSET	0x017
+#define ETHSW_CAP_14_PPPoE_SHIFT		4
+#define ETHSW_CAP_14_PPPoE_SIZE		4
+/* Bit: 'NAT' */
+/* Description: 'Routing NAT Table Size (2**NAT)' */
+#define ETHSW_CAP_14_NAT_OFFSET	0x017
+#define ETHSW_CAP_14_NAT_SHIFT		0
+#define ETHSW_CAP_14_NAT_SIZE		4
+/* ---------------------------------------------------*/
+/* Register: 'Ethernet Switch CapabilityRegister 15 (LTQ_GSWIP_3_0)' */
+/* Bit: 'MTU' */
+/* Description: 'Routing MTU Table Size (2**MTU)' */
+#define ETHSW_CAP_15_MTU_OFFSET	0x018
+#define ETHSW_CAP_15_MTU_SHIFT		8
+#define ETHSW_CAP_15_MTU_SIZE		4
+/* Bit: 'TUNNEL' */
+/* Description: 'Routing Tunnel Table Size (2**TUNNEL)' */
+#define ETHSW_CAP_15_TUNNEL_OFFSET	0x018
+#define ETHSW_CAP_15_TUNNEL_SHIFT	4
+#define ETHSW_CAP_15_TUNNEL_SIZE		4
+/* Bit: 'RTP' */
+/* Description: 'Routing RTP Table Size (2**RTP)' */
+#define ETHSW_CAP_15_RTP_OFFSET	0x018
+#define ETHSW_CAP_15_RTP_SHIFT		0
+#define ETHSW_CAP_15_RTP_SIZE		4
+
+/*-------------------------------------------------------*/
+/*Applicable only for GSWIP 3.1*/
+/* Bit: 'VLANMAP' */
+/* Description: 'VLAN Filter Table Size (2**VLANMAP) ' */
+#define ETHSW_CAP_16_VLANMAP_OFFSET	0x019
+#define ETHSW_CAP_16_VLANMAP_SHIFT		0
+#define ETHSW_CAP_16_VLANMAP_SIZE		4
+
+/* Multicast HW Snoop */
+#define ETHSW_CAP_16_MCASTHW_OFFSET	0x019
+#define ETHSW_CAP_16_MCASTHW_SHIFT		5
+#define ETHSW_CAP_16_MCASTHW_SIZE		1
+
+/* Bit: 'BRG' */
+/* Description: 'Number of Bridge (2**BRG) ' */
+#define ETHSW_CAP_17_BRG_OFFSET	0x01A
+#define ETHSW_CAP_17_BRG_SHIFT		4
+#define ETHSW_CAP_17_BRG_SIZE		4
+
+/* Bit: 'BRGPT' */
+/* Description: 'Number of Bridge Port (2**BRGPT) ' */
+#define ETHSW_CAP_17_BRGPT_OFFSET	0x01A
+#define ETHSW_CAP_17_BRGPT_SHIFT		0
+#define ETHSW_CAP_17_BRGPT_SIZE			4
+
+/* Bit: 'PMAP' */
+/* Description: 'Number of P-Mapper (2**PMAP) ' */
+#define ETHSW_CAP_17_PMAP_OFFSET	0x01A
+#define ETHSW_CAP_17_PMAP_SHIFT			8
+#define ETHSW_CAP_17_PMAP_SIZE			4
+
+/* Description: 'Number of CTP Port' */
+#define ETHSW_CAP_18_CTP_OFFSET		0x01B
+#define ETHSW_CAP_18_CTP_SHIFT			0
+#define ETHSW_CAP_18_CTP_SIZE			16
+
+/* ---------------------------------------------------*/
+
+/* ---------------------------------------------------*/
+/* Bits: FSLSB	*/
+/* Description: Timer Fractional Nano Second LSB Value (LTQ_GSWIP_2_2 ) */
+#define TIMER_FS_LSB_FSLSB_OFFSET	0x020
+#define TIMER_FS_LSB_FSLSB_SHIFT	0
+#define TIMER_FS_LSB_FSLSB_SIZE		15
+/* --------------------------------------------------- */
+/* Bits: FSMSB	*/
+/* Description: Timer Fractional Nano Second MSB Value  */
+#define TIMER_FS_MSB_FSMSB_OFFSET	0x021
+#define TIMER_FS_MSB_FSMSB_SHIFT	0
+#define TIMER_FS_MSB_FSMSB_SIZE		16
+/* --------------------------------------------------- */
+/* Bits: NSLSB	*/
+/* Description: Timer Nano Second LSB Register  */
+#define TIMER_NS_LSB_NSLSB_OFFSET	0x022
+#define TIMER_NS_LSB_NSLSB_SHIFT	0
+#define TIMER_NS_LSB_NSLSB_SIZE		16
+/* --------------------------------------------------- */
+/* Bits: NSMSB	*/
+/* Description: Timer Nano Second MSB Register  */
+#define TIMER_NS_MSB_NSMSB_OFFSET	0x023
+#define TIMER_NS_MSB_NSMSB_SHIFT	0
+#define TIMER_NS_MSB_NSMSB_SIZE		16
+/* --------------------------------------------------- */
+/* Bits: SECLSB	*/
+/* Description: Timer Second LSB Register  */
+#define TIMER_SEC_LSB_SECLSB_OFFSET	0x024
+#define TIMER_SEC_LSB_SECLSB_SHIFT	0
+#define TIMER_SEC_LSB_SECLSB_SIZE		16
+/* --------------------------------------------------- */
+/* Bits: SECMSB	*/
+/* Description: Timer Second MSB Register  */
+#define TIMER_SEC_MSB_SECMSB_OFFSET	0x025
+#define TIMER_SEC_MSB_SECMSB_SHIFT	0
+#define TIMER_SEC_MSB_SECMSB_SIZE		16
+/* --------------------------------------------------- */
+/* Bit: WR	*/
+/* Description: Write to Timer Command  (LTQ_GSWIP_2_2) */
+#define TIMER_CTRL_WR_OFFSET	0x026
+#define TIMER_CTRL_WR_SHIFT		15
+#define TIMER_CTRL_WR_SIZE		1
+/* Bit: RD	*/
+/* Description: Read from Timer Command  */
+#define TIMER_CTRL_RD_OFFSET	0x026
+#define TIMER_CTRL_RD_SHIFT		14
+#define TIMER_CTRL_RD_SIZE		1
+/* Bit: ADJ	*/
+/* Description: Adjust Timer Command  */
+#define TIMER_CTRL_ADJ_OFFSET	0x026
+#define TIMER_CTRL_ADJ_SHIFT	13
+#define TIMER_CTRL_ADJ_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'RAM Value Register 8' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL8' */
+/* Description: 'Data value [15:0]' */
+#define BM_RAM_VAL_8_VAL8_OFFSET	0x03B
+#define BM_RAM_VAL_8_VAL8_SHIFT		0
+#define BM_RAM_VAL_8_VAL8_SIZE		16
+/* --------------------------------------- */
+/* Register: 'RAM Value Register 7' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL7' */
+/* Description: 'Data value [15:0]' */
+#define BM_RAM_VAL_7_VAL7_OFFSET	0x03C
+#define BM_RAM_VAL_7_VAL7_SHIFT		0
+#define BM_RAM_VAL_7_VAL7_SIZE		16
+/* --------------------------------------- */
+/* Register: 'RAM Value Register 6' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL6' */
+/* Description: 'Data value [15:0]' */
+#define BM_RAM_VAL_6_VAL6_OFFSET	0x03D
+#define BM_RAM_VAL_6_VAL6_SHIFT		0
+#define BM_RAM_VAL_6_VAL6_SIZE		16
+/* --------------------------------------- */
+/* Register: 'RAM Value Register 5' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL5' */
+/* Description: 'Data value [15:0]' */
+#define BM_RAM_VAL_5_VAL5_OFFSET	0x03E
+#define BM_RAM_VAL_5_VAL5_SHIFT		0
+#define BM_RAM_VAL_5_VAL5_SIZE		16
+/* --------------------------------------- */
+/* Register: 'RAM Value Register 4' (LTQ_GSWIP_2_2)*/
+/* Bit: 'VAL4' */
+/* Description: 'Data value [15:0]' */
+#define BM_RAM_VAL_4_VAL4_OFFSET	0x03F
+#define BM_RAM_VAL_4_VAL4_SHIFT		0
+#define BM_RAM_VAL_4_VAL4_SIZE		16
+/* --------------------------------------- */
+/* Register: 'RAM Value Register 3' */
+/* Bit: 'VAL3' */
+/* Description: 'Data value [15:0]' */
+#define BM_RAM_VAL_3_VAL3_OFFSET	0x040
+#define BM_RAM_VAL_3_VAL3_SHIFT		0
+#define BM_RAM_VAL_3_VAL3_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'RAM Value Register 2' */
+/* Bit: 'VAL2' */
+/* Description: 'Data value [15:0]' */
+#define BM_RAM_VAL_2_VAL2_OFFSET	0x041
+#define BM_RAM_VAL_2_VAL2_SHIFT		0
+#define BM_RAM_VAL_2_VAL2_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'RAM Value Register 1' */
+/* Bit: 'VAL1' */
+/* Description: 'Data value [15:0]' */
+#define BM_RAM_VAL_1_VAL1_OFFSET	0x042
+#define BM_RAM_VAL_1_VAL1_SHIFT		0
+#define BM_RAM_VAL_1_VAL1_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'RAM Value Register 0' */
+/* Bit: 'VAL0' */
+/* Description: 'Data value [15:0]' */
+#define BM_RAM_VAL_0_VAL0_OFFSET	0x043
+#define BM_RAM_VAL_0_VAL0_SHIFT		0
+#define BM_RAM_VAL_0_VAL0_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'RAM Address Register' */
+/* Bit: 'ADDR' */
+#define BM_RAM_ADDR_REG_OFFSET		0x044
+/* Description: 'RAM Address' */
+/*For GSWIP 3.0 SIZE 11 and For GSWIP 3.1 SIZE 16*/
+#define BM_RAM_ADDR_ADDR_OFFSET		0x044
+#define BM_RAM_ADDR_ADDR_SHIFT		0
+#define BM_RAM_ADDR_ADDR_SIZE		16
+
+/*Applicable only for GSWIP 3.1*/
+#define BM_RAM_ADDR_RMON_COUNTER_OFFSET	0x044
+#define BM_RAM_ADDR_RMON_COUNTER_SHIFT	0
+#define BM_RAM_ADDR_RMON_COUNTER_SIZE   6
+
+#define BM_RAM_ADDR_RMON_PORT_OFFSET	0x044
+#define BM_RAM_ADDR_RMON_PORT_SHIFT		6
+#define BM_RAM_ADDR_RMON_PORT_SIZE    	10
+
+//Meter RMON Number
+#define BM_RAM_ADDR_RMON_METER_NUM_OFFSET	0x044
+#define BM_RAM_ADDR_RMON_METER_NUM_SHIFT	0
+#define BM_RAM_ADDR_RMON_METER_NUM_SIZE    	7
+//Meter RMON Colour
+#define BM_RAM_ADDR_RMON_METER_CLR_OFFSET	0x044
+#define BM_RAM_ADDR_RMON_METER_CLR_SHIFT	8
+#define BM_RAM_ADDR_RMON_METER_CLR_SIZE    	2
+
+#define BM_RAM_ADDR_RMON_PMAC_NO_OFFSET	0x044
+#define BM_RAM_ADDR_RMON_PMAC_NO_SHIFT	8
+#define BM_RAM_ADDR_RMON_PMAC_NO_SIZE   3
+
+#define BM_RAM_ADDR_RMON_PMAC_COUNTER_OFFSET	0x044
+#define BM_RAM_ADDR_RMON_PMAC_COUNTER_SHIFT		5
+#define BM_RAM_ADDR_RMON_PMAC_COUNTER_SIZE    	3
+
+/* Tx Dma Channel ID or Source Port ID */
+#define BM_RAM_ADDR_RMON_PMAC_ID_OFFSET		0x044
+#define BM_RAM_ADDR_RMON_PMAC_ID_SHIFT		0
+#define BM_RAM_ADDR_RMON_PMAC_ID_SIZE    	5
+
+/* --------------------------------------------------- */
+/* Register: 'RAM Access Control Register' */
+/* Bit: 'BAS' */
+#define BM_RAM_CTRL_REG_OFFSET		0x045
+/* Description: 'Access Busy/Access Start' */
+#define BM_RAM_CTRL_BAS_OFFSET		0x045
+#define BM_RAM_CTRL_BAS_SHIFT		15
+#define BM_RAM_CTRL_BAS_SIZE		1
+/* Bit: 'OPMOD' */
+/* Description: 'Lookup Table Access Operation Mode' */
+#define BM_RAM_CTRL_OPMOD_OFFSET	0x045
+#define BM_RAM_CTRL_OPMOD_SHIFT		5
+#define BM_RAM_CTRL_OPMOD_SIZE		1
+
+/*Applicable for only GSWIP 3.1*/
+#define BM_RAM_CTRL_64BIT_OPMOD_OFFSET	0x045
+#define BM_RAM_CTRL_64BIT_OPMOD_SHIFT	6
+#define BM_RAM_CTRL_64BIT_OPMOD_SIZE	1
+
+/* Bit: 'ADDR' */
+/* Description: 'Address for RAM selection' */
+#define BM_RAM_CTRL_ADDR_OFFSET		0x045
+#define BM_RAM_CTRL_ADDR_SHIFT		0
+#define BM_RAM_CTRL_ADDR_SIZE		5
+
+/* --------------------------------------------------- */
+/* Register: 'Free Segment Queue ManagerGlobal Control Register' */
+/* Bit: 'SEGNUM' */
+/* Description: 'Maximum Segment Number' */
+#define BM_FSQM_GCTRL_SEGNUM_OFFSET	0x046
+#define BM_FSQM_GCTRL_SEGNUM_SHIFT	0
+#define BM_FSQM_GCTRL_SEGNUM_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'Number of Consumed SegmentsRegister' */
+/* Bit: 'FSEG' */
+/* Description: 'Number of Consumed Segments' */
+#define BM_CONS_SEG_FSEG_OFFSET	0x047
+#define BM_CONS_SEG_FSEG_SHIFT	0
+#define BM_CONS_SEG_FSEG_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'Number of Consumed PacketPointers Register' */
+/* Bit: 'FQP' */
+/* Description: 'Number of Consumed Packet Pointers' */
+#define BM_CONS_PKT_FQP_OFFSET	0x048
+#define BM_CONS_PKT_FQP_SHIFT		0
+#define BM_CONS_PKT_FQP_SIZE		11
+/* --------------------------------------------------- */
+/* Register: 'Buffer Manager Global ControlRegister 0' */
+/* Bit: 'FR_RERGC' (LTQ_GSWIP_3_0)*/
+/* Description: 'Freeze RMON Redirection RX Byte 64 Bit Counter' */
+#define BM_GCTRL_FR_RERGC_OFFSET	0x049
+#define BM_GCTRL_FR_RERGC_SHIFT		15
+#define BM_GCTRL_FR_RERGC_SIZE		1
+/* Bit: 'FR_RETGC' (LTQ_GSWIP_3_0)*/
+/* Description: 'Freeze RMON Redirection TX Byte 64 Bit Counter' */
+#define BM_GCTRL_FR_RETGC_OFFSET	0x049
+#define BM_GCTRL_FR_RETGC_SHIFT		14
+#define BM_GCTRL_FR_RETGC_SIZE		1
+/* Bit: 'BM_STA' */
+/* Description: 'Buffer Manager Initialization Status Bit' */
+#define BM_GCTRL_BM_STA_OFFSET	0x049
+#define BM_GCTRL_BM_STA_SHIFT		13
+#define BM_GCTRL_BM_STA_SIZE		1
+/* Bit: 'SAT' */
+/* Description: 'RMON Counter Update Mode' */
+#define BM_GCTRL_SAT_OFFSET	0x049
+#define BM_GCTRL_SAT_SHIFT	12
+#define BM_GCTRL_SAT_SIZE		1
+/* Bit: 'FR_RBC' */
+/* Description: 'Freeze RMON RX Bad Byte 64 Bit Counter' */
+#define BM_GCTRL_FR_RBC_OFFSET	0x049
+#define BM_GCTRL_FR_RBC_SHIFT		11
+#define BM_GCTRL_FR_RBC_SIZE		1
+/* Bit: 'FR_RGC' */
+/* Description: 'Freeze RMON RX Good Byte 64 Bit Counter' */
+#define BM_GCTRL_FR_RGC_OFFSET	0x049
+#define BM_GCTRL_FR_RGC_SHIFT		10
+#define BM_GCTRL_FR_RGC_SIZE		1
+/* Bit: 'FR_TGC' */
+/* Description: 'Freeze RMON TX Good Byte 64 Bit Counter' */
+#define BM_GCTRL_FR_TGC_OFFSET	0x049
+#define BM_GCTRL_FR_TGC_SHIFT		9
+#define BM_GCTRL_FR_TGC_SIZE		1
+/* Bit: 'I_FIN' */
+/* Description: 'RAM initialization finished' */
+#define BM_GCTRL_I_FIN_OFFSET	0x049
+#define BM_GCTRL_I_FIN_SHIFT	8
+#define BM_GCTRL_I_FIN_SIZE		1
+/* Bit: 'CX_INI' */
+/* Description: 'PQM Context RAM initialization' */
+#define BM_GCTRL_CX_INI_OFFSET	0x049
+#define BM_GCTRL_CX_INI_SHIFT		7
+#define BM_GCTRL_CX_INI_SIZE		1
+/* Bit: 'FP_INI' */
+/* Description: 'FPQM RAM initialization' */
+#define BM_GCTRL_FP_INI_OFFSET	0x049
+#define BM_GCTRL_FP_INI_SHIFT		6
+#define BM_GCTRL_FP_INI_SIZE		1
+/* Bit: 'FS_INI' */
+/* Description: 'FSQM RAM initialization' */
+#define BM_GCTRL_FS_INI_OFFSET	0x049
+#define BM_GCTRL_FS_INI_SHIFT		5
+#define BM_GCTRL_FS_INI_SIZE		1
+/* Bit: 'R_SRES' */
+/* Description: 'Software Reset for RMON' */
+#define BM_GCTRL_R_SRES_OFFSET	0x049
+#define BM_GCTRL_R_SRES_SHIFT		4
+#define BM_GCTRL_R_SRES_SIZE		1
+/* Bit: 'S_SRES' */
+/* Description: 'Software Reset for Scheduler' */
+#define BM_GCTRL_S_SRES_OFFSET	0x049
+#define BM_GCTRL_S_SRES_SHIFT		3
+#define BM_GCTRL_S_SRES_SIZE		1
+/* Bit: 'A_SRES' */
+/* Description: 'Software Reset for AVG' */
+#define BM_GCTRL_A_SRES_OFFSET	0x049
+#define BM_GCTRL_A_SRES_SHIFT		2
+#define BM_GCTRL_A_SRES_SIZE		1
+/* Bit: 'P_SRES' */
+/* Description: 'Software Reset for PQM' */
+#define BM_GCTRL_P_SRES_OFFSET	0x049
+#define BM_GCTRL_P_SRES_SHIFT		1
+#define BM_GCTRL_P_SRES_SIZE		1
+/* Bit: 'F_SRES' */
+/* Description: 'Software Reset for FSQM' */
+#define BM_GCTRL_F_SRES_OFFSET	0x049
+#define BM_GCTRL_F_SRES_SHIFT		0
+#define BM_GCTRL_F_SRES_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Queue Manager GlobalControl Register 0' */
+/* Bit: 'BUFMOD' (LTQ_GSWIP_3_0) */
+/* Description: 'Congestion Notification Watermark' */
+#define BM_QUEUE_GCTRL_QBPWM_OFFSET	0x04A
+#define BM_QUEUE_GCTRL_QBPWM_SHIFT	13
+#define BM_QUEUE_GCTRL_QBPWM_SIZE	2
+/* Description: 'Buffer Control Mode' */
+#define BM_QUEUE_GCTRL_BUFMOD_OFFSET	0x04A
+#define BM_QUEUE_GCTRL_BUFMOD_SHIFT		12
+#define BM_QUEUE_GCTRL_BUFMOD_SIZE		1
+/* Bit: 'GL_MOD' */
+/* Description: 'WRED Mode Signal' */
+#define BM_QUEUE_GCTRL_GL_MOD_OFFSET	0x04A
+#define BM_QUEUE_GCTRL_GL_MOD_SHIFT		10
+#define BM_QUEUE_GCTRL_GL_MOD_SIZE		1
+/* Size is 2 bit wide for 2.2, 3.0 and 3.1 */
+#define BM_QUEUE_GCTRL_GL_MOD_SIZE2		2
+
+
+/* Bit: 'AQUI' */
+/* Description: 'Average Queue Update Interval' */
+#define BM_QUEUE_GCTRL_AQUI_OFFSET	0x04A
+#define BM_QUEUE_GCTRL_AQUI_SHIFT		7
+#define BM_QUEUE_GCTRL_AQUI_SIZE		3
+/* Bit: 'AQWF' */
+/* Description: 'Average Queue Weight Factor' */
+#define BM_QUEUE_GCTRL_AQWF_OFFSET	0x04A
+#define BM_QUEUE_GCTRL_AQWF_SHIFT		3
+#define BM_QUEUE_GCTRL_AQWF_SIZE		4
+/* Bit: 'QAVGEN' */
+/* Description: 'Queue Average Calculation Enable' */
+#define BM_QUEUE_GCTRL_QAVGEN_OFFSET	0x04A
+#define BM_QUEUE_GCTRL_QAVGEN_SHIFT		2
+#define BM_QUEUE_GCTRL_QAVGEN_SIZE		1
+/* Bit: 'DPROB' */
+/* Description: 'Drop Probability Profile' */
+#define BM_QUEUE_GCTRL_DPROB_OFFSET	0x04A
+#define BM_QUEUE_GCTRL_DPROB_SHIFT	0
+#define BM_QUEUE_GCTRL_DPROB_SIZE		2
+/* --------------------------------------------------- */
+/* Register: 'WRED Red Threshold Register0' */
+/* Bit: 'MINTH' */
+/* Description: 'Minimum Threshold' */
+#define BM_WRED_RTH_0_MINTH_OFFSET	0x04B
+#define BM_WRED_RTH_0_MINTH_SHIFT		0
+#define BM_WRED_RTH_0_MINTH_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'WRED Red Threshold Register1' */
+/* Bit: 'MAXTH' */
+/* Description: 'Maximum Threshold' */
+#define BM_WRED_RTH_1_MAXTH_OFFSET	0x04C
+#define BM_WRED_RTH_1_MAXTH_SHIFT		0
+#define BM_WRED_RTH_1_MAXTH_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'WRED Yellow ThresholdRegister 0' */
+/* Bit: 'MINTH' */
+/* Description: 'Minimum Threshold' */
+#define BM_WRED_YTH_0_MINTH_OFFSET	0x04D
+#define BM_WRED_YTH_0_MINTH_SHIFT		0
+#define BM_WRED_YTH_0_MINTH_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'WRED Yellow ThresholdRegister 1' */
+/* Bit: 'MAXTH' */
+/* Description: 'Maximum Threshold' */
+#define BM_WRED_YTH_1_MAXTH_OFFSET	0x04E
+#define BM_WRED_YTH_1_MAXTH_SHIFT		0
+#define BM_WRED_YTH_1_MAXTH_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'WRED Green ThresholdRegister 0' */
+/* Bit: 'MINTH' */
+/* Description: 'Minimum Threshold' */
+#define BM_WRED_GTH_0_MINTH_OFFSET	0x04F
+#define BM_WRED_GTH_0_MINTH_SHIFT		0
+#define BM_WRED_GTH_0_MINTH_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'WRED Green ThresholdRegister 1' */
+/* Bit: 'MAXTH' */
+/* Description: 'Maximum Threshold' */
+#define BM_WRED_GTH_1_MAXTH_OFFSET	0x050
+#define BM_WRED_GTH_1_MAXTH_SHIFT		0
+#define BM_WRED_GTH_1_MAXTH_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'Drop Threshold ConfigurationRegister 0' */
+/* Bit: 'THR_FQ' */
+/* Description: 'Threshold for frames marked red' */
+#define BM_DROP_GTH_0_THR_FQ_OFFSET	0x051
+#define BM_DROP_GTH_0_THR_FQ_SHIFT	0
+#define BM_DROP_GTH_0_THR_FQ_SIZE		11
+/* --------------------------------------------------- */
+/* Register: 'Drop Threshold ConfigurationRegister 1' */
+/* Bit: 'THY_FQ' */
+/* Description: 'Threshold for frames marked yellow' */
+#define BM_DROP_GTH_1_THY_FQ_OFFSET	0x052
+#define BM_DROP_GTH_1_THY_FQ_SHIFT	0
+#define BM_DROP_GTH_1_THY_FQ_SIZE		11
+/* --------------------------------------------------- */
+/* Register: 'Drop Threshold ConfigurationRegister 2' */
+/* Bit: 'THG_FQ' */
+/* Description: 'Threshold for frames marked green' */
+#define BM_DROP_GTH_2_THG_FQ_OFFSET	0x053
+#define BM_DROP_GTH_2_THG_FQ_SHIFT	0
+#define BM_DROP_GTH_2_THG_FQ_SIZE		11
+/* --------------------------------------------------- */
+/* Register: 'Buffer Manager Global InterruptEnable Register' */
+/* Bit: 'CNT4' */
+/* Description: 'Counter Group 4 (RMON-CLASSIFICATION) Interrupt*/
+/* Enable' */
+#define BM_IER_CNT4_OFFSET	0x054
+#define BM_IER_CNT4_SHIFT		7
+#define BM_IER_CNT4_SIZE		1
+/* Bit: 'CNT3' */
+/* Description: 'Counter Group 3 (RMON-PQM) Interrupt Enable' */
+#define BM_IER_CNT3_OFFSET	0x054
+#define BM_IER_CNT3_SHIFT		6
+#define BM_IER_CNT3_SIZE		1
+/* Bit: 'CNT2' */
+/* Description: 'Counter Group 2 (RMON-SCHEDULER) Interrupt Enable' */
+#define BM_IER_CNT2_OFFSET	0x054
+#define BM_IER_CNT2_SHIFT		5
+#define BM_IER_CNT2_SIZE		1
+/* Bit: 'CNT1' */
+/* Description: 'Counter Group 1 (RMON-QFETCH) Interrupt Enable' */
+#define BM_IER_CNT1_OFFSET	0x054
+#define BM_IER_CNT1_SHIFT		4
+#define BM_IER_CNT1_SIZE		1
+/* Bit: 'CNT0' */
+/* Description: 'Counter Group 0 (RMON-QSTOR) Interrupt Enable' */
+#define BM_IER_CNT0_OFFSET	0x054
+#define BM_IER_CNT0_SHIFT		3
+#define BM_IER_CNT0_SIZE		1
+/* Bit: 'DEQ' */
+/* Description: 'PQM dequeue Interrupt Enable' */
+#define BM_IER_DEQ_OFFSET	0x054
+#define BM_IER_DEQ_SHIFT	2
+#define BM_IER_DEQ_SIZE		1
+/* Bit: 'ENQ' */
+/* Description: 'PQM Enqueue Interrupt Enable' */
+#define BM_IER_ENQ_OFFSET	0x054
+#define BM_IER_ENQ_SHIFT	1
+#define BM_IER_ENQ_SIZE		1
+/* Bit: 'FSQM' */
+/* Description: 'Buffer Empty Interrupt Enable' */
+#define BM_IER_FSQM_OFFSET	0x054
+#define BM_IER_FSQM_SHIFT		0
+#define BM_IER_FSQM_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Buffer Manager Global InterruptStatus Register'(LTQ_GSWIP_2_2) */
+/* Bit: 'EQCGN' */
+/* Description: 'Egress Queue Congestion Status Change Interrupt' */
+#define BM_ISR_EQCGN_OFFSET	0x055
+#define BM_ISR_EQCGN_SHIFT	8
+#define BM_ISR_EQCGN_SIZE		1
+/* Bit: 'CNT4' */
+/* Description: 'Counter Group 4 Interrupt' */
+#define BM_ISR_CNT4_OFFSET	0x055
+#define BM_ISR_CNT4_SHIFT		7
+#define BM_ISR_CNT4_SIZE		1
+/* Bit: 'CNT3' */
+/* Description: 'Counter Group 3 Interrupt' */
+#define BM_ISR_CNT3_OFFSET	0x055
+#define BM_ISR_CNT3_SHIFT		6
+#define BM_ISR_CNT3_SIZE		1
+/* Bit: 'CNT2' */
+/* Description: 'Counter Group 2 Interrupt' */
+#define BM_ISR_CNT2_OFFSET	0x055
+#define BM_ISR_CNT2_SHIFT		5
+#define BM_ISR_CNT2_SIZE		1
+/* Bit: 'CNT1' */
+/* Description: 'Counter Group 1 Interrupt' */
+#define BM_ISR_CNT1_OFFSET	0x055
+#define BM_ISR_CNT1_SHIFT		4
+#define BM_ISR_CNT1_SIZE		1
+/* Bit: 'CNT0' */
+/* Description: 'Counter Group 0 Interrupt' */
+#define BM_ISR_CNT0_OFFSET	0x055
+#define BM_ISR_CNT0_SHIFT		3
+#define BM_ISR_CNT0_SIZE		1
+/* Bit: 'DEQ' */
+/* Description: 'PQM dequeue Interrupt Enable' */
+#define BM_ISR_DEQ_OFFSET		0x055
+#define BM_ISR_DEQ_SHIFT		2
+#define BM_ISR_DEQ_SIZE			1
+/* Bit: 'ENQ' */
+/* Description: 'PQM Enqueue Interrupt' */
+#define BM_ISR_ENQ_OFFSET		0x055
+#define BM_ISR_ENQ_SHIFT		1
+#define BM_ISR_ENQ_SIZE			1
+/* Bit: 'FSQM' */
+/* Description: 'Buffer Empty Interrupt' */
+#define BM_ISR_FSQM_OFFSET	0x055
+#define BM_ISR_FSQM_SHIFT		0
+#define BM_ISR_FSQM_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Buffer Manager RMON CounterInterrupt Select Register' */
+/* Bit: 'PORT' */
+/* Description: 'Port Number' */
+#define BM_CISEL_PORT_OFFSET	0x056
+#define BM_CISEL_PORT_SHIFT		0
+#define BM_CISEL_PORT_SIZE		4
+/* --------------------------------------------------- */
+/* Register: 'Debug Control Register' */
+/* Bit: 'DBG_SEL' */
+/* Description: 'Select Signal for Debug Multiplexer' */
+#define BM_DEBUG_CTRL_DBG_SEL_OFFSET	0x057
+#define BM_DEBUG_CTRL_DBG_SEL_SHIFT		0
+#define BM_DEBUG_CTRL_DBG_SEL_SIZE		8
+/* --------------------------------------------------- */
+/* Register: 'Debug Value Register' */
+/* Bit: 'DBG_DAT' */
+/* Description: 'Debug Data Value' */
+#define BM_DEBUG_VAL_DBG_DAT_OFFSET	0x058
+#define BM_DEBUG_VAL_DBG_DAT_SHIFT	0
+#define BM_DEBUG_VAL_DBG_DAT_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'BM Egress Queue Congestion Notification */
+/* Status Register 0'(LTQ_GSWIP_2_2) */
+/* Bit: 'EQCGN0' */
+/* Description: 'Egress Queue Congestion Notification Queue 15 to 0' */
+#define BM_EQCGN0_EQCGN0_OFFSET	0x059
+#define BM_EQCGN0_EQCGN0_SHIFT	0
+#define BM_EQCGN0_EQCGN0_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'BM Egress Queue Congestion Notification Status */
+/* Register 1'(LTQ_GSWIP_2_2) */
+/* Bit: 'EQCGN1' */
+/* Description: 'Egress Queue Congestion Notification Queue 31 to 16' */
+#define BM_EQCGN1_EQCGN1_OFFSET	0x05A
+#define BM_EQCGN1_EQCGN1_SHIFT	0
+#define BM_EQCGN1_EQCGN1_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'BM Egress Queue Congestion Notification Status Register 2' */
+/* Bit: 'EQCGN2' */
+/* Description: 'Egress Queue Congestion Notification Queue 39 to 32' */
+/*	 (LTQ_GSWIP_2_2)*/
+#define BM_EQCGN2_EQCGN2_OFFSET	0x05B
+#define BM_EQCGN2_EQCGN2_SHIFT	0
+#define BM_EQCGN2_EQCGN2_SIZE		8
+/* --------------------------------------------------- */
+/* Register: 'BM WFQ and Shaper Overhead Byte Configuration' */
+/* Bit: 'OVERHD' (LTQ_GSWIP_2_2) */
+/* Description: 'BM WFQ and Shaper Overhead Byte' */
+#define BM_OVERHD_OVERHD_OFFSET	0x061
+#define BM_OVERHD_OVERHD_SHIFT	0
+#define BM_OVERHD_OVERHD_SIZE		8
+/* --------------------------------------------------- */
+/* Register: 'BM RMON Global Control Configuration'(LTQ_GSWIP_3_0) */
+/* Bit: 'INTMON' */
+/* Description: 'Interface RMON Counter Mode' */
+#define BM_RMON_GCTRL_INTMON_OFFSET	0x062
+#define BM_RMON_GCTRL_INTMON_SHIFT	15
+#define BM_RMON_GCTRL_INTMON_SIZE	1
+/* Bit: 'MRMON' */
+/* Description: 'Meter RMON Counter Mode' */
+#define BM_RMON_GCTRL_MRMON_OFFSET	0x062
+#define BM_RMON_GCTRL_MRMON_SHIFT		14
+#define BM_RMON_GCTRL_MRMON_SIZE		1
+/* Bit: 'MRMON' */
+/* Description: 'PMAC RMON Counter Mode' */
+#define BM_RMON_GCTRL_PMAC_RES_OFFSET	0x062
+#define BM_RMON_GCTRL_PMAC_RES_SHIFT	12
+#define BM_RMON_GCTRL_PMAC_RES_SIZE		1
+/* Bit: 'ITFID' */
+/* Description: 'Interface ID to be Reset' */
+#define BM_RMON_GCTRL_ITFID_OFFSET	0x062
+#define BM_RMON_GCTRL_ITFID_SHIFT		4
+#define BM_RMON_GCTRL_ITFID_SIZE		8
+/* Bit: 'INT_RES' */
+/* Description: 'Software Reset for a Single Interface RMON RAM' */
+#define BM_RMON_GCTRL_INT_RES_OFFSET	0x062
+#define BM_RMON_GCTRL_INT_RES_SHIFT		3
+#define BM_RMON_GCTRL_INT_RES_SIZE		1
+/* Bit: 'ALLITF_RES' */
+/* Description: 'Software Reset for All Interface RMON RAM' */
+#define BM_RMON_GCTRL_ALLITF_RES_OFFSET	0x062
+#define BM_RMON_GCTRL_ALLITF_RES_SHIFT	2
+#define BM_RMON_GCTRL_ALLITF_RES_SIZE	1
+/* Bit: 'METER_RES' */
+/* Description: 'Software Reset for Meter RMON RAM' */
+#define BM_RMON_GCTRL_METER_RES_OFFSET	0x062
+#define BM_RMON_GCTRL_METER_RES_SHIFT	1
+#define BM_RMON_GCTRL_METER_RES_SIZE	1
+/* Bit: 'RED_RES' */
+/* Description: ' Software Reset for Redirection RMON RAM' */
+#define BM_RMON_GCTRL_RED_RES_OFFSET	0x062
+#define BM_RMON_GCTRL_RED_RES_SHIFT		0
+#define BM_RMON_GCTRL_RED_RES_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'BM PCE TFLOW Rx RMON counter (LTQ_GSWIP_3_1) */
+#define BM_RXFLOW_RMON_REG_OFFSET 	0x063
+/* Bit: 'MD' */
+/* Description: 'RMON counting mode' */
+#define BM_RXFLOW_RMON_MD_OFFSET	0x063
+#define BM_RXFLOW_RMON_MD_SHIFT		14
+#define BM_RXFLOW_RMON_MD_SIZE		2
+/* Bit: 'LSB' */
+/* Description: 'Numer of valid bits' */
+#define BM_RXFLOW_RMON_LSB_OFFSET	0x063
+#define BM_RXFLOW_RMON_LSB_SHIFT	9
+#define BM_RXFLOW_RMON_LSB_SIZE		3
+/* Bit: 'MSB' */
+/* Description: 'CTP/Bridge port number' */
+#define BM_RXFLOW_RMON_MSB_OFFSET	0x063
+#define BM_RXFLOW_RMON_MSB_SHIFT	3
+#define BM_RXFLOW_RMON_MSB_SIZE		6
+/* --------------------------------------------------- */
+/* Register: 'BM PCE TFLOW Tx RMON counter (LTQ_GSWIP_3_1) */
+#define BM_TXFLOW_RMON_REG_OFFSET 	0x064
+/* Bit: 'MD' */
+/* Description: 'RMON counting mode' */
+#define BM_TXFLOW_RMON_MD_OFFSET	0x064
+#define BM_TXFLOW_RMON_MD_SHIFT		14
+#define BM_TXFLOW_RMON_MD_SIZE		2
+/* Bit: 'LSB' */
+/* Description: 'Numer of valid bits' */
+#define BM_TXFLOW_RMON_LSB_OFFSET	0x064
+#define BM_TXFLOW_RMON_LSB_SHIFT	9
+#define BM_TXFLOW_RMON_LSB_SIZE		3
+/* Bit: 'MSB' */
+/* Description: 'CTP/Bridge port number' */
+#define BM_TXFLOW_RMON_MSB_OFFSET	0x064
+#define BM_TXFLOW_RMON_MSB_SHIFT	3
+#define BM_TXFLOW_RMON_MSB_SIZE		6
+/* --------------------------------------------------- */
+/* Register: 'BM PCE-Bypass TFLOW Tx RMON counter (LTQ_GSWIP_3_1) */
+#define BM_TXBPFLOW_RMON_REG_OFFSET 0x065
+/* Bit: 'MD' */
+/* Description: 'RMON counting mode' */
+#define BM_TXBPFLOW_RMON_MD_OFFSET	0x065
+#define BM_TXBPFLOW_RMON_MD_SHIFT	14
+#define BM_TXBPFLOW_RMON_MD_SIZE	2
+/* Bit: 'LSB' */
+/* Description: 'Numer of valid bits' */
+#define BM_TXBPFLOW_RMON_LSB_OFFSET	0x065
+#define BM_TXBPFLOW_RMON_LSB_SHIFT	9
+#define BM_TXBPFLOW_RMON_LSB_SIZE	3
+/* Bit: 'MSB' */
+/* Description: 'CTP/Bridge port number' */
+#define BM_TXBPFLOW_RMON_MSB_OFFSET	0x065
+#define BM_TXBPFLOW_RMON_MSB_SHIFT	3
+#define BM_TXBPFLOW_RMON_MSB_SIZE	6
+/* --------------------------------------------------- */
+/* Register: 'Buffer Manager PortConfiguration Register' */
+/* Bit: 'IGCNT' */
+/* Description: 'Ingress Special Tag RMON count' */
+#define BM_PCFG_IGCNT_OFFSET	0x080
+#define BM_PCFG_IGCNT_SHIFT		1
+#define BM_PCFG_IGCNT_SIZE		1
+/* Bit: 'CNTEN' */
+/* Description: 'RMON Counter Enable' */
+#define BM_PCFG_CNTEN_OFFSET	0x080
+#define BM_PCFG_CNTEN_SHIFT		0
+#define BM_PCFG_CNTEN_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Buffer ManagerRMON Control Register' */
+/* Bit: 'IFRMONFST' (LTQ_GSWIP_3_0)*/
+/* Description: 'Interface RMON Counter First Entry Index' */
+#define BM_RMON_CTRL_IFRMONFST_OFFSET	0x081
+#define BM_RMON_CTRL_IFRMONFST_SHIFT	8
+#define BM_RMON_CTRL_IFRMONFST_SIZE		8
+/* Bit: 'IFRMONMD' (LTQ_GSWIP_3_0)*/
+/* Description: 'Interface RMON Counter Control' */
+#define BM_RMON_CTRL_IFRMONMD_OFFSET	0x081
+#define BM_RMON_CTRL_IFRMONMD_SHIFT		6
+#define BM_RMON_CTRL_IFRMONMD_SIZE		2
+/* Bit: 'ROUT_RES' (LTQ_GSWIP_3_0)*/
+/* Description: 'Software Reset for Routing RMON RAM' */
+#define BM_RMON_CTRL_ROUT_RES_OFFSET	0x081
+#define BM_RMON_CTRL_ROUT_RES_SHIFT		3
+#define BM_RMON_CTRL_ROUT_RES_SIZE		1
+/* Bit: 'BCAST_CNT' (LTQ_GSWIP_2_2)*/
+/* Description: 'Broadcast Counter Control' */
+#define BM_RMON_CTRL_BCAST_CNT_OFFSET	0x081
+#define BM_RMON_CTRL_BCAST_CNT_SHIFT	2
+#define BM_RMON_CTRL_BCAST_CNT_SIZE		1
+/* Bit: 'RAM2_RES' */
+/* Description: 'Software Reset for RMON RAM2' */
+#define BM_RMON_CTRL_RAM2_RES_OFFSET	0x081
+#define BM_RMON_CTRL_RAM2_RES_SHIFT		1
+#define BM_RMON_CTRL_RAM2_RES_SIZE		1
+/* Bit: 'RAM1_RES' */
+/* Description: 'Software Reset for RMON RAM1' */
+#define BM_RMON_CTRL_RAM1_RES_OFFSET	0x081
+#define BM_RMON_CTRL_RAM1_RES_SHIFT		0
+#define BM_RMON_CTRL_RAM1_RES_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'WRED Port Red Threshold Register 0' (LTQ_GSWIP_2_2) */
+/* Bit: 'MINTH' */
+/* Description: 'Minimum Threshold' */
+#define BM_PWRED_RTH_0_MINTH_OFFSET	0x0A0
+#define BM_PWRED_RTH_0_MINTH_SHIFT	0
+#define BM_PWRED_RTH_0_MINTH_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'WRED Port Red Threshold Register 1' (LTQ_GSWIP_2_2)*/
+/* Bit: 'MAXTH' */
+/* Description: 'Minimum Threshold' */
+#define BM_PWRED_RTH_1_MAXTH_OFFSET	0x0A1
+#define BM_PWRED_RTH_1_MAXTH_SHIFT	0
+#define BM_PWRED_RTH_1_MAXTH_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'WRED Port Yellow Threshold Register 0'(LTQ_GSWIP_2_2) */
+/* Bit: 'MINTH' */
+/* Description: 'Minimum Threshold' */
+#define BM_PWRED_YTH_0_MINTH_OFFSET	0x0A2
+#define BM_PWRED_YTH_0_MINTH_SHIFT	0
+#define BM_PWRED_YTH_0_MINTH_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'WRED Port Yellow Threshold Register 1' (LTQ_GSWIP_2_2)*/
+/* Bit: 'MAXTH' */
+/* Description: 'Minimum Threshold' */
+#define BM_PWRED_YTH_1_MAXTH_OFFSET	0x0A3
+#define BM_PWRED_YTH_1_MAXTH_SHIFT	0
+#define BM_PWRED_YTH_1_MAXTH_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'WRED Port Green Threshold Register 0' (LTQ_GSWIP_2_2)*/
+/* Bit: 'MINTH' */
+/* Description: 'Minimum Threshold' */
+#define BM_PWRED_GTH_0_MINTH_OFFSET	0x0A4
+#define BM_PWRED_GTH_0_MINTH_SHIFT	0
+#define BM_PWRED_GTH_0_MINTH_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'WRED Port Green Threshold Register 1' (LTQ_GSWIP_2_2)*/
+/* Bit: 'MAXTH' */
+/* Description: 'Minimum Threshold' */
+#define BM_PWRED_GTH_1_MAXTH_OFFSET	0x0A5
+#define BM_PWRED_GTH_1_MAXTH_SHIFT	0
+#define BM_PWRED_GTH_1_MAXTH_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'Packet Queue ManagerRate Shaper Assignment Register' */
+/* Bit: 'EN2' */
+/* Description: 'Rate Shaper 2 Enable' */
+#define PQM_RS_EN2_OFFSET	0x101
+#define PQM_RS_EN2_SHIFT	15
+#define PQM_RS_EN2_SIZE		1
+/* Bit: 'RS2' */
+/* Description: 'Rate Shaper 2' */
+#define PQM_RS_RS2_OFFSET	0x101
+#define PQM_RS_RS2_SHIFT	8
+#define PQM_RS_RS2_SIZE		5
+/* Bit: 'EN1' */
+/* Description: 'Rate Shaper 1 Enable' */
+#define PQM_RS_EN1_OFFSET	0x101
+#define PQM_RS_EN1_SHIFT	7
+#define PQM_RS_EN1_SIZE		1
+/* Bit: 'RS1' */
+/* Description: 'Rate Shaper 1' */
+#define PQM_RS_RS1_OFFSET	0x101
+#define PQM_RS_RS1_SHIFT	0
+#define PQM_RS_RS1_SIZE		5
+/* --------------------------------------------------- */
+/* Register: 'Rate Shaper ControlRegister' (LTQ_GSWIP_2_2) */
+/* Bit: 'RSMOD' */
+/* Description: 'Rate Shaper Mode' */
+#define RS_CTRL_RSMOD_OFFSET	0x140
+#define RS_CTRL_RSMOD_SHIFT		1
+#define RS_CTRL_RSMOD_SIZE		1
+/* Bit: 'RSEN' */
+/* Description: 'Rate Shaper Enable' */
+#define RS_CTRL_RSEN_OFFSET		0x140
+#define RS_CTRL_RSEN_SHIFT		0
+#define RS_CTRL_RSEN_SIZE			1
+/* --------------------------------------------------- */
+/* Register: 'Rate Shaper CommittedBurst Size Register' */
+/* Bit: 'CBS' */
+/* Description: 'Committed Burst Size' */
+#define RS_CBS_CBS_OFFSET	0x141
+#define RS_CBS_CBS_SHIFT	0
+#define RS_CBS_CBS_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'Rate Shaper InstantaneousBurst Size Register' */
+/* Bit: 'IBS' */
+/* Description: 'Instantaneous Burst Size' */
+#define RS_IBS_IBS_OFFSET	0x142
+#define RS_IBS_IBS_SHIFT	0
+#define RS_IBS_IBS_SIZE		2
+/* Size changed for GSwIP 3.1 */
+#define RS_IBS_IBS_SIZE_GSWIP_3_1  10
+/* --------------------------------------------------- */
+/* Register: 'Rate Shaper RateExponent Register' */
+/* Bit: 'EXP' */
+/* Description: 'Exponent' */
+#define RS_CIR_EXP_EXP_OFFSET	0x143
+#define RS_CIR_EXP_EXP_SHIFT	0
+#define RS_CIR_EXP_EXP_SIZE		4
+/* --------------------------------------------------- */
+/* Register: 'Rate Shaper RateMantissa Register' */
+/* Bit: 'MANT' */
+/* Description: 'Mantissa' */
+#define RS_CIR_MANT_MANT_OFFSET	0x144
+#define RS_CIR_MANT_MANT_SHIFT	0
+#define RS_CIR_MANT_MANT_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'Table Mask Write Register3' (LTQ_GSWIP_3_0) */
+/* Bit: 'MASK3' */
+/* Description: 'Mask Pattern [15:0]' */
+#define PCE_TBL_MASK_3_MASK3_OFFSET	0x42A
+#define PCE_TBL_MASK_3_MASK3_SHIFT	0
+#define PCE_TBL_MASK_3_MASK3_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Mask Write Register2' (LTQ_GSWIP_3_0) */
+/* Bit: 'MASK2' */
+/* Description: 'Mask Pattern [15:0]' */
+#define PCE_TBL_MASK_2_MASK2_OFFSET	0x42B
+#define PCE_TBL_MASK_2_MASK2_SHIFT	0
+#define PCE_TBL_MASK_2_MASK2_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Mask Write Register1' (LTQ_GSWIP_3_0) */
+/* Bit: 'MASK1' */
+/* Description: 'Mask Pattern [15:0]' */
+#define PCE_TBL_MASK_1_MASK1_OFFSET	0x42C
+#define PCE_TBL_MASK_1_MASK1_SHIFT	0
+#define PCE_TBL_MASK_1_MASK1_SIZE		16
+/* --------------------------------------------------- */
+
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register25' (LTQ_GSWIP_3_1)*/
+/* Bit: 'VAL25' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_25_VAL25_OFFSET	0x420
+#define PCE_TBL_VAL_25_VAL25_SHIFT	0
+#define PCE_TBL_VAL_25_VAL25_SIZE		16
+/* --------------------------------------------------- */
+
+/* Register: 'Table Value Register24' (LTQ_GSWIP_3_1)*/
+/* Bit: 'VAL24' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_24_VAL24_OFFSET	0x421
+#define PCE_TBL_VAL_24_VAL24_SHIFT	0
+#define PCE_TBL_VAL_24_VAL24_SIZE		16
+/* --------------------------------------------------- */
+
+/* Register: 'Table Value Register23' (LTQ_GSWIP_3_1)*/
+/* Bit: 'VAL23' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_23_VAL23_OFFSET	0x422
+#define PCE_TBL_VAL_23_VAL23_SHIFT	0
+#define PCE_TBL_VAL_23_VAL23_SIZE		16
+/* --------------------------------------------------- */
+
+/* Register: 'Table Value Register22' (LTQ_GSWIP_3_1)*/
+/* Bit: 'VAL22' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_22_VAL22_OFFSET	0x423
+#define PCE_TBL_VAL_22_VAL22_SHIFT	0
+#define PCE_TBL_VAL_22_VAL22_SIZE		16
+/* --------------------------------------------------- */
+
+/* Register: 'Table Value Register21' (LTQ_GSWIP_3_1)*/
+/* Bit: 'VAL21' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_21_VAL21_OFFSET	0x424
+#define PCE_TBL_VAL_21_VAL21_SHIFT	0
+#define PCE_TBL_VAL_21_VAL21_SIZE		16
+/* --------------------------------------------------- */
+
+/* Register: 'Table Value Register20' (LTQ_GSWIP_3_1)*/
+/* Bit: 'VAL20' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_20_VAL20_OFFSET	0x425
+#define PCE_TBL_VAL_20_VAL20_SHIFT	0
+#define PCE_TBL_VAL_20_VAL20_SIZE		16
+/* --------------------------------------------------- */
+
+/* Register: 'Table Value Register19' (LTQ_GSWIP_3_1)*/
+/* Bit: 'VAL19' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_19_VAL19_OFFSET	0x426
+#define PCE_TBL_VAL_19_VAL19_SHIFT	0
+#define PCE_TBL_VAL_19_VAL19_SIZE		16
+/* --------------------------------------------------- */
+
+/* Register: 'Table Value Register18' (LTQ_GSWIP_3_1)*/
+/* Bit: 'VAL18' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_18_VAL18_OFFSET	0x427
+#define PCE_TBL_VAL_18_VAL18_SHIFT	0
+#define PCE_TBL_VAL_18_VAL18_SIZE		16
+/* --------------------------------------------------- */
+
+/* Register: 'Table Value Register16' (LTQ_GSWIP_3_1)*/
+/* Bit: 'VAL16' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_17_VAL17_OFFSET	0x428
+#define PCE_TBL_VAL_17_VAL17_SHIFT	0
+#define PCE_TBL_VAL_17_VAL17_SIZE		16
+/* --------------------------------------------------- */
+
+/* Register: 'Table Value Register16' (LTQ_GSWIP_3_1)*/
+/* Bit: 'VAL16' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_16_VAL16_OFFSET	0x429
+#define PCE_TBL_VAL_16_VAL16_SHIFT	0
+#define PCE_TBL_VAL_16_VAL16_SIZE		16
+/* --------------------------------------------------- */
+
+/* Register: 'Table Value Register15' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL15' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_15_VAL15_OFFSET	0x42D
+#define PCE_TBL_VAL_15_VAL15_SHIFT	0
+#define PCE_TBL_VAL_15_VAL15_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register14' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL14' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_14_VAL14_OFFSET	0x42E
+#define PCE_TBL_VAL_14_VAL14_SHIFT	0
+#define PCE_TBL_VAL_14_VAL14_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register13' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL13' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_13_VAL13_OFFSET	0x42F
+#define PCE_TBL_VAL_13_VAL13_SHIFT	0
+#define PCE_TBL_VAL_13_VAL13_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register12' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL12' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_12_VAL12_OFFSET	0x430
+#define PCE_TBL_VAL_12_VAL12_SHIFT	0
+#define PCE_TBL_VAL_12_VAL12_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register11' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL11' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_11_VAL11_OFFSET	0x431
+#define PCE_TBL_VAL_11_VAL11_SHIFT	0
+#define PCE_TBL_VAL_11_VAL11_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register10' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL10' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_10_VAL10_OFFSET	0x432
+#define PCE_TBL_VAL_10_VAL10_SHIFT	0
+#define PCE_TBL_VAL_10_VAL10_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register9' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL9' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_9_VAL9_OFFSET	0x433
+#define PCE_TBL_VAL_9_VAL9_SHIFT	0
+#define PCE_TBL_VAL_9_VAL9_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register8' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL8' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_8_VAL8_OFFSET	0x434
+#define PCE_TBL_VAL_8_VAL8_SHIFT	0
+#define PCE_TBL_VAL_8_VAL8_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register7' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL7' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_7_VAL7_OFFSET	0x435
+#define PCE_TBL_VAL_7_VAL7_SHIFT	0
+#define PCE_TBL_VAL_7_VAL7_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register6' */
+/* Bit: 'VAL6' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_6_VAL6_OFFSET	0x436
+#define PCE_TBL_VAL_6_VAL6_SHIFT	0
+#define PCE_TBL_VAL_6_VAL6_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register5' */
+/* Bit: 'VAL5' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_5_VAL5_OFFSET	0x437
+#define PCE_TBL_VAL_5_VAL5_SHIFT	0
+#define PCE_TBL_VAL_5_VAL5_SIZE		16
+/* --------------------------------------------------- */
+
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 21' GSWIP 3.1 */
+/* Bit: 'KEY21' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_21_KEY21_OFFSET	0x41A
+#define PCE_TBL_KEY_21_KEY21_SHIFT	0
+#define PCE_TBL_KEY_21_KEY21_SIZE		16
+/* --------------------------------------------------- */
+
+/* Register: 'Table Key Data 20' GSWIP 3.1 */
+/* Bit: 'KEY20' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_20_KEY20_OFFSET	0x41B
+#define PCE_TBL_KEY_20_KEY20_SHIFT	0
+#define PCE_TBL_KEY_20_KEY20_SIZE		16
+/* --------------------------------------------------- */
+
+/* Register: 'Table Key Data 19' GSWIP 3.1 */
+/* Bit: 'KEY19' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_19_KEY19_OFFSET	0x41C
+#define PCE_TBL_KEY_19_KEY19_SHIFT	0
+#define PCE_TBL_KEY_19_KEY19_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 18' GSWIP 3.1 */
+/* Bit: 'KEY18' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_18_KEY18_OFFSET	0x41D
+#define PCE_TBL_KEY_18_KEY18_SHIFT	0
+#define PCE_TBL_KEY_18_KEY18_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 17' GSWIP 3.1 */
+/* Bit: 'KEY17' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_17_KEY17_OFFSET	0x41E
+#define PCE_TBL_KEY_17_KEY17_SHIFT	0
+#define PCE_TBL_KEY_17_KEY17_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 16' GSWIP 3.1 */
+/* Bit: 'KEY16' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_16_KEY16_OFFSET	0x41F
+#define PCE_TBL_KEY_16_KEY16_SHIFT	0
+#define PCE_TBL_KEY_16_KEY16_SIZE		16
+/* --------------------------------------------------- */
+
+/* Register: 'Table Key Data 15' */
+/* Bit: 'KEY15' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_15_KEY15_OFFSET	0x438
+#define PCE_TBL_KEY_15_KEY15_SHIFT	0
+#define PCE_TBL_KEY_15_KEY15_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 14' */
+/* Bit: 'KEY14' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_14_KEY14_OFFSET	0x439
+#define PCE_TBL_KEY_14_KEY14_SHIFT	0
+#define PCE_TBL_KEY_14_KEY14_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 13' */
+/* Bit: 'KEY13' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_13_KEY13_OFFSET	0x43A
+#define PCE_TBL_KEY_13_KEY13_SHIFT	0
+#define PCE_TBL_KEY_13_KEY13_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 12' */
+/* Bit: 'KEY12' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_12_KEY12_OFFSET	0x43B
+#define PCE_TBL_KEY_12_KEY12_SHIFT	0
+#define PCE_TBL_KEY_12_KEY12_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 11' */
+/* Bit: 'KEY11' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_11_KEY11_OFFSET	0x43C
+#define PCE_TBL_KEY_11_KEY11_SHIFT	0
+#define PCE_TBL_KEY_11_KEY11_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 10' */
+/* Bit: 'KEY10' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_10_KEY10_OFFSET	0x43D
+#define PCE_TBL_KEY_10_KEY10_SHIFT	0
+#define PCE_TBL_KEY_10_KEY10_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 9' */
+/* Bit: 'KEY9' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_9_KEY9_OFFSET	0x43E
+#define PCE_TBL_KEY_9_KEY9_SHIFT	0
+#define PCE_TBL_KEY_9_KEY9_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 8' */
+/* Bit: 'KEY8' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_8_KEY8_OFFSET	0x43F
+#define PCE_TBL_KEY_8_KEY8_SHIFT	0
+#define PCE_TBL_KEY_8_KEY8_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 7' */
+/* Bit: 'KEY7' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_7_KEY7_OFFSET	0x440
+#define PCE_TBL_KEY_7_KEY7_SHIFT	0
+#define PCE_TBL_KEY_7_KEY7_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 6' */
+/* Bit: 'KEY6' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_6_KEY6_OFFSET	0x441
+#define PCE_TBL_KEY_6_KEY6_SHIFT	0
+#define PCE_TBL_KEY_6_KEY6_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 5' */
+/* Bit: 'KEY5' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_5_KEY5_OFFSET	0x442
+#define PCE_TBL_KEY_5_KEY5_SHIFT	0
+#define PCE_TBL_KEY_5_KEY5_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 4' */
+/* Bit: 'KEY4' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_4_KEY4_OFFSET	0x443
+#define PCE_TBL_KEY_4_KEY4_SHIFT	0
+#define PCE_TBL_KEY_4_KEY4_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 3' */
+/* Bit: 'KEY3' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_3_KEY3_OFFSET	0x444
+#define PCE_TBL_KEY_3_KEY3_SHIFT	0
+#define PCE_TBL_KEY_3_KEY3_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 2' */
+/* Bit: 'KEY2' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_2_KEY2_OFFSET	0x445
+#define PCE_TBL_KEY_2_KEY2_SHIFT	0
+#define PCE_TBL_KEY_2_KEY2_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 1' */
+/* Bit: 'KEY1' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_1_KEY1_OFFSET	0x446
+#define PCE_TBL_KEY_1_KEY1_SHIFT	0
+#define PCE_TBL_KEY_1_KEY1_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Key Data 0' */
+/* Bit: 'KEY0' */
+/* Description: 'Key Value[15:0]' */
+#define PCE_TBL_KEY_0_KEY0_OFFSET	0x447
+#define PCE_TBL_KEY_0_KEY0_SHIFT	0
+#define PCE_TBL_KEY_0_KEY0_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Mask Write Register0' */
+/* Bit: 'MASK0' */
+/* Description: 'Mask Pattern [15:0]' */
+#define PCE_TBL_MASK_0_MASK0_OFFSET	0x448
+#define PCE_TBL_MASK_0_MASK0_SHIFT	0
+#define PCE_TBL_MASK_0_MASK0_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register4' */
+/* Bit: 'VAL4' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_4_VAL4_OFFSET	0x449
+#define PCE_TBL_VAL_4_VAL4_SHIFT	0
+#define PCE_TBL_VAL_4_VAL4_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register3' */
+/* Bit: 'VAL3' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_3_VAL3_OFFSET	0x44A
+#define PCE_TBL_VAL_3_VAL3_SHIFT	0
+#define PCE_TBL_VAL_3_VAL3_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register2' */
+/* Bit: 'VAL2' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_2_VAL2_OFFSET	0x44B
+#define PCE_TBL_VAL_2_VAL2_SHIFT	0
+#define PCE_TBL_VAL_2_VAL2_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register1' */
+/* Bit: 'VAL1' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_1_VAL1_OFFSET	0x44C
+#define PCE_TBL_VAL_1_VAL1_SHIFT	0
+#define PCE_TBL_VAL_1_VAL1_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register0' */
+/* Bit: 'VAL0' */
+/* Description: 'Data value [15:0]' */
+#define PCE_TBL_VAL_0_VAL0_OFFSET	0x44D
+#define PCE_TBL_VAL_0_VAL0_SHIFT	0
+#define PCE_TBL_VAL_0_VAL0_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Entry AddressRegister' */
+/* Bit: 'ADDR' */
+/* Description: 'Table Address' */
+#define PCE_TBL_ADDR_ADDR_OFFSET	0x44E
+#define PCE_TBL_ADDR_ADDR_SHIFT		0
+#define PCE_TBL_ADDR_ADDR_SIZE		12
+/* --------------------------------------------------- */
+/* Register: 'Table Access ControlRegister' */
+/* Bit: 'BAS' */
+/* Description: 'Access Busy/Access Start' */
+#define PCE_TBL_CTRL_BAS_OFFSET	0x44F
+#define PCE_TBL_CTRL_BAS_SHIFT	15
+#define PCE_TBL_CTRL_BAS_SIZE		1
+/* Bit: 'EXTOP' */
+/* Description: 'Lookup Table Access Extended Operation Mode' */
+#define PCE_TBL_CTRL_EXTOP_OFFSET	0x44F
+#define PCE_TBL_CTRL_EXTOP_SHIFT	14
+#define PCE_TBL_CTRL_EXTOP_SIZE		1
+/* Bit: 'TYPE' */
+/* Description: 'Lookup Entry Type' */
+#define PCE_TBL_CTRL_TYPE_OFFSET	0x44F
+#define PCE_TBL_CTRL_TYPE_SHIFT		13
+#define PCE_TBL_CTRL_TYPE_SIZE		1
+/* Bit: 'VLD' */
+/* Description: 'Lookup Entry Valid' */
+#define PCE_TBL_CTRL_VLD_OFFSET	0x44F
+#define PCE_TBL_CTRL_VLD_SHIFT	12
+#define PCE_TBL_CTRL_VLD_SIZE		1
+/* Bit: 'KEYFORM' */
+/* Description: 'Key Format' */
+#define PCE_TBL_CTRL_KEYFORM_OFFSET	0x44F
+#define PCE_TBL_CTRL_KEYFORM_SHIFT	11
+#define PCE_TBL_CTRL_KEYFORM_SIZE		1
+/* Bit: 'GMAP' */
+/* Description: 'Group Map' */
+#define PCE_TBL_CTRL_GMAP_OFFSET	0x44F
+#define PCE_TBL_CTRL_GMAP_SHIFT		7
+#define PCE_TBL_CTRL_GMAP_SIZE		4
+/* Bit: 'OPMOD' */
+/* Description: 'Lookup Table Access Operation Mode' */
+#define PCE_TBL_CTRL_OPMOD_OFFSET	0x44F
+#define PCE_TBL_CTRL_OPMOD_SHIFT	5
+#define PCE_TBL_CTRL_OPMOD_SIZE		2
+/* Bit: 'ADDR' */
+/* Description: 'Lookup Table Address' */
+#define PCE_TBL_CTRL_ADDR_OFFSET	0x44F
+#define PCE_TBL_CTRL_ADDR_SHIFT		0
+#define PCE_TBL_CTRL_ADDR_SIZE		5
+/* --------------------------------------------------- */
+/* Register: 'Table General StatusRegister' */
+/* Bit: 'TBUSY' */
+/* Description: 'Table Access Busy' */
+#define PCE_TBL_STAT_TBUSY_OFFSET	0x450
+#define PCE_TBL_STAT_TBUSY_SHIFT	2
+#define PCE_TBL_STAT_TBUSY_SIZE		1
+/* Bit: 'TEMPT' */
+/* Description: 'Table Empty' */
+#define PCE_TBL_STAT_TEMPT_OFFSET	0x450
+#define PCE_TBL_STAT_TEMPT_SHIFT	1
+#define PCE_TBL_STAT_TEMPT_SIZE		1
+/* Bit: 'TFUL' */
+/* Description: 'Table Full' */
+#define PCE_TBL_STAT_TFUL_OFFSET	0x450
+#define PCE_TBL_STAT_TFUL_SHIFT		0
+#define PCE_TBL_STAT_TFUL_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Aging Counter ConfigurationRegister 0' */
+/* Bit: 'EXP' */
+/* Description: 'Aging Counter Exponent Value ' */
+#define PCE_AGE_0_EXP_OFFSET	0x451
+#define PCE_AGE_0_EXP_SHIFT		0
+#define PCE_AGE_0_EXP_SIZE		4
+/* --------------------------------------------------- */
+/* Register: 'Aging Counter ConfigurationRegister 1' */
+/* Bit: 'MANT' */
+/* Description: 'Aging Counter Mantissa Value ' */
+#define PCE_AGE_1_MANT_OFFSET	0x452
+#define PCE_AGE_1_MANT_SHIFT	0
+#define PCE_AGE_1_MANT_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Port Map Register 1' */
+#define PCE_PMAP_1_REG_OFFSET	0x453
+/* Bit: 'MPMAP' */
+/* Description: 'Monitoring Port Map' */
+#define PCE_PMAP_1_MPMAP_OFFSET	0x453
+#define PCE_PMAP_1_MPMAP_SHIFT	0
+#define PCE_PMAP_1_MPMAP_SIZE	16
+/* Bit: 'PID' */
+/* Description: 'Monitoring Port LogicalID' */
+#define PCE_PMAP_1_PID_OFFSET	0x453
+#define PCE_PMAP_1_PID_SHIFT	0
+#define PCE_PMAP_1_PID_SIZE	    4
+/* Bit: 'SUBID' */
+/* Description: 'Monitoring Port Sub-IF ID' */
+#define PCE_PMAP_1_SUBID_OFFSET	0x453
+#define PCE_PMAP_1_SUBID_SHIFT	4
+#define PCE_PMAP_1_SUBID_SIZE	12
+/* --------------------------------------------------- */
+/* Register: 'Port Map Register 2' */
+/* Bit: 'DMCPMAP' */
+/* Description: 'Default Multicast Port Map' */
+#define PCE_PMAP_2_DMCPMAP_OFFSET	0x454
+#define PCE_PMAP_2_DMCPMAP_SHIFT	0
+#define PCE_PMAP_2_DMCPMAP_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Port Map Register 3' */
+/* Bit: 'UUCMAP' */
+/* Description: 'Default Unknown Unicast Port Map' */
+#define PCE_PMAP_3_UUCMAP_OFFSET	0x455
+#define PCE_PMAP_3_UUCMAP_SHIFT		0
+#define PCE_PMAP_3_UUCMAP_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'PCE Global Control Register0' */
+/* Bit: 'IGMP' */
+/* Description: 'IGMP Mode Selection' */
+#define PCE_GCTRL_0_IGMP_OFFSET	0x456
+#define PCE_GCTRL_0_IGMP_SHIFT	15
+#define PCE_GCTRL_0_IGMP_SIZE		1
+/* Bit: 'VLAN' */
+/* Description: 'VLAN-aware Switching' */
+#define PCE_GCTRL_0_VLAN_OFFSET	0x456
+#define PCE_GCTRL_0_VLAN_SHIFT	14
+#define PCE_GCTRL_0_VLAN_SIZE		1
+/* Bit: 'NOPM' */
+/* Description: 'No Port Map Forwarding' */
+#define PCE_GCTRL_0_NOPM_OFFSET	0x456
+#define PCE_GCTRL_0_NOPM_SHIFT	13
+#define PCE_GCTRL_0_NOPM_SIZE		1
+/* Bit: 'SCONUC' */
+/* Description: 'Unknown Unicast Storm Control' */
+#define PCE_GCTRL_0_SCONUC_OFFSET	0x456
+#define PCE_GCTRL_0_SCONUC_SHIFT	12
+#define PCE_GCTRL_0_SCONUC_SIZE		1
+/* Bit: 'SCONMC' */
+/* Description: 'Multicast Storm Control' */
+#define PCE_GCTRL_0_SCONMC_OFFSET	0x456
+#define PCE_GCTRL_0_SCONMC_SHIFT	11
+#define PCE_GCTRL_0_SCONMC_SIZE		1
+/* Bit: 'SCONBC' */
+/* Description: 'Broadcast Storm Control' */
+#define PCE_GCTRL_0_SCONBC_OFFSET	0x456
+#define PCE_GCTRL_0_SCONBC_SHIFT	10
+#define PCE_GCTRL_0_SCONBC_SIZE		1
+/* Bit: 'SCONMOD' */
+/* Description: 'Storm Control Mode' */
+#define PCE_GCTRL_0_SCONMOD_OFFSET	0x456
+#define PCE_GCTRL_0_SCONMOD_SHIFT		8
+#define PCE_GCTRL_0_SCONMOD_SIZE		2
+/* Bit: 'SCONMET' */
+/* Description: 'Storm Control Metering Instance' */
+#define PCE_GCTRL_0_SCONMET_OFFSET	0x456
+#define PCE_GCTRL_0_SCONMET_SHIFT		4
+#define PCE_GCTRL_0_SCONMET_SIZE		4
+/* Bit: 'MC_VALID' */
+/* Description: 'Access Request' */
+#define PCE_GCTRL_0_MC_VALID_OFFSET	0x456
+#define PCE_GCTRL_0_MC_VALID_SHIFT	3
+#define PCE_GCTRL_0_MC_VALID_SIZE		1
+/* Bit: 'PLCKMOD' */
+/* Description: 'Port Lock Mode' */
+#define PCE_GCTRL_0_PLCKMOD_OFFSET	0x456
+#define PCE_GCTRL_0_PLCKMOD_SHIFT		2
+#define PCE_GCTRL_0_PLCKMOD_SIZE		1
+/* Bit: 'PLIMMOD' */
+/* Description: 'MAC Address Learning Limitation Mode' */
+#define PCE_GCTRL_0_PLIMMOD_OFFSET	0x456
+#define PCE_GCTRL_0_PLIMMOD_SHIFT		1
+#define PCE_GCTRL_0_PLIMMOD_SIZE		1
+/* Bit: 'MTFL' */
+/* Description: 'MAC Table Flushing' */
+#define PCE_GCTRL_0_MTFL_OFFSET	0x456
+#define PCE_GCTRL_0_MTFL_SHIFT	0
+#define PCE_GCTRL_0_MTFL_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'PCE Global Control Register1' */
+/* Bit: 'PARSER_DBG' */
+/* Description: 'Parser Debug Selection' */
+#define PCE_GCTRL_1_PARSER_DBG_OFFSET	0x457
+#define PCE_GCTRL_1_PARSER_DBG_SHIFT	14
+#define PCE_GCTRL_1_PARSER_DBG_SIZE		2
+/* Bit: 'RSCNTMD' */
+/* Description: 'Routing Session Counter Mode' (LTQ_GSWIP_3_0) */
+#define PCE_GCTRL_1_RSCNTMD_OFFSET	0x457
+#define PCE_GCTRL_1_RSCNTMD_SHIFT		11
+#define PCE_GCTRL_1_RSCNTMD_SIZE		1
+/* Bit: 'MKFIDEN' */
+/* Description: 'IP Multicast Forwardng Software Mode FID Enable' */
+/**	(LTQ_GSWIP_3_0) */
+#define PCE_GCTRL_1_MKFIDEN_OFFSET	0x457
+#define PCE_GCTRL_1_MKFIDEN_SHIFT		10
+#define PCE_GCTRL_1_MKFIDEN_SIZE		1
+/* Bit: 'VLANMD' */
+/* Description: 'GSWIP2.2 VLAN Mode' */
+#define PCE_GCTRL_1_VLANMD_OFFSET	0x457
+#define PCE_GCTRL_1_VLANMD_SHIFT	9
+#define PCE_GCTRL_1_VLANMD_SIZE		1
+/* Bit: 'UKIPMC' */
+/* Description: 'Unknown IP Multicast Forwardng Mode' */
+#define PCE_GCTRL_1_UKIPMC_OFFSET	0x457
+#define PCE_GCTRL_1_UKIPMC_SHIFT	8
+#define PCE_GCTRL_1_UKIPMC_SIZE		1
+/* Bit: 'SPFMOD' */
+/* Description: 'Port Spoofing Detection Violation Forwarding Mode' */
+#define PCE_GCTRL_1_SPFMOD_OFFSET	0x457
+#define PCE_GCTRL_1_SPFMOD_SHIFT	7
+#define PCE_GCTRL_1_SPFMOD_SIZE		1
+/* Bit: 'FLOWPTR_LIST_EN' */
+/* Description: 'Flow Pointer List enable' */
+#define PCE_GCTRL_1_FLOWPTR_LIST_EN_OFFSET	0x457
+#define PCE_GCTRL_1_FLOWPTR_LIST_EN_SHIFT		4
+#define PCE_GCTRL_1_FLOWPTR_LIST_EN_SIZE		1
+/* Bit: 'MAC_GLOCKMOD' */
+/* Description: 'MAC Address Table Lock forwarding mode' */
+#define PCE_GCTRL_1_MAC_GLOCKMOD_OFFSET	0x457
+#define PCE_GCTRL_1_MAC_GLOCKMOD_SHIFT	3
+#define PCE_GCTRL_1_MAC_GLOCKMOD_SIZE		1
+/* Bit: 'MAC_GLOCK' */
+/* Description: 'MAC Address Table Lock' */
+#define PCE_GCTRL_1_MAC_GLOCK_OFFSET	0x457
+#define PCE_GCTRL_1_MAC_GLOCK_SHIFT		2
+#define PCE_GCTRL_1_MAC_GLOCK_SIZE		1
+/* Bit: 'PCE_DIS' */
+/* Description: 'PCE Disable after currently processed packet' */
+#define PCE_GCTRL_1_PCE_DIS_OFFSET	0x457
+#define PCE_GCTRL_1_PCE_DIS_SHIFT		1
+#define PCE_GCTRL_1_PCE_DIS_SIZE		1
+/* Bit: 'LRNMOD' */
+/* Description: 'MAC Address Learning Mode' */
+#define PCE_GCTRL_1_LRNMOD_OFFSET	0x457
+#define PCE_GCTRL_1_LRNMOD_SHIFT	0
+#define PCE_GCTRL_1_LRNMOD_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Three-color MarkerGlobal Control Register' */
+/* Bit: 'DPRED' */
+/* Description: 'Re-marking Drop Precedence Red Encoding' */
+#define PCE_TCM_GLOB_CTRL_DPRED_OFFSET	0x458
+#define PCE_TCM_GLOB_CTRL_DPRED_SHIFT		6
+#define PCE_TCM_GLOB_CTRL_DPRED_SIZE		3
+/* Bit: 'DPYEL' */
+/* Description: 'Re-marking Drop Precedence Yellow Encoding' */
+#define PCE_TCM_GLOB_CTRL_DPYEL_OFFSET	0x458
+#define PCE_TCM_GLOB_CTRL_DPYEL_SHIFT		3
+#define PCE_TCM_GLOB_CTRL_DPYEL_SIZE		3
+/* Bit: 'DPGRN' */
+/* Description: 'Re-marking Drop Precedence Green Encoding' */
+#define PCE_TCM_GLOB_CTRL_DPGRN_OFFSET	0x458
+#define PCE_TCM_GLOB_CTRL_DPGRN_SHIFT		0
+#define PCE_TCM_GLOB_CTRL_DPGRN_SIZE		3
+/* --------------------------------------------------- */
+/* Register: 'IGMP Control Register' */
+/* Bit: 'FAGEEN' */
+/* Description: 'Force Aging of Table Entries Enable' */
+#define PCE_IGMP_CTRL_FAGEEN_OFFSET	0x459
+#define PCE_IGMP_CTRL_FAGEEN_SHIFT	15
+#define PCE_IGMP_CTRL_FAGEEN_SIZE		1
+/* Bit: 'FLEAVE' */
+/* Description: 'Fast Leave Enable' */
+#define PCE_IGMP_CTRL_FLEAVE_OFFSET	0x459
+#define PCE_IGMP_CTRL_FLEAVE_SHIFT	14
+#define PCE_IGMP_CTRL_FLEAVE_SIZE		1
+/* Bit: 'DMRTEN' */
+/* Description: 'Default Maximum Response Time Enable' */
+#define PCE_IGMP_CTRL_DMRTEN_OFFSET	0x459
+#define PCE_IGMP_CTRL_DMRTEN_SHIFT	13
+#define PCE_IGMP_CTRL_DMRTEN_SIZE		1
+/* Bit: 'JASUP' */
+/* Description: 'Join Aggregation Suppression Enable' */
+#define PCE_IGMP_CTRL_JASUP_OFFSET	0x459
+#define PCE_IGMP_CTRL_JASUP_SHIFT		12
+#define PCE_IGMP_CTRL_JASUP_SIZE		1
+/* Bit: 'REPSUP' */
+/* Description: 'Report Suppression Enable' */
+#define PCE_IGMP_CTRL_REPSUP_OFFSET	0x459
+#define PCE_IGMP_CTRL_REPSUP_SHIFT	11
+#define PCE_IGMP_CTRL_REPSUP_SIZE		1
+/* Bit: 'SRPEN' */
+/* Description: 'Snooping of Router Port Enable' */
+#define PCE_IGMP_CTRL_SRPEN_OFFSET	0x459
+#define PCE_IGMP_CTRL_SRPEN_SHIFT		10
+#define PCE_IGMP_CTRL_SRPEN_SIZE		1
+/* Bit: 'ROB' */
+/* Description: 'Robustness Variable' */
+#define PCE_IGMP_CTRL_ROB_OFFSET	0x459
+#define PCE_IGMP_CTRL_ROB_SHIFT		8
+#define PCE_IGMP_CTRL_ROB_SIZE		2
+/* Bit: 'DMRT' */
+/* Description: 'IGMP Default Maximum Response Time' */
+#define PCE_IGMP_CTRL_DMRT_OFFSET	0x459
+#define PCE_IGMP_CTRL_DMRT_SHIFT	0
+#define PCE_IGMP_CTRL_DMRT_SIZE		8
+/* --------------------------------------------------- */
+/* Register: 'IGMP Default RouterPort Map Register' */
+/* Bit: 'DRPM' */
+/* Description: 'IGMP Default Router Port Map' */
+#define PCE_IGMP_DRPM_DRPM_OFFSET	0x45A
+#define PCE_IGMP_DRPM_DRPM_SHIFT	0
+#define PCE_IGMP_DRPM_DRPM_SIZE		16
+/* --------------------------------------------- */
+/* Register: 'IGMP Aging Register0' */
+/* Bit: 'MANT' */
+/* Description: 'IGMP Group Aging Time Mantissa' */
+#define PCE_IGMP_AGE_0_MANT_OFFSET	0x45B
+#define PCE_IGMP_AGE_0_MANT_SHIFT		3
+#define PCE_IGMP_AGE_0_MANT_SIZE		8
+/* Bit: 'EXP' */
+/* Description: 'IGMP Group Aging Time Exponent' */
+#define PCE_IGMP_AGE_0_EXP_OFFSET	0x45B
+#define PCE_IGMP_AGE_0_EXP_SHIFT	0
+#define PCE_IGMP_AGE_0_EXP_SIZE		3
+/* --------------------------------------------------- */
+/* Register: 'IGMP Aging Register1' */
+/* Bit: 'MANT' */
+/* Description: 'IGMP Router Port Aging Time Mantissa' */
+#define PCE_IGMP_AGE_1_MANT_OFFSET	0x45C
+#define PCE_IGMP_AGE_1_MANT_SHIFT		0
+#define PCE_IGMP_AGE_1_MANT_SIZE		12
+/* --------------------------------------------------- */
+/* Register: 'IGMP Status Register' */
+/* Bit: 'IGPM' */
+/* Description: 'IGMP Port Map' */
+#define PCE_IGMP_STAT_IGPM_OFFSET	0x45D
+#define PCE_IGMP_STAT_IGPM_SHIFT	0
+#define PCE_IGMP_STAT_IGPM_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Wake-on-LAN ControlRegister' */
+/* Bit: 'PASSEN' */
+/* Description: 'WoL Password Enable' */
+#define WOL_GLB_CTRL_PASSEN_OFFSET	0x45E
+#define WOL_GLB_CTRL_PASSEN_SHIFT		0
+#define WOL_GLB_CTRL_PASSEN_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Wake-on-LAN DestinationAddress Register 0' */
+/* Bit: 'DA0' */
+/* Description: 'WoL Destination Address [15:0]' */
+#define WOL_DA_0_DA0_OFFSET	0x45F
+#define WOL_DA_0_DA0_SHIFT	0
+#define WOL_DA_0_DA0_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Wake-on-LAN DestinationAddress Register 1' */
+/* Bit: 'DA1' */
+/* Description: 'WoL Destination Address [31:16]' */
+#define WOL_DA_1_DA1_OFFSET	0x460
+#define WOL_DA_1_DA1_SHIFT	0
+#define WOL_DA_1_DA1_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Wake-on-LAN DestinationAddress Register 2' */
+/* Bit: 'DA2' */
+/* Description: 'WoL Destination Address [47:32]' */
+#define WOL_DA_2_DA2_OFFSET	0x461
+#define WOL_DA_2_DA2_SHIFT	0
+#define WOL_DA_2_DA2_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Wake-on-LAN Password Register0' */
+/* Bit: 'PW0' */
+/* Description: 'WoL Password [15:0]' */
+#define WOL_PW_0_PW0_OFFSET	0x462
+#define WOL_PW_0_PW0_SHIFT	0
+#define WOL_PW_0_PW0_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Wake-on-LAN Password Register1' */
+/* Bit: 'PW1' */
+/* Description: 'WoL Password [31:16]' */
+#define WOL_PW_1_PW1_OFFSET	0x463
+#define WOL_PW_1_PW1_SHIFT	0
+#define WOL_PW_1_PW1_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Wake-on-LAN Password Register2' */
+/* Bit: 'PW2' */
+/* Description: 'WoL Password [47:32]' */
+#define WOL_PW_2_PW2_OFFSET	0x464
+#define WOL_PW_2_PW2_SHIFT	0
+#define WOL_PW_2_PW2_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Parser and ClassificationEngine Global */
+/* Interrupt Enable Register 0' */
+/* Bit: 'PINT_15' */
+/* Description: 'Port Interrupt Enable' */
+#define PCE_IER_0_PINT_15_OFFSET	0x465
+#define PCE_IER_0_PINT_15_SHIFT		15
+#define PCE_IER_0_PINT_15_SIZE		1
+/* Bit: 'PINT_14' */
+/* Description: 'Port Interrupt Enable' */
+#define PCE_IER_0_PINT_14_OFFSET	0x465
+#define PCE_IER_0_PINT_14_SHIFT		14
+#define PCE_IER_0_PINT_14_SIZE		1
+/* Bit: 'PINT_13' */
+/* Description: 'Port Interrupt Enable' */
+#define PCE_IER_0_PINT_13_OFFSET	0x465
+#define PCE_IER_0_PINT_13_SHIFT		13
+#define PCE_IER_0_PINT_13_SIZE		1
+/* Bit: 'PINT_12' */
+/* Description: 'Port Interrupt Enable' */
+#define PCE_IER_0_PINT_12_OFFSET	0x465
+#define PCE_IER_0_PINT_12_SHIFT		12
+#define PCE_IER_0_PINT_12_SIZE		1
+/* Bit: 'PINT_11' */
+/* Description: 'Port Interrupt Enable' */
+#define PCE_IER_0_PINT_11_OFFSET	0x465
+#define PCE_IER_0_PINT_11_SHIFT		11
+#define PCE_IER_0_PINT_11_SIZE		1
+/* Bit: 'PINT_10' */
+/* Description: 'Port Interrupt Enable' */
+#define PCE_IER_0_PINT_10_OFFSET	0x465
+#define PCE_IER_0_PINT_10_SHIFT		10
+#define PCE_IER_0_PINT_10_SIZE		1
+/* Bit: 'PINT_9' */
+/* Description: 'Port Interrupt Enable' */
+#define PCE_IER_0_PINT_9_OFFSET	0x465
+#define PCE_IER_0_PINT_9_SHIFT	9
+#define PCE_IER_0_PINT_9_SIZE		1
+/* Bit: 'PINT_8' */
+/* Description: 'Port Interrupt Enable' */
+#define PCE_IER_0_PINT_8_OFFSET	0x465
+#define PCE_IER_0_PINT_8_SHIFT	8
+#define PCE_IER_0_PINT_8_SIZE		1
+/* Bit: 'PINT_7' */
+/* Description: 'Port Interrupt Enable' */
+#define PCE_IER_0_PINT_7_OFFSET	0x465
+#define PCE_IER_0_PINT_7_SHIFT	7
+#define PCE_IER_0_PINT_7_SIZE		1
+/* Bit: 'PINT_6' */
+/* Description: 'Port Interrupt Enable' */
+#define PCE_IER_0_PINT_6_OFFSET	0x465
+#define PCE_IER_0_PINT_6_SHIFT	6
+#define PCE_IER_0_PINT_6_SIZE		1
+/* Bit: 'PINT_5' */
+/* Description: 'Port Interrupt Enable' */
+#define PCE_IER_0_PINT_5_OFFSET	0x465
+#define PCE_IER_0_PINT_5_SHIFT	5
+#define PCE_IER_0_PINT_5_SIZE		1
+/* Bit: 'PINT_4' */
+/* Description: 'Port Interrupt Enable' */
+#define PCE_IER_0_PINT_4_OFFSET	0x465
+#define PCE_IER_0_PINT_4_SHIFT	4
+#define PCE_IER_0_PINT_4_SIZE		1
+/* Bit: 'PINT_3' */
+/* Description: 'Port Interrupt Enable' */
+#define PCE_IER_0_PINT_3_OFFSET	0x465
+#define PCE_IER_0_PINT_3_SHIFT	3
+#define PCE_IER_0_PINT_3_SIZE		1
+/* Bit: 'PINT_2' */
+/* Description: 'Port Interrupt Enable' */
+#define PCE_IER_0_PINT_2_OFFSET	0x465
+#define PCE_IER_0_PINT_2_SHIFT	2
+#define PCE_IER_0_PINT_2_SIZE		1
+/* Bit: 'PINT_1' */
+/* Description: 'Port Interrupt Enable' */
+#define PCE_IER_0_PINT_1_OFFSET	0x465
+#define PCE_IER_0_PINT_1_SHIFT	1
+#define PCE_IER_0_PINT_1_SIZE		1
+/* Bit: 'PINT_0' */
+/* Description: 'Port Interrupt Enable' */
+#define PCE_IER_0_PINT_0_OFFSET	0x465
+#define PCE_IER_0_PINT_0_SHIFT	0
+#define PCE_IER_0_PINT_0_SIZE		1
+/* --------------------------------------------------- */
+/*Register: 'Parser and ClassificationEngine Global Interrupt */
+/* Enable Register 1' */
+/* Bit: 'CHG' */
+/* Description: 'MAC Table Changed Entry Interrupt Enable' */
+#define PCE_IER_1_CHG_OFFSET	0x466
+#define PCE_IER_1_CHG_SHIFT		7
+#define PCE_IER_1_CHG_SIZE		1
+/* Bit: 'FLOWINT' */
+/* Description: 'Traffic Flow Table Interrupt Rule matched Interrupt */
+/* Enable' */
+#define PCE_IER_1_FLOWINT_OFFSET	0x466
+#define PCE_IER_1_FLOWINT_SHIFT		6
+#define PCE_IER_1_FLOWINT_SIZE		1
+/* Bit: 'CPH2' */
+/* Description: 'Classification Phase 2 Ready Interrupt Enable' */
+#define PCE_IER_1_CPH2_OFFSET	0x466
+#define PCE_IER_1_CPH2_SHIFT	5
+#define PCE_IER_1_CPH2_SIZE		1
+/* Bit: 'CPH1' */
+/* Description: 'Classification Phase 1 Ready Interrupt Enable' */
+#define PCE_IER_1_CPH1_OFFSET	0x466
+#define PCE_IER_1_CPH1_SHIFT	4
+#define PCE_IER_1_CPH1_SIZE		1
+/* Bit: 'CPH0' */
+/* Description: 'Classification Phase 0 Ready Interrupt Enable' */
+#define PCE_IER_1_CPH0_OFFSET	0x466
+#define PCE_IER_1_CPH0_SHIFT	3
+#define PCE_IER_1_CPH0_SIZE		1
+/* Bit: 'PRDY' */
+/* Description: 'Parser Ready Interrupt Enable' */
+#define PCE_IER_1_PRDY_OFFSET	0x466
+#define PCE_IER_1_PRDY_SHIFT	2
+#define PCE_IER_1_PRDY_SIZE		1
+/* Bit: 'IGTF' */
+/* Description: 'IGMP Table Full Interrupt Enable' */
+#define PCE_IER_1_IGTF_OFFSET	0x466
+#define PCE_IER_1_IGTF_SHIFT	1
+#define PCE_IER_1_IGTF_SIZE		1
+/* Bit: 'MTF' */
+/* Description: 'MAC Table Full Interrupt Enable' */
+#define PCE_IER_1_MTF_OFFSET	0x466
+#define PCE_IER_1_MTF_SHIFT		0
+#define PCE_IER_1_MTF_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Parser and ClassificationEngine Global */
+/* Interrupt Status Register 0' */
+/* Bit: 'PINT_15' */
+/* Description: 'Port Interrupt' */
+#define PCE_ISR_0_PINT_15_OFFSET	0x467
+#define PCE_ISR_0_PINT_15_SHIFT		15
+#define PCE_ISR_0_PINT_15_SIZE		1
+/* Bit: 'PINT_14' */
+/* Description: 'Port Interrupt' */
+#define PCE_ISR_0_PINT_14_OFFSET	0x467
+#define PCE_ISR_0_PINT_14_SHIFT		14
+#define PCE_ISR_0_PINT_14_SIZE		1
+/* Bit: 'PINT_13' */
+/* Description: 'Port Interrupt' */
+#define PCE_ISR_0_PINT_13_OFFSET	0x467
+#define PCE_ISR_0_PINT_13_SHIFT		13
+#define PCE_ISR_0_PINT_13_SIZE		1
+/* Bit: 'PINT_12' */
+/* Description: 'Port Interrupt' */
+#define PCE_ISR_0_PINT_12_OFFSET	0x467
+#define PCE_ISR_0_PINT_12_SHIFT		12
+#define PCE_ISR_0_PINT_12_SIZE		1
+/* Bit: 'PINT_11' */
+/* Description: 'Port Interrupt' */
+#define PCE_ISR_0_PINT_11_OFFSET	0x467
+#define PCE_ISR_0_PINT_11_SHIFT		11
+#define PCE_ISR_0_PINT_11_SIZE		1
+/* Bit: 'PINT_10' */
+/* Description: 'Port Interrupt' */
+#define PCE_ISR_0_PINT_10_OFFSET	0x467
+#define PCE_ISR_0_PINT_10_SHIFT		10
+#define PCE_ISR_0_PINT_10_SIZE		1
+/* Bit: 'PINT_9' */
+/* Description: 'Port Interrupt' */
+#define PCE_ISR_0_PINT_9_OFFSET	0x467
+#define PCE_ISR_0_PINT_9_SHIFT	9
+#define PCE_ISR_0_PINT_9_SIZE		1
+/* Bit: 'PINT_8' */
+/* Description: 'Port Interrupt' */
+#define PCE_ISR_0_PINT_8_OFFSET	0x467
+#define PCE_ISR_0_PINT_8_SHIFT	8
+#define PCE_ISR_0_PINT_8_SIZE		1
+/* Bit: 'PINT_7' */
+/* Description: 'Port Interrupt' */
+#define PCE_ISR_0_PINT_7_OFFSET	0x467
+#define PCE_ISR_0_PINT_7_SHIFT	7
+#define PCE_ISR_0_PINT_7_SIZE		1
+/* Bit: 'PINT_6' */
+/* Description: 'Port Interrupt' */
+#define PCE_ISR_0_PINT_6_OFFSET	0x467
+#define PCE_ISR_0_PINT_6_SHIFT	6
+#define PCE_ISR_0_PINT_6_SIZE		1
+/* Bit: 'PINT_5' */
+/* Description: 'Port Interrupt' */
+#define PCE_ISR_0_PINT_5_OFFSET	0x467
+#define PCE_ISR_0_PINT_5_SHIFT	5
+#define PCE_ISR_0_PINT_5_SIZE		1
+/* Bit: 'PINT_4' */
+/* Description: 'Port Interrupt' */
+#define PCE_ISR_0_PINT_4_OFFSET	0x467
+#define PCE_ISR_0_PINT_4_SHIFT	4
+#define PCE_ISR_0_PINT_4_SIZE		1
+/* Bit: 'PINT_3' */
+/* Description: 'Port Interrupt' */
+#define PCE_ISR_0_PINT_3_OFFSET	0x467
+#define PCE_ISR_0_PINT_3_SHIFT	3
+#define PCE_ISR_0_PINT_3_SIZE		1
+/* Bit: 'PINT_2' */
+/* Description: 'Port Interrupt' */
+#define PCE_ISR_0_PINT_2_OFFSET	0x467
+#define PCE_ISR_0_PINT_2_SHIFT	2
+#define PCE_ISR_0_PINT_2_SIZE		1
+/* Bit: 'PINT_1' */
+/* Description: 'Port Interrupt' */
+#define PCE_ISR_0_PINT_1_OFFSET	0x467
+#define PCE_ISR_0_PINT_1_SHIFT	1
+#define PCE_ISR_0_PINT_1_SIZE		1
+/* Bit: 'PINT_0' */
+/* Description: 'Port Interrupt' */
+#define PCE_ISR_0_PINT_0_OFFSET	0x467
+#define PCE_ISR_0_PINT_0_SHIFT	0
+#define PCE_ISR_0_PINT_0_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Parser and ClassificationEngine Global */
+/* Interrupt Status Register 1' */
+/* Bit: 'CHG' */
+/* Description: 'MAC Table Changed Entry Interrupt' */
+#define PCE_ISR_1_CHG_OFFSET	0x468
+#define PCE_ISR_1_CHG_SHIFT		7
+#define PCE_ISR_1_CHG_SIZE		1
+/* Bit: 'FLOWINT' */
+/* Description: 'Traffic Flow Table Interrupt Rule matched' */
+#define PCE_ISR_1_FLOWINT_OFFSET	0x468
+#define PCE_ISR_1_FLOWINT_SHIFT		6
+#define PCE_ISR_1_FLOWINT_SIZE		1
+/* Bit: 'CPH2' */
+/* Description: 'Classification Phase 2 Ready Interrupt' */
+#define PCE_ISR_1_CPH2_OFFSET	0x468
+#define PCE_ISR_1_CPH2_SHIFT	5
+#define PCE_ISR_1_CPH2_SIZE		1
+/* Bit: 'CPH1' */
+/* Description: 'Classification Phase 1 Ready Interrupt' */
+#define PCE_ISR_1_CPH1_OFFSET	0x468
+#define PCE_ISR_1_CPH1_SHIFT	4
+#define PCE_ISR_1_CPH1_SIZE		1
+/* Bit: 'CPH0' */
+/* Description: 'Classification Phase 0 Ready Interrupt' */
+#define PCE_ISR_1_CPH0_OFFSET	0x468
+#define PCE_ISR_1_CPH0_SHIFT	3
+#define PCE_ISR_1_CPH0_SIZE		1
+/* Bit: 'PRDY' */
+/* Description: 'Parser Ready Interrupt' */
+#define PCE_ISR_1_PRDY_OFFSET	0x468
+#define PCE_ISR_1_PRDY_SHIFT	2
+#define PCE_ISR_1_PRDY_SIZE		1
+/* Bit: 'IGTF' */
+/* Description: 'IGMP Table Full Interrupt' */
+#define PCE_ISR_1_IGTF_OFFSET	0x468
+#define PCE_ISR_1_IGTF_SHIFT	1
+#define PCE_ISR_1_IGTF_SIZE		1
+/* Bit: 'MTF' */
+/* Description: 'MAC Table Full Interrupt' */
+#define PCE_ISR_1_MTF_OFFSET	0x468
+#define PCE_ISR_1_MTF_SHIFT		0
+#define PCE_ISR_1_MTF_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Parser Status Register' */
+/* Bit: 'FSM_DAT_CNT' */
+/* Description: 'Parser FSM Data Counter' */
+#define PARSER_STAT_FSM_DAT_CNT_OFFSET	0x469
+#define PARSER_STAT_FSM_DAT_CNT_SHIFT		8
+#define PARSER_STAT_FSM_DAT_CNT_SIZE		8
+/* Bit: 'FSM_STATE' */
+/* Description: 'Parser FSM State' */
+#define PARSER_STAT_FSM_STATE_OFFSET	0x469
+#define PARSER_STAT_FSM_STATE_SHIFT		5
+#define PARSER_STAT_FSM_STATE_SIZE		3
+/* Bit: 'PKT_ERR' */
+/* Description: 'Packet error detected' */
+#define PARSER_STAT_PKT_ERR_OFFSET	0x469
+#define PARSER_STAT_PKT_ERR_SHIFT		4
+#define PARSER_STAT_PKT_ERR_SIZE		1
+/* Bit: 'FSM_FIN' */
+/* Description: 'Parser FSM finished' */
+#define PARSER_STAT_FSM_FIN_OFFSET	0x469
+#define PARSER_STAT_FSM_FIN_SHIFT		3
+#define PARSER_STAT_FSM_FIN_SIZE		1
+/* Bit: 'FSM_START' */
+/* Description: 'Parser FSM start' */
+#define PARSER_STAT_FSM_START_OFFSET	0x469
+#define PARSER_STAT_FSM_START_SHIFT		2
+#define PARSER_STAT_FSM_START_SIZE		1
+/* Bit: 'FIFO_RDY' */
+/* Description: 'Parser FIFO ready for read.' */
+#define PARSER_STAT_FIFO_RDY_OFFSET	0x469
+#define PARSER_STAT_FIFO_RDY_SHIFT	1
+#define PARSER_STAT_FIFO_RDY_SIZE		1
+/* Bit: 'FIFO_FULL' */
+/* Description: 'Parser's FIFO full' */
+#define PARSER_STAT_FIFO_FULL_OFFSET	0x469
+#define PARSER_STAT_FIFO_FULL_SHIFT		0
+#define PARSER_STAT_FIFO_FULL_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'PCE Changed MAC Entry Number' */
+/* Bit: 'NUM' */
+/* Description: 'PCE Changed MAC Entry Number' */
+#define PCE_CGDMAC_NUM_OFFSET		0x46A
+#define PCE_CGDMAC_NUM_SHIFT		0
+#define PCE_CGDMAC_NUM_SIZE			13
+/* --------------------------------------------------- */
+/* Register: 'PCE Trunking Distribution Number' (LTQ_GSWIP_2_2)*/
+/* Bit: 'DIP' */
+/* Description: 'Destination IP Mask' */
+#define PCE_TRUNK_CONF_DIP_OFFSET	0x46B
+#define PCE_TRUNK_CONF_DIP_SHIFT	3
+#define PCE_TRUNK_CONF_DIP_SIZE		1
+/* Bit: 'SIP' */
+/* Description: 'Source IP Mask' */
+#define PCE_TRUNK_CONF_SIP_OFFSET	0x46B
+#define PCE_TRUNK_CONF_SIP_SHIFT	2
+#define PCE_TRUNK_CONF_SIP_SIZE		1
+/* Bit: 'DA' */
+/* Description: 'Destination MAC Mask' */
+#define PCE_TRUNK_CONF_DA_OFFSET	0x46B
+#define PCE_TRUNK_CONF_DA_SHIFT		1
+#define PCE_TRUNK_CONF_DA_SIZE		1
+/* Bit: 'SA' */
+/* Description: 'Source MAC Mask' */
+#define PCE_TRUNK_CONF_SA_OFFSET	0x46B
+#define PCE_TRUNK_CONF_SA_SHIFT		0
+#define PCE_TRUNK_CONF_SA_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'PCE Meter Shaper Overhead Byte Configuration' (LTQ_GSWIP_2_2)*/
+/* Bit: 'OVERHD' */
+/* Description: 'PCE Meter Overhead Byte' */
+#define PCE_OVERHD_OVERHD_OFFSET	0x46C
+#define PCE_OVERHD_OVERHD_SHIFT		0
+#define PCE_OVERHD_OVERHD_SIZE		8
+/* --------------------------------------------------- */
+/* Register: 'Routing Table Access Control Register' (LTQ_GSWIP_3_0)*/
+/* Bit: 'BAS' */
+/* Description: 'Access Busy/Access Start' */
+#define PCE_RTBL_CTRL_BAS_OFFSET	0x46D
+#define PCE_RTBL_CTRL_BAS_SHIFT		15
+#define PCE_RTBL_CTRL_BAS_SIZE		1
+/* Bit: 'VLD' */
+/* Description: 'Lookup Entry Valid' */
+#define PCE_RTBL_CTRL_VLD_OFFSET	0x46D
+#define PCE_RTBL_CTRL_VLD_SHIFT		12
+#define PCE_RTBL_CTRL_VLD_SIZE		1
+/* Bit: 'OPMOD' */
+/* Description: 'Lookup Table Access Operation Mode' */
+#define PCE_RTBL_CTRL_OPMOD_OFFSET	0x46D
+#define PCE_RTBL_CTRL_OPMOD_SHIFT		5
+#define PCE_RTBL_CTRL_OPMOD_SIZE		2
+/* Bit: 'ADDR' */
+/* Description: 'Lookup Table Address' */
+#define PCE_RTBL_CTRL_ADDR_OFFSET	0x46D
+#define PCE_RTBL_CTRL_ADDR_SHIFT	0
+#define PCE_RTBL_CTRL_ADDR_SIZE		5
+/* --------------------------------------------------- */
+/* Register: 'PCE Flow Engine Common Region Start Index Register' */
+/**	(LTQ_GSWIP_3_0)*/
+/* Bit: 'INDEX' */
+/* Description: 'PCE Flow Engine Common Region Start Index ' */
+#define PCE_TFCR_ID_INDEX_OFFSET	0x46E
+#define PCE_TFCR_ID_INDEX_SHIFT		2
+#define PCE_TFCR_ID_INDEX_SIZE		7
+/* --------------------------------------------------- */
+/* Register: 'PCE Flow Engine Common Region Entry Numbers Register' */
+/**	(LTQ_GSWIP_3_0)*/
+/* Bit: 'NUM' */
+/* Description: 'PCE Flow Engine Common Region Entry Numbers ' */
+#define PCE_TFCR_NUM_NUM_OFFSET	0x46F
+#define PCE_TFCR_NUM_NUM_SHIFT	0
+#define PCE_TFCR_NUM_NUM_SIZE		8
+/* --------------------------------------------------- */
+/* Register: 'PCE CPU Meter Control Register'(LTQ_GSWIP_3_0)*/
+/* Bit: 'REQ' */
+/* Description: 'Meter Trigger Request' */
+#define PCE_CPUMETER_CTRL_REQ_OFFSET	0x470
+#define PCE_CPUMETER_CTRL_REQ_SHIFT		15
+#define PCE_CPUMETER_CTRL_REQ_SIZE		1
+/* Bit: 'MT1EN' */
+/* Description: 'Metering Instance 1 Enable' */
+#define PCE_CPUMETER_CTRL_MT1EN_OFFSET	0x470
+#define PCE_CPUMETER_CTRL_MT1EN_SHIFT		14
+#define PCE_CPUMETER_CTRL_MT1EN_SIZE		1
+/* Bit: 'MT0EN' */
+/* Description: 'Metering Instance 0 Enable' */
+#define PCE_CPUMETER_CTRL_MT0EN_OFFSET	0x470
+#define PCE_CPUMETER_CTRL_MT0EN_SHIFT		13
+#define PCE_CPUMETER_CTRL_MT0EN_SIZE		1
+/* Bit: 'AFTCOL' */
+/* Description: 'Packet Color After Metering' */
+#define PCE_CPUMETER_CTRL_AFTCOL_OFFSET	0x470
+#define PCE_CPUMETER_CTRL_AFTCOL_SHIFT	2
+#define PCE_CPUMETER_CTRL_AFTCOL_SIZE		2
+/* Bit: 'PRECOL' */
+/* Description: 'Packet Color Before Metering' */
+#define PCE_CPUMETER_CTRL_PRECOL_OFFSET	0x470
+#define PCE_CPUMETER_CTRL_PRECOL_SHIFT	0
+#define PCE_CPUMETER_CTRL_PRECOL_SIZE		2
+/* --------------------------------------------------- */
+/* Register: 'PCE CPU Meter Size Register'(LTQ_GSWIP_3_0)*/
+/* Bit: 'SIZE' */
+/* Description: 'Packet Size' */
+#define PCE_CPUMETER_SIZE_SIZE_OFFSET	0x471
+#define PCE_CPUMETER_SIZE_SIZE_SHIFT	0
+#define PCE_CPUMETER_SIZE_SIZE_SIZE		14
+/* --------------------------------------------------- */
+/* Register: 'PCE CPU Meter Instance 0 ID Register'(LTQ_GSWIP_3_0)*/
+/* Bit: 'MID' */
+/* Description: 'Meter Instance 0 ID' */
+#define PCE_CPUMETER_MID0_MID_OFFSET	0x472
+#define PCE_CPUMETER_MID0_MID_SHIFT		0
+#define PCE_CPUMETER_MID0_MID_SIZE		6
+/* --------------------------------------------------- */
+/* Register: 'PCE CPU Meter Instance 1 ID Register'(LTQ_GSWIP_3_0)*/
+/* Bit: 'MID' */
+/* Description: 'Meter Instance 1 ID' */
+#define PCE_CPUMETER_MID1_MID_OFFSET	0x473
+#define PCE_CPUMETER_MID1_MID_SHIFT		0
+#define PCE_CPUMETER_MID1_MID_SIZE		6
+/* --------------------------------------------------- */
+/* Register: 'PCE MPE Meter Control Register'(LTQ_GSWIP_3_0)*/
+/* Bit: 'REQ' */
+/* Description: 'Meter Trigger Request' */
+#define PCE_MPEMETER_CTRL_REQ_OFFSET	0x478
+#define PCE_MPEMETER_CTRL_REQ_SHIFT		15
+#define PCE_MPEMETER_CTRL_REQ_SIZE		1
+/* Bit: 'MT1EN' */
+/* Description: 'Metering Instance 1 Enable' */
+#define PCE_MPEMETER_CTRL_MT1EN_OFFSET	0x478
+#define PCE_MPEMETER_CTRL_MT1EN_SHIFT		14
+#define PCE_MPEMETER_CTRL_MT1EN_SIZE		1
+/* Bit: 'MT0EN' */
+/* Description: 'Metering Instance 0 Enable' */
+#define PCE_MPEMETER_CTRL_MT0EN_OFFSET	0x478
+#define PCE_MPEMETER_CTRL_MT0EN_SHIFT		13
+#define PCE_MPEMETER_CTRL_MT0EN_SIZE		1
+/* Bit: 'AFTCOL' */
+/* Description: 'Packet Color After Metering' */
+#define PCE_MPEMETER_CTRL_AFTCOL_OFFSET	0x478
+#define PCE_MPEMETER_CTRL_AFTCOL_SHIFT	2
+#define PCE_MPEMETER_CTRL_AFTCOL_SIZE		2
+/* Bit: 'PRECOL' */
+/* Description: 'Packet Color Before Metering' */
+#define PCE_MPEMETER_CTRL_PRECOL_OFFSET	0x478
+#define PCE_MPEMETER_CTRL_PRECOL_SHIFT	0
+#define PCE_MPEMETER_CTRL_PRECOL_SIZE		2
+/* --------------------------------------------------- */
+/* Register: 'PCE MPE Meter Size Register'(LTQ_GSWIP_3_0)*/
+/* Bit: 'SIZE' */
+/* Description: 'Packet Size' */
+#define PCE_MPEMETER_SIZE_SIZE_OFFSET	0x479
+#define PCE_MPEMETER_SIZE_SIZE_SHIFT	0
+#define PCE_MPEMETER_SIZE_SIZE_SIZE		14
+/* --------------------------------------------------- */
+/* Register: 'PCE MPE Meter Instance 0 ID Register'(LTQ_GSWIP_3_0)*/
+/* Bit: 'MID' */
+/* Description: 'Meter Instance 0 ID' */
+#define PCE_MPEMETER_MID0_MID_OFFSET	0x47A
+#define PCE_MPEMETER_MID0_MID_SHIFT		0
+#define PCE_MPEMETER_MID0_MID_SIZE		6
+/* --------------------------------------------------- */
+/* Register: 'PCE MPE Meter Instance 1 ID Register'(LTQ_GSWIP_3_0)*/
+/* Bit: 'MID' */
+/* Description: 'Meter Instance 0 ID' */
+#define PCE_MPEMETER_MID1_MID_OFFSET	0x47B
+#define PCE_MPEMETER_MID1_MID_SHIFT		0
+#define PCE_MPEMETER_MID1_MID_SIZE		6
+/* --------------------------------------------------- */
+/* Register: 'PCE Port Index Register'(LTQ_GSWIP_3_0)*/
+/* Bit: 'CPU' */
+/* Description: 'PCE CPU Port Index Register' */
+#define PCE_PID_CPU_OFFSET	0x47C
+#define PCE_PID_CPU_SHIFT		0
+#define PCE_PID_CPU_SIZE		4
+/* --------------------------------------------------- */
+/* Register: 'PCE Port ControlRegister 0' */
+/* Bit: 'MSTP' */
+/* Description: 'Multiple STP Instance Enable' (LTQ_GSWIP_2_2) */
+#define PCE_PCTRL_0_MSTP_OFFSET	0x480
+#define PCE_PCTRL_0_MSTP_SHIFT	15
+#define PCE_PCTRL_0_MSTP_SIZE		1
+/* Bit: 'SPFDIS' */
+/* Description: 'Port Spoofing Detection' (LTQ_GSWIP_2_2)*/
+#define PCE_PCTRL_0_SPFDIS_OFFSET	0x480
+#define PCE_PCTRL_0_SPFDIS_SHIFT	14
+#define PCE_PCTRL_0_SPFDIS_SIZE		1
+/* Bit: 'MCST' */
+/* Description: 'Multicast Forwarding Mode Selection' */
+#define PCE_PCTRL_0_MCST_OFFSET	0x480
+#define PCE_PCTRL_0_MCST_SHIFT	13
+#define PCE_PCTRL_0_MCST_SIZE		1
+/* Bit: 'EGSTEN' */
+/* Description: 'Table-based Egress Special Tag Enable' */
+#define PCE_PCTRL_0_EGSTEN_OFFSET	0x480
+#define PCE_PCTRL_0_EGSTEN_SHIFT	12
+#define PCE_PCTRL_0_EGSTEN_SIZE		1
+/* Bit: 'IGSTEN' */
+/* Description: 'Ingress Special Tag Enable' */
+#define PCE_PCTRL_0_IGSTEN_OFFSET	0x480
+#define PCE_PCTRL_0_IGSTEN_SHIFT	11
+#define PCE_PCTRL_0_IGSTEN_SIZE		1
+/* Bit: 'PCPEN' */
+/* Description: 'PCP Remarking Mode' */
+#define PCE_PCTRL_0_PCPEN_OFFSET	0x480
+#define PCE_PCTRL_0_PCPEN_SHIFT		10
+#define PCE_PCTRL_0_PCPEN_SIZE		1
+/* Bit: 'CLPEN' */
+/* Description: 'Class Remarking Mode' */
+#define PCE_PCTRL_0_CLPEN_OFFSET	0x480
+#define PCE_PCTRL_0_CLPEN_SHIFT		9
+#define PCE_PCTRL_0_CLPEN_SIZE		1
+/* Bit: 'DPEN' */
+/* Description: 'Drop Precedence Remarking Mode' */
+#define PCE_PCTRL_0_DPEN_OFFSET	0x480
+#define PCE_PCTRL_0_DPEN_SHIFT	8
+#define PCE_PCTRL_0_DPEN_SIZE		1
+/* Bit: 'CMOD' */
+/* Description: 'Three-color Marker Color Mode' */
+#define PCE_PCTRL_0_CMOD_OFFSET	0x480
+#define PCE_PCTRL_0_CMOD_SHIFT	7
+#define PCE_PCTRL_0_CMOD_SIZE		1
+/* Bit: 'VREP' */
+/* Description: 'VLAN Replacement Mode' */
+#define PCE_PCTRL_0_VREP_OFFSET	0x480
+#define PCE_PCTRL_0_VREP_SHIFT	6
+#define PCE_PCTRL_0_VREP_SIZE		1
+/* Bit: 'TVM' */
+/* Description: 'Transparent VLAN Mode' */
+#define PCE_PCTRL_0_TVM_OFFSET	0x480
+#define PCE_PCTRL_0_TVM_SHIFT		5
+#define PCE_PCTRL_0_TVM_SIZE		1
+/* Bit: 'PLOCK' */
+/* Description: 'Port Locking Enable' */
+#define PCE_PCTRL_0_PLOCK_OFFSET	0x480
+#define PCE_PCTRL_0_PLOCK_SHIFT		4
+#define PCE_PCTRL_0_PLOCK_SIZE		1
+/* Bit: 'AGEDIS' */
+/* Description: 'Aging Disable' */
+#define PCE_PCTRL_0_AGEDIS_OFFSET	0x480
+#define PCE_PCTRL_0_AGEDIS_SHIFT	3
+#define PCE_PCTRL_0_AGEDIS_SIZE		1
+/* Bit: 'PSTATE' */
+/* Description: 'Port State' */
+#define PCE_PCTRL_0_PSTATE_OFFSET	0x480
+#define PCE_PCTRL_0_PSTATE_SHIFT	0
+#define PCE_PCTRL_0_PSTATE_SIZE		3
+/* --------------------------------------------------- */
+/* Register: 'PCE Port ControlRegister 1' */
+/* Bit: 'LRNLIM' */
+/* Description: 'MAC Address Learning Limit' */
+#define PCE_PCTRL_1_LRNLIM_OFFSET	0x481
+#define PCE_PCTRL_1_LRNLIM_SHIFT	0
+#define PCE_PCTRL_1_LRNLIM_SIZE		8
+/* --------------------------------------------------- */
+/* Register: 'PCE Port ControlRegister 2' */
+/* Bit: 'L2NAT' (LTQ_GSWIP_3_0)*/
+/* Description: 'Enables the L2NAT' */
+#define PCE_PCTRL_2_L2NAT_OFFSET	0x482
+#define PCE_PCTRL_2_L2NAT_SHIFT		11
+#define PCE_PCTRL_2_L2NAT_SIZE		1
+/* Bit: 'SDEIEN' */
+/* Description: 'STAG DEI Remarking Mode' (LTQ_GSWIP_2_2) */
+#define PCE_PCTRL_2_SDEIEN_OFFSET	0x482
+#define PCE_PCTRL_2_SDEIEN_SHIFT	10
+#define PCE_PCTRL_2_SDEIEN_SIZE		1
+/* Bit: 'SPCPEN' */
+/* Description: 'STAG PCP Remarking Mode' (LTQ_GSWIP_2_2) */
+#define PCE_PCTRL_2_SPCPEN_OFFSET	0x482
+#define PCE_PCTRL_2_SPCPEN_SHIFT	9
+#define PCE_PCTRL_2_SPCPEN_SIZE		1
+/* Bit: 'SPCP' */
+/* Description: 'Enable VLAN STAG PCP and DEI to select */
+/**	the Class of Service' (LTQ_GSWIP_2_2) */
+#define PCE_PCTRL_2_SPCP_OFFSET	0x482
+#define PCE_PCTRL_2_SPCP_SHIFT	8
+#define PCE_PCTRL_2_SPCP_SIZE		1
+/* Bit: 'DSCPMOD' */
+/* Description: 'DSCP Mode Selection' */
+#define PCE_PCTRL_2_DSCPMOD_OFFSET	0x482
+#define PCE_PCTRL_2_DSCPMOD_SHIFT		7
+#define PCE_PCTRL_2_DSCPMOD_SIZE		1
+/* Bit: 'DSCP' */
+/* Description: 'Enable DSCP to select the Class of Service' */
+#define PCE_PCTRL_2_DSCP_OFFSET	0x482
+#define PCE_PCTRL_2_DSCP_SHIFT	5
+#define PCE_PCTRL_2_DSCP_SIZE		2
+/* Bit: 'PCP' */
+/* Description: 'Enable VLAN PCP to select the Class of Service' */
+#define PCE_PCTRL_2_PCP_OFFSET	0x482
+#define PCE_PCTRL_2_PCP_SHIFT		4
+#define PCE_PCTRL_2_PCP_SIZE		1
+/* Bit: 'PCLASS' */
+/* Description: 'Port-based Traffic Class' */
+#define PCE_PCTRL_2_PCLASS_OFFSET	0x482
+#define PCE_PCTRL_2_PCLASS_SHIFT	0
+#define PCE_PCTRL_2_PCLASS_SIZE		4
+/* --------------------------------------------------- */
+/* Register: 'PCE Port ControlRegister 3'  */
+/* Bit: 'LNDIS' */
+/* Description: 'Learning Disable'(LTQ_GSWIP_2_2) */
+#define PCE_PCTRL_3_LNDIS_OFFSET	0x483
+#define PCE_PCTRL_3_LNDIS_SHIFT		15
+#define PCE_PCTRL_3_LNDIS_SIZE		1
+/* Bit: 'IGPTRM' */
+/* Description: 'Ingress Port Removal Disable'(LTQ_GSWIP_2_2)*/
+#define PCE_PCTRL_3_IGPTRM_OFFSET	0x483
+#define PCE_PCTRL_3_IGPTRM_SHIFT	14
+#define PCE_PCTRL_3_IGPTRM_SIZE		1
+/* Bit: 'VIO_9' */
+/* Description: 'New MAC-Port Association Mirroring Enable'(LTQ_GSWIP_2_2) */
+#define PCE_PCTRL_3_VIO_9_OFFSET	0x483
+#define PCE_PCTRL_3_VIO_9_SHIFT		13
+#define PCE_PCTRL_3_VIO_9_SIZE		1
+/* Bit: 'VIO_8' */
+/* Description: 'Violation Type 8 Mirroring Enable' */
+#define PCE_PCTRL_3_VIO_8_OFFSET	0x483
+#define PCE_PCTRL_3_VIO_8_SHIFT		12
+#define PCE_PCTRL_3_VIO_8_SIZE		1
+/* Bit: 'EDIR' */
+/* Description: 'Egress Redirection Mode' */
+#define PCE_PCTRL_3_EDIR_OFFSET	0x483
+#define PCE_PCTRL_3_EDIR_SHIFT	11
+#define PCE_PCTRL_3_EDIR_SIZE		1
+/* Bit: 'RXDMIR' */
+/* Description: 'Receive Mirroring Enable for dropped frames' */
+#define PCE_PCTRL_3_RXDMIR_OFFSET	0x483
+#define PCE_PCTRL_3_RXDMIR_SHIFT	10
+#define PCE_PCTRL_3_RXDMIR_SIZE		1
+/* Bit: 'RXVMIR' */
+/* Description: 'Receive Mirroring Enable for valid frames' */
+#define PCE_PCTRL_3_RXVMIR_OFFSET	0x483
+#define PCE_PCTRL_3_RXVMIR_SHIFT	9
+#define PCE_PCTRL_3_RXVMIR_SIZE		1
+/* Bit: 'TXMIR' */
+/* Description: 'Transmit Mirroring Enable' */
+#define PCE_PCTRL_3_TXMIR_OFFSET	0x483
+#define PCE_PCTRL_3_TXMIR_SHIFT		8
+#define PCE_PCTRL_3_TXMIR_SIZE		1
+/* Bit: 'VIO_7' */
+/* Description: 'Violation Type 7 Mirroring Enable' */
+#define PCE_PCTRL_3_VIO_7_OFFSET	0x483
+#define PCE_PCTRL_3_VIO_7_SHIFT		7
+#define PCE_PCTRL_3_VIO_7_SIZE		1
+/* Bit: 'VIO_6' */
+/* Description: 'Violation Type 6 Mirroring Enable' */
+#define PCE_PCTRL_3_VIO_6_OFFSET	0x483
+#define PCE_PCTRL_3_VIO_6_SHIFT		6
+#define PCE_PCTRL_3_VIO_6_SIZE		1
+/* Bit: 'VIO_5' */
+/* Description: 'Violation Type 5 Mirroring Enable' */
+#define PCE_PCTRL_3_VIO_5_OFFSET	0x483
+#define PCE_PCTRL_3_VIO_5_SHIFT		5
+#define PCE_PCTRL_3_VIO_5_SIZE		1
+/* Bit: 'VIO_4' */
+/* Description: 'Violation Type 4 Mirroring Enable' */
+#define PCE_PCTRL_3_VIO_4_OFFSET	0x483
+#define PCE_PCTRL_3_VIO_4_SHIFT		4
+#define PCE_PCTRL_3_VIO_4_SIZE		1
+/* Bit: 'VIO_3' */
+/* Description: 'Violation Type 3 Mirroring Enable' */
+#define PCE_PCTRL_3_VIO_3_OFFSET	0x483
+#define PCE_PCTRL_3_VIO_3_SHIFT		3
+#define PCE_PCTRL_3_VIO_3_SIZE		1
+/* Bit: 'VIO_2' */
+/* Description: 'Violation Type 2 Mirroring Enable' */
+#define PCE_PCTRL_3_VIO_2_OFFSET	0x483
+#define PCE_PCTRL_3_VIO_2_SHIFT		2
+#define PCE_PCTRL_3_VIO_2_SIZE		1
+/* Bit: 'VIO_1' */
+/* Description: 'Violation Type 1 Mirroring Enable' */
+#define PCE_PCTRL_3_VIO_1_OFFSET	0x483
+#define PCE_PCTRL_3_VIO_1_SHIFT		1
+#define PCE_PCTRL_3_VIO_1_SIZE		1
+/* Bit: 'VIO_0' */
+/* Description: 'Violation Type 0 Mirroring Enable' */
+#define PCE_PCTRL_3_VIO_0_OFFSET	0x483
+#define PCE_PCTRL_3_VIO_0_SHIFT		0
+#define PCE_PCTRL_3_VIO_0_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Wake-on-LAN ControlRegister' */
+/* Bit: 'PORT' */
+/* Description: 'WoL Enable' */
+#define WOL_CTRL_PORT_OFFSET	0x484
+#define WOL_CTRL_PORT_SHIFT		0
+#define WOL_CTRL_PORT_SIZE		1
+/* Bit: 'ADDRDIS' */
+/* Description: 'WoL Ignore Address Check' (GSWIP_3_1)*/
+#define WOL_CTRL_ADDRDIS_OFFSET	0x484
+#define WOL_CTRL_ADDRDIS_SHIFT		1
+#define WOL_CTRL_ADDRDIS_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'PCE VLAN ControlRegister'*/
+/* Bit: 'MACEN' */
+/* Description: 'MAC VLAN Enable' (LTQ_GSWIP_2_2) */
+#define PCE_VCTRL_MACEN_OFFSET	0x485
+#define PCE_VCTRL_MACEN_SHIFT		15
+#define PCE_VCTRL_MACEN_SIZE		1
+/* Bit: 'SVID0' */
+/* Description: 'STAG Priority Tagged Rule' (LTQ_GSWIP_2_2) */
+#define PCE_VCTRL_SVID0_OFFSET	0x485
+#define PCE_VCTRL_SVID0_SHIFT		14
+#define PCE_VCTRL_SVID0_SIZE		1
+/* Bit: 'SVSR' */
+/* Description: 'STAG VLAN Security Rule' (LTQ_GSWIP_2_2) */
+#define PCE_VCTRL_SVSR_OFFSET		0x485
+#define PCE_VCTRL_SVSR_SHIFT		13
+#define PCE_VCTRL_SVSR_SIZE			1
+/* Bit: 'SVEMR' (LTQ_GSWIP_2_2)*/
+/* Description: 'STAG VLAN Egress Member Violation Rule' */
+#define PCE_VCTRL_SVEMR_OFFSET	0x485
+#define PCE_VCTRL_SVEMR_SHIFT		12
+#define PCE_VCTRL_SVEMR_SIZE		1
+/* Bit: 'SVIMR' (LTQ_GSWIP_2_2)*/
+/* Description: 'STAG VLAN Ingress Member Violation Rule' */
+#define PCE_VCTRL_SVIMR_OFFSET	0x485
+#define PCE_VCTRL_SVIMR_SHIFT		11
+#define PCE_VCTRL_SVIMR_SIZE		1
+/* Bit: 'SVINR' */
+/* Description: 'STAG VLAN Ingress Tag Rule'(LTQ_GSWIP_2_2) */
+#define PCE_VCTRL_SVINR_OFFSET	0x485
+#define PCE_VCTRL_SVINR_SHIFT		9
+#define PCE_VCTRL_SVINR_SIZE		2
+/* Bit: 'STEN' */
+/* Description: 'STAG VLAN Enable'(LTQ_GSWIP_2_2) */
+#define PCE_VCTRL_STEN_OFFSET		0x485
+#define PCE_VCTRL_STEN_SHIFT		8
+#define PCE_VCTRL_STEN_SIZE			1
+/* Bit: 'STVM' */
+/* Description: 'STAG Transparent VLAN Mode'(LTQ_GSWIP_2_2) */
+#define PCE_VCTRL_STVM_OFFSET		0x485
+#define PCE_VCTRL_STVM_SHIFT		7
+#define PCE_VCTRL_STVM_SIZE			1
+/* Bit: 'VID0' */
+/* Description: 'Priority Tagged Rule' */
+#define PCE_VCTRL_VID0_OFFSET		0x485
+#define PCE_VCTRL_VID0_SHIFT		6
+#define PCE_VCTRL_VID0_SIZE			1
+/* Bit: 'VSR' */
+/* Description: 'VLAN Security Rule' */
+#define PCE_VCTRL_VSR_OFFSET		0x485
+#define PCE_VCTRL_VSR_SHIFT			5
+#define PCE_VCTRL_VSR_SIZE			1
+/* Bit: 'VEMR' */
+/* Description: 'VLAN Egress Member Violation Rule' */
+#define PCE_VCTRL_VEMR_OFFSET		0x485
+#define PCE_VCTRL_VEMR_SHIFT		4
+#define PCE_VCTRL_VEMR_SIZE			1
+/* Bit: 'VIMR' */
+/* Description: 'VLAN Ingress Member Violation Rule' */
+#define PCE_VCTRL_VIMR_OFFSET		0x485
+#define PCE_VCTRL_VIMR_SHIFT		3
+#define PCE_VCTRL_VIMR_SIZE			1
+/* Bit: 'VINR' */
+/* Description: 'VLAN Ingress Tag Rule' */
+#define PCE_VCTRL_VINR_OFFSET		0x485
+#define PCE_VCTRL_VINR_SHIFT		1
+#define PCE_VCTRL_VINR_SIZE			2
+/* Bit: 'UVR' */
+/* Description: 'Unknown VLAN Rule' */
+#define PCE_VCTRL_UVR_OFFSET		0x485
+#define PCE_VCTRL_UVR_SHIFT			0
+#define PCE_VCTRL_UVR_SIZE			1
+/* --------------------------------------------------- */
+/* Register: 'PCE Default PortVID Register' */
+/* Bit: 'PVID' (LTQ_GSWIP_2_2) size changed from 6 to 12*/
+/* Description: 'Default Port VID Index'  */
+#define PCE_DEFPVID_PVID_OFFSET	0x486
+#define PCE_DEFPVID_PVID_SHIFT	0
+#define PCE_DEFPVID_PVID_SIZE		12
+/* --------------------------------------------------- */
+/* Register: 'PCE Port StatusRegister' */
+/* Bit: 'LRNCNT' */
+/* Description: 'Learning Count' */
+#define PCE_PSTAT_LRNCNT_OFFSET	0x487
+#define PCE_PSTAT_LRNCNT_SHIFT	0
+#define PCE_PSTAT_LRNCNT_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Parser and ClassificationEngine Port Interrupt Enable Register' */
+/* Bit: 'MTEBP' (LTQ_GSWIP_2_2)*/
+/* Description: 'Metering Based Backpressure Status Change Interrupt Enable' */
+#define PCE_PIER_MTEBP_OFFSET	0x488
+#define PCE_PIER_MTEBP_SHIFT	8
+#define PCE_PIER_MTEBP_SIZE		1
+/* Bit: 'SPFINT' (LTQ_GSWIP_2_2)*/
+/* Description: 'Port Spoofing Alert Interrupt Enable' */
+#define PCE_PIER_SPFINT_OFFSET	0x488
+#define PCE_PIER_SPFINT_SHIFT		7
+#define PCE_PIER_SPFINT_SIZE		1
+/* Bit: 'FRZDRP' */
+/* Description: 'MAC Table Freeze Drop Interrupt Enable' */
+#define PCE_PIER_FRZDRP_OFFSET	0x488
+#define PCE_PIER_FRZDRP_SHIFT		6
+#define PCE_PIER_FRZDRP_SIZE		1
+/* Bit: 'CLDRP' */
+/* Description: 'Classification Drop Interrupt Enable' */
+#define PCE_PIER_CLDRP_OFFSET	0x488
+#define PCE_PIER_CLDRP_SHIFT	5
+#define PCE_PIER_CLDRP_SIZE		1
+/* Bit: 'PTDRP' */
+/* Description: 'Port Drop Interrupt Enable' */
+#define PCE_PIER_PTDRP_OFFSET	0x488
+#define PCE_PIER_PTDRP_SHIFT	4
+#define PCE_PIER_PTDRP_SIZE		1
+/* Bit: 'VLAN' */
+/* Description: 'VLAN Violation Interrupt Enable' */
+#define PCE_PIER_VLAN_OFFSET	0x488
+#define PCE_PIER_VLAN_SHIFT		3
+#define PCE_PIER_VLAN_SIZE		1
+/* Bit: 'WOL' */
+/* Description: 'Wake-on-LAN Interrupt Enable' */
+#define PCE_PIER_WOL_OFFSET		0x488
+#define PCE_PIER_WOL_SHIFT		2
+#define PCE_PIER_WOL_SIZE			1
+/* Bit: 'LOCK' */
+/* Description: 'Port Lock Alert Interrupt Enable' */
+#define PCE_PIER_LOCK_OFFSET	0x488
+#define PCE_PIER_LOCK_SHIFT		1
+#define PCE_PIER_LOCK_SIZE		1
+/* Bit: 'LIM' */
+/* Description: 'Port Limit Alert Interrupt Enable' */
+#define PCE_PIER_LIM_OFFSET	0x488
+#define PCE_PIER_LIM_SHIFT	0
+#define PCE_PIER_LIM_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Parser and ClassificationEngine Port Interrupt Status Register' */
+/* Bit: 'MTEBP' (LTQ_GSWIP_2_2)*/
+/* Description: 'Metering Based Backpressure Status Change Interrupt' */
+#define PCE_PISR_MTEBP_OFFSET	0x489
+#define PCE_PISR_MTEBP_SHIFT	8
+#define PCE_PISR_MTEBP_SIZE		1
+/* Bit: 'SPFINT'(LTQ_GSWIP_2_2) */
+/* Description: 'Port Spoofing Alert Interrupt' */
+#define PCE_PISR_SPFINT_OFFSET	0x489
+#define PCE_PISR_SPFINT_SHIFT		7
+#define PCE_PISR_SPFINT_SIZE		1
+/* Bit: 'FRZDRP' */
+/* Description: 'MAC Table Freeze Drop Interrupt' */
+#define PCE_PISR_FRZDRP_OFFSET	0x489
+#define PCE_PISR_FRZDRP_SHIFT		6
+#define PCE_PISR_FRZDRP_SIZE		1
+/* Bit: 'CLDRP' */
+/* Description: 'Classification Drop Interrupt' */
+#define PCE_PISR_CLDRP_OFFSET	0x489
+#define PCE_PISR_CLDRP_SHIFT	5
+#define PCE_PISR_CLDRP_SIZE		1
+/* Bit: 'PTDRP' */
+/* Description: 'Port Drop Interrupt' */
+#define PCE_PISR_PTDRP_OFFSET	0x489
+#define PCE_PISR_PTDRP_SHIFT	4
+#define PCE_PISR_PTDRP_SIZE		1
+/* Bit: 'VLAN' */
+/* Description: 'VLAN Violation Interrupt' */
+#define PCE_PISR_VLAN_OFFSET	0x489
+#define PCE_PISR_VLAN_SHIFT		3
+#define PCE_PISR_VLAN_SIZE		1
+/* Bit: 'WOL' */
+/* Description: 'Wake-on-LAN Interrupt' */
+#define PCE_PISR_WOL_OFFSET	0x489
+#define PCE_PISR_WOL_SHIFT	2
+#define PCE_PISR_WOL_SIZE		1
+/* Bit: 'LOCK' */
+/* Description: 'Port Lock Alert Interrupt' */
+#define PCE_PISR_LOCK_OFFSET	0x489
+#define PCE_PISR_LOCK_SHIFT		1
+#define PCE_PISR_LOCK_SIZE		1
+/* Bit: 'LIMIT' */
+/* Description: 'Port Limitation Alert Interrupt' */
+#define PCE_PISR_LIMIT_OFFSET	0x489
+#define PCE_PISR_LIMIT_SHIFT	0
+#define PCE_PISR_LIMIT_SIZE		1
+/* -------------------------------------------*/
+/* Register: 'PCE Default Port STAG VID Register'(LTQ_GSWIP_2_2) */
+/* Bit: 'PVID' */
+/* Description: 'Default Port STAG VID Index' */
+#define PCE_DEFPSVID_PVID_OFFSET	0x520
+#define PCE_DEFPSVID_PVID_SHIFT		0
+#define PCE_DEFPSVID_PVID_SIZE		13
+/* ---------------------------------------------*/
+/* Register: 'PCE Port Trunking Register' (LTQ_GSWIP_2_2)*/
+/* Bit: 'EN' */
+/* Description: 'Port Trunking Enable' */
+#define PCE_PTRUNK_EN_OFFSET	0x521
+#define PCE_PTRUNK_EN_SHIFT		15
+#define PCE_PTRUNK_EN_SIZE		1
+/* Bit: 'PARTER' */
+/* Description: 'Port Trunking Partner Port ID' */
+#define PCE_PTRUNK_PARTER_OFFSET	0x521
+#define PCE_PTRUNK_PARTER_SHIFT		0
+#define PCE_PTRUNK_PARTER_SIZE		4
+/* --------------------------------------------------- */
+/* Register: 'PCE Port Memmbership Register'(LTQ_GSWIP_3_0) */
+/* Bit: 'MEMBER' */
+/* Description: 'PCE Port Membership ' */
+#define PCE_PPM_MEMBER_OFFSET	0x540
+#define PCE_PPM_MEMBER_SHIFT	0
+#define PCE_PPM_MEMBER_SIZE		13
+/* ---------------------------------------------*/
+/* Register: 'PCE Port Egress VLAN Treatment Configuration Register' */
+/**	(LTQ_GSWIP_3_0)*/
+/* Bit: 'EGVMD' */
+/* Description: 'PCE Egress VLAN Treatment Access Selection' */
+#define PCE_EVLANCFG_EGVMD_OFFSET	0x541
+#define PCE_EVLANCFG_EGVMD_SHIFT		15
+#define PCE_EVLANCFG_EGVMD_SIZE		1
+/* Bit: 'EGVFST' */
+/* Description: 'PCE Egress VLAN Treatment First Entry Index ' */
+#define PCE_EVLANCFG_EGVFST_OFFSET	0x541
+#define PCE_EVLANCFG_EGVFST_SHIFT		0
+#define PCE_EVLANCFG_EGVFST_SIZE		8
+/* --------------------------------------------------- */
+/* Register:'PCE Flow Engine Port Region Start Index Register' */
+/* (LTQ_GSWIP_3_0)*/
+/* Bit: 'INDEX' */
+/* Description: 'PCE Flow Engine Port Region Start Index  ' */
+#define PCE_TFPR_INDEX_OFFSET	0x542
+#define PCE_TFPR_INDEX_SHIFT	2
+#define PCE_TFPR_INDEX_SIZE		6
+/* ---------------------------------------------*/
+/* Register:'PCE Flow Engine Port Region Entry Numbers Register' */
+/* (LTQ_GSWIP_3_0)*/
+/* Bit: 'NUMBER' */
+/* Description: 'PCE Flow Engine Port Region Entry Numbers ' */
+#define PCE_TFPR_NUMBER_OFFSET	0x543
+#define PCE_TFPR_NUMBER_SHIFT		2
+#define PCE_TFPR_NUMBER_SIZE		8
+/* ---------------------------------------------*/
+/* Register: 'PCE Ingress Port Removal Configuration Register'(LTQ_GSWIP_3_0) */
+/* Bit: 'SUB15' */
+/* Description: 'Sub-Interface Group 15 Ingress Port Removal' */
+#define PCE_IGPTRM_SUB15_OFFSET	0x546
+#define PCE_IGPTRM_SUB15_SHIFT	15
+#define PCE_IGPTRM_SUB15_SIZE		1
+/* Bit: 'SUB14' */
+/* Description: 'Sub-Interface Group 14 Ingress Port Removal' */
+#define PCE_IGPTRM_SUB14_OFFSET	0x546
+#define PCE_IGPTRM_SUB14_SHIFT	14
+#define PCE_IGPTRM_SUB14_SIZE		1
+/* Bit: 'SUB13' */
+/* Description: 'Sub-Interface Group 13 Ingress Port Removal' */
+#define PCE_IGPTRM_SUB13_OFFSET	0x546
+#define PCE_IGPTRM_SUB13_SHIFT	13
+#define PCE_IGPTRM_SUB13_SIZE		1
+/* Bit: 'SUB12' */
+/* Description: 'Sub-Interface Group 12 Ingress Port Removal' */
+#define PCE_IGPTRM_SUB12_OFFSET	0x546
+#define PCE_IGPTRM_SUB12_SHIFT	12
+#define PCE_IGPTRM_SUB12_SIZE		1
+/* Bit: 'SUB11' */
+/* Description: 'Sub-Interface Group 11 Ingress Port Removal' */
+#define PCE_IGPTRM_SUB11_OFFSET	0x546
+#define PCE_IGPTRM_SUB11_SHIFT	11
+#define PCE_IGPTRM_SUB11_SIZE		1
+/* Bit: 'SUB10' */
+/* Description: 'Sub-Interface Group 10 Ingress Port Removal' */
+#define PCE_IGPTRM_SUB10_OFFSET	0x546
+#define PCE_IGPTRM_SUB10_SHIFT	10
+#define PCE_IGPTRM_SUB10_SIZE		1
+/* Bit: 'SUB9' */
+/* Description: 'Sub-Interface Group 9 Ingress Port Removal' */
+#define PCE_IGPTRM_SUB9_OFFSET	0x546
+#define PCE_IGPTRM_SUB9_SHIFT		9
+#define PCE_IGPTRM_SUB9_SIZE		1
+/* Bit: 'SUB8' */
+/* Description: 'Sub-Interface Group 8 Ingress Port Removal' */
+#define PCE_IGPTRM_SUB8_OFFSET	0x546
+#define PCE_IGPTRM_SUB8_SHIFT		8
+#define PCE_IGPTRM_SUB8_SIZE		1
+/* Bit: 'SUB7' */
+/* Description: 'Sub-Interface Group 7 Ingress Port Removal' */
+#define PCE_IGPTRM_SUB7_OFFSET	0x546
+#define PCE_IGPTRM_SUB7_SHIFT		7
+#define PCE_IGPTRM_SUB7_SIZE		1
+/* Bit: 'SUB6' */
+/* Description: 'Sub-Interface Group 6 Ingress Port Removal' */
+#define PCE_IGPTRM_SUB6_OFFSET	0x546
+#define PCE_IGPTRM_SUB6_SHIFT		6
+#define PCE_IGPTRM_SUB6_SIZE		1
+/* Bit: 'SUB5' */
+/* Description: 'Sub-Interface Group 5 Ingress Port Removal' */
+#define PCE_IGPTRM_SUB5_OFFSET	0x546
+#define PCE_IGPTRM_SUB5_SHIFT		5
+#define PCE_IGPTRM_SUB5_SIZE		1
+/* Bit: 'SUB4' */
+/* Description: 'Sub-Interface Group 4 Ingress Port Removal' */
+#define PCE_IGPTRM_SUB4_OFFSET	0x546
+#define PCE_IGPTRM_SUB4_SHIFT		4
+#define PCE_IGPTRM_SUB4_SIZE		1
+/* Bit: 'SUB3' */
+/* Description: 'Sub-Interface Group 3 Ingress Port Removal' */
+#define PCE_IGPTRM_SUB3_OFFSET	0x546
+#define PCE_IGPTRM_SUB3_SHIFT		3
+#define PCE_IGPTRM_SUB3_SIZE		1
+/* Bit: 'SUB2' */
+/* Description: 'Sub-Interface Group 2 Ingress Port Removal' */
+#define PCE_IGPTRM_SUB2_OFFSET	0x546
+#define PCE_IGPTRM_SUB2_SHIFT		2
+#define PCE_IGPTRM_SUB2_SIZE		1
+/* Bit: 'SUB1' */
+/* Description: 'Sub-Interface Group 1 Ingress Port Removal' */
+#define PCE_IGPTRM_SUB1_OFFSET	0x546
+#define PCE_IGPTRM_SUB1_SHIFT		1
+#define PCE_IGPTRM_SUB1_SIZE		1
+/* Bit: 'SUB0' */
+/* Description: 'Sub-Interface Group 0 Ingress Port Removal' */
+#define PCE_IGPTRM_SUB0_OFFSET	0x546
+#define PCE_IGPTRM_SUB0_SHIFT		0
+#define PCE_IGPTRM_SUB0_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'PCE L2NAT MAC0 Register'(LTQ_GSWIP_3_0) */
+/* Bit: 'MAC0' */
+/* Description: 'L2NAT MAC Address Bit 15 to 0' */
+#define PCE_L2NAT_MAC0_MAC0_OFFSET	0x545
+#define PCE_L2NAT_MAC0_MAC0_SHIFT		0
+#define PCE_L2NAT_MAC0_MAC0_SIZE		16
+/* ---------------------------------------------*/
+/* Register: 'PCE L2NAT MAC1 Register'(LTQ_GSWIP_3_0) */
+/* Bit: 'MAC1' */
+/* Description: 'L2NAT MAC Address Bit 31 to 16' */
+#define PCE_L2NAT_MAC1_MAC1_OFFSET	0x546
+#define PCE_L2NAT_MAC1_MAC1_SHIFT		0
+#define PCE_L2NAT_MAC1_MAC1_SIZE		16
+/* ---------------------------------------------*/
+/* Register: 'PCE L2NAT MAC2 Register'(LTQ_GSWIP_3_0) */
+/* Bit: 'MAC2' */
+/* Description: 'L2NAT MAC Address Bit 47 to 32' */
+#define PCE_L2NAT_MAC2_MAC2_OFFSET	0x547
+#define PCE_L2NAT_MAC2_MAC2_SHIFT		0
+#define PCE_L2NAT_MAC2_MAC2_SIZE		16
+/* ---------------------------------------------*/
+/* Register: 'Three-colorMarker Control Register' */
+/* Bit: 'TEBYP' (LTQ_GSWIP_3_0)*/
+/* Description: 'Te Bucket Check Bypass' */
+#define PCE_TCM_CTRL_TEBYP_OFFSET	0x580
+#define PCE_TCM_CTRL_TEBYP_SHIFT	1
+#define PCE_TCM_CTRL_TEBYP_SIZE		1
+/* Bit: 'TCMEN' */
+/* Description: 'Three-color Marker metering instance enable' */
+#define PCE_TCM_CTRL_TCMEN_OFFSET	0x580
+#define PCE_TCM_CTRL_TCMEN_SHIFT	0
+#define PCE_TCM_CTRL_TCMEN_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Three-colorMarker Status Register' */
+/* Bit: 'MTEBP' (LTQ_GSWIP_2_2)*/
+/* Description: 'Metering Based Back Pressure Status' */
+#define PCE_TCM_STAT_MTEBP_OFFSET	0x581
+#define PCE_TCM_STAT_MTEBP_SHIFT	2
+#define PCE_TCM_STAT_MTEBP_SIZE		1
+/* Bit: 'AL1' */
+/* Description: 'Three-color Marker Alert 1 Status' */
+#define PCE_TCM_STAT_AL1_OFFSET	0x581
+#define PCE_TCM_STAT_AL1_SHIFT	1
+#define PCE_TCM_STAT_AL1_SIZE		1
+/* Bit: 'AL0' */
+/* Description: 'Three-color Marker Alert 0 Status' */
+#define PCE_TCM_STAT_AL0_OFFSET	0x581
+#define PCE_TCM_STAT_AL0_SHIFT	0
+#define PCE_TCM_STAT_AL0_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Three-color MarkerCommitted Burst Size Register' */
+/* Bit: 'CBS' */
+/* Description: 'Committed Burst Size' */
+#define PCE_TCM_CBS_CBS_OFFSET	0x582
+#define PCE_TCM_CBS_CBS_SHIFT		0
+#define PCE_TCM_CBS_CBS_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'Three-color MarkerExcess Burst Size Register' */
+/* Bit: 'EBS' */
+/* Description: 'Excess Burst Size' */
+#define PCE_TCM_EBS_EBS_OFFSET	0x583
+#define PCE_TCM_EBS_EBS_SHIFT		0
+#define PCE_TCM_EBS_EBS_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'Three-color MarkerInstantaneous Burst Size Register' */
+/* Bit: 'IBS' */
+/* Description: 'Instantaneous Burst Size' */
+#define PCE_TCM_IBS_IBS_OFFSET	0x584
+#define PCE_TCM_IBS_IBS_SHIFT		0
+#define PCE_TCM_IBS_IBS_SIZE		2
+/* --------------------------------------------------- */
+/* Register: 'Three-colorMarker Constant Information Rate Mantissa Register' */
+/* Bit: 'MANT' */
+/* Description: 'Rate Counter Mantissa' */
+#define PCE_TCM_CIR_MANT_MANT_OFFSET	0x585
+#define PCE_TCM_CIR_MANT_MANT_SHIFT		0
+#define PCE_TCM_CIR_MANT_MANT_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'Three-colorMarker Constant Information Rate Exponent Register' */
+/* Bit: 'EXP' */
+/* Description: 'Rate Counter Exponent' */
+#define PCE_TCM_CIR_EXP_EXP_OFFSET	0x586
+#define PCE_TCM_CIR_EXP_EXP_SHIFT		0
+#define PCE_TCM_CIR_EXP_EXP_SIZE		4
+/* --------------------------------------------------- */
+/* Register 'Instance Selection Register' ( LTQ_GSWIP_3_0 )*/
+/* Bit: 'INST' */
+/* Description: 'Instance Selection' */
+#define GSW_INST_SEL_INST_OFFSET	0xE00
+#define GSW_INST_SEL_INST_SHIFT		0
+#define GSW_INST_SEL_INST_SIZE		8
+/* --------------------------------------------------- */
+/* Register: 'Three-colorMarker Control Register' ( LTQ_GSWIP_3_0 )*/
+/* Bit: 'TMOD' (LTQ_GSWIP_3_0)*/
+/* Description: 'Meter Mode' */
+#define GSW_PCE_TCM_CTRL_TMOD_OFFSET	0xE10
+#define GSW_PCE_TCM_CTRL_TMOD_SHIFT	2
+#define GSW_PCE_TCM_CTRL_TMOD_SIZE	1
+/* Bit: 'TEBYP' (LTQ_GSWIP_3_0)*/
+/* Description: 'Te Bucket Check Bypass' */
+#define GSW_PCE_TCM_CTRL_TEBYP_OFFSET	0xE10
+#define GSW_PCE_TCM_CTRL_TEBYP_SHIFT	1
+#define GSW_PCE_TCM_CTRL_TEBYP_SIZE		1
+/* Bit: 'TCMEN' */
+/* Description: 'Three-color Marker metering instance enable' */
+#define GSW_PCE_TCM_CTRL_TCMEN_OFFSET	0xE10
+#define GSW_PCE_TCM_CTRL_TCMEN_SHIFT	0
+#define GSW_PCE_TCM_CTRL_TCMEN_SIZE		1
+
+/* Bit: 'BLIND' */
+/* Description: To Configure Meter Color Blind Mode'
+   applicable for GSWIP 3.1 only*/
+#define GSW_PCE_TCM_CTRL_BLIND_OFFSET	0xE10
+#define GSW_PCE_TCM_CTRL_BLIND_SHIFT	3
+#define GSW_PCE_TCM_CTRL_BLIND_SIZE		1
+
+/* --------------------------------------------------- */
+/* Register: 'Three-colorMarker Status Register' ( LTQ_GSWIP_3_0 )*/
+/* Bit: 'MTEBP' (LTQ_GSWIP_2_2)*/
+/* Description: 'Metering Based Back Pressure Status' */
+#define GSW_PCE_TCM_STAT_MTEBP_OFFSET	0xE11
+#define GSW_PCE_TCM_STAT_MTEBP_SHIFT	0
+#define GSW_PCE_TCM_STAT_MTEBP_SIZE		1
+/* Bit: 'AL1' */
+/* Description: 'Three-color Marker Alert 1 Status' */
+#define GSW_PCE_TCM_STAT_AL1_OFFSET	0xE11
+#define GSW_PCE_TCM_STAT_AL1_SHIFT		2
+#define GSW_PCE_TCM_STAT_AL1_SIZE		1
+/* Bit: 'AL0' */
+/* Description: 'Three-color Marker Alert 0 Status' */
+#define GSW_PCE_TCM_STAT_AL0_OFFSET	0xE11
+#define GSW_PCE_TCM_STAT_AL0_SHIFT		1
+#define GSW_PCE_TCM_STAT_AL0_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Three-color MarkerCommitted Burst Size Register' (LTQ_GSWIP_3_0)*/
+/* Bit: 'CBS' */
+/* Description: 'Committed Burst Size' */
+#define GSW_PCE_TCM_CBS_CBS_OFFSET	0xE12
+#define GSW_PCE_TCM_CBS_CBS_SHIFT		0
+#define GSW_PCE_TCM_CBS_CBS_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'Three-color MarkerExcess Burst Size Register' (LTQ_GSWIP_3_0)*/
+/* Bit: 'EBS' */
+/* Description: 'Excess Burst Size' */
+#define GSW_PCE_TCM_EBS_EBS_OFFSET	0xE13
+#define GSW_PCE_TCM_EBS_EBS_SHIFT		0
+#define GSW_PCE_TCM_EBS_EBS_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'Three-color MarkerInstantaneous Burst Size Register' */
+/* (LTQ_GSWIP_3_0) */
+/* Bit: 'IBS' */
+/* Description: 'Instantaneous Burst Size' */
+#define GSW_PCE_TCM_IBS_IBS_OFFSET	0xE14
+#define GSW_PCE_TCM_IBS_IBS_SHIFT		0
+#define GSW_PCE_TCM_IBS_IBS_SIZE		2
+
+/*Size changed in GWIP 3.1*/
+#define GSW_PCE_TCM_IBS_IBS_SIZE_GSWIP_3_1		10
+/* --------------------------------------------------- */
+/* Register: 'Three-colorMarker Constant Information Rate Mantissa Register' */
+/* (LTQ_GSWIP_3_0) */
+/* Bit: 'MANT' */
+/* Description: 'Rate Counter Mantissa' */
+#define GSW_PCE_TCM_CIR_MANT_MANT_OFFSET	0xE15
+#define GSW_PCE_TCM_CIR_MANT_MANT_SHIFT		0
+#define GSW_PCE_TCM_CIR_MANT_MANT_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'Three-colorMarker Constant Information Rate */
+/* Exponent Register' (LTQ_GSWIP_3_0)*/
+/* Bit: 'EXP' */
+/* Description: 'Rate Counter Exponent' */
+#define GSW_PCE_TCM_CIR_EXP_EXP_OFFSET	0xE16
+#define GSW_PCE_TCM_CIR_EXP_EXP_SHIFT		0
+#define GSW_PCE_TCM_CIR_EXP_EXP_SIZE		4
+/* --------------------------------------------------- */
+/* Register: 'Three-colorMarker Peak Information Rate */
+/* Mantissa Register'(LTQ_GSWIP_3_0) */
+/* Bit: 'MANT' */
+/* Description: 'Rate Counter Mantissa' */
+#define GSW_PCE_TCM_PIR_MANT_MANT_OFFSET	0xE17
+#define GSW_PCE_TCM_PIR_MANT_MANT_SHIFT		0
+#define GSW_PCE_TCM_PIR_MANT_MANT_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'Three-colorMarker Peak Information Rate */
+/* Exponent Register' (LTQ_GSWIP_3_0)*/
+/* Bit: 'EXP' */
+/* Description: 'Rate Counter Exponent' */
+#define GSW_PCE_TCM_PIR_EXP_EXP_OFFSET	0xE18
+#define GSW_PCE_TCM_PIR_EXP_EXP_SHIFT		0
+#define GSW_PCE_TCM_PIR_EXP_EXP_SIZE		4
+/* --------------------------------------------------- */
+/* Register: 'MAC Test Register' */
+/* Bit: 'JTP' */
+/* Description: 'Jitter Test Pattern' */
+#define MAC_TEST_JTP_OFFSET	0x8C0
+#define MAC_TEST_JTP_SHIFT	0
+#define MAC_TEST_JTP_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'MAC Pause FrameSource Address Configuration Register' */
+/* Bit: 'SAMOD' */
+/* Description: 'Source Address Mode' */
+#define MAC_PFAD_CFG_SAMOD_OFFSET	0x8C1
+#define MAC_PFAD_CFG_SAMOD_SHIFT	0
+#define MAC_PFAD_CFG_SAMOD_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Pause Frame SourceAddress Part 0 ' */
+/* Bit: 'PFAD' */
+/* Description: 'Pause Frame Source Address Part 0' */
+#define MAC_PFSA_0_PFAD_OFFSET	0x8C2
+#define MAC_PFSA_0_PFAD_SHIFT		0
+#define MAC_PFSA_0_PFAD_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Pause Frame SourceAddress Part 1 ' */
+/* Bit: 'PFAD' */
+/* Description: 'Pause Frame Source Address Part 1' */
+#define MAC_PFSA_1_PFAD_OFFSET	0x8C3
+#define MAC_PFSA_1_PFAD_SHIFT		0
+#define MAC_PFSA_1_PFAD_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Pause Frame SourceAddress Part 2 ' */
+/* Bit: 'PFAD' */
+/* Description: 'Pause Frame Source Address Part 2' */
+#define MAC_PFSA_2_PFAD_OFFSET	0x8C4
+#define MAC_PFSA_2_PFAD_SHIFT		0
+#define MAC_PFSA_2_PFAD_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'MAC Frame Length Register' */
+/* Bit: 'LEN' */
+/* Description: 'Maximum Frame Length' */
+#define MAC_FLEN_LEN_OFFSET	0x8C5
+#define MAC_FLEN_LEN_SHIFT	0
+#define MAC_FLEN_LEN_SIZE		14
+/* --------------------------------------------------- */
+/* Register: 'MAC VLAN EthertypeRegister 0' */
+/* Bit: 'OUTER' */
+/* Description: 'Ethertype' */
+#define MAC_VLAN_ETYPE_0_OUTER_OFFSET	0x8C6
+#define MAC_VLAN_ETYPE_0_OUTER_SHIFT	0
+#define MAC_VLAN_ETYPE_0_OUTER_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'MAC VLAN EthertypeRegister 1' */
+/* Bit: 'INNER' */
+/* Description: 'Ethertype' */
+#define MAC_VLAN_ETYPE_1_INNER_OFFSET	0x8C7
+#define MAC_VLAN_ETYPE_1_INNER_SHIFT	0
+#define MAC_VLAN_ETYPE_1_INNER_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'MAC Interrupt EnableRegister' */
+/* Bit: 'MACIEN' */
+/* Description: 'MAC Interrupt Enable' */
+#define MAC_IER_MACIEN_OFFSET	0x8C8
+#define MAC_IER_MACIEN_SHIFT	0
+#define MAC_IER_MACIEN_SIZE		13
+/* --------------------------------------------------- */
+/* Register: 'MAC Interrupt StatusRegister' */
+/* Bit: 'MACINT' */
+/* Description: 'MAC Interrupt' */
+#define MAC_ISR_MACINT_OFFSET	0x8C9
+#define MAC_ISR_MACINT_SHIFT	0
+#define MAC_ISR_MACINT_SIZE		13
+/* --------------------------------------------------- */
+/* Register: 'MAC Port Status Register' */
+/* Bit: 'PACT' */
+/* Description: 'PHY Active Status' */
+#define MAC_PSTAT_PACT_OFFSET	0x900
+#define MAC_PSTAT_PACT_SHIFT	11
+#define MAC_PSTAT_PACT_SIZE		1
+/* Bit: 'GBIT' */
+/* Description: 'Gigabit Speed Status' */
+#define MAC_PSTAT_GBIT_OFFSET	0x900
+#define MAC_PSTAT_GBIT_SHIFT	10
+#define MAC_PSTAT_GBIT_SIZE		1
+/* Bit: 'MBIT' */
+/* Description: 'Megabit Speed Status' */
+#define MAC_PSTAT_MBIT_OFFSET	0x900
+#define MAC_PSTAT_MBIT_SHIFT	9
+#define MAC_PSTAT_MBIT_SIZE		1
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Status' */
+#define MAC_PSTAT_FDUP_OFFSET	0x900
+#define MAC_PSTAT_FDUP_SHIFT	8
+#define MAC_PSTAT_FDUP_SIZE		1
+/* Bit: 'RXPAU' */
+/* Description: 'Receive Pause Status' */
+#define MAC_PSTAT_RXPAU_OFFSET	0x900
+#define MAC_PSTAT_RXPAU_SHIFT		7
+#define MAC_PSTAT_RXPAU_SIZE		1
+/* Bit: 'TXPAU' */
+/* Description: 'Transmit Pause Status' */
+#define MAC_PSTAT_TXPAU_OFFSET	0x900
+#define MAC_PSTAT_TXPAU_SHIFT		6
+#define MAC_PSTAT_TXPAU_SIZE		1
+/* Bit: 'RXPAUEN' */
+/* Description: 'Receive Pause Enable Status' */
+#define MAC_PSTAT_RXPAUEN_OFFSET	0x900
+#define MAC_PSTAT_RXPAUEN_SHIFT		5
+#define MAC_PSTAT_RXPAUEN_SIZE		1
+/* Bit: 'TXPAUEN' */
+/* Description: 'Transmit Pause Enable Status' */
+#define MAC_PSTAT_TXPAUEN_OFFSET	0x900
+#define MAC_PSTAT_TXPAUEN_SHIFT		4
+#define MAC_PSTAT_TXPAUEN_SIZE		1
+/* Bit: 'LSTAT' */
+/* Description: 'Link Status' */
+#define MAC_PSTAT_LSTAT_OFFSET	0x900
+#define MAC_PSTAT_LSTAT_SHIFT		3
+#define MAC_PSTAT_LSTAT_SIZE		1
+/* Bit: 'CRS' */
+/* Description: 'Carrier Sense Status' */
+#define MAC_PSTAT_CRS_OFFSET	0x900
+#define MAC_PSTAT_CRS_SHIFT		2
+#define MAC_PSTAT_CRS_SIZE		1
+/* Bit: 'TXLPI' */
+/* Description: 'Transmit Low-power Idle Status' */
+#define MAC_PSTAT_TXLPI_OFFSET	0x900
+#define MAC_PSTAT_TXLPI_SHIFT		1
+#define MAC_PSTAT_TXLPI_SIZE		1
+/* Bit: 'RXLPI' */
+/* Description: 'Receive Low-power Idle Status' */
+#define MAC_PSTAT_RXLPI_OFFSET	0x900
+#define MAC_PSTAT_RXLPI_SHIFT		0
+#define MAC_PSTAT_RXLPI_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'MAC Interrupt Status Register' */
+/* Bit: 'PHYERR' */
+/* Description: 'PHY Error Interrupt' */
+#define MAC_PISR_PHYERR_OFFSET	0x901
+#define MAC_PISR_PHYERR_SHIFT		15
+#define MAC_PISR_PHYERR_SIZE		1
+/* Bit: 'ALIGN' */
+/* Description: 'Allignment Error Interrupt' */
+#define MAC_PISR_ALIGN_OFFSET	0x901
+#define MAC_PISR_ALIGN_SHIFT	14
+#define MAC_PISR_ALIGN_SIZE		1
+/* Bit: 'PACT' */
+/* Description: 'PHY Active Status' */
+#define MAC_PISR_PACT_OFFSET	0x901
+#define MAC_PISR_PACT_SHIFT		13
+#define MAC_PISR_PACT_SIZE		1
+/* Bit: 'SPEED' */
+/* Description: 'Megabit Speed Status' */
+#define MAC_PISR_SPEED_OFFSET	0x901
+#define MAC_PISR_SPEED_SHIFT	12
+#define MAC_PISR_SPEED_SIZE		1
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Status' */
+#define MAC_PISR_FDUP_OFFSET	0x901
+#define MAC_PISR_FDUP_SHIFT		11
+#define MAC_PISR_FDUP_SIZE		1
+/* Bit: 'RXPAUEN' */
+/* Description: 'Receive Pause Enable Status' */
+#define MAC_PISR_RXPAUEN_OFFSET	0x901
+#define MAC_PISR_RXPAUEN_SHIFT	10
+#define MAC_PISR_RXPAUEN_SIZE		1
+/* Bit: 'TXPAUEN' */
+/* Description: 'Transmit Pause Enable Status' */
+#define MAC_PISR_TXPAUEN_OFFSET	0x901
+#define MAC_PISR_TXPAUEN_SHIFT	9
+#define MAC_PISR_TXPAUEN_SIZE		1
+/* Bit: 'LPIOFF' */
+/* Description: 'Receive Low-power Idle Mode is left' */
+#define MAC_PISR_LPIOFF_OFFSET	0x901
+#define MAC_PISR_LPIOFF_SHIFT		8
+#define MAC_PISR_LPIOFF_SIZE		1
+/* Bit: 'LPION' */
+/* Description: 'Receive Low-power Idle Mode is entered' */
+#define MAC_PISR_LPION_OFFSET	0x901
+#define MAC_PISR_LPION_SHIFT	7
+#define MAC_PISR_LPION_SIZE		1
+/* Bit: 'JAM' */
+/* Description: 'Jam Status Detected' */
+#define MAC_PISR_JAM_OFFSET	0x901
+#define MAC_PISR_JAM_SHIFT	6
+#define MAC_PISR_JAM_SIZE		1
+/* Bit: 'TOOSHORT' */
+/* Description: 'Too Short Frame Error Detected' */
+#define MAC_PISR_TOOSHORT_OFFSET	0x901
+#define MAC_PISR_TOOSHORT_SHIFT		5
+#define MAC_PISR_TOOSHORT_SIZE		1
+/* Bit: 'TOOLONG' */
+/* Description: 'Too Long Frame Error Detected' */
+#define MAC_PISR_TOOLONG_OFFSET	0x901
+#define MAC_PISR_TOOLONG_SHIFT	4
+#define MAC_PISR_TOOLONG_SIZE		1
+/* Bit: 'LENERR' */
+/* Description: 'Length Mismatch Error Detected' */
+#define MAC_PISR_LENERR_OFFSET	0x901
+#define MAC_PISR_LENERR_SHIFT		3
+#define MAC_PISR_LENERR_SIZE		1
+/* Bit: 'FCSERR' */
+/* Description: 'Frame Checksum Error Detected' */
+#define MAC_PISR_FCSERR_OFFSET	0x901
+#define MAC_PISR_FCSERR_SHIFT		2
+#define MAC_PISR_FCSERR_SIZE		1
+/* Bit: 'TXPAUSE' */
+/* Description: 'Pause Frame Transmitted' */
+#define MAC_PISR_TXPAUSE_OFFSET	0x901
+#define MAC_PISR_TXPAUSE_SHIFT	1
+#define MAC_PISR_TXPAUSE_SIZE		1
+/* Bit: 'RXPAUSE' */
+/* Description: 'Pause Frame Received' */
+#define MAC_PISR_RXPAUSE_OFFSET	0x901
+#define MAC_PISR_RXPAUSE_SHIFT	0
+#define MAC_PISR_RXPAUSE_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'MAC Interrupt Enable Register' */
+/* Bit: 'PHYERR' */
+/* Description: 'PHY Error Interrupt' */
+#define MAC_PIER_PHYERR_OFFSET	0x902
+#define MAC_PIER_PHYERR_SHIFT		15
+#define MAC_PIER_PHYERR_SIZE		1
+/* Bit: 'ALIGN' */
+/* Description: 'Allignment Error Interrupt' */
+#define MAC_PIER_ALIGN_OFFSET	0x902
+#define MAC_PIER_ALIGN_SHIFT	14
+#define MAC_PIER_ALIGN_SIZE		1
+/* Bit: 'PACT' */
+/* Description: 'PHY Active Status' */
+#define MAC_PIER_PACT_OFFSET	0x902
+#define MAC_PIER_PACT_SHIFT		13
+#define MAC_PIER_PACT_SIZE		1
+/* Bit: 'SPEED' */
+/* Description: 'Megabit Speed Status' */
+#define MAC_PIER_SPEED_OFFSET	0x902
+#define MAC_PIER_SPEED_SHIFT	12
+#define MAC_PIER_SPEED_SIZE		1
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Status' */
+#define MAC_PIER_FDUP_OFFSET	0x902
+#define MAC_PIER_FDUP_SHIFT		11
+#define MAC_PIER_FDUP_SIZE		1
+/* Bit: 'RXPAUEN' */
+/* Description: 'Receive Pause Enable Status' */
+#define MAC_PIER_RXPAUEN_OFFSET	0x902
+#define MAC_PIER_RXPAUEN_SHIFT	10
+#define MAC_PIER_RXPAUEN_SIZE		1
+/* Bit: 'TXPAUEN' */
+/* Description: 'Transmit Pause Enable Status' */
+#define MAC_PIER_TXPAUEN_OFFSET	0x902
+#define MAC_PIER_TXPAUEN_SHIFT	9
+#define MAC_PIER_TXPAUEN_SIZE		1
+/* Bit: 'LPIOFF' */
+/* Description: 'Low-power Idle Off Interrupt Mask' */
+#define MAC_PIER_LPIOFF_OFFSET	0x902
+#define MAC_PIER_LPIOFF_SHIFT		8
+#define MAC_PIER_LPIOFF_SIZE		1
+/* Bit: 'LPION' */
+/* Description: 'Low-power Idle On Interrupt Mask' */
+#define MAC_PIER_LPION_OFFSET	0x902
+#define MAC_PIER_LPION_SHIFT	7
+#define MAC_PIER_LPION_SIZE		1
+/* Bit: 'JAM' */
+/* Description: 'Jam Status Interrupt Mask' */
+#define MAC_PIER_JAM_OFFSET	0x902
+#define MAC_PIER_JAM_SHIFT	6
+#define MAC_PIER_JAM_SIZE		1
+/* Bit: 'TOOSHORT' */
+/* Description: 'Too Short Frame Error Interrupt Mask' */
+#define MAC_PIER_TOOSHORT_OFFSET	0x902
+#define MAC_PIER_TOOSHORT_SHIFT		5
+#define MAC_PIER_TOOSHORT_SIZE		1
+/* Bit: 'TOOLONG' */
+/* Description: 'Too Long Frame Error Interrupt Mask' */
+#define MAC_PIER_TOOLONG_OFFSET	0x902
+#define MAC_PIER_TOOLONG_SHIFT	4
+#define MAC_PIER_TOOLONG_SIZE		1
+/* Bit: 'LENERR' */
+/* Description: 'Length Mismatch Error Interrupt Mask' */
+#define MAC_PIER_LENERR_OFFSET	0x902
+#define MAC_PIER_LENERR_SHIFT		3
+#define MAC_PIER_LENERR_SIZE		1
+/* Bit: 'FCSERR' */
+/* Description: 'Frame Checksum Error Interrupt Mask' */
+#define MAC_PIER_FCSERR_OFFSET	0x902
+#define MAC_PIER_FCSERR_SHIFT		2
+#define MAC_PIER_FCSERR_SIZE		1
+/* Bit: 'TXPAUSE' */
+/* Description: 'Transmit Pause Frame Interrupt Mask' */
+#define MAC_PIER_TXPAUSE_OFFSET	0x902
+#define MAC_PIER_TXPAUSE_SHIFT	1
+#define MAC_PIER_TXPAUSE_SIZE		1
+/* Bit: 'RXPAUSE' */
+/* Description: 'Receive Pause Frame Interrupt Mask' */
+#define MAC_PIER_RXPAUSE_OFFSET	0x902
+#define MAC_PIER_RXPAUSE_SHIFT	0
+#define MAC_PIER_RXPAUSE_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'MAC Control Register0' */
+/* Bit: 'BM' */
+/* Description: 'Burst Mode Control' */
+#define MAC_CTRL_0_BM_OFFSET	0x903
+#define MAC_CTRL_0_BM_SHIFT		12
+#define MAC_CTRL_0_BM_SIZE		1
+/* Bit: 'APADEN' */
+/* Description: 'Automatic VLAN Padding Enable' */
+#define MAC_CTRL_0_APADEN_OFFSET	0x903
+#define MAC_CTRL_0_APADEN_SHIFT		11
+#define MAC_CTRL_0_APADEN_SIZE		1
+/* Bit: 'VPAD2EN' */
+/* Description: 'Stacked VLAN Padding Enable' */
+#define MAC_CTRL_0_VPAD2EN_OFFSET	0x903
+#define MAC_CTRL_0_VPAD2EN_SHIFT	10
+#define MAC_CTRL_0_VPAD2EN_SIZE		1
+/* Bit: 'VPADEN' */
+/* Description: 'VLAN Padding Enable' */
+#define MAC_CTRL_0_VPADEN_OFFSET	0x903
+#define MAC_CTRL_0_VPADEN_SHIFT		9
+#define MAC_CTRL_0_VPADEN_SIZE		1
+/* Bit: 'PADEN' */
+/* Description: 'Padding Enable' */
+#define MAC_CTRL_0_PADEN_OFFSET	0x903
+#define MAC_CTRL_0_PADEN_SHIFT	8
+#define MAC_CTRL_0_PADEN_SIZE		1
+/* Bit: 'FCS' */
+/* Description: 'Transmit FCS Control' */
+#define MAC_CTRL_0_FCS_OFFSET	0x903
+#define MAC_CTRL_0_FCS_SHIFT	7
+#define MAC_CTRL_0_FCS_SIZE		1
+/* Bit: 'FCON' */
+/* Description: 'Flow Control Mode' */
+#define MAC_CTRL_0_FCON_OFFSET	0x903
+#define MAC_CTRL_0_FCON_SHIFT		4
+#define MAC_CTRL_0_FCON_SIZE		3
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Control' */
+#define MAC_CTRL_0_FDUP_OFFSET	0x903
+#define MAC_CTRL_0_FDUP_SHIFT		2
+#define MAC_CTRL_0_FDUP_SIZE		2
+/* Bit: 'GMII' */
+/* Description: 'GMII/MII interface mode selection' */
+#define MAC_CTRL_0_GMII_OFFSET	0x903
+#define MAC_CTRL_0_GMII_SHIFT		0
+#define MAC_CTRL_0_GMII_SIZE		2
+/* --------------------------------------------------- */
+/* Register: 'MAC Control Register1' */
+/* Bit: 'DEFERMODE' */
+/* Description: 'Defer Model' */
+#define MAC_CTRL_1_DEFERMODE_OFFSET	0x904
+#define MAC_CTRL_1_DEFERMODE_SHIFT	15
+#define MAC_CTRL_1_DEFERMODE_SIZE		1
+/* Bit: 'SHORTPRE' */
+/* Description: 'Short Preamble Control' */
+#define MAC_CTRL_1_SHORTPRE_OFFSET	0x904
+#define MAC_CTRL_1_SHORTPRE_SHIFT		8
+#define MAC_CTRL_1_SHORTPRE_SIZE		1
+/* Bit: 'IPG' */
+/* Description: 'Minimum Inter Packet Gap Size' */
+#define MAC_CTRL_1_IPG_OFFSET	0x904
+#define MAC_CTRL_1_IPG_SHIFT	0
+#define MAC_CTRL_1_IPG_SIZE		4
+/* --------------------------------------------------- */
+/* Register: 'MAC Control Register2' */
+/* Bit: 'MLEN' */
+/* Description: 'Maximum Untagged Frame Length' */
+#define MAC_CTRL_2_MLEN_OFFSET	0x905
+#define MAC_CTRL_2_MLEN_SHIFT		3
+#define MAC_CTRL_2_MLEN_SIZE		1
+/* Bit: 'LCHKL' */
+/* Description: 'Frame Length Check Long Enable' */
+#define MAC_CTRL_2_LCHKL_OFFSET	0x905
+#define MAC_CTRL_2_LCHKL_SHIFT	2
+#define MAC_CTRL_2_LCHKL_SIZE		1
+/* Bit: 'LCHKS' */
+/* Description: 'Frame Length Check Short Enable' */
+#define MAC_CTRL_2_LCHKS_OFFSET	0x905
+#define MAC_CTRL_2_LCHKS_SHIFT	0
+#define MAC_CTRL_2_LCHKS_SIZE		2
+/* --------------------------------------------------- */
+/* Register: 'MAC Control Register3' */
+/* Bit: 'RCNT' */
+/* Description: 'Retry Count' */
+#define MAC_CTRL_3_RCNT_OFFSET	0x906
+#define MAC_CTRL_3_RCNT_SHIFT		0
+#define MAC_CTRL_3_RCNT_SIZE		4
+/* --------------------------------------------------- */
+/* Register: 'MAC Control Register4' */
+/* Bit: 'GWAIT' */
+/* Description: 'LPI Wait Time for 1G' */
+#define MAC_CTRL_4_GWAIT_OFFSET	0x907
+#define MAC_CTRL_4_GWAIT_SHIFT	8
+#define MAC_CTRL_4_GWAIT_SIZE		7
+/* Bit: 'LPIEN' */
+/* Description: 'LPI Mode Enable' */
+#define MAC_CTRL_4_LPIEN_OFFSET	0x907
+#define MAC_CTRL_4_LPIEN_SHIFT	7
+#define MAC_CTRL_4_LPIEN_SIZE		1
+/* Bit: 'WAIT' */
+/* Description: 'LPI Wait Time for 100M' */
+#define MAC_CTRL_4_WAIT_OFFSET	0x907
+#define MAC_CTRL_4_WAIT_SHIFT		0
+#define MAC_CTRL_4_WAIT_SIZE		7
+/* --------------------------------------------------- */
+/* Register: 'MAC Control Register5' */
+/* Bit: 'PJPS_NOBP' */
+/* Description: 'Prolonged Jam pattern size during no-backpressure */
+/* state' */
+#define MAC_CTRL_5_PJPS_NOBP_OFFSET	0x908
+#define MAC_CTRL_5_PJPS_NOBP_SHIFT	1
+#define MAC_CTRL_5_PJPS_NOBP_SIZE		1
+/* Bit: 'PJPS_BP' */
+/* Description: 'Prolonged Jam pattern size during backpressure state' */
+#define MAC_CTRL_5_PJPS_BP_OFFSET	0x908
+#define MAC_CTRL_5_PJPS_BP_SHIFT	0
+#define MAC_CTRL_5_PJPS_BP_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'MAC LPI Timer Register 0' */
+/* Bit: 'TMLSB' */
+/* Description: 'MAC LPI Timer LSB' */
+#define MAC_LPITMER0_TMLSB_OFFSET	0x909
+#define MAC_LPITMER0_TMLSB_SHIFT	0
+#define MAC_LPITMER0_TMLSB_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'MAC LPI Timer Register 1' */
+/* Bit: 'TMMSB' */
+/* Description: 'MAC LPI Timer MSB' */
+#define MAC_LPITMER1_TMMSB_OFFSET	0x90A
+#define MAC_LPITMER1_TMMSB_SHIFT	0
+#define MAC_LPITMER1_TMMSB_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'MAC Test Enable Register' */
+/* Bit: 'LPITM' */
+/* Description: 'LPI Monitoring Mode' */
+#define MAC_TESTEN_LPITM_OFFSET	0x90B
+#define MAC_TESTEN_LPITM_SHIFT	8
+#define MAC_TESTEN_LPITM_SIZE		2
+/* Bit: 'JTEN' */
+/* Description: 'Jitter Test Enable' */
+#define MAC_TESTEN_JTEN_OFFSET	0x90B
+#define MAC_TESTEN_JTEN_SHIFT		2
+#define MAC_TESTEN_JTEN_SIZE		1
+/* Bit: 'TXER' */
+/* Description: 'Transmit Error Insertion' */
+#define MAC_TESTEN_TXER_OFFSET	0x90B
+#define MAC_TESTEN_TXER_SHIFT		1
+#define MAC_TESTEN_TXER_SIZE		1
+/* Bit: 'LOOP' */
+/* Description: 'MAC Loopback Enable' */
+#define MAC_TESTEN_LOOP_OFFSET	0x90B
+#define MAC_TESTEN_LOOP_SHIFT		0
+#define MAC_TESTEN_LOOP_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Ethernet Switch FetchDMA Control Register' (LTQ_GSWIP_2_2_ETC)*/
+/* Bit: 'RMMD' */
+/* Description: 'Remarking Mode' */
+#define FDMA_CTRL_RMMD_OFFSET	0xA40
+#define FDMA_CTRL_RMMD_SHIFT	8
+#define FDMA_CTRL_RMMD_SIZE		1
+/* Bit: 'EGCNT' */
+/* Description: 'Egress Special Tag RMON count' */
+#define FDMA_CTRL_EGCNT_OFFSET	0xA40
+#define FDMA_CTRL_EGCNT_SHIFT		7
+#define FDMA_CTRL_EGCNT_SIZE		1
+/* Bit: 'LPI_MODE' */
+/* Description: 'Low Power Idle Mode' */
+#define FDMA_CTRL_LPI_MODE_OFFSET	0xA40
+#define FDMA_CTRL_LPI_MODE_SHIFT	4
+#define FDMA_CTRL_LPI_MODE_SIZE		3
+/* Bit: 'EGSTAG' */
+/* Description: 'Egress Special Tag Size' */
+#define FDMA_CTRL_EGSTAG_OFFSET	0xA40
+#define FDMA_CTRL_EGSTAG_SHIFT	2
+#define FDMA_CTRL_EGSTAG_SIZE		2
+/* Bit: 'IGSTAG' */
+/* Description: 'Ingress Special Tag Size' */
+#define FDMA_CTRL_IGSTAG_OFFSET	0xA40
+#define FDMA_CTRL_IGSTAG_SHIFT	1
+#define FDMA_CTRL_IGSTAG_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Special Tag EthertypeControl Register' */
+/* Bit: 'ETYPE' */
+/* Description: 'Special Tag Ethertype' */
+#define FDMA_STETYPE_ETYPE_OFFSET	0xA41
+#define FDMA_STETYPE_ETYPE_SHIFT	0
+#define FDMA_STETYPE_ETYPE_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'VLAN Tag EthertypeControl Register' */
+/* Bit: 'ETYPE' */
+/* Description: 'VLAN Tag Ethertype' */
+#define FDMA_VTETYPE_ETYPE_OFFSET	0xA42
+#define FDMA_VTETYPE_ETYPE_SHIFT	0
+#define FDMA_VTETYPE_ETYPE_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'FDMA Status Register0' */
+/* Bit: 'FSMS' */
+/* Description: 'FSM states status' */
+#define FDMA_STAT_0_FSMS_OFFSET	0xA43
+#define FDMA_STAT_0_FSMS_SHIFT	0
+#define FDMA_STAT_0_FSMS_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Fetch DMA Global InterruptEnable Register' */
+/* Bit: 'PCKD' */
+/* Description: 'Packet Drop Interrupt Enable' */
+#define FDMA_IER_PCKD_OFFSET	0xA44
+#define FDMA_IER_PCKD_SHIFT		14
+#define FDMA_IER_PCKD_SIZE		1
+/* Bit: 'PCKR' */
+/* Description: 'Packet Ready Interrupt Enable' */
+#define FDMA_IER_PCKR_OFFSET	0xA44
+#define FDMA_IER_PCKR_SHIFT		13
+#define FDMA_IER_PCKR_SIZE		1
+/* Bit: 'PCKT' */
+/* Description: 'Packet Sent Interrupt Enable' */
+#define FDMA_IER_PCKT_OFFSET	0xA44
+#define FDMA_IER_PCKT_SHIFT		0
+#define FDMA_IER_PCKT_SIZE		13
+/* --------------------------------------------------- */
+/* Register: 'Fetch DMA Global InterruptStatus Register' */
+/* Bit: 'PCKTD' */
+/* Description: 'Packet Drop' */
+#define FDMA_ISR_PCKTD_OFFSET	0xA45
+#define FDMA_ISR_PCKTD_SHIFT	14
+#define FDMA_ISR_PCKTD_SIZE		1
+/* Bit: 'PCKR' */
+/* Description: 'Packet is Ready for Transmission' */
+#define FDMA_ISR_PCKR_OFFSET	0xA45
+#define FDMA_ISR_PCKR_SHIFT		13
+#define FDMA_ISR_PCKR_SIZE		1
+/* Bit: 'PCKT' */
+/* Description: 'Packet Sent Event' */
+#define FDMA_ISR_PCKT_OFFSET	0xA45
+#define FDMA_ISR_PCKT_SHIFT		0
+#define FDMA_ISR_PCKT_SIZE		13
+/* --------------------------------------------------- */
+/* Register: 'Service VLAN Tag Ethertype Control Register' */
+/* (LTQ_GSWIP_2_2_ETC)*/
+/* Bit: 'ETYPE' */
+/* Description: 'A VLAN tag can be inserted into egress frames, */
+/* identified by this Ethertype value.' */
+#define FDMA_SVTETYPE_OFFSET			0xA46
+#define FDMA_SVTETYPE_ETYPE_SHIFT	0
+#define FDMA_SVTETYPE_ETYPE_SIZE	16
+/* --------------------------------------------------- */
+/* Register: 'Fetch DMA Parsing Result Control Register' (LTQ_GSWIP_3_0)*/
+/* Bit: 'MPE3' */
+/* Description: 'Parsing Results to CPU Port MPE3.' */
+#define FDMA_PASR_MPE3_OFFSET	0xA47
+#define FDMA_PASR_MPE3_SHIFT	6
+#define FDMA_PASR_MPE3_SIZE		2
+/* Bit: 'MPE2' */
+/* Description: 'Parsing Results to CPU Port MPE2.' */
+#define FDMA_PASR_MPE2_OFFSET	0xA47
+#define FDMA_PASR_MPE2_SHIFT	4
+#define FDMA_PASR_MPE2_SIZE		2
+/* Bit: 'MPE1' */
+/* Description: 'Parsing Results to CPU Port MPE1.' */
+#define FDMA_PASR_MPE1_OFFSET	0xA47
+#define FDMA_PASR_MPE1_SHIFT	2
+#define FDMA_PASR_MPE1_SIZE		2
+/* Bit: 'CPU' */
+/* Description: 'Parsing Results to CPU Port.' */
+#define FDMA_PASR_CPU_OFFSET	0xA47
+#define FDMA_PASR_CPU_SHIFT		0
+#define FDMA_PASR_CPU_SIZE		2
+/* --------------------------------------------------- */
+/* Register:'Fetch DMA Global Interrupt Enable Register 1'(LTQ_GSWIP_3_0)*/
+/* Bit: 'PCKD' */
+/* Description: 'Packet Drop Interrupt Enable.' */
+#define FDMA_IER_1_PCKD_OFFSET	0xA48
+#define FDMA_IER_1_PCKD_SHIFT		14
+#define FDMA_IER_1_PCKD_SIZE		1
+/* Bit: 'PCKR' */
+/* Description: 'Packet Ready Interrupt Enable.' */
+#define FDMA_IER_1_PCKR_OFFSET	0xA48
+#define FDMA_IER_1_PCKR_SHIFT		13
+#define FDMA_IER_1_PCKR_SIZE		1
+/* --------------------------------------------------- */
+/* Register:'Fetch DMA Global Interrupt Status Register 1'(LTQ_GSWIP_3_0)*/
+/* Bit: 'PCKTD' */
+/* Description: 'Packet Drop.' */
+#define FDMA_ISR_1_PCKTD_OFFSET	0xA49
+#define FDMA_ISR_1_PCKTD_SHIFT	14
+#define FDMA_ISR_1_PCKTD_SIZE		1
+/* Bit: 'PCKR' */
+/* Description: 'Packet is Ready for Transmission.' */
+#define FDMA_ISR_1_PCKR_OFFSET	0xA49
+#define FDMA_ISR_1_PCKR_SHIFT		13
+#define FDMA_ISR_1_PCKR_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Ethernet SwitchFetch DMA Port Control Register' */
+/* Bit: 'DEIMOD' */
+/* Description: 'Controls DEI remarking mode.' */
+#define FDMA_PCTRL_DEIMOD_OFFSET	0xA80
+#define FDMA_PCTRL_DEIMOD_SHIFT		9
+#define FDMA_PCTRL_DEIMOD_SIZE		1
+/* Bit: 'SFDSTB' */
+/* Description: 'Controls selection of SFD strobe for time stamp capture..' */
+#define FDMA_PCTRL_SFDSTB_OFFSET	0xA80
+#define FDMA_PCTRL_SFDSTB_SHIFT		8
+#define FDMA_PCTRL_SFDSTB_SIZE		1
+/* Bit: 'SVLANMOD' */
+/* Description: 'Controls the VLAN tag modification function on egress.' */
+#define FDMA_PCTRL_SVLANMOD_OFFSET	0xA80
+#define FDMA_PCTRL_SVLANMOD_SHIFT		6
+#define FDMA_PCTRL_SVLANMOD_SIZE		2
+/* Bit: 'ST_TYPE' */
+/* Description: 'Special Tag Ethertype Mode' */
+#define FDMA_PCTRL_ST_TYPE_OFFSET	0xA80
+#define FDMA_PCTRL_ST_TYPE_SHIFT	5
+#define FDMA_PCTRL_ST_TYPE_SIZE		1
+/* Bit: 'VLANMOD' */
+/* Description: 'VLAN Modification Control' */
+#define FDMA_PCTRL_VLANMOD_OFFSET	0xA80
+#define FDMA_PCTRL_VLANMOD_SHIFT	3
+#define FDMA_PCTRL_VLANMOD_SIZE		2
+/*VLANMOD_SIZE is reduced to 1 in GSWIP 3.1*/
+#define FDMA_GSWIP3_1_PCTRL_VLANMOD_SIZE 1
+/* Bit: 'DSCPRM' */
+/* Description: 'DSCP Re-marking Enable' */
+#define FDMA_PCTRL_DSCPRM_OFFSET	0xA80
+#define FDMA_PCTRL_DSCPRM_SHIFT		2
+#define FDMA_PCTRL_DSCPRM_SIZE		1
+/* Bit: 'STEN' */
+/* Description: 'Special Tag Insertion Enable' */
+#define FDMA_PCTRL_STEN_OFFSET	0xA80
+#define FDMA_PCTRL_STEN_SHIFT		1
+#define FDMA_PCTRL_STEN_SIZE		1
+/* Bit: 'EN' */
+/* Description: 'FDMA Port Enable' */
+#define FDMA_PCTRL_EN_OFFSET	0xA80
+#define FDMA_PCTRL_EN_SHIFT		0
+#define FDMA_PCTRL_EN_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Ethernet SwitchFetch DMA Port Priority Register' */
+/* Bit: 'PRIO' */
+/* Description: 'FDMA PRIO' */
+#define FDMA_PRIO_PRIO_OFFSET	0xA81
+#define FDMA_PRIO_PRIO_SHIFT	0
+#define FDMA_PRIO_PRIO_SIZE		2
+/* --------------------------------------------------- */
+/* Register: 'Ethernet SwitchFetch DMA Port Status Register 0' */
+/* Bit: 'PKT_AVAIL' */
+/* Description: 'Port Egress Packet Available' */
+#define FDMA_PSTAT0_PKT_AVAIL_OFFSET	0xA82
+#define FDMA_PSTAT0_PKT_AVAIL_SHIFT		15
+#define FDMA_PSTAT0_PKT_AVAIL_SIZE		1
+/* Bit: 'POK' */
+/* Description: 'Port Status OK' */
+#define FDMA_PSTAT0_POK_OFFSET	0xA82
+#define FDMA_PSTAT0_POK_SHIFT		14
+#define FDMA_PSTAT0_POK_SIZE		1
+/* Bit: 'PSEG' */
+/* Description: 'Port Egress Segment Count' */
+#define FDMA_PSTAT0_PSEG_OFFSET	0xA82
+#define FDMA_PSTAT0_PSEG_SHIFT	0
+#define FDMA_PSTAT0_PSEG_SIZE		6
+/* --------------------------------------------------- */
+/* Register: 'Ethernet SwitchFetch DMA Port Status Register 1' */
+/* Bit: 'HDR_PTR' */
+/* Description: 'Header Pointer' */
+#define FDMA_PSTAT1_HDR_PTR_OFFSET	0xA83
+#define FDMA_PSTAT1_HDR_PTR_SHIFT		0
+#define FDMA_PSTAT1_HDR_PTR_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'Egress TimeStamp Register 0' */
+/* Bit: 'TSTL' */
+/* Description: 'Time Stamp [15:0]' */
+#define FDMA_TSTAMP0_TSTL_OFFSET	0xA84
+#define FDMA_TSTAMP0_TSTL_SHIFT		0
+#define FDMA_TSTAMP0_TSTL_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Egress TimeStamp Register 1' */
+/* Bit: 'TSTH' */
+/* Description: 'Time Stamp [31:16]' */
+#define FDMA_TSTAMP1_TSTH_OFFSET	0xA85
+#define FDMA_TSTAMP1_TSTH_SHIFT		0
+#define FDMA_TSTAMP1_TSTH_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Ethernet Switch StoreDMA Control Register' */
+/* Bit: 'RMON_ALIGN' */
+/* Description: 'MUX to select what to count on align error rmon */
+/* counter' */
+#define SDMA_CTRL_RMON_ALIGN_OFFSET	0xB40
+#define SDMA_CTRL_RMON_ALIGN_SHIFT	2
+#define SDMA_CTRL_RMON_ALIGN_SIZE		2
+/* Bit: 'ARBIT' */
+/* Description: 'SIMPLE ARBITER FOR PARSER FILLING' */
+#define SDMA_CTRL_ARBIT_OFFSET	0xB40
+#define SDMA_CTRL_ARBIT_SHIFT		1
+#define SDMA_CTRL_ARBIT_SIZE		1
+/* Bit: 'TSTEN' */
+/* Description: 'Time Stamp Enable' */
+#define SDMA_CTRL_TSTEN_OFFSET	0xB40
+#define SDMA_CTRL_TSTEN_SHIFT		0
+#define SDMA_CTRL_TSTEN_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'SDMA Flow Control Threshold1 Register' */
+/* Bit: 'THR1' */
+/* Description: 'Threshold 1' */
+#define SDMA_FCTHR1_THR1_OFFSET	0xB41
+#define SDMA_FCTHR1_THR1_SHIFT	0
+#define SDMA_FCTHR1_THR1_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'SDMA Flow Control Threshold2 Register' */
+/* Bit: 'THR2' */
+/* Description: 'Threshold 2' */
+#define SDMA_FCTHR2_THR2_OFFSET	0xB42
+#define SDMA_FCTHR2_THR2_SHIFT	0
+#define SDMA_FCTHR2_THR2_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'SDMA Flow Control Threshold3 Register' */
+/* Bit: 'THR3' */
+/* Description: 'Threshold 3' */
+#define SDMA_FCTHR3_THR3_OFFSET	0xB43
+#define SDMA_FCTHR3_THR3_SHIFT	0
+#define SDMA_FCTHR3_THR3_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'SDMA Flow Control Threshold4 Register' */
+/* Bit: 'THR4' */
+/* Description: 'Threshold 4' */
+#define SDMA_FCTHR4_THR4_OFFSET	0xB44
+#define SDMA_FCTHR4_THR4_SHIFT	0
+#define SDMA_FCTHR4_THR4_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'SDMA Flow Control Threshold5 Register' */
+/* Bit: 'THR5' */
+/* Description: 'Threshold 5' */
+#define SDMA_FCTHR5_THR5_OFFSET	0xB45
+#define SDMA_FCTHR5_THR5_SHIFT	0
+#define SDMA_FCTHR5_THR5_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'SDMA Flow Control Threshold6 Register' */
+/* Bit: 'THR6' */
+/* Description: 'Threshold 6' */
+#define SDMA_FCTHR6_THR6_OFFSET	0xB46
+#define SDMA_FCTHR6_THR6_SHIFT	0
+#define SDMA_FCTHR6_THR6_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'SDMA Flow Control Threshold7 Register' */
+/* Bit: 'THR7' */
+/* Description: 'Threshold 7' */
+#define SDMA_FCTHR7_THR7_OFFSET	0xB47
+#define SDMA_FCTHR7_THR7_SHIFT	0
+#define SDMA_FCTHR7_THR7_SIZE		11
+/* --------------------------------------------------- */
+/* Register: 'SDMA Status Register0' */
+/* Bit: 'BPS_FILL' */
+/* Description: 'Back Pressure Status' */
+#define SDMA_STAT_0_BPS_FILL_OFFSET	0xB48
+#define SDMA_STAT_0_BPS_FILL_SHIFT	4
+#define SDMA_STAT_0_BPS_FILL_SIZE		3
+/* Bit: 'BPS_PNT' */
+/* Description: 'Back Pressure Status' */
+#define SDMA_STAT_0_BPS_PNT_OFFSET	0xB48
+#define SDMA_STAT_0_BPS_PNT_SHIFT	2
+#define SDMA_STAT_0_BPS_PNT_SIZE	2
+/* Bit: 'DROP' */
+/* Description: 'Back Pressure Status' */
+#define SDMA_STAT_0_DROP_OFFSET	0xB48
+#define SDMA_STAT_0_DROP_SHIFT	0
+#define SDMA_STAT_0_DROP_SIZE		2
+/* --------------------------------------------------- */
+/* Register: 'SDMA Status Register1' */
+/* Bit: 'FILL' */
+/* Description: 'Buffer Filling Level' */
+#define SDMA_STAT_1_FILL_OFFSET	0xB49
+#define SDMA_STAT_1_FILL_SHIFT	0
+#define SDMA_STAT_1_FILL_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'SDMA Status Register2' */
+/* Bit: 'FSMS' */
+/* Description: 'FSM states status' */
+#define SDMA_STAT_2_FSMS_OFFSET	0xB4A
+#define SDMA_STAT_2_FSMS_SHIFT	0
+#define SDMA_STAT_2_FSMS_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'SDMA Interrupt Enable Register' */
+/* Bit: 'BPEX' */
+/* Description: 'Buffer Pointers Exceeded' */
+#define SDMA_IER_BPEX_OFFSET	0xB4B
+#define SDMA_IER_BPEX_SHIFT		15
+#define SDMA_IER_BPEX_SIZE		1
+/* Bit: 'BFULL' */
+/* Description: 'Buffer Full' */
+#define SDMA_IER_BFULL_OFFSET	0xB4B
+#define SDMA_IER_BFULL_SHIFT	14
+#define SDMA_IER_BFULL_SIZE		1
+/* Bit: 'FERR' */
+/* Description: 'Frame Error' */
+#define SDMA_IER_FERR_OFFSET	0xB4B
+#define SDMA_IER_FERR_SHIFT		13
+#define SDMA_IER_FERR_SIZE		1
+/* Bit: 'FRX' */
+/* Description: 'Frame Received Successfully' */
+#define SDMA_IER_FRX_OFFSET		0xB4B
+#define SDMA_IER_FRX_SHIFT		0
+#define SDMA_IER_FRX_SIZE			13
+/* --------------------------------------------------- */
+/* Register: 'SDMA Interrupt Status Register' */
+/* Bit: 'BPEX' */
+/* Description: 'Packet Descriptors Exceeded' */
+#define SDMA_ISR_BPEX_OFFSET	0xB4C
+#define SDMA_ISR_BPEX_SHIFT		15
+#define SDMA_ISR_BPEX_SIZE		1
+/* Bit: 'BFULL' */
+/* Description: 'Buffer Full' */
+#define SDMA_ISR_BFULL_OFFSET	0xB4C
+#define SDMA_ISR_BFULL_SHIFT	14
+#define SDMA_ISR_BFULL_SIZE		1
+/* Bit: 'FERR' */
+/* Description: 'Frame Error' */
+#define SDMA_ISR_FERR_OFFSET	0xB4C
+#define SDMA_ISR_FERR_SHIFT		13
+#define SDMA_ISR_FERR_SIZE		1
+/* Bit: 'FRX' */
+/* Description: 'Frame Received Successfully' */
+#define SDMA_ISR_FRX_OFFSET	0xB4C
+#define SDMA_ISR_FRX_SHIFT	0
+#define SDMA_ISR_FRX_SIZE		13
+/* --------------------------------------------------- */
+/* Register: 'SDMA Interrupt Enable Register 1' (LTQ_GSWIP_2_2) */
+/* Bit: 'CGNBP' */
+/* Description: 'Ingress Port Congestion Based Back Pressure Status Change' */
+#define SDMA_IER_1_CGNBP_OFFSET	0xB4D
+#define SDMA_IER_1_CGNBP_SHIFT	0
+#define SDMA_IER_1_CGNBP_SIZE		13
+/* --------------------------------------------------- */
+/* Register: 'SDMA Interrupt Enable Register 1' (LTQ_GSWIP_2_2)*/
+/* Bit: 'CGNBP' */
+/* Description: 'Ingress Port Congested Based Backpressure Status Change' */
+#define SDMA_ISR_1_CGNBP_OFFSET	0xB4E
+#define SDMA_ISR_1_CGNBP_SHIFT	0
+#define SDMA_ISR_1_CGNBP_SIZE		13
+/* --------------------------------------------------- */
+/* Register: 'SDMA Congestion Backpressure Status Register' (LTQ_GSWIP_2_2)*/
+/* Bit: 'CGNBP' */
+/* Description: 'Ingress Port Congestion Based Back Pressure Status' */
+#define SDMA_CGNBP_CGNBP_OFFSET	0xB4F
+#define SDMA_CGNBP_CGNBP_SHIFT	0
+#define SDMA_CGNBP_CGNBP_SIZE		13
+/* --------------------------------------------------- */
+/* Register: 'SDMA Interrupt Enable Register 2' (LTQ_GSWIP_3_0)*/
+/* Bit: 'BPEX' */
+/* Description: 'Buffer Pointers Exceeded' */
+#define SDMA_IER_2_BPEX_OFFSET	0xB50
+#define SDMA_IER_2_BPEX_SHIFT		15
+#define SDMA_IER_2_BPEX_SIZE		1
+/* Bit: 'BFULL' */
+/* Description: 'Buffer Full' */
+#define SDMA_IER_2_BFULL_OFFSET	0xB50
+#define SDMA_IER_2_BFULL_SHIFT	14
+#define SDMA_IER_2_BFULL_SIZE		1
+/* Bit: 'FERR' */
+/* Description: 'Frame Error' */
+#define SDMA_IER_2_FERR_OFFSET	0xB50
+#define SDMA_IER_2_FERR_SHIFT		13
+#define SDMA_IER_2_FERR_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'SDMA Interrupt Status Register 2' (LTQ_GSWIP_3_0)*/
+/* Bit: 'BPEX' */
+/* Description: 'Packet Descriptors Exceeded' */
+#define SDMA_ISR_2_BPEX_OFFSET	0xB51
+#define SDMA_ISR_2_BPEX_SHIFT		15
+#define SDMA_ISR_2_BPEX_SIZE		1
+/* Bit: 'BFULL' */
+/* Description: 'Buffer Full' */
+#define SDMA_ISR_2_BFULL_OFFSET	0xB51
+#define SDMA_ISR_2_BFULL_SHIFT	14
+#define SDMA_ISR_2_BFULL_SIZE		1
+/* Bit: 'FERR' */
+/* Description: 'Frame Error' */
+#define SDMA_ISR_2_FERR_OFFSET	0xB51
+#define SDMA_ISR_2_FERR_SHIFT		13
+#define SDMA_ISR_2_FERR_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Ethernet SwitchStore DMA Port Control Register'(LTQ_GSWIP_2_2) */
+/* Bit: 'SFDSTB' */
+/* Description: 'Drop Threshold Selection' */
+#define SDMA_PCTRL_SFDSTB_OFFSET	0xBC0
+#define SDMA_PCTRL_SFDSTB_SHIFT		15
+#define SDMA_PCTRL_SFDSTB_SIZE		1
+/* Bit: 'DTHR' */
+/* Description: 'Drop Threshold Selection' */
+#define SDMA_PCTRL_DTHR_OFFSET	0xBC0
+#define SDMA_PCTRL_DTHR_SHIFT		13
+#define SDMA_PCTRL_DTHR_SIZE		2
+/* Bit: 'PTHR' */
+/* Description: 'Pause Threshold Selection' */
+#define SDMA_PCTRL_PTHR_OFFSET	0xBC0
+#define SDMA_PCTRL_PTHR_SHIFT		11
+#define SDMA_PCTRL_PTHR_SIZE		2
+/* Bit: 'PHYEFWD' */
+/* Description: 'Forward PHY Error Frames' */
+#define SDMA_PCTRL_PHYEFWD_OFFSET	0xBC0
+#define SDMA_PCTRL_PHYEFWD_SHIFT	10
+#define SDMA_PCTRL_PHYEFWD_SIZE		1
+/* Bit: 'ALGFWD' */
+/* Description: 'Forward Alignment Error Frames' */
+#define SDMA_PCTRL_ALGFWD_OFFSET	0xBC0
+#define SDMA_PCTRL_ALGFWD_SHIFT		9
+#define SDMA_PCTRL_ALGFWD_SIZE		1
+/* Bit: 'LENFWD' */
+/* Description: 'Forward Length Errored Frames' */
+#define SDMA_PCTRL_LENFWD_OFFSET	0xBC0
+#define SDMA_PCTRL_LENFWD_SHIFT		8
+#define SDMA_PCTRL_LENFWD_SIZE		1
+/* Bit: 'OSFWD' */
+/* Description: 'Forward Oversized Frames' */
+#define SDMA_PCTRL_OSFWD_OFFSET	0xBC0
+#define SDMA_PCTRL_OSFWD_SHIFT	7
+#define SDMA_PCTRL_OSFWD_SIZE		1
+/* Bit: 'USFWD' */
+/* Description: 'Forward Undersized Frames' */
+#define SDMA_PCTRL_USFWD_OFFSET 0xBC0
+#define SDMA_PCTRL_USFWD_SHIFT	6
+#define SDMA_PCTRL_USFWD_SIZE		1
+/* Bit: 'FCSIGN' */
+/* Description: 'Ignore FCS Errors' */
+#define SDMA_PCTRL_FCSIGN_OFFSET	0xBC0
+#define SDMA_PCTRL_FCSIGN_SHIFT		5
+#define SDMA_PCTRL_FCSIGN_SIZE		1
+/* Bit: 'FCSFWD' */
+/* Description: 'Forward FCS Errored Frames' */
+#define SDMA_PCTRL_FCSFWD_OFFSET	0xBC0
+#define SDMA_PCTRL_FCSFWD_SHIFT		4
+#define SDMA_PCTRL_FCSFWD_SIZE		1
+/* Bit: 'PAUFWD' */
+/* Description: 'Pause Frame Forwarding' */
+#define SDMA_PCTRL_PAUFWD_OFFSET	0xBC0
+#define SDMA_PCTRL_PAUFWD_SHIFT		3
+#define SDMA_PCTRL_PAUFWD_SIZE		1
+/* Bit: 'MFCEN' */
+/* Description: 'Metering Flow Control Enable' */
+#define SDMA_PCTRL_MFCEN_OFFSET	0xBC0
+#define SDMA_PCTRL_MFCEN_SHIFT	2
+#define SDMA_PCTRL_MFCEN_SIZE		1
+/* Bit: 'FCEN' */
+/* Description: 'Flow Control Enable' */
+#define SDMA_PCTRL_FCEN_OFFSET	0xBC0
+#define SDMA_PCTRL_FCEN_SHIFT		1
+#define SDMA_PCTRL_FCEN_SIZE		1
+/* Bit: 'PEN' */
+/* Description: 'Port Enable' */
+#define SDMA_PCTRL_PEN_OFFSET	0xBC0
+#define SDMA_PCTRL_PEN_SHIFT	0
+#define SDMA_PCTRL_PEN_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'Ethernet SwitchStore DMA Port Priority Register' */
+/* Bit: 'MIN_IFG' */
+/* Description: 'Minimum IFG,SFD and preamble' */
+#define SDMA_PRIO_MIN_IFG_OFFSET	0xBC1
+#define SDMA_PRIO_MIN_IFG_SHIFT		7
+#define SDMA_PRIO_MIN_IFG_SIZE		5
+/* Bit: 'PHYEIGN' */
+/* Description: 'Ignore PHY Error Frames' */
+#define SDMA_PRIO_PHYEIGN_OFFSET	0xBC1
+#define SDMA_PRIO_PHYEIGN_SHIFT		6
+#define SDMA_PRIO_PHYEIGN_SIZE		1
+/* Bit: 'ALGIGN' */
+/* Description: 'Ignore Alignment Error Frames' */
+#define SDMA_PRIO_ALGIGN_OFFSET	0xBC1
+#define SDMA_PRIO_ALGIGN_SHIFT	5
+#define SDMA_PRIO_ALGIGN_SIZE		1
+/* Bit: 'LENIGN' */
+/* Description: 'Ignore Length Errored Frames' */
+#define SDMA_PRIO_LENIGN_OFFSET	0xBC1
+#define SDMA_PRIO_LENIGN_SHIFT	4
+#define SDMA_PRIO_LENIGN_SIZE		1
+/* Bit: 'OSIGN' */
+/* Description: 'Ignore Oversized Frames' */
+#define SDMA_PRIO_OSIGN_OFFSET	0xBC1
+#define SDMA_PRIO_OSIGN_SHIFT		3
+#define SDMA_PRIO_OSIGN_SIZE		1
+/* Bit: 'USIGN' */
+/* Description: 'Ignore Undersized Frames' */
+#define SDMA_PRIO_USIGN_OFFSET	0xBC1
+#define SDMA_PRIO_USIGN_SHIFT		2
+#define SDMA_PRIO_USIGN_SIZE		1
+/* Bit: 'PRIO' */
+/* Description: 'SDMA PRIO' */
+#define SDMA_PRIO_PRIO_OFFSET	0xBC1
+#define SDMA_PRIO_PRIO_SHIFT	0
+#define SDMA_PRIO_PRIO_SIZE		2
+/* --------------------------------------------------- */
+/* Register: 'Ethernet SwitchStore DMA Port Status Register 0' */
+/* Bit: 'HDR_PTR' */
+/* Description: 'Port Ingress Queue Header Pointer' */
+#define SDMA_PSTAT0_HDR_PTR_OFFSET	0xBC2
+#define SDMA_PSTAT0_HDR_PTR_SHIFT		0
+#define SDMA_PSTAT0_HDR_PTR_SIZE		10
+/* --------------------------------------------------- */
+/* Register: 'Ethernet SwitchStore DMA Port Status Register 1' */
+/* Bit: 'PPKT' */
+/* Description: 'Port Ingress Packet Count' */
+#define SDMA_PSTAT1_PPKT_OFFSET	0xBC3
+#define SDMA_PSTAT1_PPKT_SHIFT	0
+#define SDMA_PSTAT1_PPKT_SIZE	10
+/* --------------------------------------------------- */
+/* Register: 'Ethernet SwitchStore DMA PCE Bypass Register' */
+#define SDMA_BYPASS_PCE_REG_OFFSET	0xBC4
+/* Bit: 'EXTQID' */
+/* Description: 'Extracted packet's Q-ID' */
+#define SDMA_BYPASS_PCE_EXTQID_OFFSET	0xBC4
+#define SDMA_BYPASS_PCE_EXTQID_SHIFT	6
+#define SDMA_BYPASS_PCE_EXTQID_SIZE		5
+/* Bit: 'NMQID' */
+/* Description: 'Non-Extracted packet's starting Q-ID' */
+#define SDMA_BYPASS_PCE_NMQID_OFFSET	0xBC4
+#define SDMA_BYPASS_PCE_NMQID_SHIFT		1
+#define SDMA_BYPASS_PCE_NMQID_SIZE		5
+/* Bit: 'MD' */
+/* Description: 'Q-Map mode' */
+#define SDMA_BYPASS_PCE_MD_OFFSET		0xBC4
+#define SDMA_BYPASS_PCE_MD_SHIFT		0
+#define SDMA_BYPASS_PCE_MD_SIZE			1
+/* --------------------------------------------------- */
+/* Register: 'Ingress TimeStamp Register 0' */
+/* Bit: 'TSTL' */
+/* Description: 'Time Stamp [15:0]' */
+#define SDMA_TSTAMP0_TSTL_OFFSET	0xBC4
+#define SDMA_TSTAMP0_TSTL_SHIFT		0
+#define SDMA_TSTAMP0_TSTL_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Ingress TimeStamp Register 1' */
+/* Bit: 'TSTH' */
+/* Description: 'Time Stamp [31:16]' */
+#define SDMA_TSTAMP1_TSTH_OFFSET	0xBC5
+#define SDMA_TSTAMP1_TSTH_SHIFT		0
+#define SDMA_TSTAMP1_TSTH_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Ingress Port Flow Control Threshold 8 Register' (LTQ_GSWIP_2_2)*/
+/* Bit: 'THR8' */
+/* Description: 'Threshold 8' */
+#define SDMA_PFCTHR8_THR8_OFFSET22	0xC0E
+#define SDMA_PFCTHR8_THR8_OFFSET30	0xB80  /* (LTQ_GSWIP_3_0) */
+#define SDMA_PFCTHR8_THR8_SHIFT		0
+#define SDMA_PFCTHR8_THR8_SIZE		11
+/* --------------------------------------------------- */
+/* Register: 'Ingress Port Flow Control Threshold 9 Register' (LTQ_GSWIP_2_2)*/
+/* Bit: 'THR9' */
+/* Description: 'Threshold 8' */
+#define SDMA_PFCTHR9_THR9_OFFSET22	0xC0F
+#define SDMA_PFCTHR9_THR9_OFFSET30	0xB81  /* (LTQ_GSWIP_3_0) */
+#define SDMA_PFCTHR9_THR9_SHIFT		0
+#define SDMA_PFCTHR9_THR9_SIZE		11
+/* --------------------------------------------------- */
+/******** Ethernet PMAC Registers ******************** */
+/* --------------------------------------------------- */
+/* Register: 'PMAC Interrupt Status Register' (LTQ_GSWIP_3_0)*/
+/* Bit: 'EGCHKERR' */
+/* Description: 'Egress IP/UDP/TCP Checksum Error Detected' */
+#define PMAC_ISR_EGCHKERR_OFFSET	0xD01
+#define PMAC_ISR_EGCHKERR_SHIFT		7
+#define PMAC_ISR_EGCHKERR_SIZE		1
+/* Bit: 'IGCHKERR' */
+/* Description: 'Ingress IP/UDP/TCP Checksum Error Detected' */
+#define PMAC_ISR_IGCHKERR_OFFSET	0xD01
+#define PMAC_ISR_IGCHKERR_SHIFT		6
+#define PMAC_ISR_IGCHKERR_SIZE		1
+/* Bit: 'TOOSHORT' */
+/* Description: 'Too Short Frame Error Detected' */
+#define PMAC_ISR_TOOSHORT_OFFSET	0xD01
+#define PMAC_ISR_TOOSHORT_SHIFT		5
+#define PMAC_ISR_TOOSHORT_SIZE		1
+/* Bit: 'TOOLONG' */
+/* Description: 'Too Long Frame Error Detected' */
+#define PMAC_ISR_TOOLONG_OFFSET	0xD01
+#define PMAC_ISR_TOOLONG_SHIFT	4
+#define PMAC_ISR_TOOLONG_SIZE		1
+/* Bit: 'LENERR' */
+/* Description: 'Length Mismatch Error Detected' */
+#define PMAC_ISR_LENERR_OFFSET	0xD01
+#define PMAC_ISR_LENERR_SHIFT		3
+#define PMAC_ISR_LENERR_SIZE		1
+/* Bit: 'FCSERR' */
+/* Description: 'Frame Checksum Error Detected' */
+#define PMAC_ISR_FCSERR_OFFSET	0xD01
+#define PMAC_ISR_FCSERR_SHIFT		2
+#define PMAC_ISR_FCSERR_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'PMAC Interrupt Enable Register' (LTQ_GSWIP_3_0)*/
+/* Bit: 'EGCHKERR' */
+/* Description: 'Egress Checksum Error Interrupt Mask' */
+#define PMAC_IER_EGCHKERR_OFFSET	0xD02
+#define PMAC_IER_EGCHKERR_SHIFT		7
+#define PMAC_IER_EGCHKERR_SIZE		1
+/* Bit: 'IGCHKERR' */
+/* Description: 'Ingress Checksum Error Interrupt Mask' */
+#define PMAC_IER_IGCHKERR_OFFSET	0xD02
+#define PMAC_IER_IGCHKERR_SHIFT		6
+#define PMAC_IER_IGCHKERR_SIZE		1
+/* Bit: 'TOOSHORT' */
+/* Description: 'Too Short Frame Error Interrupt Mask' */
+#define PMAC_IER_TOOSHORT_OFFSET	0xD02
+#define PMAC_IER_TOOSHORT_SHIFT		5
+#define PMAC_IER_TOOSHORT_SIZE		1
+/* Bit: 'TOOLONG' */
+/* Description: 'Too Long Frame Error Interrupt Mask' */
+#define PMAC_IER_TOOLONG_OFFSET	0xD02
+#define PMAC_IER_TOOLONG_SHIFT	4
+#define PMAC_IER_TOOLONG_SIZE		1
+/* Bit: 'LENERR' */
+/* Description: 'Length Mismatch Error Interrupt Mask' */
+#define PMAC_IER_LENERR_OFFSET	0xD02
+#define PMAC_IER_LENERR_SHIFT		3
+#define PMAC_IER_LENERR_SIZE		1
+/* Bit: 'FCSERR' */
+/* Description: 'Frame Checksum Error Interrupt Mask' */
+#define PMAC_IER_FCSERR_OFFSET	0xD02
+#define PMAC_IER_FCSERR_SHIFT		2
+#define PMAC_IER_FCSERR_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'PMAC Control Register 0' (LTQ_GSWIP_3_0)*/
+/* Bit: 'APADEN' */
+/* Description: 'Automatic VLAN Padding Enable' */
+#define PMAC_CTRL_0_APADEN_OFFSET	0xD03
+#define PMAC_CTRL_0_APADEN_SHIFT	11
+#define PMAC_CTRL_0_APADEN_SIZE		1
+/* Bit: 'VPAD2EN' */
+/* Description: 'Stacked VLAN Padding Enable' */
+#define PMAC_CTRL_0_VPAD2EN_OFFSET	0xD03
+#define PMAC_CTRL_0_VPAD2EN_SHIFT		10
+#define PMAC_CTRL_0_VPAD2EN_SIZE		1
+/* Bit: 'VPADEN' */
+/* Description: 'VLAN Padding Enable' */
+#define PMAC_CTRL_0_VPADEN_OFFSET	0xD03
+#define PMAC_CTRL_0_VPADEN_SHIFT	9
+#define PMAC_CTRL_0_VPADEN_SIZE		1
+/* Bit: 'PADEN' */
+/* Description: 'Padding Enable' */
+#define PMAC_CTRL_0_PADEN_OFFSET	0xD03
+#define PMAC_CTRL_0_PADEN_SHIFT		8
+#define PMAC_CTRL_0_PADEN_SIZE		1
+
+/* Bit: 'FCSEN' */
+/* Description: 'FCS Enable Control' GSWIP 3.1*/
+#define PMAC_CTRL_0_FCSEN_OFFSET	0xD03
+#define PMAC_CTRL_0_FCSEN_SHIFT		12
+#define PMAC_CTRL_0_FCSEN_SIZE		1
+
+/* Bit: 'FCS' */
+/* Description: 'Transmit FCS Control' */
+#define PMAC_CTRL_0_FCS_OFFSET	0xD03
+#define PMAC_CTRL_0_FCS_SHIFT		7
+#define PMAC_CTRL_0_FCS_SIZE		1
+/* Bit: 'CHKREG' */
+/* Description: 'IP/TCP/UDP Checksum Generation Control' */
+#define PMAC_CTRL_0_CHKREG_OFFSET	0xD03
+#define PMAC_CTRL_0_CHKREG_SHIFT	6
+#define PMAC_CTRL_0_CHKREG_SIZE		1
+/* Bit: 'CHKVER' */
+/* Description: 'IP/TCP/UDP Checksum Verification Control' */
+#define PMAC_CTRL_0_CHKVER_OFFSET	0xD03
+#define PMAC_CTRL_0_CHKVER_SHIFT	5
+#define PMAC_CTRL_0_CHKVER_SIZE		1
+/* --------------------------------------------------- */
+/* Register: 'GSW_PMAC_CTRL_1' for PMAC-0 (LTQ_GSWIP_3_1)*/
+/* Bit: 'MLEN' */
+/* Description: 'Maximum Frame Length' */
+#define PMAC_CTRL_1_MLEN_OFFSET	    0xD04
+#define PMAC_CTRL_1_MLEN_SHIFT	    0
+#define PMAC_CTRL_1_MLEN_SIZE		14
+/* --------------------------------------------------- */
+/* Register: 'GSW_PMAC_CTRL_1_1'  for PMAC-1  (LTQ_GSWIP_3_1)*/
+/* Bit: 'MLEN' */
+/* Description: 'Maximum Frame Length' */
+#define PMAC_CTRL_1_1_MLEN_OFFSET	0xD84
+#define PMAC_CTRL_1_1_MLEN_SHIFT	0
+#define PMAC_CTRL_1_1_MLEN_SIZE		14
+/* --------------------------------------------------- */
+/* Register: 'PMAC Control Register 2' (LTQ_GSWIP_3_0)*/
+/* Bit: 'MLEN' */
+/* Description: 'Maximum Untagged Frame Length' */
+#define PMAC_CTRL_2_MLEN_OFFSET	0xD05
+#define PMAC_CTRL_2_MLEN_SHIFT	3
+#define PMAC_CTRL_2_MLEN_SIZE		1
+/* Bit: 'LCHKL' */
+/* Description: 'Frame Length Check Long Enable' */
+#define PMAC_CTRL_2_LCHKL_OFFSET	0xD05
+#define PMAC_CTRL_2_LCHKL_SHIFT		2
+#define PMAC_CTRL_2_LCHKL_SIZE		1
+/* Bit: 'LCHKS' */
+/* Description: 'Frame Length Check Short Enable' */
+#define PMAC_CTRL_2_LCHKS_OFFSET	0xD05
+#define PMAC_CTRL_2_LCHKS_SHIFT		0
+#define PMAC_CTRL_2_LCHKS_SIZE		2
+/* --------------------------------------------------- */
+/* Register: 'PMAC Control Register 3' (LTQ_GSWIP_3_0)*/
+/* Bit: 'JUMBO' */
+/* Description: 'Frame Length Threshold for Jumbo Packet' */
+#define PMAC_CTRL_3_JUMBO_OFFSET	0xD06
+#define PMAC_CTRL_3_JUMBO_SHIFT		0
+#define PMAC_CTRL_3_JUMBO_SIZE		14
+/* --------------------------------------------------- */
+/* Register: 'PMAC Control Register 4' (LTQ_GSWIP_3_0)*/
+/* Bit: 'FLAGEN' */
+/* Description: 'Select Processing Flags or Traffic Class For */
+/*	Addressing Egress Configuration Table' */
+#define PMAC_CTRL_4_FLAGEN_OFFSET	0xD07
+#define PMAC_CTRL_4_FLAGEN_SHIFT	0
+#define PMAC_CTRL_4_FLAGEN_SIZE		1
+/*GSWIP3.1 PMAC_CTRL_4_FLAGEN_SIZE
+  has changed to 2 */
+#define PMAC_CTRL_4_GSWIP3_1_FLAGEN_SIZE		2
+/* --------------------------------------------------- */
+/*Applicable for GSWIP3.1*/
+#define	PMAC_BSL_LEN0_OFFSET	0xD10
+#define	PMAC_BSL_LEN0_SHIFT		0
+#define	PMAC_BSL_LEN0_SIZE		16
+
+#define	PMAC_BSL_LEN1_OFFSET	0xD11
+#define	PMAC_BSL_LEN1_SHIFT		0
+#define	PMAC_BSL_LEN1_SIZE		16
+
+#define	PMAC_BSL_LEN2_OFFSET	0xD12
+#define	PMAC_BSL_LEN2_SHIFT		0
+#define	PMAC_BSL_LEN2_SIZE		16
+/* --------------------------------------------------- */
+
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register 4' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL4' */
+/* Description: 'Data value [15:0]' */
+#define PMAC_TBL_VAL_4_VAL4_OFFSET	0xD40
+#define PMAC_TBL_VAL_4_VAL4_SHIFT		0
+#define PMAC_TBL_VAL_4_VAL4_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register 3' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL3' */
+/* Description: 'Data value [15:0]' */
+#define PMAC_TBL_VAL_3_VAL3_OFFSET	0xD41
+#define PMAC_TBL_VAL_3_VAL3_SHIFT		0
+#define PMAC_TBL_VAL_3_VAL3_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register 2' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL2' */
+/* Description: 'Data value [15:0]' */
+#define PMAC_TBL_VAL_2_VAL2_OFFSET	0xD42
+#define PMAC_TBL_VAL_2_VAL2_SHIFT		0
+#define PMAC_TBL_VAL_2_VAL2_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register 1' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL1' */
+/* Description: 'Data value [15:0]' */
+#define PMAC_TBL_VAL_1_VAL1_OFFSET	0xD43
+#define PMAC_TBL_VAL_1_VAL1_SHIFT		0
+#define PMAC_TBL_VAL_1_VAL1_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Value Register 0' (LTQ_GSWIP_3_0)*/
+/* Bit: 'VAL0' */
+/* Description: 'Data value [15:0]' */
+#define PMAC_TBL_VAL_0_VAL0_OFFSET	0xD44
+#define PMAC_TBL_VAL_0_VAL0_SHIFT		0
+#define PMAC_TBL_VAL_0_VAL0_SIZE		16
+/* --------------------------------------------------- */
+/* Register: 'Table Entry Address Register' (LTQ_GSWIP_3_0)*/
+/* Bit: 'ADDR' */
+/* Description: 'Table Address' */
+#define PMAC_TBL_ADDR_ADDR_OFFSET	0xD45
+#define PMAC_TBL_ADDR_ADDR_SHIFT	0
+#define PMAC_TBL_ADDR_ADDR_SIZE		12
+/* --------------------------------------------------- */
+/* Register: 'Table Access Control Register' (LTQ_GSWIP_3_0)*/
+/* Bit: 'BAS' */
+/* Description: 'Access Busy/Access Start' */
+#define PMAC_TBL_CTRL_BAS_OFFSET	0xD46
+#define PMAC_TBL_CTRL_BAS_SHIFT		15
+#define PMAC_TBL_CTRL_BAS_SIZE		1
+/* Bit: 'OPMOD' */
+/* Description: 'Lookup Table Access Operation Mode' */
+#define PMAC_TBL_CTRL_OPMOD_OFFSET	0xD46
+#define PMAC_TBL_CTRL_OPMOD_SHIFT		5
+#define PMAC_TBL_CTRL_OPMOD_SIZE		1
+/* Bit: 'ADDR' */
+/* Description: 'Lookup Table Address' */
+#define PMAC_TBL_CTRL_ADDR_OFFSET	0xD46
+#define PMAC_TBL_CTRL_ADDR_SHIFT	0
+#define PMAC_TBL_CTRL_ADDR_SIZE		3
+
+
+/* Description: Ethernet Switch CTP Assignment Start Register 0 - Applicable for 3.1 */
+#define ETHSW_CTP_STARTID_0_OFFSET		0xE80
+/* Description: Macro to get Ethernet Switch CTP Assignment Start Register Address OFFSET based on Logical Port ID - Applicable for 3.1 */
+#define ETHSW_CTP_STARTID_GET(LogicalPortID)	(ETHSW_CTP_STARTID_0_OFFSET+(LogicalPortID)*2)
+#define ETHSW_CTP_STARTID_MD_SHIFT			14
+#define ETHSW_CTP_STARTID_MD_SIZE			2
+#define ETHSW_CTP_STARTID_SHIFT				0
+#define ETHSW_CTP_STARTID_SIZE				9
+
+/* Description: Ethernet Switch CTP Assignment End Register 0 - Applicable for 3.1 */
+#define ETHSW_CTP_ENDID_0_OFFSET		0xE81
+/* Description: Macro to get Ethernet Switch CTP Assignment End Register Address OFFSET based on Logical Port ID - Applicable for 3.1 */
+#define ETHSW_CTP_ENDID_GET(LogicalPortID)		(ETHSW_CTP_ENDID_0_OFFSET+(LogicalPortID)*2)
+#define ETHSW_CTP_ENDID_SHIFT				0
+#define ETHSW_CTP_ENDID_SIZE				9
+
+#define PCE_DA_FILTER_0_OFFSET				0x3E0
+#define PCE_DA_FILTER_OFFSET_GET(PortMemberId)	(PCE_DA_FILTER_0_OFFSET+PortMemberId)
+#define PCE_DA_FILTER_SHIFT					0
+#define PCE_DA_FILTER_SIZE					16
+
+#define PCE_SA_FILTER_0_OFFSET				0x3F0
+#define PCE_SA_FILTER_OFFSET_GET(PortMemberId)	(PCE_SA_FILTER_0_OFFSET+PortMemberId)
+#define PCE_SA_FILTER_SHIFT					0
+#define PCE_SA_FILTER_SIZE					16
+
+/*Description: Ethernet Switch IRQ register - Applicable for 3.1*/
+
+#define PCE_IER_0_OFFSET			0x465
+#define PCE_IER_0_SHIFT					0
+#define PCE_IER_0_SIZE					16
+
+#define PCE_IER_0_PORT_MASK_GET(LogicalPortID)	(1 << LogicalPortID)
+
+#define PCE_IER_1_OFFSET			0x466
+#define PCE_IER_1_SHIFT					0
+#define PCE_IER_1_SIZE					16
+
+#define PCE_ISR_0_OFFSET			0x467
+#define PCE_ISR_0_SHIFT					0
+#define PCE_ISR_0_SIZE					16
+#define PCE_ISR_0_PORT_MASK_GET(LogicalPortID)	(1 << LogicalPortID)
+
+
+#define PCE_ISR_1_OFFSET			0x468
+#define PCE_ISR_1_SHIFT					0
+#define PCE_ISR_1_SIZE					16
+
+/* --------------------------------------------------- */
+#endif /* _LTQ_GSWITCH_REG_H_ */
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_reg_top.h b/drivers/net/ethernet/lantiq/switch-api/gsw_reg_top.h
new file mode 100644
index 000000000000..f5c56e554069
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_reg_top.h
@@ -0,0 +1,859 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+#ifndef _LTQ_GSW_SOC_TOP_H_
+#define _LTQ_GSW_SOC_TOP_H_
+/* ----------------------------------------------- */
+/* Register: 'Global Control Register0' */
+/* Bit: 'SE' */
+/* Description: 'Global Switch Macro Enable' */
+#define GLOB_CTRL_SE_OFFSET	0x000
+#define GLOB_CTRL_SE_SHIFT	15
+#define GLOB_CTRL_SE_SIZE		1
+/* Bit: 'HWRES' */
+/* Description: 'Global Hardware Reset' */
+#define GLOB_CTRL_HWRES_OFFSET	0x000
+#define GLOB_CTRL_HWRES_SHIFT		1
+#define GLOB_CTRL_HWRES_SIZE		1
+/* Bit: 'SWRES' */
+/* Description: 'Global Software Reset' */
+#define GLOB_CTRL_SWRES_OFFSET	0x000
+#define GLOB_CTRL_SWRES_SHIFT		0
+#define GLOB_CTRL_SWRES_SIZE		1
+/* ----------------------------------------------- */
+/* Register: 'MDIO Control Register' */
+/* Bit: 'MBUSY' */
+/* Description: 'MDIO Busy' */
+#define MDIO_CTRL_MBUSY_OFFSET	0x008
+#define MDIO_CTRL_MBUSY_SHIFT		12
+#define MDIO_CTRL_MBUSY_SIZE		1
+/* Bit: 'OP' */
+/* Description: 'Operation Code' */
+#define MDIO_CTRL_OP_OFFSET		0x008
+#define MDIO_CTRL_OP_SHIFT		10
+#define MDIO_CTRL_OP_SIZE			2
+/* Bit: 'PHYAD' */
+/* Description: 'PHY Address' */
+#define MDIO_CTRL_PHYAD_OFFSET	0x008
+#define MDIO_CTRL_PHYAD_SHIFT		5
+#define MDIO_CTRL_PHYAD_SIZE		5
+/* Bit: 'REGAD' */
+/* Description: 'Register Address' */
+#define MDIO_CTRL_REGAD_OFFSET	0x008
+#define MDIO_CTRL_REGAD_SHIFT		0
+#define MDIO_CTRL_REGAD_SIZE		5
+/* ----------------------------------------------- */
+/* Register: 'MDIO Read Data Register' */
+/* Bit: 'RDATA' */
+/* Description: 'Read Data' */
+#define MDIO_READ_RDATA_OFFSET	0x009
+#define MDIO_READ_RDATA_SHIFT		0
+#define MDIO_READ_RDATA_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'MDIO Write Data Register' */
+/* Bit: 'WDATA' */
+/* Description: 'Write Data' */
+#define MDIO_WRITE_WDATA_OFFSET	0x00A
+#define MDIO_WRITE_WDATA_SHIFT	0
+#define MDIO_WRITE_WDATA_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'MDC Clock ConfigurationRegister 0' */
+/* Bit: 'PEN_5' */
+/* Description: 'Polling State Machine Enable' */
+#define MDC_CFG_0_PEN_5_OFFSET	0x00B
+#define MDC_CFG_0_PEN_5_SHIFT		5
+#define MDC_CFG_0_PEN_5_SIZE		1
+/* Bit: 'PEN_4' */
+/* Description: 'Polling State Machine Enable' */
+#define MDC_CFG_0_PEN_4_OFFSET	0x00B
+#define MDC_CFG_0_PEN_4_SHIFT		4
+#define MDC_CFG_0_PEN_4_SIZE		1
+/* Bit: 'PEN_3' */
+/* Description: 'Polling State Machine Enable' */
+#define MDC_CFG_0_PEN_3_OFFSET	0x00B
+#define MDC_CFG_0_PEN_3_SHIFT		3
+#define MDC_CFG_0_PEN_3_SIZE		1
+/* Bit: 'PEN_2' */
+/* Description: 'Polling State Machine Enable' */
+#define MDC_CFG_0_PEN_2_OFFSET	0x00B
+#define MDC_CFG_0_PEN_2_SHIFT		2
+#define MDC_CFG_0_PEN_2_SIZE		1
+/* Bit: 'PEN_1' */
+/* Description: 'Polling State Machine Enable' */
+#define MDC_CFG_0_PEN_1_OFFSET	0x00B
+#define MDC_CFG_0_PEN_1_SHIFT		1
+#define MDC_CFG_0_PEN_1_SIZE		1
+/* Bit: 'PEN_0' */
+/* Description: 'Polling State Machine Enable' */
+#define MDC_CFG_0_PEN_0_OFFSET	0x00B
+#define MDC_CFG_0_PEN_0_SHIFT		0
+#define MDC_CFG_0_PEN_0_SIZE		1
+/* Bit: 'PEN_0~PEN_5' */
+/* Description: 'Polling State Machine Enable' */
+#define MDC_CFG_0_PEN_ALL_OFFSET	0x00B
+#define MDC_CFG_0_PEN_ALL_SHIFT		0
+#define MDC_CFG_0_PEN_ALL_SIZE		6
+/* ----------------------------------------------- */
+/* Register: 'MDC Clock ConfigurationRegister 1' */
+/* Bit: 'RES' */
+/* Description: 'MDIO Hardware Reset' */
+#define MDC_CFG_1_RES_OFFSET	0x00C
+#define MDC_CFG_1_RES_SHIFT		15
+#define MDC_CFG_1_RES_SIZE		1
+/* Bit: 'MCEN' */
+/* Description: 'Management Clock Enable' */
+#define MDC_CFG_1_MCEN_OFFSET	0x00C
+#define MDC_CFG_1_MCEN_SHIFT	8
+#define MDC_CFG_1_MCEN_SIZE		1
+/* Bit: 'FREQ' */
+/* Description: 'MDIO Interface Clock Rate' */
+#define MDC_CFG_1_FREQ_OFFSET	0x00C
+#define MDC_CFG_1_FREQ_SHIFT	0
+#define MDC_CFG_1_FREQ_SIZE		8
+/* ----------------------------------------------- */
+/* Register: 'PHY Address RegisterPORT 5' */
+/* Bit: 'LNKST' */
+/* Description: 'Link Status Control' */
+#define PHY_ADDR_5_LNKST_OFFSET	0x010
+#define PHY_ADDR_5_LNKST_SHIFT	13
+#define PHY_ADDR_5_LNKST_SIZE		2
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define PHY_ADDR_5_SPEED_OFFSET	0x010
+#define PHY_ADDR_5_SPEED_SHIFT	11
+#define PHY_ADDR_5_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Control' */
+#define PHY_ADDR_5_FDUP_OFFSET	0x010
+#define PHY_ADDR_5_FDUP_SHIFT		9
+#define PHY_ADDR_5_FDUP_SIZE		2
+/* Bit: 'FCONTX' */
+/* Description: 'Flow Control Mode TX' */
+#define PHY_ADDR_5_FCONTX_OFFSET	0x010
+#define PHY_ADDR_5_FCONTX_SHIFT		7
+#define PHY_ADDR_5_FCONTX_SIZE		2
+/* Bit: 'FCONRX' */
+/* Description: 'Flow Control Mode RX' */
+#define PHY_ADDR_5_FCONRX_OFFSET	0x010
+#define PHY_ADDR_5_FCONRX_SHIFT		5
+#define PHY_ADDR_5_FCONRX_SIZE		2
+/* Bit: 'ADDR' */
+/* Description: 'PHY Address' */
+#define PHY_ADDR_5_ADDR_OFFSET	0x010
+#define PHY_ADDR_5_ADDR_SHIFT		0
+#define PHY_ADDR_5_ADDR_SIZE		5
+/* ----------------------------------------------- */
+/* Register: 'PHY Address RegisterPORT 4' */
+/* Bit: 'LNKST' */
+/* Description: 'Link Status Control' */
+#define PHY_ADDR_4_LNKST_OFFSET	0x011
+#define PHY_ADDR_4_LNKST_SHIFT	13
+#define PHY_ADDR_4_LNKST_SIZE		2
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define PHY_ADDR_4_SPEED_OFFSET	0x011
+#define PHY_ADDR_4_SPEED_SHIFT	11
+#define PHY_ADDR_4_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Control' */
+#define PHY_ADDR_4_FDUP_OFFSET	0x011
+#define PHY_ADDR_4_FDUP_SHIFT		9
+#define PHY_ADDR_4_FDUP_SIZE		2
+/* Bit: 'FCONTX' */
+/* Description: 'Flow Control Mode TX' */
+#define PHY_ADDR_4_FCONTX_OFFSET	0x011
+#define PHY_ADDR_4_FCONTX_SHIFT		7
+#define PHY_ADDR_4_FCONTX_SIZE		2
+/* Bit: 'FCONRX' */
+/* Description: 'Flow Control Mode RX' */
+#define PHY_ADDR_4_FCONRX_OFFSET	0x011
+#define PHY_ADDR_4_FCONRX_SHIFT		5
+#define PHY_ADDR_4_FCONRX_SIZE		2
+/* Bit: 'ADDR' */
+/* Description: 'PHY Address' */
+#define PHY_ADDR_4_ADDR_OFFSET	0x011
+#define PHY_ADDR_4_ADDR_SHIFT		0
+#define PHY_ADDR_4_ADDR_SIZE		5
+/* ----------------------------------------------- */
+/* Register: 'PHY Address RegisterPORT 3' */
+/* Bit: 'LNKST' */
+/* Description: 'Link Status Control' */
+#define PHY_ADDR_3_LNKST_OFFSET	0x012
+#define PHY_ADDR_3_LNKST_SHIFT	13
+#define PHY_ADDR_3_LNKST_SIZE		2
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define PHY_ADDR_3_SPEED_OFFSET	0x012
+#define PHY_ADDR_3_SPEED_SHIFT	11
+#define PHY_ADDR_3_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Control' */
+#define PHY_ADDR_3_FDUP_OFFSET	0x012
+#define PHY_ADDR_3_FDUP_SHIFT		9
+#define PHY_ADDR_3_FDUP_SIZE		2
+/* Bit: 'FCONTX' */
+/* Description: 'Flow Control Mode TX' */
+#define PHY_ADDR_3_FCONTX_OFFSET	0x012
+#define PHY_ADDR_3_FCONTX_SHIFT		7
+#define PHY_ADDR_3_FCONTX_SIZE		2
+/* Bit: 'FCONRX' */
+/* Description: 'Flow Control Mode RX' */
+#define PHY_ADDR_3_FCONRX_OFFSET	0x012
+#define PHY_ADDR_3_FCONRX_SHIFT		5
+#define PHY_ADDR_3_FCONRX_SIZE		2
+/* Bit: 'ADDR' */
+/* Description: 'PHY Address' */
+#define PHY_ADDR_3_ADDR_OFFSET	0x012
+#define PHY_ADDR_3_ADDR_SHIFT		0
+#define PHY_ADDR_3_ADDR_SIZE		5
+/* ----------------------------------------------- */
+/* Register: 'PHY Address RegisterPORT 2' */
+/* Bit: 'LNKST' */
+/* Description: 'Link Status Control' */
+#define PHY_ADDR_2_LNKST_OFFSET	0x013
+#define PHY_ADDR_2_LNKST_SHIFT	13
+#define PHY_ADDR_2_LNKST_SIZE		2
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define PHY_ADDR_2_SPEED_OFFSET	0x013
+#define PHY_ADDR_2_SPEED_SHIFT	11
+#define PHY_ADDR_2_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Control' */
+#define PHY_ADDR_2_FDUP_OFFSET	0x013
+#define PHY_ADDR_2_FDUP_SHIFT		9
+#define PHY_ADDR_2_FDUP_SIZE		2
+/* Bit: 'FCONTX' */
+/* Description: 'Flow Control Mode TX' */
+#define PHY_ADDR_2_FCONTX_OFFSET	0x013
+#define PHY_ADDR_2_FCONTX_SHIFT		7
+#define PHY_ADDR_2_FCONTX_SIZE		2
+/* Bit: 'FCONRX' */
+/* Description: 'Flow Control Mode RX' */
+#define PHY_ADDR_2_FCONRX_OFFSET	0x013
+#define PHY_ADDR_2_FCONRX_SHIFT		5
+#define PHY_ADDR_2_FCONRX_SIZE		2
+/* Bit: 'ADDR' */
+/* Description: 'PHY Address' */
+#define PHY_ADDR_2_ADDR_OFFSET	0x013
+#define PHY_ADDR_2_ADDR_SHIFT		0
+#define PHY_ADDR_2_ADDR_SIZE		5
+/* ----------------------------------------------- */
+/* Register: 'PHY Address RegisterPORT 1' */
+/* Bit: 'LNKST' */
+/* Description: 'Link Status Control' */
+#define PHY_ADDR_1_LNKST_OFFSET	0x014
+#define PHY_ADDR_1_LNKST_SHIFT	13
+#define PHY_ADDR_1_LNKST_SIZE		2
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define PHY_ADDR_1_SPEED_OFFSET	0x014
+#define PHY_ADDR_1_SPEED_SHIFT	11
+#define PHY_ADDR_1_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Control' */
+#define PHY_ADDR_1_FDUP_OFFSET	0x014
+#define PHY_ADDR_1_FDUP_SHIFT		9
+#define PHY_ADDR_1_FDUP_SIZE		2
+/* Bit: 'FCONTX' */
+/* Description: 'Flow Control Mode TX' */
+#define PHY_ADDR_1_FCONTX_OFFSET	0x014
+#define PHY_ADDR_1_FCONTX_SHIFT		7
+#define PHY_ADDR_1_FCONTX_SIZE		2
+/* Bit: 'FCONRX' */
+/* Description: 'Flow Control Mode RX' */
+#define PHY_ADDR_1_FCONRX_OFFSET	0x014
+#define PHY_ADDR_1_FCONRX_SHIFT		5
+#define PHY_ADDR_1_FCONRX_SIZE		2
+/* Bit: 'ADDR' */
+/* Description: 'PHY Address' */
+#define PHY_ADDR_1_ADDR_OFFSET	0x014
+#define PHY_ADDR_1_ADDR_SHIFT		0
+#define PHY_ADDR_1_ADDR_SIZE		5
+/* ----------------------------------------------- */
+/* Register: 'PHY Address RegisterPORT 0' */
+/* Bit: 'LNKST' */
+/* Description: 'Link Status Control' */
+#define PHY_ADDR_0_LNKST_OFFSET	0x015
+#define PHY_ADDR_0_LNKST_SHIFT	13
+#define PHY_ADDR_0_LNKST_SIZE		2
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define PHY_ADDR_0_SPEED_OFFSET	0x015
+#define PHY_ADDR_0_SPEED_SHIFT	11
+#define PHY_ADDR_0_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Control' */
+#define PHY_ADDR_0_FDUP_OFFSET	0x015
+#define PHY_ADDR_0_FDUP_SHIFT		9
+#define PHY_ADDR_0_FDUP_SIZE		2
+/* Bit: 'FCONTX' */
+/* Description: 'Flow Control Mode TX' */
+#define PHY_ADDR_0_FCONTX_OFFSET	0x015
+#define PHY_ADDR_0_FCONTX_SHIFT		7
+#define PHY_ADDR_0_FCONTX_SIZE		2
+/* Bit: 'FCONRX' */
+/* Description: 'Flow Control Mode RX' */
+#define PHY_ADDR_0_FCONRX_OFFSET	0x015
+#define PHY_ADDR_0_FCONRX_SHIFT		5
+#define PHY_ADDR_0_FCONRX_SIZE		2
+/* Bit: 'ADDR' */
+/* Description: 'PHY Address' */
+#define PHY_ADDR_0_ADDR_OFFSET	0x015
+#define PHY_ADDR_0_ADDR_SHIFT		0
+#define PHY_ADDR_0_ADDR_SIZE		5
+/* ----------------------------------------------- */
+/* Register: 'PHY MDIO PollingStatus per PORT' */
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'PHY supports MAC turning of TX clk' */
+#define MDIO_STAT_0_CLK_STOP_CAPABLE_OFFSET	0x016
+#define MDIO_STAT_0_CLK_STOP_CAPABLE_SHIFT	8
+#define MDIO_STAT_0_CLK_STOP_CAPABLE_SIZE		1
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'PHY and link partner support EEE for current speed' */
+#define MDIO_STAT_0_EEE_CAPABLE_OFFSET	0x016
+#define MDIO_STAT_0_EEE_CAPABLE_SHIFT		7
+#define MDIO_STAT_0_EEE_CAPABLE_SIZE		1
+/* Bit: 'PACT' */
+/* Description: 'PHY Active Status' */
+#define MDIO_STAT_0_PACT_OFFSET	0x016
+#define MDIO_STAT_0_PACT_SHIFT	6
+#define MDIO_STAT_0_PACT_SIZE		1
+/* Bit: 'LSTAT' */
+/* Description: 'Link Status' */
+#define MDIO_STAT_0_LSTAT_OFFSET	0x016
+#define MDIO_STAT_0_LSTAT_SHIFT		5
+#define MDIO_STAT_0_LSTAT_SIZE		1
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define MDIO_STAT_0_SPEED_OFFSET	0x016
+#define MDIO_STAT_0_SPEED_SHIFT		3
+#define MDIO_STAT_0_SPEED_SIZE		2
+/* Bit: 'FDUP' */
+/* Description: 'Full Duplex Status' */
+#define MDIO_STAT_0_FDUP_OFFSET	0x016
+#define MDIO_STAT_0_FDUP_SHIFT	2
+#define MDIO_STAT_0_FDUP_SIZE		1
+/* Bit: 'RXPAUEN' */
+/* Description: 'Receive Pause Enable Status' */
+#define MDIO_STAT_0_RXPAUEN_OFFSET	0x016
+#define MDIO_STAT_0_RXPAUEN_SHIFT		1
+#define MDIO_STAT_0_RXPAUEN_SIZE		1
+/* Bit: 'TXPAUEN' */
+/* Description: 'Transmit Pause Enable Status' */
+#define MDIO_STAT_0_TXPAUEN_OFFSET	0x016
+#define MDIO_STAT_0_TXPAUEN_SHIFT		0
+#define MDIO_STAT_0_TXPAUEN_SIZE		1
+/* ----------------------------------------------- */
+/* Register: 'EEE auto negotiationoverides' for PORT 0*/
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'clk stop capable' */
+#define ANEG_EEE_0_CLK_STOP_CAPABLE_OFFSET	0x01C
+#define ANEG_EEE_0_CLK_STOP_CAPABLE_SHIFT		2
+#define ANEG_EEE_0_CLK_STOP_CAPABLE_SIZE		2
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'EEE capable' */
+#define ANEG_EEE_0_EEE_CAPABLE_OFFSET	0x01C
+#define ANEG_EEE_0_EEE_CAPABLE_SHIFT	0
+#define ANEG_EEE_0_EEE_CAPABLE_SIZE		2
+/* ----------------------------------------------- */
+/* Register: 'EEE auto negotiationoverides' for PORT 0 */
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'clk stop capable' */
+#define ANEG_EEE_1_CLK_STOP_CAPABLE_OFFSET	0x01D
+#define ANEG_EEE_1_CLK_STOP_CAPABLE_SHIFT		2
+#define ANEG_EEE_1_CLK_STOP_CAPABLE_SIZE		2
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'EEE capable' */
+#define ANEG_EEE_1_EEE_CAPABLE_OFFSET	0x01D
+#define ANEG_EEE_1_EEE_CAPABLE_SHIFT	0
+#define ANEG_EEE_1_EEE_CAPABLE_SIZE		2
+/* ----------------------------------------------- */
+/* Register: 'EEE auto negotiationoverides' for PORT 2 */
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'clk stop capable' */
+#define ANEG_EEE_2_CLK_STOP_CAPABLE_OFFSET	0x01E
+#define ANEG_EEE_2_CLK_STOP_CAPABLE_SHIFT		2
+#define ANEG_EEE_2_CLK_STOP_CAPABLE_SIZE		2
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'EEE capable' */
+#define ANEG_EEE_2_EEE_CAPABLE_OFFSET	0x01E
+#define ANEG_EEE_2_EEE_CAPABLE_SHIFT	0
+#define ANEG_EEE_2_EEE_CAPABLE_SIZE		2
+/* ----------------------------------------------- */
+/* Register: 'EEE auto negotiationoverides' for PORT 3 */
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'clk stop capable' */
+#define ANEG_EEE_3_CLK_STOP_CAPABLE_OFFSET	0x01F
+#define ANEG_EEE_3_CLK_STOP_CAPABLE_SHIFT		2
+#define ANEG_EEE_3_CLK_STOP_CAPABLE_SIZE		2
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'EEE capable' */
+#define ANEG_EEE_3_EEE_CAPABLE_OFFSET	0x01F
+#define ANEG_EEE_3_EEE_CAPABLE_SHIFT	0
+#define ANEG_EEE_3_EEE_CAPABLE_SIZE		2
+/* ----------------------------------------------- */
+/* Register: 'EEE auto negotiationoverides' for PORT 4  */
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'clk stop capable' */
+#define ANEG_EEE_4_CLK_STOP_CAPABLE_OFFSET	0x020
+#define ANEG_EEE_4_CLK_STOP_CAPABLE_SHIFT		2
+#define ANEG_EEE_4_CLK_STOP_CAPABLE_SIZE		2
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'EEE capable' */
+#define ANEG_EEE_4_EEE_CAPABLE_OFFSET	0x020
+#define ANEG_EEE_4_EEE_CAPABLE_SHIFT	0
+#define ANEG_EEE_4_EEE_CAPABLE_SIZE		2
+/* ----------------------------------------------- */
+/* Register: 'EEE auto negotiationoverides' for PORT 5 */
+/* Bit: 'CLK_STOP_CAPABLE' */
+/* Description: 'clk stop capable' */
+#define ANEG_EEE_5_CLK_STOP_CAPABLE_OFFSET	0x021
+#define ANEG_EEE_5_CLK_STOP_CAPABLE_SHIFT		2
+#define ANEG_EEE_5_CLK_STOP_CAPABLE_SIZE		2
+/* Bit: 'EEE_CAPABLE' */
+/* Description: 'EEE capable' */
+#define ANEG_EEE_5_EEE_CAPABLE_OFFSET	0x021
+#define ANEG_EEE_5_EEE_CAPABLE_SHIFT	0
+#define ANEG_EEE_5_EEE_CAPABLE_SIZE		2
+/* ----------------------------------------------- */
+/* Register: 'xMII Port 0 ConfigurationRegister' */
+/* Bit: 'RES' */
+/* Description: 'Hardware Reset' */
+#define MII_CFG_0_RES_OFFSET	0x036
+#define MII_CFG_0_RES_SHIFT		15
+#define MII_CFG_0_RES_SIZE		1
+/* Bit: 'EN' */
+/* Description: 'xMII Interface Enable' */
+#define MII_CFG_0_EN_OFFSET		0x036
+#define MII_CFG_0_EN_SHIFT		14
+#define MII_CFG_0_EN_SIZE			1
+/* Bit: 'ISOL' */
+/* Description: 'ISOLATE xMII Interface' */
+#define MII_CFG_0_ISOL_OFFSET		0x036
+#define MII_CFG_0_ISOL_SHIFT		13
+#define MII_CFG_0_ISOL_SIZE			1
+/* Bit: 'LDCLKDIS' */
+/* Description: 'Link Down Clock Disable' */
+#define MII_CFG_0_LDCLKDIS_OFFSET	0x036
+#define MII_CFG_0_LDCLKDIS_SHIFT	12
+#define MII_CFG_0_LDCLKDIS_SIZE		1
+/* Bit: 'CRS' */
+/* Description: 'CRS Sensitivity Configuration' */
+#define MII_CFG_0_CRS_OFFSET	0x036
+#define MII_CFG_0_CRS_SHIFT		9
+#define MII_CFG_0_CRS_SIZE		2
+/* Bit: 'RGMII_IBS' */
+/* Description: 'RGMII In Band Status' */
+#define MII_CFG_0_RGMII_IBS_OFFSET	0x036
+#define MII_CFG_0_RGMII_IBS_SHIFT		8
+#define MII_CFG_0_RGMII_IBS_SIZE		1
+/* Bit: 'RMII' */
+/* Description: 'RMII Reference Clock Direction of the Port' */
+#define MII_CFG_0_RMII_OFFSET	0x036
+#define MII_CFG_0_RMII_SHIFT	7
+#define MII_CFG_0_RMII_SIZE		1
+/* Bit: 'MIIRATE' */
+/* Description: 'xMII Port Interface Clock Rate' */
+#define MII_CFG_0_MIIRATE_OFFSET	0x036
+#define MII_CFG_0_MIIRATE_SHIFT		4
+#define MII_CFG_0_MIIRATE_SIZE		3
+/* Bit: 'MIIMODE' */
+/* Description: 'xMII Interface Mode' */
+#define MII_CFG_0_MIIMODE_OFFSET	0x036
+#define MII_CFG_0_MIIMODE_SHIFT		0
+#define MII_CFG_0_MIIMODE_SIZE		4
+/* ----------------------------------------------- */
+/* Register: 'Configuration of ClockDelay for Port 0' */
+/* Bit: 'RXLOCK' */
+/* Description: 'Lock Status MDL of Receive PCDU' */
+#define PCDU_0_RXLOCK_OFFSET	0x037
+#define PCDU_0_RXLOCK_SHIFT		15
+#define PCDU_0_RXLOCK_SIZE		1
+/* Bit: 'TXLOCK' */
+/* Description: 'Lock Status of MDL of Transmit PCDU' */
+#define PCDU_0_TXLOCK_OFFSET	0x037
+#define PCDU_0_TXLOCK_SHIFT		14
+#define PCDU_0_TXLOCK_SIZE		1
+/* Bit: 'RXDLY' */
+/* Description: 'Configure Receive Clock Delay' */
+#define PCDU_0_RXDLY_OFFSET		0x037
+#define PCDU_0_RXDLY_SHIFT		7
+#define PCDU_0_RXDLY_SIZE			3
+/* Bit: 'TXDLY' */
+/* Description: 'Configure Transmit PCDU' */
+#define PCDU_0_TXDLY_OFFSET		0x037
+#define PCDU_0_TXDLY_SHIFT		0
+#define PCDU_0_TXDLY_SIZE			3
+/* ----------------------------------------------- */
+/* Register: 'xMII Port 1 ConfigurationRegister' */
+/* Bit: 'RES' */
+/* Description: 'Hardware Reset' */
+#define MII_CFG_1_RES_OFFSET	0x038
+#define MII_CFG_1_RES_SHIFT		15
+#define MII_CFG_1_RES_SIZE		1
+/* Bit: 'EN' */
+/* Description: 'xMII Interface Enable' */
+#define MII_CFG_1_EN_OFFSET		0x038
+#define MII_CFG_1_EN_SHIFT		14
+#define MII_CFG_1_EN_SIZE			1
+/* Bit: 'ISOL' */
+/* Description: 'ISOLATE xMII Interface' */
+#define MII_CFG_1_ISOL_OFFSET	0x038
+#define MII_CFG_1_ISOL_SHIFT	13
+#define MII_CFG_1_ISOL_SIZE		1
+/* Bit: 'LDCLKDIS' */
+/* Description: 'Link Down Clock Disable' */
+#define MII_CFG_1_LDCLKDIS_OFFSET	0x038
+#define MII_CFG_1_LDCLKDIS_SHIFT	12
+#define MII_CFG_1_LDCLKDIS_SIZE		1
+/* Bit: 'CRS' */
+/* Description: 'CRS Sensitivity Configuration' */
+#define MII_CFG_1_CRS_OFFSET	0x038
+#define MII_CFG_1_CRS_SHIFT		9
+#define MII_CFG_1_CRS_SIZE		2
+/* Bit: 'RGMII_IBS' */
+/* Description: 'RGMII In Band Status' */
+#define MII_CFG_1_RGMII_IBS_OFFSET	0x038
+#define MII_CFG_1_RGMII_IBS_SHIFT		8
+#define MII_CFG_1_RGMII_IBS_SIZE		1
+/* Bit: 'RMII' */
+/* Description: 'RMII Reference Clock Direction of the Port' */
+#define MII_CFG_1_RMII_OFFSET	0x038
+#define MII_CFG_1_RMII_SHIFT	7
+#define MII_CFG_1_RMII_SIZE		1
+/* Bit: 'MIIRATE' */
+/* Description: 'xMII Port Interface Clock Rate' */
+#define MII_CFG_1_MIIRATE_OFFSET	0x038
+#define MII_CFG_1_MIIRATE_SHIFT		4
+#define MII_CFG_1_MIIRATE_SIZE		3
+/* Bit: 'MIIMODE' */
+/* Description: 'xMII Interface Mode' */
+#define MII_CFG_1_MIIMODE_OFFSET	0x038
+#define MII_CFG_1_MIIMODE_SHIFT		0
+#define MII_CFG_1_MIIMODE_SIZE		4
+/* ----------------------------------------------- */
+/* Register: 'Configuration of ClockDelay for Port 1' */
+/* Bit: 'RXLOCK' */
+/* Description: 'Lock Status MDL of Receive PCDU' */
+#define PCDU_1_RXLOCK_OFFSET	0x039
+#define PCDU_1_RXLOCK_SHIFT		15
+#define PCDU_1_RXLOCK_SIZE		1
+/* Bit: 'TXLOCK' */
+/* Description: 'Lock Status of MDL of Transmit PCDU' */
+#define PCDU_1_TXLOCK_OFFSET	0x039
+#define PCDU_1_TXLOCK_SHIFT		14
+#define PCDU_1_TXLOCK_SIZE		1
+/* Bit: 'RXDLY' */
+/* Description: 'Configure Receive Clock Delay' */
+#define PCDU_1_RXDLY_OFFSET		0x039
+#define PCDU_1_RXDLY_SHIFT		7
+#define PCDU_1_RXDLY_SIZE			3
+/* Bit: 'TXDLY' */
+/* Description: 'Configure Transmit PCDU' */
+#define PCDU_1_TXDLY_OFFSET		0x039
+#define PCDU_1_TXDLY_SHIFT		0
+#define PCDU_1_TXDLY_SIZE			3
+/* ----------------------------------------------- */
+/* Register: 'xMII Port 5 ConfigurationRegister' */
+/* Bit: 'RES' */
+/* Description: 'Hardware Reset' */
+#define MII_CFG_5_RES_OFFSET	0x040
+#define MII_CFG_5_RES_SHIFT		15
+#define MII_CFG_5_RES_SIZE		1
+/* Bit: 'EN' */
+/* Description: 'xMII Interface Enable' */
+#define MII_CFG_5_EN_OFFSET		0x040
+#define MII_CFG_5_EN_SHIFT		14
+#define MII_CFG_5_EN_SIZE			1
+/* Bit: 'ISOL' */
+/* Description: 'ISOLATE xMII Interface' */
+#define MII_CFG_5_ISOL_OFFSET	0x040
+#define MII_CFG_5_ISOL_SHIFT	13
+#define MII_CFG_5_ISOL_SIZE		1
+/* Bit: 'LDCLKDIS' */
+/* Description: 'Link Down Clock Disable' */
+#define MII_CFG_5_LDCLKDIS_OFFSET	0x040
+#define MII_CFG_5_LDCLKDIS_SHIFT	12
+#define MII_CFG_5_LDCLKDIS_SIZE		1
+/* Bit: 'CRS' */
+/* Description: 'CRS Sensitivity Configuration' */
+#define MII_CFG_5_CRS_OFFSET	0x040
+#define MII_CFG_5_CRS_SHIFT		9
+#define MII_CFG_5_CRS_SIZE		2
+/* Bit: 'RGMII_IBS' */
+/* Description: 'RGMII In Band Status' */
+#define MII_CFG_5_RGMII_IBS_OFFSET	0x040
+#define MII_CFG_5_RGMII_IBS_SHIFT		8
+#define MII_CFG_5_RGMII_IBS_SIZE		1
+/* Bit: 'MIIRATE' */
+/* Description: 'xMII Port Interface Clock Rate' */
+#define MII_CFG_5_MIIRATE_OFFSET	0x040
+#define MII_CFG_5_MIIRATE_SHIFT		4
+#define MII_CFG_5_MIIRATE_SIZE		3
+/* Bit: 'MIIMODE' */
+/* Description: 'xMII Interface Mode' */
+#define MII_CFG_5_MIIMODE_OFFSET	0x040
+#define MII_CFG_5_MIIMODE_SHIFT		0
+#define MII_CFG_5_MIIMODE_SIZE		4
+/* ----------------------------------------------- */
+/* Register: 'Configuration of ClockDelay for External Port 5' */
+/* Bit: 'RXLOCK' */
+/* Description: 'Lock Status MDL of Receive PCDU' */
+#define PCDU_5_RXLOCK_OFFSET	0x041
+#define PCDU_5_RXLOCK_SHIFT		15
+#define PCDU_5_RXLOCK_SIZE		1
+/* Bit: 'TXLOCK' */
+/* Description: 'Lock Status of MDL of Transmit PCDU' */
+#define PCDU_5_TXLOCK_OFFSET	0x041
+#define PCDU_5_TXLOCK_SHIFT		14
+#define PCDU_5_TXLOCK_SIZE		1
+/* Bit: 'RXDLY' */
+/* Description: 'Configure Receive Clock Delay' */
+#define PCDU_5_RXDLY_OFFSET		0x041
+#define PCDU_5_RXDLY_SHIFT		7
+#define PCDU_5_RXDLY_SIZE			3
+/* Bit: 'TXDLY' */
+/* Description: 'Configure Transmit PCDU' */
+#define PCDU_5_TXDLY_OFFSET		0x041
+#define PCDU_5_TXDLY_SHIFT		0
+#define PCDU_5_TXDLY_SIZE			3
+/* ----------------------------------------------- */
+/* Register: 'Receive Buffer ControlRegister for Port 0' */
+/* Bit: 'RBUF_UFL' */
+/* Description: 'Receive Buffer Underflow Indicator' */
+#define RXB_CTL_0_RBUF_UFL_OFFSET	0x056
+#define RXB_CTL_0_RBUF_UFL_SHIFT	15
+#define RXB_CTL_0_RBUF_UFL_SIZE		1
+/* Bit: 'RBUF_OFL' */
+/* Description: 'Receive Buffer Overflow Indicator' */
+#define RXB_CTL_0_RBUF_OFL_OFFSET	0x056
+#define RXB_CTL_0_RBUF_OFL_SHIFT	14
+#define RXB_CTL_0_RBUF_OFL_SIZE		1
+/* Bit: 'RBUF_DLY_WP' */
+/* Description: 'Delay' */
+#define RXB_CTL_0_RBUF_DLY_WP_OFFSET	0x056
+#define RXB_CTL_0_RBUF_DLY_WP_SHIFT		0
+#define RXB_CTL_0_RBUF_DLY_WP_SIZE		3
+/* ----------------------------------------------- */
+/* Register: 'Receive Buffer ControlRegister External Port 1' */
+/* Bit: 'RBUF_UFL' */
+/* Description: 'Receive Buffer Underflow Indicator' */
+#define RXB_CTL_1_RBUF_UFL_OFFSET	0x057
+#define RXB_CTL_1_RBUF_UFL_SHIFT	15
+#define RXB_CTL_1_RBUF_UFL_SIZE		1
+/* Bit: 'RBUF_OFL' */
+/* Description: 'Receive Buffer Overflow Indicator' */
+#define RXB_CTL_1_RBUF_OFL_OFFSET	0x057
+#define RXB_CTL_1_RBUF_OFL_SHIFT	14
+#define RXB_CTL_1_RBUF_OFL_SIZE		1
+/* Bit: 'RBUF_DLY_WP' */
+/* Description: 'Delay' */
+#define RXB_CTL_1_RBUF_DLY_WP_OFFSET	0x057
+#define RXB_CTL_1_RBUF_DLY_WP_SHIFT		0
+#define RXB_CTL_1_RBUF_DLY_WP_SIZE		3
+/* ----------------------------------------------- */
+/* Register: 'Receive Buffer ControlRegister External Port 5' */
+/* Bit: 'RBUF_UFL' */
+/* Description: 'Receive Buffer Underflow Indicator' */
+#define RXB_CTL_5_RBUF_UFL_OFFSET	0x05B
+#define RXB_CTL_5_RBUF_UFL_SHIFT	15
+#define RXB_CTL_5_RBUF_UFL_SIZE		1
+/* Bit: 'RBUF_OFL' */
+/* Description: 'Receive Buffer Overflow Indicator' */
+#define RXB_CTL_5_RBUF_OFL_OFFSET	0x05B
+#define RXB_CTL_5_RBUF_OFL_SHIFT	14
+#define RXB_CTL_5_RBUF_OFL_SIZE		1
+/* Bit: 'RBUF_DLY_WP' */
+/* Description: 'Delay' */
+#define RXB_CTL_5_RBUF_DLY_WP_OFFSET	0x05B
+#define RXB_CTL_5_RBUF_DLY_WP_SHIFT		0
+#define RXB_CTL_5_RBUF_DLY_WP_SIZE		3
+/* ----------------------------------------------- */
+/* Register: 'Debug Control Register' */
+/* Bit: 'DBG_EN' */
+/* Description: 'Debug enable' */
+#define DBG_CTL_DBG_EN_OFFSET	0x081
+#define DBG_CTL_DBG_EN_SHIFT	14
+#define DBG_CTL_DBG_EN_SIZE		1
+/* Bit: 'DBG_SEL' */
+/* Description: 'Debug select' */
+#define DBG_CTL_DBG_SEL_OFFSET	0x081
+#define DBG_CTL_DBG_SEL_SHIFT		0
+#define DBG_CTL_DBG_SEL_SIZE		1
+/* ----------------------------------------------- */
+/* Register: 'PMAC Header ControlRegister' */
+/* Bit: 'FC' */
+/* Description: 'Enable Flow Control' */
+#define PMAC_HD_CTL_FC_OFFSET	0x082
+#define PMAC_HD_CTL_FC_SHIFT	10
+#define PMAC_HD_CTL_FC_SIZE		1
+/* Bit: 'CCRC' */
+/* Description: 'Check CRC' */
+#define PMAC_HD_CTL_CCRC_OFFSET	0x082
+#define PMAC_HD_CTL_CCRC_SHIFT	9
+#define PMAC_HD_CTL_CCRC_SIZE		1
+/* Bit: 'RST' */
+/* Description: 'Remove Special Tag' */
+#define PMAC_HD_CTL_RST_OFFSET	0x082
+#define PMAC_HD_CTL_RST_SHIFT		8
+#define PMAC_HD_CTL_RST_SIZE		1
+/* Bit: 'AST' */
+/* Description: 'Add Special Tag' */
+#define PMAC_HD_CTL_AST_OFFSET	0x082
+#define PMAC_HD_CTL_AST_SHIFT		7
+#define PMAC_HD_CTL_AST_SIZE		1
+/* Bit: 'RXSH' */
+/* Description: 'Status Header' */
+#define PMAC_HD_CTL_RXSH_OFFSET	0x082
+#define PMAC_HD_CTL_RXSH_SHIFT	6
+#define PMAC_HD_CTL_RXSH_SIZE		1
+/* Bit: 'RL2' */
+/* Description: 'Remove Layer-2 Header' */
+#define PMAC_HD_CTL_RL2_OFFSET	0x082
+#define PMAC_HD_CTL_RL2_SHIFT		5
+#define PMAC_HD_CTL_RL2_SIZE		1
+/* Bit: 'RC' */
+/* Description: 'Remove CRC' */
+#define PMAC_HD_CTL_RC_OFFSET	0x082
+#define PMAC_HD_CTL_RC_SHIFT	4
+#define PMAC_HD_CTL_RC_SIZE		1
+/* Bit: 'AS' */
+/* Description: 'Add Status Header' */
+#define PMAC_HD_CTL_AS_OFFSET	0x082
+#define PMAC_HD_CTL_AS_SHIFT	3
+#define PMAC_HD_CTL_AS_SIZE		1
+/* Bit: 'AC' */
+/* Description: 'Add CRC' */
+#define PMAC_HD_CTL_AC_OFFSET	0x082
+#define PMAC_HD_CTL_AC_SHIFT	2
+#define PMAC_HD_CTL_AC_SIZE		1
+/* Bit: 'TAG' */
+/* Description: 'Add TAG' */
+#define PMAC_HD_CTL_TAG_OFFSET	0x082
+#define PMAC_HD_CTL_TAG_SHIFT		1
+#define PMAC_HD_CTL_TAG_SIZE		1
+/* Bit: 'ADD' */
+/* Description: 'ADD Header' */
+#define PMAC_HD_CTL_ADD_OFFSET	0x082
+#define PMAC_HD_CTL_ADD_SHIFT		0
+#define PMAC_HD_CTL_ADD_SIZE		1
+/* ----------------------------------------------- */
+/* Register: 'PMAC Type/Length Register' */
+/* Bit: 'TYPE_LEN' */
+/* Description: 'TYPE or Lenght Value' */
+#define PMAC_TL_TYPE_LEN_OFFSET	0x083
+#define PMAC_TL_TYPE_LEN_SHIFT	0
+#define PMAC_TL_TYPE_LEN_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'PMAC Source Address Register1' */
+/* Bit: 'SA_47_32' */
+/* Description: 'Source Address 47..32' */
+#define PMAC_SA1_SA_47_32_OFFSET	0x084
+#define PMAC_SA1_SA_47_32_SHIFT		0
+#define PMAC_SA1_SA_47_32_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'PMAC Source Address Register2' */
+/* Bit: 'SA_31_16' */
+/* Description: 'Source Address 31..16' */
+#define PMAC_SA2_SA_31_16_OFFSET	0x085
+#define PMAC_SA2_SA_31_16_SHIFT		0
+#define PMAC_SA2_SA_31_16_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'PMAC Source Address Register3' */
+/* Bit: 'SA_15_0' */
+/* Description: 'Source Address 15..0' */
+#define PMAC_SA3_SA_15_0_OFFSET	0x086
+#define PMAC_SA3_SA_15_0_SHIFT	0
+#define PMAC_SA3_SA_15_0_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'PMAC Destination AddressRegister 1' */
+/* Bit: 'SA_47_32' */
+/* Description: 'Destination Address 47..32' */
+#define PMAC_DA1_SA_47_32_OFFSET	0x087
+#define PMAC_DA1_SA_47_32_SHIFT		0
+#define PMAC_DA1_SA_47_32_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'PMAC Destination AddressRegister 2' */
+/* Bit: 'DA_31_16' */
+/* Description: 'Destination Address 31..16' */
+#define PMAC_DA2_DA_31_16_OFFSET	0x088
+#define PMAC_DA2_DA_31_16_SHIFT		0
+#define PMAC_DA2_DA_31_16_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'PMAC Destination AddressRegister 3' */
+/* Bit: 'DA_15_0' */
+/* Description: 'Destination Address 15..0' */
+#define PMAC_DA3_DA_15_0_OFFSET	0x089
+#define PMAC_DA3_DA_15_0_SHIFT	0
+#define PMAC_DA3_DA_15_0_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'PMAC VLAN Register' */
+/* Bit: 'PRI' */
+/* Description: 'VLAN Priority' */
+#define PMAC_VLAN_PRI_OFFSET	0x08A
+#define PMAC_VLAN_PRI_SHIFT		13
+#define PMAC_VLAN_PRI_SIZE		3
+/* Bit: 'CFI' */
+/* Description: 'Canonical Format Identifier' */
+#define PMAC_VLAN_CFI_OFFSET	0x08A
+#define PMAC_VLAN_CFI_SHIFT		12
+#define PMAC_VLAN_CFI_SIZE		1
+/* Bit: 'VLAN_ID' */
+/* Description: 'VLAN ID' */
+#define PMAC_VLAN_VLAN_ID_OFFSET	0x08A
+#define PMAC_VLAN_VLAN_ID_SHIFT		0
+#define PMAC_VLAN_VLAN_ID_SIZE		12
+/* ----------------------------------------------- */
+/* Register: 'PMAC Inter Packet Gapin RX Direction' */
+/* Bit: 'REQ_DS_THRES' */
+/* Description: 'Request Deassertion Threshold' */
+#define PMAC_RX_IPG_REQ_DS_THRES_OFFSET	0x08B
+#define PMAC_RX_IPG_REQ_DS_THRES_SHIFT	8
+#define PMAC_RX_IPG_REQ_DS_THRES_SIZE		1
+/* Bit: 'REQ_AS_THRES' */
+/* Description: 'Request Assertion Threshold' */
+#define PMAC_RX_IPG_REQ_AS_THRES_OFFSET	0x08B
+#define PMAC_RX_IPG_REQ_AS_THRES_SHIFT	4
+#define PMAC_RX_IPG_REQ_AS_THRES_SIZE		4
+/* Bit: 'IPG_CNT' */
+/* Description: 'IPG Counter' */
+#define PMAC_RX_IPG_IPG_CNT_OFFSET	0x08B
+#define PMAC_RX_IPG_IPG_CNT_SHIFT		0
+#define PMAC_RX_IPG_IPG_CNT_SIZE		4
+/* ----------------------------------------------- */
+/* Register: 'PMAC Special Tag Ethertype' */
+/* Bit: 'ST_ETYPE' */
+/* Description: 'Special Tag Ethertype' */
+#define PMAC_ST_ETYPE_ST_ETYPE_OFFSET	0x08C
+#define PMAC_ST_ETYPE_ST_ETYPE_SHIFT	0
+#define PMAC_ST_ETYPE_ST_ETYPE_SIZE		16
+/* ----------------------------------------------- */
+/* Register: 'PMAC Ethernet WAN Group' */
+/* Bit: 'EWAN' */
+/* Description: 'Ethernet WAN Group' */
+#define PMAC_EWAN_EWAN_OFFSET	0x08D
+#define PMAC_EWAN_EWAN_SHIFT	0
+#define PMAC_EWAN_EWAN_SIZE		6
+/* ----------------------------------------------- */
+/* Register: 'PMAC Control Register' */
+/* Bit: 'SPEED' */
+/* Description: 'Speed Control' */
+#define PMAC_CTL_SPEED_OFFSET	0x08E
+#define PMAC_CTL_SPEED_SHIFT	1
+#define PMAC_CTL_SPEED_SIZE		1
+/* Bit: 'EN' */
+/* Description: 'PMAC Enable' */
+#define PMAC_CTL_EN_OFFSET	0x08E
+#define PMAC_CTL_EN_SHIFT		0
+#define PMAC_CTL_EN_SIZE		1
+/* ----------------------------------------------- */
+#endif /*  _LTQ_GSW_SOC_TOP_H_ */
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_swmcast.c b/drivers/net/ethernet/lantiq/switch-api/gsw_swmcast.c
new file mode 100644
index 000000000000..ab0a9ab2f4fd
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_swmcast.c
@@ -0,0 +1,877 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#include <gsw_init.h>
+#include <gsw_swmcast.h>
+
+#define DEBUG_TEST 0
+#define FOR_LOOP_TEST 0
+#define DEBUG_PRINT 0
+
+static MCAST_HASHTBL phtable[MCAST_TABLE_SIZE];
+
+//static MCAST_HASHTBL *gsw_create_hash_table(u32 table_size);
+static int get_hashtable_empty_slot(void *cdev, MCAST_HASHTBL *phtable);
+static u16 cal_hash(u32 src_ip_mode, MCAST_HASHTBL_PTN *pattern, u32 type);
+static u16 crcmsb(const u8 *data, u32 len);
+static int set_pce_hash_table(void *cdev, MCAST_HASHTBL *phtable, u32 loc);
+static void update_bridge_pmap(u32 portId, MCAST_HASHTBL *table_ptr, u32 val);
+static int search_hashtable_entry(u32 hashidx, MCAST_HASHTBL_PTN *pattern, u32 *loc);
+static int remove_hashentry(void *cdev, u32 hashidx, u32 rm_idx, u32 portId);
+
+static u16 crcmsb(const u8 *data, u32 len)
+{
+	u16 crc = 0;
+	int i;
+
+	if (len) do {
+			crc ^= ((*data) << 8);
+			data++;
+
+			for (i = 0; i < 8; i++) {
+				if (crc & 0x8000) crc = (crc << 1) ^ 0x1021;
+				else crc <<= 1;
+
+				crc = crc & 0xFFFF;
+			}
+		} while (--len);
+
+	return crc;
+}
+
+
+static u16 cal_hash(u32 src_ip_mode, MCAST_HASHTBL_PTN *pattern, u32 type)
+{
+	u8  b[9];
+	u16 crc;
+	u32 len = 0;
+	int i = 0, j = 0;
+	u32 ip6data[4];
+	u32 xdata;
+
+	memset(b, 0, sizeof(b));
+
+	/* Order is important here, fid, dip, sip */
+	b[i] = pattern->fid;
+
+	if (src_ip_mode == GSW_IGMP_MEMBER_INCLUDE) {
+		if (type == GSW_IP_SELECT_IPV4) {
+			for (i = 0; i < 4; i++)
+				b[i + 1] = ((pattern->dstip.nIPv4 >> ((3 - i) * 8)) & 0xFF);
+
+			for (i = 0; i < 4; i++)
+				b[i + 5] = ((pattern->srcip.nIPv4 >> ((3 - i) * 8)) & 0xFF);
+		} else if (type == GSW_IP_SELECT_IPV6) {
+
+			for (i = 0, j = 0; i < 4; i++, j += 2) {
+				ip6data[i] =
+					((pattern->dstip.nIPv6[j] << 16) | ((pattern->dstip.nIPv6[j + 1])));
+			}
+
+			xdata = (ip6data[0] ^ ip6data[1] ^ ip6data[2] ^ ip6data[3]);
+
+			for (i = 0; i < 4; i++)
+				b[i + 1] = ((xdata >> ((3 - i) * 8)) & 0xFF);
+
+			for (i = 0, j = 0; i < 4; i++, j += 2) {
+				ip6data[i] =
+					((pattern->srcip.nIPv6[j] << 16) | ((pattern->srcip.nIPv6[j + 1])));
+			}
+
+			xdata = (ip6data[0] ^ ip6data[1] ^ ip6data[2] ^ ip6data[3]);
+
+			for (i = 0; i < 4; i++)
+				b[i + 5] = ((xdata >> ((3 - i) * 8)) & 0xFF);
+
+		}
+
+		len = 9;
+	} else {
+		if (type == GSW_IP_SELECT_IPV4) {
+			for (i = 0; i < 4; i++)
+				b[i + 1] = ((pattern->dstip.nIPv4 >> ((3 - i) * 8)) & 0xFF);
+		} else if (type == GSW_IP_SELECT_IPV6) {
+			for (i = 0, j = 0; i < 4; i++, j += 2) {
+				ip6data[i] =
+					((pattern->dstip.nIPv6[j] << 16) | ((pattern->dstip.nIPv6[j + 1])));
+			}
+
+			xdata = (ip6data[0] ^ ip6data[1] ^ ip6data[2] ^ ip6data[3]);
+
+			for (i = 0; i < 4; i++)
+				b[i + 1] = ((xdata >> ((3 - i) * 8)) & 0xFF);
+		}
+
+		for (i = 0; i < 4; i++)
+			b[i + 5] = 0;
+
+		len = 9;
+	}
+
+	crc = crcmsb(b, len);
+
+	crc &= 0x01FF;	// To make sure it is withing 512
+
+	return (crc);
+}
+
+static int get_hashtable_empty_slot(void *cdev, MCAST_HASHTBL *phtable)
+{
+	u32 location_counter = 0;
+	MCAST_HASHTBL *pt;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	while (location_counter < gswdev->mctblsize) {
+		pt  = &phtable[location_counter];
+
+		if ((pt->nxt_idx == 0xFFFF) && (pt->valid == 0))
+			return location_counter;
+
+		location_counter++;
+	}
+
+	return TBL_FULL;
+}
+
+int gsw_check_hashtable_entry(void *cdev)
+{
+	u32 location_counter = 0;
+	MCAST_HASHTBL *pt;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	while (location_counter < gswdev->mctblsize) {
+		pt  = &phtable[location_counter];
+
+		if (pt->valid == 1)
+			return 1;
+
+		location_counter++;
+	}
+
+	return 0;
+}
+
+// Returns position of the only set bit in 'n'
+static int findPosition(u16 n)
+{
+	u16 i = 1;
+	int pos = 0;
+
+	if (n == 0)
+		return -1;
+
+	// Iterate through bits of n till we find a set bit
+	// i&n will be non-zero only when 'i' and 'n' have a set bit
+	// at same position
+	while (!(i & n)) {
+		// Unset current bit and set the next bit in 'i'
+		i = i << 1;
+
+		// increment position
+		++pos;
+	}
+
+	return pos;
+}
+
+static void update_bridge_pmap(u32 portId, MCAST_HASHTBL *table_ptr, u32 val)
+{
+
+	int i = 0, bit = 0;
+
+	i = (portId / 16);
+	bit = (portId % 16);
+
+	if (val == SET)
+		table_ptr->action.br_portmap[i] |= (1 << bit);
+	else
+		table_ptr->action.br_portmap[i] &= ~(1 << bit);
+
+	return;
+}
+
+int gsw_init_hash_table(void *cdev)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	u16 pcindex;
+
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	//printk("Enter %s:%s:%d\n", __FILE__, __func__, __LINE__);
+	memset(phtable, 0, (MCAST_HASHTBL_SIZE * gswdev->mctblsize));
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+
+		for (pcindex = 0; pcindex < gswdev->mctblsize; pcindex++) {
+
+			phtable[pcindex].valid  	= 0;
+			phtable[pcindex].nxt_idx	= 0xFFFF;
+			phtable[pcindex].first_idx	= 0xFFFF;
+			phtable[pcindex].idx        = pcindex;
+
+			pcetable.pcindex = pcindex;
+			pcetable.table = PCE_MULTICAST_SW_INDEX;
+
+			// TODO: Write the initial entries to HW Table
+			//gsw_pce_table_write(cdev, &pcetable);
+		}
+
+		//printk("Exit %s:%s:%d\n", __FILE__, __func__, __LINE__);
+		return GSW_statusOk;
+	}
+
+	return GSW_statusNoSupport;
+}
+
+int gsw_get_swmcast_entry(void *cdev, GSW_multicastTableRead_t *parm, u32 loc)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	int i = 0;
+	int pos;
+
+	printk("Enter %s:%s:%d\n", __FILE__, __func__, __LINE__);
+
+	printk("Getting Index %d\n", loc);
+
+	if (gswdev == NULL)
+		return 0;
+
+#if DEBUG_TEST
+
+	if (loc == 0) {
+#if FOR_LOOP_TEST
+
+		for (j = 0; j < 512; j++) {
+			loc = j;
+#endif
+#endif
+			memset(&pcetable, 0, sizeof(pctbl_prog_t));
+			pcetable.pcindex = loc;
+			pcetable.table = PCE_MULTICAST_SW_INDEX;
+			gsw_pce_table_read(cdev, &pcetable);
+
+			printk("Getting Index %d\n", loc);
+#if DEBUG_PRINT
+
+			printk("pcetable.valid = %d\n", pcetable.valid);
+
+			for (i = 0; i < 18; i++)
+				printk("pcetable.key[%d] %d\n", i, pcetable.key[i]);
+
+			for (i = 1; i < 18; i++)
+				printk("pcetable.val[%d] %d\n", i, pcetable.val[i]);
+
+			printk("\n\n");
+#else
+
+#if FOR_LOOP_TEST
+
+			int issue = 0;
+
+			if (pcetable.valid != 1) {
+				issue = 1;
+			}
+
+			if ((pcetable.key[0] != 0x3FF) && (pcetable.key[1] != 0x1FF) && (pcetable.key[2] != 0xC03F))
+				issue = 1;
+
+			for (i = 3; i < 18; i++) {
+				if (pcetable.key[i] != 0xFFFF)
+					issue = 1;
+			}
+
+			if (pcetable.val[1] != 0xFFF8)
+				issue = 1;
+
+			for (i = 2; i < 10; i++) {
+				if (pcetable.val[i] != 0xFFFF)
+					issue = 1;
+			}
+
+			for (i = 10; i < 18; i++) {
+				if (pcetable.val[i] != 0)
+					issue = 1;
+			}
+
+			if (issue) {
+				printk("Error in READING INDEX %d\n", loc);
+				return 1;
+			}
+
+#endif
+#endif
+
+			if (pcetable.valid == 1) {
+				parm->bExclSrcIP = ((pcetable.key[2] >> 14) & 0x3);
+
+				// Pattern
+				parm->nFID = pcetable.key[2] & 0x3F;
+
+				for (i = 0; i < 8; i++)
+					parm->uIP_Gda.nIPv6[i] = pcetable.key[3 + i];
+
+				for (i = 0; i < 8; i++)
+					parm->uIP_Gsa.nIPv6[i] = pcetable.key[11 + i];
+
+				// Action
+				parm->nSubIfId = ((pcetable.val[1] >> 3) & 0x1FFF);
+
+				for (i = 0; i < 16; i++) {
+					parm->nPortMap[i] = pcetable.val[2 + i];
+
+					pos = findPosition(pcetable.val[2 + i]);
+
+					if (pos != -1) {
+						parm->nPortId += (pos + (i * 16));
+					}
+				}
+
+				printk("ENTRY_FOUND %s:%s:%d\n", __FILE__, __func__, __LINE__);
+			}
+
+
+			printk("Got Loc        %d\n", loc);
+			printk("Valid          %d\n", pcetable.valid);
+			printk("ExclSrcIP      %d\n", parm->bExclSrcIP);
+			printk("nFID           %d\n", parm->nFID);
+			printk("First Idx      %d\n", pcetable.key[0]);
+			printk("Next Idx       %d\n", pcetable.key[1]);
+
+			for (i = 0; i < 8; i++)
+				printk("uIP_Gda.nIPv6[%d] %04x\n", i, parm->uIP_Gda.nIPv6[i]);
+
+			for (i = 0; i < 8; i++)
+				printk("uIP_Gsa.nIPv6[%d] %04x\n", i, parm->uIP_Gsa.nIPv6[i]);
+
+			printk("nSubIfId       %d\n", parm->nSubIfId);
+
+			for (i = 0; i < 16; i++)
+				printk("nPortMap[%d] %04x\n", i, parm->nPortMap[i]);
+
+			printk("nPortId        %d\n", parm->nPortId);
+
+			printk("Exit %s:%s:%d\n", __FILE__, __func__, __LINE__);
+
+#if DEBUG_TEST
+#if FOR_LOOP_TEST
+
+		}
+
+#endif
+	}
+
+#endif
+
+#if DEBUG_TEST
+	return 1;
+#else
+	return (pcetable.valid);
+#endif
+}
+
+static int set_pce_hash_table(void *cdev, MCAST_HASHTBL *phtable, u32 loc)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	pctbl_prog_t pcetable;
+	int i = 0;
+
+	if (gswdev == NULL)
+		return 0;
+
+	printk("Enter %s:%s:%d\n", __FILE__, __func__, __LINE__);
+
+	printk("Setting Index %d\n", loc);
+	memset(&pcetable, 0, sizeof(pctbl_prog_t));
+	pcetable.pcindex = loc;
+	pcetable.table = PCE_MULTICAST_SW_INDEX;
+	gsw_pce_table_read(cdev, &pcetable);
+
+	pcetable.pcindex = loc;
+	pcetable.table = PCE_MULTICAST_SW_INDEX;
+
+	pcetable.key[0] = phtable->first_idx;
+	pcetable.key[1] = phtable->nxt_idx;
+	pcetable.valid = phtable->valid;
+	pcetable.key[2] = ((phtable->excl_src_ip & 0x3) << 14);
+
+	// Pattern
+	pcetable.key[2] |= phtable->key.fid & 0x3F;
+
+	for (i = 0; i < 8; i++) {
+		pcetable.key[3 + i] = phtable->key.dstip.nIPv6[i];
+	}
+
+	for (i = 0; i < 8; i++) {
+		pcetable.key[11 + i] = phtable->key.srcip.nIPv6[i];
+	}
+
+	// Action
+	pcetable.val[1] = ((phtable->action.subifid & 0x1FFF) << 3);
+
+	/*Set Bridge Port Map*/
+	for (i = 0; i < 16; i++)
+		pcetable.val[2 + i] = phtable->action.br_portmap[i];
+
+#if DEBUG_TEST
+
+	if (loc == 0) {
+#if FOR_LOOP_TEST
+
+		for (j = 0; j < 512; j++) {
+			loc = j;
+#endif
+			printk("Setting Index %d\n", loc);
+			pcetable.pcindex = loc;
+			pcetable.table = PCE_MULTICAST_SW_INDEX;
+			pcetable.valid = 1;
+
+			for (i = 1; i < 18; i++)
+				pcetable.val[i] = 0xFFFF;
+
+			for (i = 0; i < 18; i++)
+				pcetable.key[i] = 0xFFFF;
+
+#if DEBUG_PRINT
+			printk("pcetable.valid = %d\n", pcetable.valid);
+
+			for (i = 0; i < 18; i++)
+				printk("pcetable.key[%d] %04x\n", i, pcetable.key[i]);
+
+			for (i = 1; i < 18; i++)
+				printk("pcetable.val[%d] %04x\n", i, pcetable.val[i]);
+
+			printk("\n\n");
+
+			printk("valid = %d\n", phtable->valid);
+
+			printk("eModeMember %d\n", phtable->src_ip_mode);
+			printk("nFID %d\n", phtable->key.fid);
+
+			for (i = 0; i < 8; i++)
+				printk("uIP_Gda.nIPv6[%d] %04x\n", i, phtable->key.dstip.nIPv6[i]);
+
+			for (i = 0; i < 8; i++)
+				printk("uIP_Gsa.nIPv6[%d] %04x\n", i, phtable->key.srcip.nIPv6[i]);
+
+			printk("nSubIfId %d\n", phtable->action.subifid);
+
+			for (i = 0; i < 16; i++)
+				printk("nPortMap[%d] %04x\n", i, phtable->action.br_portmap[i]);
+
+			printk("Exit %s:%s:%d\n", __FILE__, __func__, __LINE__);
+#endif
+			gsw_pce_table_write(cdev, &pcetable);
+#if FOR_LOOP_TEST
+		}
+
+#endif
+	}
+
+#else
+	gsw_pce_table_write(cdev, &pcetable);
+
+	//gsw_get_swmcast_entry(cdev, &parm, loc);
+
+#endif
+
+	return GSW_statusOk;
+}
+
+int gsw_insert_hashtable_entry(void *cdev, GSW_multicastTable_t *parm)
+{
+	u32 loc = 0, found_loc = 0;
+	u32 hashidx;
+	int i = 0, ret = 0;
+	u32 portId;
+
+	MCAST_HASHTBL  *table_ptr = NULL, *new_table_ptr = NULL;
+	MCAST_HASHTBL_PTN pattern;
+
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	printk("Enter %s:%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (parm->nPortId > gswdev->num_of_bridge_port) {
+		pr_err("PortId only upto %d is supported\n", gswdev->num_of_bridge_port);
+		return FAIL;
+	}
+
+	portId = parm->nPortId;
+
+	if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
+		pattern.srcip.nIPv4 = parm->uIP_Gsa.nIPv4;
+		pattern.dstip.nIPv4 = parm->uIP_Gda.nIPv4;
+		printk("portId = %d\n parm->eIPVersion = %d\n nSubIfId = %d\n uIP_Gsa.nIPv4 = %08x\n uIP_Gda.nIPv4 = %08x\n fid = %d\n bExclSrcIP = %d\n eModeMember = %d\n", parm->nPortId, parm->eIPVersion, parm->nSubIfId, parm->uIP_Gsa.nIPv4, parm->uIP_Gda.nIPv4,
+		       parm->nFID,  parm->bExclSrcIP, parm->eModeMember);
+	} else if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+
+		printk("portId = %d\n parm->eIPVersion = %d\n nSubIfId = %d\n fid = %d\n bExclSrcIP = %d\n eModeMember = %d\n",
+		       parm->nPortId, parm->eIPVersion, parm->nSubIfId, parm->nFID,  parm->bExclSrcIP, parm->eModeMember);
+
+		for (i = 0; i < 8; i++) {
+			pattern.srcip.nIPv6[i] = parm->uIP_Gsa.nIPv6[7 - i];
+			pattern.dstip.nIPv6[i] = parm->uIP_Gda.nIPv6[7 - i];
+		}
+	}
+
+	pattern.fid = parm->nFID;
+
+	hashidx = cal_hash(parm->eModeMember, &pattern, parm->eIPVersion);
+
+	ret = search_hashtable_entry(hashidx, &pattern, &found_loc);
+
+	if (ret == TABLE_ERROR) {
+		printk(":::::: IMPOSSIBLE ::::: TABLE ERROR\n");
+		return ret;
+	} else if (ret ==  MATCH_FOUND) {
+
+		// Existing Entry Found, update the bridge portmap with the new portid and exit
+
+		printk("Existing Entry Found, update the bridge portmap with the new portid and exit\n");
+		table_ptr = &phtable[found_loc];
+		update_bridge_pmap(portId, table_ptr, SET);
+		set_pce_hash_table(cdev, table_ptr, found_loc);
+
+		return found_loc;
+	}
+
+	/* Get a new location, this is needed for 2 cases,
+	   1. New hashidx entry
+	   2. Existing hashidx with a new entry
+	 */
+	if ((loc = get_hashtable_empty_slot(cdev, phtable)) == TBL_FULL) {
+		printk("Hash Table FULL\n");
+		return TBL_FULL;
+	}
+
+	if (loc > MCAST_TABLE_SIZE) {
+		printk("Location got is wrong\n");
+		return FAIL;
+	}
+
+	printk("Got new location %d\n", loc);
+
+	new_table_ptr = &phtable[loc];
+
+	// No session yet in this hashidx, add the first entry
+	if (ret == NO_VALID_HASHENTRY) {
+		printk("ADDING new hash idx = %x first loc %d\n", hashidx, loc);
+		phtable[hashidx].first_idx = loc;
+		set_pce_hash_table(cdev, &phtable[hashidx], hashidx);
+	}
+	// There is already some entry in the hash index, add new one
+	else if (ret == MATCH_NOT_FOUND) {
+
+		printk("MATCH NOT FOUND in hash idx = %x new entry loc %d\n", hashidx, loc);
+
+		table_ptr = &phtable[hashidx];
+		table_ptr = &phtable[table_ptr->first_idx];
+
+		// Find the last entry of the current hash index
+		while (table_ptr->idx != table_ptr->nxt_idx)
+			table_ptr = &phtable[table_ptr->nxt_idx];
+
+		// Update the existing hash last entry's nxt pointer to the new loc.
+		table_ptr->nxt_idx = loc;
+
+		set_pce_hash_table(cdev, table_ptr, table_ptr->idx);
+	}
+
+	memset(&new_table_ptr->key, 0, sizeof(MCAST_HASHTBL_PTN));
+	memset(&new_table_ptr->action, 0, sizeof(MCAST_HASHTBL_ACT));
+
+	// New entry will be the last entry in this hashidx so update the loc to the nxt ptr
+	new_table_ptr->nxt_idx = loc;
+
+	new_table_ptr->valid        = 1;
+
+	if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+		for (i = 0; i < 8; i++) {
+			new_table_ptr->key.srcip.nIPv6[i] = pattern.srcip.nIPv6[i];
+			new_table_ptr->key.dstip.nIPv6[i] = pattern.dstip.nIPv6[i];
+		}
+	} else {
+		new_table_ptr->key.srcip.nIPv4 = pattern.srcip.nIPv4;
+		new_table_ptr->key.dstip.nIPv4 = pattern.dstip.nIPv4;
+	}
+
+	new_table_ptr->ip_type = parm->eIPVersion;
+	new_table_ptr->key.fid = pattern.fid;
+	new_table_ptr->src_ip_mode = parm->eModeMember;
+	new_table_ptr->excl_src_ip = parm->bExclSrcIP;
+
+	if (ret == NO_VALID_HASHENTRY) {
+		// Need to update sub if id only for the first entry
+		new_table_ptr->action.subifid = parm->nSubIfId;
+	}
+
+	update_bridge_pmap(portId, new_table_ptr, SET);
+	set_pce_hash_table(cdev, new_table_ptr, loc);
+
+	printk("Insert Exit %s:%s:%d\n", __FILE__, __func__, __LINE__);
+
+	return loc;
+}
+
+/* If external modules need to search */
+int gsw_search_hashtable_entry(void *cdev, GSW_multicastTable_t *parm, GSW_multicastTableRead_t *read_parm, u32 *loc)
+{
+
+	u32 found_loc = 0, hashidx;
+	int i = 0, ret = 0;
+	u32 portId;
+
+	MCAST_HASHTBL_PTN pattern;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+
+	if (parm->nPortId > gswdev->num_of_bridge_port) {
+		pr_err("PortId only upto %d is supported\n", gswdev->num_of_bridge_port);
+		return FAIL;
+	}
+
+	printk("Enter %s:%s:%d\n", __FILE__, __func__, __LINE__);
+
+	portId = parm->nPortId;
+
+	if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
+		pattern.srcip.nIPv4 = parm->uIP_Gsa.nIPv4;
+		pattern.dstip.nIPv4 = parm->uIP_Gda.nIPv4;
+	} else if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+		for (i = 0; i < 8; i++) {
+			pattern.srcip.nIPv6[i] = parm->uIP_Gsa.nIPv6[7 - i];
+			pattern.dstip.nIPv6[i] = parm->uIP_Gda.nIPv6[7 - i];
+		}
+	}
+
+	pattern.fid = parm->nFID;
+
+	hashidx = cal_hash(parm->eModeMember, &pattern, parm->eIPVersion);
+
+	ret = search_hashtable_entry(hashidx, &pattern, &found_loc);
+
+	if (ret == TABLE_ERROR)
+		printk(":::::: IMPOSSIBLE ::::: TABLE ERROR\n");
+	else if (ret ==  MATCH_FOUND) {
+		*loc = found_loc;
+		gsw_get_swmcast_entry(cdev, read_parm, found_loc);
+	} else if (ret == NO_VALID_HASHENTRY)
+		printk("No Valid Entry to the HASHIDX %x\n", hashidx);
+	// There is already some entry in the hash index, add new one
+	else if (ret == MATCH_NOT_FOUND)
+		printk("MATCH_NOT_FOUND to the HASHIDX %x\n", hashidx);
+
+	return ret;
+}
+
+static int search_hashtable_entry(u32 hashidx, MCAST_HASHTBL_PTN *pattern, u32 *loc)
+{
+	int  i = 0;
+
+	MCAST_HASHTBL  *table_ptr;
+
+	printk("Enter %s:%s:%d\n", __FILE__, __func__, __LINE__);
+
+	printk("SEARCHING session hash idx = %x \n", hashidx);
+
+	table_ptr = &phtable[hashidx];
+
+	if (table_ptr->first_idx == 0xFFFF)
+		return NO_VALID_HASHENTRY;
+
+	// Go Inside the First Ptr
+	table_ptr = &phtable[table_ptr->first_idx];
+
+	for (i = 0; i < MAX_STEP_CNTR; i++) {
+		printk("Searching Idx %d\n", table_ptr->idx);
+
+		if (table_ptr->valid) {
+
+			if (table_ptr->ip_type == GSW_IP_SELECT_IPV6) {
+
+				if ((!memcmp(pattern->srcip.nIPv6, table_ptr->key.srcip.nIPv6, sizeof(pattern->srcip))) &&
+				    (!memcmp(pattern->dstip.nIPv6, table_ptr->key.dstip.nIPv6, sizeof(pattern->dstip))) &&
+				    (pattern->fid == table_ptr->key.fid)) {
+
+					*loc = table_ptr->idx;
+					printk("MATCH_FOUND %s:%s:%d\n", __FILE__, __func__, __LINE__);
+					return MATCH_FOUND;
+				}
+			} else {
+
+				if ((pattern->srcip.nIPv4 == table_ptr->key.srcip.nIPv4) &&
+				    (pattern->dstip.nIPv4 == table_ptr->key.dstip.nIPv4) &&
+				    (pattern->fid == table_ptr->key.fid)) {
+
+					*loc = table_ptr->idx;
+					printk("MATCH_FOUND %s:%s:%d\n", __FILE__, __func__, __LINE__);
+					return MATCH_FOUND;
+				}
+
+			}
+		}
+
+		printk("Current Idx %d Nxt Ptr %d\n", table_ptr->idx, table_ptr->nxt_idx);
+
+		if (table_ptr->idx == table_ptr->nxt_idx) {
+			printk("No match is found\n");
+			return MATCH_NOT_FOUND;
+		}
+
+		table_ptr = &phtable[table_ptr->nxt_idx];
+	}
+
+	printk("MATCH_NOT_FOUND %s:%s:%d\n", __FILE__, __func__, __LINE__);
+
+	return TABLE_ERROR;
+}
+
+static int remove_hashentry(void *cdev, u32 hashidx, u32 rm_idx, u32 portId)
+{
+	u32 i = 0;
+	MCAST_HASHTBL *table_ptr = &phtable[hashidx];
+
+	update_bridge_pmap(portId, &phtable[rm_idx], CLR);
+
+	for (i = 0; i < 16; i++) {
+		if (phtable[rm_idx].action.br_portmap[i])
+			return  UPDATED_BR_PMAP;
+	}
+
+	// Going to remove the entry
+
+	// Go Inside the table
+	table_ptr = &phtable[table_ptr->first_idx];
+
+	if (phtable[rm_idx].nxt_idx == rm_idx) { // we are going to remove the last entry
+		// first entry to the hash is the last entry
+		if (phtable[hashidx].first_idx == rm_idx) {
+			// Indicate there is no valid session to the particular hashidx
+			phtable[hashidx].first_idx = 0xFFFF;
+			set_pce_hash_table(cdev, &phtable[hashidx], hashidx);
+		} else {	// we have atleast 2 entries to the hash
+
+			// Find the previous entry to the current remove entry
+			while (rm_idx != table_ptr->nxt_idx)
+				table_ptr = &phtable[table_ptr->nxt_idx];
+
+			// Update the previous entry as the last entry
+			table_ptr->nxt_idx = table_ptr->idx;
+			set_pce_hash_table(cdev, table_ptr, table_ptr->idx);
+		}
+	}
+	// we are going to remove something in middle
+	else {
+
+		// firt entry to the hash we are going to remove
+		if (phtable[hashidx].first_idx == rm_idx) {
+			// Update the hashidx first ptr entry as the next entry
+			phtable[hashidx].first_idx = table_ptr->nxt_idx;
+			set_pce_hash_table(cdev, &phtable[hashidx], hashidx);
+		} else {
+			// Find the previous entry to the current remove entry
+			while (rm_idx != table_ptr->nxt_idx)
+				table_ptr = &phtable[table_ptr->nxt_idx];
+
+			// Update the previous entry nxt ptr to the next entry after remove entry
+			table_ptr->nxt_idx = phtable[rm_idx].nxt_idx;
+			set_pce_hash_table(cdev, table_ptr, table_ptr->idx);
+		}
+	}
+
+	phtable[rm_idx].valid = 0;
+	phtable[rm_idx].nxt_idx = 0xFFFF;
+
+	return REMOVED_ENTRY;
+}
+
+int gsw_remove_hashtable_entry(void *cdev, GSW_multicastTable_t *parm)
+{
+	u32 hashidx;
+	u32 loc = 0, ret = 0;
+
+	int  i = 0;
+
+	MCAST_HASHTBL  *table_ptr = NULL;
+	MCAST_HASHTBL_PTN pattern;
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	if (parm->nPortId > gswdev->num_of_bridge_port) {
+		pr_err("PortId only upto %d is supported\n", gswdev->num_of_bridge_port);
+		return FAIL;
+	}
+
+	printk("Enter %s:%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
+		pattern.srcip.nIPv4 = parm->uIP_Gsa.nIPv4;
+		pattern.dstip.nIPv4 = parm->uIP_Gda.nIPv4;
+	} else if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+		for (i = 0; i < 8; i++) {
+			pattern.srcip.nIPv6[i] = parm->uIP_Gsa.nIPv6[7 - i];
+			pattern.dstip.nIPv6[i] = parm->uIP_Gda.nIPv6[7 - i];
+		}
+	}
+
+	pattern.fid = parm->nFID;
+
+	hashidx = cal_hash(parm->eModeMember, &pattern, parm->eIPVersion);
+
+	if (MATCH_FOUND != search_hashtable_entry(hashidx, &pattern, &loc))
+		return ENTRY_CANNOT_REMOVE;
+
+	table_ptr = &phtable[loc];
+
+	printk("REMOVING hash idx %x Found loc %d table idx %d\n", hashidx, loc, table_ptr->idx);
+
+	ret = remove_hashentry(cdev, hashidx, loc, parm->nPortId);
+	set_pce_hash_table(cdev, table_ptr, loc);
+
+	if (ret == REMOVED_ENTRY)
+		printk("REMOVED_ENTRY %s:%s:%d\n", __FILE__, __func__, __LINE__);
+	else if (ret == UPDATED_BR_PMAP)
+		printk("UPDATED BR PMAP ENTRY %s:%s:%d\n", __FILE__, __func__, __LINE__);
+	else
+		printk("ENTRY_CANNOT_REMOVE %s:%s:%d\n", __FILE__, __func__, __LINE__);
+
+	return ret;
+
+}
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_swmcast.h b/drivers/net/ethernet/lantiq/switch-api/gsw_swmcast.h
new file mode 100644
index 000000000000..c94a1d05f740
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_swmcast.h
@@ -0,0 +1,73 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+For licensing information, see the file 'LICENSE' in the root folder of
+this software module.
+******************************************************************************/
+
+
+
+
+#ifndef _SW_MCAST_H_
+#define _SW_MCAST_H_
+
+enum _ret {
+	FAIL = -8,
+	NO_VALID_HASHENTRY = -7,
+	TABLE_ERROR = -6,
+	TBL_EMPTY = -5,
+	HASH_CAL_FAIL = -4,
+	TBL_FULL = -3,
+	MATCH_NOT_FOUND = -2,
+	ENTRY_CANNOT_REMOVE = -1,
+	MATCH_FOUND = 0,
+	REMOVED_ENTRY = 1,
+	ENTRY_FOUND = 2,
+	UPDATED_BR_PMAP = 3,
+};
+
+typedef struct mcast_hash_key {
+	GSW_IP_t dstip;        /*!< destination IP address */
+	GSW_IP_t srcip;        /*!< source IP address */
+	u8 fid;
+} MCAST_HASHTBL_PTN;
+
+typedef struct mcast_action_ptr {
+	u16 br_portmap[16];
+	u16 subifid;
+} MCAST_HASHTBL_ACT;
+
+typedef struct compare_hash {
+	u32 idx;
+	u32 ip_type;
+	u32 valid;
+	u32 first_idx;   /*!< first valid compare entry index for this hash index*/
+	u32 nxt_idx;       /*!< next compare entry index in this hash index */
+	GSW_IGMP_MemberMode_t src_ip_mode;
+	u32 excl_src_ip;
+	MCAST_HASHTBL_PTN key;
+	MCAST_HASHTBL_ACT action;
+} MCAST_HASHTBL;
+
+#define MAX_STEP_CNTR 16
+
+#define MCAST_HASHTBL_SIZE sizeof(MCAST_HASHTBL)
+
+#define MCAST_TABLE_SIZE	512
+
+#define MCAST_HWSNOOP_EN	1
+#define MCAST_HWSNOOP_DIS	0
+
+#define SET 1
+#define CLR 0
+
+int gsw_init_hash_table(void *cdev);
+int gsw_insert_hashtable_entry(void *cdev, GSW_multicastTable_t *parm);
+int gsw_search_hashtable_entry(void *cdev, GSW_multicastTable_t *parm, GSW_multicastTableRead_t *read_parm, u32 *loc);
+int gsw_remove_hashtable_entry(void *cdev, GSW_multicastTable_t *parm);
+int gsw_check_hashtable_entry(void *cdev);
+int gsw_get_swmcast_entry(void *cdev, GSW_multicastTableRead_t *parm, u32 loc);
+//void print_table();
+
+#endif
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_tbl_rw.c b/drivers/net/ethernet/lantiq/switch-api/gsw_tbl_rw.c
new file mode 100644
index 000000000000..da016c508d23
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_tbl_rw.c
@@ -0,0 +1,820 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#include <gsw_init.h>
+
+GSW_return_t gsw_bm_table_read(void *cdev, bmtbl_prog_t *ptdata)
+{
+	GSW_return_t err = GSW_statusOk;
+	int i, noOfValues;
+
+	if (ptdata->b64bitMode)
+		ptdata->tableID |= 0x40;
+
+	noOfValues = ptdata->numValues;
+	gsw_w32_raw(cdev, BM_RAM_ADDR_REG_OFFSET, (u32) ptdata->adr.raw);
+	gsw_w32_raw(cdev, BM_RAM_CTRL_REG_OFFSET, ((u32)ptdata->tableID) | 0x8000);
+	CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET, BM_RAM_CTRL_BAS_SHIFT,
+		   BM_RAM_CTRL_BAS_SIZE, RETURN_FROM_FUNCTION);
+
+	for (i = 0; (i < noOfValues) /*&& (GSW_statusOk == err)*/; i++)
+		gsw_r32_raw(cdev, BM_RAM_VAL_0_VAL0_OFFSET - i, &(ptdata->value[i]));
+
+	return err;
+}
+
+GSW_return_t gsw_bm_table_write(void *cdev, bmtbl_prog_t *ptdata)
+{
+	GSW_return_t err = GSW_statusOk;
+	int i, noOfValues;
+
+	if (ptdata->b64bitMode)
+		ptdata->tableID |= 0x40;
+
+	noOfValues = ptdata->numValues;
+	gsw_w32_raw(cdev, BM_RAM_ADDR_REG_OFFSET, (u32) ptdata->adr.raw);
+	gsw_w32_raw(cdev, BM_RAM_CTRL_REG_OFFSET, ((u32)ptdata->tableID) | 0x0020);
+
+	for (i = 0; (i < noOfValues) /*&& (GSW_statusOk == err)*/; i++)
+		gsw_w32_raw(cdev, BM_RAM_VAL_0_VAL0_OFFSET - i, ptdata->value[i]);
+
+	gsw_w32_raw(cdev, BM_RAM_CTRL_REG_OFFSET, ((u32)ptdata->tableID) | 0x8020);
+	CHECK_BUSY(BM_RAM_CTRL_BAS_OFFSET, BM_RAM_CTRL_BAS_SHIFT,
+		   BM_RAM_CTRL_BAS_SIZE, RETURN_FROM_FUNCTION);
+	return err;
+}
+
+u32 pmac_addr_off(u32 off, u32 id)
+{
+
+	if (id == 1)
+		off = off + 0x80;
+	else if (id == 2)
+		off = off + 0x200;
+
+	return off;
+}
+
+int xwayflow_pmac_table_read(void *cdev, pmtbl_prog_t *ptdata)
+{
+	u32 value;
+
+	CHECK_BUSY(pmac_addr_off(PMAC_TBL_CTRL_BAS_OFFSET, ptdata->pmacId),
+		   PMAC_TBL_CTRL_BAS_SHIFT, PMAC_TBL_CTRL_BAS_SIZE, RETURN_FROM_FUNCTION);
+	gsw_w32(cdev, pmac_addr_off(PMAC_TBL_ADDR_ADDR_OFFSET, ptdata->pmacId),
+		PMAC_TBL_ADDR_ADDR_SHIFT,
+		PMAC_TBL_ADDR_ADDR_SIZE, ptdata->ptaddr);
+	gsw_w32(cdev, pmac_addr_off(PMAC_TBL_CTRL_ADDR_OFFSET, ptdata->pmacId),
+		PMAC_TBL_CTRL_ADDR_SHIFT,
+		PMAC_TBL_CTRL_ADDR_SIZE, ptdata->ptcaddr);
+	gsw_w32(cdev, pmac_addr_off(PMAC_TBL_CTRL_OPMOD_OFFSET, ptdata->pmacId),
+		PMAC_TBL_CTRL_OPMOD_SHIFT,
+		PMAC_TBL_CTRL_OPMOD_SIZE, 0 /* ptdata->op_mode */);
+	gsw_w32(cdev, pmac_addr_off(PMAC_TBL_CTRL_BAS_OFFSET, ptdata->pmacId),
+		PMAC_TBL_CTRL_BAS_SHIFT,
+		PMAC_TBL_CTRL_BAS_SIZE, 1);
+	CHECK_BUSY(pmac_addr_off(PMAC_TBL_CTRL_BAS_OFFSET, ptdata->pmacId),
+		   PMAC_TBL_CTRL_BAS_SHIFT, PMAC_TBL_CTRL_BAS_SIZE, RETURN_FROM_FUNCTION);
+	gsw_r32(cdev, pmac_addr_off(PMAC_TBL_VAL_4_VAL4_OFFSET, ptdata->pmacId),
+		PMAC_TBL_VAL_4_VAL4_SHIFT,
+		PMAC_TBL_VAL_4_VAL4_SIZE, &value);
+	ptdata->val[4] = value;
+	gsw_r32(cdev, pmac_addr_off(PMAC_TBL_VAL_3_VAL3_OFFSET, ptdata->pmacId),
+		PMAC_TBL_VAL_3_VAL3_SHIFT,
+		PMAC_TBL_VAL_3_VAL3_SIZE, &value);
+	ptdata->val[3] = value;
+	gsw_r32(cdev, pmac_addr_off(PMAC_TBL_VAL_2_VAL2_OFFSET, ptdata->pmacId),
+		PMAC_TBL_VAL_2_VAL2_SHIFT,
+		PMAC_TBL_VAL_2_VAL2_SIZE, &value);
+	ptdata->val[2] = value;
+	gsw_r32(cdev, pmac_addr_off(PMAC_TBL_VAL_1_VAL1_OFFSET, ptdata->pmacId),
+		PMAC_TBL_VAL_1_VAL1_SHIFT,
+		PMAC_TBL_VAL_1_VAL1_SIZE, &value);
+	ptdata->val[1] = value;
+	gsw_r32(cdev, pmac_addr_off(PMAC_TBL_VAL_0_VAL0_OFFSET, ptdata->pmacId),
+		PMAC_TBL_VAL_0_VAL0_SHIFT,
+		PMAC_TBL_VAL_0_VAL0_SIZE, &value);
+	ptdata->val[0] = value;
+	return 0;
+}
+
+int xwayflow_pmac_table_write(void *cdev, pmtbl_prog_t *ptdata)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+		GSW_Freeze();
+	}
+
+	CHECK_BUSY(pmac_addr_off(PMAC_TBL_CTRL_BAS_OFFSET, ptdata->pmacId),
+		   PMAC_TBL_CTRL_BAS_SHIFT, PMAC_TBL_CTRL_BAS_SIZE, RETURN_FROM_FUNCTION);
+	gsw_w32(cdev, pmac_addr_off(PMAC_TBL_ADDR_ADDR_OFFSET, ptdata->pmacId),
+		PMAC_TBL_ADDR_ADDR_SHIFT,
+		PMAC_TBL_ADDR_ADDR_SIZE, ptdata->ptaddr);
+	gsw_w32(cdev, pmac_addr_off(PMAC_TBL_CTRL_ADDR_OFFSET, ptdata->pmacId),
+		PMAC_TBL_CTRL_ADDR_SHIFT,
+		PMAC_TBL_CTRL_ADDR_SIZE, ptdata->ptcaddr);
+	gsw_w32(cdev, pmac_addr_off(PMAC_TBL_CTRL_OPMOD_OFFSET, ptdata->pmacId),
+		PMAC_TBL_CTRL_OPMOD_SHIFT,
+		PMAC_TBL_CTRL_OPMOD_SIZE, 1 /* ptdata->op_mode */);
+	gsw_w32(cdev, pmac_addr_off(PMAC_TBL_VAL_4_VAL4_OFFSET, ptdata->pmacId),
+		PMAC_TBL_VAL_4_VAL4_SHIFT,
+		PMAC_TBL_VAL_4_VAL4_SIZE, ptdata->val[4]);
+	gsw_w32(cdev, pmac_addr_off(PMAC_TBL_VAL_3_VAL3_OFFSET, ptdata->pmacId),
+		PMAC_TBL_VAL_3_VAL3_SHIFT,
+		PMAC_TBL_VAL_3_VAL3_SIZE, ptdata->val[3]);
+	gsw_w32(cdev, pmac_addr_off(PMAC_TBL_VAL_2_VAL2_OFFSET, ptdata->pmacId),
+		PMAC_TBL_VAL_2_VAL2_SHIFT,
+		PMAC_TBL_VAL_2_VAL2_SIZE, ptdata->val[2]);
+	gsw_w32(cdev, pmac_addr_off(PMAC_TBL_VAL_1_VAL1_OFFSET, ptdata->pmacId),
+		PMAC_TBL_VAL_1_VAL1_SHIFT,
+		PMAC_TBL_VAL_1_VAL1_SIZE, ptdata->val[1]);
+	gsw_w32(cdev, pmac_addr_off(PMAC_TBL_VAL_0_VAL0_OFFSET, ptdata->pmacId),
+		PMAC_TBL_VAL_0_VAL0_SHIFT,
+		PMAC_TBL_VAL_0_VAL0_SIZE, ptdata->val[0]);
+	gsw_w32(cdev, pmac_addr_off(PMAC_TBL_CTRL_BAS_OFFSET, ptdata->pmacId),
+		PMAC_TBL_CTRL_BAS_SHIFT,
+		PMAC_TBL_CTRL_BAS_SIZE, 1);
+	CHECK_BUSY(pmac_addr_off(PMAC_TBL_CTRL_BAS_OFFSET, ptdata->pmacId),
+		   PMAC_TBL_CTRL_BAS_SHIFT, PMAC_TBL_CTRL_BAS_SIZE, RETURN_FROM_FUNCTION);
+
+	if (IS_VRSN_31(gswdev->gipver)) {
+		GSW_UnFreeze();
+	}
+
+	return 0;
+}
+
+int route_table_read(void *cdev, pctbl_prog_t *rdata)
+{
+	u32 value;
+
+	do {
+		gsw_r32(cdev, PCE_RTBL_CTRL_BAS_OFFSET,
+			PCE_RTBL_CTRL_BAS_SHIFT,
+			PCE_RTBL_CTRL_BAS_SIZE, &value);
+	} while (value != 0);
+
+	gsw_w32(cdev, PCE_TBL_ADDR_ADDR_OFFSET,
+		PCE_TBL_ADDR_ADDR_SHIFT,
+		PCE_TBL_ADDR_ADDR_SIZE, rdata->pcindex);
+	gsw_w32(cdev, PCE_RTBL_CTRL_ADDR_OFFSET,
+		PCE_RTBL_CTRL_ADDR_SHIFT,
+		PCE_RTBL_CTRL_ADDR_SIZE, rdata->table);
+	gsw_w32(cdev, PCE_RTBL_CTRL_OPMOD_OFFSET,
+		PCE_RTBL_CTRL_OPMOD_SHIFT,
+		PCE_RTBL_CTRL_OPMOD_SIZE, rdata->op_mode);
+	gsw_w32(cdev, PCE_RTBL_CTRL_BAS_OFFSET,
+		PCE_RTBL_CTRL_BAS_SHIFT,
+		PCE_RTBL_CTRL_BAS_SIZE, 1);
+
+	do {
+		gsw_r32(cdev, PCE_RTBL_CTRL_BAS_OFFSET,
+			PCE_RTBL_CTRL_BAS_SHIFT,
+			PCE_RTBL_CTRL_BAS_SIZE, &value);
+	} while (value != 0);
+
+	gsw_r32(cdev, PCE_TBL_KEY_15_KEY15_OFFSET,
+		PCE_TBL_KEY_15_KEY15_SHIFT,
+		PCE_TBL_KEY_15_KEY15_SIZE, &value);
+	rdata->key[15] = value;
+	gsw_r32(cdev, PCE_TBL_KEY_14_KEY14_OFFSET,
+		PCE_TBL_KEY_14_KEY14_SHIFT,
+		PCE_TBL_KEY_14_KEY14_SIZE, &value);
+	rdata->key[14] = value;
+	gsw_r32(cdev, PCE_TBL_KEY_13_KEY13_OFFSET,
+		PCE_TBL_KEY_13_KEY13_SHIFT,
+		PCE_TBL_KEY_13_KEY13_SIZE, &value);
+	rdata->key[13] = value;
+	gsw_r32(cdev, PCE_TBL_KEY_12_KEY12_OFFSET,
+		PCE_TBL_KEY_12_KEY12_SHIFT,
+		PCE_TBL_KEY_12_KEY12_SIZE, &value);
+	rdata->key[12] = value;
+	gsw_r32(cdev, PCE_TBL_KEY_11_KEY11_OFFSET,
+		PCE_TBL_KEY_11_KEY11_SHIFT,
+		PCE_TBL_KEY_11_KEY11_SIZE, &value);
+	rdata->key[11] = value;
+	gsw_r32(cdev, PCE_TBL_KEY_10_KEY10_OFFSET,
+		PCE_TBL_KEY_10_KEY10_SHIFT,
+		PCE_TBL_KEY_10_KEY10_SIZE, &value);
+	rdata->key[10] = value;
+	gsw_r32(cdev, PCE_TBL_KEY_9_KEY9_OFFSET,
+		PCE_TBL_KEY_9_KEY9_SHIFT,
+		PCE_TBL_KEY_9_KEY9_SIZE, &value);
+	rdata->key[9] = value;
+	gsw_r32(cdev, PCE_TBL_KEY_8_KEY8_OFFSET,
+		PCE_TBL_KEY_8_KEY8_SHIFT,
+		PCE_TBL_KEY_8_KEY8_SIZE, &value);
+	rdata->key[8] = value;
+	gsw_r32(cdev, PCE_TBL_KEY_7_KEY7_OFFSET,
+		PCE_TBL_KEY_7_KEY7_SHIFT,
+		PCE_TBL_KEY_7_KEY7_SIZE, &value);
+	rdata->key[7] = value;
+	gsw_r32(cdev, PCE_TBL_KEY_6_KEY6_OFFSET,
+		PCE_TBL_KEY_6_KEY6_SHIFT,
+		PCE_TBL_KEY_6_KEY6_SIZE, &value);
+	rdata->key[6] = value;
+	gsw_r32(cdev, PCE_TBL_KEY_5_KEY5_OFFSET,
+		PCE_TBL_KEY_5_KEY5_SHIFT,
+		PCE_TBL_KEY_5_KEY5_SIZE, &value);
+	rdata->key[5] = value;
+	gsw_r32(cdev, PCE_TBL_KEY_4_KEY4_OFFSET,
+		PCE_TBL_KEY_4_KEY4_SHIFT,
+		PCE_TBL_KEY_4_KEY4_SIZE, &value);
+	rdata->key[4] = value;
+	gsw_r32(cdev, PCE_TBL_KEY_3_KEY3_OFFSET,
+		PCE_TBL_KEY_3_KEY3_SHIFT,
+		PCE_TBL_KEY_3_KEY3_SIZE, &value);
+	rdata->key[3] = value;
+	gsw_r32(cdev, PCE_TBL_KEY_2_KEY2_OFFSET,
+		PCE_TBL_KEY_2_KEY2_SHIFT,
+		PCE_TBL_KEY_2_KEY2_SIZE, &value);
+	rdata->key[2] = value;
+	gsw_r32(cdev, PCE_TBL_KEY_1_KEY1_OFFSET,
+		PCE_TBL_KEY_1_KEY1_SHIFT,
+		PCE_TBL_KEY_1_KEY1_SIZE, &value);
+	rdata->key[1] = value;
+	gsw_r32(cdev, PCE_TBL_KEY_0_KEY0_OFFSET,
+		PCE_TBL_KEY_0_KEY0_SHIFT,
+		PCE_TBL_KEY_0_KEY0_SIZE, &value);
+	rdata->key[0] = value;
+
+	gsw_r32(cdev, PCE_TBL_VAL_15_VAL15_OFFSET,
+		PCE_TBL_VAL_15_VAL15_SHIFT,
+		PCE_TBL_VAL_15_VAL15_SIZE, &value);
+	rdata->val[15] = value;
+	gsw_r32(cdev, PCE_TBL_VAL_14_VAL14_OFFSET,
+		PCE_TBL_VAL_14_VAL14_SHIFT,
+		PCE_TBL_VAL_14_VAL14_SIZE, &value);
+	rdata->val[14] = value;
+	gsw_r32(cdev, PCE_TBL_VAL_13_VAL13_OFFSET,
+		PCE_TBL_VAL_13_VAL13_SHIFT,
+		PCE_TBL_VAL_13_VAL13_SIZE, &value);
+	rdata->val[13] = value;
+	gsw_r32(cdev, PCE_TBL_VAL_12_VAL12_OFFSET,
+		PCE_TBL_VAL_12_VAL12_SHIFT,
+		PCE_TBL_VAL_12_VAL12_SIZE, &value);
+	rdata->val[12] = value;
+	gsw_r32(cdev, PCE_TBL_VAL_11_VAL11_OFFSET,
+		PCE_TBL_VAL_11_VAL11_SHIFT,
+		PCE_TBL_VAL_11_VAL11_SIZE, &value);
+	rdata->val[11] = value;
+	gsw_r32(cdev, PCE_TBL_VAL_10_VAL10_OFFSET,
+		PCE_TBL_VAL_10_VAL10_SHIFT,
+		PCE_TBL_VAL_10_VAL10_SIZE, &value);
+	rdata->val[10] = value;
+	gsw_r32(cdev, PCE_TBL_VAL_9_VAL9_OFFSET,
+		PCE_TBL_VAL_9_VAL9_SHIFT,
+		PCE_TBL_VAL_9_VAL9_SIZE, &value);
+	rdata->val[9] = value;
+	gsw_r32(cdev, PCE_TBL_VAL_8_VAL8_OFFSET,
+		PCE_TBL_VAL_8_VAL8_SHIFT,
+		PCE_TBL_VAL_8_VAL8_SIZE, &value);
+	rdata->val[8] = value;
+	gsw_r32(cdev, PCE_TBL_VAL_7_VAL7_OFFSET,
+		PCE_TBL_VAL_7_VAL7_SHIFT,
+		PCE_TBL_VAL_7_VAL7_SIZE, &value);
+	rdata->val[7] = value;
+	gsw_r32(cdev, PCE_TBL_VAL_6_VAL6_OFFSET,
+		PCE_TBL_VAL_6_VAL6_SHIFT,
+		PCE_TBL_VAL_6_VAL6_SIZE, &value);
+	rdata->val[6] = value;
+	gsw_r32(cdev, PCE_TBL_VAL_5_VAL5_OFFSET,
+		PCE_TBL_VAL_5_VAL5_SHIFT,
+		PCE_TBL_VAL_5_VAL5_SIZE, &value);
+	rdata->val[5] = value;
+	gsw_r32(cdev, PCE_TBL_VAL_4_VAL4_OFFSET,
+		PCE_TBL_VAL_4_VAL4_SHIFT,
+		PCE_TBL_VAL_4_VAL4_SIZE, &value);
+	rdata->val[4] = value;
+	gsw_r32(cdev, PCE_TBL_VAL_3_VAL3_OFFSET,
+		PCE_TBL_VAL_3_VAL3_SHIFT,
+		PCE_TBL_VAL_3_VAL3_SIZE, &value);
+	rdata->val[3] = value;
+	gsw_r32(cdev, PCE_TBL_VAL_2_VAL2_OFFSET,
+		PCE_TBL_VAL_2_VAL2_SHIFT,
+		PCE_TBL_VAL_2_VAL2_SIZE, &value);
+	rdata->val[2] = value;
+	gsw_r32(cdev, PCE_TBL_VAL_1_VAL1_OFFSET,
+		PCE_TBL_VAL_1_VAL1_SHIFT,
+		PCE_TBL_VAL_1_VAL1_SIZE, &value);
+	rdata->val[1] = value;
+	gsw_r32(cdev, PCE_TBL_VAL_0_VAL0_OFFSET,
+		PCE_TBL_VAL_0_VAL0_SHIFT,
+		PCE_TBL_VAL_0_VAL0_SIZE, &value);
+	rdata->val[0] = value;
+	gsw_r32(cdev, PCE_TBL_MASK_0_MASK0_OFFSET,
+		PCE_TBL_MASK_0_MASK0_SHIFT,
+		PCE_TBL_MASK_0_MASK0_SIZE, &value);
+	rdata->mask[0] = value;
+	gsw_r32(cdev, PCE_RTBL_CTRL_VLD_OFFSET,
+		PCE_RTBL_CTRL_VLD_SHIFT,
+		PCE_RTBL_CTRL_VLD_SIZE, &value);
+	rdata->valid = value;
+	gsw_w32(cdev, PCE_TBL_CTRL_ADDR_OFFSET, 0, 16, 0);
+	return GSW_statusOk;
+}
+
+int route_table_write(void *cdev, pctbl_prog_t *rdata)
+{
+	u32 value;
+	u16 udata;
+
+	do {
+		gsw_r32(cdev, PCE_RTBL_CTRL_BAS_OFFSET,
+			PCE_RTBL_CTRL_BAS_SHIFT,
+			PCE_RTBL_CTRL_BAS_SIZE, &value);
+	} while (value);
+
+	gsw_w32(cdev, PCE_TBL_ADDR_ADDR_OFFSET,
+		PCE_TBL_ADDR_ADDR_SHIFT, PCE_TBL_ADDR_ADDR_SIZE,
+		rdata->pcindex);
+
+	udata = rdata->table;
+	gsw_w32(cdev, PCE_RTBL_CTRL_ADDR_OFFSET,
+		PCE_RTBL_CTRL_ADDR_SHIFT,
+		PCE_RTBL_CTRL_ADDR_SIZE, udata);
+
+	gsw_w32(cdev, PCE_RTBL_CTRL_OPMOD_OFFSET,
+		PCE_RTBL_CTRL_OPMOD_SHIFT,
+		PCE_RTBL_CTRL_OPMOD_SIZE, rdata->op_mode);
+
+	gsw_w32(cdev, PCE_TBL_KEY_15_KEY15_OFFSET,
+		PCE_TBL_KEY_15_KEY15_SHIFT,
+		PCE_TBL_KEY_15_KEY15_SIZE, rdata->key[15]);
+	gsw_w32(cdev, PCE_TBL_KEY_14_KEY14_OFFSET,
+		PCE_TBL_KEY_14_KEY14_SHIFT,
+		PCE_TBL_KEY_14_KEY14_SIZE, rdata->key[14]);
+	gsw_w32(cdev, PCE_TBL_KEY_13_KEY13_OFFSET,
+		PCE_TBL_KEY_13_KEY13_SHIFT,
+		PCE_TBL_KEY_13_KEY13_SIZE, rdata->key[13]);
+	gsw_w32(cdev, PCE_TBL_KEY_12_KEY12_OFFSET,
+		PCE_TBL_KEY_12_KEY12_SHIFT,
+		PCE_TBL_KEY_12_KEY12_SIZE, rdata->key[12]);
+	gsw_w32(cdev, PCE_TBL_KEY_11_KEY11_OFFSET,
+		PCE_TBL_KEY_11_KEY11_SHIFT,
+		PCE_TBL_KEY_11_KEY11_SIZE, rdata->key[11]);
+	gsw_w32(cdev, PCE_TBL_KEY_10_KEY10_OFFSET,
+		PCE_TBL_KEY_10_KEY10_SHIFT,
+		PCE_TBL_KEY_10_KEY10_SIZE, rdata->key[10]);
+	gsw_w32(cdev, PCE_TBL_KEY_9_KEY9_OFFSET,
+		PCE_TBL_KEY_9_KEY9_SHIFT,
+		PCE_TBL_KEY_9_KEY9_SIZE, rdata->key[9]);
+	gsw_w32(cdev, PCE_TBL_KEY_8_KEY8_OFFSET,
+		PCE_TBL_KEY_8_KEY8_SHIFT,
+		PCE_TBL_KEY_8_KEY8_SIZE, rdata->key[8]);
+	gsw_w32(cdev, PCE_TBL_KEY_7_KEY7_OFFSET,
+		PCE_TBL_KEY_7_KEY7_SHIFT,
+		PCE_TBL_KEY_7_KEY7_SIZE, rdata->key[7]);
+	gsw_w32(cdev, PCE_TBL_KEY_6_KEY6_OFFSET,
+		PCE_TBL_KEY_6_KEY6_SHIFT,
+		PCE_TBL_KEY_6_KEY6_SIZE, rdata->key[6]);
+	gsw_w32(cdev, PCE_TBL_KEY_5_KEY5_OFFSET,
+		PCE_TBL_KEY_5_KEY5_SHIFT,
+		PCE_TBL_KEY_5_KEY5_SIZE, rdata->key[5]);
+	gsw_w32(cdev, PCE_TBL_KEY_4_KEY4_OFFSET,
+		PCE_TBL_KEY_4_KEY4_SHIFT,
+		PCE_TBL_KEY_4_KEY4_SIZE, rdata->key[4]);
+	gsw_w32(cdev, PCE_TBL_KEY_3_KEY3_OFFSET,
+		PCE_TBL_KEY_3_KEY3_SHIFT,
+		PCE_TBL_KEY_3_KEY3_SIZE, rdata->key[3]);
+	gsw_w32(cdev, PCE_TBL_KEY_2_KEY2_OFFSET,
+		PCE_TBL_KEY_2_KEY2_SHIFT,
+		PCE_TBL_KEY_2_KEY2_SIZE, rdata->key[2]);
+	gsw_w32(cdev, PCE_TBL_KEY_1_KEY1_OFFSET,
+		PCE_TBL_KEY_1_KEY1_SHIFT,
+		PCE_TBL_KEY_1_KEY1_SIZE, rdata->key[1]);
+	gsw_w32(cdev, PCE_TBL_KEY_0_KEY0_OFFSET,
+		PCE_TBL_KEY_0_KEY0_SHIFT,
+		PCE_TBL_KEY_0_KEY0_SIZE, rdata->key[0]);
+
+	gsw_w32(cdev, PCE_TBL_MASK_0_MASK0_OFFSET,
+		PCE_TBL_MASK_0_MASK0_SHIFT,
+		PCE_TBL_MASK_0_MASK0_SIZE, rdata->mask[0]);
+
+	gsw_w32(cdev, PCE_TBL_VAL_15_VAL15_OFFSET,
+		PCE_TBL_VAL_15_VAL15_SHIFT,
+		PCE_TBL_VAL_15_VAL15_SIZE, rdata->val[15]);
+	gsw_w32(cdev, PCE_TBL_VAL_14_VAL14_OFFSET,
+		PCE_TBL_VAL_14_VAL14_SHIFT,
+		PCE_TBL_VAL_14_VAL14_SIZE, rdata->val[14]);
+	gsw_w32(cdev, PCE_TBL_VAL_13_VAL13_OFFSET,
+		PCE_TBL_VAL_13_VAL13_SHIFT,
+		PCE_TBL_VAL_13_VAL13_SIZE, rdata->val[13]);
+	gsw_w32(cdev, PCE_TBL_VAL_12_VAL12_OFFSET,
+		PCE_TBL_VAL_12_VAL12_SHIFT,
+		PCE_TBL_VAL_12_VAL12_SIZE, rdata->val[12]);
+	gsw_w32(cdev, PCE_TBL_VAL_11_VAL11_OFFSET,
+		PCE_TBL_VAL_11_VAL11_SHIFT,
+		PCE_TBL_VAL_11_VAL11_SIZE, rdata->val[11]);
+	gsw_w32(cdev, PCE_TBL_VAL_10_VAL10_OFFSET,
+		PCE_TBL_VAL_10_VAL10_SHIFT,
+		PCE_TBL_VAL_10_VAL10_SIZE, rdata->val[10]);
+	gsw_w32(cdev, PCE_TBL_VAL_9_VAL9_OFFSET,
+		PCE_TBL_VAL_9_VAL9_SHIFT,
+		PCE_TBL_VAL_9_VAL9_SIZE, rdata->val[9]);
+	gsw_w32(cdev, PCE_TBL_VAL_8_VAL8_OFFSET,
+		PCE_TBL_VAL_8_VAL8_SHIFT,
+		PCE_TBL_VAL_8_VAL8_SIZE, rdata->val[8]);
+	gsw_w32(cdev, PCE_TBL_VAL_7_VAL7_OFFSET,
+		PCE_TBL_VAL_7_VAL7_SHIFT,
+		PCE_TBL_VAL_7_VAL7_SIZE, rdata->val[7]);
+	gsw_w32(cdev, PCE_TBL_VAL_6_VAL6_OFFSET,
+		PCE_TBL_VAL_6_VAL6_SHIFT,
+		PCE_TBL_VAL_6_VAL6_SIZE, rdata->val[6]);
+	gsw_w32(cdev, PCE_TBL_VAL_5_VAL5_OFFSET,
+		PCE_TBL_VAL_5_VAL5_SHIFT,
+		PCE_TBL_VAL_5_VAL5_SIZE, rdata->val[5]);
+	gsw_w32(cdev, PCE_TBL_VAL_4_VAL4_OFFSET,
+		PCE_TBL_VAL_4_VAL4_SHIFT,
+		PCE_TBL_VAL_4_VAL4_SIZE, rdata->val[4]);
+	gsw_w32(cdev, PCE_TBL_VAL_3_VAL3_OFFSET,
+		PCE_TBL_VAL_3_VAL3_SHIFT,
+		PCE_TBL_VAL_3_VAL3_SIZE, rdata->val[3]);
+	gsw_w32(cdev, PCE_TBL_VAL_2_VAL2_OFFSET,
+		PCE_TBL_VAL_2_VAL2_SHIFT,
+		PCE_TBL_VAL_2_VAL2_SIZE, rdata->val[2]);
+	gsw_w32(cdev, PCE_TBL_VAL_1_VAL1_OFFSET,
+		PCE_TBL_VAL_1_VAL1_SHIFT,
+		PCE_TBL_VAL_1_VAL1_SIZE, rdata->val[1]);
+	gsw_w32(cdev, PCE_TBL_VAL_0_VAL0_OFFSET,
+		PCE_TBL_VAL_0_VAL0_SHIFT,
+		PCE_TBL_VAL_0_VAL0_SIZE, rdata->val[0]);
+	gsw_w32(cdev, PCE_RTBL_CTRL_VLD_OFFSET,
+		PCE_RTBL_CTRL_VLD_SHIFT,
+		PCE_RTBL_CTRL_VLD_SIZE, rdata->valid);
+	gsw_w32(cdev, PCE_RTBL_CTRL_BAS_OFFSET,
+		PCE_RTBL_CTRL_BAS_SHIFT,
+		PCE_RTBL_CTRL_BAS_SIZE, 1);
+
+	do {
+		gsw_r32(cdev, PCE_RTBL_CTRL_BAS_OFFSET,
+			PCE_RTBL_CTRL_BAS_SHIFT,
+			PCE_RTBL_CTRL_BAS_SIZE, &value);
+	} while (value != 0);
+
+	gsw_w32(cdev, PCE_TBL_CTRL_ADDR_OFFSET, 0, 16, 0);
+	return GSW_statusOk;
+}
+
+int gsw_pce_table_write(void *cdev, pctbl_prog_t *ptdata)
+{
+	u32 ctrlval;
+	u16 i, j;
+	//pr_err("Enter table write\n");
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("\n%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	do {
+		gsw_r32_raw(cdev, PCE_TBL_CTRL_BAS_OFFSET, &ctrlval);
+	} while (gsw_field_r32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
+			       PCE_TBL_CTRL_BAS_SIZE));
+
+	gsw_w32_raw(cdev, PCE_TBL_ADDR_ADDR_OFFSET, ptdata->pcindex);
+	/*TABLE ADDRESS*/
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_ADDR_SHIFT,
+				PCE_TBL_CTRL_ADDR_SIZE, ptdata->table);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_OPMOD_SHIFT,
+				PCE_TBL_CTRL_OPMOD_SIZE, PCE_OP_MODE_ADWR);
+	/*KEY REG*/
+	j = gswdev->pce_tbl_info[ptdata->table].num_key;
+
+	if (ptdata->kformat)
+		j *= 4;
+
+	for (i = 0; i < j; i++) {
+		gsw_w32_raw(cdev, gswdev->pce_tbl_reg.key[i], ptdata->key[i]);
+	}
+
+	/*MASK REG*/
+	j = gswdev->pce_tbl_info[ptdata->table].num_mask;
+
+	for (i = 0; i < j; i++) {
+		gsw_w32_raw(cdev, gswdev->pce_tbl_reg.mask[i], ptdata->mask[i]);
+	}
+
+	/*VAL REG*/
+	j = gswdev->pce_tbl_info[ptdata->table].num_val;
+
+	for (i = 0; i < j; i++) {
+		gsw_w32_raw(cdev, gswdev->pce_tbl_reg.value[i], ptdata->val[i]);
+//		printk("gswdev->pce_tbl_reg.value[%d] =%x\n", i, gswdev->pce_tbl_reg.value[i]);
+//		printk("ptdata->val[%d] =%x\n", i, ptdata->val[i]);
+	}
+
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_KEYFORM_SHIFT,
+				PCE_TBL_CTRL_KEYFORM_SIZE, ptdata->kformat);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_TYPE_SHIFT,
+				PCE_TBL_CTRL_TYPE_SIZE, ptdata->type);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_VLD_SHIFT,
+				PCE_TBL_CTRL_VLD_SIZE, ptdata->valid);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_GMAP_SHIFT,
+				PCE_TBL_CTRL_GMAP_SIZE, ptdata->group);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
+				PCE_TBL_CTRL_BAS_SIZE, 1);
+	gsw_w32_raw(cdev, PCE_TBL_CTRL_BAS_OFFSET, ctrlval);
+
+	do {
+		gsw_r32_raw(cdev, PCE_TBL_CTRL_BAS_OFFSET, &ctrlval);
+	} while (gsw_field_r32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
+			       PCE_TBL_CTRL_BAS_SIZE));
+
+	gsw_w32_raw(cdev, PCE_TBL_CTRL_ADDR_OFFSET, 0);
+	//pr_err("Exit table write\n");
+
+	return GSW_statusOk;
+}
+
+int gsw_pce_table_read(void *cdev, pctbl_prog_t *ptdata)
+{
+	u32 ctrlval, value;
+	u16 i, j;
+	//pr_err("Enter table read\n");
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("\n%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	do {
+		gsw_r32_raw(cdev, PCE_TBL_CTRL_BAS_OFFSET, &ctrlval);
+	} while (gsw_field_r32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
+			       PCE_TBL_CTRL_BAS_SIZE));
+
+	gsw_w32_raw(cdev, PCE_TBL_ADDR_ADDR_OFFSET, ptdata->pcindex);
+	/*TABLE ADDRESS*/
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_ADDR_SHIFT,
+				PCE_TBL_CTRL_ADDR_SIZE, ptdata->table);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_OPMOD_SHIFT,
+				PCE_TBL_CTRL_OPMOD_SIZE, PCE_OP_MODE_ADRD);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_KEYFORM_SHIFT,
+				PCE_TBL_CTRL_KEYFORM_SIZE, ptdata->kformat);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
+				PCE_TBL_CTRL_BAS_SIZE, 1);
+	gsw_w32_raw(cdev, PCE_TBL_CTRL_BAS_OFFSET, ctrlval);
+
+	do {
+		gsw_r32_raw(cdev, PCE_TBL_CTRL_BAS_OFFSET, &ctrlval);
+	} while (gsw_field_r32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
+			       PCE_TBL_CTRL_BAS_SIZE));
+
+	/*KEY REG*/
+	j = gswdev->pce_tbl_info[ptdata->table].num_key;
+
+	if (ptdata->kformat)
+		j *= 4;
+
+	for (i = 0; i < j; i++) {
+		gsw_r32_raw(cdev, gswdev->pce_tbl_reg.key[i], &value);
+		ptdata->key[i] = value;
+	}
+
+	/*MASK REG*/
+	j = gswdev->pce_tbl_info[ptdata->table].num_mask;
+
+	for (i = 0; i < j; i++) {
+		gsw_r32_raw(cdev, gswdev->pce_tbl_reg.mask[i], &value);
+		ptdata->mask[i] = value;
+	}
+
+	/*VAL REG*/
+	j = gswdev->pce_tbl_info[ptdata->table].num_val;
+
+	for (i = 0; i < j; i++) {
+		gsw_r32_raw(cdev, gswdev->pce_tbl_reg.value[i], &value);
+		ptdata->val[i] = value;
+	}
+
+	ptdata->type = gsw_field_r32(ctrlval, PCE_TBL_CTRL_TYPE_SHIFT,
+				     PCE_TBL_CTRL_TYPE_SIZE);
+	ptdata->valid = gsw_field_r32(ctrlval, PCE_TBL_CTRL_VLD_SHIFT,
+				      PCE_TBL_CTRL_VLD_SIZE);
+	ptdata->group = gsw_field_r32(ctrlval, PCE_TBL_CTRL_GMAP_SHIFT,
+				      PCE_TBL_CTRL_GMAP_SIZE);
+	gsw_w32_raw(cdev, PCE_TBL_CTRL_ADDR_OFFSET, 0);
+	//pr_err("Exit table read\n");
+
+	return GSW_statusOk;
+}
+
+int gsw_pce_table_key_read(void *cdev, pctbl_prog_t *ptdata)
+{
+	u32 ctrlval, value;
+	u16 i, j;
+	//pr_err("Enter table key read\n");
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("\n%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	do {
+		gsw_r32_raw(cdev, PCE_TBL_CTRL_BAS_OFFSET, &ctrlval);
+	} while (gsw_field_r32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
+			       PCE_TBL_CTRL_BAS_SIZE));
+
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_ADDR_SHIFT,
+				PCE_TBL_CTRL_ADDR_SIZE, ptdata->table);
+
+	/*KEY REG*/
+	j = gswdev->pce_tbl_info[ptdata->table].num_key;
+
+	for (i = 0; i < j; i++) {
+		gsw_w32_raw(cdev, gswdev->pce_tbl_reg.key[i], ptdata->key[i]);
+	}
+
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_OPMOD_SHIFT,
+				PCE_TBL_CTRL_OPMOD_SIZE, PCE_OP_MODE_KSRD);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_KEYFORM_SHIFT,
+				PCE_TBL_CTRL_KEYFORM_SIZE, 0);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
+				PCE_TBL_CTRL_BAS_SIZE, 1);
+	gsw_w32_raw(cdev, PCE_TBL_CTRL_BAS_OFFSET, ctrlval);
+
+	do {
+		gsw_r32_raw(cdev, PCE_TBL_CTRL_BAS_OFFSET, &ctrlval);
+	} while (gsw_field_r32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
+			       PCE_TBL_CTRL_BAS_SIZE));
+
+	/*VAL REG*/
+	j = gswdev->pce_tbl_info[ptdata->table].num_val;
+
+	for (i = 0; i < j; i++) {
+		gsw_r32_raw(cdev, gswdev->pce_tbl_reg.value[i], &value);
+		ptdata->val[i] = value;
+	}
+
+	ptdata->type = gsw_field_r32(ctrlval, PCE_TBL_CTRL_TYPE_SHIFT,
+				     PCE_TBL_CTRL_TYPE_SIZE);
+	ptdata->valid = gsw_field_r32(ctrlval, PCE_TBL_CTRL_VLD_SHIFT,
+				      PCE_TBL_CTRL_VLD_SIZE);
+	ptdata->group = gsw_field_r32(ctrlval, PCE_TBL_CTRL_GMAP_SHIFT,
+				      PCE_TBL_CTRL_GMAP_SIZE);
+	gsw_r32_raw(cdev, PCE_TBL_ADDR_ADDR_OFFSET, &value);
+	ptdata->pcindex = value;
+	gsw_w32_raw(cdev, PCE_TBL_CTRL_ADDR_OFFSET, 0);
+	//pr_err("Exit table key read\n");
+
+	return GSW_statusOk;
+}
+
+int gsw_pce_table_key_write(void *cdev, pctbl_prog_t *ptdata)
+{
+	u32 ctrlval;
+	u16 i, j;
+	//pr_err("Enter table key write\n");
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+
+	if (gswdev == NULL) {
+		pr_err("\n%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	do {
+		gsw_r32_raw(cdev, PCE_TBL_CTRL_BAS_OFFSET, &ctrlval);
+	} while (gsw_field_r32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
+			       PCE_TBL_CTRL_BAS_SIZE));
+
+	/*TABLE ADDRESS*/
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_ADDR_SHIFT,
+				PCE_TBL_CTRL_ADDR_SIZE, ptdata->table);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_OPMOD_SHIFT,
+				PCE_TBL_CTRL_OPMOD_SIZE, PCE_OP_MODE_KSWR);
+
+	/*KEY REG*/
+	j = gswdev->pce_tbl_info[ptdata->table].num_key;
+
+	for (i = 0; i < j; i++) {
+		gsw_w32_raw(cdev, gswdev->pce_tbl_reg.key[i], ptdata->key[i]);
+	}
+
+	/*MASK REG*/
+	j = gswdev->pce_tbl_info[ptdata->table].num_mask;
+
+	for (i = 0; i < j; i++) {
+		gsw_w32_raw(cdev, gswdev->pce_tbl_reg.mask[i], ptdata->mask[i]);
+	}
+
+	/*VAL REG*/
+	j = gswdev->pce_tbl_info[ptdata->table].num_val;
+
+	for (i = 0; i < j; i++) {
+		gsw_w32_raw(cdev, gswdev->pce_tbl_reg.value[i], ptdata->val[i]);
+	}
+
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_KEYFORM_SHIFT,
+				PCE_TBL_CTRL_KEYFORM_SIZE, 0);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_TYPE_SHIFT,
+				PCE_TBL_CTRL_TYPE_SIZE, ptdata->type);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_VLD_SHIFT,
+				PCE_TBL_CTRL_VLD_SIZE, ptdata->valid);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_GMAP_SHIFT,
+				PCE_TBL_CTRL_GMAP_SIZE, ptdata->group);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
+				PCE_TBL_CTRL_BAS_SIZE, 1);
+	gsw_w32_raw(cdev, PCE_TBL_CTRL_BAS_OFFSET, ctrlval);
+
+	do {
+		gsw_r32_raw(cdev, PCE_TBL_CTRL_BAS_OFFSET, &ctrlval);
+	} while (gsw_field_r32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
+			       PCE_TBL_CTRL_BAS_SIZE));
+
+	gsw_w32_raw(cdev, PCE_TBL_CTRL_ADDR_OFFSET, 0);
+	//pr_err("Exit table key write\n");
+
+	return GSW_statusOk;
+}
+
+
+GSW_return_t GSW_DumpTable(void *cdev, GSW_table_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	struct core_ops *gsw_ops;
+
+
+	gsw_ops = cdev;
+
+	if (parm->tbl_id == 1) {
+		memset(&parm->ptdata, 0, sizeof(parm->ptdata));
+
+		parm->ptdata.pcindex = parm->tbl_entry;
+		parm->ptdata.table = parm->tbl_addr;
+#ifdef __KERNEL__
+		spin_lock_bh(&gswdev->lock_pce);
+#endif
+		gsw_pce_table_read(gsw_ops, &parm->ptdata);
+
+#ifdef __KERNEL__
+		spin_unlock_bh(&gswdev->lock_pce);
+#endif
+
+	}
+
+	if (parm->tbl_id == 2) {
+		memset(&parm->ptdata, 0, sizeof(parm->ptdata));
+
+		parm->ptdata.pcindex = parm->tbl_entry;
+		parm->ptdata.table = parm->tbl_addr;
+
+#ifdef __KERNEL__
+		spin_lock_bh(&gswdev->lock_pce);
+#endif
+		route_table_read(gsw_ops, &parm->ptdata);
+
+#ifdef __KERNEL__
+		spin_unlock_bh(&gswdev->lock_pce);
+#endif
+
+	}
+
+	if (parm->tbl_id == 3) {
+		memset(&parm->bmtable, 0, sizeof(parm->bmtable));
+
+		parm->bmtable.adr.raw = parm->tbl_entry;
+		parm->bmtable.tableID = parm->tbl_addr;
+		parm->bmtable.numValues = parm->bm_numValues;
+
+#ifdef __KERNEL__
+		spin_lock_bh(&gswdev->lock_bm);
+#endif
+		gsw_bm_table_read(gsw_ops, &parm->bmtable);
+
+#ifdef __KERNEL__
+		spin_unlock_bh(&gswdev->lock_bm);
+#endif
+
+	}
+
+	if (parm->tbl_id == 4) {
+		memset(&parm->pmactable, 0, sizeof(parm->pmactable));
+
+		parm->pmactable.pmacId = parm->tbl_entry;
+		parm->pmactable.ptcaddr = parm->tbl_addr;
+
+#ifdef __KERNEL__
+		spin_lock_bh(&gswdev->lock_pmac);
+#endif
+		xwayflow_pmac_table_read(gsw_ops, &parm->pmactable);
+
+#ifdef __KERNEL__
+		spin_unlock_bh(&gswdev->lock_pmac);
+#endif
+	}
+
+	return GSW_statusOk;
+}
+
+
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/gswip_dev/Makefile b/drivers/net/ethernet/lantiq/switch-api/gswip_dev/Makefile
new file mode 100644
index 000000000000..0067851d798d
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gswip_dev/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for GSWIP Framework
+#
+
+EXTRA_CFLAGS += -I$(src)/ -I$(src)/../ -I$(src)/../mac/
+obj-$(CONFIG_LTQ_ETHSW_API) += gsw_dev.o
diff --git a/drivers/net/ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c b/drivers/net/ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c
new file mode 100644
index 000000000000..af838fd30d20
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c
@@ -0,0 +1,769 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ * This driver is the Parent GSWIP Subsystem driver, which Parses Device
+ * Tree and starts multiple functional drivers for GSWIP.
+ ******************************************************************************/
+
+#include <lantiq_soc.h>
+#include <net/switch_api/gsw_dev.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/reset.h>
+#include <xgmac_common.h>
+#include <gswss_api.h>
+#include <gsw_flow_core.h>
+
+#define GRX500_MACH_NAME        "lantiq,xrx500"
+#define FALC_MACH_NAME          "intel,falconmx"
+#define DEVID_STR               "intel,gsw-devid"
+
+/* Structure for GSWIP Subsystem operations
+ * used to start Sub-Functional Drivers
+ */
+struct gsw_cell {
+	char                      name[128];
+	int                       cell_id;
+	u32                       device_id;
+	u32                       prod_id;
+	/* platform data passed to the sub devices drivers */
+	void                      *platform_data;
+	u32                       pdata_size;
+
+	/* Driver data passed to the sub devices drivers */
+	void                      *drv_data;
+	u32                       drv_data_size;
+
+	/*  Device Tree compatible string*/
+	const char                *of_compatible;
+	/* hese resources can be specified relative to the parent device.
+	 * For accessing hardware you should use resources from the platform dev
+	 */
+	u32                       num_resources;
+	struct resource           *resources;
+	struct device_node        *of_node;
+};
+
+/* Globals */
+#ifdef CONFIG_OF
+static struct gsw_cell *gsw_dev_cells;
+#else
+
+/* Static declaration of Resources when device tree is not present */
+static struct resource falc_macsec_res[] = {
+	/* Macsec Ingress Instance 0 */
+	{
+		.start	= 0x18400000,
+		.end	= 0x18420000,
+		.flags	= IORESOURCE_MEM,
+	},
+	/* Macsec Egress Instance 1 */
+	{
+		.start	= 0x18420000,
+		.end	= 0x18420000,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct resource falc_mac_res[] = {
+	/* Adaption Resources */
+	{
+		.start	= 0x18440000,
+		.end	= 0x18442000,
+		.flags	= IORESOURCE_MEM,
+	},
+	/* LMAC resources */
+	{
+		.start	= 0x18442000,
+		.end	= 0x18443000,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct resource falc_core_res[] = {
+	/* GSW_CORE resources */
+	{
+		.start	= 0x18445000,
+		.end	= 0x18444000,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct resource grx500_core_res_l[] = {
+	/* GSW_CORE resources L */
+	{
+		.start	= 0x1C000000,
+		.end	= 0x1C003000,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct resource grx500_core_res_r[] = {
+	/* GSW_CORE resources R */
+	{
+		.start	= 0x1A000000,
+		.end	= 0x1A003000,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+/* Multi Functional Devices inside GSWIP Sub-System
+ * for product Falcon-Mx
+ */
+static struct gsw_cell gsw_dev_cells[] = {
+	/* MAC 0 */
+	{
+		.name = MAC_DEV_NAME,
+		.cell_id = 0,
+		.device_id = 0,
+		.prod_id = FALCONMX,
+		.of_compatible = "intel,gsw_mac",
+		.num_resources = ARRAY_SIZE(falc_mac_res),
+		.resources = &falc_mac_res;
+	},
+	/* MAC 1 */
+	{
+		.name = MAC_DEV_NAME,
+		.cell_id = 1,
+		.device_id = 0,
+		.prod_id = FALCONMX,
+		.of_compatible = "intel,gsw_mac",
+		.num_resources = ARRAY_SIZE(falc_mac_res),
+		.resources = &falc_mac_res;
+	},
+	/* MAC 2 */
+	{
+		.name = MAC_DEV_NAME,
+		.cell_id = 2,
+		.device_id = 0,
+		.prod_id = FALCONMX,
+		.of_compatible = "intel,gsw_mac",
+		.num_resources = ARRAY_SIZE(falc_mac_res),
+		.resources = &falc_mac_res;
+
+	},
+	/* GSW CORE L or Falcon Mx */
+	{
+		.name = CORE_DEV_NAME,
+		.cell_id = 3,
+		.device_id = 0,
+		.prod_id = FALCONMX,
+		.of_compatible = "intel,gsw_core",
+		.num_resources = ARRAY_SIZE(falc_core_res),
+		.resources = &falc_core_res;
+
+	},
+
+};
+#endif
+
+struct gswss gsw_dev[MAX_GSWDEV];
+
+struct reset_control *gsw_reset_get(struct platform_device *pdev)
+{
+	struct reset_control *gsw_rst;
+
+	gsw_rst = devm_reset_control_get(&pdev->dev, "gswip");
+
+	if (IS_ERR(gsw_rst))
+		return NULL;
+
+	return gsw_rst;
+}
+
+static void gsw_rst(struct reset_control *gsw_rst)
+{
+	reset_control_assert(gsw_rst);
+	/* Make sure one micro-second delay */
+	udelay(1);
+	reset_control_deassert(gsw_rst);
+}
+
+static int gsw_remove_data(u32 devid)
+{
+	int i = 0;
+	struct mac_prv_data *mac_pdata = NULL;
+	ethsw_api_dev_t *core_pdata = NULL;
+
+	for (i = 0; i < gsw_dev[devid].num_devs; i++) {
+		if (gsw_dev_cells[i].drv_data) {
+			if (!strcmp(gsw_dev_cells[i].name, MAC_DEV_NAME)) {
+				mac_pdata =
+					container_of(gsw_dev_cells[i].drv_data,
+						     struct mac_prv_data,
+						     ops);
+				kfree(mac_pdata);
+			} else if (!strcmp(gsw_dev_cells[i].name, CORE_DEV_NAME)) {
+				core_pdata =
+					container_of(gsw_dev_cells[i].drv_data,
+						     ethsw_api_dev_t,
+						     ops);
+				kfree(core_pdata);
+			}
+		}
+
+		if (gsw_dev_cells[i].platform_data)
+			kfree(gsw_dev_cells[i].platform_data);
+
+		if (gsw_dev_cells[i].resources)
+			kfree(gsw_dev_cells[i].resources);
+	}
+
+	if (gsw_dev_cells)
+		kfree(gsw_dev_cells);
+
+	return 0;
+}
+
+static int gsw_add_macdev(struct gsw_cell *gsw_dev_cell, u32 devid)
+{
+	struct mac_prv_data *mac_pdata;
+	int ret = 0;
+	struct resource irqres;
+
+	/* Allocate the private data for MAC */
+	mac_pdata = kzalloc(sizeof(struct mac_prv_data), GFP_KERNEL);
+
+	if (!mac_pdata)
+		return -ENOMEM;
+
+	/* Copy the initial values of MAC Private Data */
+	xgmac_init_pdata(mac_pdata, (int)gsw_dev[devid].mac_subdevs_cnt);
+
+#ifdef CONFIG_OF
+	/* Retrieve the phymode */
+	ret = of_property_read_string(gsw_dev_cell->of_node, "phy-mode",
+				      &mac_pdata->phy_mode);
+
+	of_irq_to_resource_table(gsw_dev_cell->of_node, &irqres, 1);
+
+	mac_pdata->irq_num = irqres.start;
+
+	/* Retrieve the speedset */
+	ret = of_property_read_u32(gsw_dev_cell->of_node, "speed",
+				   &mac_pdata->phy_speed);
+#else
+
+	if (gsw_dev[devid].prod_id & FALCONMX) {
+		gsw_dev_cell->num_resources = ARRAY_SIZE(falc_mac_res);
+		gsw_dev_cell->resources = falc_mac_res;
+	}
+
+#endif
+
+	gsw_dev_cell->drv_data = (void *)(&mac_pdata->ops);
+	gsw_dev_cell->drv_data_size = sizeof(mac_pdata->ops);
+
+	return ret;
+}
+
+static int gsw_add_switchdev(struct gsw_cell *gsw_dev_cell, u32 devid)
+{
+	ethsw_api_dev_t *switch_pdata = NULL;
+	int ret = 0;
+	struct resource irqres;
+
+	/* Allocate the private data for Switch */
+	switch_pdata = kzalloc(sizeof(ethsw_api_dev_t), GFP_KERNEL);
+
+	if (!switch_pdata)
+		return -ENOMEM;
+
+	gsw_dev_cell->drv_data = (void *)(&switch_pdata->ops);
+	gsw_dev_cell->drv_data_size = sizeof(switch_pdata->ops);
+
+	of_irq_to_resource_table(gsw_dev_cell->of_node, &irqres, 1);
+	switch_pdata->irq_num = irqres.start;
+
+#ifndef CONFIG_OF
+
+	if (gsw_dev[devid].prod_id == GRX500) {
+		if (gsw_dev_cell->device_id == 0) {
+			gsw_dev_cell->num_resources =
+				ARRAY_SIZE(grx500_core_res_l);
+			gsw_dev_cell->resources = grx500_core_res_l;
+		} else if (gsw_dev_cell->device_id == 1) {
+			gsw_dev_cell->num_resources =
+				ARRAY_SIZE(grx500_core_res_r);
+			gsw_dev_cell->resources = grx500_core_res_r;
+		}
+	}
+
+	if (gsw_dev[devid].prod_id == FALCONMX) {
+		gsw_dev_cell->num_resources = ARRAY_SIZE(falc_core_res);
+		gsw_dev_cell->resources = falc_core_res;
+	}
+
+#endif
+
+	return ret;
+}
+
+static int update_gsw_dev_cell(struct device_node *np,
+			       int idx,
+			       u32 devid,
+			       int prod_id)
+{
+
+	int ret = 0, r = 0;
+
+	ret = of_property_read_string(np,
+				      "compatible",
+				      &gsw_dev_cells[idx].of_compatible);
+	ret = of_property_read_u32(np,
+				   "num_resources",
+				   &gsw_dev_cells[idx].num_resources);
+
+	if (ret)
+		goto failed;
+
+	strncpy(gsw_dev_cells[idx].name, np->name, 
+		ARRAY_SIZE(gsw_dev_cells[idx].name));
+
+	gsw_dev_cells[idx].of_node = np;
+
+	gsw_dev_cells[idx].cell_id = idx;
+
+	/* All node in this GSWSS will have same device id and prod id
+	 */
+	gsw_dev_cells[idx].device_id = devid;
+	gsw_dev_cells[idx].prod_id = prod_id;
+
+	/* Store the product id in gsw_dev structure
+	   Individual drivers can get this info from parent driver data
+	 */
+	gsw_dev[devid].prod_id = gsw_dev_cells[idx].prod_id;
+
+	if (gsw_dev_cells[idx].num_resources) {
+		gsw_dev_cells[idx].resources =
+			kzalloc((sizeof(struct resource) *
+				 (gsw_dev_cells[idx].num_resources)),
+				GFP_KERNEL);
+
+		if (!gsw_dev_cells[idx].resources)
+			return -ENOMEM;
+
+		for (r = 0; r < gsw_dev_cells[idx].num_resources; r++) {
+			if (of_address_to_resource(np, r,
+						   &gsw_dev_cells[idx].resources[r]))
+				goto failed;
+		}
+	}
+
+	if (of_node_cmp(np->name, MAC_DEV_NAME) == 0) {
+		ret = gsw_add_macdev(&gsw_dev_cells[idx], devid);
+
+		if (ret)
+			goto failed;
+
+		gsw_dev[devid].mac_subdevs_cnt++;
+	} else if (of_node_cmp(np->name, CORE_DEV_NAME) == 0) {
+		ret = gsw_add_switchdev(&gsw_dev_cells[idx], devid);
+
+		if (ret)
+			goto failed;
+	}
+
+	return 0;
+failed:
+	return ret;
+}
+
+#ifdef CONFIG_OF
+static int gsw_parse_dt(struct device_node *base_node)
+{
+	struct device_node *np = NULL;
+	int idx = 0, ret = 0, prod_id = 0;
+	u32 devid = 0;
+
+	/* Get the Product ID */
+	if (of_machine_is_compatible(GRX500_MACH_NAME))
+		prod_id |= GRX500;
+
+	if (of_machine_is_compatible(FALC_MACH_NAME))
+		prod_id |= FALCONMX;
+
+	if (!prod_id) {
+		printk("Cannot find the Product ID\n");
+		return -1;
+	}
+
+	/* Get the GSWIP device ID */
+	if ((!base_node) ||
+	    of_property_read_u32(base_node, DEVID_STR, &devid)) {
+		printk("Cannot find the Device ID\n");
+		return -1;
+	}
+
+	memset(&gsw_dev[devid], 0, sizeof(gsw_dev));
+
+	for_each_child_of_node(base_node, np) {
+		gsw_dev[devid].num_devs++;
+	}
+
+	gsw_dev_cells =
+		kzalloc((sizeof(struct gsw_cell) * (gsw_dev[devid].num_devs)),
+			GFP_KERNEL);
+
+	if (!gsw_dev_cells)
+		return -ENOMEM;
+
+	idx = 0;
+
+	for_each_child_of_node(base_node, np) {
+		ret = update_gsw_dev_cell(np, idx, devid, prod_id);
+
+		if (ret != 0)
+			goto failed;
+
+		idx++;
+	}
+
+	return 0;
+failed:
+	gsw_remove_data(devid);
+
+	return -1;
+}
+#else
+
+static int gsw_parse_dt(struct device_node *base_node)
+{
+	int idx = 0;
+	u32 devid = gsw_dev_cells[0].device_id;
+
+	memset(&gsw_dev[devid], 0, sizeof(gsw_dev));
+
+	gsw_dev[devid].num_devs = ARRAY_SIZE(gsw_dev_cells);
+
+	/* Store the product id in gsw_dev structure
+	 * Individual drivers can get this info from parent driver data
+	 */
+	gsw_dev[devid].prod_id = gsw_dev_cells[0].prod_id;
+
+	for (idx = 0; idx < ARRAY_SIZE(gsw_dev_cells); idx++) {
+		if (strcmp(gsw_dev_cells[idx].name, MAC_DEV_NAME) == 0) {
+			gsw_add_macdev(&gsw_dev_cells[idx], devid);
+			gsw_dev[devid].mac_subdevs_cnt++;
+		} else if (strcmp(gsw_dev_cells[idx].name, CORE_DEV_NAME) == 0)
+			gsw_add_switchdev(&gsw_dev_cells[idx], devid);
+
+	}
+
+	return 0;
+
+}
+#endif
+
+static int init_adapt_prvdata(int devid)
+{
+	struct adap_prv_data *adap_pdata = NULL;
+
+	/* Allocate the Adaption Private Data */
+	adap_pdata = kzalloc(sizeof(struct adap_prv_data), GFP_KERNEL);
+
+	if (!adap_pdata) {
+		printk("%s: Failed to allocate Adaption Private Data \n",
+		       __func__);
+		return -ENOMEM;
+	}
+
+	adap_pdata->ss_addr_base = 0;
+
+	gsw_dev[devid].adap_ops = (void *)&adap_pdata->ops;
+
+	/* Initialize Adaption Spin lock */
+	spin_lock_init(&adap_pdata->adap_lock);
+
+	/* Init Adaption layer function pointers */
+	gswss_init_fn_ptrs(&adap_pdata->ops);
+
+	return 0;
+}
+
+static int gsw_remove_devices(struct device *parent)
+{
+	struct gswss *gswdev = dev_get_drvdata(parent);
+	int i = 0;
+
+	gsw_remove_data(parent->id);
+
+	if (gswdev->adap_ops)
+		kfree(gswdev->adap_ops);
+
+	if (gswdev->core_dev)
+		platform_device_put(gswdev->core_dev);
+
+	for (i = 0; i < gswdev->mac_subdevs_cnt; i++)
+		platform_device_put(gswdev->mac_dev[i]);
+
+	return 0;
+}
+
+static int gsw_add_device(struct device *parent, int id,
+			  struct gsw_cell *cell,
+			  struct resource *mem_base,
+			  int irq_base)
+{
+	struct resource *res;
+	struct platform_device *pdev;
+	int ret = -ENOMEM;
+	int platform_id;
+	int r;
+
+	if (id == PLATFORM_DEVID_AUTO)
+		platform_id = id;
+	else
+		platform_id = id + cell->cell_id;
+
+	pdev = platform_device_alloc(cell->name, platform_id);
+
+	if (!pdev)
+		goto fail_alloc;
+
+	res = kzalloc(sizeof(*res) * cell->num_resources, GFP_KERNEL);
+
+	if (!res)
+		goto fail_device;
+
+	pdev->dev.parent = parent;
+
+	pdev->dev.of_node = cell->of_node;
+
+	if (cell->pdata_size) {
+		ret = platform_device_add_data(pdev,
+					       cell->platform_data,
+					       cell->pdata_size);
+
+		if (ret)
+			goto fail_res;
+	}
+
+	if (cell->drv_data_size) {
+		platform_set_drvdata(pdev, cell->drv_data);
+	}
+
+	for (r = 0; r < cell->num_resources; r++) {
+		res[r].name = cell->resources[r].name;
+		res[r].flags = cell->resources[r].flags;
+
+		/* Find out base to use */
+		if ((cell->resources[r].flags & IORESOURCE_MEM) && mem_base) {
+			res[r].parent = mem_base;
+			res[r].start = mem_base->start +
+				       cell->resources[r].start;
+			res[r].end = mem_base->start +
+				     cell->resources[r].end;
+		} else if (cell->resources[r].flags & IORESOURCE_IRQ) {
+			res[r].start = irq_base +
+				       cell->resources[r].start;
+			res[r].end   = irq_base +
+				       cell->resources[r].end;
+		} else {
+			res[r].parent = cell->resources[r].parent;
+			res[r].start = cell->resources[r].start;
+			res[r].end   = cell->resources[r].end;
+		}
+	}
+
+	ret = platform_device_add_resources(pdev, res, cell->num_resources);
+
+	if (ret)
+		goto fail_res;
+
+	ret = platform_device_add(pdev);
+
+	if (ret)
+		goto fail_res;
+
+	kfree(res);
+
+	return 0;
+
+fail_res:
+	kfree(res);
+fail_device:
+	platform_device_put(pdev);
+fail_alloc:
+	return ret;
+}
+
+static int gsw_add_devices(struct device *parent, int id,
+			   struct gsw_cell *cells, int n_devs,
+			   struct resource *mem_base,
+			   int irq_base)
+{
+	int i;
+	int ret;
+
+	for (i = 0; i < n_devs; i++) {
+		ret = gsw_add_device(parent, id, &cells[i], mem_base,
+				     irq_base);
+
+		if (ret)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+
+	if (i)
+		gsw_remove_devices(parent);
+
+	return ret;
+}
+
+static int gsw_dev_probe(struct platform_device *pdev)
+{
+	u32 devid = 0;
+	int ret = 0;
+	struct device *dev = &pdev->dev;
+	struct device_node *base_node = dev->of_node;
+	u32 prod_id = 0;
+	struct reset_control *gswss_rst;
+
+	if (pdev->dev.of_node)
+		printk("Node name %s\n", base_node->full_name);
+
+	/* parse Device tree */
+	ret = gsw_parse_dt(base_node);
+
+	if (ret) {
+		pr_crit("%s: Failed to parse device tree \n",
+			__func__);
+		return -1;
+	}
+
+	devid = gsw_dev_cells[0].device_id;
+	prod_id = gsw_dev[devid].prod_id;
+
+	/* Store the device id in parent device ID */
+	dev->id = devid;
+
+	if (prod_id == FALCONMX) {
+
+		gswss_rst = gsw_reset_get(pdev);
+
+		if (!gswss_rst) {
+			dev_err(&pdev->dev, "failed to get gswip reset:\n");
+			return -1;
+		}
+
+		/* Make Sure GSWIP is out of reset in RCU reg */
+		gsw_rst(gswss_rst);
+
+		/* Init Adaption private data */
+		ret = init_adapt_prvdata(devid);
+
+		if (ret) {
+			pr_crit("%s: Failed to allocate Adaption Priv Data\n",
+				__func__);
+			return -1;
+		}
+	}
+
+	/* Set gsw_dev[devid] inside parent Driver data */
+	dev_set_drvdata(dev, &gsw_dev[devid]);
+
+	/* Add devices */
+	ret = gsw_add_devices(dev, PLATFORM_DEVID_AUTO, gsw_dev_cells,
+			      gsw_dev[devid].num_devs,
+			      NULL, 0);
+	return ret;
+}
+
+struct adap_ops *gsw_get_adap_ops(u32 devid)
+{
+	if (gsw_dev[devid].adap_ops)
+		return ((struct adap_ops *)(gsw_dev[devid].adap_ops));
+
+	return NULL;
+}
+EXPORT_SYMBOL(gsw_get_adap_ops);
+
+struct mac_ops *gsw_get_mac_ops(u32 devid, u32 mac_idx)
+{
+	if (mac_idx > gsw_dev[devid].mac_subdevs_cnt)
+		return NULL;
+
+	if (gsw_dev[devid].mac_dev)
+		return (platform_get_drvdata(gsw_dev[devid].mac_dev[mac_idx]));
+
+	return NULL;
+}
+EXPORT_SYMBOL(gsw_get_mac_ops);
+
+/* API to get GSWIP Core Layer operations */
+struct core_ops *gsw_get_swcore_ops(u32 devid)
+{
+	if (gsw_dev[devid].core_dev)
+		return (platform_get_drvdata(gsw_dev[devid].core_dev));
+
+	return NULL;
+}
+EXPORT_SYMBOL(gsw_get_swcore_ops);
+
+struct platform_device *gsw_get_coredev(u32 devid)
+{
+	if (gsw_dev[devid].core_dev)
+		return (gsw_dev[devid].core_dev);
+
+	return NULL;
+}
+EXPORT_SYMBOL(gsw_get_coredev);
+
+struct platform_device *gsw_get_macdev(u32 devid, u32 mac_idx)
+{
+	if (mac_idx > gsw_dev[devid].mac_subdevs_cnt) {
+		pr_crit("%s: No. of Mac Idx given is more than Mac Sub devs"
+			"supported\n",
+			__func__);
+		return NULL;
+	}
+
+	if (gsw_dev[devid].mac_dev)
+		return (gsw_dev[devid].mac_dev[mac_idx]);
+
+	return NULL;
+}
+EXPORT_SYMBOL(gsw_get_macdev);
+
+u32 gsw_get_mac_subifcnt(u32 devid)
+{
+	return (gsw_dev[devid].mac_subdevs_cnt);
+}
+EXPORT_SYMBOL(gsw_get_mac_subifcnt);
+
+u32 gsw_get_total_devs(u32 devid)
+{
+	return (gsw_dev[devid].num_devs);
+}
+EXPORT_SYMBOL(gsw_get_total_devs);
+
+static const struct of_device_id gsw_dev_match[] = {
+	{ .compatible = "intel,gswdev" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, gsw_dev_match);
+
+static struct platform_driver gsw_dev_driver = {
+	.probe = gsw_dev_probe,
+	.driver = {
+		.name = "gswdev",
+		.owner = THIS_MODULE,
+		.of_match_table = gsw_dev_match,
+	},
+};
+
+module_platform_driver(gsw_dev_driver);
+
+MODULE_AUTHOR("Intel");
+MODULE_DESCRIPTION("Intel GSWIP Device driver for Adding devices");
+MODULE_LICENSE("GPL");
+
diff --git a/include/net/switch_api/adap_ops.h b/include/net/switch_api/adap_ops.h
new file mode 100755
index 000000000000..47947650e190
--- /dev/null
+++ b/include/net/switch_api/adap_ops.h
@@ -0,0 +1,187 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#ifndef _ADAP_OPS_H_
+#define _ADAP_OPS_H_
+
+#include "gsw_types.h"
+
+struct adap_ops {
+	/* This function does the whole GSWIP Subsystem Reset.
+	 * param[in/out]	IN:	ops Adaption ops Struct registered.
+	 * return		OUT  0:	Reset Succesfully
+	 * return		OUT  !0:	GSWIP Subsystem Reset Error
+	 */
+	int(*ss_hwreset)(void *);
+	/* This function Sets the Master Time Source for REF_TIME, DIG_TIME,
+	 * BIN_TIME, PPS_SEL.
+	 * param[in/out]	IN:	ops Adaption ops Struct registered.
+	 * param[in/out]	IN:	ref_time	Selects the Master
+	 *  0 -	PON_PCS is the MASTER, 1 - PCIE0 is the master,
+	 *  2 - PCIE1 is the master 3 - XGMAC2 is the master,
+	 *  4 - XGMAC3 is the master, 5 - XGMAC4 is the master
+	 * param[in/out]	IN:	dig_time
+	 *  0 -	PON_PCS is the MASTER, 1 - PCIE0 is the master,
+	 *  2 - PCIE1 is the master 3 - XGMAC2 is the master,
+	 *  4 - XGMAC3 is the master, 5 - XGMAC4 is the master
+	 * param[in/out]	IN:	bin_time
+	 *  0 -	PON_PCS is the MASTER, 1 - PCIE0 is the master,
+	 *  2 - PCIE1 is the master 3 - XGMAC2 is the master,
+	 *  4 - XGMAC3 is the master, 5 - XGMAC4 is the master
+	 * param[in/out]	IN:	pps_sel
+	 *  0 -	PON_PCS is the MASTER, 1 - PCIE0 is the master,
+	 *  2 - PCIE1 is the master 3 - XGMAC2 is the master,
+	 *  4 - XGMAC3 is the master, 5 - XGMAC4 is the master
+	 * return		OUT  0:	Master Set Succesfully
+	 * return		OUT  !0:Error in Setting Master Time Source
+	 */
+	int(*ss_set_cfg0_1588)(void *, u32, u32, u32, u32);
+	/* This function Sets the Master Time Source for REF_TIME, DIG_TIME,
+	 * BIN_TIME, PPS_SEL.
+	 * param[in/out]	IN:	ops Adaption ops Struct registered.
+	 * param[in/out]  OUT:	ref_time	Gets the Master for REF_TIME.
+	 *  0 -	PON_PCS is the MASTER, 1 - PCIE0 is the master,
+	 *  2 - PCIE1 is the master 3 - XGMAC2 is the master,
+	 *  4 - XGMAC3 is the master, 5 - XGMAC4 is the master
+	 * param[in/out]  OUT:	dig_time	Gets the Master for DIG_TIME.
+	 *  0 -	PON_PCS is the MASTER, 1 - PCIE0 is the master,
+	 *  2 - PCIE1 is the master 3 - XGMAC2 is the master,
+	 *  4 - XGMAC3 is the master, 5 - XGMAC4 is the master
+	 * param[in/out]  OUT:	bin_time	Gets the Master for BIN_TIME.
+	 *  0 -	PON_PCS is the MASTER, 1 - PCIE0 is the master,
+	 *  2 - PCIE1 is the master 3 - XGMAC2 is the master,
+	 *  4 - XGMAC3 is the master, 5 - XGMAC4 is the master
+	 * param[in/out]  OUT:	pps_sel		Gets the Master for PPS_SEL.
+	 *  0 -	PON_PCS is the MASTER, 1 - PCIE0 is the master,
+	 *  2 - PCIE1 is the master 3 - XGMAC2 is the master,
+	 *  4 - XGMAC3 is the master, 5 - XGMAC4 is the master
+	 * return		OUT  0:	Master Got Succesfully
+	 * return		OUT  !0:Error in Getting Master Time Source
+	 */
+	int(*ss_get_cfg0_1588)(void *, u32 *, u32 *, u32 *, u32 *);
+	/* This function Sets the GSWIP Clock Mode to NC01, NCO2 or Auto Mode.
+	 * param[in/out]	IN:	ops Adaption ops Struct registered.
+	 * param[in/out]  IN:	Clk Mode	Selects the Clock Mode.
+	 *  0 -	NCO1 - default 666 Mhz, 1 - NCO2 - default 450 Mhz,
+	 *  2 - Auto Mode (666/450) Mhz, 3 - Auto Mode (666/450) Mhz
+	 * return		   OUT  0:	Clock Mode Set Succesfully
+	 * return		   OUT  !0:	Error in Setting Clock Mode
+	 */
+	int(*ss_set_clkmode)(void *, u32);
+	/* This function Gets the GSWIP Clock Mode.
+	 * param[in/out]	IN:	ops Adaption ops Struct registered.
+	 * return		OUT:	Clk Mode	Gets the Clock Mode.
+	 *  0 -	NCO1 - default 666 Mhz, 1 - NCO2 - default 450 Mhz,
+	 *  2 - Auto Mode (666/450) Mhz, 3 - Auto Mode (666/450) Mhz
+	 * return		OUT  -1:	Error in Getting Clock Mode
+	 */
+	u32(*ss_get_clkmode)(void *);
+	/* This function does the Switch Core Enable/Disable.
+	 * param[in/out]	IN:	ops Adaption ops Struct registered.
+	 * param[in/out]	IN:	Core Enable	Selects the Core Enable
+	 *				1 - Enable, 0 - Disable.
+	 * return		OUT  0:	Switch Core Enable/Disable Successfully
+	 * return		OUT  !0:Switch Core Enable/Disable Error
+	 */
+	int(*ss_core_en)(void *, u32);
+	/* This function Gets the Switch Core Enable/Disable.
+	 * param[in/out]	IN:	ops Adaption ops Struct registered.
+	 * return		OUT:	core_se	Gets the CORE_SE val.
+	 *  			0:	Switch Core Disable,
+	 *  			1:	Switch Core Enable
+	 */
+	u32(*ss_get_core_en)(void *);
+	/* This function Sets MACSEC to a Mac Module Attachment.
+	 *  param[in/out]IN:	ops Adaption ops Struct registered.
+	 * param[in/out]IN:	Mac Index	0 - MAC2 is attached to MACSEC,
+	 * 	 				1 - MAC3 is attached to MACSEC,
+	 * 					2 - MAC4 is attached to MACSEC.
+	 * param[in/out]IN:	Enable		1 - Enable MACSEC to MAC Mapping
+	 * 	 			0 - Disable MACSEC to MAC Mapping,
+	 * return	OUT  0:	MACSEC to Mac Module Attachment done
+	 * return	OUT  !0:Error in MACSEC to Mac Module Attachment
+	 */
+	int(*ss_set_macsec_mac)(void *, u32, u32);
+	/* This function Gets MACSEC to a Mac Module mapping.
+	 * param[in/out]	IN:	ops Adaption ops Struct registered.
+	 * \return		OUT:	0 - Disabled MACSEC to MAC mapping,
+	 * 	 			2 - MAC2 is attached to MACSEC,
+	 * 	 			3 - MAC3 is attached to MACSEC,
+	 * 	 			4 - MAC4 is attached to MACSEC
+	 * return		OUT  -1:Error in MACSEC to Mac Module Attachment
+	 */
+	int(*ss_get_macsec_mac)(void *);
+	/* This function does MACsec Hardware Reset.
+	 * param[in/out]	IN:	ops Adaption ops Struct registered.
+	 * param[in/out]	IN:  	0	OFF reset is off
+	 *				1	ON reset is active
+	 * return		OUT  0:		MACsec Hardware Reset done
+	 * return		OUT  !0:	MACsec Hardware Reset Error
+	 */
+	int(*ss_reset_macsec)(void *, u32);
+	/* This function Sets NCO value.
+	 * param[in/out]	IN:	ops Adaption ops Struct registered.
+	 * param[in/out]	IN:  val	NCO value to set
+	 * 			IN:  nco idx	NCO Index to set (0/1/2/3/4)
+	 * return		OUT  0:		NCO value Set Successfully
+	 * return		OUT  !0:	NCO value Set Error
+	 */
+	int(*ss_set_nco)(void *, u32, u32);
+	/* This function Gets NCO value.
+	 * param[in/out]	IN:	ops Adaption ops Struct registered.
+	 * param[in/out]	IN:	nco idx	NCO Value to Get from which
+	 *				Index (0/1/2/3/4)
+	 * return		OUT  0:	NCO value Configured
+	 * return		OUT  -1:NCO value Get Error
+	 */
+	u32(*ss_get_nco)(void *, u32);
+	/* This function Enables/Disbales Interrupt Enable Register.
+	 * param[in/out]	IN:	ops Adaption ops Struct registered.
+	 * param[in/out]	IN:	module	0 - XGMAC
+	 *					4 - LINK
+	 * param[in/out]	IN:	idx	XGMAC Index enabled/disabled
+	 * param[in/out]	IN:	enable	1 - Enable, 0 - Disable
+	 * return		OUT	0:	Interrupt Enable Register Set
+	 *					Successfully
+	 * return		OUT	!0:	Interrupt Enable Register Set
+	 *					Error
+	 */
+	int(*ss_set_inten)(void *, u32, u32, u32);
+	/* This function Gets the Interrupt Sts Register.
+	 * param[in/out]	IN:	ops Adaption ops Struct registered.
+	 * param[in/out]	IN:	module	0 - XGMAC
+	 *					4 - LINK
+	 * param[in/out]	IN:	idx	XGMAC Index to Get Sts
+	 * return		OUT	val:	Interrupt Sts
+	 *					0 - no interrupt pending
+	 *					1 - interrupt is pending
+	 * return		OUT	!0:	Interrupt Sts Register Get Error
+	 */
+	int(*ss_get_intstat)(void *, u32);
+	/* This sequence is Read Adaption register
+	 * param[in/out]IN:	ops	Adap ops Struct registered
+	 * param[in/out]IN:	off	Adap Register offset.
+	 * return	OUT	reg_val:Register value will be returned
+	 */
+	u32(*ss_rg_rd)(void *, u32);
+	/* This sequence is Write Adaption register
+	 * param[in/out]IN:	ops	Adap ops Struct registered.
+	 * param[in/out]IN:	off	Adap Register offset.
+	 * param[in/out]IN:	val	Adap Register Value to be written.
+	 */
+	void(*ss_rg_wr)(void *, u32, u32);
+	/* This sequence is used for GSWSS Cli implementation
+	 * param[in/out]IN:	argc - Number of args.
+	 * param[in/out]IN:	argv - Argument value.
+	 * return	OUT	-1: 	Exit GSWSS Error
+	 */
+	int(*ss_cli)(u32, u8 **);
+};
+
+#endif
diff --git a/include/net/switch_api/gsw_dev.h b/include/net/switch_api/gsw_dev.h
new file mode 100644
index 000000000000..429282b3b935
--- /dev/null
+++ b/include/net/switch_api/gsw_dev.h
@@ -0,0 +1,109 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#ifndef _GSW_DEV_H
+#define _GSW_DEV_H
+
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/export.h>
+#include <net/switch_api/adap_ops.h>
+#include <net/switch_api/mac_ops.h>
+#include <net/switch_api/gsw_flow_ops.h>
+#include <net/switch_api/lantiq_gsw_api.h>
+
+#define MAX_GSWDEV		16
+#define MAC_DEV_NAME		"gsw_mac"
+#define CORE_DEV_NAME		"gsw_core"
+
+/* This represents the GSWIP SubSystem block, one instance per SubSystem
+ * For xrx500 GSWIP-L device ID is 0
+ * For xrx500 GSWIP-R device ID is 1
+ * For Falcon-Mx device ID is 0
+ */
+struct gswss {
+	/* Product ID, GRX500, FALCONMX, ..... */
+	u32 prod_id;
+	/* Adaption layer Operations Structure */
+	struct adap_ops *adap_ops;
+	/* Number of devices in this GSWIP SubSystem */
+	u32 num_devs;
+	/* Core Platform device */
+	struct platform_device *core_dev;
+	/* Number of Mac Subdevice in this GSWIP SubSystem */
+	u32 mac_subdevs_cnt;
+	/* Mac Platform device for each Mac Subdevice */
+	struct platform_device *mac_dev[];
+};
+
+/* Enumeration for Product ID
+ * This is to identify the Product ID in functional drivers in GSWIP Subsystem
+ */
+enum {
+	GRX500     = 0x01,
+	FALCONMX   = 0x02,
+};
+
+/* This function returns the Adaptions Operations registered.
+ * param[in/out]	IN:  devid   	Device ID used.
+ *			OUT: adap_ops	Adaption ops Func Pointer Structure
+ * return		NULL:		No Adaption operations registered
+ * return		!NULL:		Returns Adaption operations registered
+ */
+struct adap_ops *gsw_get_adap_ops(u32 devid);
+
+/* This function returns the GSWIP Core Operations registered.
+ * param[in/out]	IN:  devid	Device ID used.
+ *			OUT: core_ops	Core operations Func Pointer Structure
+ * return         NULL:			No GSWIP Core operations registered
+ * return         !NULL:		Returns GSWIP Core operations registered
+ */
+struct core_ops *gsw_get_swcore_ops(u32 devid);
+
+/* This function returns the MAC Operations registered.
+ * param[in/out]	IN:  devid	Device ID used.
+ *			IN:  mac_idx   	Mac Idx used(0/1/2..).
+ *					Depends on mac_subdev_cnt
+ *			OUT: mac_ops	MAC operations Func Pointer Structure
+ * return		NULL:		No MAC operations registered
+ * return		!NULL:		Returns MAC operations registered
+ */
+struct mac_ops *gsw_get_mac_ops(u32 devid, u32 mac_idx);
+
+/* This function returns the MAC Platform Device registered.
+ * param[in/out]	IN:  devid	Device ID used.
+ *			OUT: platform_device	Core Platform Device registered Structure
+ * return		NULL:		No Core Platform Device registered
+ * return		!NULL:		Returns Core Platform Device registered
+ */
+struct platform_device *gsw_get_coredev(u32 devid);
+
+/* This function returns the MAC Platform Device registered.
+ * param[in/out]	IN:  devid	Device ID used.
+ *			IN:  mac_idx	Mac Idx used(0/1/2..).
+ *			Depends on mac_subdev_cnt
+ *			OUT: platform_device	MAC Platform Device registered Structure
+ * return		NULL:		No MAC Platform Device registered
+ * return		!NULL:		Returns MAC Platform Device registered
+ */
+struct platform_device *gsw_get_macdev(u32 devid, u32 mac_idx);
+
+/* This function returns the MAC Sub Interface Count.
+ * param[in/out]	IN:  devid   	Device ID used.
+ * return		OUT:		Returns MAC Sub Interface Count
+ */
+u32 gsw_get_mac_subifcnt(u32 devid);
+
+/* This function returns the Total GSWIP device Count.
+ * param[in/out]	IN:  devid	Device ID used.
+ * return		OUT:		Returns Total GSWIP device Count
+ */
+u32 gsw_get_total_devs(u32 devid);
+
+#endif
diff --git a/include/net/switch_api/gsw_flow_ops.h b/include/net/switch_api/gsw_flow_ops.h
new file mode 100644
index 000000000000..cb75ecbe0b20
--- /dev/null
+++ b/include/net/switch_api/gsw_flow_ops.h
@@ -0,0 +1,708 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+For licensing information, see the file 'LICENSE' in the root folder of
+this software module.
+******************************************************************************/
+
+
+#ifndef _GSW_FLOW_OPS_H_
+#define _GSW_FLOW_OPS_H_
+
+#include "gsw_types.h"
+#include "lantiq_gsw_api.h"
+#include "gsw_irq.h"
+
+
+/*RMON operation*/
+struct rmon_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_RMON_PORT_GET ; Index: 0x01 */
+	GSW_return_t (*RMON_Port_Get)(void *, GSW_RMON_Port_cnt_t *);
+	/* Command: GSW_RMON_MODE_SET ; Index: 0x02 */
+	GSW_return_t (*RMON_Mode_Set)(void *, GSW_RMON_mode_t *);
+	/* Command: GSW_RMON_METER_GET ; Index: 0x03 */
+	GSW_return_t (*RMON_Meter_Get)(void *, GSW_RMON_Meter_cnt_t *);
+	/* Command: GSW_RMON_REDIRECT_GET ; Index: 0x04 */
+	GSW_return_t (*RMON_Redirect_Get)(void *, GSW_RMON_Redirect_cnt_t *);
+	/* Command: GSW_RMON_IF_GET ; Index: 0x05 */
+	GSW_return_t (*RMON_If_Get)(void *, GSW_RMON_If_cnt_t *);
+	/* Command: GSW_RMON_ROUTE_GET ; Index: 0x06 */
+	GSW_return_t (*RMON_Route_Get)(void *, GSW_RMON_Route_cnt_t *);
+	/* Command: GSW_RMON_CLEAR ; Index: 0x07 */
+	GSW_return_t (*RMON_Clear)(void *, GSW_RMON_clear_t *);
+	/* Command: GSW_RMON_EXTEND_GET ; Index: 0x08 */
+	GSW_return_t (*RMON_ExtendGet)(void *, GSW_RMON_extendGet_t *);
+	/* Command: GSW_RMON_FLOW_GET ; Index: 0x09 */
+	GSW_return_t (*RMON_TflowGet)(void *, GSW_RMON_flowGet_t *);
+	/* Command: GSW_RMON_TFLOW_CLEAR ; Index: 0x0A */
+	GSW_return_t (*RMON_TflowClear)(void *, GSW_RMON_flowGet_t *);
+	/* Command: GSW_TFLOW_COUNT_MODE_SET ; Index: 0x0B */
+	GSW_return_t (*RMON_TflowCountModeSet)(void *, GSW_TflowCmodeConf_t *);
+	/* Command: GSW_TFLOW_COUNT_MODE_GET ; Index: 0x0C */
+	GSW_return_t (*RMON_TflowCountModeGet)(void *, GSW_TflowCmodeConf_t *);
+};
+
+/*Switch MAc operations*/
+struct swmac_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_MAC_TABLE_CLEAR ; Index: 0x01 */
+	GSW_return_t (*MAC_TableClear)(void *);
+	/* Command: GSW_MAC_TABLE_ENTRY_ADD ; Index: 0x02 */
+	GSW_return_t (*MAC_TableEntryAdd)(void *, GSW_MAC_tableAdd_t *);
+	/* Command: GSW_MAC_TABLE_ENTRY_READ ; Index: 0x03 */
+	GSW_return_t (*MAC_TableEntryRead)(void *, GSW_MAC_tableRead_t *);
+	/* Command: GSW_MAC_TABLE_ENTRY_QUERY ; Index: 0x04 */
+	GSW_return_t (*MAC_TableEntryQuery)(void *, GSW_MAC_tableQuery_t *);
+	/* Command: GSW_MAC_TABLE_ENTRY_REMOVE ; Index: 0x05 */
+	GSW_return_t (*MAC_TableEntryRemove)(void *, GSW_MAC_tableRemove_t *);
+	/* Command: GSW_DEFAUL_MAC_FILTER_SET ; Index: 0x06 */
+	GSW_return_t (*MAC_DefaultFilterSet)(void *, GSW_MACFILTER_default_t *);
+	/* Command: GSW_DEFAUL_MAC_FILTER_GET ; Index: 0x07 */
+	GSW_return_t (*MAC_DefaultFilterGet)(void *, GSW_MACFILTER_default_t *);
+};
+
+/*Extended Vlan operations*/
+struct extvlan_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_EXTENDEDVLAN_ALLOC ; Index: 0x01 */
+	GSW_return_t (*ExtendedVlan_Alloc)(void *, GSW_EXTENDEDVLAN_alloc_t *);
+	/* Command: GSW_EXTENDEDVLAN_SET ; Index: 0x02 */
+	GSW_return_t (*ExtendedVlan_Set)(void *, GSW_EXTENDEDVLAN_config_t *);
+	/* Command: GSW_EXTENDEDVLAN_GET ; Index: 0x03 */
+	GSW_return_t (*ExtendedVlan_Get)(void *, GSW_EXTENDEDVLAN_config_t *);
+	/* Command: GSW_EXTENDEDVLAN_FREE ; Index: 0x04 */
+	GSW_return_t (*ExtendedVlan_Free)(void *, GSW_EXTENDEDVLAN_alloc_t *);
+};
+
+/*Vlan Filter operations*/
+struct vlanfilter_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_VLANFILTER_ALLOC ; Index: 0x01 */
+	GSW_return_t (*VlanFilter_Alloc)(void *, GSW_VLANFILTER_alloc_t *);
+	/* Command: GSW_VLANFILTER_SET ; Index: 0x02 */
+	GSW_return_t (*VlanFilter_Set)(void *, GSW_VLANFILTER_config_t *);
+	/* Command: GSW_VLANFILTER_GET ; Index: 0x03 */
+	GSW_return_t (*VlanFilter_Get)(void *, GSW_VLANFILTER_config_t *);
+	/* Command: GSW_VLANFILTER_FREE ; Index: 0x04 */
+	GSW_return_t (*VlanFilter_Free)(void *, GSW_VLANFILTER_alloc_t *);
+};
+
+/*CTP operations*/
+struct ctp_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_CTP_PORT_ASSIGNMENT_ALLOC ; Index: 0x01 */
+	GSW_return_t (*CTP_PortAssignmentAlloc)(void *, GSW_CTP_portAssignment_t *);
+	/* Command: GSW_CTP_PORT_ASSIGNMENT_FREE ; Index: 0x02 */
+	GSW_return_t (*CTP_PortAssignmentFree)(void *, GSW_CTP_portAssignment_t *);
+	/* Command: GSW_CTP_PORT_ASSIGNMENT_SET ; Index: 0x03 */
+	GSW_return_t (*CTP_PortAssignmentSet)(void *, GSW_CTP_portAssignment_t *);
+	/* Command: GSW_CTP_PORT_ASSIGNMENT_GET ; Index: 0x04 */
+	GSW_return_t (*CTP_PortAssignmentGet)(void *, GSW_CTP_portAssignment_t *);
+	/* Command: GSW_CTP_PORT_CONFIG_SET ; Index: 0x05 */
+	GSW_return_t (*CTP_PortConfigSet)(void *, GSW_CTP_portConfig_t *);
+	/* Command: GSW_CTP_PORT_CONFIG_GET ; Index: 0x06 */
+	GSW_return_t (*CTP_PortConfigGet)(void *, GSW_CTP_portConfig_t *);
+	/* Command: GSW_CTP_PORT_CONFIG_RESET ; Index: 0x07 */
+	GSW_return_t (*CTP_PortConfigReset)(void *, GSW_CTP_portConfig_t *);
+};
+
+/*Bridge Port operations*/
+struct brdgport_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_BRIDGE_PORT_ALLOC ; Index: 0x01 */
+	GSW_return_t (*BridgePort_Alloc)(void *, GSW_BRIDGE_portAlloc_t *);
+	/* Command: GSW_BRIDGE_PORT_CONFIG_SET ; Index: 0x02 */
+	GSW_return_t (*BridgePort_ConfigSet)(void *, GSW_BRIDGE_portConfig_t *);
+	/* Command: GSW_BRIDGE_PORT_CONFIG_GET ; Index: 0x03 */
+	GSW_return_t (*BridgePort_ConfigGet)(void *, GSW_BRIDGE_portConfig_t *);
+	/* Command: GSW_BRIDGE_PORT_FREE ; Index: 0x04 */
+	GSW_return_t (*BridgePort_Free)(void *, GSW_BRIDGE_portAlloc_t *);
+};
+
+/*Bridge Operations*/
+struct brdg_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_BRIDGE_ALLOC ; Index: 0x01 */
+	GSW_return_t (*Bridge_Alloc)(void *, GSW_BRIDGE_alloc_t *);
+	/* Command: GSW_BRIDGE_CONFIG_SET ; Index: 0x02 */
+	GSW_return_t (*Bridge_ConfigSet)(void *, GSW_BRIDGE_config_t *);
+	/* Command: GSW_BRIDGE_CONFIG_GET ; Index: 0x03 */
+	GSW_return_t (*Bridge_ConfigGet)(void *, GSW_BRIDGE_config_t *);
+	/* Command: GSW_BRIDGE_FREE ; Index: 0x04 */
+	GSW_return_t (*Bridge_Free)(void *, GSW_BRIDGE_alloc_t *);
+};
+
+/*TFlow operations*/
+struct tflow_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_PCE_RULE_DELETE ; Index: 0x01 */
+	GSW_return_t (*TFLOW_PceRuleDelete)(void *, GSW_PCE_ruleDelete_t *);
+	/* Command: GSW_PCE_RULE_READ ; Index: 0x02 */
+	GSW_return_t (*TFLOW_PceRuleRead)(void *, GSW_PCE_rule_t *);
+	/* Command: GSW_PCE_RULE_WRITE ; Index: 0x03 */
+	GSW_return_t (*TFLOW_PceRuleWrite)(void *, GSW_PCE_rule_t *);
+};
+
+/*QOS operations*/
+struct qos_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_QOS_METER_CFG_GET ; Index: 0x01 */
+	GSW_return_t (*QoS_MeterCfgGet)(void *, GSW_QoS_meterCfg_t *);
+	/* Command: GSW_QOS_METER_CFG_SET ; Index: 0x02 */
+	GSW_return_t (*QoS_MeterCfgSet)(void *, GSW_QoS_meterCfg_t *);
+	/* Command: GSW_QOS_METER_PORT_ASSIGN ; Index: 0x03 */
+	GSW_return_t (*QoS_MeterPortAssign)(void *, GSW_QoS_meterPort_t *);
+	/* Command: GSW_QOS_METER_PORT_DEASSIGN ; Index: 0x04 */
+	GSW_return_t (*QoS_MeterPortDeassign)(void *, GSW_QoS_meterPort_t *);
+	/* Command: GSW_QOS_METER_PORT_GET ; Index: 0x05 */
+	GSW_return_t (*QoS_MeterPortGet)(void *, GSW_QoS_meterPortGet_t *);
+	/* Command: GSW_QOS_DSCP_CLASS_GET ; Index: 0x06 */
+	GSW_return_t (*QoS_DSCP_ClassGet)(void *, GSW_QoS_DSCP_ClassCfg_t *);
+	/* Command: GSW_QOS_DSCP_CLASS_SET ; Index: 0x07 */
+	GSW_return_t (*QoS_DSCP_ClassSet)(void *, GSW_QoS_DSCP_ClassCfg_t *);
+	/* Command: GSW_QOS_CLASS_DSCP_GET ; Index: 0x08 */
+	GSW_return_t (*QoS_ClassDSCP_Get)(void *, GSW_QoS_ClassDSCP_Cfg_t *);
+	/* Command: GSW_QOS_CLASS_DSCP_SET ; Index: 0x09 */
+	GSW_return_t (*QoS_ClassDSCP_Set)(void *, GSW_QoS_ClassDSCP_Cfg_t *);
+	/* Command: GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_GET ; Index: 0x0A */
+	GSW_return_t (*QoS_DSCP_DropPrecedenceCfgGet)(void *, GSW_QoS_DSCP_DropPrecedenceCfg_t *);
+	/* Command: GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_SET ; Index: 0x0B */
+	GSW_return_t (*QoS_DSCP_DropPrecedenceCfgSet)(void *, GSW_QoS_DSCP_DropPrecedenceCfg_t *);
+	/* Command: GSW_QOS_PORT_REMARKING_CFG_GET ; Index: 0x0C */
+	GSW_return_t (*QoS_PortRemarkingCfgGet)(void *, GSW_QoS_portRemarkingCfg_t *);
+	/* Command: GSW_QOS_PORT_REMARKING_CFG_SET ; Index: 0x0D */
+	GSW_return_t (*QoS_PortRemarkingCfgSet)(void *, GSW_QoS_portRemarkingCfg_t *);
+	/* Command: GSW_QOS_CLASS_PCP_GET ; Index: 0x0E*/
+	GSW_return_t (*QoS_ClassPCP_Get)(void *, GSW_QoS_ClassPCP_Cfg_t *);
+	/* Command: GSW_QOS_CLASS_PCP_SET ; Index: 0x0F */
+	GSW_return_t (*QoS_ClassPCP_Set)(void *, GSW_QoS_ClassPCP_Cfg_t *);
+	/* Command: GSW_QOS_PCP_CLASS_GET ; Index: 0x10 */
+	GSW_return_t (*QoS_PCP_ClassGet)(void *, GSW_QoS_PCP_ClassCfg_t *);
+	/* Command: GSW_QOS_PCP_CLASS_SET ; Index: 0x11 */
+	GSW_return_t (*QoS_PCP_ClassSet)(void *, GSW_QoS_PCP_ClassCfg_t *);
+	/* Command: GSW_QOS_PORT_CFG_GET ; Index: 0x12 */
+	GSW_return_t (*QoS_PortCfgGet)(void *, GSW_QoS_portCfg_t *);
+	/* Command: GSW_QOS_PORT_CFG_SET ; Index: 0x13 */
+	GSW_return_t (*QoS_PortCfgSet)(void *, GSW_QoS_portCfg_t *);
+	/* Command: GSW_QOS_QUEUE_PORT_GET ; Index: 0x14 */
+	GSW_return_t (*QoS_QueuePortGet)(void *, GSW_QoS_queuePort_t *);
+	/* Command: GSW_QOS_QUEUE_PORT_SET ; Index: 0x15 */
+	GSW_return_t (*QoS_QueuePortSet)(void *, GSW_QoS_queuePort_t *);
+	/* Command: GSW_QOS_SCHEDULER_CFG_GET ; Index: 0x16 */
+	GSW_return_t (*QoS_SchedulerCfgGet)(void *, GSW_QoS_schedulerCfg_t *);
+	/* Command: GSW_QOS_SCHEDULER_CFG_SET ; Index: 0x17 */
+	GSW_return_t (*QoS_SchedulerCfgSet)(void *, GSW_QoS_schedulerCfg_t *);
+	/* Command: GSW_QOS_SHAPER_CFG_GET ; Index: 0x18 */
+	GSW_return_t (*QoS_ShaperCfgGet)(void *, GSW_QoS_ShaperCfg_t *);
+	/* Command: GSW_QOS_SHAPER_CFG_SET ; Index: 0x19 */
+	GSW_return_t (*QoS_ShaperCfgSet)(void *, GSW_QoS_ShaperCfg_t *);
+	/* Command: GSW_QOS_SHAPER_QUEUE_ASSIGN ; Index: 0x1A */
+	GSW_return_t (*QoS_ShaperQueueAssign)(void *, GSW_QoS_ShaperQueue_t *);
+	/* Command: GSW_QOS_SHAPER_QUEUE_DEASSIGN ; Index: 0x1B */
+	GSW_return_t (*QoS_ShaperQueueDeassign)(void *, GSW_QoS_ShaperQueue_t *);
+	/* Command: GSW_QOS_SHAPER_QUEUE_GET ; Index: 0x1C */
+	GSW_return_t (*QoS_ShaperQueueGet)(void *, GSW_QoS_ShaperQueueGet_t *);
+	/* Command: GSW_QOS_STORM_CFG_SET ; Index: 0x1D */
+	GSW_return_t (*QoS_StormCfgSet)(void *, GSW_QoS_stormCfg_t *);
+	/* Command: GSW_QOS_STORM_CFG_GET ; Index: 0x1E */
+	GSW_return_t (*QoS_StormCfgGet)(void *, GSW_QoS_stormCfg_t *);
+	/* Command: GSW_QOS_WRED_CFG_GET ; Index: 0x1F */
+	GSW_return_t (*QoS_WredCfgGet)(void *, GSW_QoS_WRED_Cfg_t *);
+	/* Command: GSW_QOS_WRED_CFG_SET ; Index: 0x20 */
+	GSW_return_t (*QoS_WredCfgSet)(void *, GSW_QoS_WRED_Cfg_t *);
+	/* Command: GSW_QOS_WRED_QUEUE_CFG_GET ; Index: 0x21 */
+	GSW_return_t (*QoS_WredQueueCfgGet)(void *, GSW_QoS_WRED_QueueCfg_t *);
+	/* Command: GSW_QOS_WRED_QUEUE_CFG_SET ; Index: 0x22 */
+	GSW_return_t (*QoS_WredQueueCfgSet)(void *, GSW_QoS_WRED_QueueCfg_t *);
+	/* Command: GSW_QOS_WRED_PORT_CFG_GET ; Index: 0x23 */
+	GSW_return_t (*QoS_WredPortCfgGet)(void *, GSW_QoS_WRED_PortCfg_t *);
+	/* Command: GSW_QOS_WRED_PORT_CFG_SET ; Index: 0x24 */
+	GSW_return_t (*QoS_WredPortCfgSet)(void *, GSW_QoS_WRED_PortCfg_t *);
+	/* Command: GSW_QOS_FLOWCTRL_CFG_GET ; Index: 0x25 */
+	GSW_return_t (*QoS_FlowctrlCfgGet)(void *, GSW_QoS_FlowCtrlCfg_t *);
+	/* Command: GSW_QOS_FLOWCTRL_CFG_SET ; Index: 0x26 */
+	GSW_return_t (*QoS_FlowctrlCfgSet)(void *, GSW_QoS_FlowCtrlCfg_t *);
+	/* Command: GSW_QOS_FLOWCTRL_PORT_CFG_GET ; Index: 0x27 */
+	GSW_return_t (*QoS_FlowctrlPortCfgGet)(void *, GSW_QoS_FlowCtrlPortCfg_t *);
+	/* Command: GSW_QOS_FLOWCTRL_PORT_CFG_SET ; Index: 0x28 */
+	GSW_return_t (*QoS_FlowctrlPortCfgSet)(void *, GSW_QoS_FlowCtrlPortCfg_t *);
+	/* Command: GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_GET ; Index: 0x29 */
+	GSW_return_t (*QoS_QueueBufferReserveCfgGet)(void *, GSW_QoS_QueueBufferReserveCfg_t *);
+	/* Command: GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_SET ; Index: 0x2A */
+	GSW_return_t (*QoS_QueueBufferReserveCfgSet)(void *, GSW_QoS_QueueBufferReserveCfg_t *);
+	/* Command: GSW_QOS_METER_ACT ; Index: 0x2B */
+	GSW_return_t (*QoS_Meter_Act)(void *, GSW_QoS_mtrAction_t *);
+	/* Command: GSW_QOS_COLOR_MARKING_TABLE_SET ; Index: 0x2C */
+	GSW_return_t (*QOS_ColorMarkingTableGet)(void *, GSW_QoS_colorMarkingEntry_t *);
+	/* Command: GSW_QOS_COLOR_MARKING_TABLE_GET ; Index: 0x2D */
+	GSW_return_t (*QOS_ColorMarkingTableSet)(void *, GSW_QoS_colorMarkingEntry_t *);
+	/* Command: GSW_QOS_COLOR_REMARKING_TABLE_SET ; Index: 0x2E */
+	GSW_return_t (*QOS_ColorReMarkingTableSet)(void *, GSW_QoS_colorRemarkingEntry_t *);
+	/* Command: GSW_QOS_COLOR_REMARKING_TABLE_GET ; Index: 0x2F */
+	GSW_return_t (*QOS_ColorReMarkingTableGet)(void *, GSW_QoS_colorRemarkingEntry_t *);
+	/* Command: GSW_QOS_METER_ALLOC ; Index: 0x30 */
+	GSW_return_t (*QOS_MeterAlloc)(void *, GSW_QoS_meterCfg_t *param);
+	/* Command: GSW_QOS_METER_FREE ; Index: 0x31 */
+	GSW_return_t (*QOS_MeterFree)(void *, GSW_QoS_meterCfg_t *param);
+	/* Command: GSW_DSCP2PCP_MAP_SET ; Index: 0x32 */
+	GSW_return_t (*QOS_Dscp2PcpTableSet)(void *, GSW_DSCP2PCP_map_t *);
+	/* Command: GSW_DSCP2PCP_MAP_GET ; Index: 0x33 */
+	GSW_return_t (*QOS_Dscp2PcpTableGet)(void *, GSW_DSCP2PCP_map_t *);
+	/* Command: GSW_PMAPPER_SET ; Index: 0x34 */
+	GSW_return_t (*QOS_PmapperTableSet)(void *, GSW_PMAPPER_t *);
+	/* Command: GSW_PMAPPER_GET ; Index: 0x35 */
+	GSW_return_t (*QOS_PmapperTableGet)(void *, GSW_PMAPPER_t *);
+	/* Command: GSW_QOS_SVLAN_CLASS_PCP_PORT_GET ; Index: 0x36 */
+	GSW_return_t (*QoS_SVLAN_ClassPCP_PortGet)(void *, GSW_QoS_SVLAN_ClassPCP_PortCfg_t *);
+	/* Command: GSW_QOS_SVLAN_CLASS_PCP_PORT_SET ; Index: 0x37 */
+	GSW_return_t (*QoS_SVLAN_ClassPCP_PortSet)(void *, GSW_QoS_SVLAN_ClassPCP_PortCfg_t *);
+	/* Command: GSW_QOS_SVLAN_PCP_CLASS_GET ; Index: 0x38 */
+	GSW_return_t (*QoS_SVLAN_PCP_ClassGet)(void *, GSW_QoS_SVLAN_PCP_ClassCfg_t *);
+	/* Command: GSW_QOS_SVLAN_PCP_CLASS_SET ; Index: 0x39 */
+	GSW_return_t (*QoS_SVLAN_PCP_ClassSet)(void *, GSW_QoS_SVLAN_PCP_ClassCfg_t *);
+};
+
+/*STP operations*/
+struct stp_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_STP_BPDU_RULE_GET ; Index: 0x01 */
+	GSW_return_t (*STP_BPDU_RuleGet)(void *, GSW_STP_BPDU_Rule_t *);
+	/* Command: GSW_STP_BPDU_RULE_SET ; Index: 0x02 */
+	GSW_return_t (*STP_BPDU_RuleSet)(void *, GSW_STP_BPDU_Rule_t *);
+	/* Command: GSW_STP_PORT_CFG_GET ; Index: 0x03 */
+	GSW_return_t (*STP_PortCfgGet)(void *, GSW_STP_portCfg_t *);
+	/* Command: GSW_STP_PORT_CFG_SET ; Index: 0x04 */
+	GSW_return_t (*STP_PortCfgSet)(void *, GSW_STP_portCfg_t *);
+};
+
+/*8021x operations*/
+struct eapol_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_8021X_EAPOL_RULE_GET ; Index: 0x01 */
+	GSW_return_t (*EAPOL_RuleGet)(void *, GSW_8021X_EAPOL_Rule_t *);
+	/* Command: GSW_8021X_EAPOL_RULE_SET ; Index: 0x02 */
+	GSW_return_t (*EAPOL_RuleGet_RuleSet)(void *, GSW_8021X_EAPOL_Rule_t *);
+	/* Command: GSW_8021X_PORT_CFG_GET ; Index: 0x03 */
+	GSW_return_t (*EAPOL_RuleGet_PortCfgGet)(void *, GSW_8021X_portCfg_t *);
+	/* Command: GSW_8021X_PORT_CFG_SET ; Index: 0x04 */
+	GSW_return_t (*EAPOL_RuleGet_PortCfgSet)(void *, GSW_8021X_portCfg_t *);
+};
+
+/*multicast operations*/
+struct multicast_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_MULTICAST_ROUTER_PORT_ADD ; Index: 0x01 */
+	GSW_return_t (*Multicast_RouterPortAdd)(void *, GSW_multicastRouter_t *);
+	/* Command: GSW_MULTICAST_ROUTER_PORT_READ ; Index: 0x02 */
+	GSW_return_t (*Multicast_RouterPortRead)(void *, GSW_multicastRouterRead_t *);
+	/* Command: GSW_MULTICAST_ROUTER_PORT_REMOVE ; Index: 0x03 */
+	GSW_return_t (*Multicast_RouterPortRemove)(void *, GSW_multicastRouter_t *);
+	/* Command: GSW_MULTICAST_SNOOP_CFG_GET ; Index: 0x04 */
+	GSW_return_t (*Multicast_SnoopCfgGet)(void *, GSW_multicastSnoopCfg_t *);
+	/* Command: GSW_MULTICAST_SNOOP_CFG_SET ; Index: 0x05 */
+	GSW_return_t (*Multicast_SnoopCfgSet)(void *, GSW_multicastSnoopCfg_t *);
+	/* Command: GSW_MULTICAST_TABLE_ENTRY_ADD ; Index: 0x06 */
+	GSW_return_t (*Multicast_TableEntryAdd)(void *, GSW_multicastTable_t *);
+	/* Command: GSW_MULTICAST_TABLE_ENTRY_READ ; Index: 0x07 */
+	GSW_return_t (*Multicast_TableEntryRead)(void *, GSW_multicastTableRead_t *);
+	/* Command: GSW_MULTICAST_TABLE_ENTRY_REMOVE ; Index: 0x08 */
+	GSW_return_t (*Multicast_TableEntryRemove)(void *, GSW_multicastTable_t *);
+};
+
+/*Trunking operations*/
+struct trunking_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_TRUNKING_CFG_GET ; Index: 0x01 */
+	GSW_return_t (*Trunking_CfgGet)(void *, GSW_trunkingCfg_t *);
+	/* Command: GSW_TRUNKING_CFG_SET ; Index: 0x02 */
+	GSW_return_t (*Trunking_CfgSet)(void *, GSW_trunkingCfg_t *);
+	/* Command: GSW_TRUNKING_PORT_CFG_GET ; Index: 0x03 */
+	GSW_return_t (*Trunking_PortCfgGet)(void *, GSW_trunkingPortCfg_t *);
+	/* Command: GSW_TRUNKING_PORT_CFG_SET ; Index: 0x04 */
+	GSW_return_t (*Trunking_PortCfgSet)(void *, GSW_trunkingPortCfg_t *);
+};
+
+/*WOL operations*/
+struct wol_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_WOL_CFG_GET ; Index: 0x01 */
+	GSW_return_t (*WoL_CfgGet)(void *, GSW_WoL_Cfg_t *);
+	/* Command: GSW_WOL_CFG_SET ; Index: 0x02 */
+	GSW_return_t (*WoL_CfgSet)(void *, GSW_WoL_Cfg_t *);
+	/* Command: GSW_WOL_PORT_CFG_GET ; Index: 0x03 */
+	GSW_return_t (*WoL_PortCfgGet)(void *, GSW_WoL_PortCfg_t *);
+	/* Command: GSW_WOL_PORT_CFG_SET ; Index: 0x04 */
+	GSW_return_t (*WoL_PortCfgSet)(void *, GSW_WoL_PortCfg_t *);
+};
+
+/*Common switch operations*/
+struct common_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_REGISTER_GET ; Index: 0x01 */
+	GSW_return_t (*RegisterGet)(void *, GSW_register_t *);
+	/* Command: GSW_REGISTER_SET ; Index: 0x02 */
+	GSW_return_t (*RegisterSet)(void *, GSW_register_t *);
+	/* Command: GSW_IRQ_GET ; Index: 0x03 */
+	GSW_return_t (*IrqGet)(void *, GSW_irq_t *);
+	/* Command: GSW_IRQ_MASK_GET ; Index: 0x04 */
+	GSW_return_t (*IrqMaskGet)(void *, GSW_irq_t *);
+	/* Command: GSW_IRQ_MASK_SET ; Index: 0x05 */
+	GSW_return_t (*IrqMaskSet)(void *, GSW_irq_t *);
+	/* Command: GSW_IRQ_STATUS_CLEAR ; Index: 0x06 */
+	GSW_return_t (*IrqStatusClear)(void *, GSW_irq_t *);
+	/* Command: GSW_ENABLE ; Index: 0x07 */
+	GSW_return_t (*Enable)(void *);
+	/* Command: GSW_RESET ; Index: 0x08 */
+	GSW_return_t (*Reset)(void *, GSW_reset_t *);
+	/* Command: GSW_DISABLE ; Index: 0x09 */
+	GSW_return_t (*Disable)(void *);
+	/* Command: GSW_VERSION_GET ; Index: 0x0A */
+	GSW_return_t (*VersionGet)(void *, GSW_version_t *);
+	/* Command: GSW_CAP_GET ; Index: 0x0B */
+	GSW_return_t (*CapGet)(void *, GSW_cap_t *);
+	/* Command: GSW_CFG_GET ; Index: 0x0C */
+	GSW_return_t (*CfgGet)(void *, GSW_cfg_t *);
+	/* Command: GSW_CFG_SET ; Index: 0x0D */
+	GSW_return_t (*CfgSet)(void *, GSW_cfg_t *);
+	/* Command: GSW_HW_INIT ; Index: 0x0E */
+	GSW_return_t (*HW_Init)(void *, GSW_HW_Init_t *);
+	/* Command: GSW_PORT_LINK_CFG_GET ; Index: 0x0F */
+	GSW_return_t (*PortLinkCfgGet)(void *, GSW_portLinkCfg_t *);
+	/* Command: GSW_PORT_LINK_CFG_SET ; Index: 0x10 */
+	GSW_return_t (*PortLinkCfgSet)(void *, GSW_portLinkCfg_t *);
+	/* Command: GSW_PORT_PHY_ADDR_GET ; Index: 0x11 */
+	GSW_return_t (*PortPHY_AddrGet)(void *, GSW_portPHY_Addr_t *);
+	/* Command: GSW_PORT_PHY_QUERY ; Index: 0x12 */
+	GSW_return_t (*PortPHY_Query)(void *, GSW_portPHY_Query_t *);
+	/* Command: GSW_PORT_RGMII_CLK_CFG_GET ; Index: 0x13 */
+	GSW_return_t (*PortRGMII_ClkCfgGet)(void *, GSW_portRGMII_ClkCfg_t *);
+	/* Command: GSW_PORT_RGMII_CLK_CFG_SET ; Index: 0x14 */
+	GSW_return_t (*PortRGMII_ClkCfgSet)(void *, GSW_portRGMII_ClkCfg_t *);
+	/* Command: GSW_PORT_REDIRECT_GET ; Index: 0x15 */
+	GSW_return_t (*PortRedirectGet)(void *, GSW_portRedirectCfg_t *);
+	/* Command: GSW_PORT_REDIRECT_SET ; Index: 0x16 */
+	GSW_return_t (*PortRedirectSet)(void *, GSW_portRedirectCfg_t *);
+	/* Command: GSW_CPU_PORT_CFG_GET ; Index: 0x17 */
+	GSW_return_t (*CPU_PortCfgGet)(void *, GSW_CPU_PortCfg_t *);
+	/* Command: GSW_CPU_PORT_CFG_SET ; Index: 0x18 */
+	GSW_return_t (*CPU_PortCfgSet)(void *, GSW_CPU_PortCfg_t *);
+	/* Command: GSW_CPU_PORT_EXTEND_CFG_GET ; Index: 0x19 */
+	GSW_return_t (*CPU_PortExtendCfgGet)(void *, GSW_CPU_PortExtendCfg_t *);
+	/* Command: GSW_CPU_PORT_EXTEND_CFG_SET ; Index: 0x1A */
+	GSW_return_t (*CPU_PortExtendCfgSet)(void *, GSW_CPU_PortExtendCfg_t *);
+	/* Command: GSW_MONITOR_PORT_CFG_GET ; Index: 0x1B */
+	GSW_return_t (*MonitorPortCfgGet)(void *, GSW_monitorPortCfg_t *);
+	/* Command: GSW_MONITOR_PORT_CFG_SET ; Index: 0x1C */
+	GSW_return_t (*MonitorPortCfgSet)(void *, GSW_monitorPortCfg_t *);
+	/* Command: GSW_TIMESTAMP_TIMER_SET ; Index: 0x1D */
+	GSW_return_t (*Timestamp_TimerSet)(void *, GSW_TIMESTAMP_Timer_t *);
+	/* Command: GSW_TIMESTAMP_TIMER_GET ; Index: 0x1E */
+	GSW_return_t (*Timestamp_TimerGet)(void *, GSW_TIMESTAMP_Timer_t *);
+	/* Command: GSW_TIMESTAMP_PORT_READ ; Index: 0x1F */
+	GSW_return_t (*Timestamp_PortRead)(void *, GSW_TIMESTAMP_PortRead_t *);
+	/* Command: GSW_PORT_CFG_GET ; Index: 0x20 */
+	GSW_return_t (*PortCfgGet)(void *, GSW_portCfg_t *);
+	/* Command: GSW_PORT_CFG_SET ; Index: 0x21 */
+	GSW_return_t (*PortCfgSet)(void *, GSW_portCfg_t *);
+	/* Command: GSW_MDIO_CFG_GET ; Index: 0x22 */
+	GSW_return_t (*MDIO_CfgGet)(void *, GSW_MDIO_cfg_t *);
+	/* Command: GSW_MDIO_CFG_SET ; Index: 0x23 */
+	GSW_return_t (*MDIO_CfgSet)(void *, GSW_MDIO_cfg_t *);
+	/* Command: GSW_MDIO_DATA_READ ; Index: 0x24 */
+	GSW_return_t (*MDIO_DataRead)(void *, GSW_MDIO_data_t *);
+	/* Command: GSW_MDIO_DATA_WRITE ; Index: 0x25 */
+	GSW_return_t (*MDIO_DataWrite)(void *, GSW_MDIO_data_t *);
+	/* Command: GSW_MMD_DATA_READ ; Index: 0x26 */
+	GSW_return_t (*MmdDataRead)(void *, GSW_MMD_data_t *);
+	/* Command: GSW_MMD_DATA_WRITE ; Index: 0x27 */
+	GSW_return_t (*MmdDataWrite)(void *, GSW_MMD_data_t *);
+};
+
+struct vlan_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_VLAN_MEMBER_INIT ; Index: 0x01 */
+	GSW_return_t (*VLAN_Member_Init)(void *, GSW_VLAN_memberInit_t *);
+	/* Command: GSW_VLAN_ID_CREATE ; Index: 0x02 */
+	GSW_return_t (*VLAN_IdCreate)(void *, GSW_VLAN_IdCreate_t *);
+	/* Command: GSW_VLAN_ID_DELETE ; Index: 0x03 */
+	GSW_return_t (*VLAN_IdDelete)(void *, GSW_VLAN_IdDelete_t *);
+	/* Command: GSW_VLAN_ID_GET ; Index: 0x04 */
+	GSW_return_t (*VLAN_IdGet)(void *, GSW_VLAN_IdGet_t *);
+	/* Command: GSW_VLAN_PORT_CFG_GET ; Index: 0x05 */
+	GSW_return_t (*VLAN_PortCfgGet)(void *, GSW_VLAN_portCfg_t *);
+	/* Command: GSW_VLAN_PORT_CFG_SET ; Index: 0x06 */
+	GSW_return_t (*VLAN_PortCfgSet)(void *, GSW_VLAN_portCfg_t *);
+	/* Command: GSW_VLAN_PORT_MEMBER_ADD ; Index: 0x07 */
+	GSW_return_t (*VLAN_PortMemberAdd)(void *, GSW_VLAN_portMemberAdd_t *);
+	/* Command: GSW_VLAN_PORT_MEMBER_READ ; Index: 0x08 */
+	GSW_return_t (*VLAN_PortMemberRead)(void *, GSW_VLAN_portMemberRead_t *);
+	/* Command: GSW_VLAN_PORT_MEMBER_REMOVE ; Index: 0x09 */
+	GSW_return_t (*VLAN_PortMemberRemove)(void *, GSW_VLAN_portMemberRemove_t *);
+	/* Command: GSW_VLAN_RESERVED_ADD ; Index: 0x0A */
+	GSW_return_t (*VLAN_ReservedAdd)(void *, GSW_VLAN_reserved_t *);
+	/* Command: GSW_VLAN_RESERVED_REMOVE ; Index: 0x0B */
+	GSW_return_t (*VLAN_ReservedRemove)(void *, GSW_VLAN_reserved_t *);
+	/* Command: GSW_PCE_EG_VLAN_CFG_SET ; Index: 0x0C */
+	GSW_return_t (*VLAN_PCE_EG_CfgSet)(void *, GSW_PCE_EgVLAN_Cfg_t *);
+	/* Command: GSW_PCE_EG_VLAN_CFG_GET ; Index: 0x0D */
+	GSW_return_t (*VLAN_PCE_EG_CfgGet)(void *, GSW_PCE_EgVLAN_Cfg_t *);
+	/* Command: GSW_PCE_EG_VLAN_ENTRY_WRITE ; Index: 0x0E */
+	GSW_return_t (*VLAN_PCE_EG_EntryWrite)(void *, GSW_PCE_EgVLAN_Entry_t *);
+	/* Command: GSW_PCE_EG_VLAN_ENTRY_READ ; Index: 0x0F */
+	GSW_return_t (*VLAN_PCE_EG_EntryRead)(void *, GSW_PCE_EgVLAN_Entry_t *);
+	/* Command: GSW_SVLAN_CFG_GET ; Index: 0x10 */
+	GSW_return_t (*SVLAN_CfgGet)(void *, GSW_SVLAN_cfg_t *);
+	/* Command: GSW_SVLAN_CFG_SET ; Index: 0x11 */
+	GSW_return_t (*SVLAN_CfgSet)(void *, GSW_SVLAN_cfg_t *);
+	/* Command: GSW_SVLAN_PORT_CFG_GET ; Index: 0x12 */
+	GSW_return_t (*SVLAN_PortCfgGet)(void *, GSW_SVLAN_portCfg_t *);
+	/* Command: GSW_SVLAN_PORT_CFG_SET ; Index: 0x13 */
+	GSW_return_t (*SVLAN_PortCfgSet)(void *, GSW_SVLAN_portCfg_t *);
+};
+
+/*PMAC operation*/
+struct pmac_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_PMAC_COUNT_GET ; Index: 0x01 */
+	int (*Pmac_CountGet)(void *, GSW_PMAC_Cnt_t *);
+	/* Command: GSW_PMAC_GLBL_CFG_SET ; Index: 0x02 */
+	int (*Pmac_Gbl_CfgSet)(void *, GSW_PMAC_Glbl_Cfg_t *);
+	/* Command: GSW_PMAC_GLBL_CFG_GET ; Index: 0x03 */
+	int (*Pmac_Gbl_CfgGet)(void *, GSW_PMAC_Glbl_Cfg_t *);
+	/* Command: GSW_PMAC_BM_CFG_SET ; Index: 0x04 */
+	int (*Pmac_Bm_CfgSet)(void *, GSW_PMAC_BM_Cfg_t *);
+	/* Command: GSW_PMAC_BM_CFG_GET ; Index: 0x05 */
+	int (*Pmac_Bm_CfgGet)(void *, GSW_PMAC_BM_Cfg_t *);
+	/* Command: GSW_PMAC_IG_CFG_SET ; Index: 0x06 */
+	int (*Pmac_Ig_CfgSet)(void *, GSW_PMAC_Ig_Cfg_t *);
+	/* Command: GSW_PMAC_IG_CFG_GET ; Index: 0x07 */
+	int (*Pmac_Ig_CfgGet)(void *, GSW_PMAC_Ig_Cfg_t *);
+	/* Command: GSW_PMAC_EG_CFG_SET ; Index: 0x08 */
+	int (*Pmac_Eg_CfgSet)(void *, GSW_PMAC_Eg_Cfg_t *);
+	/* Command: GSW_PMAC_EG_CFG_GET ; Index: 0x09 */
+	int (*Pmac_Eg_CfgGet)(void *, GSW_PMAC_Eg_Cfg_t *);
+};
+
+
+
+/*PAE operation*/
+struct pae_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_ROUTE_ENTRY_ADD ; Index: 0x01 */
+	int (*ROUTE_SessionEntryAdd)(void *, GSW_ROUTE_Entry_t *);
+	/* Command: GSW_ROUTE_ENTRY_DELETE ; Index: 0x02 */
+	int (*ROUTE_SessionEntryDel)(void *, GSW_ROUTE_Entry_t *);
+	/* Command: GSW_ROUTE_ENTRY_READ ; Index: 0x03 */
+	int (*ROUTE_SessionEntryRead)(void *, GSW_ROUTE_Entry_t *);
+	/* Command: GSW_ROUTE_TUNNEL_ENTRY_ADD ; Index: 0x04 */
+	int (*ROUTE_TunnelEntryAdd)(void *, GSW_ROUTE_Tunnel_Entry_t *);
+	/* Command: GSW_ROUTE_TUNNEL_ENTRY_READ ; Index: 0x05 */
+	int (*ROUTE_TunnelEntryRead)(void *, GSW_ROUTE_Tunnel_Entry_t *);
+	/* Command: GSW_ROUTE_TUNNEL_ENTRY_DELETE ; Index: 0x06 */
+	int (*ROUTE_TunnelEntryDel)(void *, GSW_ROUTE_Tunnel_Entry_t *);
+	/* Command: GSW_ROUTE_L2NAT_CFG_WRITE ; Index: 0x07 */
+	int (*ROUTE_L2NATCfgWrite)(void *, GSW_ROUTE_EgPort_L2NAT_Cfg_t *);
+	/* Command: GSW_ROUTE_L2NAT_CFG_READ ; Index: 0x08 */
+	int (*ROUTE_L2NATCfgRead)(void *, GSW_ROUTE_EgPort_L2NAT_Cfg_t *);
+	/* Command: GSW_ROUTE_SESSION_HIT_OP ; Index: 0x09 */
+	int (*ROUTE_SessHitOp)(void *, GSW_ROUTE_Session_Hit_t *);
+	/* Command: GSW_ROUTE_SESSION_DEST_MOD ; Index: 0x0A */
+	int (*ROUTE_SessDestModify)(void *, GSW_ROUTE_Session_Dest_t *);
+};
+
+
+struct debug_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_DEBUG_CTPTABLE_STATUS ; Index: 0x01 */
+	GSW_return_t (*DEBUG_CtpTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_BRDGPORTTABLE_STATUS ; Index: 0x02 */
+	GSW_return_t (*DEBUG_BrgPortTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_BRDGTABLE_STATUS ; Index: 0x03 */
+	GSW_return_t (*DEBUG_BrgTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_EXVLANTABLE_STATUS ; Index: 0x04 */
+	GSW_return_t (*DEBUG_ExvlanTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_VLANFILTERTABLE_STATUS ; Index: 0x05 */
+	GSW_return_t (*DEBUG_VlanFilterTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_METERTABLE_STATUS ; Index: 0x06 */
+	GSW_return_t (*DEBUG_MeterTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_DSCP2PCPTABLE_STATUS ; Index: 0x07 */
+	GSW_return_t (*DEBUG_Dscp2PcpTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_PMAPPER_STATUS ; Index: 0x08 */
+	GSW_return_t (*DEBUG_PmapperTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_PMAC_EG ; Index: 0x09 */
+	GSW_return_t (*DEBUG_PmacEg)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_PMAC_IG ; Index: 0x0A */
+	GSW_return_t (*DEBUG_PmacIg)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_DEF_QMAP ; Index: 0x0B */
+	GSW_return_t (*DEBUG_Def_PceQmap)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_DEF_BYP_QMAP ; Index: 0x0C */
+	GSW_return_t (*DEBUG_Def_PceBypQmap)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_PMAC_BP ; Index: 0x0D */
+	GSW_return_t (*DEBUG_PmacBp)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_LP_STATISTICS ; Index: 0x0E */
+	GSW_return_t (*DEBUG_GetLpStatistics)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_CTP_STATISTICS ; Index: 0x0F */
+	GSW_return_t (*DEBUG_GetCtpStatistics)(void *, GSW_debug_t *);
+	/* Command: GSW_XGMAC_CFG ; Index: 0x10 */
+	GSW_return_t (*Xgmac)(void *, GSW_MAC_cfg_t *);
+	/* Command: GSW_GSWSS_CFG ; Index: 0x11 */
+	GSW_return_t (*Gswss)(void *, GSW_MAC_cfg_t *);
+	/* Command: GSW_LMAC_CFG ; Index: 0x12 */
+	GSW_return_t (*Lmac)(void *, GSW_MAC_cfg_t *);
+	/* Command: GSW_MACSEC_CFG ; Index: 0x13 */
+	GSW_return_t (*Macsec)(void *, GSW_MAC_cfg_t *);
+	/* Command: GSW_DUMP_MEM ; Index: 0x14 */
+	GSW_return_t (*DumpMem)(void *, GSW_table_t *);
+	/* Command: GSW_DEBUG_PRINT_PCEIRQ_LIST ; Index: 0x15 */
+	GSW_return_t (*DEBUG_PrintPceIrqList)(void *);
+	/* Command: GSW_DEBUG_RMON_PORT_GET ; Index: 0x16 */
+	GSW_return_t (*DEBUG_RMON_Port_Get)(void *, GSW_Debug_RMON_Port_cnt_t *);
+};
+
+struct irq_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_IRQ_REGISTER ; Index: 0x01 */
+	GSW_return_t (*IRQ_Register)(void *, GSW_Irq_Op_t *);
+	/* Command: GSW_IRQ_UNREGISTER ; Index: 0x02 */
+	GSW_return_t (*IRQ_UnRegister)(void *, GSW_Irq_Op_t *);
+	/* Command: GSW_IRQ_ENABLE ; Index: 0x03 */
+	GSW_return_t (*IRQ_Enable)(void *, GSW_Irq_Op_t *);
+	/* Command: GSW_IRQ_DISABLE ; Index: 0x04 */
+	GSW_return_t (*IRQ_Disable)(void *, GSW_Irq_Op_t *);
+};
+
+
+struct core_ops {
+	/**Switch Opertations**/
+	/*RMON Counters GET opertations for Port/Meter/TFlow/Redirect
+	  RMON Counters Mode SET opertations
+	  RMON Counters CLEAR operations
+	  NOTE: Applicable for GSWIP 3.1 and GSWIP 3.0*/
+
+	struct rmon_ops 			gsw_rmon_ops;
+
+	/*Switch MAC table ADD/READ/QUERY/CLEAR/REMOVE operations
+	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0/GSWIP 2.2
+
+	  Switch Defaul MAC filter SET/GET operations
+	  NOTE: Applicable for GSWIP 3.1 only*/
+
+	struct swmac_ops 			gsw_swmac_ops;
+
+	/*Extended VLAN Block ALLOC/SET/GET/FREE operations
+	  NOTE: Applicable for GSWIP 3.1 only*/
+
+	struct extvlan_ops		gsw_extvlan_ops;
+
+	/*VLAN Filter Block ALLOC/SET/GET/FREE operations
+	  NOTE: Applicable for GSWIP 3.1 only*/
+
+	struct vlanfilter_ops 	gsw_vlanfilter_ops;
+
+	/*CTP Port ALLOC/FREE operations
+	  CTP Port Configuration SET/GET/RESET operations
+	  NOTE: Applicable for GSWIP 3.1 only*/
+
+	struct ctp_ops			gsw_ctp_ops;
+
+	/*Bridge Port ALLOC/FREE operations
+	  Bridge Port Configuration SET/GET operations
+	  NOTE: Applicable for GSWIP 3.1 only*/
+
+	struct brdgport_ops		gsw_brdgport_ops;
+
+	/*Bridge ALLOC/FREE operations
+	  Bridge Configuration SET/GET operations
+	  NOTE: Applicable for GSWIP 3.1 only*/
+
+	struct brdg_ops			gsw_brdg_ops;
+
+	/*TFLOW PCE Rule Read/Write/Delete operations
+	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0/GSWIP 2.2*/
+
+	struct tflow_ops			gsw_tflow_ops;
+
+	/*QOS related operations
+	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0/GSWIP 2.2*/
+
+	struct qos_ops			gsw_qos_ops;
+
+	/*Spanning Tree Protocol opertaions
+	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
+
+	struct stp_ops			gsw_stp_ops;
+
+	/*Extensible Authentication Protocol opertaions
+	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
+
+	struct eapol_ops			gsw_8021x_ops;
+
+	/*Multicast related opertaions
+	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
+
+	struct multicast_ops		gsw_multicast_ops;
+
+	/*Port Trunking opertaions
+	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
+
+	struct trunking_ops		gsw_trunking_ops;
+
+	/*Wake On Lan opertaions
+	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
+
+	struct wol_ops			gsw_wol_ops;
+
+	/*VLAN/SVLAN related opertaions
+	 NOTE: Applicable Only for GSWIP 3.0 and below*/
+
+	struct vlan_ops			gsw_vlan_ops;
+
+	/*PMAC related opertaions
+	 NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
+
+	struct pmac_ops			gsw_pmac_ops;
+
+	/*PAE related opertaions*/
+	struct pae_ops			gsw_pae_ops;
+
+	/*Common Purpose Switch operations like
+	Switch REG read/write
+	Irq mask set/get/status clear
+	Switch enable/disable/reset/init
+	Port monitor set/get
+	Port link get/set
+	Port redirect
+	Time stamp,version get
+	Switch capablity get ..etc
+	 NOTE: Applicable for GSWIP 3.1/GSWIP 3.0/GSWIP 2.2*/
+
+	struct common_ops			gsw_common_ops;
+	/*Debug Purpose for GSWIP 3.1*/
+	struct debug_ops			gsw_debug_ops;
+
+	struct irq_ops			gsw_irq_ops;
+};
+
+
+#endif
diff --git a/include/net/switch_api/gsw_ioctlcmd_type.h b/include/net/switch_api/gsw_ioctlcmd_type.h
new file mode 100644
index 000000000000..a41af3f435c1
--- /dev/null
+++ b/include/net/switch_api/gsw_ioctlcmd_type.h
@@ -0,0 +1,66 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+For licensing information, see the file 'LICENSE' in the root folder of
+this software module.
+******************************************************************************/
+
+
+
+
+
+#ifndef _GSW_FLOW_IOCTLCMD_TYPE_H_
+#define _GSW_FLOW_IOCTLCMD_TYPE_H_
+
+/* RMON IOCTL MAGIC Number */
+#define GSW_RMON_MAGIC 				('A')
+/* Switch MAC IOCTL MAGIC Number */
+#define GSW_MAC_MAGIC  				('B')
+/* Extended IOCTL MAGIC Number */
+#define GSW_EXVLAN_MAGIC 			('C')
+/* VLAN filter IOCTL MAGIC Number */
+#define GSW_VLANFILTER_MAGIC  		('D')
+/* CTP IOCTL MAGIC Number */
+#define GSW_CTP_MAGIC 				('E')
+/* Bridge Port IOCTL MAGIC Number */
+#define GSW_BRDGPORT_MAGIC  		('F')
+/* Bridge IOCTL MAGIC Number */
+#define GSW_BRDG_MAGIC 				('G')
+/* Tflow IOCTL MAGIC Number */
+#define GSW_TFLOW_MAGIC  			('H')
+/* QOS IOCTL MAGIC Number */
+#define GSW_QOS_MAGIC 				('I')
+/* STP IOCTL MAGIC Number */
+#define GSW_STP_MAGIC  				('J')
+/* EAPOL IOCTL MAGIC Number */
+#define GSW_EAPOL_MAGIC 			('K')
+/* Multicast IOCTL MAGIC Number */
+#define GSW_MULTICAST_MAGIC  		('L')
+/* Trunking IOCTL MAGIC Number */
+#define GSW_TRUNKING_MAGIC 			('N')
+/* WOL IOCTL MAGIC Number */
+#define GSW_WOL_MAGIC 				('O')
+/* VLAN IOCTL MAGIC Number */
+#define GSW_VLAN_MAGIC 				('P')
+/* PMAC IOCTL MAGIC Number */
+#define GSW_PMAC_MAGIC  			('Q')
+/* Switch Common usage IOCTL MAGIC Number */
+#define GSW_COMMON_MAGIC 			('R')
+/* Routing IOCTL MAGIC Number */
+#define GSW_ROUTE_MAGIC 			('S')
+/* IOCTL MAGIC */
+#define GSW_MAGIC 					('U')
+/* IOCTL MAGIC */
+#define GSW_FLOW_MAGIC 				('W')
+/* IOCTL DEBUG */
+#define GSW_DEBUG_MAGIC				('V')
+/* IRQ */
+#define GSW_IRQ_MAGIC				('T')
+
+#endif
+
+
+
+
+
+
diff --git a/include/net/switch_api/gsw_irq.h b/include/net/switch_api/gsw_irq.h
new file mode 100644
index 000000000000..900f7eb45761
--- /dev/null
+++ b/include/net/switch_api/gsw_irq.h
@@ -0,0 +1,80 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+For licensing information, see the file 'LICENSE' in the root folder of
+this software module.
+******************************************************************************/
+
+
+#ifndef _GSW_IRQ_H_
+#define _GSW_IRQ_H_
+
+typedef struct {
+	unsigned int blk;
+	unsigned int event;
+	unsigned int portid;
+	void *call_back;
+	void *param;
+} GSW_Irq_Op_t;
+
+typedef enum {
+	BM 		= 0,
+	SDMA	= 1,
+	FDMA	= 2,
+	PCE		= 3,
+	PMAC	= 4
+} GSWIP_IRQ_BLK;
+
+typedef enum {
+	PCE_INVALID_EVENT_IERQ		= 0xFE,
+	PCE_INVALID_PORT_IERQ 		= 0xFF
+} GSWIP_PCE_INVALID_IERQ;
+
+typedef enum {
+	PCE_MAC_TABLE_FULL			= 0,
+	PCE_IGMP_TABLE_FULL			= 1,
+	PCE_PARSER_READY 			= 2,
+	PCE_CLASSIFICATION_PHASE_0 	= 3,
+	PCE_CLASSIFICATION_PHASE_1 	= 4,
+	PCE_CLASSIFICATION_PHASE_2 	= 5,
+	PCE_FLOW_TABLE_RULE_MATCHED = 6,
+	PCE_MAC_TABLE_CHANGE 		= 7,
+} GSWIP_PCE_EVENT;
+
+
+typedef enum {
+	XGMAC_BLK	= 0,
+	LMAC_BLK	= 1,
+} MAC_IRQ_BLK;
+
+typedef enum {
+	XGMAC_TSTAMP_EVNT = 0,
+	XGMAC_LPI_EVNT,
+	XGMAC_TXERR_STS_EVNT,
+	XGMAC_RXERR_STS_EVNT,
+	XGMAC_PMT_EVNT,
+	XGMAC_TXQ_OVFW_EVNT,
+	XGMAC_RXQ_OVFW_EVNT,
+	XGMAC_AVG_BPS_EVNT,
+	LMAC_PHYERR_EVNT,
+	LMAC_ALIGN_EVNT,
+	LMAC_SPEED_EVNT,
+	LMAC_FDUP_EVNT,
+	LMAC_RXPAUEN_EVNT,
+	LMAC_TXPAUEN_EVNT,
+	LMAC_LPIOFF_EVNT,
+	LMAC_LPION_EVNT,
+	LMAC_JAM_EVNT,
+	LMAC_FCSERR_EVNT,
+	LMAC_TXPAU_EVNT,
+	LMAC_RXPAU_EVNT,
+	MAX_IRQ_EVNT,
+	XGMAC_ALL_EVNT,
+	LMAC_ALL_EVNT
+} MAC_IRQ_ENT;
+
+
+// TODO: MACSec IRq Events need to add
+#define MACSEC_MAX_IRQ_EVENT	10
+
+#endif
\ No newline at end of file
diff --git a/include/net/switch_api/gsw_tbl_rw.h b/include/net/switch_api/gsw_tbl_rw.h
new file mode 100644
index 000000000000..3438d1e0223f
--- /dev/null
+++ b/include/net/switch_api/gsw_tbl_rw.h
@@ -0,0 +1,164 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#ifndef _GSW_TBL_RW_H_
+#define _GSW_TBL_RW_H_
+
+#include "gsw_types.h"
+
+/* GSWIP PCE Table Programming structure */
+typedef struct {
+	u16 key[34];
+	u16 mask[4];
+	u16 val[31];
+	u16 table;
+	u16 pcindex;
+	u16 op_mode: 2;
+	u16 extop: 1;
+	u16 kformat: 1;
+	u16 type: 1;
+	u16 valid: 1;
+	u16 group: 4;
+} pctbl_prog_t;
+
+/* GSWIP BM Table ID to access different tables */
+typedef enum {
+	CTP_PORT_RX_RMON 				= 0x00,
+	CTP_PORT_TX_RMON 				= 0x01,
+	BRIDGE_PORT_RX_RMON 				= 0x02,
+	BRIDGE_PORT_TX_RMON				= 0x03,
+	CTP_PORT_PCE_BYPASS_TX_RMON			= 0x04,
+	FLOW_RX_RMON					= 0x05,
+	FLOW_TX_RMON					= 0x06,
+	WFQ_PARAM					= 0x08,
+	PQM_THRESHOLD					= 0x09,
+	PQM_PACKET_PTR					= 0x0A,
+	SSL_NEXT_PTR_MEM				= 0x0B,
+	SSL_HEADER_DES_MEM1				= 0x0C,
+	SSL_HEADER_DES_MEM2				= 0x0D,
+	BUF_MGR_Q_MAP_TABLE				= 0x0E,
+	METER_RMON_COUNTER				= 0x19,
+	ROUTING_RMON_COUNTER				= 0x1B,
+	PMAC_RMON_COUNTER				= 0x1C,
+} BM_Table_ID;
+
+/* GSWIP BM Table Address */
+typedef union {
+	u16 raw;
+#if CONFIG_CPU_BIG_ENDIAN
+	struct {
+		u16 b15: 1, b14: 1, b13: 1, b12: 1, b11: 1, b10: 1, b9: 1, b8: 1,
+		    b7: 1, b6: 1, b5: 1, b4: 1, b3: 1, b2: 1, b1: 1, b0: 1;
+	} bits;
+	struct {
+		u16 portOffset: 10, counterOffset: 6;
+	} rmon;
+	struct {
+		u16 reserved0: 10, nQueueId: 6;
+	} wfq;
+	struct {
+		u16 reserved1: 7, nQueueId: 6, mode: 1, color_or_submode: 2;
+	} pqmThr;
+	struct {
+		u16 reserved2: 5, ptr: 11;
+	} pqmPtr;
+	struct {
+		u16 reserved3: 6, ptr: 10;
+	} ssl;
+	struct {
+		u16 reserved4: 10, nQueueId: 6;
+	} qMapTbl;
+	struct {
+		u16 reserved6: 6, color: 2, reserved5: 1, meterNo: 7;
+	} meterRmon;
+	struct {
+		u16 reserved7: 8, counterType: 4, portNo: 4 ;
+	} routingRmon;
+	struct {
+		u16 reserved8: 5, pmacNo: 3, count: 3, channel_or_port: 5;
+	} pmacRmon;
+#else
+	struct {
+		u16 b0: 1, b1: 1, b2: 1, b3: 1, b4: 1, b5: 1, b6: 1, b7: 1,
+		    b8: 1, b9: 1, b10: 1, b11: 1, b12: 1, b13: 1, b14: 1, b15: 1;
+	} bits;
+	struct {
+		u16 counterOffset: 6, portOffset: 10;
+	} rmon;
+	struct {
+		u16 nQueueId: 6, reserved0: 10;
+	} wfq;
+	struct {
+		u16 color_or_submode: 2, mode: 1, nQueueId: 6, reserved1: 7;
+	} pqmThr;
+	struct {
+		u16 ptr: 11, reserved2: 5;
+	} pqmPtr;
+	struct {
+		u16 ptr: 10, reserved3: 6;
+	} ssl;
+	struct {
+		u16 nQueueId: 6, reserved4: 10;
+	} qMapTbl;
+	struct {
+		u16 meterNo: 7, reserved5: 1, color: 2, reserved6: 6;
+	} meterRmon;
+	struct {
+		u16 portNo: 4, counterType: 4, reserved7: 8;
+	} routingRmon;
+	struct {
+		u16 channel_or_port: 5, count: 3, pmacNo: 3, reserved8: 5;
+	} pmacRmon;
+#endif
+
+} BM_Table_Address ;
+
+/* GSWIP BM Table programming structure */
+typedef struct {
+	BM_Table_ID  tableID;
+	BM_Table_Address adr;
+	u32 value[10];
+	ltq_bool_t b64bitMode;
+	u32 numValues;
+} bmtbl_prog_t;
+
+/* GSWIP PMAC Table programming structure */
+typedef struct {
+	u16 val[8];
+	u16 ptaddr;
+	u16 ptcaddr;
+	u16 op_mode;
+	u16 pmacId;
+	/*	u16 valid:1; */
+} pmtbl_prog_t;
+
+/* GSWIP Table structure to access all tables */
+typedef struct {
+	u8 tbl_entry;
+	/** Start offset mem dump purpose */
+	u32 tbl_addr;
+	u32 tbl_id;
+	u32 bm_numValues;
+	pctbl_prog_t ptdata;
+	bmtbl_prog_t bmtable;
+	pmtbl_prog_t pmactable;
+} GSW_table_t;
+
+int gsw_pce_table_write(void *cdev, pctbl_prog_t *ptdata);
+int gsw_pce_table_read(void *cdev, pctbl_prog_t *ptdata);
+int xwayflow_pmac_table_read(void *cdev, pmtbl_prog_t *ptdata);
+int xwayflow_pmac_table_write(void *cdev, pmtbl_prog_t *ptdata);
+int route_table_read(void *cdev, pctbl_prog_t *rdata);
+int route_table_write(void *cdev, pctbl_prog_t *rdata);
+GSW_return_t gsw_bm_table_read(void *cdev, bmtbl_prog_t *ptdata);
+GSW_return_t gsw_bm_table_write(void *cdev, bmtbl_prog_t *ptdata);
+u32 pmac_addr_off(u32 off, u32 id);
+
+#endif
+
diff --git a/include/net/switch_api/gsw_types.h b/include/net/switch_api/gsw_types.h
new file mode 100644
index 000000000000..713562f7f3f0
--- /dev/null
+++ b/include/net/switch_api/gsw_types.h
@@ -0,0 +1,68 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+#ifndef _GSW_TYPES_H_
+#define _GSW_TYPES_H_
+/** \file gsw_types.h GSW Base Types */
+
+/** \brief MAC Address Field Size.
+    Number of bytes used to store MAC address information. */
+#define GSW_MAC_ADDR_LEN 6
+/** \brief Instantiated tables entries name  string length.
+    The user can supply a name and get in return an id from Switch API. */
+#define GSW_NAME_LEN	32
+/** \brief This is the unsigned 64-bit datatype. */
+typedef unsigned long long    u64;
+/** \brief This is the unsigned 32-bit datatype. */
+typedef unsigned int    u32;
+/** \brief This is the unsigned 8-bit datatype. */
+typedef unsigned char   u8;
+/** \brief This is the unsigned 16-bit datatype. */
+typedef unsigned short  u16;
+/** \brief This is the signed 16-bit datatype. */
+typedef short  i16;
+/** \brief This is the signed 8-bit datatype. */
+typedef char  i8;
+/** \brief This is the signed 32-bit datatype. */
+typedef long  i32;
+
+/** \brief This enumeration type defines two boolean states: False and True. */
+typedef enum {
+	/** Boolean False. */
+	LTQ_FALSE		= 0,
+	/** Boolean True. */
+	LTQ_TRUE		= 1
+} ltq_bool_t;
+
+/** \brief This is a union to describe the IPv4 and IPv6 Address in numeric representation. Used by multiple Structures and APIs. The member selection would be based upon \ref GSW_IP_Select_t */
+typedef union {
+	/** Describe the IPv4 address.
+	    Only used if the IPv4 address should be read or configured.
+	    Cannot be used together with the IPv6 address fields. */
+	u32	nIPv4;
+	/** Describe the IPv6 address.
+	    Only used if the IPv6 address should be read or configured.
+	    Cannot be used together with the IPv4 address fields. */
+	u16	nIPv6[8];
+} GSW_IP_t;
+
+/** \brief Selection to use IPv4 or IPv6.
+    Used  along with \ref GSW_IP_t to denote which union member to be accessed.
+*/
+typedef enum {
+	/** IPv4 Type */
+	GSW_IP_SELECT_IPV4	= 0,
+	/** IPv6 Type */
+	GSW_IP_SELECT_IPV6	= 1
+} GSW_IP_Select_t;
+
+
+#endif
diff --git a/include/net/switch_api/lantiq_gsw.h b/include/net/switch_api/lantiq_gsw.h
new file mode 100755
index 000000000000..58638d11609d
--- /dev/null
+++ b/include/net/switch_api/lantiq_gsw.h
@@ -0,0 +1,7467 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+
+
+#ifndef _LANTIQ_GSW_H_
+#define _LANTIQ_GSW_H_
+
+/* =================================== */
+/* Global typedef forward declarations */
+/* =================================== */
+
+/* ============================= */
+/* Local Macros & Definitions    */
+/* ============================= */
+#include "gsw_types.h"
+
+
+/** \defgroup GSW_GROUP GSWIP Functional APIs
+    \brief This chapter describes the entire interface for accessing and configuring the different services of the Ethernet Switch module. The prefix GSW (Gigabit Switch) is used for all data structures and APIs pertaining to GSWIP.
+*/
+
+/*@{*/
+
+/** \defgroup GSW_IOCTL_BRIDGE Ethernet Bridging Functions
+    \brief Ethernet bridging (or switching) is the basic task of the device. It provides individual configurations per port and standard global switch features.
+*/
+
+/** \defgroup GSW_IOCTL_VLAN VLAN Functions
+    \brief This section describes VLAN bridging functionality. This includes support for Customer VLAN Tags (C-VLAN) and also Service VLAN Tags (S-VLAN).
+     The Egress VLAN Treatment is new addition to GSWIP-3.0.
+*/
+
+/** \defgroup GSW_IOCTL_MULTICAST Multicast Functions
+    \brief Group of functional APIs for IGMP/MLD snooping configuration and support for IGMPv1/v2/v3 and MLDv1/v2.
+*/
+
+/** \defgroup GSW_IOCTL_OAM Operation, Administration, and Management Functions
+    \brief Group of functions that are provided to perform OAM functions on Switch.
+*/
+
+/** \defgroup GSW_IOCTL_QOS Quality of Service Functions
+    \brief Group of functional APIs for Quality of Service (QoS) components.
+*/
+
+/** \defgroup GSW_IOCTL_PMAC Pseudo-MAC Functions
+    \brief Group of functional APIs for Pseudo MAC (PMAC). The PMAC config is applicable to GSWIP-3.0 only.
+*/
+
+/** \defgroup GSW_IOCTL_RMON RMON Counters Functions
+    \brief Group of functional APIs for Remote-Monitoring (RMON) counters.
+*/
+
+/** \defgroup GSW_IOCTL_GSWIP31 GSWIP-3.1 Specific Functions
+    \brief Group of functional APIs for GSWIP-3.1 to cover GPON/EPON/G.INT.
+*/
+
+/*@}*/
+
+/* -------------------------------------------------------------------------- */
+/*                 Structure and Enumeration Type Defintions                  */
+/* -------------------------------------------------------------------------- */
+
+/** \addtogroup GSW_IOCTL_BRIDGE */
+/*@{*/
+/** \brief MAC Table Entry to be read.
+    Used by \ref GSW_MAC_TABLE_ENTRY_READ. */
+typedef struct {
+	/** Restart the get operation from the beginning of the table. Otherwise
+	    return the next table entry (next to the entry that was returned
+	    during the previous get operation). This boolean parameter is set by the
+	    calling application. */
+	ltq_bool_t bInitial;
+	/** Indicates that the read operation got all last valid entries of the
+	    table. This boolean parameter is set by the switch API
+	    when the Switch API is called after the last valid one was returned already. */
+	ltq_bool_t bLast;
+	/** Get the MAC table entry belonging to the given Filtering Identifier
+	    (not supported by all switches). */
+	u32 nFId;
+	/** Ethernet Port number (zero-based counting) in GSWIP-2.1/2.2/3.0. From
+	    GSWIP-3.1, this field is Bridge Port ID. The valid range is hardware
+	    dependent.
+
+	    \remarks
+	    In GSWIP-2.1/2.2/3.0, this field is used as portmap field, when the MSB
+	    bit is set. In portmap mode, every value bit represents an Ethernet port.
+	    LSB represents Port 0 with incrementing counting.
+	    The (MSB - 1) bit represent the last port.
+	    The macro \ref GSW_PORTMAP_FLAG_SET allows to set the MSB bit,
+	    marking it as portmap variable.
+	    Checking the portmap flag can be done by
+	    using the \ref GSW_PORTMAP_FLAG_GET macro.
+	    From GSWIP3.1, if MSB is set, other bits in this field are ignored.
+	    array \ref GSW_MAC_tableRead_t::nPortMap is used for bit map. */
+	u32 nPortId;
+	/** Bridge Port Map - to support GSWIP-3.1, following field is added
+	    for port map in static entry. It's valid only when MSB of
+	    \ref GSW_MAC_tableRead_t::nPortId is set. Each bit stands for 1 bridge
+	    port. */
+	u16 nPortMap[16];
+	/** Aging Time, given in multiples of 1 second in a range from 1 s to 1,000,000 s.
+	    The value read back in a GET command might differ slightly from the value
+	    given in the SET command due to limited hardware timing resolution.
+	    Filled out by the switch API implementation. */
+	int nAgeTimer;
+	/** STAG VLAN Id. Only applicable in case SVLAN support is enabled on the device. */
+	u16 nSVLAN_Id;
+	/** Static Entry (value will be aged out after 'nAgeTimer' if the entry
+	    is not set to static). */
+	ltq_bool_t bStaticEntry;
+	/** Sub-Interface Identifier Destination (supported in GSWIP-3.0/3.1 only). */
+	u16 nSubIfId;
+	/** MAC Address. Filled out by the switch API implementation. */
+	u8 nMAC[GSW_MAC_ADDR_LEN];
+	/** Source/Destination MAC address filtering flag (GSWIP-3.1 only)
+	    Value 0 - not filter, 1 - source address filter,
+	    2 - destination address filter, 3 - both source and destination filter.
+
+	    \remarks
+	    Please refer to "GSWIP Hardware Architecture Spec" chapter 3.4.4.6
+	    "Source MAC Address Filtering and Destination MAC Address Filtering"
+	    for more detail. */
+	u8 nFilterFlag;
+	/** Packet is marked as IGMP controlled if destination MAC address matches
+	    MAC in this entry. (GSWIP-3.1 only) */
+	ltq_bool_t bIgmpControlled;
+
+	/** Changed
+	0: the entry is not changed
+	1: the entry is changed and not accessed yet */
+
+	ltq_bool_t bEntryChanged;
+} GSW_MAC_tableRead_t;
+
+/** \brief Search for a MAC address entry in the address table.
+    Used by \ref GSW_MAC_TABLE_ENTRY_QUERY. */
+typedef struct {
+	/** MAC Address. This parameter needs to be provided for the search operation.
+	    This is an input parameter. */
+	u8 nMAC[GSW_MAC_ADDR_LEN];
+	/** Get the MAC table entry belonging to the given Filtering Identifier
+	    (not supported by all switches).
+	    This is an input parameter. */
+	u32 nFId;
+	/** MAC Address Found. Switch API sets this boolean variable in case
+	    the requested MAC address 'nMAC' is found inside the address table,
+	    otherwise it is set to FALSE.
+	    This is an output parameter. */
+	ltq_bool_t bFound;
+	/** Ethernet Port number (zero-based counting) in GSWIP-2.1/2.2/3.0. From
+	    GSWIP-3.1, this field is Bridge port ID. The valid range is hardware
+	    dependent.
+
+	    \remarks
+	    In GSWIP-2.1/2.2/3.0, this field is used as portmap field, when the MSB
+	    bit is set. In portmap mode, every value bit represents an Ethernet port.
+	    LSB represents Port 0 with incrementing counting.
+	    The (MSB - 1) bit represent the last port.
+	    The macro \ref GSW_PORTMAP_FLAG_SET allows to set the MSB bit,
+	    marking it as portmap variable.
+	    Checking the portmap flag can be done by
+	    using the \ref GSW_PORTMAP_FLAG_GET macro.
+	    From GSWIP3.1, if MSB is set, other bits in this field are ignored.
+	    array \ref GSW_MAC_tableRead_t::nPortMap is used for bit map. */
+	u32 nPortId;
+	/** Bridge Port Map - to support GSWIP-3.1, following field is added
+	    for port map in static entry. It's valid only when MSB of
+	    \ref GSW_MAC_tableRead_t::nPortId is set. Each bit stands for 1 bridge
+	    port. */
+	u16 nPortMap[16];
+	/** Sub-Interface Identifier Destination (supported in GSWIP-3.0/3.1 only). */
+	u16 nSubIfId;
+	/** Aging Time, given in multiples of 1 second in a range from 1 s to 1,000,000 s.
+	    The value read back in a GET command might differ slightly from the value
+	    given in the SET command due to limited hardware timing resolution.
+	    Filled out by the switch API implementation.
+	    This is an output parameter. */
+	int nAgeTimer;
+	/** STAG VLAN Id. Only applicable in case SVLAN support is enabled on the device. */
+	u16 nSVLAN_Id;
+	/** Static Entry (value will be aged out after 'nAgeTimer' if the entry
+	    is not set to static).
+	    This is an output parameter. */
+	ltq_bool_t bStaticEntry;
+	/** Source/Destination MAC address filtering flag (GSWIP-3.1 only)
+	    Value 0 - not filter, 1 - source address filter,
+	    2 - destination address filter, 3 - both source and destination filter.
+
+	    \remarks
+	    Please refer to "GSWIP Hardware Architecture Spec" chapter 3.4.4.6
+	    "Source MAC Address Filtering and Destination MAC Address Filtering"
+	    for more detail. */
+	u8 nFilterFlag;
+
+	/** Packet is marked as IGMP controlled if destination MAC address matches
+	    MAC in this entry. (GSWIP-3.1 only) */
+	ltq_bool_t bIgmpControlled;
+
+	/** Changed
+	0: the entry is not changed
+	1: the entry is changed and not accessed yet */
+	ltq_bool_t bEntryChanged;
+} GSW_MAC_tableQuery_t;
+
+/** \brief MAC Table Entry to be added.
+    Used by \ref GSW_MAC_TABLE_ENTRY_ADD. */
+typedef struct {
+	/** Filtering Identifier (FID) (not supported by all switches) */
+	u32 nFId;
+	/** Ethernet Port number (zero-based counting) in GSWIP-2.1/2.2/3.0. From
+	    GSWIP-3.1, this field is Bridge Port ID. The valid range is hardware
+	    dependent.
+
+	    \remarks
+	    In GSWIP-2.1/2.2/3.0, this field is used as portmap field, when the MSB
+	    bit is set. In portmap mode, every value bit represents an Ethernet port.
+	    LSB represents Port 0 with incrementing counting.
+	    The (MSB - 1) bit represent the last port.
+	    The macro \ref GSW_PORTMAP_FLAG_SET allows to set the MSB bit,
+	    marking it as portmap variable.
+	    Checking the portmap flag can be done by
+	    using the \ref GSW_PORTMAP_FLAG_GET macro.
+	    From GSWIP3.1, if MSB is set, other bits in this field are ignored.
+	    array \ref GSW_MAC_tableRead_t::nPortMap is used for bit map. */
+	u32 nPortId;
+	/** Bridge Port Map - to support GSWIP-3.1, following field is added
+	    for port map in static entry. It's valid only when MSB of
+	    \ref GSW_MAC_tableRead_t::nPortId is set. Each bit stands for 1 bridge
+	    port. */
+	u16 nPortMap[16];
+	/** Sub-Interface Identifier Destination (supported in GSWIP-3.0/3.1 only).
+
+	    \remarks
+	    In GSWIP-3.1, this field is sub interface ID for WLAN logical port. For
+	    Other types, either outer VLAN ID if Nto1Vlan enabled or 0. */
+	u16 nSubIfId;
+	/** Aging Time, given in multiples of 1 second in a range
+	    from 1 s to 1,000,000 s.
+	    The configured value might be rounded that it fits to the given hardware platform. */
+	int nAgeTimer;
+	/** STAG VLAN Id. Only applicable in case SVLAN support is enabled on the device. */
+	u16 nSVLAN_Id;
+	/** Static Entry (value will be aged out if the entry is not set to static). The
+	    switch API implementation uses the maximum age timer in case the entry
+	    is not static. */
+	ltq_bool_t bStaticEntry;
+	/** Egress queue traffic class.
+	    The queue index starts counting from zero.   */
+	u8 nTrafficClass;
+	/** MAC Address to add to the table. */
+	u8 nMAC[GSW_MAC_ADDR_LEN];
+	/** Source/Destination MAC address filtering flag (GSWIP-3.1 only)
+	    Value 0 - not filter, 1 - source address filter,
+	    2 - destination address filter, 3 - both source and destination filter.
+
+	    \remarks
+	    Please refer to "GSWIP Hardware Architecture Spec" chapter 3.4.4.6
+	    "Source MAC Address Filtering and Destination MAC Address Filtering"
+	    for more detail. */
+	u8 nFilterFlag;
+	/** Packet is marked as IGMP controlled if destination MAC address matches
+	    MAC in this entry. (GSWIP-3.1 only) */
+	ltq_bool_t bIgmpControlled;
+} GSW_MAC_tableAdd_t;
+
+/** \brief MAC Table Entry to be removed.
+    Used by \ref GSW_MAC_TABLE_ENTRY_REMOVE. */
+typedef struct {
+	/** Filtering Identifier (FID) (not supported by all switches) */
+	u32 nFId;
+	/** MAC Address to be removed from the table. */
+	u8 nMAC[GSW_MAC_ADDR_LEN];
+	/** Source/Destination MAC address filtering flag (GSWIP-3.1 only)
+	    Value 0 - not filter, 1 - source address filter,
+	    2 - destination address filter, 3 - both source and destination filter.
+
+	    \remarks
+	    Please refer to "GSWIP Hardware Architecture Spec" chapter 3.4.4.6
+	    "Source MAC Address Filtering and Destination MAC Address Filtering"
+	    for more detail. */
+	u8 nFilterFlag;
+} GSW_MAC_tableRemove_t;
+
+/** \brief Packet forwarding.
+    Used by \ref GSW_STP_BPDU_Rule_t and \ref GSW_multicastSnoopCfg_t
+    and \ref GSW_8021X_EAPOL_Rule_t. */
+typedef enum {
+	/** Default; portmap is determined by the forwarding classification. */
+	GSW_PORT_FORWARD_DEFAULT = 0,
+	/** Discard; discard packets. */
+	GSW_PORT_FORWARD_DISCARD = 1,
+	/** Forward to the CPU port. This requires that the CPU port is previously
+	    set by calling \ref GSW_CPU_PORT_CFG_SET. */
+	GSW_PORT_FORWARD_CPU = 2,
+	/** Forward to a port, selected by the parameter 'nForwardPortId'.
+	    Please note that this feature is not supported by all
+	    hardware platforms. */
+	GSW_PORT_FORWARD_PORT = 3
+} GSW_portForward_t;
+
+/** \brief Spanning Tree Protocol port states.
+    Used by \ref GSW_STP_portCfg_t. */
+typedef enum {
+	/** Forwarding state. The port is allowed to transmit and receive
+	    all packets. Address Learning is allowed. */
+	GSW_STP_PORT_STATE_FORWARD = 0,
+	/** Disabled/Discarding state. The port entity will not transmit
+	    and receive any packets. Learning is disabled in this state. */
+	GSW_STP_PORT_STATE_DISABLE = 1,
+	/** Learning state. The port entity will only transmit and receive
+	    Spanning Tree Protocol packets (BPDU). All other packets are discarded.
+	    MAC table address learning is enabled for all good frames. */
+	GSW_STP_PORT_STATE_LEARNING = 2,
+	/** Blocking/Listening. Only the Spanning Tree Protocol packets will
+	    be received and transmitted. All other packets are discarded by
+	    the port entity. MAC table address learning is disabled in this
+	    state. */
+	GSW_STP_PORT_STATE_BLOCKING = 3
+} GSW_STP_PortState_t;
+
+/** \brief Configures the Spanning Tree Protocol state of an Ethernet port.
+    Used by \ref GSW_STP_PORT_CFG_SET
+    and \ref GSW_STP_PORT_CFG_GET. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting) in GSWIP-2.1/2.2/3.0. From
+	    GSWIP-3.1, this field is Bridge Port ID. The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u32 nPortId;
+	/** Filtering Identifier (FID) (not supported by all switches).
+	    The FID allows to keep multiple STP states per physical Ethernet port.
+	    Multiple CTAG VLAN groups could be a assigned to one FID and therefore
+	    share the same STP port state. Switch API ignores the FID value
+	    in case the switch device does not support it or switch CTAG VLAN
+	    awareness is disabled. */
+	u32 nFId;
+	/** Spanning Tree Protocol state of the port. */
+	GSW_STP_PortState_t ePortState;
+} GSW_STP_portCfg_t;
+
+/** \brief Spanning tree packet detection and forwarding.
+    Used by \ref GSW_STP_BPDU_RULE_SET
+    and \ref GSW_STP_BPDU_RULE_GET. */
+typedef struct {
+	/** Filter spanning tree packets and forward them, discard them or
+	    disable the filter. */
+	GSW_portForward_t eForwardPort;
+	/** Target (bridge) port for forwarded packets; only used if selected by
+	    'eForwardPort'. Forwarding is done
+	    if 'eForwardPort = GSW_PORT_FORWARD_PORT'. */
+	u8 nForwardPortId;
+} GSW_STP_BPDU_Rule_t;
+
+/** \brief Describes the 802.1x port state.
+    Used by \ref GSW_8021X_portCfg_t. */
+typedef enum {
+	/** Receive and transmit direction are authorized. The port is allowed to
+	    transmit and receive all packets and the address learning process is
+	    also allowed. */
+	GSW_8021X_PORT_STATE_AUTHORIZED = 0,
+	/** Receive and transmit direction are unauthorized. All the packets
+	    except EAPOL are not allowed to transmit and receive. The address learning
+	    process is disabled. */
+	GSW_8021X_PORT_STATE_UNAUTHORIZED = 1,
+	/** Receive direction is authorized, transmit direction is unauthorized.
+	    The port is allowed to receive all packets. Packet transmission to this
+	    port is not allowed. The address learning process is also allowed. */
+	GSW_8021X_PORT_STATE_RX_AUTHORIZED = 2,
+	/** Transmit direction is authorized, receive direction is unauthorized.
+	    The port is allowed to transmit all packets. Packet reception on this
+	    port is not allowed. The address learning process is disabled. */
+	GSW_8021X_PORT_STATE_TX_AUTHORIZED = 3
+} GSW_8021X_portState_t;
+
+/** \brief EAPOL frames filtering rule parameter.
+    Used by \ref GSW_8021X_EAPOL_RULE_GET
+    and \ref GSW_8021X_EAPOL_RULE_SET. */
+typedef struct {
+	/** Filter authentication packets and forward them, discard them or
+	    disable the filter. */
+	GSW_portForward_t eForwardPort;
+	/** Target (bridge) port for forwarded packets, only used if selected by
+	    'eForwardPort'. Forwarding is done
+	    if 'eForwardPort = GSW_PORT_FORWARD_PORT'. */
+	u8 nForwardPortId;
+} GSW_8021X_EAPOL_Rule_t;
+
+/** \brief 802.1x port authentication status.
+    Used by \ref GSW_8021X_PORT_CFG_GET
+    and \ref GSW_8021X_PORT_CFG_SET. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting) in GSWIP-2.1/2.2/3.0. From
+	    GSWIP-3.1, this field is Bridge Port ID. The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u32 nPortId;
+	/** 802.1x state of the port. */
+	GSW_8021X_portState_t eState;
+} GSW_8021X_portCfg_t;
+
+/** \brief Global Ethernet trunking configuration.
+    Used by \ref GSW_TRUNKING_CFG_GET
+    and \ref GSW_TRUNKING_CFG_SET. */
+typedef struct {
+	/** IP source address is used by the
+	    hash algorithm to calculate the egress trunking port index. */
+	ltq_bool_t bIP_Src;
+	/** IP destination address is used by the
+	    hash algorithm to calculate the egress trunking port index. */
+	ltq_bool_t bIP_Dst;
+	/** MAC source address is used by the
+	    hash algorithm to calculate the egress trunking port index. */
+	ltq_bool_t bMAC_Src;
+	/** MAC destination address is used by the
+	    hash algorithm to calculate the egress trunking port index. */
+	ltq_bool_t bMAC_Dst;
+} GSW_trunkingCfg_t;
+
+/** \brief Ethernet port trunking configuration.
+    Used by \ref GSW_TRUNKING_PORT_CFG_GET
+    and \ref GSW_TRUNKING_PORT_CFG_SET. */
+typedef struct {
+	/** Ports are aggregated.
+	    Enabling means that the 'nPortId' and
+	    the 'nAggrPortId' ports form an aggregated link. */
+	ltq_bool_t bAggregateEnable;
+	/** Ethernet Port number (zero-based counting).
+	    The valid range is hardware dependent.
+	    An error code is delivered if the selected port is not
+	    available. */
+	u32 nPortId;
+	/** Second Aggregated Ethernet Port number (zero-based counting).
+	    The valid range is hardware dependent.
+	    An error code is delivered if the selected port is not
+	    available. */
+	u32 nAggrPortId;
+} GSW_trunkingPortCfg_t;
+
+/*@}*/ /* GSW_IOCTL_BRIDGE */
+
+/** \addtogroup GSW_IOCTL_VLAN */
+/*@{*/
+
+/** \brief VLAN port configuration for ingress packet filtering. Tagged packet and
+    untagged packet can be configured to be accepted or dropped (filtered out).
+    Used by \ref GSW_VLAN_portCfg_t. */
+typedef enum {
+	/** Admit all. Tagged and untagged packets are allowed. */
+	GSW_VLAN_ADMIT_ALL = 0,
+	/** Untagged packets only (not supported yet). Tagged packets are dropped. */
+	GSW_VLAN_ADMIT_UNTAGGED = 1,
+	/** Tagged packets only. Untagged packets are dropped. */
+	GSW_VLAN_ADMIT_TAGGED = 2
+} GSW_VLAN_Admit_t;
+
+/** \brief Add a CTAG VLAN ID group to the CTAG VLAN hardware table of the switch.
+    Used by \ref GSW_VLAN_ID_CREATE. Not applicable to GSWIP-3.1. */
+typedef struct {
+	/** CTAG VLAN ID. The valid range is from 0 to 4095.
+	    An error code is delivered in case of range mismatch. */
+	u16 nVId;
+	/** Filtering Identifier (FID) (not supported by all switches). */
+	u32 nFId;
+} GSW_VLAN_IdCreate_t;
+
+/** \brief Read out the CTAG VLAN ID to FID assignment. The user provides the CTAG VLAN ID
+    parameter and the switch API returns the FID parameter.
+    Used by \ref GSW_VLAN_ID_GET. Not applicable to GSWIP-3.1. */
+typedef struct {
+	/** CTAG VLAN ID. The valid range is from 0 to 4095.
+	    An error code is delivered in case of range mismatch. */
+	u16 nVId;
+	/** Filtering Identifier (FID) (not supported by all switches). */
+	u32 nFId;
+} GSW_VLAN_IdGet_t;
+
+/** \brief Default VLAN membership portmap and egress tagmap for unconfigured VLAN groups.
+    Every bit in the portmap variables represents one port (port 0 = LSB bit).
+    Used by \ref GSW_VLAN_MEMBER_INIT. Not applicable to GSWIP-3.1. */
+typedef struct {
+	/** Portmap field of the uninitialized VLAN groups. */
+	u32 nPortMemberMap;
+	/** Egress tagmap field of the uninitialized VLAN groups. */
+	u32 nEgressTagMap;
+} GSW_VLAN_memberInit_t;
+
+/** \brief Remove a CTAG VLAN ID from the switch CTAG VLAN table.
+    Used by \ref GSW_VLAN_ID_DELETE. Not applicable to GSWIP-3.1. */
+typedef struct {
+	/** CTAG VLAN ID. The valid range is from 0 to 4095.
+	    An error code is delivered in case of range mismatch. */
+	u16 nVId;
+} GSW_VLAN_IdDelete_t;
+
+/** \brief Adds a CTAG VLAN to a port and set its egress filter information.
+    Used by \ref GSW_VLAN_PORT_MEMBER_ADD. Not applicable to GSWIP-3.1. */
+typedef struct {
+	/** CTAG VLAN ID. The valid range is from 0 to 4095.
+	    An error code is delivered in case of range mismatch. */
+	u16 nVId;
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available.
+
+	    \remarks
+	    This field is used as portmap field, when the MSB bit is set.
+	    In portmap mode, every value bit represents an Ethernet port.
+	    LSB represents Port 0 with incrementing counting.
+	    The (MSB - 1) bit represent the last port.
+	    The macro \ref GSW_PORTMAP_FLAG_SET allows to set the MSB bit,
+	    marking it as portmap variable.
+	    Checking the portmap flag can be done by
+	    using the \ref GSW_PORTMAP_FLAG_GET macro. */
+	u32 nPortId;
+	/** Tag Member Egress. Enable egress tag-based support.
+	    If enabled, all port egress traffic
+	    from this CTAG VLAN group carries a CTAG VLAN group tag. */
+	ltq_bool_t bVLAN_TagEgress;
+} GSW_VLAN_portMemberAdd_t;
+
+/** \brief Remove the CTAG VLAN configuration from an Ethernet port.
+    Used by \ref GSW_VLAN_PORT_MEMBER_REMOVE. Not applicable to GSWIP-3.1. */
+typedef struct {
+	/** CTAG VLAN ID. The valid range is from 0 to 4095.
+	    An error code is delivered in case of range mismatch.
+	    If the selected VLAN ID is not found in the VLAN table,
+	    an error code is delivered. */
+	u16 nVId;
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available.
+
+	    \remarks
+	    This field is used as portmap field, when the MSB bit is set.
+	    In portmap mode, every value bit represents an Ethernet port.
+	    LSB represents Port 0 with incrementing counting.
+	    The (MSB - 1) bit represent the last port.
+	    The macro \ref GSW_PORTMAP_FLAG_SET allows to set the MSB bit,
+	    marking it as portmap variable.
+	    Checking the portmap flag can be done by
+	    using the \ref GSW_PORTMAP_FLAG_GET macro. */
+	u32 nPortId;
+} GSW_VLAN_portMemberRemove_t;
+
+/** \brief Read the CTAG VLAN port membership table.
+    Used by \ref GSW_VLAN_PORT_MEMBER_READ. Not applicable to GSWIP-3.1. */
+typedef struct {
+	/** Restart the get operation from the start of the table. Otherwise
+	    return the next table entry (next to the entry that was returned
+	    during the previous get operation). This parameter is always reset
+	    during the read operation. This boolean parameter is set by the
+	    calling application. */
+	ltq_bool_t bInitial;
+	/** Indicates that the read operation got all last valid entries of the
+	    table. This boolean parameter is set by the switch API
+	    when the Switch API is called after the last valid one was returned already. */
+	ltq_bool_t bLast;
+	/** CTAG VLAN ID. The valid range is from 0 to 4095.
+	    An error code is delivered in case of range mismatch. */
+	u16 nVId;
+	/** Ethernet Port number (zero-based counting). Every bit represents
+	    an Ethernet port.
+
+	    \remarks
+	    This field is used as portmap field, when the MSB bit is set.
+	    In portmap mode, every value bit represents an Ethernet port.
+	    LSB represents Port 0 with incrementing counting.
+	    The (MSB - 1) bit represent the last port.
+	    The macro \ref GSW_PORTMAP_FLAG_SET allows to set the MSB bit,
+	    marking it as portmap variable.
+	    Checking the portmap flag can be done by
+	    using the \ref GSW_PORTMAP_FLAG_GET macro. */
+	u32 nPortId;
+	/** Enable egress tag-Portmap. Every bit represents an Ethernet port.
+	    This field is used as portmap field, and the MSB bit is
+	    statically always set. LSB represents Port 0 with
+	    incrementing counting.
+	    The (MSB - 1) bit represent the last port.
+	    All port egress traffic from this CTAG VLAN group carries a
+	    tag, in case the port bit is set.
+
+	    \remarks
+	    Checking the portmap flag can be done by
+	    using the \ref GSW_PORTMAP_FLAG_GET macro. */
+	u32 nTagId;
+} GSW_VLAN_portMemberRead_t;
+
+/** \brief Port configuration for VLAN member violation.
+    Used by \ref GSW_VLAN_portCfg_t. */
+typedef enum {
+	/** No VLAN member violation. Ingress and egress packets violating the
+	    membership pass and are not filtered out. */
+	GSW_VLAN_MEMBER_VIOLATION_NO = 0,
+	/** VLAN member violation for ingress packets. Ingress packets violating
+	    the membership are filtered out. Egress packets violating the
+	    membership are not filtered out. */
+	GSW_VLAN_MEMBER_VIOLATION_INGRESS = 1,
+	/** VLAN member violation for egress packets. Egress packets violating
+	    the membership are filtered out. Ingress packets violating the
+	    membership are not filtered out.*/
+	GSW_VLAN_MEMBER_VIOLATION_EGRESS = 2,
+	/** VLAN member violation for ingress and egress packets.
+	    Ingress and egress packets violating the membership are filtered out. */
+	GSW_VLAN_MEMBER_VIOLATION_BOTH = 3
+} GSW_VLAN_MemberViolation_t;
+
+/** \brief CTAG VLAN Port Configuration.
+    Used by \ref GSW_VLAN_PORT_CFG_GET
+    and \ref GSW_VLAN_PORT_CFG_SET. Not applicable to GSWIP-3.1. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u16 nPortId;
+	/** Port CTAG VLAN ID (PVID). The software shall ensure that the used VID has
+	    been configured in advance on the hardware by
+	    using \ref GSW_VLAN_ID_CREATE. */
+	u16 nPortVId;
+	/** Drop ingress CTAG VLAN-tagged packets if the VLAN ID
+	    is not listed in the active VLAN set. If disabled, all incoming
+	    VLAN-tagged packets are forwarded using the FID tag members and
+	    the port members of the PVID.
+	    This parameter is only supported for devices which do not
+	    support 4k VLAN table entries (64 entries instead). */
+	ltq_bool_t bVLAN_UnknownDrop;
+	/** Reassign all ingress CTAG VLAN tagged packets to the port-based
+	    VLAN ID (PVID). */
+	ltq_bool_t bVLAN_ReAssign;
+	/** VLAN ingress and egress membership violation mode. Allows admittance of
+	    VLAN-tagged packets where the port is not a member of the VLAN ID
+	    carried in the received and sent packet. */
+	GSW_VLAN_MemberViolation_t eVLAN_MemberViolation;
+	/** Ingress VLAN-tagged or untagged packet filter configuration. */
+	GSW_VLAN_Admit_t eAdmitMode;
+	/** Transparent CTAG VLAN Mode (TVM). All packets are handled as untagged
+	    packets. Any existing tag is ignored and treated as packet payload. */
+	ltq_bool_t bTVM;
+} GSW_VLAN_portCfg_t;
+
+/** \brief This CTAG VLAN configuration supports replacing of the VID of received packets
+    with the PVID of the receiving port.
+    Used by \ref GSW_VLAN_RESERVED_ADD
+    and \ref GSW_VLAN_RESERVED_REMOVE. Not applicable to GSWIP-3.1. */
+typedef struct {
+	/** VID of the received packet to be replaced by the PVID.
+	    The valid range is from 0 to 4095.
+	    An error code is delivered in case of range mismatch. */
+	u16 nVId;
+} GSW_VLAN_reserved_t;
+
+/** \brief STAG VLAN global configuration.
+    Used by \ref GSW_SVLAN_CFG_GET
+    and \ref GSW_SVLAN_CFG_SET. Not applicable to GSWIP-3.1. */
+typedef struct {
+	/** Protocol EtherType Field. This 16-bit of the STAG VLAN (default=0x88A8). */
+	u16 nEthertype;
+} GSW_SVLAN_cfg_t;
+
+/** \brief STAG VLAN Port Configuration.
+    Used by \ref GSW_SVLAN_PORT_CFG_GET
+    and \ref GSW_SVLAN_PORT_CFG_SET. Not applicable to GSWIP-3.1. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u16 nPortId;
+	/** Port based STAG VLAN Support. All STAG VLAN protocol parsing and
+	    configuration features are only applied on this port in case the
+	    STAG VLAN port support is enabled. */
+	ltq_bool_t bSVLAN_TagSupport;
+	/** Port Egress MAC based STAG VLAN. All egress packets contain a
+	    STAG VLAN ID that is based on the VLAN ID which is retrieved
+	    from the MAC bridging table. This MAC bridging table SVLAN ID
+	    can be learned from the snooped traffic or statically added. */
+	ltq_bool_t bSVLAN_MACbasedTag;
+	/** Port STAG VLAN ID (PVID) */
+	u16 nPortVId;
+	/** Reassign all ingress STAG VLAN tagged packets to the port-based
+	    STAG VLAN ID (PVID). */
+	ltq_bool_t bVLAN_ReAssign;
+	/** VLAN ingress and egress membership violation mode. Allows admittance of
+	    STAG VLAN-tagged packets where the port is not a member of the STAG VLAN ID
+	    carried in the received and sent packet. */
+	GSW_VLAN_MemberViolation_t eVLAN_MemberViolation;
+	/** Ingress STAG VLAN-tagged or untagged packet filter configuration. */
+	GSW_VLAN_Admit_t eAdmitMode;
+} GSW_SVLAN_portCfg_t;
+
+/** \brief Egress VLAN Treatment Selector based upon FID or destination SubIf-Id MSB bits (Bit position 12 to 8) - for GSWIP-3.0 only.
+    Used by \ref GSW_PCE_EgVLAN_Cfg_t. */
+typedef enum {
+	/** FID based Egress VLAN Treatment. */
+	GSW_PCE_EG_VLAN_FID_BASED = 0,
+	/** Sub-InterfaceId Group (Bits 12 to 8) based Egress VLAN Treatment. */
+	GSW_PCE_EG_VLAN_SUBIFID_BASED = 1
+} GSW_PCE_EgVLAN_mode_t;
+
+/** \brief Egress VLAN Treatment Configuration - for GSWIP-3.0 only.
+    Used by \ref GSW_PCE_EG_VLAN_CFG_GET and \ref GSW_PCE_EG_VLAN_CFG_SET. */
+typedef struct {
+	/** Egress Port Identifier */
+	u16  nPortId;
+	/** To enable or disable Egress VLAN treatment on given port */
+	ltq_bool_t bEgVidEna;
+	/** Egress VLAN Treatment Selector - FID or SubIf-Id-MSB (Bits 12 to 8) based */
+	GSW_PCE_EgVLAN_mode_t eEgVLANmode;
+	/** Egress VLAN Treatment start index for specified nPortId. Continuous block of VLAN is used until next port's Start block assignment */
+	u8  nEgStartVLANIdx;
+} GSW_PCE_EgVLAN_Cfg_t;
+
+
+/** \brief Egress VLAN Treatment Entry Configuration - for GSWIP-3.0 only.
+    Used by \ref GSW_PCE_EG_VLAN_ENTRY_READ and \ref GSW_PCE_EG_VLAN_ENTRY_WRITE. */
+typedef struct {
+	/** Egress Port Identifier */
+	u16  nPortId;
+	/** Index corresponding to FID or SubIf-ID Subfield (Bits 12 to 8) */
+	u16  nIndex;
+	/** Egress VLAN Treatment Action Enable */
+	ltq_bool_t	bEgVLAN_Action;
+	/** STAG VLAN Removal action */
+	ltq_bool_t	bEgSVidRem_Action;
+	/** STAG VLAN Insert action */
+	ltq_bool_t	bEgSVidIns_Action;
+	/** SVLAN Value to be inserted in egress */
+	u16 nEgSVid;
+	/** CTAG VLAN Removal action*/
+	ltq_bool_t	bEgCVidRem_Action;
+	/** CTAG VLAN Insert action */
+	ltq_bool_t	bEgCVidIns_Action;
+	/** CVLAN Value to be inserted in egress */
+	u16 nEgCVid;
+} GSW_PCE_EgVLAN_Entry_t;
+
+/*@}*/ /* GSW_IOCTL_VLAN */
+
+/** \addtogroup GSW_IOCTL_QOS */
+/*@{*/
+
+/** \brief Define setting the priority queue to an undefined value.
+    This disables the priority feature. */
+#define GSW_TRAFFIC_CLASS_DISABLE 0xFF
+
+/** \brief DSCP mapping table.
+    Used by \ref GSW_QOS_DSCP_CLASS_SET
+    and \ref GSW_QOS_DSCP_CLASS_GET. */
+typedef struct {
+	/** Traffic class associated with a particular DSCP value.
+	    DSCP is the index to an array of resulting traffic class values.
+	    The index starts counting from zero. */
+	u8	nTrafficClass[64];
+} GSW_QoS_DSCP_ClassCfg_t;
+
+/** \brief Traffic class associated with a particular 802.1P (PCP) priority mapping value.
+    This table is global for the entire switch device. Priority map entry structure.
+    Used by \ref GSW_QOS_PCP_CLASS_SET
+    and \ref GSW_QOS_PCP_CLASS_GET. */
+typedef struct {
+	/** Configures the PCP to traffic class mapping.
+	    The queue index starts counting from zero. */
+	u8	nTrafficClass[8];
+} GSW_QoS_PCP_ClassCfg_t;
+
+/** \brief Ingress DSCP remarking attribute. This attribute defines on the
+    ingress port packets how these will be remarked on the egress port.
+    A packet is only remarked in case its ingress and its egress port
+    have remarking enabled.
+    Used by \ref GSW_QoS_portRemarkingCfg_t. */
+typedef enum {
+	/** No DSCP Remarking. No remarking is done on the egress port. */
+	GSW_DSCP_REMARK_DISABLE = 0,
+	/** TC DSCP 6-Bit Remarking. The complete DSCP remarking is done based
+	    on the traffic class. The traffic class to DSCP value mapping is
+	    given in a device global table. */
+	GSW_DSCP_REMARK_TC6 = 1,
+	/** TC DSCP 3-Bit Remarking. The upper 3-Bits of the DSCP field are
+	    remarked based on the traffic class. The traffic class to DSCP value
+	    mapping is given in a device global table. */
+	GSW_DSCP_REMARK_TC3 = 2,
+	/** Drop Precedence Remarking. The Drop Precedence is remarked on the
+	    egress side. */
+	GSW_DSCP_REMARK_DP3 = 3,
+	/** TC Drop Precedence Remarking. The Drop Precedence is remarked on the
+	    egress side and the upper 3-Bits of the DSCP field are
+	    remarked based on the traffic class. The traffic class to DSCP value
+	    mapping is given in a device global table. */
+	GSW_DSCP_REMARK_DP3_TC3 = 4
+} GSW_Qos_ingressRemarking_t;
+
+/** \brief Port Remarking Configuration. Ingress and Egress remarking options for
+    dedicated packet fields DSCP, CTAG VLAN PCP, STAG VLAN PCP
+    and STAG VLAN DEI.
+    Remarking is done either on the used traffic class or the
+    drop precedence.
+    Packet field specific remarking only applies on a packet if
+    enabled on ingress and egress port.
+    Used by \ref GSW_QOS_PORT_REMARKING_CFG_SET
+    and \ref GSW_QOS_PORT_REMARKING_CFG_GET. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u16 nPortId;
+	/** Ingress DSCP Remarking. Specifies on ingress side how a packet should
+	    be remarked. This DSCP remarking only works in case remarking is
+	    enabled on the egress port.
+	    This configuration requires that remarking is also enabled on the
+	    egress port. DSCP remarking enable on either ingress or egress port
+	    side does not perform any remark operation. */
+	GSW_Qos_ingressRemarking_t	eDSCP_IngressRemarkingEnable;
+	/** Egress DSCP Remarking. Applies remarking on egress packets in a
+	    fashion as specified on the ingress port. This ingress port remarking
+	    is configured by the parameter 'eDSCP_IngressRemarking'.
+	    This configuration requires that remarking is also enabled on the
+	    ingress port. DSCP remarking enable on either ingress or egress port
+	    side does not perform any remark operation. */
+	ltq_bool_t bDSCP_EgressRemarkingEnable;
+	/** Ingress PCP Remarking. Applies remarking to all port ingress packets.
+	    This configuration requires that remarking is also enabled on the
+	    egress port. PCP remarking enable on either ingress or egress port
+	    side does not perform any remark operation. */
+	ltq_bool_t bPCP_IngressRemarkingEnable;
+	/** Egress PCP Remarking. Applies remarking for all port egress packets.
+	    This configuration requires that remarking is also enabled on the
+	    ingress port. PCP remarking enable on either ingress or egress port
+	    side does not perform any remark operation. */
+	ltq_bool_t bPCP_EgressRemarkingEnable;
+	/** Ingress STAG VLAN PCP Remarking */
+	ltq_bool_t bSTAG_PCP_IngressRemarkingEnable;
+	/** Ingress STAG VLAN DEI Remarking */
+	ltq_bool_t bSTAG_DEI_IngressRemarkingEnable;
+	/** Egress STAG VLAN PCP & DEI Remarking */
+	ltq_bool_t bSTAG_PCP_DEI_EgressRemarkingEnable;
+} GSW_QoS_portRemarkingCfg_t;
+
+/** \brief Traffic class to DSCP mapping table.
+    Used by \ref GSW_QOS_CLASS_DSCP_SET
+    and \ref GSW_QOS_CLASS_DSCP_GET. */
+typedef struct {
+	/** DSCP value (6-bit) associated with a particular Traffic class.
+	    Traffic class is the index to an array of resulting DSCP values.
+	    The index starts counting from zero. */
+	u8 nDSCP[16];
+} GSW_QoS_ClassDSCP_Cfg_t;
+
+/** \brief Traffic class associated with a particular 802.1P (PCP) priority mapping value.
+    This table is global for the entire switch device. Priority map entry structure.
+    Used by \ref GSW_QOS_CLASS_PCP_SET
+    and \ref GSW_QOS_CLASS_PCP_GET. */
+typedef struct {
+	/** Configures the traffic class to PCP (3-bit) mapping.
+	    The queue index starts counting from zero. */
+	u8 nPCP[16];
+} GSW_QoS_ClassPCP_Cfg_t;
+
+/** \brief DSCP Drop Precedence to color code assignment.
+    Used by \ref GSW_QoS_DSCP_DropPrecedenceCfg_t. */
+typedef enum {
+	/** Critical Packet. Metering never changes the drop precedence of these packets. */
+	GSW_DROP_PRECEDENCE_CRITICAL           = 0,
+	/** Green Drop Precedence Packet. Packet is marked with a 'low' drop precedence. */
+	GSW_DROP_PRECEDENCE_GREEN = 1,
+	/** Yellow Drop Precedence Packet. Packet is marked with a 'middle' drop precedence. */
+	GSW_DROP_PRECEDENCE_YELLOW	= 2,
+	/** Red Drop Precedence Packet. Packet is marked with a 'high' drop precedence. */
+	GSW_DROP_PRECEDENCE_RED = 3
+} GSW_QoS_DropPrecedence_t;
+
+/** \brief DSCP to Drop Precedence assignment table configuration.
+    Used by \ref GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_SET
+    and \ref GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_GET. */
+typedef struct {
+	/** DSCP to drop precedence assignment. Every array entry represents the
+	    drop precedence for one of the 64 existing DSCP values.
+	    DSCP is the index to an array of resulting drop precedence values.
+	    The index starts counting from zero. */
+	GSW_QoS_DropPrecedence_t nDSCP_DropPrecedence[64];
+} GSW_QoS_DSCP_DropPrecedenceCfg_t;
+
+/** \brief Selection of the traffic class field.
+    Used by \ref GSW_QoS_portCfg_t.
+    The port default traffic class is assigned in case non of the
+    configured protocol code points given by the packet. */
+typedef enum {
+	/** No traffic class assignment based on DSCP or PCP */
+	GSW_QOS_CLASS_SELECT_NO = 0,
+	/** Traffic class assignment based on DSCP. PCP information is ignored.
+	    The Port Class is used in case DSCP is not available in the packet. */
+	GSW_QOS_CLASS_SELECT_DSCP = 1,
+	/** Traffic class assignment based on PCP. DSCP information is ignored.
+	    The Port Class is used in case PCP is not available in the packet. */
+	GSW_QOS_CLASS_SELECT_PCP	= 2,
+	/** Traffic class assignment based on DSCP. Make the assignment based on
+	    PCP in case the DSCP information is not available in the packet header.
+	    The Port Class is used in case both are not available in the packet. */
+	GSW_QOS_CLASS_SELECT_DSCP_PCP          = 3,
+	/** CTAG VLAN PCP, IP DSCP. Traffic class assignment based
+	    on CTAG VLAN PCP, alternative use DSCP based assignment. */
+	GSW_QOS_CLASS_SELECT_PCP_DSCP          = 4,
+	/** STAG VLAN PCP. Traffic class assignment based
+	    on STAG VLAN PCP. */
+	GSW_QOS_CLASS_SELECT_SPCP	= 5,
+	/** STAG VLAN PCP, IP DSCP. Traffic class assignment based
+	    on STAG VLAN PCP, alternative use DSCP based assignment. */
+	GSW_QOS_CLASS_SELECT_SPCP_DSCP         = 6,
+	/** IP DSCP, STAG VLAN PCP. Traffic class assignment based
+	    on DSCP, alternative use STAG VLAN PCP based assignment. */
+	GSW_QOS_CLASS_SELECT_DSCP_SPCP         = 7,
+	/** STAG VLAN PCP, CTAG VLAN PCP. Traffic class assignment based
+	    on STAG VLAN PCP, alternative use CTAG VLAN PCP based assignment. */
+	GSW_QOS_CLASS_SELECT_SPCP_PCP          = 8,
+	/** STAG VLAN PCP, CTAG VLAN PCP, IP DSCP. Traffic class assignment
+	    based on STAG VLAN PCP, alternative use CTAG VLAN PCP based
+	    assignment, alternative use DSCP based assignment. */
+	GSW_QOS_CLASS_SELECT_SPCP_PCP_DSCP     = 9,
+	/** IP DSCP, STAG VLAN PCP, CTAG VLAN PCP. Traffic class assignment
+	    based on DSCP, alternative use STAG VLAN PCP based
+	    assignment, alternative use CTAG VLAN PCP based assignment. */
+	GSW_QOS_CLASS_SELECT_DSCP_SPCP_PCP     = 10
+} GSW_QoS_ClassSelect_t;
+
+/** \brief Describes which priority information of ingress packets is used
+    (taken into account) to identify the packet priority and the related egress
+    priority queue. For DSCP, the priority to queue assignment is done
+    using \ref GSW_QOS_DSCP_CLASS_SET. For VLAN, the priority to queue
+    assignment is done using \ref GSW_QOS_PCP_CLASS_SET.
+    Used by \ref GSW_QOS_PORT_CFG_SET and \ref GSW_QOS_PORT_CFG_GET. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u16	nPortId;
+	/** Select the packet header field on which to base the traffic class assignment. */
+	GSW_QoS_ClassSelect_t	eClassMode;
+	/** Default port priority in case no other priority
+	    (such as VLAN-based PCP or IP-based DSCP) is used. */
+	u8	nTrafficClass;
+} GSW_QoS_portCfg_t;
+
+/** \brief Configures a rate shaper instance with the rate and the burst size.
+    Used by \ref GSW_QOS_SHAPER_CFG_SET and \ref GSW_QOS_SHAPER_CFG_GET. */
+typedef struct {
+	/** Rate shaper index (zero-based counting). */
+	u32	nRateShaperId;
+	/** Enable/Disable the rate shaper. */
+	ltq_bool_t	bEnable;
+	/** 802.1Qav credit based shaper mode. This specific shaper
+	    algorithm mode is used by the audio/video bridging (AVB)
+	    network (according to 802.1Qav). By default, an token
+	    based shaper algorithm is used. */
+	ltq_bool_t	bAVB;
+	/** Committed Burst Size (CBS [bytes]) */
+	u32	nCbs;
+	/** Rate [kbit/s] */
+	u32	nRate;
+} GSW_QoS_ShaperCfg_t;
+
+/** \brief Assign one rate shaper instance to a QoS queue.
+    Used by \ref GSW_QOS_SHAPER_QUEUE_ASSIGN and \ref GSW_QOS_SHAPER_QUEUE_DEASSIGN. */
+typedef struct {
+	/** Rate shaper index (zero-based counting). */
+	u8	nRateShaperId;
+	/** QoS queue index (zero-based counting). */
+	u8	nQueueId;
+} GSW_QoS_ShaperQueue_t;
+
+/** \brief Retrieve if a rate shaper instance is assigned to a QoS egress queue.
+    Used by \ref GSW_QOS_SHAPER_QUEUE_GET. */
+typedef struct {
+	/** QoS queue index (zero-based counting).
+	    This parameter is the input parameter for the GET function. */
+	u8	nQueueId;
+	/** Rate shaper instance assigned.
+	    If 1, a rate shaper instance is assigned to the queue. Otherwise no shaper instance is assigned. */
+	ltq_bool_t	bAssigned;
+	/** Rate shaper index (zero-based counting). Only a valid instance is returned in case 'bAssigned == 1'. */
+	u8	nRateShaperId;
+} GSW_QoS_ShaperQueueGet_t;
+
+/** \brief WRED Cfg Type - Automatic (Adaptive) or Manual.
+    Used by \ref GSW_QoS_WRED_Cfg_t. */
+typedef enum {
+	/** Automatic - Adaptive Watermark Type - GSWIP-3.0/3.1 only*/
+	GSW_QOS_WRED_Adaptive	= 0,
+	/** Manual Threshold Levels Type */
+	GSW_QOS_WRED_Manual	= 1
+} GSW_QoS_WRED_Mode_t;
+
+/** \brief WRED Thresholds Mode Type. - GSWIP-3.0/3.1 only
+    Used by \ref GSW_QoS_WRED_Cfg_t. */
+typedef enum {
+	/** Local Thresholds Mode */
+	GSW_QOS_WRED_Local_Thresh	= 0,
+	/** Global Thresholds Mode */
+	GSW_QOS_WRED_Global_Thresh	= 1,
+	/** Port queue and Port WRED Thresholds */
+	GSW_QOS_WRED_Port_Thresh	= 2,
+
+} GSW_QoS_WRED_ThreshMode_t;
+
+/** \brief Drop Probability Profile. Defines the drop probability profile.
+    Used by \ref GSW_QoS_WRED_Cfg_t. */
+typedef enum {
+	/** Pmin = 25%, Pmax = 75% (default) */
+	GSW_QOS_WRED_PROFILE_P0	= 0,
+	/** Pmin = 25%, Pmax = 50% */
+	GSW_QOS_WRED_PROFILE_P1	= 1,
+	/** Pmin = 50%, Pmax = 50% */
+	GSW_QOS_WRED_PROFILE_P2	= 2,
+	/** Pmin = 50%, Pmax = 75% */
+	GSW_QOS_WRED_PROFILE_P3	= 3
+} GSW_QoS_WRED_Profile_t;
+
+/** \brief Egress Queue Congestion Notification Watermark.
+    Used by \ref GSW_QoS_WRED_Cfg_t. */
+typedef enum {
+	/**
+	>= 1/4 of green max water mark assert
+	<= 1/4 of green max water mark de assert*/
+	GSW_QOS_WRED_WATERMARK_1_4	= 0,
+	/**
+	>= 1/8 of green max water mark assert
+	<= 1/8 of green max water mark de assert*/
+	GSW_QOS_WRED_WATERMARK_1_8	= 1,
+	/**
+	>= 1/12 of green max water mark assert
+	<= 1/12 of green max water mark de assert*/
+	GSW_QOS_WRED_WATERMARK_1_12	= 2,
+	/**
+	>= 1/16 of green max water mark assert
+	<= 1/16 of green max water mark de assert*/
+	GSW_QOS_WRED_WATERMARK_1_16	= 3
+} GSW_QoS_WRED_WATERMARK_t;
+
+/** \brief Configures the global probability profile of the device.
+    The min. and max. threshold values are given in number of packet
+    buffer segments and required only in case of Manual Mode. The GSWIP-3.0/3.1 supports Auto mode and the threshold values are dynamically computed internally by GSWIP. The size of a segment can be retrieved using \ref GSW_CAP_GET.
+    Used by \ref GSW_QOS_WRED_CFG_SET and \ref GSW_QOS_WRED_CFG_GET. */
+typedef struct {
+	/** Egress Queue Congestion Notification Watermark
+	   only applicable for GSWIP 3.1*/
+	GSW_QoS_WRED_WATERMARK_t eCongestionWatermark;
+	/** Drop Probability Profile. */
+	GSW_QoS_WRED_Profile_t	eProfile;
+	/** Automatic or Manual Mode of Thresholds Config */
+	GSW_QoS_WRED_Mode_t eMode;
+	/** WRED Threshold Mode Config */
+	GSW_QoS_WRED_ThreshMode_t eThreshMode;
+	/** WRED Red Threshold Min [number of segments] - Valid for Manual Mode only. */
+	u32	nRed_Min;
+	/** WRED Red Threshold Max [number of segments] - Valid for Manual Mode only */
+	u32	nRed_Max;
+	/** WRED Yellow Threshold Min [number of segments] - Valid for Manual Mode only */
+	u32	nYellow_Min;
+	/** WRED Yellow Threshold Max [number of segments] - Valid for Manual Mode only */
+	u32	nYellow_Max;
+	/** WRED Green Threshold Min [number of segments] - Valid for Manual Mode only */
+	u32	nGreen_Min;
+	/** WRED Green Threshold Max [number of segments] - Valid for Manual Mode only */
+	u32	nGreen_Max;
+} GSW_QoS_WRED_Cfg_t;
+
+/** \brief Configures the WRED threshold level values.
+    The min. and max. values are given in number of packet
+    buffer segments. The size of a segment can be
+    retrieved using \ref GSW_CAP_GET.
+    Used by \ref GSW_QOS_WRED_QUEUE_CFG_SET and \ref GSW_QOS_WRED_QUEUE_CFG_GET. */
+typedef struct {
+	/** QoS queue index (zero-based counting). */
+	u32	nQueueId;
+	/** WRED Red Threshold Min [number of segments]. */
+	u32	nRed_Min;
+	/** WRED Red Threshold Max [number of segments]. */
+	u32	nRed_Max;
+	/** WRED Yellow Threshold Min [number of segments]. */
+	u32	nYellow_Min;
+	/** WRED Yellow Threshold Max [number of segments]. */
+	u32	nYellow_Max;
+	/** WRED Green Threshold Min [number of segments]. */
+	u32	nGreen_Min;
+	/** WRED Green Threshold Max [number of segments]. */
+	u32	nGreen_Max;
+} GSW_QoS_WRED_QueueCfg_t;
+
+/** \brief Configures the WRED threshold parameter per port.
+    The configured thresholds apply to fill level sum
+    of all egress queues which are assigned to the egress port.
+    The min. and max. values are given in number of packet
+    buffer segments. The size of a segment can be
+    retrieved using \ref GSW_CAP_GET.
+    Used by \ref GSW_QOS_WRED_PORT_CFG_SET and \ref GSW_QOS_WRED_PORT_CFG_GET. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting).
+	    The valid range is hardware dependent. */
+	u32	nPortId;
+	/** WRED Red Threshold Min [number of segments]. */
+	u32	nRed_Min;
+	/** WRED Red Threshold Max [number of segments]. */
+	u32	nRed_Max;
+	/** WRED Yellow Threshold Min [number of segments]. */
+	u32	nYellow_Min;
+	/** WRED Yellow Threshold Max [number of segments]. */
+	u32	nYellow_Max;
+	/** WRED Green Threshold Min [number of segments]. */
+	u32	nGreen_Min;
+	/** WRED Green Threshold Max [number of segments]. */
+	u32	nGreen_Max;
+} GSW_QoS_WRED_PortCfg_t;
+
+/** \brief Configures the global buffer flow control threshold for
+    conforming and non-conforming packets.
+    The min. and max. values are given in number of packet
+    buffer segments. The size of a segment can be
+    retrieved using \ref GSW_CAP_GET.
+    Used by \ref GSW_QOS_FLOWCTRL_CFG_SET and \ref GSW_QOS_FLOWCTRL_CFG_GET. */
+typedef struct {
+	/** Global Buffer Non Conforming Flow Control Threshold Minimum [number of segments]. */
+	u32	nFlowCtrlNonConform_Min;
+	/** Global Buffer Non Conforming Flow Control Threshold Maximum [number of segments]. */
+	u32	nFlowCtrlNonConform_Max;
+	/** Global Buffer Conforming Flow Control Threshold Minimum [number of segments]. */
+	u32	nFlowCtrlConform_Min;
+	/** Global Buffer Conforming Flow Control Threshold Maximum [number of segments]. */
+	u32	nFlowCtrlConform_Max;
+} GSW_QoS_FlowCtrlCfg_t;
+
+/** \brief Configures the ingress port flow control threshold for
+    used packet segments.
+    The min. and max. values are given in number of packet
+    buffer segments. The size of a segment can be
+    retrieved using \ref GSW_CAP_GET.
+    Used by \ref GSW_QOS_FLOWCTRL_PORT_CFG_SET and \ref GSW_QOS_FLOWCTRL_PORT_CFG_GET. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting).
+	    The valid range is hardware dependent. */
+	u32	nPortId;
+	/** Ingress Port occupied Buffer Flow Control Threshold Minimum [number of segments]. */
+	u32	nFlowCtrl_Min;
+	/** Ingress Port occupied Buffer Flow Control Threshold Maximum [number of segments]. */
+	u32	nFlowCtrl_Max;
+} GSW_QoS_FlowCtrlPortCfg_t;
+
+/** \brief Meter Type - srTCM or trTCM. Defines the Metering algorithm Type.
+    Used by \ref GSW_QoS_meterCfg_t. */
+typedef enum {
+	/** srTCM Meter Type */
+	GSW_QOS_Meter_srTCM	= 0,
+	/** trTCM Meter Type - GSWIP-3.0 only */
+	GSW_QOS_Meter_trTCM	= 1,
+} GSW_QoS_Meter_Type;
+
+/** \brief Configures the parameters of a rate meter instance.
+    Used by \ref GSW_QOS_METER_ALLOC, \ref GSW_QOS_METER_FREE,
+    \ref GSW_QOS_METER_CFG_SET and \ref GSW_QOS_METER_CFG_GET. */
+typedef struct {
+	/** Enable/Disable the meter shaper. */
+	ltq_bool_t	bEnable;
+	/** Meter index (zero-based counting).
+
+	    \remarks
+	    For \ref GSW_QOS_METER_FREE, this is the only input and other fields are
+	    ignored. For \ref GSW_QOS_METER_ALLOC, this is output when allocation
+	    is successful. For \ref GSW_QOS_METER_CFG_SET and
+	    \ref GSW_QOS_METER_CFG_GET, this is input to indicate meter to
+	    configure/get-configuration. */
+	u32	nMeterId;
+	/** Meter Name string for easy reference (Id to Name Mapping) - TBD*/
+	char	cMeterName[32];
+	/** Meter Algorithm Type */
+	GSW_QoS_Meter_Type eMtrType;
+	/** Committed Burst Size (CBS [Bytes]). */
+	u32	nCbs;
+	/** Excess Burst Size (EBS [Bytes]). */
+	u32	nEbs;
+	/** Committed Information Rate (CIR [kbit/s])*/
+	u32	nRate;
+	/** Peak Information Rate (PIR [kbit/s]) - applicable for trTCM only */
+	u32	nPiRate;
+	/** Peak Burst Size (PBS [Bytes]) - applicable for trTCM only */
+//   u32	nPbs;
+	/** Meter colour mode **/
+	u32 nColourBlindMode;
+} GSW_QoS_meterCfg_t;
+
+/** \brief Specifies the direction for ingress and egress.
+    Used by \ref GSW_QoS_meterPort_t and \ref GSW_QoS_meterPortGet_t. */
+typedef enum {
+	/** No direction. */
+	GSW_DIRECTION_NONE	= 0,
+	/** Ingress direction. */
+	GSW_DIRECTION_INGRESS	= 1,
+	/** Egress direction. */
+	GSW_DIRECTION_EGRESS	= 2,
+	/** Ingress and egress direction. */
+	GSW_DIRECTION_BOTH	= 3
+} GSW_direction_t;
+
+/** \brief Assign a rate meter instance to an ingress and/or egress port.
+    Used by \ref GSW_QOS_METER_PORT_ASSIGN and \ref GSW_QOS_METER_PORT_DEASSIGN.
+    Not applicable to GSWIP-3.1. */
+typedef struct {
+	/** Meter index (zero-based counting). */
+	u32	nMeterId;
+	/** Port assignment. Could be either ingress, egress or both. Setting it to
+	    'GSW_DIRECTION_NONE' would remove the queue for any port
+	    assignment. */
+	GSW_direction_t eDir;
+	/** Ingress Port Id. */
+	u32	nPortIngressId;
+	/** Egress Port Id. */
+	u32	nPortEgressId;
+} GSW_QoS_meterPort_t;
+
+/** \brief Reads out all meter instance to port assignments.
+    Used by \ref GSW_QOS_METER_PORT_GET. Not applicable to GSWIP-3.1. */
+typedef struct {
+	/** Restart the get operation from the start of the table. Otherwise
+	    return the next table entry (next to the entry that was returned
+	    during the previous get operation). This boolean parameter is set by the
+	    calling application. */
+	ltq_bool_t	bInitial;
+	/** Indicates that the read operation got all last valid entries of the
+	    table. This boolean parameter is set by the switch API
+	    when the Switch API is called after the last valid one was returned already. */
+	ltq_bool_t	bLast;
+	/** Port assignment. Could be either ingress, egress or both. Setting it to
+	    'GSW_DIRECTION_NONE' would remove the queue for any port
+	    assignment. */
+	GSW_direction_t	eDir;
+	/** Meter index (zero-based counting). */
+	u8	nMeterId;
+	/** Ingress Port Id. */
+	u8	nPortIngressId;
+	/** Egress Port Id. */
+	u8	nPortEgressId;
+} GSW_QoS_meterPortGet_t;
+
+/** \brief Assigns one meter instances for storm control.
+    Used by \ref GSW_QOS_STORM_CFG_SET and \ref GSW_QOS_STORM_CFG_GET.
+    Not applicable to GSWIP-3.1. */
+typedef struct {
+	/** Meter index 0 (zero-based counting). */
+	int	nMeterId;
+	/** Meter instances used for broadcast traffic. */
+	ltq_bool_t	bBroadcast;
+	/** Meter instances used for multicast traffic. */
+	ltq_bool_t	bMulticast;
+	/** Meter instances used for unknown unicast traffic. */
+	ltq_bool_t	bUnknownUnicast;
+} GSW_QoS_stormCfg_t;
+
+/** \brief Triggers Metering Action for Traffic by CPU/MPE (available for GSWIP-3.0 only).
+    Used by \ref GSW_QOS_METER_ACT */
+typedef struct {
+	/** CPU User Id  - GSWIP-3.0 supports up to 2 users - CPU-0 & CPU-1 */
+	u8	nCpuUserId;
+	/** Primary Meter Instance Id (zero-based counting). */
+	u8	nMeterId;
+	/** Primary Meter Enable or Disable Action */
+	ltq_bool_t	bMeterEna;
+	/** Secondary Meter Instance Id (zero-based counting). (-1) to indicate this is not used */
+	u8	nSecMeterId;
+	/** Secondary Meter Enable or Disable Action */
+	ltq_bool_t	bSecMeterEna;
+	/** Pre-Color to indicate the traffic type getting Metered. */
+	GSW_QoS_DropPrecedence_t ePreColor;
+	/** Packet Length in Bytes subject to Metering action from CPU */
+	u16	pktLen;
+	/** Metering Colour Output after it was subject to Metering Algorithm.
+	    This is an output parameter carrying combined Meter action of two Meter instances */
+	GSW_QoS_DropPrecedence_t eOutColor;
+} GSW_QoS_mtrAction_t;
+
+/** \brief Select the type of the Egress Queue Scheduler.
+    Used by \ref GSW_QoS_schedulerCfg_t. */
+typedef enum {
+	/** Strict Priority Scheduler. */
+	GSW_QOS_SCHEDULER_STRICT	= 0,
+	/** Weighted Fair Queuing Shceduler. */
+	GSW_QOS_SCHEDULER_WFQ	= 1
+} GSW_QoS_Scheduler_t;
+
+/** \brief Configures the egress queues attached to a single port, and that
+    are scheduled to transmit the queued Ethernet packets.
+    Used by \ref GSW_QOS_SCHEDULER_CFG_SET and \ref GSW_QOS_SCHEDULER_CFG_GET. */
+typedef struct {
+	/** QoS queue index (zero-based counting). */
+	u8	nQueueId;
+	/** Scheduler Type (Strict Priority/Weighted Fair Queuing). */
+	GSW_QoS_Scheduler_t	eType;
+	/** Weight in Token. Parameter used for WFQ configuration.
+	    Sets the weight in token in relation to all remaining
+	    queues on this egress port having WFQ configuration.
+	    This parameter is only used when 'eType=GSW_QOS_SCHEDULER_WFQ'. */
+	u32	nWeight;
+} GSW_QoS_schedulerCfg_t;
+
+/** \brief Describes the QoS Queue Mapping Mode. GSWIP-3.1 only.
+    Used by \ref GSW_QoS_queuePort_t. */
+typedef enum {
+	/** This is default mode where the QID is fixed at
+	    \ref GSW_QOS_QUEUE_PORT_SET. */
+	GSW_QOS_QMAP_SINGLE_MODE = 0,
+	/** This is new mode in GSWIP-3.1. The QID given in
+	    \ref GSW_QOS_QUEUE_PORT_SET is base, and bit 0~3 of sub-interface ID
+	    is offset. The final QID is base + SubIfId[0:3]. */
+	GSW_QOS_QMAP_SUBIFID_MODE = 1
+} GSW_QoS_qMapMode_t;
+
+/** \brief Sets the Queue ID for one traffic class of one port.
+    Used by \ref GSW_QOS_QUEUE_PORT_SET and \ref GSW_QOS_QUEUE_PORT_GET. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available.
+	    This is an input parameter for \ref GSW_QOS_QUEUE_PORT_GET. */
+	u16	nPortId;
+	/** Forward CPU (extraction) before external QoS queueing (DownMEP).
+	    GSWIP-3.1 only. */
+	ltq_bool_t bExtrationEnable;
+	/** When \ref GSW_QoS_queuePort_t::bExtrationEnable is FALSE, this field
+	    defines Queue Mapping Mode. GSWIP-3.1 only. */
+	GSW_QoS_qMapMode_t eQMapMode;
+	/** Traffic Class index (zero-based counting).
+	    This is an input parameter for \ref GSW_QOS_QUEUE_PORT_GET. */
+	u8	nTrafficClassId;
+	/** QoS queue index (zero-based counting).
+	    This is an output parameter for \ref GSW_QOS_QUEUE_PORT_GET. */
+	u8	nQueueId;
+	/** Queue Redirection bypass Option.
+	    If enabled, all packets destined to 'nQueueId' are redirected from the
+	    'nPortId' to 'nRedirectPortId'. This is used for 2nd stage of FULL QoS
+	    Path, where the packet has completed QoS process at CBM/CQEM and been
+	    injected into GSWIP again. */
+	ltq_bool_t	bRedirectionBypass;
+	/** Redirected traffic forward port.
+	    All egress packets to 'nPortId' are redirected to "nRedirectPortId".
+	    If there is no redirection required, it should be same as "nPortId".
+	    GSWIP-3.0/3.1 only. */
+	u8	nRedirectPortId;
+} GSW_QoS_queuePort_t;
+
+/** \brief Reserved egress queue buffer segments.
+    Used by \ref GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_SET and \ref GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_GET. */
+typedef struct {
+	/** QoS queue index (zero-based counting).
+	    This is an input parameter for \ref GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_GET. */
+	u8	nQueueId;
+	/** Reserved Buffer Segment Threshold [number of segments].
+	    This is an output parameter for \ref GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_GET. */
+	u32	nBufferReserved;
+} GSW_QoS_QueueBufferReserveCfg_t;
+
+/** \brief Traffic class associated with a particular 802.1P (PCP) priority mapping value.
+    One table is given per egress port. Priority map entry structure.
+    The lowest 3 LSB bits (0 ... 2) of 'nPCP_DEI' describe the PCP field.
+    Bit 3 describes the 'DEI' field.
+    Used by \ref GSW_QOS_SVLAN_CLASS_PCP_PORT_SET and \ref GSW_QOS_SVLAN_CLASS_PCP_PORT_GET.
+    Not applicable to GSWIP-3.1. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u16	nPortId;
+	/** Configures the traffic class to PCP (3-bit) mapping.
+	    The queue index starts counting from zero. */
+//   u8	nPCP_DEI[16];
+
+	/** Configures the traffic class to CPCP (3-bit) mapping.
+	    The queue index starts counting from zero. */
+	u8	nCPCP[16];
+
+	/** Configures the traffic class to SPCP (3-bit) mapping.
+	    The queue index starts counting from zero. */
+	u8	nSPCP[16];
+
+	/** DSCP value (6-bit) associated with a particular Traffic class.
+	    Traffic class is the index to an array of resulting DSCP values.
+	    The index starts counting from zero. */
+	u8	nDSCP[16];
+
+} GSW_QoS_SVLAN_ClassPCP_PortCfg_t;
+
+/** \brief Traffic class associated with a particular STAG VLAN 802.1P (PCP) priority and Drop Eligible Indicator (DEI) mapping value.
+    This table is global for the entire switch device. Priority map entry structure.
+    The table index value is calculated by 'index=PCP + 8*DEI'
+    Used by \ref GSW_QOS_SVLAN_PCP_CLASS_SET and \ref GSW_QOS_SVLAN_PCP_CLASS_GET. */
+typedef struct {
+	/** Configures the PCP and DEI to traffic class mapping.
+	    The queue index starts counting from zero. */
+	u8	nTrafficClass[16];
+	/**  Configures the PCP traffic color.
+	     Not applicable to GSWIP-3.1. */
+	u8	nTrafficColor[16];
+	/** PCP Remark disable control.
+	     Not applicable to GSWIP-3.1. */
+	u8	nPCP_Remark_Enable[16];
+	/** DEI Remark disable control.
+	    Not applicable to GSWIP-3.1. */
+	u8	nDEI_Remark_Enable[16];
+
+} GSW_QoS_SVLAN_PCP_ClassCfg_t;
+
+/*@}*/ /* GSW_IOCTL_QOS */
+
+/** \addtogroup GSW_IOCTL_MULTICAST */
+/*@{*/
+
+
+/** \brief Configure the IGMP snooping mode.
+    Used by \ref GSW_multicastSnoopCfg_t. */
+typedef enum {
+	/** IGMP management packet snooping and multicast level 3 table learning
+	    is disabled. */
+	GSW_MULTICAST_SNOOP_MODE_DISABLED = 0,
+	/** IGMP management packet snooping is enabled and used for the hardware
+	    auto-learning to fill the multicast level 3 table. */
+	GSW_MULTICAST_SNOOP_MODE_AUTOLEARNING	= 1,
+	/** IGMP management packet snooping is enabled and forwarded to the
+	    configured port. No autolearning of the multicast level 3 table. This
+	    table has to be maintained by the management software. */
+	GSW_MULTICAST_SNOOP_MODE_FORWARD = 2
+} GSW_multicastSnoopMode_t;
+
+/** \brief Configure the IGMP report suppression mode.
+    Used by \ref GSW_multicastSnoopCfg_t. */
+typedef enum {
+	/** Report Suppression and Join Aggregation. */
+	GSW_MULTICAST_REPORT_JOIN	= 0,
+	/** Report Suppression. No Join Aggregation. */
+	GSW_MULTICAST_REPORT	= 1,
+	/** Transparent Mode. No Report Suppression and no Join Aggregation. */
+	GSW_MULTICAST_TRANSPARENT	= 2
+} GSW_multicastReportSuppression_t;
+
+/** \brief Configure the switch multicast configuration.
+    Used by \ref GSW_MULTICAST_SNOOP_CFG_SET and \ref GSW_MULTICAST_SNOOP_CFG_GET. */
+typedef struct {
+	/** Enables and configures the IGMP/MLD snooping feature.
+	Select autolearning or management packet forwarding mode.
+	Packet forwarding is done to the port selected in 'eForwardPort'. */
+	GSW_multicastSnoopMode_t	eIGMP_Mode;
+	/** IGMPv3 hardware support.
+	When enabled the IGMP table includes both the group table and
+	the source list table. Otherwise the table only includes the
+	group table. This feature is needed when supporting IGMPv3 and
+	MLDv2 protocols. */
+	ltq_bool_t	bIGMPv3;
+	/** Enables snooped IGMP control packets treated as cross-CTAG VLAN packets. This
+	parameter is used for hardware auto-learning and snooping packets
+	forwarded to a dedicated port. This dedicated port can be selected
+	over 'eForwardPort'. */
+	ltq_bool_t	bCrossVLAN;
+	/** Forward snooped packet, only used if forwarded mode
+	is selected
+	by 'eIGMP_Mode = GSW_MULTICAST_SNOOP_MODE_SNOOPFORWARD'. */
+	GSW_portForward_t	eForwardPort;
+	/** Target port for forwarded packets, only used if selected by
+	'eForwardPort'. Forwarding is done
+	if 'eForwardPort = GSW_PORT_FORWARD_PORT'.
+	This is Bridge Port ID in GSWIP-3.1. */
+	u8	nForwardPortId;
+	/** Snooping control class of service.
+	Snooping control packet can be forwarded to the 'nForwardPortId' when
+	selected in 'eIGMP_Mode'. The class of service of this port can be
+	selected for the snooped control packets, starting from zero.
+	The maximum possible service class depends
+	on the hardware platform used. The value
+	GSW_TRAFFIC_CLASS_DISABLE disables overwriting the given
+	class assignment. */
+	u8	nClassOfService;
+	/** Robustness variable.
+	Used when the hardware-based IGMP/MLD snooping function is enabled. This
+	robust variable is used in case IGMP hardware learning is
+	enabled ('eIGMP_Mode = GSW_MULTICAST_SNOOP_MODE_AUTOLEARNING').
+	Supported range: 1 ... 3 */
+	u8	nRobust;
+	/** Query interval.
+	Used to define the query interval in units of 100 ms when the
+	hardware-based IGMP/MLD snooping function is enabled.
+	The automatically learned router port will be aged out if no IGMP/MLD
+	query frame is received from the router port
+	for (nQueryInterval * nRobust) seconds.
+	The supported range is from 100 ms to 25.5 s, with a default value
+	of 10 s. This query interval is used in case IGMP hardware learning is
+	enabled ('eIGMP_Mode = GSW_MULTICAST_SNOOP_MODE_AUTOLEARNING'). */
+	u8	nQueryInterval;
+	/** IGMP/MLD report suppression and Join Aggregation control.
+	Whenever the report message is already sent out for the same multicast
+	group, the successive report message within the
+	query-max-responsetime with the same group ID will be filtered
+	by the switch. This is called report suppression.
+	Whenever the join message is already sent out for the same multicast
+	group, the successive join message with the same group ID will be filtered.
+	This is called join aggregation. This suppression control is used in
+	case IGMP hardware learning is
+	enable ('eIGMP_Mode = GSW_MULTICAST_SNOOP_MODE_AUTOLEARNING'). */
+	GSW_multicastReportSuppression_t       eSuppressionAggregation;
+	/** Hardware IGMP snooping fast leave option.
+	Allows the hardware to automatically clear the membership
+	when receiving the IGMP leave packet. This
+	fast leave option is used in case IGMP hardware learning is
+	enabled ('eIGMP_Mode = GSW_MULTICAST_SNOOP_MODE_AUTOLEARNING').
+	Note: The fast-leave option shall only be enabled where only
+	one host is connected to each interface.
+	If fast-leave is enabled where more than one host is connected
+	to an interface, some hosts might be dropped inadvertently.
+	Fast-leave processing is supported only with IGMP version 2 hosts. */
+	ltq_bool_t	bFastLeave;
+	/** Hardware router port auto-learning. Allows for the
+	    ports on which a router is located to be learned automatically. This router port learning option is
+	    used in case IGMP hardware learning is
+	    enabled ('eIGMP_Mode = GSW_MULTICAST_SNOOP_MODE_AUTOLEARNING'). */
+	ltq_bool_t	bLearningRouter;
+	/** Discard Unknown IP Multicast Packets.
+	    Multicast packets are defined as unknown in case the group address
+	    cannot be found in the switch multicast group table. The table group
+	    entries could be either automatically learned or they are statically
+	    added. This Boolean parameter defines if such unknown multicast
+	    packet are forwarded to the multicast forwarding
+	    portmap (command \ref GSW_PORT_CFG_SET,
+	    parameter 'bMulticastUnknownDrop') or if they are dropped instead.
+
+	    - 1: Drop unknown multicast packets.
+	    - 0: Forward unknown multicast packets for the
+	      multicast forwarding portmap.
+	*/
+	ltq_bool_t	bMulticastUnknownDrop;
+	/** Multicast Forwarding based upon FID or Not - valid for GSWIP-3.0 only.
+	- 1 : Multicast Forwarding is based upon FID.
+	- 0 : Multicast Forwarding is not based upon FID.  **/
+	ltq_bool_t	bMulticastFIDmode;
+} GSW_multicastSnoopCfg_t;
+
+/** \brief Add an Ethernet port as router port to the switch hardware multicast table.
+    Used by \ref GSW_MULTICAST_ROUTER_PORT_ADD and \ref GSW_MULTICAST_ROUTER_PORT_REMOVE. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting) in GSWIP-2.1/2.2/3.0. From
+	    GSWIP-3.1, this field is Bridge Port ID. The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available.
+
+	    \remarks
+	    This field is used as portmap field, when the MSB bit is set.
+	    In portmap mode, every value bit represents an Ethernet port.
+	    LSB represents Port 0 with incrementing counting.
+	    The (MSB - 1) bit represent the last port.
+	    The macro \ref GSW_PORTMAP_FLAG_SET allows to set the MSB bit,
+	    marking it as portmap variable.
+	    Checking the portmap flag can be done by
+	    using the \ref GSW_PORTMAP_FLAG_GET macro. */
+	u16	nPortId;
+} GSW_multicastRouter_t;
+
+/** \brief Check if a port has been selected as a router port.
+    Used by \ref GSW_MULTICAST_ROUTER_PORT_READ. Not applicable to GSWIP-3.1. */
+typedef struct {
+	/** Restart the get operation from the start of the table. Otherwise
+	    return the next table entry (next to the entry that was returned
+	    during the previous get operation). This parameter is always reset
+	    during the read operation. This boolean parameter is set by the
+	    calling application. */
+	ltq_bool_t	bInitial;
+	/** Indicates that the read operation got all last valid entries of the
+	    table. This boolean parameter is set by the switch API
+	    when the Switch API is called after the last valid one was returned already. */
+	ltq_bool_t	bLast;
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u16	nPortId;
+} GSW_multicastRouterRead_t;
+
+/** \brief Defines the multicast group member mode.
+    Used by \ref GSW_multicastTable_t and \ref GSW_multicastTableRead_t. */
+typedef enum {
+	/** Include source IP address membership mode.
+	    Only supported for IGMPv3. */
+	GSW_IGMP_MEMBER_INCLUDE	= 0,
+	/** Exclude source IP address membership mode.
+	    Only supported for IGMPv3. */
+	GSW_IGMP_MEMBER_EXCLUDE	= 1,
+	/** Group source IP address is 'don't care'. This means all source IP
+	    addresses (*) are included for the multicast group membership.
+	    This is the default mode for IGMPv1 and IGMPv2. */
+	GSW_IGMP_MEMBER_DONT_CARE	= 2
+} GSW_IGMP_MemberMode_t;
+
+/** \brief Add a host as a member to a multicast group.
+    Used by \ref GSW_MULTICAST_TABLE_ENTRY_ADD and \ref GSW_MULTICAST_TABLE_ENTRY_REMOVE. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting) in GSWIP-2.1/2.2/3.0. From
+	    GSWIP-3.1, this field is Bridge Port ID. The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u32	nPortId;
+	/** Sub-Interface Id - valid for GSWIP 3.0/3.1 only */
+	u16	nSubIfId;
+	/** Select the IP version of the 'uIP_Gda' and 'uIP_Gsa' fields.
+	    Both fields support either IPv4 or IPv6. */
+	GSW_IP_Select_t	eIPVersion;
+	/** Group Destination IP address (GDA). */
+	GSW_IP_t	uIP_Gda;
+	/** Group Source IP address. Only used in case IGMPv3 support is enabled
+	    and 'eModeMember != GSW_IGMP_MEMBER_DONT_CARE'. */
+	GSW_IP_t	uIP_Gsa;
+	/** FID - valid for GSWIP 3.0 only subject to Global FID for MC is enabled.
+	          always valid in GSWIP-3.1. */
+	u8 nFID;
+	/** Exclude Mode - valid for GSWIP 3.0 only - Includes or Excludes Source IP - uIP_Gsa */
+	ltq_bool_t bExclSrcIP;
+	/** Group member filter mode.
+	    This is valid for GSWIP-3.0/3.1 to replaces bExclSrcIP.
+	    This parameter is ignored when deleting a multicast membership table entry.
+	    The configurations 'GSW_IGMP_MEMBER_EXCLUDE'
+	    and 'GSW_IGMP_MEMBER_INCLUDE' are only supported
+	    if IGMPv3 is used. */
+	GSW_IGMP_MemberMode_t	eModeMember;
+} GSW_multicastTable_t;
+
+/** \brief Read out the multicast membership table.
+    Used by \ref GSW_MULTICAST_TABLE_ENTRY_READ. */
+typedef struct {
+	/** Restart the get operation from the beginning of the table. Otherwise
+	    return the next table entry (next to the entry that was returned
+	    during the previous get operation). This parameter is always reset
+	    during the read operation. This boolean parameter is set by the
+	    calling application. */
+	ltq_bool_t	bInitial;
+	/** Indicates that the read operation got all last valid entries of the
+	    table. This boolean parameter is set by the switch API
+	    when the Switch API is called after the last valid one was returned already. */
+	ltq_bool_t	bLast;
+	/** Ethernet Port number (zero-based counting) in GSWIP-2.1/2.2/3.0. From
+	    GSWIP-3.1, this field is Bridge Port ID. The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available.
+
+	    \remarks
+	    This field is used as portmap field, when the MSB bit is set.
+	    In portmap mode, every value bit represents an Ethernet port.
+	    LSB represents Port 0 with incrementing counting.
+	    The (MSB - 1) bit represent the last port.
+	    The macro \ref GSW_PORTMAP_FLAG_SET allows to set the MSB bit,
+	    marking it as portmap variable.
+	    Checking the portmap flag can be done by
+	    using the \ref GSW_PORTMAP_FLAG_GET macro. */
+	u16	nPortId;
+	/** Ethernet Port Map - to support GSWIP-3.1, following field is added
+	    for port map in static entry. It's valid only when MSB of nPortId is set.
+	    Each bit stands for 1 bridge port. */
+	u16 nPortMap[16];
+	/** Sub-Interface Id - valid for GSWIP 3.0 only */
+	u8	nSubIfId;
+	/** Select the IP version of the 'uIP_Gda' and 'uIP_Gsa' fields.
+	    Both fields support either IPv4 or IPv6. */
+	GSW_IP_Select_t	eIPVersion;
+	/** Group Destination IP address (GDA). */
+	GSW_IP_t	uIP_Gda;
+	/** Group Source IP address. Only used in case IGMPv3 support is enabled. */
+	GSW_IP_t	uIP_Gsa;
+	/** FID - valid for GSWIP 3.0 only subject to Global FID for MC is enabled */
+	u8 nFID;
+	/** Exclude Mode - valid for GSWIP 3.0 only - Includes or Excludes Source IP - uIP_Gsa */
+	ltq_bool_t bExclSrcIP;
+	/** Group member filter mode.
+	    This parameter is ignored when deleting a multicast membership table entry.
+	    The configurations 'GSW_IGMP_MEMBER_EXCLUDE'
+	    and 'GSW_IGMP_MEMBER_INCLUDE' are only supported
+	    if IGMPv3 is used. */
+	GSW_IGMP_MemberMode_t	eModeMember;
+} GSW_multicastTableRead_t;
+
+/*@}*/ /* GSW_IOCTL_MULTICAST */
+
+/** \addtogroup GSW_IOCTL_OAM */
+/*@{*/
+
+/** \brief Maximum version information string length. */
+#define GSW_VERSION_LEN 64
+
+/** \brief Maximum String Length for the Capability String. */
+#define GSW_CAP_STRING_LEN 128
+
+/** \brief Sets the portmap flag of a PortID variable.
+    Some Switch API commands allow to use a port index as portmap variable.
+    This requires that the MSB bit is set to indicate that this variable
+    contains a portmap, instead of a port index.
+    In portmap mode, every value bit represents an Ethernet port.
+    LSB represents Port 0 with incrementing counting.
+    The (MSB - 1) bit represent the last port. */
+#define GSW_PORTMAP_FLAG_SET(varType) (1 << ( sizeof(((varType *)0)->nPortId) * 8 - 1))
+
+/** \brief Checks the portmap flag of a PortID variable.
+    Some Switch API commands allow to use a port index as portmap variable.
+    This requires that the MSB bit is set to indicate that this variable
+    contains a portmap, instead of a port index.
+    In portmap mode, every value bit represents an Ethernet port.
+    LSB represents Port 0 with incrementing counting.
+    The (MSB - 1) bit represent the last port. */
+#define GSW_PORTMAP_FLAG_GET(varType) (1 << ( sizeof(((varType *)0)->nPortId) * 8 - 1))
+
+/** \brief Data structure used to request the Switch API and device hardware
+    version information. A zero-based index is provided to the Switch API that
+    describes the request version information.
+    Used by \ref GSW_VERSION_GET. */
+typedef struct {
+	/** Version ID starting with 0. */
+	u16	nId;
+	/** Name or ID of the version information. */
+	char cName[GSW_VERSION_LEN];
+	/** Version string information. */
+	char	cVersion[GSW_VERSION_LEN];
+} GSW_version_t;
+
+/** \brief Switch API hardware initialization mode.
+    Used by \ref GSW_HW_Init_t. */
+typedef enum {
+	/** Access the switch hardware to read out status and capability
+	    information. Then define the basic hardware configuration to bring
+	    the hardware into a pre-defined state. */
+	GSW_HW_INIT_WR	= 0,
+	/** Access the switch hardware to read out status and capability
+	    information. Do not write any hardware configuration to the device.
+	    This means that the current existing hardware configuration remains
+	    unchanged. */
+	GSW_HW_INIT_RO	= 1,
+	/** Initialize the switch software module but do not touch the switch
+	    hardware. This means that no read or write operations are done on
+	    the switch hardware. Status and capability information cannot be
+	    retrieved from the hardware. */
+	GSW_HW_INIT_NO	= 2
+} GSW_HW_InitMode_t;
+
+/** \brief Switch hardware platform initialization structure.
+    Used by \ref GSW_HW_INIT. */
+typedef struct {
+	/** Select the type of Switch API and hardware initialization. */
+	GSW_HW_InitMode_t	eInitMode;
+} GSW_HW_Init_t;
+
+/** \brief Aging Timer Value.
+    Used by \ref GSW_cfg_t. */
+typedef enum {
+	/** 1 second aging time */
+	GSW_AGETIMER_1_SEC	= 1,
+	/** 10 seconds aging time */
+	GSW_AGETIMER_10_SEC	= 2,
+	/** 300 seconds aging time */
+	GSW_AGETIMER_300_SEC	= 3,
+	/** 1 hour aging time */
+	GSW_AGETIMER_1_HOUR	= 4,
+	/** 24 hours aging time */
+	GSW_AGETIMER_1_DAY	= 5,
+	/** Custom aging time in seconds */
+	GSW_AGETIMER_CUSTOM  = 6
+} GSW_ageTimer_t;
+
+/** \brief Ethernet port speed mode.
+    For certain generations of GSWIP, a port might support only a subset of the possible settings.
+    Used by \ref GSW_portLinkCfg_t. */
+typedef enum {
+	/** 10 Mbit/s */
+	GSW_PORT_SPEED_10	= 10,
+	/** 100 Mbit/s */
+	GSW_PORT_SPEED_100	= 100,
+	/** 200 Mbit/s */
+	GSW_PORT_SPEED_200	= 200,
+	/** 1000 Mbit/s */
+	GSW_PORT_SPEED_1000	= 1000,
+	/** 2.5 Gbit/s */
+	GSW_PORT_SPEED_25000	= 25000,
+	/** 10 Gbit/s */
+	GSW_PORT_SPEED_100000 = 100000,
+} GSW_portSpeed_t;
+
+/** \brief Ethernet port duplex status.
+    Used by \ref GSW_portLinkCfg_t. */
+typedef enum {
+	/** Port operates in full-duplex mode */
+	GSW_DUPLEX_FULL	= 0,
+	/** Port operates in half-duplex mode */
+	GSW_DUPLEX_HALF	= 1,
+	/** Port operates in Auto mode */
+	GSW_DUPLEX_AUTO	= 2,
+} GSW_portDuplex_t;
+
+/** \brief Force the MAC and PHY link modus.
+    Used by \ref GSW_portLinkCfg_t. */
+typedef enum {
+	/** Link up. Any connected LED
+	    still behaves based on the real PHY status. */
+	GSW_PORT_LINK_UP	= 0,
+	/** Link down. */
+	GSW_PORT_LINK_DOWN	= 1,
+	/** Link Auto. */
+	GSW_PORT_LINK_AUTO	= 2,	
+} GSW_portLink_t;
+
+/** \brief Enumeration used for Switch capability types. GSWIP-3.0 only capabilities are explicitly indicated.
+    Used by \ref GSW_cap_t. */
+typedef enum {
+	/** Number of physical Ethernet ports. */
+	GSW_CAP_TYPE_PORT = 0,
+	/** Number of virtual Ethernet ports. */
+	GSW_CAP_TYPE_VIRTUAL_PORT = 1,
+	/** Size of internal packet memory [in Bytes]. */
+	GSW_CAP_TYPE_BUFFER_SIZE = 2,
+	/** Buffer segment size.
+	    Byte size of a segment, used to store received packet data. */
+	GSW_CAP_TYPE_SEGMENT_SIZE = 3,
+	/** Number of priority queues per device. */
+	GSW_CAP_TYPE_PRIORITY_QUEUE = 4,
+	/** Number of meter instances. */
+	GSW_CAP_TYPE_METER	= 5,
+	/** Number of rate shaper instances. */
+	GSW_CAP_TYPE_RATE_SHAPER	= 6,
+	/** Number of CTAG VLAN groups that can be configured on the switch hardware. */
+	GSW_CAP_TYPE_VLAN_GROUP	= 7,
+	/** Number of Filtering Identifiers (FIDs) */
+	GSW_CAP_TYPE_FID	= 8,
+	/** Number of MAC Bridging table entries */
+	GSW_CAP_TYPE_MAC_TABLE_SIZE	= 9,
+	/** Number of multicast level 3 hardware table entries */
+	GSW_CAP_TYPE_MULTICAST_TABLE_SIZE      = 10,
+	/** Number of supported PPPoE sessions. */
+	GSW_CAP_TYPE_PPPOE_SESSION	= 11,
+	/** Number of STAG VLAN groups that can be configured on the switch hardware. */
+	GSW_CAP_TYPE_SVLAN_GROUP	= 12,
+	/** Number of PMAC Supported in Switch Macro - for GSWIP-3.0 only. */
+	GSW_CAP_TYPE_PMAC	= 13,
+	/** Number of entries in Payload Table size - for GSWIP-3.0 only. */
+	GSW_CAP_TYPE_PAYLOAD	= 14,
+	/** Number of RMON Counters Supported - for GSWIP-3.0 only. */
+	GSW_CAP_TYPE_IF_RMON	= 15,
+	/** Number of Egress VLAN Treatment Entries - for GSWIP-3.0 only. */
+	GSW_CAP_TYPE_EGRESS_VLAN = 16,
+	/** Number of Routing Source-MAC Entries - for GSWIP-R-3.0 only. */
+	GSW_CAP_TYPE_RT_SMAC = 17,
+	/** Number of Routing Destination-MAC Entries - for GSWIP-R-3.0 only. */
+	GSW_CAP_TYPE_RT_DMAC = 18,
+	/** Number of Routing-PPPoE Entries - for GSWIP-R-3.0 only. */
+	GSW_CAP_TYPE_RT_PPPoE = 19,
+	/** Number of Routing-NAT Entries - for GSWIP-R-3.0 only. */
+	GSW_CAP_TYPE_RT_NAT = 20,
+	/** Number of MTU Entries - for GSWIP-R-3.0 only. */
+	GSW_CAP_TYPE_RT_MTU = 21,
+	/** Number of Tunnel Entries - for GSWIP-R-3.0 only. */
+	GSW_CAP_TYPE_RT_TUNNEL = 22,
+	/** Number of RTP Entries - for GSWIP-R-3.0 only. */
+	GSW_CAP_TYPE_RT_RTP = 23,
+	/** Number of CTP ports - for GSWIP-3.1 only. */
+	GSW_CAP_TYPE_CTP = 24,
+	/** Number of bridge ports - for GSWIP-3.1 only. */
+	GSW_CAP_TYPE_BRIDGE_PORT = 25,
+	/** Last Capability Index */
+	GSW_CAP_TYPE_LAST	= 26
+} GSW_capType_t;
+
+/** \brief Capability structure.
+    Used by \ref GSW_CAP_GET. */
+typedef struct {
+	/** Defines the capability type, see \ref GSW_capType_t.*/
+	GSW_capType_t	nCapType;
+	/** Description of the capability. */
+	char cDesc[GSW_CAP_STRING_LEN];
+	/** Defines if, what or how many are available. The definition of cap
+	depends on the type, see captype. */
+	u32 nCap;
+} GSW_cap_t;
+
+/** \brief Global Switch configuration Attributes.
+    Used by \ref GSW_CFG_SET and \ref GSW_CFG_GET. */
+typedef struct {
+	/** MAC table aging timer. After this timer expires the MAC table
+	    entry is aged out. */
+	GSW_ageTimer_t	eMAC_TableAgeTimer;
+	/** If eMAC_TableAgeTimer = GSW_AGETIMER_CUSTOM, this variable defines
+	    MAC table aging timer in seconds. */
+	u32  nAgeTimer;
+	/** VLAN Awareness. The switch is VLAN unaware if this variable is disabled.
+	    In this mode, no VLAN-related APIs are supported and return with an error.
+	    The existing VLAN configuration is discarded when VLAN is disabled again. */
+	ltq_bool_t	bVLAN_Aware;
+	/** Maximum Ethernet packet length. */
+	u16	nMaxPacketLen;
+	/** Automatic MAC address table learning limitation consecutive action.
+	    These frame addresses are not learned, but there exists control as to whether
+	    the frame is still forwarded or dropped.
+
+	    - False: Drop
+	    - True: Forward
+	*/
+	ltq_bool_t	bLearningLimitAction;
+	/** Accept or discard MAC spoofing and port MAC locking violation packets.
+	    MAC spoofing detection features identifies ingress packets that carry
+	    a MAC source address which was previously learned on a different
+	    ingress port (learned by MAC bridging table). This also applies to
+	    static added entries. MAC spoofing detection is enabled on port
+	    level by 'bMAC_SpoofingDetection'.
+	    MAC address port locking is configured on port level
+	    by 'bLearningMAC_PortLock'.
+
+	    - False: Drop
+	    - True: Forward
+	*/
+	ltq_bool_t	bMAC_SpoofingAction;
+	/** Pause frame MAC source address mode. If enabled, use the alternative
+	    address specified with 'nMAC'. */
+	ltq_bool_t	bPauseMAC_ModeSrc;
+	/** Pause frame MAC source address. */
+	u8	nPauseMAC_Src[GSW_MAC_ADDR_LEN];
+} GSW_cfg_t;
+
+/** \brief Port Enable Type Selection.
+    Used by \ref GSW_portCfg_t. */
+typedef enum {
+	/** The port is disabled in both directions. */
+	GSW_PORT_DISABLE	= 0,
+	/** The port is enabled in both directions (ingress and egress). */
+	GSW_PORT_ENABLE_RXTX	= 1,
+	/** The port is enabled in the receive (ingress) direction only. */
+	GSW_PORT_ENABLE_RX	= 2,
+	/** The port is enabled in the transmit (egress) direction only. */
+	GSW_PORT_ENABLE_TX	= 3
+} GSW_portEnable_t;
+
+/** \brief Port Mirror Options.
+    Used by \ref GSW_portCfg_t. */
+typedef enum {
+	/** Mirror Feature is disabled. Normal port usage. */
+	GSW_PORT_MONITOR_NONE	= 0,
+	/** Port Ingress packets are mirrored to the monitor port. */
+	GSW_PORT_MONITOR_RX	= 1,
+	/** Port Egress packets are mirrored to the monitor port. */
+	GSW_PORT_MONITOR_TX	= 2,
+	/** Port Ingress and Egress packets are mirrored to the monitor port. */
+	GSW_PORT_MONITOR_RXTX	= 3,
+	/** Packet mirroring of 'unknown VLAN violation' frames. */
+	GSW_PORT_MONITOR_VLAN_UNKNOWN          = 4,
+	/** Packet mirroring of 'VLAN ingress or egress membership violation' frames. */
+	GSW_PORT_MONITOR_VLAN_MEMBERSHIP       = 16,
+	/** Packet mirroring of 'port state violation' frames. */
+	GSW_PORT_MONITOR_PORT_STATE	= 32,
+	/** Packet mirroring of 'MAC learning limit violation' frames. */
+	GSW_PORT_MONITOR_LEARNING_LIMIT        = 64,
+	/** Packet mirroring of 'port lock violation' frames. */
+	GSW_PORT_MONITOR_PORT_LOCK	= 128
+} GSW_portMonitor_t;
+
+/** \brief Ethernet flow control status.
+    Used by \ref GSW_portCfg_t. */
+typedef enum {
+	/** Automatic flow control mode selection through auto-negotiation. */
+	GSW_FLOW_AUTO	= 0,
+	/** Receive flow control only */
+	GSW_FLOW_RX	= 1,
+	/** Transmit flow control only */
+	GSW_FLOW_TX	= 2,
+	/** Receive and Transmit flow control */
+	GSW_FLOW_RXTX	= 3,
+	/** No flow control */
+	GSW_FLOW_OFF	= 4
+} GSW_portFlow_t;
+
+/** \brief Interface RMON Counter Mode - (FID, SUBID or FLOWID) Config - GSWIP-3.0 only.
+    Used by \ref GSW_portCfg_t. */
+typedef enum {
+	/** FID based Interface RMON counters Usage */
+	GSW_IF_RMON_FID	= 0,
+	/** Sub-Interface Id based Interface RMON counters Usage */
+	GSW_IF_RMON_SUBID	= 1,
+	/** Flow Id (LSB bits 3 to 0) based Interface RMON counters Usage */
+	GSW_IF_RMON_FLOWID_LSB	= 2,
+	/** Flow Id (MSB bits 7 to 4) based Interface RMON counters Usage */
+	GSW_IF_RMON_FLOWID_MSB	= 3
+} GSW_If_RMON_Mode_t;
+
+/** \brief Port Type - GSWIP-3.1 only.
+   Used by \ref GSW_portCfg_t. */
+typedef enum {
+	/** Logical Port */
+	GSW_LOGICAL_PORT = 0,
+	/** Physical Port
+	    Applicable only for GSWIP-3.1/3.2 */
+	GSW_PHYSICAL_PORT = 1,
+	/** Connectivity Termination Port (CTP)
+	    Applicable only for GSWIP-3.1/3.2 */
+	GSW_CTP_PORT = 2,
+	/** Bridge Port
+	    Applicable only for GSWIP-3.1/3.2 */
+	GSW_BRIDGE_PORT = 3
+} GSW_portType_t;
+
+/** \brief Port Configuration Parameters.
+    Used by \ref GSW_PORT_CFG_GET and \ref GSW_PORT_CFG_SET. */
+typedef struct {
+	/** Port Type. This gives information which type of port is configured.
+	    nPortId should be based on this field. */
+	GSW_portType_t ePortType;
+
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u16	nPortId;
+	/** Enable Port (ingress only, egress only, both directions, or disabled).
+	    This parameter is used for Spanning Tree Protocol and 802.1X applications. */
+	GSW_portEnable_t	eEnable;
+	/** Drop unknown unicast packets.
+	    Do not send out unknown unicast packets on this port,
+	    if the boolean parameter is enabled. By default packets of this type
+	    are forwarded to this port. */
+	ltq_bool_t	bUnicastUnknownDrop;
+	/** Drop unknown multicast packets.
+	    Do not send out unknown multicast packets on this port,
+	    if boolean parameter is enabled. By default packets of this type
+	    are forwarded to this port.
+	    Some platforms also drop broadcast packets. */
+	ltq_bool_t	bMulticastUnknownDrop;
+	/** Drop reserved packet types
+	    (destination address from '01 80 C2 00 00 00' to
+	    '01 80 C2 00 00 2F') received on this port. */
+	ltq_bool_t	bReservedPacketDrop;
+	/** Drop Broadcast packets received on this port. By default packets of this
+	  type are forwarded to this port. */
+	ltq_bool_t	bBroadcastDrop;
+	/** Enables MAC address table aging.
+	    The MAC table entries learned on this port are removed after the
+	    aging time has expired.
+	    The aging time is a global parameter, common to all ports. */
+	ltq_bool_t	bAging;
+	/** MAC address table learning on the port specified by 'nPortId'.
+	    By default this parameter is always enabled. */
+	ltq_bool_t	bLearning;
+	/** Automatic MAC address table learning locking on the port specified
+	    by 'nPortId'.
+	    This parameter is only taken into account when 'bLearning' is enabled. */
+	ltq_bool_t	bLearningMAC_PortLock;
+	/** Automatic MAC address table learning limitation on this port.
+	    The learning functionality is disabled when the limit value is zero.
+	    The value 0xFFFF to allow unlimited learned address.
+	    This parameter is only taken into account when 'bLearning' is enabled. */
+	u16 nLearningLimit;
+	/** MAC spoofing detection. Identifies ingress packets that carry
+	    a MAC source address which was previously learned on a different ingress
+	    port (learned by MAC bridging table). This also applies to static added
+	    entries. Those violated packets could be accepted or discarded,
+	    depending on the global switch configuration 'bMAC_SpoofingAction'.
+	    This parameter is only taken into account when 'bLearning' is enabled. */
+	ltq_bool_t	bMAC_SpoofingDetection;
+	/** Port Flow Control Status. Enables the flow control function. */
+	GSW_portFlow_t	eFlowCtrl;
+	/** Port monitor feature. Allows forwarding of egress and/or ingress
+	    packets to the monitor port. If enabled, the monitor port gets
+	    a copy of the selected packet type. */
+	GSW_portMonitor_t	ePortMonitor;
+	/** Assign Interface RMON Counters for this Port - GSWIP-3.0 */
+	ltq_bool_t	bIfCounters;
+	/** Interface RMON Counters Start Index - GSWIP-3.0.
+	    Value of (-1) denotes unassigned Interface Counters.
+	    Valid range : 0-255 available to be shared amongst ports in desired way*/
+	int nIfCountStartIdx;
+	/** Interface RMON Counters Mode - GSWIP-3.0 */
+	GSW_If_RMON_Mode_t	eIfRMONmode;
+} GSW_portCfg_t;
+
+/** \brief Special tag Ethertype mode */
+typedef enum {
+	/** The EtherType field of the Special Tag of egress packets is always set
+	    to a prefined value. This same defined value applies for all
+	    switch ports. */
+	GSW_CPU_ETHTYPE_PREDEFINED	= 0,
+	/** The Ethertype field of the Special Tag of egress packets is set to
+	    the FlowID parameter, which is a results of the switch flow
+	    classification result. The switch flow table rule provides this
+	    FlowID as action parameter. */
+	GSW_CPU_ETHTYPE_FLOWID	= 1
+} GSW_CPU_SpecialTagEthType_t;
+
+/** \brief Parser Flags and Offsets Header settings on CPU Port for GSWIP-3.0.
+    Used by \ref GSW_CPU_PortCfg_t. */
+typedef enum {
+	/** No Parsing Flags or Offsets accompanying to CPU Port for this combination */
+	GSW_CPU_PARSER_NIL	= 0,
+	/** 8-Bytes Parsing Flags (Bit 63:0) accompanying to CPU Port for this combination */
+	GSW_CPU_PARSER_FLAGS	= 1,
+	/** 40-Bytes Offsets (Offset-0 to -39) + 8-Bytes Parsing Flags (Bit 63:0) accompanying to CPU Port for this combination */
+	GSW_CPU_PARSER_OFFSETS_FLAGS	= 2,
+	/** Reserved - for future use */
+	GSW_CPU_PARSER_RESERVED = 3
+} GSW_CPU_ParserHeaderCfg_t;
+
+/** \brief Defines one port that is directly connected to the CPU and its applicable settings.
+    Used by \ref GSW_CPU_PORT_CFG_SET and \ref GSW_CPU_PORT_CFG_GET. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting) set to CPU Port. The valid number is hardware
+	    dependent. (E.g. Port number 0 for GSWIP-3.0 or 6 for GSWIP-2.x). An error code is delivered if the selected port is not
+	    available. */
+	u16	nPortId;
+	/** CPU port validity.
+	    Set command: set true to define a CPU port, set false to undo the setting.
+	    Get command: true if defined as CPU, false if not defined as CPU port. */
+	ltq_bool_t	bCPU_PortValid;
+	/** Special tag enable in ingress direction. */
+	ltq_bool_t	bSpecialTagIngress;
+	/** Special tag enable in egress direction. */
+	ltq_bool_t	bSpecialTagEgress;
+	/** Enable FCS check
+
+	    - false: No check, forward all frames
+	    - 1: Check FCS, drop frames with errors
+	*/
+	ltq_bool_t	bFcsCheck;
+	/** Enable FCS generation
+
+	    - false: Forward packets without FCS
+	    - 1: Generate FCS for all frames
+	*/
+	ltq_bool_t	bFcsGenerate;
+	/** Special tag Ethertype mode. Not applicable to GSWIP-3.1. */
+	GSW_CPU_SpecialTagEthType_t	bSpecialTagEthType;
+	/** GSWIP-3.0 specific Parser Header Config for no MPE flags (i.e. MPE1=0, MPE2=0). */
+	GSW_CPU_ParserHeaderCfg_t  eNoMPEParserCfg;
+	/** GSWIP-3.0 specific Parser Header Config for MPE-1 set flag (i.e. MPE1=1, MPE2=0). */
+	GSW_CPU_ParserHeaderCfg_t  eMPE1ParserCfg;
+	/** GSWIP-3.0 specific Parser Header Config for MPE-2 set flag (i.e. MPE1=0, MPE2=1). */
+	GSW_CPU_ParserHeaderCfg_t  eMPE2ParserCfg;
+	/** GSWIP-3.0 specific Parser Header Config for both MPE-1 and MPE-2 set flag (i.e. MPE1=1, MPE2=1). */
+	GSW_CPU_ParserHeaderCfg_t  eMPE1MPE2ParserCfg;
+} GSW_CPU_PortCfg_t;
+
+/** \brief Ethernet layer-2 header selector, when adding or removing on
+    transmitted packets.
+    Used by \ref GSW_CPU_PortExtendCfg_t. */
+typedef enum {
+	/** No additional Ethernet header. */
+	GSW_CPU_HEADER_NO	= 0,
+	/** Additional Ethernet header. */
+	GSW_CPU_HEADER_MAC	= 1,
+	/** Additional Ethernet- and CTAG VLAN- header. */
+	GSW_CPU_HEADER_VLAN	= 2
+} GSW_CPU_HeaderMode_t;
+
+/** \brief CPU Port Layer-2 Header extension.
+    Used by \ref GSW_CPU_PortExtendCfg_t. */
+typedef struct {
+	/** Packet MAC Source Address. */
+	u8	nMAC_Src[GSW_MAC_ADDR_LEN];
+	/** Packet MAC Destination Address. */
+	u8	nMAC_Dst[GSW_MAC_ADDR_LEN];
+	/** Packet EtherType Field. */
+	u16	nEthertype;
+	/** CTAG VLAN Tag Priority Field.
+	    Only used when adding VLAN tag is
+	    enabled (eHeaderAdd=GSW_CPU_HEADER_VLAN). */
+	u8	nVLAN_Prio;
+	/** CTAG VLAN Tag Canonical Format Identifier.
+	    Only used when adding VLAN tag is
+	    enabled (eHeaderAdd=GSW_CPU_HEADER_VLAN). */
+	u8	nVLAN_CFI;
+	/** CTAG VLAN Tag VID.
+	    Only used when adding VLAN tag is
+	    enabled (eHeaderAdd=GSW_CPU_HEADER_VLAN). */
+	u16	nVLAN_ID;
+} GSW_CPU_Header_t;
+
+/** \brief CPU port PAUSE frame handling.
+    Used by \ref GSW_CPU_PortExtendCfg_t. */
+typedef enum {
+	/** Forward all PAUSE frames coming from the switch macro towards
+	    the DMA channel. These frames do not influence the packet transmission. */
+	GSW_CPU_PAUSE_FORWARD	= 0,
+	/** Dispatch all PAUSE frames coming from the switch macro towards
+	    the DMA channel. These are filtered out and the packets transmission is
+	    stopped and restarted accordingly. */
+	GSW_CPU_PAUSE_DISPATCH	= 1
+} GSW_CPU_Pause_t;
+
+/** \brief Ethernet port interface mode.
+    A port might support only a subset of the possible settings.
+    Used by \ref GSW_portLinkCfg_t. */
+typedef enum {
+	/** Normal PHY interface (twisted pair), use the internal MII Interface. */
+	GSW_PORT_HW_MII	= 0,
+	/** Reduced MII interface in normal mode. */
+	GSW_PORT_HW_RMII	= 1,
+	/** GMII or MII, depending upon the speed. */
+	GSW_PORT_HW_GMII	= 2,
+	/** RGMII mode. */
+	GSW_PORT_HW_RGMII = 3,
+	/** XGMII mode. */
+	GSW_PORT_HW_XGMII = 4,
+} GSW_MII_Mode_t;
+
+/** \brief Ethernet port configuration for PHY or MAC mode.
+    Used by \ref GSW_portLinkCfg_t. */
+typedef enum {
+	/** MAC Mode. The Ethernet port is configured to work in MAC mode. */
+	GSW_PORT_MAC	= 0,
+	/** PHY Mode. The Ethernet port is configured to work in PHY mode. */
+	GSW_PORT_PHY	= 1
+} GSW_MII_Type_t;
+
+/** \brief Ethernet port clock source configuration.
+    Used by \ref GSW_portLinkCfg_t. */
+typedef enum {
+	/** Clock Mode not applicable. */
+	GSW_PORT_CLK_NA	= 0,
+	/** Clock Master Mode. The port is configured to provide the clock as output signal. */
+	GSW_PORT_CLK_MASTER	= 1,
+	/** Clock Slave Mode. The port is configured to use the input clock signal. */
+	GSW_PORT_CLK_SLAVE	= 2
+} GSW_clkMode_t;
+
+/** \brief Additional CPU port configuration for platforms where the CPU port is
+    fixed set on a dedicated port.
+
+    Used by \ref GSW_CPU_PORT_EXTEND_CFG_SET
+    and \ref GSW_CPU_PORT_EXTEND_CFG_GET. */
+typedef struct {
+	/** Add Ethernet layer-2 header (also CTAG VLAN) to the transmit packet.
+	    The corresponding header fields are set in 'sHeader'. */
+	GSW_CPU_HeaderMode_t	eHeaderAdd;
+	/** Remove Ethernet layer-2 header (also CTAG VLAN) for packets going from
+	    Ethernet switch to the DMA. Only the first VLAN tag found is removed
+	    and additional available VLAN tags remain untouched. */
+	ltq_bool_t	bHeaderRemove;
+	/** Ethernet layer-2 header information. Used when adding a header to the
+	    transmitted packet. The parameter 'eHeaderAdd' selects the mode if
+	    a layer-2 header should be added (including VLAN).
+	    This structure contains all fields of the Ethernet and VLAN header. */
+	GSW_CPU_Header_t	sHeader;
+	/** Describes how the port handles received PAUSE frames coming from the
+	    switch. Either forward them to DMA or stop/start transmission.
+	    Note that the parameter 'eFlowCtrl' of the
+	    command 'GSW_PORT_CFG_SET' determines whether the switch
+	    generates PAUSE frames. */
+	GSW_CPU_Pause_t	ePauseCtrl;
+	/** Remove the CRC (FCS) of all packets coming from the switch towards
+	    the DMA channel.
+	    Note that the FCS check and generation option can be configured
+	    using 'GSW_CPU_PORT_CFG_SET'. */
+	ltq_bool_t	bFcsRemove;
+	/** Port map of Ethernet switch ports that are assigned to the WAN side
+	    (dedicated for applications where ports are grouped into WAN- and
+	    LAN-segments). All ports that are not selected belong to the LAN segment.
+	    The LSB bit represents port 0, the higher bits represent the higher
+	    port numbers. */
+	u32	nWAN_Ports;
+} GSW_CPU_PortExtendCfg_t;
+
+/** \brief Ethernet port link, speed status and flow control status.
+    Used by \ref GSW_PORT_LINK_CFG_GET and \ref GSW_PORT_LINK_CFG_SET. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u16	nPortId;
+	/** Force Port Duplex Mode.
+
+	    - 0: Negotiate Duplex Mode. Auto-negotiation mode. Negotiated
+	      duplex mode given in 'eDuplex'
+	      during GSW_PORT_LINK_CFG_GET calls.
+	    - 1: Force Duplex Mode. Force duplex mode in 'eDuplex'.
+	*/
+	ltq_bool_t	bDuplexForce;
+	/** Port Duplex Status. */
+	GSW_portDuplex_t	eDuplex;
+	/** Force Link Speed.
+
+	    - 0: Negotiate Link Speed. Negotiated speed given in
+	      'eSpeed' during GSW_PORT_LINK_CFG_GET calls.
+	    - 1: Force Link Speed. Forced speed mode in 'eSpeed'.
+	*/
+	ltq_bool_t	bSpeedForce;
+	/** Ethernet port link up/down and speed status. */
+	GSW_portSpeed_t	eSpeed;
+	/** Force Link.
+
+	     - 0: Auto-negotiate Link. Current link status is given in
+	       'eLink' during GSW_PORT_LINK_CFG_GET calls.
+	     - 1: Force Duplex Mode. Force duplex mode in 'eLink'.
+	 */
+	ltq_bool_t	bLinkForce;
+	/** Link Status. Read out the current link status.
+	    Note that the link could be forced by setting 'bLinkForce'. */
+	GSW_portLink_t	eLink;
+	/** Selected interface mode (MII/RMII/RGMII/GMII/XGMII). */
+	GSW_MII_Mode_t	eMII_Mode;
+	/** Select MAC or PHY mode (PHY = Reverse xMII). */
+	GSW_MII_Type_t	eMII_Type;
+	/** Interface Clock mode (used for RMII mode). */
+	GSW_clkMode_t	eClkMode;
+	/** 'Low Power Idle' Support for 'Energy Efficient Ethernet'.
+	    Only enable this feature in case the attached PHY also supports it. */
+	ltq_bool_t	bLPI;
+} GSW_portLinkCfg_t;
+
+/** \brief Ethernet Interface RGMII Clock Configuration. Only needed in case the
+    interface runs in RGMII mode.
+    Used by \ref GSW_PORT_RGMII_CLK_CFG_SET and \ref GSW_PORT_RGMII_CLK_CFG_GET. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u16	nPortId;
+	/** Clock Delay RX [multiple of 500 ps]. */
+	u8	nDelayRx;
+	/** Clock Delay TX [multiple of 500 ps]. */
+	u8	nDelayTx;
+} GSW_portRGMII_ClkCfg_t;
+
+/** \brief Query whether the Ethernet switch hardware has detected a connected
+    PHY on the port.
+    Used by \ref GSW_PORT_PHY_QUERY. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u16	nPortId;
+	/** Check if the Ethernet switch hardware has detected a connected PHY
+	    on this port. */
+	ltq_bool_t	bPHY_Present;
+} GSW_portPHY_Query_t;
+
+/** \brief Ethernet PHY address definition. Defines the relationship between a
+    bridge port and the MDIO address of a PHY that is attached to this port.
+    Used by \ref GSW_PORT_PHY_ADDR_GET. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u16	nPortId;
+	/** Device address on the MDIO interface */
+	u8	nAddressDev;
+} GSW_portPHY_Addr_t;
+
+/** \brief Port redirection control.
+    Used by \ref GSW_PORT_REDIRECT_GET and \ref GSW_PORT_REDIRECT_SET. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u16	nPortId;
+	/** Port Redirect Option.
+	    If enabled, all packets destined to 'nPortId' are redirected to the
+	    CPU port. The destination port map in the status header information is
+	    not changed so that the original destination port can be identified by
+	    software. */
+	ltq_bool_t	bRedirectEgress;
+	/** Port Ingress Direct Forwarding.
+	    If enabled, all packets sourced from 'nPortId' are directly forwarded to queue 0
+	    of the CPU port. These packets are not modified and are not affected by
+	    normal learning, look up, VLAN processing and queue selection. */
+	ltq_bool_t	bRedirectIngress;
+} GSW_portRedirectCfg_t;
+
+/** \brief Port monitor configuration.
+    Used by \ref GSW_MONITOR_PORT_CFG_GET and \ref GSW_MONITOR_PORT_CFG_SET. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u16	nPortId;
+	/** This port is used as a monitor port. To use this feature, the port
+	  mirror function is enabled on one or more ports. */
+	ltq_bool_t	bMonitorPort;
+	/* Monitoring Sub-IF id */
+	u16	nSubIfId;
+} GSW_monitorPortCfg_t;
+
+/** \brief MDIO Interface Configuration.
+    Used by \ref GSW_MDIO_CFG_GET and \ref GSW_MDIO_CFG_SET. */
+typedef struct {
+	/** MDIO interface clock and data rate [in kHz]. */
+	u32	nMDIO_Speed;
+	/** MDIO interface enable. */
+	ltq_bool_t	bMDIO_Enable;
+} GSW_MDIO_cfg_t;
+
+/** \brief MDIO Register Access.
+    The 'nData' value is directly written to the device register
+    or read from the device.
+    Some PHY device registers have standard bit definitions as stated in
+    IEEE 802.
+    Used by \ref GSW_MDIO_DATA_READ and \ref GSW_MDIO_DATA_WRITE. */
+typedef struct {
+	/** Device address on the MDIO interface */
+	u8	nAddressDev;
+	/** Register address inside the device. */
+	u8	nAddressReg;
+	/** Exchange data word with the device (read / write). */
+	u16	nData;
+} GSW_MDIO_data_t;
+
+/** \brief MAC Cli struct.
+     MAC Cli struct for passing args and argument values. */
+typedef struct {
+	/** Number of args */
+	u32 argc;
+	/** Argument values */
+	u8 argv[10][30];
+} GSW_MAC_cfg_t;
+
+/** \brief MMD Register Access. The 'nData' value is directly written
+    to the device register or read from the device. Some PHY
+    device registers have standard bit definitions as stated in
+    IEEE 802. Used by \ref GSW_MMD_DATA_READ and \ref
+    GSW_MMD_DATA_WRITE. */
+typedef struct {
+	/** Device address on the MDIO interface */
+	u8	nAddressDev;
+	/** MMD Register address/offset inside the device. */
+	u32	nAddressReg;
+	/** Exchange data word with the device (read / write). */
+	u16	nData;
+} GSW_MMD_data_t;
+
+/** \brief Enumeration for function status return. The upper four bits are reserved for error classification */
+typedef enum {
+	/** Correct or Expected Status */
+	GSW_statusOk	= 0,
+	/** Invalid function parameter */
+	GSW_statusParam	= -2,
+	/** No space left in VLAN table */
+	GSW_statusVLAN_Space	= -3,
+	/** Requested VLAN ID not found in table */
+	GSW_statusVLAN_ID	= -4,
+	/** Invalid ioctl */
+	GSW_statusInvalIoctl	= -5,
+	/** Operation not supported by hardware */
+	GSW_statusNoSupport	= -6,
+	/** Timeout */
+	GSW_statusTimeout	= -7,
+	/** At least one value is out of range */
+	GSW_statusValueRange	= -8,
+	/** The PortId/QueueId/MeterId/etc. is not available in this hardware or the
+	    selected feature is not available on this port */
+	GSW_statusPortInvalid	= -9,
+	/** The interrupt is not available in this hardware */
+	GSW_statusIRQ_Invalid	= -10,
+	/** The MAC table is full, an entry could not be added */
+	GSW_statusMAC_TableFull	= -11,
+	/** Locking failed - SWAPI is busy */
+	GSW_statusLock_Failed	=  -12,
+	/** Generic or unknown error occurred */
+	GSW_statusErr	= -1
+} GSW_return_t;
+
+/** \brief Configures the Wake-on-LAN function.
+    Used by \ref GSW_WOL_CFG_SET and \ref GSW_WOL_CFG_GET. */
+typedef struct {
+	/** WoL MAC address. */
+	u8	nWolMAC[GSW_MAC_ADDR_LEN];
+	/** WoL password. */
+	u8	nWolPassword[GSW_MAC_ADDR_LEN];
+	/** WoL password enable. */
+	ltq_bool_t	bWolPasswordEnable;
+} GSW_WoL_Cfg_t;
+
+/** \brief Enables Wake-on-LAN functionality on the port.
+    Used by \ref GSW_WOL_PORT_CFG_SET and \ref GSW_WOL_PORT_CFG_GET. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u16	nPortId;
+	/** Enable Wake-on-LAN. */
+	ltq_bool_t	bWakeOnLAN_Enable;
+	/** Ignore address check */
+	ltq_bool_t	bIgnoreAdrCheck;
+} GSW_WoL_PortCfg_t;
+
+/*@}*/ /* GSW_IOCTL_OAM */
+
+/** \addtogroup GSW_IOCTL_RMON */
+/*@{*/
+
+
+/** \brief RMON Counters Type enumeration.
+    Used by \ref GSW_RMON_clear_t and \ref GSW_RMON_mode_t. */
+typedef enum {
+	/** All RMON Types Counters */
+	GSW_RMON_ALL_TYPE = 0,
+	/** All PMAC RMON Counters */
+	GSW_RMON_PMAC_TYPE = 1,
+	/** Port based RMON Counters */
+	GSW_RMON_PORT_TYPE = 2,
+	/** Meter based RMON Counters */
+	GSW_RMON_METER_TYPE = 3,
+	/** Interface based RMON Counters */
+	GSW_RMON_IF_TYPE = 4,
+	/** Route based RMON Counters */
+	GSW_RMON_ROUTE_TYPE = 5,
+	/** Redirected Traffic based RMON Counters */
+	GSW_RMON_REDIRECT_TYPE	= 6,
+	/** Bridge Port based RMON Counters */
+	GSW_RMON_BRIDGE_TYPE	= 7,
+	/** CTP Port based RMON Counters */
+	GSW_RMON_CTP_TYPE	= 8,
+} GSW_RMON_type_t;
+
+/** \brief RMON Counters Data Structure for clearance of values.
+    Used by \ref GSW_RMON_CLEAR. */
+typedef struct {
+	/** RMON Counters Type */
+	GSW_RMON_type_t eRmonType;
+	/** RMON Counters Identifier - Meter, Port, If, Route, etc. */
+	u8 nRmonId;
+} GSW_RMON_clear_t;
+
+/**Defined as per RMON counter table structure
+  Applicable only for GSWIP 3.1*/
+typedef enum {
+	GSW_RMON_CTP_PORT_RX = 0,
+	GSW_RMON_CTP_PORT_TX = 1,
+	GSW_RMON_BRIDGE_PORT_RX = 2,
+	GSW_RMON_BRIDGE_PORT_TX = 3,
+	GSW_RMON_CTP_PORT_PCE_BYPASS = 4,
+	GSW_RMON_TFLOW_RX = 5,
+	GSW_RMON_TFLOW_TX = 6,
+	GSW_RMON_QMAP = 0x0E,
+	GSW_RMON_METER = 0x19,
+	GSW_RMON_PMAC = 0x1C,
+} GSW_RMON_portType_t;
+
+/* TFLOW counter mode type */
+typedef enum {
+	/* Global mode */
+	GSW_TFLOW_CMODE_GLOBAL = 0,
+	/* Logical mode */
+	GSW_TFLOW_CMODE_LOGICAL = 1,
+	/* CTP port mode */
+	GSW_TFLOW_CMODE_CTP = 2,
+	/* Bridge port mode */
+	GSW_TFLOW_CMODE_BRIDGE = 3,
+} GSW_TflowCmodeType_t;
+
+/* TFLOW counter type */
+typedef enum {
+	/* Set all Rx/Tx/PCE-Bp-Tx registers to same value */
+	GSW_TFLOW_COUNTER_ALL = 0, //Default for 'set' function.
+	/* SEt PCE Rx register config only */
+	GSW_TFLOW_COUNTER_PCE_Rx = 1, //Default for 'get' function.
+	/* SEt PCE Tx register config only */
+	GSW_TFLOW_COUNTER_PCE_Tx = 2,
+	/* SEt PCE-Bypass Tx register config only */
+	GSW_TFLOW_COUNTER_PCE_BP_Tx = 3,
+} GSW_TflowCountConfType_t;
+
+/* TFLOW CTP counter LSB bits */
+typedef enum {
+	/* Num of valid bits  */
+	GSW_TCM_CTP_VAL_BITS_0 = 0,
+	GSW_TCM_CTP_VAL_BITS_1 = 1,
+	GSW_TCM_CTP_VAL_BITS_2 = 2,
+	GSW_TCM_CTP_VAL_BITS_3 = 3,
+	GSW_TCM_CTP_VAL_BITS_4 = 4,
+	GSW_TCM_CTP_VAL_BITS_5 = 5,
+	GSW_TCM_CTP_VAL_BITS_6 = 6,
+} GSW_TflowCtpValBits_t;
+
+/* TFLOW bridge port counter LSB bits */
+typedef enum {
+	/* Num of valid bits  */
+	GSW_TCM_BRP_VAL_BITS_2 = 2,
+	GSW_TCM_BRP_VAL_BITS_3 = 3,
+	GSW_TCM_BRP_VAL_BITS_4 = 4,
+	GSW_TCM_BRP_VAL_BITS_5 = 5,
+	GSW_TCM_BRP_VAL_BITS_6 = 6,
+} GSW_TflowBrpValBits_t;
+
+/**
+ \brief RMON Counters for individual Port.
+ This structure contains the RMON counters of an Ethernet Switch Port.
+    Used by \ref GSW_RMON_PORT_GET. */
+typedef struct {
+	/** Port Type. This gives information which type of port to get RMON.
+	    nPortId should be based on this field.
+	    This is new in GSWIP-3.1. For GSWIP-2.1/2.2/3.0, this field is always
+	    ZERO (GSW_LOGICAL_PORT). */
+	GSW_portType_t ePortType;
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. This parameter specifies for which MAC port the RMON
+	    counter is read. It has to be set by the application before
+	    calling \ref GSW_RMON_PORT_GET. */
+	u16	nPortId;
+	/** Sub interface ID group. The valid range is hardware/protocol dependent.
+
+	    \remarks
+	    This field is valid when \ref GSW_RMON_Port_cnt_t::ePortType is
+	    \ref GSW_portType_t::GSW_CTP_PORT.
+	    Sub interface ID group is defined for each of \ref GSW_LogicalPortMode_t.
+	    For both \ref GSW_LOGICAL_PORT_8BIT_WLAN and
+	    \ref GSW_LOGICAL_PORT_9BIT_WLAN, this field is VAP.
+	    For \ref GSW_LOGICAL_PORT_GPON, this field is GEM index.
+	    For \ref GSW_LOGICAL_PORT_EPON, this field is stream index.
+	    For \ref GSW_LOGICAL_PORT_GINT, this field is LLID.
+	    For others, this field is 0. */
+	u32 nSubIfIdGroup;
+	/** Separate set of CTP Tx counters when PCE is bypassed. GSWIP-3.1 only.*/
+	ltq_bool_t bPceBypass;
+	/*Applicable only for GSWIP 3.1*/
+	/** Discarded at Extended VLAN Operation Packet Count. GSWIP-3.1 only. */
+	u32	nRxExtendedVlanDiscardPkts;
+	/** Discarded MTU Exceeded Packet Count. GSWIP-3.1 only. */
+	u32	nMtuExceedDiscardPkts;
+	/** Tx Undersize (<64) Packet Count. GSWIP-3.1 only. */
+	u32 nTxUnderSizeGoodPkts;
+	/** Tx Oversize (>1518) Packet Count. GSWIP-3.1 only. */
+	u32 nTxOversizeGoodPkts;
+	/** Receive Packet Count (only packets that are accepted and not discarded). */
+	u32	nRxGoodPkts;
+	/** Receive Unicast Packet Count. */
+	u32	nRxUnicastPkts;
+	/** Receive Broadcast Packet Count. */
+	u32	nRxBroadcastPkts;
+	/** Receive Multicast Packet Count. */
+	u32	nRxMulticastPkts;
+	/** Receive FCS Error Packet Count. */
+	u32	nRxFCSErrorPkts;
+	/** Receive Undersize Good Packet Count. */
+	u32	nRxUnderSizeGoodPkts;
+	/** Receive Oversize Good Packet Count. */
+	u32	nRxOversizeGoodPkts;
+	/** Receive Undersize Error Packet Count. */
+	u32	nRxUnderSizeErrorPkts;
+	/** Receive Good Pause Packet Count. */
+	u32	nRxGoodPausePkts;
+	/** Receive Oversize Error Packet Count. */
+	u32	nRxOversizeErrorPkts;
+	/** Receive Align Error Packet Count. */
+	u32	nRxAlignErrorPkts;
+	/** Filtered Packet Count. */
+	u32	nRxFilteredPkts;
+	/** Receive Size 64 Bytes Packet Count. */
+	u32	nRx64BytePkts;
+	/** Receive Size 65-127 Bytes Packet Count. */
+	u32	nRx127BytePkts;
+	/** Receive Size 128-255 Bytes Packet Count. */
+	u32	nRx255BytePkts;
+	/** Receive Size 256-511 Bytes Packet Count. */
+	u32	nRx511BytePkts;
+	/** Receive Size 512-1023 Bytes Packet Count. */
+	u32	nRx1023BytePkts;
+	/** Receive Size 1024-1522 Bytes (or more, if configured) Packet Count. */
+	u32	nRxMaxBytePkts;
+	/** Overall Transmit Good Packets Count. */
+	u32	nTxGoodPkts;
+	/** Transmit Unicast Packet Count. */
+	u32	nTxUnicastPkts;
+	/** Transmit Broadcast Packet Count. */
+	u32	nTxBroadcastPkts;
+	/** Transmit Multicast Packet Count. */
+	u32	nTxMulticastPkts;
+	/** Transmit Single Collision Count. */
+	u32	nTxSingleCollCount;
+	/** Transmit Multiple Collision Count. */
+	u32	nTxMultCollCount;
+	/** Transmit Late Collision Count. */
+	u32	nTxLateCollCount;
+	/** Transmit Excessive Collision Count. */
+	u32	nTxExcessCollCount;
+	/** Transmit Collision Count. */
+	u32	nTxCollCount;
+	/** Transmit Pause Packet Count. */
+	u32	nTxPauseCount;
+	/** Transmit Size 64 Bytes Packet Count. */
+	u32	nTx64BytePkts;
+	/** Transmit Size 65-127 Bytes Packet Count. */
+	u32	nTx127BytePkts;
+	/** Transmit Size 128-255 Bytes Packet Count. */
+	u32	nTx255BytePkts;
+	/** Transmit Size 256-511 Bytes Packet Count. */
+	u32	nTx511BytePkts;
+	/** Transmit Size 512-1023 Bytes Packet Count. */
+	u32	nTx1023BytePkts;
+	/** Transmit Size 1024-1522 Bytes (or more, if configured) Packet Count. */
+	u32	nTxMaxBytePkts;
+	/** Transmit Drop Packet Count. */
+	u32	nTxDroppedPkts;
+	/** Transmit Dropped Packet Count, based on Congestion Management. */
+	u32	nTxAcmDroppedPkts;
+	/** Receive Dropped Packet Count. */
+	u32	nRxDroppedPkts;
+	/** Receive Good Byte Count (64 bit). */
+	u64	nRxGoodBytes;
+	/** Receive Bad Byte Count (64 bit). */
+	u64	nRxBadBytes;
+	/** Transmit Good Byte Count (64 bit). */
+	u64	nTxGoodBytes;
+} GSW_RMON_Port_cnt_t;
+
+/** \brief RMON Counters Mode Enumeration.
+    This enumeration defines Counters mode - Packets based or Bytes based counting.
+    Metering and Routing Sessions RMON counting support either Byte based or packets based only. */
+typedef enum {
+	/** Packet based RMON Counters */
+	GSW_RMON_COUNT_PKTS	= 0,
+	/** Bytes based RMON Counters */
+	GSW_RMON_COUNT_BYTES	= 1,
+	/**  number of dropped frames, supported only for interface cunters */
+	GSW_RMON_DROP_COUNT	= 2,
+} GSW_RMON_CountMode_t;
+
+/** \brief RMON Counters Mode for different Elements.
+    This structure takes RMON Counter Element Name and mode config */
+typedef struct {
+	/** RMON Counters Type */
+	GSW_RMON_type_t eRmonType;
+	/** RMON Counters Mode */
+	GSW_RMON_CountMode_t eCountMode;
+} GSW_RMON_mode_t;
+
+/**
+ \brief RMON Counters for Meter - Type (GSWIP-3.0 only).
+ This structure contains the RMON counters of one Meter Instance.
+    Used by \ref GSW_RMON_METER_GET. */
+typedef struct {
+	/** Meter Instance number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected meter is not
+	    available. This parameter specifies for which Meter Id the RMON-1
+	    counter is read. It has to be set by the application before
+	    calling \ref GSW_RMON_METER_GET. */
+	u8	nMeterId;
+	/** Metered Green colored packets or bytes (depending upon mode) count. */
+	u32	nGreenCount;
+	/** Metered Yellow colored packets or bytes (depending upon mode) count. */
+	u32	nYellowCount;
+	/** Metered Red colored packets or bytes (depending upon mode) count. */
+	u32	nRedCount;
+	/** Metered Reserved (Future Use) packets or bytes (depending upon mode) count. */
+	u32	nResCount;
+} GSW_RMON_Meter_cnt_t;
+
+/**
+ \brief RMON Redirected Counters for  (GSWIP-3.0 only).
+ This structure contains the RMON counters of all Redirected packets.
+    Used by \ref GSW_RMON_REDIRECT_GET. */
+typedef struct {
+	/** Received Total Packets count. */
+	u32	nRxPktsCount;
+	/** Received Discarded Packets count. */
+	u32	nRxDiscPktsCount;
+	/** Received Bytes count excluding discards. */
+	u64	nRxBytesCount;
+	/** Transmitted Total Packets count. */
+	u32	nTxPktsCount;
+	/** Egress Queue Discarded Packets count. */
+	u32	nTxDiscPktsCount;
+	/** Transmitted Bytes count excluding discards. */
+	u64	nTxBytesCount;
+} GSW_RMON_Redirect_cnt_t;
+
+/**
+ \brief RMON Interface Counters for  (GSWIP-3.0 only).
+ This structure contains the RMON counters of Interface Instance.
+    Used by \ref GSW_RMON_IF_GET. */
+typedef struct {
+	/** Interface Counter Index Number. (Range : 0-255)
+	    It has to be reserved for ports by the application before
+	    calling \ref GSW_RMON_IF_GET. */
+	u8	nIfId;
+	/** Counters Mode - Global level current settings. */
+	GSW_RMON_CountMode_t  countMode;
+	/** Received Total Packets count. */
+	u32	nRxPktsCount;
+	/** Received Discarded Packets count */
+	u32	nRxDiscPktsCount;
+	/** Received Bytes count - When this is used, Discarded Count is not available*/
+	u32	nRxBytesCount;
+	/** Transmitted Total Packets count. */
+	u32	nTxPktsCount;
+	/** Egress Discarded Packets count. */
+	u32	nTxDiscPktsCount;
+	/** Transmitted Bytes count - When this is used, Discarded Count is not available */
+	u32	nTxBytesCount;
+} GSW_RMON_If_cnt_t;
+
+/**
+ \brief RMON Routing Counters for  (GSWIP-3.0 only).
+ This structure contains the RMON counters of Routing Port number.
+    Used by \ref GSW_RMON_ROUTE_GET. */
+typedef struct {
+	/** Routed Port Number. */
+	u8	nRoutedPortId;
+	/** Fast Path unicast IPv4 Total UDP Packets Received Count. */
+	u32	nRxUCv4UDPPktsCount;
+	/** Fast Path unicast IPv4 Total TCP Packets Received Count. */
+	u32	nRxUCv4TCPPktsCount;
+	/** Fast Path unicast IPv6 Total UDP Packets Received Count. */
+	u32	nRxUCv6UDPPktsCount;
+	/** Fast Path unicast IPv6 Total TCP Packets Received Count. */
+	u32	nRxUCv6TCPPktsCount;
+	/** Fast Path multicast IPv4 packets Received Count. */
+	u32	nRxMCv4PktsCount;
+	/** Fast Path multicast IPv6 packets Received Count. */
+	u32	nRxMCv6PktsCount;
+	/** CPU Path Received Total Packets Count. */
+	u32	nRxCpuPktsCount;
+	/** Fast Path Dropped Total Packets Count. */
+	u32	nRxPktsDropCount;
+	/** Fast Path IPv4 Traffic Total Bytes Received Count */
+	u32	nRxIPv4BytesCount;
+	/** Fast Path IPv6 Traffic Total Bytes Received Count */
+	u32	nRxIPv6BytesCount;
+	/** CPU Path Traffic Total Bytes Received Count */
+	u32	nRxCpuBytesCount;
+	/** Fast Path Traffic Total Bytes Dropped Count */
+	u32	nRxBytesDropCount;
+	/** Fast Path Traffic Total Packets Transmitted Count */
+	u32	nTxPktsCount;
+	/** Fast Path Traffic Total Bytes Transmitted Count */
+	u32	nTxBytesCount;
+} GSW_RMON_Route_cnt_t;
+
+/*@}*/ /* GSW_IOCTL_RMON */
+
+/** \addtogroup GSW_IOCTL_PMAC */
+/*@{*/
+/** \brief Configure the Backpressure mapping for egress Queues Congestion or ingress (receiving)  ports to DMA channel.
+    Used by \ref GSW_PMAC_BM_CFG_SET and \ref GSW_PMAC_BM_CFG_GET. */
+typedef struct {
+	/** PMAC Interface ID */
+	u8 nPmacId;
+	/**  Tx DMA Channel Identifier which receives sideband backpressure signal (0..15) */
+	u8 nTxDmaChanId;
+	/** Transmit Queues Selection Mask which will generate backpressure - (Configurable upto 32 Egress Queues) */
+	u32 txQMask;
+	/** Receive (Ingress) ports selection congestion Mask which will generate backpressure - (Configurable upto 16 ports) */
+	u32 rxPortMask;
+} GSW_PMAC_BM_Cfg_t;
+
+
+/** \brief Short Length Received Frame Check Type for PMAC.
+    Used by PMAC structure \ref GSW_PMAC_Glbl_Cfg_t. */
+typedef enum {
+	/** Short frame length check is disabled. */
+	GSW_PMAC_SHORT_LEN_DIS = 0,
+	/** Short frame length check is enabled without considering VLAN Tags. */
+	GSW_PMAC_SHORT_LEN_ENA_UNTAG = 1,
+	/** Short frame length check is enabled including VLAN Tags. */
+	GSW_PMAC_SHORT_LEN_ENA_TAG = 2,
+	/** Reserved - Currently unused */
+	GSW_PMAC_SHORT_LEN_RESERVED = 3
+} GSW_PMAC_Short_Frame_Chk_t;
+
+/** \brief Egress PMAC Config Table Selector */
+typedef enum {
+	/** Use value of \ref GSW_PMAC_Glbl_Cfg_t::bProcFlagsEgCfgEna */
+	GSW_PMAC_PROC_FLAGS_NONE = 0,
+	/** Use traffic class for egress config table addressing */
+	GSW_PMAC_PROC_FLAGS_TC = 1,
+	/** Use flags (MPE1, MPE2, DEC, ENC) for egress config table addressing */
+	GSW_PMAC_PROC_FLAGS_FLAG = 2,
+	/** Use reduced traffic class (saturated to 3) and flags (MPE1, MPE2) for
+	    egress config table addressing */
+	GSW_PMAC_PROC_FLAGS_MIX = 3
+} GSW_PMAC_Proc_Flags_Eg_Cfg_t;
+
+/** \brief Configure the global settings of PMAC for GSWIP-3.x. This includes settings such as Jumbo frame, Checksum handling,
+    Padding and Engress PMAC Selector Config.
+    Used by \ref GSW_PMAC_GLBL_CFG_SET and \ref GSW_PMAC_GLBL_CFG_GET. */
+typedef struct {
+	/** PMAC Interface Id */
+	u8 nPmacId;
+	/**  Automatic Padding Settings - Disabled (Default), to enable set it true. */
+	ltq_bool_t bAPadEna;
+	/**  Global Padding Settings - Disabled (Default), to enable set it true. */
+	ltq_bool_t bPadEna;
+	/**  VLAN Padding Setting - Disabled (Default), to enable set it true - applicable when bPadEna is set. */
+	ltq_bool_t bVPadEna;
+	/**  Stacked VLAN Padding Setting - Disabled (Default), to enable set it true - applicable when bPadEna is set. */
+	ltq_bool_t bSVPadEna;
+	/**  Packet carry FCS after PMAC process - Enabled (Default), to disable set it true.
+	     For GSWIP-3.1 only. */
+	ltq_bool_t bRxFCSDis;
+	/**  Transmit FCS Regeneration Setting - Enabled (Default), to disable set it true. */
+	ltq_bool_t bTxFCSDis;
+	/**   IP and Transport (TCP/UDP) Headers Checksum Generation Control - Enabled (Default), to disable set it true. */
+	ltq_bool_t bIPTransChkRegDis;
+	/**   IP and Transport (TCP/UDP) Headers Checksum Verification Control - Enabled (Default), to disable set it true. */
+	ltq_bool_t bIPTransChkVerDis;
+	/**   To enable receipt of Jumbo frames - Disabled (Default - 1518 bytes normal frames without VLAN tags), to enable Jumbo set it true. */
+	ltq_bool_t bJumboEna;
+	/**   Maximum length of Jumbo frames in terms of bytes (Bits 13:0). The maximum handled in Switch is 9990 bytes.  */
+	u16 nMaxJumboLen;
+	/**   Threshold length for Jumbo frames qualification in terms of bytes (Bits 13:0).  */
+	u16 nJumboThreshLen;
+	/**   Long frame length check - Enabled (Default), to disable set it true.  */
+	ltq_bool_t bLongFrmChkDis;
+	/**   Short frame length check Type - default (Enabled for 64 bytes without considering VLAN).  */
+	GSW_PMAC_Short_Frame_Chk_t eShortFrmChkType;
+	/** GSWIP3.0 specific - Egress PMAC Config Table Selector - TrafficClass or Processing Flags (MPE1, MPE22, DEC, ENC based).
+	    The default setting is Traffic Class based selector for Egress PMAC. */
+	ltq_bool_t	bProcFlagsEgCfgEna;
+	/** GSWIP3.1 specific - Egress PMAC Config Table Selector
+	    If this field is not \ref GSW_PMAC_PROC_FLAGS_NONE, it will override
+	    bProcFlagsEgCfgEna. */
+	GSW_PMAC_Proc_Flags_Eg_Cfg_t eProcFlagsEgCfg;
+	/** GSWIP3.1 specific - frame size threshold for buffer selection.
+	    Value in this array should be in ascending order. */
+	u32 nBslThreshold[3];
+} GSW_PMAC_Glbl_Cfg_t;
+
+/** \brief PMAC Ingress Configuration Source
+    Source of the corresponding field. */
+typedef enum {
+	/** Field is from DMA descriptor */
+	GSW_PMAC_IG_CFG_SRC_DMA_DESC = 0,
+	/** Field is from default PMAC header */
+	GSW_PMAC_IG_CFG_SRC_DEF_PMAC = 1,
+	/** Field is from PMAC header of packet */
+	GSW_PMAC_IG_CFG_SRC_PMAC = 2,
+} GSW_PMAC_Ig_Cfg_Src_t;
+
+/** \brief Configure the PMAC Ingress Configuration on a given Tx DMA channel to PMAC. (Upto 16 entries).
+    This Ingress PMAC table is addressed through Trasnmit DMA Channel Identifier.
+    Used by \ref GSW_PMAC_IG_CFG_SET and \ref GSW_PMAC_IG_CFG_GET. */
+typedef struct {
+	/** PMAC Interface Id */
+	u8 nPmacId;
+	/**  Tx DMA Channel Identifier (0..16) - Index of Ingress PMAC Config Table */
+	u8 nTxDmaChanId;
+	/** Error set packets to be discarded (True) or not (False) */
+	ltq_bool_t bErrPktsDisc;
+	/** Port Map info from default PMAC header (True) or incoming PMAC header (False) */
+	ltq_bool_t bPmapDefault;
+	/** Port Map Enable info from default PMAC header (True) or incoming PMAC header (False) */
+	ltq_bool_t bPmapEna;
+	/** Class Info from default PMAC header (True) or incoming PMAC header (False) */
+	ltq_bool_t bClassDefault;
+	/** Class Enable info from default PMAC header (True) or incoming PMAC header (False) */
+	ltq_bool_t bClassEna;
+	/** Sub_Interface Id Info from ingress PMAC header (GSW_PMAC_IG_CFG_SRC_PMAC),
+	    default PMAC header (GSW_PMAC_IG_CFG_SRC_DEF_PMAC), or source sub-If in
+	    packet descriptor (GSW_PMAC_IG_CFG_SRC_DMA_DESC) */
+	GSW_PMAC_Ig_Cfg_Src_t eSubId;
+	/**  Source Port Id from default PMAC header (True) or incoming PMAC header (False) */
+	ltq_bool_t bSpIdDefault;
+	/** Packet PMAC header is present (True) or not (False) */
+	ltq_bool_t bPmacPresent;
+	/** Default PMAC header - 8 Bytes Configuration  - Ingress PMAC Header Format */
+	u8 defPmacHdr[8];
+} GSW_PMAC_Ig_Cfg_t;
+
+/** \brief Configure the PMAC Egress Configuration. (Upto 1024 entries)
+    This Egress PMAC table is addressed through combination of following fields (Bit0 - Bit 9).
+     nDestPortId (Bits 0-3) + Combination of [bMpe1Flag (Bit 4) + bMpe2Flag (Bit 5) + bEncFlag (Bit 6) + bDecFlag (Bit 7) ] or TrafficClass Value (Bits 4-7) + nFlowIdMSB (Bits 8-9).
+    The bits 4-7 of index option is either based upon TC (default) or combination of Processing flags is decided through bProcFlagsEgPMACEna.
+    It is expected to pass the correct value in bProcFlagsSelect same as global bProcFlagsEgPMACEna;
+    Used by \ref GSW_PMAC_EG_CFG_SET and \ref GSW_PMAC_EG_CFG_GET. */
+typedef struct {
+	/** PMAC Interface ID */
+	u8 nPmacId;
+	/**  Destination Port Identifier (0..15) - Part of Table Index (Bits 0-3)*/
+	u8 nDestPortId;
+	/** Traffic Class value [Lower 4 -bits (LSB-0, 1, 2, 3)]. - Part of Table Index Bits 4-7.
+	    This value is considered, only when bProcFlagsSelect is not set */
+	u8 nTrafficClass;
+	/**  MPE-1 Flag value - Part of Table Index Bit 4. Valid only when bProcFlagsSelect is set. */
+	ltq_bool_t bMpe1Flag;
+	/**  MPE-2 Flag value - Part of Table Index Bit 5. Valid only when bProcFlagsSelect is set. */
+	ltq_bool_t bMpe2Flag;
+	/**  Cryptography Decryption Action Flag value - Part of Table Index Bit 6. Valid only, when bProcFlagsSelect is set. */
+	ltq_bool_t bDecFlag;
+	/**  Cryptography Encryption Action Flag value - Part of Table Index Bit 7. Valid only, when bProcFlagsSelect is set. */
+	ltq_bool_t bEncFlag;
+	/**  Flow-ID MSB (2-bits) value -  valid range (0..2). - Part of Table Index Bits 8-9. */
+	u8 nFlowIDMsb;
+	/** Selector for Processing Flags (MPE1, MPE2, DEC & ENC bits). If enabled, then the combination of flags bDecFlag, bEncFlag, bMpe1Flag and  bMpe2Flag are considered as index instead of nTrafficClass. For using these combination flags, turn ON this boolean selector.
+	TC or combination processing flag is decided at global level through bProcFlagsEgPMACEna.
+	It is expected that user always passes correct value based upon bProcFlagsEgMPACEna. If mismatch found with global PMAC mode, SWAPI will return error code.
+
+	    \remarks
+	    In GSWIP-3.1, this is ignored and driver will determine automatically by
+	    reading register.
+	*/
+	ltq_bool_t bProcFlagsSelect;
+	/**  Receive DMA Channel Identifier (0..15) */
+	u8 nRxDmaChanId;
+	/** To remove L2 header & additional bytes (True) or Not (False) */
+	ltq_bool_t bRemL2Hdr;
+	/** No. of bytes to be removed after Layer-2 Header, valid when bRemL2Hdr is set */
+	u8 numBytesRem;
+	/** Packet egressing will have FCS (True) or Not (False) */
+	ltq_bool_t bFcsEna;
+	/** Packet egressing will have PMAC (True) or Not (False) */
+	ltq_bool_t bPmacEna;
+	/** Enable redirection flag. GSWIP-3.1 only.
+	    Overwritten by bRes1DW0Enable and nRes1DW0. */
+	ltq_bool_t bRedirEnable;
+	/** Allow (False) or not allow (True) segmentation during buffer selection.
+	    GSWIP-3.1 only. Overwritten by bResDW1Enable and nResDW1. */
+	ltq_bool_t bBslSegmentDisable;
+	/** Traffic class used for buffer selection. GSWIP-3.1 only.
+	    Overwritten by bResDW1Enable and nResDW1. */
+	u8 nBslTrafficClass;
+	/** If false, nResDW1 is ignored. */
+	ltq_bool_t bResDW1Enable;
+	/** 4-bits Reserved Field in DMA Descriptor - DW1 (bit 7 to 4) - for any future/custom usage. (Valid range : 0-15) */
+	u8 nResDW1;
+	/** If false, nRes1DW0 is ignored. */
+	ltq_bool_t bRes1DW0Enable;
+	/** 3-bits Reserved Field in DMA Descriptor - DW0 (bit 31 to 29) - for any future/custom usage. (Valid range : 0-7) */
+	u8 nRes1DW0;
+	/** If false, nRes2DW0 is ignored. */
+	ltq_bool_t bRes2DW0Enable;
+	/** 2-bits Reserved Field in DMA Descriptor - DW0 (bit 14 to 13) - for any future/custom usage. (Valid range : 0-2) */
+	u8 nRes2DW0;
+	/** Selector for TrafficClass bits. If enabled, then the flags
+	bDecFlag, bEncFlag, bMpe1Flag and  bMpe2Flag are not used instead nTrafficClass parameter is used. For using these flags turn off this boolean */
+	ltq_bool_t bTCEnable;
+} GSW_PMAC_Eg_Cfg_t;
+
+/** \brief PMAC Counters available for specified DMA Channel.
+    Used by \ref GSW_PMAC_COUNT_GET. */
+typedef struct {
+	/** PMAC Interface ID Applicable only for GSWIP 3.1 */
+	u8 nPmacId;
+	/*Applicable only for GSWIP 3.1*/
+	ltq_bool_t  b64BitMode;
+	/**  Transmit DMA Channel Identifier (0..15) for GSWIP3.0  (0..16) for GSWIP3.1 Source PortId for Egress Counters (0..15) for GSWIP3.1 - Index */
+	u8 nTxDmaChanId;
+	/** Ingress Total discarded packets counter (32-bits) */
+	u32 nDiscPktsCount;
+	/** Ingress Total discarded bytes counter (32-bits) */
+	u32 nDiscBytesCount;
+	/** Egress Total TCP/UDP/IP checksum error-ed packets counter (32-bits) */
+	u32 nChkSumErrPktsCount;
+	/** Egress Total TCP/UDP/IP checksum error-ed bytes counter (32-bits) */
+	u32 nChkSumErrBytesCount;
+	/** Total Ingress Packet Count in Applicable only for GSWIP 3.1 (32-bits) */
+	u32 nIngressPktsCount;
+	/** Total Ingress Bytes Count in Applicable only for GSWIP 3.1 (32-bits) */
+	u32 nIngressBytesCount;
+	/** Total Engress Packet Count in Applicable only for GSWIP 3.1 (32-bits) */
+	u32 nEgressPktsCount;
+	/** Total Engress Bytes Count in Applicable only for GSWIP 3.1 (32-bits) */
+	u32 nEgressBytesCount;
+} GSW_PMAC_Cnt_t;
+
+
+
+/** \brief For debugging Purpose only.
+    Used for GSWIP 3.1. */
+typedef struct {
+	/** Table Index to get status of the Table Index only for GSWIP 3.1 */
+	u32 nTableIndex;
+	/** Force table Index In USEonly for GSWIP 3.1 */
+	u8 nForceSet;
+	/** To check dispaly index which are In USE for GSWIP 3.1 */
+	u8 nCheckIndexInUse;
+	/** Vlan Filter or Exvlan BlockID*/
+	u32 nblockid;
+	/** Vlan Filter debugging usage*/
+	u8 nDiscardUntagged;
+	/** Vlan Filter debugging usage*/
+	u8 nDiscardUnMatchedTagged;
+	/** Pmac debugging purpose*/
+	u8 nPmacId;
+	/** Pmac debugging purpose*/
+	u8 nDestPort;
+} GSW_debug_t;
+
+/** \brief For debugging Purpose only.
+    Used for GSWIP 3.1. */
+
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. This parameter specifies for which MAC port the RMON
+	    counter is read. It has to be set by the application before
+	    calling \ref GSW_RMON_PORT_GET. */
+	u16	nPortId;
+	/**Table address selection based on port type
+	  Applicable only for GSWIP 3.1
+	 \ref GSW_RMON_portType_t**/
+	GSW_RMON_portType_t ePortType;
+	/*Applicable only for GSWIP 3.1*/
+	ltq_bool_t  b64BitMode;
+	/*Applicable only for GSWIP 3.1*/
+	u32	nRxExtendedVlanDiscardPkts;
+	/*Applicable only for GSWIP 3.1*/
+	u32	nMtuExceedDiscardPkts;
+	/*Applicable only for GSWIP 3.1*/
+	u32 nTxUnderSizeGoodPkts;
+	/*Applicable only for GSWIP 3.1*/
+	u32 nTxOversizeGoodPkts;
+	/** Receive Packet Count (only packets that are accepted and not discarded). */
+	u32	nRxGoodPkts;
+	/** Receive Unicast Packet Count. */
+	u32	nRxUnicastPkts;
+	/** Receive Broadcast Packet Count. */
+	u32	nRxBroadcastPkts;
+	/** Receive Multicast Packet Count. */
+	u32	nRxMulticastPkts;
+	/** Receive FCS Error Packet Count. */
+	u32	nRxFCSErrorPkts;
+	/** Receive Undersize Good Packet Count. */
+	u32	nRxUnderSizeGoodPkts;
+	/** Receive Oversize Good Packet Count. */
+	u32	nRxOversizeGoodPkts;
+	/** Receive Undersize Error Packet Count. */
+	u32	nRxUnderSizeErrorPkts;
+	/** Receive Good Pause Packet Count. */
+	u32	nRxGoodPausePkts;
+	/** Receive Oversize Error Packet Count. */
+	u32	nRxOversizeErrorPkts;
+	/** Receive Align Error Packet Count. */
+	u32	nRxAlignErrorPkts;
+	/** Filtered Packet Count. */
+	u32	nRxFilteredPkts;
+	/** Receive Size 64 Bytes Packet Count. */
+	u32	nRx64BytePkts;
+	/** Receive Size 65-127 Bytes Packet Count. */
+	u32	nRx127BytePkts;
+	/** Receive Size 128-255 Bytes Packet Count. */
+	u32	nRx255BytePkts;
+	/** Receive Size 256-511 Bytes Packet Count. */
+	u32	nRx511BytePkts;
+	/** Receive Size 512-1023 Bytes Packet Count. */
+	u32	nRx1023BytePkts;
+	/** Receive Size 1024-1522 Bytes (or more, if configured) Packet Count. */
+	u32	nRxMaxBytePkts;
+	/** Overall Transmit Good Packets Count. */
+	u32	nTxGoodPkts;
+	/** Transmit Unicast Packet Count. */
+	u32	nTxUnicastPkts;
+	/** Transmit Broadcast Packet Count. */
+	u32	nTxBroadcastPkts;
+	/** Transmit Multicast Packet Count. */
+	u32	nTxMulticastPkts;
+	/** Transmit Single Collision Count. */
+	u32	nTxSingleCollCount;
+	/** Transmit Multiple Collision Count. */
+	u32	nTxMultCollCount;
+	/** Transmit Late Collision Count. */
+	u32	nTxLateCollCount;
+	/** Transmit Excessive Collision Count. */
+	u32	nTxExcessCollCount;
+	/** Transmit Collision Count. */
+	u32	nTxCollCount;
+	/** Transmit Pause Packet Count. */
+	u32	nTxPauseCount;
+	/** Transmit Size 64 Bytes Packet Count. */
+	u32	nTx64BytePkts;
+	/** Transmit Size 65-127 Bytes Packet Count. */
+	u32	nTx127BytePkts;
+	/** Transmit Size 128-255 Bytes Packet Count. */
+	u32	nTx255BytePkts;
+	/** Transmit Size 256-511 Bytes Packet Count. */
+	u32	nTx511BytePkts;
+	/** Transmit Size 512-1023 Bytes Packet Count. */
+	u32	nTx1023BytePkts;
+	/** Transmit Size 1024-1522 Bytes (or more, if configured) Packet Count. */
+	u32	nTxMaxBytePkts;
+	/** Transmit Drop Packet Count. */
+	u32	nTxDroppedPkts;
+	/** Transmit Dropped Packet Count, based on Congestion Management. */
+	u32	nTxAcmDroppedPkts;
+	/** Receive Dropped Packet Count. */
+	u32	nRxDroppedPkts;
+	/** Receive Good Byte Count (64 bit). */
+	u64	nRxGoodBytes;
+	/** Receive Bad Byte Count (64 bit). */
+	u64	nRxBadBytes;
+	/** Transmit Good Byte Count (64 bit). */
+	u64	nTxGoodBytes;
+} GSW_Debug_RMON_Port_cnt_t;
+
+
+
+
+#if 0
+/** \brief PMAC Egress Counters available for every egress PMAC port.
+    Used by \ref GSW_PMAC_EG_COUNT_GET. */
+typedef struct {
+	/**  Transmitting Port Identifier (0..15) */
+	u8 nTxPortId;
+	/** Total TCP/UDP/IP checksum error-ed packets counter (32-bits) */
+	u32 nChkSumErrPktsCount;
+	/** Total TCP/UDP/IP checksum error-ed bytes counter (32-bits) */
+	u32 nChkSumErrBytesCount;
+} GSW_PMAC_Eg_Cnt_t;
+#endif
+/*@}*/ /* GSW_IOCTL_PMAC */
+
+/** \addtogroup GSW_IOCTL_GSWIP31 */
+/*@{*/
+/** \brief Invalid Value.
+    Used mainly during resource allocation to indicate that resource is not
+    allocated. */
+#define INVALID_HANDLE  (~0)
+
+/** \brief Extended VLAN Filter Type.
+    Used by \ref GSW_EXTENDEDVLAN_filterVLAN_t. */
+typedef enum {
+	/** There is tag and criteria applies. */
+	GSW_EXTENDEDVLAN_FILTER_TYPE_NORMAL = 0,
+	/** There is tag but no criteria. */
+	GSW_EXTENDEDVLAN_FILTER_TYPE_NO_FILTER = 1,
+	/** Default entry if no other rule applies. */
+	GSW_EXTENDEDVLAN_FILTER_TYPE_DEFAULT = 2,
+	/** There is no tag. */
+	GSW_EXTENDEDVLAN_FILTER_TYPE_NO_TAG = 3,
+	/** Block invalid*/
+	GSW_EXTENDEDVLAN_BLOCK_INVALID = 4
+} GSW_ExtendedVlanFilterType_t;
+
+/** \brief Extended VLAN Filter TPID Field.
+    Used by \ref GSW_EXTENDEDVLAN_filterVLAN_t. */
+typedef enum {
+	/** Do not filter. */
+	GSW_EXTENDEDVLAN_FILTER_TPID_NO_FILTER = 0,
+	/** TPID is 0x8100. */
+	GSW_EXTENDEDVLAN_FILTER_TPID_8021Q = 1,
+	/** TPID is global configured value. */
+	GSW_EXTENDEDVLAN_FILTER_TPID_VTETYPE = 2
+} GSW_ExtendedVlanFilterTpid_t;
+
+/** \brief Extended VLAN Filter DEI Field.
+    Used by \ref GSW_EXTENDEDVLAN_filterVLAN_t. */
+typedef enum {
+	/** Do not filter. */
+	GSW_EXTENDEDVLAN_FILTER_DEI_NO_FILTER = 0,
+	/** DEI is 0. */
+	GSW_EXTENDEDVLAN_FILTER_DEI_0 = 1,
+	/** DEI is 1. */
+	GSW_EXTENDEDVLAN_FILTER_DEI_1 = 2
+} GSW_ExtendedVlanFilterDei_t;
+
+/** \brief Extended VLAN Filter EtherType.
+    Used by \ref GSW_EXTENDEDVLAN_filterVLAN_t. */
+typedef enum {
+	/** Do not filter. */
+	GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_NO_FILTER = 0,
+	/** IPoE frame (Ethertyp is 0x0800). */
+	GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_IPOE = 1,
+	/** PPPoE frame (Ethertyp is 0x8863 or 0x8864). */
+	GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_PPPOE = 2,
+	/** ARP frame (Ethertyp is 0x0806). */
+	GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_ARP = 3,
+	/** IPv6 IPoE frame (Ethertyp is 0x86DD). */
+	GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_IPV6IPOE = 4,
+	/** EAPOL (Ethertyp is 0x888E). */
+	GSW_EXTENDEDVLAN_FILTER_ETHERTYPE_EAPOL = 5
+} GSW_ExtendedVlanFilterEthertype_t;
+
+/** \brief Extended VLAN Filter VLAN Tag.
+    Used by \ref GSW_EXTENDEDVLAN_filter_t. */
+typedef struct {
+	/** Filter Type: normal filter, default rule, or no tag */
+	GSW_ExtendedVlanFilterType_t eType;
+	/** Enable priority field filtering. */
+	ltq_bool_t bPriorityEnable;
+	/** Filter priority value if bPriorityEnable is TRUE. */
+	u32 nPriorityVal;
+	/** Enable VID filtering. */
+	ltq_bool_t bVidEnable;
+	/** Filter VID if bVidEnable is TRUE. */
+	u32 nVidVal;
+	/** Mode to filter TPID of VLAN tag. */
+	GSW_ExtendedVlanFilterTpid_t eTpid;
+	/** Mode to filter DEI of VLAN tag. */
+	GSW_ExtendedVlanFilterDei_t eDei;
+} GSW_EXTENDEDVLAN_filterVLAN_t;
+
+/** \brief Extended VLAN Filter.
+    Used by \ref GSW_EXTENDEDVLAN_config_t. */
+typedef struct {
+	/** Filter for outer VLAN tag. */
+	GSW_EXTENDEDVLAN_filterVLAN_t sOuterVlan;
+	/** Filter for inner VLAN tag. */
+	GSW_EXTENDEDVLAN_filterVLAN_t sInnerVlan;
+	/** Filter EtherType. */
+	GSW_ExtendedVlanFilterEthertype_t eEtherType;
+} GSW_EXTENDEDVLAN_filter_t;
+
+/** \brief Extended VLAN Treatment Remove Tag.
+    Used by \ref GSW_EXTENDEDVLAN_treatmentVlan_t. */
+typedef enum {
+	/** Do not remove VLAN tag. */
+	GSW_EXTENDEDVLAN_TREATMENT_NOT_REMOVE_TAG = 0,
+	/** Remove 1 VLAN tag following DA/SA. */
+	GSW_EXTENDEDVLAN_TREATMENT_REMOVE_1_TAG = 1,
+	/** Remove 2 VLAN tag following DA/SA. */
+	GSW_EXTENDEDVLAN_TREATMENT_REMOVE_2_TAG = 2,
+	/** Discard upstream traffic. */
+	GSW_EXTENDEDVLAN_TREATMENT_DISCARD_UPSTREAM = 3,
+} GSW_ExtendedVlanTreatmentRemoveTag_t;
+
+/** \brief Extended VLAN Treatment Set Priority.
+   Used by \ref GSW_EXTENDEDVLAN_treatmentVlan_t. */
+typedef enum {
+	/** Set priority with given value. */
+	GSW_EXTENDEDVLAN_TREATMENT_PRIORITY_VAL = 0,
+	/** Prority value is copied from inner VLAN tag of received packet. */
+	GSW_EXTENDEDVLAN_TREATMENT_INNER_PRORITY = 1,
+	/** Prority value is copied from outer VLAN tag of received packet. */
+	GSW_EXTENDEDVLAN_TREATMENT_OUTER_PRORITY = 2,
+	/** Prority value is derived from DSCP field of received packet. */
+	GSW_EXTENDEDVLAN_TREATMENT_DSCP = 3
+} GSW_ExtendedVlanTreatmentPriority_t;
+
+/** \brief Extended VLAN Treatment Set VID.
+   Used by \ref GSW_EXTENDEDVLAN_treatmentVlan_t. */
+typedef enum {
+	/** Set VID with given value. */
+	GSW_EXTENDEDVLAN_TREATMENT_VID_VAL = 0,
+	/** VID is copied from inner VLAN tag of received packet. */
+	GSW_EXTENDEDVLAN_TREATMENT_INNER_VID = 1,
+	/** VID is copied from outer VLAN tag of received packet. */
+	GSW_EXTENDEDVLAN_TREATMENT_OUTER_VID = 2,
+} GSW_ExtendedVlanTreatmentVid_t;
+
+/** \brief Extended VLAN Treatment Set TPID.
+   Used by \ref GSW_EXTENDEDVLAN_treatmentVlan_t. */
+typedef enum {
+	/** TPID is copied from inner VLAN tag of received packet. */
+	GSW_EXTENDEDVLAN_TREATMENT_INNER_TPID = 0,
+	/** TPID is copied from outer VLAN tag of received packet. */
+	GSW_EXTENDEDVLAN_TREATMENT_OUTER_TPID = 1,
+	/** TPID is global configured value. */
+	GSW_EXTENDEDVLAN_TREATMENT_VTETYPE = 2,
+	/** TPID is 0x8100. */
+	GSW_EXTENDEDVLAN_TREATMENT_8021Q = 3
+} GSW_ExtendedVlanTreatmentTpid_t;
+
+/** \brief Extended VLAN Treatment Set DEI.
+   Used by \ref GSW_EXTENDEDVLAN_treatmentVlan_t. */
+typedef enum {
+	/** DEI (if applicable) is copied from inner VLAN tag of received packet. */
+	GSW_EXTENDEDVLAN_TREATMENT_INNER_DEI = 0,
+	/** DEI (if applicable) is copied from outer VLAN tag of received packet. */
+	GSW_EXTENDEDVLAN_TREATMENT_OUTER_DEI = 1,
+	/** DEI is 0. */
+	GSW_EXTENDEDVLAN_TREATMENT_DEI_0 = 2,
+	/** DEI is 1. */
+	GSW_EXTENDEDVLAN_TREATMENT_DEI_1 = 3
+} GSW_ExtendedVlanTreatmentDei_t;
+
+/** \brief Extended VLAN Treatment VLAN Tag.
+    Used by \ref GSW_EXTENDEDVLAN_treatment_t. */
+typedef struct {
+	/** Select source of priority field of VLAN tag. */
+	GSW_ExtendedVlanTreatmentPriority_t ePriorityMode;
+	/** If \ref GSW_EXTENDEDVLAN_treatmentVlan_t::ePriorityMode is
+	    \ref GSW_EXTENDEDVLAN_TREATMENT_PRIORITY_VAL, use this value for
+	    priority field of VLAN tag. */
+	u32 ePriorityVal;
+	/** Select source of VID field of VLAN tag. */
+	GSW_ExtendedVlanTreatmentVid_t eVidMode;
+	/** If \ref GSW_EXTENDEDVLAN_treatmentVlan_t::eVidMode is
+	    \ref GSW_EXTENDEDVLAN_TREATMENT_VID_VAL, use this value for VID field
+	    of VLAN tag. */
+	u32 eVidVal;
+	/** Select source of TPID field of VLAN tag. */
+	GSW_ExtendedVlanTreatmentTpid_t eTpid;
+	/** Select source of DEI field of VLAN tag. */
+	GSW_ExtendedVlanTreatmentDei_t eDei;
+} GSW_EXTENDEDVLAN_treatmentVlan_t;
+
+/** \brief Extended VLAN Treatment.
+    Used by \ref GSW_EXTENDEDVLAN_config_t. */
+typedef struct {
+	/** Number of VLAN tag(s) to remove. */
+	GSW_ExtendedVlanTreatmentRemoveTag_t eRemoveTag;
+
+	/** Enable outer VLAN tag add/modification. */
+	ltq_bool_t bAddOuterVlan;
+	/** If bAddOuterVlan is TRUE, add or modify outer VLAN tag. */
+	GSW_EXTENDEDVLAN_treatmentVlan_t sOuterVlan;
+
+	/** Enable inner VLAN tag add/modification. */
+	ltq_bool_t bAddInnerVlan;
+	/** If bAddInnerVlan is TRUE, add or modify inner VLAN tag. */
+	GSW_EXTENDEDVLAN_treatmentVlan_t sInnerVlan;
+
+	/** Enable re-assignment of bridge port. */
+	ltq_bool_t bReassignBridgePort;
+	/** If bReassignBridgePort is TRUE, use this value for bridge port. */
+	u32 nNewBridgePortId;
+
+	/** Enable new DSCP. */
+	ltq_bool_t bNewDscpEnable;
+	/** If bNewDscpEnable is TRUE, use this value for DSCP. */
+	u32 nNewDscp;
+
+	/** Enable new traffic class. */
+	ltq_bool_t bNewTrafficClassEnable;
+	/** If bNewTrafficClassEnable is TRUE, use this value for traffic class. */
+	u32 nNewTrafficClass;
+
+	/** Enable new meter. */
+	ltq_bool_t bNewMeterEnable;
+	/** New meter ID.
+
+	    \remarks
+	    Meter should be allocated with \ref GSW_QOS_METER_ALLOC before extended
+	    VLAN treatment is added. If this extended VLAN treatment is deleted,
+	    this meter should be released with \ref GSW_QOS_METER_FREE. */
+	u32 sNewTrafficMeterId;
+
+	/** DSCP to PCP mapping, if
+	    \ref GSW_EXTENDEDVLAN_treatmentVlan_t::ePriorityMode in
+	    \ref GSW_EXTENDEDVLAN_treatment_t::sOuterVlan.ePriorityMode or
+	    \ref GSW_EXTENDEDVLAN_treatment_t::sInnerVlan.ePriorityMode is
+	    \ref GSW_EXTENDEDVLAN_TREATMENT_DSCP.
+
+	    \remarks
+	    The index of array stands for DSCP value. Each byte of the array is 3-bit
+	    PCP value. For implementation, if DSCP2PCP is separate hardware table,
+	    a resource management mechanism should be implemented. Allocation happens
+	    when extended VLAN treatment added, and release happens when the
+	    treatment is deleted. For debug, the DSCP2PCP table can be dumped with
+	    \ref GSW_DSCP2PCP_MAP_GET. */
+	u8 nDscp2PcpMap[64];
+
+	/** Enable loopback. */
+	ltq_bool_t bLoopbackEnable;
+	/** Enable destination/source MAC address swap. */
+	ltq_bool_t bDaSaSwapEnable;
+	/** Enable traffic mirrored to the monitoring port. */
+	ltq_bool_t bMirrorEnable;
+} GSW_EXTENDEDVLAN_treatment_t;
+
+/** \brief Extended VLAN Allocation.
+    Used by \ref GSW_EXTENDEDVLAN_ALLOC and \ref GSW_EXTENDEDVLAN_FREE. */
+typedef struct {
+	/** Total number of extended VLAN entries are requested. Proper value should
+	    be given for \ref GSW_EXTENDEDVLAN_ALLOC. This field is ignored for
+	    \ref GSW_EXTENDEDVLAN_FREE. */
+	u32 nNumberOfEntries;
+
+	/** If \ref GSW_EXTENDEDVLAN_ALLOC is successful, a valid ID will be returned
+	    in this field. Otherwise, \ref INVALID_HANDLE is returned in this field.
+	    For \ref GSW_EXTENDEDVLAN_FREE, this field should be valid ID returned by
+	    \ref GSW_EXTENDEDVLAN_ALLOC. */
+	u32 nExtendedVlanBlockId;
+} GSW_EXTENDEDVLAN_alloc_t;
+
+/** \brief Extended VLAN Configuration.
+    Used by \ref GSW_EXTENDEDVLAN_SET and \ref GSW_EXTENDEDVLAN_GET. */
+typedef struct {
+	/** This should be valid ID returned by \ref GSW_EXTENDEDVLAN_ALLOC.
+	    If it is \ref INVALID_HANDLE, \ref GSW_EXTENDEDVLAN_config_t::nEntryIndex
+	    is absolute index of Extended VLAN entry in hardware for debug purpose,
+	    bypassing any check. */
+	u32 nExtendedVlanBlockId;
+
+	/** Index of entry, ranges between 0 and
+	    \ref GSW_EXTENDEDVLAN_alloc_t::nNumberOfEntries - 1, to
+	    set (\ref GSW_EXTENDEDVLAN_SET) or get (\ref GSW_EXTENDEDVLAN_GET)
+	    Extended VLAN Configuration entry. For debug purpose, this field could be
+	    absolute index of Entended VLAN entry in hardware, when
+	    \ref GSW_EXTENDEDVLAN_config_t::nExtendedVlanBlockId is
+	    \ref INVALID_HANDLE. */
+	u32 nEntryIndex;
+
+	/** Extended VLAN Filter */
+	GSW_EXTENDEDVLAN_filter_t sFilter;
+	/** Extended VLAN Treatment */
+	GSW_EXTENDEDVLAN_treatment_t sTreatment;
+} GSW_EXTENDEDVLAN_config_t;
+
+/** \brief VLAN Filter TCI Mask.
+    Used by \ref GSW_VLANFILTER_config_t */
+typedef enum {
+	GSW_VLAN_FILTER_TCI_MASK_VID = 0,
+	GSW_VLAN_FILTER_TCI_MASK_PCP = 1,
+	GSW_VLAN_FILTER_TCI_MASK_TCI = 2
+} GSW_VlanFilterTciMask_t;
+
+/** \brief VLAN Filter Allocation.
+    Used by \ref GSW_VLANFILTER_ALLOC and \ref GSW_VLANFILTER_FREE. */
+typedef struct {
+	/** Total number of VLAN Filter entries are requested. Proper value should
+	    be given for \ref GSW_VLANFILTER_ALLOC. This field is ignored for
+	    \ref GSW_VLANFILTER_FREE. */
+	u32 nNumberOfEntries;
+
+	/** If \ref GSW_VLANFILTER_ALLOC is successful, a valid ID will be returned
+	    in this field. Otherwise, \ref INVALID_HANDLE is returned in this field.
+	    For \ref GSW_EXTENDEDVLAN_FREE, this field should be valid ID returned by
+	    \ref GSW_VLANFILTER_ALLOC. */
+	u32 nVlanFilterBlockId;
+
+	/** Discard packet without VLAN tag. */
+	ltq_bool_t bDiscardUntagged;
+	/** Discard VLAN tagged packet not matching any filter entry. */
+	ltq_bool_t bDiscardUnmatchedTagged;
+	/** Use default port VLAN ID for VLAN filtering
+
+	    \remarks
+	    This field is not available in Falcon-Mx. */
+	ltq_bool_t bUseDefaultPortVID;
+} GSW_VLANFILTER_alloc_t;
+
+/** \brief VLAN Filter.
+    Used by \ref GSW_VLANFILTER_SET and \ref GSW_VLANFILTER_GET */
+typedef struct {
+	/** This should be valid ID return by \ref GSW_VLANFILTER_ALLOC.
+	    If it is \ref INVALID_HANDLE, \ref GSW_VLANFILTER_config_t::nEntryIndex
+	    is absolute index of VLAN Filter entry in hardware for debug purpose,
+	    bypassing any check. */
+	u32 nVlanFilterBlockId;
+
+	/** Index of entry. ranges between 0 and
+	    \ref GSW_VLANFILTER_alloc_t::nNumberOfEntries - 1, to
+	    set (\ref GSW_VLANFILTER_SET) or get (\ref GSW_VLANFILTER_GET)
+	    VLAN FIlter entry. For debug purpose, this field could be absolute index
+	    of VLAN Filter entry in hardware, when
+	    \ref GSW_VLANFILTER_config_t::nVlanFilterBlockId is
+	    \ref INVALID_HANDLE. */
+	u32 nEntryIndex;
+
+	/** VLAN TCI filter mask mode.
+
+	    \remarks
+	    In GSWIP-3.1, this field of first entry in the block will applies to rest
+	    of entries in the same block. */
+	GSW_VlanFilterTciMask_t eVlanFilterMask;
+
+	/** This is value for VLAN filtering. It depends on
+	    \ref GSW_VLANFILTER_config_t::eVlanFilterMask.
+	    For GSW_VLAN_FILTER_TCI_MASK_VID, this is 12-bit VLAN ID.
+	    For GSW_VLAN_FILTER_TCI_MASK_PCP, this is 3-bit PCP field of VLAN tag.
+	    For GSW_VLAN_FILTER_TCI_MASK_TCI, this is 16-bit TCI of VLAN tag. */
+	u32 nVal;
+	/** Discard packet if match. */
+	ltq_bool_t bDiscardMatched;
+} GSW_VLANFILTER_config_t;
+
+/** \brief CTP Port configuration mask.
+    Used by \ref GSW_CTP_portConfig_t. */
+typedef enum {
+	/** Mask for \ref GSW_CTP_portConfig_t::nBridgePortId */
+	GSW_CTP_PORT_CONFIG_MASK_BRIDGE_PORT_ID = 0x00000001,
+	/** Mask for \ref GSW_CTP_portConfig_t::bForcedTrafficClass and
+	    \ref GSW_CTP_portConfig_t::nDefaultTrafficClass */
+	GSW_CTP_PORT_CONFIG_MASK_FORCE_TRAFFIC_CLASS = 0x00000002,
+	/** Mask for \ref GSW_CTP_portConfig_t::bIngressExtendedVlanEnable and
+	    \ref GSW_CTP_portConfig_t::nIngressExtendedVlanBlockId */
+	GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN = 0x00000004,
+	/** Mask for \ref GSW_CTP_portConfig_t::bIngressExtendedVlanIgmpEnable and
+	    \ref GSW_CTP_portConfig_t::nIngressExtendedVlanBlockIdIgmp */
+	GSW_CTP_PORT_CONFIG_MASK_INGRESS_VLAN_IGMP = 0x00000008,
+	/** Mask for \ref GSW_CTP_portConfig_t::bEgressExtendedVlanEnable and
+	    \ref GSW_CTP_portConfig_t::nEgressExtendedVlanBlockId */
+	GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN = 0x00000010,
+	/** Mask for \ref GSW_CTP_portConfig_t::bEgressExtendedVlanIgmpEnable and
+	    \ref GSW_CTP_portConfig_t::nEgressExtendedVlanBlockIdIgmp */
+	GSW_CTP_PORT_CONFIG_MASK_EGRESS_VLAN_IGMP = 0x00000020,
+	/** Mask for \ref GSW_CTP_portConfig_t::bIngressNto1VlanEnable */
+	GSW_CTP_PORT_CONFIG_MASK_INRESS_NTO1_VLAN = 0x00000040,
+	/** Mask for \ref GSW_CTP_portConfig_t::bEgressNto1VlanEnable */
+	GSW_CTP_PORT_CONFIG_MASK_EGRESS_NTO1_VLAN = 0x00000080,
+	/** Mask for \ref GSW_CTP_portConfig_t::eIngressMarkingMode */
+	GSW_CTP_PORT_CONFIG_INGRESS_MARKING = 0x00000100,
+	/** Mask for \ref GSW_CTP_portConfig_t::eEgressMarkingMode */
+	GSW_CTP_PORT_CONFIG_EGRESS_MARKING = 0x00000200,
+	/** Mask for \ref GSW_CTP_portConfig_t::bEgressMarkingOverrideEnable and
+	    \ref GSW_CTP_portConfig_t::eEgressMarkingModeOverride */
+	GSW_CTP_PORT_CONFIG_EGRESS_MARKING_OVERRIDE = 0x00000400,
+	/** Mask for \ref GSW_CTP_portConfig_t::eEgressRemarkingMode */
+	GSW_CTP_PORT_CONFIG_EGRESS_REMARKING = 0x00000800,
+	/** Mask for \ref GSW_CTP_portConfig_t::bIngressMeteringEnable and
+	    \ref GSW_CTP_portConfig_t::nIngressTrafficMeterId */
+	GSW_CTP_PORT_CONFIG_INGRESS_METER = 0x00001000,
+	/** Mask for \ref GSW_CTP_portConfig_t::bEgressMeteringEnable and
+	    \ref GSW_CTP_portConfig_t::nEgressTrafficMeterId */
+	GSW_CTP_PORT_CONFIG_EGRESS_METER = 0x00002000,
+	/** Mask for \ref GSW_CTP_portConfig_t::bBridgingBypass,
+	    \ref GSW_CTP_portConfig_t::nDestLogicalPortId,
+	    \ref GSW_CTP_portConfig_t::bPmapperEnable,
+	    \ref GSW_CTP_portConfig_t::nDestSubIfIdGroup,
+	    \ref GSW_CTP_portConfig_t::ePmapperMappingMode and
+	    \ref GSW_CTP_portConfig_t::sPmapper */
+	GSW_CTP_PORT_CONFIG_BRIDGING_BYPASS = 0x00004000,
+	/** Mask for \ref GSW_CTP_portConfig_t::nFirstFlowEntryIndex and
+	    \ref GSW_CTP_portConfig_t::nNumberOfFlowEntries */
+	GSW_CTP_PORT_CONFIG_FLOW_ENTRY = 0x00008000,
+	/** Mask for \ref GSW_CTP_portConfig_t::bIngressLoopbackEnable,
+	    \ref GSW_CTP_portConfig_t::bIngressDaSaSwapEnable,
+	    \ref GSW_CTP_portConfig_t::bEgressLoopbackEnable,
+	    \ref GSW_CTP_portConfig_t::bEgressDaSaSwapEnable,
+	    \ref GSW_CTP_portConfig_t::bIngressMirrorEnable and
+	    \ref GSW_CTP_portConfig_t::bEgressMirrorEnable */
+	GSW_CTP_PORT_CONFIG_LOOPBACK_AND_MIRROR = 0x00010000,
+
+	/** Enable all fields */
+	GSW_CTP_PORT_CONFIG_MASK_ALL = 0x7FFFFFFF,
+	/** Bypass any check for debug purpose */
+	GSW_CTP_PORT_CONFIG_MASK_FORCE = 0x80000000
+} GSW_CtpPortConfigMask_t;
+
+/** \brief Color Marking Mode
+    Used by \ref GSW_CTP_portConfig_t. */
+typedef enum {
+	/** mark packets (except critical) to green */
+	GSW_MARKING_ALL_GREEN = 0,
+	/** do not change color and priority */
+	GSW_MARKING_INTERNAL_MARKING = 1,
+	/** DEI mark mode */
+	GSW_MARKING_DEI = 2,
+	/** PCP 8P0D mark mode */
+	GSW_MARKING_PCP_8P0D = 3,
+	/** PCP 7P1D mark mode */
+	GSW_MARKING_PCP_7P1D = 4,
+	/** PCP 6P2D mark mode */
+	GSW_MARKING_PCP_6P2D = 5,
+	/** PCP 5P3D mark mode */
+	GSW_MARKING_PCP_5P3D = 6,
+	/** DSCP AF class */
+	GSW_MARKING_DSCP_AF = 7
+} GSW_ColorMarkingMode_t;
+
+/** \brief Color Remarking Mode
+    Used by \ref GSW_CTP_portConfig_t. */
+typedef enum {
+	/** values from last process stage */
+	GSW_REMARKING_NONE = 0,
+	/** DEI mark mode */
+	GSW_REMARKING_DEI = 2,
+	/** PCP 8P0D mark mode */
+	GSW_REMARKING_PCP_8P0D = 3,
+	/** PCP 7P1D mark mode */
+	GSW_REMARKING_PCP_7P1D = 4,
+	/** PCP 6P2D mark mode */
+	GSW_REMARKING_PCP_6P2D = 5,
+	/** PCP 5P3D mark mode */
+	GSW_REMARKING_PCP_5P3D = 6,
+	/** DSCP AF class */
+	GSW_REMARKING_DSCP_AF = 7
+} GSW_ColorRemarkingMode_t;
+
+/** \brief P-mapper Mapping Mode
+    Used by \ref GSW_CTP_portConfig_t. */
+typedef enum {
+	/** Use PCP for VLAN tagged packets to derive sub interface ID group.
+
+	    \remarks
+	    P-mapper table entry 1-8. */
+	GSW_PMAPPER_MAPPING_PCP = 0,
+	/** Use DSCP for VLAN tagged IP packets to derive sub interface ID group.
+
+	    \remarks
+	    P-mapper table entry 9-72. */
+	GSW_PMAPPER_MAPPING_DSCP = 1
+} GSW_PmapperMappingMode_t;
+
+/** \brief P-mapper Configuration
+    Used by \ref GSW_CTP_portConfig_t. */
+typedef struct {
+	/** Index of P-mapper. */
+	u32 nPmapperId;
+
+	/** Sub interface ID group.
+
+	    \remarks
+	    Entry 0 is for non-IP and non-VLAN tagged packets. Entries 1-8 are PCP
+	    mapping entries for VLAN tagged packets with \ref GSW_PMAPPER_MAPPING_PCP
+	    selected. Entries 9-72 are DSCP mapping entries for IP packets without
+	    VLAN tag or VLAN tagged packets with \ref GSW_PMAPPER_MAPPING_DSCP
+	    selected */
+	u8 nDestSubIfIdGroup[73];
+} GSW_PMAPPER_t;
+
+/** \brief CTP Port Configuration.
+    Used by \ref GSW_CTP_PORT_CONFIG_SET and \ref GSW_CTP_PORT_CONFIG_GET. */
+typedef struct {
+	/** Logical Port Id. The valid range is hardware dependent.
+	    If \ref GSW_CTP_portConfig_t::eMask has
+	    \ref GSW_CtpPortConfigMask_t::GSW_CTP_PORT_CONFIG_MASK_FORCE, this field
+	    is ignored. */
+	u32 nLogicalPortId;
+
+	/** Sub interface ID group. The valid range is hardware/protocol dependent.
+
+	    \remarks
+	    Sub interface ID group is defined for each of \ref GSW_LogicalPortMode_t.
+	    For both \ref GSW_LOGICAL_PORT_8BIT_WLAN and
+	    \ref GSW_LOGICAL_PORT_9BIT_WLAN, this field is VAP.
+	    For \ref GSW_LOGICAL_PORT_GPON, this field is GEM index.
+	    For \ref GSW_LOGICAL_PORT_EPON, this field is stream index.
+	    For \ref GSW_LOGICAL_PORT_GINT, this field is LLID.
+	    For others, this field is 0.
+	    If \ref GSW_CTP_portConfig_t::eMask has
+	    \ref GSW_CtpPortConfigMask_t::GSW_CTP_PORT_CONFIG_MASK_FORCE, this field
+	    is absolute index of CTP in hardware for debug purpose, bypassing
+	    any check. */
+	u32 nSubIfIdGroup;
+
+	/** Mask for updating/retrieving fields. */
+	GSW_CtpPortConfigMask_t eMask;
+
+	/** Ingress Bridge Port ID to which this CTP port is associated for ingress
+	    traffic. */
+	u32 nBridgePortId;
+
+	/** Default traffic class can not be overridden by other rules (except
+	    traffic flow table and special tag) in processing stages. */
+	ltq_bool_t bForcedTrafficClass;
+	/** Default traffic class associated with all ingress traffic from this CTP
+	    Port. */
+	u32 nDefaultTrafficClass;
+
+	/** Enable Extended VLAN processing for ingress non-IGMP traffic. */
+	ltq_bool_t bIngressExtendedVlanEnable;
+	/** Extended VLAN block allocated for ingress non-IGMP traffic. It defines
+	    extended VLAN process for ingress non-IGMP traffic. Valid when
+	    bIngressExtendedVlanEnable is TRUE. */
+	u32 nIngressExtendedVlanBlockId;
+	/** Extended VLAN block size for ingress non-IGMP traffic. This is optional.
+	    If it is 0, the block size of nIngressExtendedVlanBlockId will be used.
+	    Otherwise, this field will be used. */
+	u32 nIngressExtendedVlanBlockSize;
+	/** Enable extended VLAN processing for ingress IGMP traffic. */
+	ltq_bool_t bIngressExtendedVlanIgmpEnable;
+	/** Extended VLAN block allocated for ingress IGMP traffic. It defines
+	    extended VLAN process for ingress IGMP traffic. Valid when
+	    bIngressExtendedVlanIgmpEnable is TRUE. */
+	u32 nIngressExtendedVlanBlockIdIgmp;
+	/** Extended VLAN block size for ingress IGMP traffic. This is optional.
+	    If it is 0, the block size of nIngressExtendedVlanBlockIdIgmp will be
+	    used. Otherwise, this field will be used. */
+	u32 nIngressExtendedVlanBlockSizeIgmp;
+
+	/** Enable extended VLAN processing for egress non-IGMP traffic. */
+	ltq_bool_t bEgressExtendedVlanEnable;
+	/** Extended VLAN block allocated for egress non-IGMP traffic. It defines
+	    extended VLAN process for egress non-IGMP traffic. Valid when
+	    bEgressExtendedVlanEnable is TRUE. */
+	u32 nEgressExtendedVlanBlockId;
+	/** Extended VLAN block size for egress non-IGMP traffic. This is optional.
+	    If it is 0, the block size of nEgressExtendedVlanBlockId will be used.
+	    Otherwise, this field will be used. */
+	u32 nEgressExtendedVlanBlockSize;
+	/** Enable extended VLAN processing for egress IGMP traffic. */
+	ltq_bool_t bEgressExtendedVlanIgmpEnable;
+	/** Extended VLAN block allocated for egress IGMP traffic. It defines
+	    extended VLAN process for egress IGMP traffic. Valid when
+	    bEgressExtendedVlanIgmpEnable is TRUE. */
+	u32 nEgressExtendedVlanBlockIdIgmp;
+	/** Extended VLAN block size for egress IGMP traffic. This is optional.
+	    If it is 0, the block size of nEgressExtendedVlanBlockIdIgmp will be
+	    used. Otherwise, this field will be used. */
+	u32 nEgressExtendedVlanBlockSizeIgmp;
+
+	/** For WLAN type logical port, this should be FALSE. For other types, if
+	     enabled and ingress packet is VLAN tagged, outer VLAN ID is used for
+	    "nSubIfId" field in MAC table, otherwise, 0 is used for "nSubIfId". */
+	ltq_bool_t bIngressNto1VlanEnable;
+	/** For WLAN type logical port, this should be FALSE. For other types, if
+	     enabled and egress packet is known unicast, outer VLAN ID is from
+	     "nSubIfId" field in MAC table. */
+	ltq_bool_t bEgressNto1VlanEnable;
+
+	/** Ingress color marking mode for ingress traffic. */
+	GSW_ColorMarkingMode_t eIngressMarkingMode;
+	/** Egress color marking mode for ingress traffic at egress priority queue
+	    color marking stage */
+	GSW_ColorMarkingMode_t eEgressMarkingMode;
+	/** Egress color marking mode override color marking mode from last stage. */
+	ltq_bool_t bEgressMarkingOverrideEnable;
+	/** Egress color marking mode for egress traffic. Valid only when
+	    bEgressMarkingOverride is TRUE. */
+	GSW_ColorMarkingMode_t eEgressMarkingModeOverride;
+
+	/** Color remarking for egress traffic. */
+	GSW_ColorRemarkingMode_t eEgressRemarkingMode;
+
+	/** Traffic metering on ingress traffic applies. */
+	ltq_bool_t bIngressMeteringEnable;
+	/** Meter for ingress CTP process.
+
+	    \remarks
+	    Meter should be allocated with \ref GSW_QOS_METER_ALLOC before CTP
+	    port configuration. If this CTP port is re-set, the last used meter
+	    should be released. */
+	u32 nIngressTrafficMeterId;
+	/** Traffic metering on egress traffic applies. */
+	ltq_bool_t bEgressMeteringEnable;
+	/** Meter for egress CTP process.
+
+	    \remarks
+	    Meter should be allocated with \ref GSW_QOS_METER_ALLOC before CTP
+	    port configuration. If this CTP port is re-set, the last used meter
+	    should be released. */
+	u32 nEgressTrafficMeterId;
+
+	/** Ingress traffic bypass bridging/multicast processing. Following
+	    parameters are used to determine destination. Traffic flow table is not
+	    bypassed. */
+	ltq_bool_t bBridgingBypass;
+	/** When bBridgingBypass is TRUE, this field defines destination logical
+	    port. */
+	u32 nDestLogicalPortId;
+	/** When bBridgingBypass is TRUE, this field indicates whether to use
+	    \ref GSW_CTP_portConfig_t::nDestSubIfIdGroup or
+	    \ref GSW_CTP_portConfig_t::ePmapperMappingMode/
+	    \ref GSW_CTP_portConfig_t::sPmapper. */
+	ltq_bool_t bPmapperEnable;
+	/** When bBridgingBypass is TRUE and bPmapperEnable is FALSE, this field
+	    defines destination sub interface ID group. */
+	u32 nDestSubIfIdGroup;
+	/** When bBridgingBypass is TRUE and bPmapperEnable is TRUE, this field
+	    selects either DSCP or PCP to derive sub interface ID. */
+	GSW_PmapperMappingMode_t ePmapperMappingMode;
+	/** When bBridgingBypass is TRUE and bPmapperEnable is TRUE, P-mapper is
+	    used. API implementation need take care of P-mapper allocation, and
+	    maintain the reference counter of P-mapper used multiple times. */
+	GSW_PMAPPER_t sPmapper;
+
+	/** First traffic flow table entry is associated to this CTP port. Ingress
+	    traffic from this CTP port will go through traffic flow table search
+	    starting from nFirstFlowEntryIndex. Should be times of 4. */
+	u32 nFirstFlowEntryIndex;
+	/** Number of traffic flow table entries are associated to this CTP port.
+	    Ingress traffic from this CTP port will go through PCE rules search
+	    ending at (nFirstFlowEntryIndex+nNumberOfFlowEntries)-1. Should
+	    be times of 4. */
+	u32 nNumberOfFlowEntries;
+
+	/** Ingress traffic from this CTP port will be redirected to ingress
+	    logical port of this CTP port with source sub interface ID used as
+	    destination sub interface ID. Following processing except traffic
+	    flow table search is bypassed if loopback enabled. */
+	ltq_bool_t bIngressLoopbackEnable;
+	/** Destination/Source MAC address of ingress traffic is swapped before
+	    transmitted (not swapped during PCE processing stages). If destination
+	    is multicast, there is no swap, but source MAC address is replaced
+	    with global configurable value. */
+	ltq_bool_t bIngressDaSaSwapEnable;
+	/** Egress traffic to this CTP port will be redirected to ingress logical
+	    port with same sub interface ID as ingress. */
+	ltq_bool_t bEgressLoopbackEnable;
+	/** Destination/Source MAC address of egress traffic is swapped before
+	    transmitted. */
+	ltq_bool_t bEgressDaSaSwapEnable;
+
+	/** If enabled, ingress traffic is mirrored to the monitoring port.
+
+	    \remarks
+	    This should be used exclusive with bIngressLoopbackEnable. */
+	ltq_bool_t bIngressMirrorEnable;
+	/** If enabled, egress traffic is mirrored to the monitoring port.
+
+	    \remarks
+	    This should be used exclusive with bEgressLoopbackEnable. */
+	ltq_bool_t bEgressMirrorEnable;
+} GSW_CTP_portConfig_t;
+
+/** \brief Bridge Port configuration mask.
+    Used by \ref GSW_BRIDGE_portConfig_t. */
+typedef enum {
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::nBridgeId */
+	GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID = 0x00000001,
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::bIngressExtendedVlanEnable and
+	    \ref GSW_BRIDGE_portConfig_t::nIngressExtendedVlanBlockId */
+	GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_VLAN = 0x00000002,
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::bEgressExtendedVlanEnable and
+	    \ref GSW_BRIDGE_portConfig_t::nEgressExtendedVlanBlockId */
+	GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN = 0x00000004,
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::eIngressMarkingMode */
+	GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_MARKING = 0x00000008,
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::eEgressRemarkingMode */
+	GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_REMARKING = 0x00000010,
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::bIngressMeteringEnable and
+	    \ref GSW_BRIDGE_portConfig_t::nIngressTrafficMeterId */
+	GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_METER = 0x00000020,
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::bEgressSubMeteringEnable and
+	    \ref GSW_BRIDGE_portConfig_t::nEgressTrafficSubMeterId */
+	GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_SUB_METER = 0x00000040,
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::nDestLogicalPortId,
+	    \ref GSW_BRIDGE_portConfig_t::bPmapperEnable,
+	    \ref GSW_BRIDGE_portConfig_t::nDestSubIfIdGroup,
+	    \ref GSW_BRIDGE_portConfig_t::ePmapperMappingMode and
+	    \ref GSW_BRIDGE_portConfig_t::sPmapper. */
+	GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_CTP_MAPPING = 0x00000080,
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::nBridgePortMap */
+	GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP = 0x00000100,
+
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::bMcDestIpLookupEnable. */
+	GSW_BRIDGE_PORT_CONFIG_MASK_MC_DEST_IP_LOOKUP = 0x00000200,
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::bMcSrcIpLookupEnable. */
+	GSW_BRIDGE_PORT_CONFIG_MASK_MC_SRC_IP_LOOKUP = 0x00000400,
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::bDestMacLookupEnable. */
+	GSW_BRIDGE_PORT_CONFIG_MASK_MC_DEST_MAC_LOOKUP = 0x00000800,
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::bSrcMacLearningEnable. */
+	GSW_BRIDGE_PORT_CONFIG_MASK_MC_SRC_MAC_LEARNING = 0x00001000,
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::bMacSpoofingDetectEnable. */
+	GSW_BRIDGE_PORT_CONFIG_MASK_MAC_SPOOFING = 0x00002000,
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::bPortLockEnable. */
+	GSW_BRIDGE_PORT_CONFIG_MASK_PORT_LOCK = 0x00004000,
+
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::bMacLearningLimitEnable and
+	    \ref GSW_BRIDGE_portConfig_t::nMacLearningLimit. */
+	GSW_BRIDGE_PORT_CONFIG_MASK_MAC_LEARNING_LIMIT = 0x00008000,
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::nMacLearningCount */
+	GSW_BRIDGE_PORT_CONFIG_MASK_MAC_LEARNED_COUNT = 0x00010000,
+
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::bIngressVlanFilterEnable and
+	    \ref GSW_BRIDGE_portConfig_t::nIngressVlanFilterBlockId. */
+	GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_VLAN_FILTER = 0x00020000,
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::bBypassEgressVlanFilter1,
+	    \ref GSW_BRIDGE_portConfig_t::bEgressVlanFilter1Enable
+	    and \ref GSW_BRIDGE_portConfig_t::nEgressVlanFilter1BlockId. */
+	GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN_FILTER1 = 0x00040000,
+	/** Mask for \ref GSW_BRIDGE_portConfig_t::bEgressVlanFilter2Enable and
+	    \ref GSW_BRIDGE_portConfig_t::nEgressVlanFilter2BlockId. */
+	GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_VLAN_FILTER2 = 0x00080000,
+
+	/** Enable all */
+	GSW_BRIDGE_PORT_CONFIG_MASK_ALL = 0x7FFFFFFF,
+	/** Bypass any check for debug purpose */
+	GSW_BRIDGE_PORT_CONFIG_MASK_FORCE = 0x80000000
+} GSW_BridgePortConfigMask_t;
+
+/** \brief Meters for various egress traffic type.
+    Used by \ref GSW_BRIDGE_portConfig_t. */
+typedef enum {
+	/** Index of broadcast traffic meter */
+	GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST = 0,
+	/** Index of known multicast traffic meter */
+	GSW_BRIDGE_PORT_EGRESS_METER_MULTICAST = 1,
+	/** Index of unknown multicast IP traffic meter */
+	GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_MC_IP = 2,
+	/** Index of unknown multicast non-IP traffic meter */
+	GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_MC_NON_IP = 3,
+	/** Index of unknown unicast traffic meter */
+	GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_UC = 4,
+	/** Index of traffic meter for other types */
+	GSW_BRIDGE_PORT_EGRESS_METER_OTHERS = 5,
+	/** Number of index */
+	GSW_BRIDGE_PORT_EGRESS_METER_MAX = 6
+} GSW_BridgePortEgressMeter_t;
+
+/** \brief Bridge forwarding type of packet.
+    Used by \ref GSW_BRIDGE_portConfig_t. */
+typedef enum {
+	/** Packet is flooded to port members of ingress bridge port */
+	GSW_BRIDGE_FORWARD_FLOOD = 0,
+	/** Packet is dscarded */
+	GSW_BRIDGE_FORWARD_DISCARD = 1,
+	/** Packet is forwarded to logical port 0 CTP port 0 bridge port 0 */
+	GSW_BRIDGE_FORWARD_CPU = 2
+} GSW_BridgeForwardMode_t;
+
+/** \brief Bridge Port Allocation.
+    Used by \ref GSW_BRIDGE_PORT_ALLOC and \ref GSW_BRIDGE_PORT_FREE. */
+typedef struct {
+	/** If \ref GSW_BRIDGE_PORT_ALLOC is successful, a valid ID will be returned
+	    in this field. Otherwise, \ref INVALID_HANDLE is returned in this field.
+	    For \ref GSW_BRIDGE_PORT_FREE, this field should be valid ID returned by
+	    \ref GSW_BRIDGE_PORT_ALLOC. ID 0 is special for CPU port in Falcon-Mx
+	    by mapping to CTP 0 (Logical Port 0 with Sub-interface ID 0), and
+	    pre-alloced during initialization. */
+	u32 nBridgePortId;
+} GSW_BRIDGE_portAlloc_t;
+
+/** \brief Bridge Port Configuration.
+    Used by \ref GSW_BRIDGE_PORT_CONFIG_SET and \ref GSW_BRIDGE_PORT_CONFIG_GET. */
+typedef struct {
+	/** Bridge Port ID allocated by \ref GSW_BRIDGE_PORT_ALLOC.
+
+	    \remarks
+	    If \ref GSW_BRIDGE_portConfig_t::eMask has
+	    \ref GSW_BridgePortConfigMask_t::GSW_BRIDGE_PORT_CONFIG_MASK_FORCE, this
+	    field is absolute index of Bridge Port in hardware for debug purpose,
+	    bypassing any check. */
+	u32 nBridgePortId;
+
+	/** Mask for updating/retrieving fields. */
+	GSW_BridgePortConfigMask_t eMask;
+
+	/** Bridge ID (FID) to which this bridge port is associated. A default
+	    bridge (ID 0) should be always available. */
+	u32 nBridgeId;
+
+	/** Enable extended VLAN processing for ingress non-IGMP traffic. */
+	ltq_bool_t bIngressExtendedVlanEnable;
+	/** Extended VLAN block allocated for ingress non-IGMP traffic. It defines
+	    extended VLAN process for ingress non-IGMP traffic. Valid when
+	    bIngressExtendedVlanEnable is TRUE. */
+	u32 nIngressExtendedVlanBlockId;
+	/** Extended VLAN block size for ingress non-IGMP traffic. This is optional.
+	    If it is 0, the block size of nIngressExtendedVlanBlockId will be used.
+	    Otherwise, this field will be used. */
+	u32 nIngressExtendedVlanBlockSize;
+
+	/** Enable extended VLAN processing enabled for egress non-IGMP traffic. */
+	ltq_bool_t bEgressExtendedVlanEnable;
+	/** Extended VLAN block allocated for egress non-IGMP traffic. It defines
+	    extended VLAN process for egress non-IGMP traffic. Valid when
+	    bEgressExtendedVlanEnable is TRUE. */
+	u32 nEgressExtendedVlanBlockId;
+	/** Extended VLAN block size for egress non-IGMP traffic. This is optional.
+	    If it is 0, the block size of nEgressExtendedVlanBlockId will be used.
+	    Otherwise, this field will be used. */
+	u32 nEgressExtendedVlanBlockSize;
+
+	/** Ingress color marking mode for ingress traffic. */
+	GSW_ColorMarkingMode_t eIngressMarkingMode;
+
+	/** Color remarking for egress traffic. */
+	GSW_ColorRemarkingMode_t eEgressRemarkingMode;
+
+	/** Traffic metering on ingress traffic applies. */
+	ltq_bool_t bIngressMeteringEnable;
+	/** Meter for ingress Bridge Port process.
+
+	    \remarks
+	    Meter should be allocated with \ref GSW_QOS_METER_ALLOC before Bridge
+	    port configuration. If this Bridge port is re-set, the last used meter
+	    should be released. */
+	u32 nIngressTrafficMeterId;
+
+	/** Traffic metering on various types of egress traffic (such as broadcast,
+	    multicast, unknown unicast, etc) applies. */
+	ltq_bool_t bEgressSubMeteringEnable[GSW_BRIDGE_PORT_EGRESS_METER_MAX];
+	/** Meter for egress Bridge Port process with specific type (such as
+	    broadcast, multicast, unknown unicast, etc). Need pre-allocated for each
+	    type. */
+	u32 nEgressTrafficSubMeterId[GSW_BRIDGE_PORT_EGRESS_METER_MAX];
+
+	/** This field defines destination logical port. */
+	u32 nDestLogicalPortId;
+	/** This field indicates whether to enable P-mapper. */
+	ltq_bool_t bPmapperEnable;
+	/** When bPmapperEnable is FALSE, this field defines destination sub
+	    interface ID group. */
+	u32 nDestSubIfIdGroup;
+	/** When bPmapperEnable is TRUE, this field selects either DSCP or PCP to
+	    derive sub interface ID. */
+	GSW_PmapperMappingMode_t ePmapperMappingMode;
+	/** When bPmapperEnable is TRUE, P-mapper is used. API implementation need
+	    take care of P-mapper allocation, and maintain the reference counter of
+	    P-mapper used multiple times. */
+	GSW_PMAPPER_t sPmapper;
+
+	/** Port map define broadcast domain.
+
+	    \remarks
+	    Each bit is one bridge port. Bridge port ID is index * 16 + bit offset.
+	    For example, bit 1 of nBridgePortMap[1] is bridge port ID 17. */
+	u16 nBridgePortMap[16];
+
+	/** Multicast IP table is searched if this field is FALSE and traffic is IP
+	    multicast. */
+	ltq_bool_t bMcDestIpLookupDisable;
+	/** Multicast IP table is searched if this field is TRUE and traffic is IP
+	    multicast. */
+	ltq_bool_t bMcSrcIpLookupEnable;
+
+	/** Default is FALSE. Packet is treated as "unknown" if it's not
+	    broadcast/multicast packet. */
+	ltq_bool_t bDestMacLookupDisable;
+
+	/** Default is FALSE. Source MAC address is learned. */
+	ltq_bool_t bSrcMacLearningDisable;
+
+	/** If this field is TRUE and MAC address which is already learned in another
+	    bridge port appears on this bridge port, port locking violation is
+	    detected. */
+	ltq_bool_t bMacSpoofingDetectEnable;
+
+	/** If this field is TRUE and MAC address which is already learned in this
+	    bridge port appears on another bridge port, port locking violation is
+	    detected. */
+	ltq_bool_t bPortLockEnable;
+
+	/** Enable MAC learning limitation. */
+	ltq_bool_t bMacLearningLimitEnable;
+	/** Max number of MAC can be learned from this bridge port. */
+	u32 nMacLearningLimit;
+
+	/** Get number of MAC address learned from this bridge port. */
+	u32 nMacLearningCount;
+
+	/** Enable ingress VLAN filter */
+	ltq_bool_t bIngressVlanFilterEnable;
+	/** VLAN filter block of ingress traffic if
+	    \ref GSW_BRIDGE_portConfig_t::bIngressVlanFilterEnable is TRUE. */
+	u32 nIngressVlanFilterBlockId;
+	/** VLAN filter block size. This is optional.
+	    If it is 0, the block size of nIngressVlanFilterBlockId will be used.
+	    Otherwise, this field will be used. */
+	u32 nIngressVlanFilterBlockSize;
+	/** For ingress traffic, bypass VLAN filter 1 at egress bridge port
+	    processing. */
+	ltq_bool_t bBypassEgressVlanFilter1;
+	/** Enable egress VLAN filter 1 */
+	ltq_bool_t bEgressVlanFilter1Enable;
+	/** VLAN filter block 1 of egress traffic if
+	    \ref GSW_BRIDGE_portConfig_t::bEgressVlanFilter1Enable is TRUE. */
+	u32 nEgressVlanFilter1BlockId;
+	/** VLAN filter block 1 size. This is optional.
+	    If it is 0, the block size of nEgressVlanFilter1BlockId will be used.
+	    Otherwise, this field will be used. */
+	u32 nEgressVlanFilter1BlockSize;
+	/** Enable egress VLAN filter 2 */
+	ltq_bool_t bEgressVlanFilter2Enable;
+	/** VLAN filter block 2 of egress traffic if
+	    \ref GSW_BRIDGE_portConfig_t::bEgressVlanFilter2Enable is TRUE. */
+	u32 nEgressVlanFilter2BlockId;
+	/** VLAN filter block 2 size. This is optional.
+	    If it is 0, the block size of nEgressVlanFilter2BlockId will be used.
+	    Otherwise, this field will be used. */
+	u32 nEgressVlanFilter2BlockSize;
+} GSW_BRIDGE_portConfig_t;
+
+/** \brief Bridge configuration mask.
+    Used by \ref GSW_BRIDGE_config_t. */
+typedef enum {
+	/** Mask for \ref GSW_BRIDGE_config_t::bMacLearningLimitEnable
+	    and \ref GSW_BRIDGE_config_t::nMacLearningLimit. */
+	GSW_BRIDGE_CONFIG_MASK_MAC_LEARNING_LIMIT = 0x00000001,
+	/** Mask for \ref GSW_BRIDGE_config_t::nMacLearningCount */
+	GSW_BRIDGE_CONFIG_MASK_MAC_LEARNED_COUNT = 0x00000002,
+	/** Mask for \ref GSW_BRIDGE_config_t::nLearningDiscardEvent */
+	GSW_BRIDGE_CONFIG_MASK_MAC_DISCARD_COUNT = 0x00000004,
+	/** Mask for \ref GSW_BRIDGE_config_t::bSubMeteringEnable and
+	    \ref GSW_BRIDGE_config_t::nTrafficSubMeterId */
+	GSW_BRIDGE_CONFIG_MASK_SUB_METER = 0x00000008,
+	/** Mask for \ref GSW_BRIDGE_config_t::eForwardBroadcast,
+	    \ref GSW_BRIDGE_config_t::eForwardUnknownMulticastIp,
+	    \ref GSW_BRIDGE_config_t::eForwardUnknownMulticastNonIp,
+	    and \ref GSW_BRIDGE_config_t::eForwardUnknownUnicast. */
+	GSW_BRIDGE_CONFIG_MASK_FORWARDING_MODE = 0x00000010,
+
+	/** Enable all */
+	GSW_BRIDGE_CONFIG_MASK_ALL = 0x7FFFFFFF,
+	/** Bypass any check for debug purpose */
+	GSW_BRIDGE_CONFIG_MASK_FORCE = 0x80000000
+} GSW_BridgeConfigMask_t;
+
+/** \brief Bridge Allocation.
+    Used by \ref GSW_BRIDGE_ALLOC and \ref GSW_BRIDGE_FREE. */
+typedef struct {
+	/** If \ref GSW_BRIDGE_ALLOC is successful, a valid ID will be returned
+	    in this field. Otherwise, \ref INVALID_HANDLE is returned in this field.
+	    For \ref GSW_BRIDGE_FREE, this field should be valid ID returned by
+	    \ref GSW_BRIDGE_ALLOC. ID 0 is special Bridge created during
+	    initialization. */
+	u32 nBridgeId;
+} GSW_BRIDGE_alloc_t;
+
+/** \brief Bridge Configuration.
+    Used by \ref GSW_BRIDGE_CONFIG_SET and \ref GSW_BRIDGE_CONFIG_GET. */
+typedef struct {
+	/** Bridge ID (FID) allocated by \ref GSW_BRIDGE_ALLOC.
+
+	    \remarks
+	    If \ref GSW_BRIDGE_config_t::eMask has
+	    \ref GSW_BridgeConfigMask_t::GSW_BRIDGE_CONFIG_MASK_FORCE, this field is
+	    absolute index of Bridge (FID) in hardware for debug purpose, bypassing
+	    any check. */
+	u32 nBridgeId;
+
+	/** Mask for updating/retrieving fields. */
+	GSW_BridgeConfigMask_t eMask;
+
+	/** Enable MAC learning limitation. */
+	ltq_bool_t bMacLearningLimitEnable;
+	/** Max number of MAC can be learned in this bridge (all bridge ports). */
+	u32 nMacLearningLimit;
+
+	/** Get number of MAC address learned from this bridge port. */
+	u32 nMacLearningCount;
+
+	/** Number of learning discard event due to hardware resource not available.
+
+	    \remarks
+	    This is discard event due to either MAC table full or Hash collision.
+	    Discard due to nMacLearningCount reached is not counted in this field. */
+	u32 nLearningDiscardEvent;
+
+	/** Traffic metering on type of traffic (such as broadcast, multicast,
+	    unknown unicast, etc) applies. */
+	ltq_bool_t bSubMeteringEnable[GSW_BRIDGE_PORT_EGRESS_METER_MAX];
+	/** Meter for bridge process with specific type (such as broadcast,
+	    multicast, unknown unicast, etc). Need pre-allocated for each type. */
+	u32 nTrafficSubMeterId[GSW_BRIDGE_PORT_EGRESS_METER_MAX];
+
+	/** Forwarding mode of broadcast traffic. */
+	GSW_BridgeForwardMode_t eForwardBroadcast;
+	/** Forwarding mode of unknown multicast IP traffic. */
+	GSW_BridgeForwardMode_t eForwardUnknownMulticastIp;
+	/** Forwarding mode of unknown multicast non-IP traffic. */
+	GSW_BridgeForwardMode_t eForwardUnknownMulticastNonIp;
+	/** Forwarding mode of unknown unicast traffic. */
+	GSW_BridgeForwardMode_t eForwardUnknownUnicast;
+} GSW_BRIDGE_config_t;
+
+/** \brief Logical port mode.
+    Used by \ref GSW_CTP_portAssignment_t. */
+typedef enum {
+	/** WLAN with 8-bit station ID */
+	GSW_LOGICAL_PORT_8BIT_WLAN = 0,
+	/** WLAN with 9-bit station ID */
+	GSW_LOGICAL_PORT_9BIT_WLAN = 1,
+	/** GPON OMCI context */
+	GSW_LOGICAL_PORT_GPON = 2,
+	/** EPON context */
+	GSW_LOGICAL_PORT_EPON = 3,
+	/** G.INT context */
+	GSW_LOGICAL_PORT_GINT = 4,
+	/** Others (sub interface ID is 0 by default) */
+	GSW_LOGICAL_PORT_OTHER = 0xFF,
+} GSW_LogicalPortMode_t;
+
+/** \brief CTP Port Assignment/association with logical port.
+    Used by \ref GSW_CTP_PORT_ASSIGNMENT_ALLOC, \ref GSW_CTP_PORT_ASSIGNMENT_SET
+    and \ref GSW_CTP_PORT_ASSIGNMENT_GET. */
+typedef struct {
+	/** Logical Port Id. The valid range is hardware dependent. */
+	u32 nLogicalPortId;
+
+	/** First CTP Port ID mapped to above logical port ID.
+
+	    \remarks
+	    For \ref GSW_CTP_PORT_ASSIGNMENT_ALLOC, this is output when CTP
+	    allocation is successful. For other APIs, this is input. */
+	u32 nFirstCtpPortId;
+	/** Total number of CTP Ports mapped above logical port ID. */
+	u32 nNumberOfCtpPort;
+
+	/** Logical port mode to define sub interface ID format. */
+	GSW_LogicalPortMode_t eMode;
+
+	/** Bridge ID (FID)
+
+	    \remarks
+	    For \ref GSW_CTP_PORT_ASSIGNMENT_ALLOC, this is input. Each CTP allocated
+	    is mapped to Bridge Port given by this field. The Bridge Port will be
+	    configured to use first CTP
+	    (\ref GSW_CTP_portAssignment_t::nFirstCtpPortId) as egress CTP.
+	    For other APIs, this is ignored. */
+	u32 nBridgePortId;
+} GSW_CTP_portAssignment_t;
+
+/** \brief Color Marking Table.
+    There are standards to define the marking table. User should use
+    \ref GSW_QOS_COLOR_MARKING_TABLE_SET to initialize the table before color
+    marking happens. \ref GSW_QOS_COLOR_MARKING_TABLE_GET is used to get
+    the marking table, mainly for debug purpose. */
+typedef struct {
+	/** Mode of color marking. */
+	GSW_ColorMarkingMode_t eMode;
+
+	/** If eMode is GSW_REMARKING_DSCP_AF, index stands for 6-bit DSCP value.
+	    If eMode is one of GSW_REMARKING_PCP_8P0D, GSW_REMARKING_PCP_7P1D,
+	    GSW_REMARKING_PCP_6P2D and GSW_REMARKING_PCP_5P3D, index 0-7 is
+	    3-bit PCP value with DEI is 0, and index 8-15 is 3-bit PCP value with
+	    DEI is 1. Ignored in other modes. */
+	u8 nPriority[64];
+	/** If eMode is GSW_REMARKING_DSCP_AF, index stands for 6-bit DSCP value.
+	    If eMode is one of GSW_REMARKING_PCP_8P0D, GSW_REMARKING_PCP_7P1D,
+	    GSW_REMARKING_PCP_6P2D and GSW_REMARKING_PCP_5P3D, index 0-7 is 3-bit
+	    PCP value with DEI is 0, and index 8-15 is 3-bit PCP value with DEI is 1.
+	    Ignored in other modes. */
+	GSW_QoS_DropPrecedence_t nColor[64];
+} GSW_QoS_colorMarkingEntry_t;
+
+/** \brief Color Remarking Table.
+    There are standards to define the remarking table. User should use
+    \ref GSW_QOS_COLOR_REMARKING_TABLE_SET to initialize the table before color
+    remarking happens. \ref GSW_QOS_COLOR_REMARKING_TABLE_GET is used to get
+    the remarking table, mainly for debug purpose. */
+typedef struct {
+	/** Mode of color remarking. */
+	GSW_ColorRemarkingMode_t eMode;
+
+	/** Index stands for color and priority. Index 0-7 is green color with
+	    priority (traffic class) 0-7. Index 8-15 is yellow color with priority
+	    (traffic class) 0-7. Value is DSCP if eMode is GSW_REMARKING_DSCP_AF.
+	    Value bit 0 is DEI and bit 1-3 is PCP if eMode is one of
+	    GSW_REMARKING_PCP_8P0D, GSW_REMARKING_PCP_7P1D, GSW_REMARKING_PCP_6P2D
+	    and GSW_REMARKING_PCP_5P3D. Value is ignored for other mode. */
+	u8 nVal[16];
+} GSW_QoS_colorRemarkingEntry_t;
+
+/** \brief DSCP to PCP Mapping.
+    Used by \ref GSW_DSCP2PCP_MAP_GET. */
+typedef struct {
+	/** Index of entry in mapping table. */
+	u32 nIndex;
+
+	/** The index of array stands for DSCP value. Each byte of the array is 3-bit
+	    PCP value. */
+	u8 nMap[64];
+} GSW_DSCP2PCP_map_t;
+
+/** \brief MAC Address Filter Type.
+    Used by \ref GSW_MACFILTER_default_t */
+typedef enum {
+	/** Source MAC Address Filter */
+	GSW_MACFILTERTYPE_SRC = 0,
+	/** Destination MAC Address Filter */
+	GSW_MACFILTERTYPE_DEST = 1
+} GSW_MacFilterType_t;
+
+/** \brief Default MAC Address Filter.
+    Used by \ref GSW_DEFAUL_MAC_FILTER_SET and \ref GSW_DEFAUL_MAC_FILTER_GET */
+typedef struct {
+	/** MAC Filter Type */
+	GSW_MacFilterType_t eType;
+
+	/** Destination bridge port map. For GSWIP-3.1 only.
+
+	    \remarks
+	    Each bit stands for 1 bridge port. For Falcon-Mx (GSWIP-3.1 integrated),
+	    only index 0-7 is valid. */
+	u16 nPortmap[16];
+} GSW_MACFILTER_default_t;
+/*@}*/ /* GSW_IOCTL_GSWIP31 */
+
+/* -------------------------------------------------------------------------- */
+/*                        IOCTL Command Definitions                           */
+/* -------------------------------------------------------------------------- */
+
+/** \addtogroup GSW_IOCTL_BRIDGE */
+/*@{*/
+
+/**
+   \brief Read an entry of the MAC table.
+   If the parameter 'bInitial=TRUE', the GET operation starts at the beginning
+   of the table. Otherwise it continues the GET operation at the entry that
+   follows the previous access.
+   The function sets all fields to zero in case the end of the table is reached.
+   In order to read out the complete table, this function can be called in a loop.
+   The Switch API sets 'bLast=1' when the last entry is read out.
+   This 'bLast' parameter could be the loop exit criteria.
+
+   \param GSW_MAC_tableRead_t Pointer to a MAC table entry
+   \ref GSW_MAC_tableRead_t structure that is filled out by the switch driver.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MAC_TABLE_ENTRY_READ	_IOWR(GSW_MAC_MAGIC, 0x03, GSW_MAC_tableRead_t)
+
+/**
+   \brief Search the MAC Address table for a specific address entry.
+   A MAC address is provided by the application and Switch API
+   performs a search operation on the hardware's MAC address table.
+   Many hardware platforms provide an optimized and fast address search algorithm.
+
+   \param GSW_MAC_tableQuery_t Pointer to a MAC table entry
+   \ref GSW_MAC_tableQuery_t structure that is filled out by the switch
+   implementation.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MAC_TABLE_ENTRY_QUERY	_IOWR(GSW_MAC_MAGIC, 0x04, GSW_MAC_tableQuery_t)
+
+/**
+   \brief Add a MAC table entry. If an entry already exists for the given MAC Address
+   in Filtering Database, this entry is overwritten. If not,
+   a new entry is added.
+
+   \param GSW_MAC_tableAdd_t Pointer to a MAC table entry
+   \ref GSW_MAC_tableAdd_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MAC_TABLE_ENTRY_ADD	_IOW(GSW_MAC_MAGIC, 0x02, GSW_MAC_tableAdd_t)
+
+/**
+   \brief Remove a single MAC entry from the MAC table.
+
+   \param GSW_MAC_tableRemove_t Pointer to a MAC table entry
+   \ref GSW_MAC_tableRemove_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MAC_TABLE_ENTRY_REMOVE	_IOW(GSW_MAC_MAGIC, 0x05, GSW_MAC_tableRemove_t)
+
+/**
+   \brief Remove all MAC entries from the MAC table.
+
+   \param void This command does not require any parameter structure
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MAC_TABLE_CLEAR	_IO(GSW_MAC_MAGIC, 0x01)
+
+/**
+   \brief Configure the Spanning Tree Protocol state of an Ethernet port.
+   The switch supports four Spanning Tree Port states (Disable/Discarding,
+   Blocking/Listening, Learning and Forwarding state) for every port, to enable
+   the Spanning Tree Protocol function when co-operating with software on
+   the CPU port.
+   Identified Spanning Tree Protocol packets can be redirected to the CPU port.
+   Depending on the hardware implementation, the CPU port assignment is fixed
+   or can be configured using \ref GSW_CPU_PORT_CFG_SET.
+   The current port state can be read back
+   using \ref GSW_STP_PORT_CFG_GET.
+
+   \param GSW_STP_portCfg_t Pointer to \ref GSW_STP_portCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_STP_PORT_CFG_SET	_IOW(GSW_STP_MAGIC, 0x04, GSW_STP_portCfg_t)
+
+/**
+   \brief Read out the current Spanning Tree Protocol state of an Ethernet port.
+   This configuration can be set using \ref GSW_STP_PORT_CFG_SET.
+
+   \param GSW_STP_portCfg_t Pointer to \ref GSW_STP_portCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_STP_PORT_CFG_GET	_IOWR(GSW_STP_MAGIC, 0x03, GSW_STP_portCfg_t)
+
+/**
+   \brief Set the Spanning Tree configuration. This configuration includes the
+   filtering of detected spanning tree packets. These packets could be
+   redirected to one dedicated port (e.g. CPU port) or they could be discarded.
+   The current configuration can be read using \ref GSW_STP_BPDU_RULE_GET.
+
+   \param GSW_STP_BPDU_Rule_t Pointer to \ref GSW_STP_BPDU_Rule_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_STP_BPDU_RULE_SET	_IOW(GSW_STP_MAGIC, 0x02, GSW_STP_BPDU_Rule_t)
+
+/**
+   \brief Read the Spanning Tree configuration.
+   The configuration can be modified using \ref GSW_STP_BPDU_RULE_SET.
+
+   \param GSW_STP_BPDU_Rule_t Pointer to \ref GSW_STP_BPDU_Rule_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_STP_BPDU_RULE_GET	_IOWR(GSW_STP_MAGIC, 0x01, GSW_STP_BPDU_Rule_t)
+
+/**
+   \brief Read the IEEE 802.1x filter configuration.
+   The parameters can be modified using \ref GSW_8021X_EAPOL_RULE_SET.
+
+   \param GSW_8021X_EAPOL_Rule_t Pointer to \ref GSW_8021X_EAPOL_Rule_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_8021X_EAPOL_RULE_GET	_IOWR(GSW_EAPOL_MAGIC, 0x01, GSW_8021X_EAPOL_Rule_t)
+
+/**
+   \brief Set the IEEE 802.1x filter rule for a dedicated port. Filtered packets can be
+   redirected to one dedicated port (e.g. CPU port).
+   The switch supports the addition of a specific packet header to the filtered packets
+   that contains information like source port, priority and so on.
+   The parameters can be read using \ref GSW_8021X_EAPOL_RULE_GET.
+
+   \param GSW_8021X_EAPOL_Rule_t Pointer to \ref GSW_8021X_EAPOL_Rule_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_8021X_EAPOL_RULE_SET	_IOW(GSW_EAPOL_MAGIC, 0x02, GSW_8021X_EAPOL_Rule_t)
+
+/**
+   \brief Get the 802.1x port status for a switch port.
+   A configuration can be set using \ref GSW_8021X_PORT_CFG_SET
+
+   \param GSW_8021X_portCfg_t Pointer to a
+      802.1x port authorized state port
+      configuration \ref GSW_8021X_portCfg_t
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_8021X_PORT_CFG_GET	_IOWR(GSW_EAPOL_MAGIC, 0x03, GSW_8021X_portCfg_t)
+
+/**
+   \brief Set the 802.1x port status for a switch port.
+   The port configuration can be read using \ref GSW_8021X_PORT_CFG_GET.
+
+   \param GSW_8021X_portCfg_t Pointer to a
+      802.1x port authorized state port
+      configuration \ref GSW_8021X_portCfg_t
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_8021X_PORT_CFG_SET	_IOW(GSW_EAPOL_MAGIC, 0x04, GSW_8021X_portCfg_t)
+
+/**
+   \brief Read out the current port trunking algorithm that is used to retrieved if
+   a packet is sent on the lower or higher trunking port index number. The algorithm
+   performs an hash calculation over the MAC- and IP- addresses using the
+   source- and destination- fields. This command retrieve which of the
+   mentioned fields is used by the hash algorithm.
+   The usage of any field could be configured over
+   the \ref GSW_TRUNKING_CFG_SET command.
+
+   \param GSW_trunkingCfg_t Pointer to a
+      configuration \ref GSW_trunkingCfg_t
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_TRUNKING_CFG_GET	_IOWR(GSW_TRUNKING_MAGIC, 0x01, GSW_trunkingCfg_t)
+/**
+   \brief Configure the current port trunking algorithm that is used to retrieved if
+   a packet is sent on the lower or higher trunking port index number. The algorithm
+   performs an hash calculation over the MAC- and IP- addresses using the
+   source- and destination- fields. This command retrieve which of the
+   mentioned fields is used by the hash algorithm.
+   The usage of any field could be configured over
+   the \ref GSW_TRUNKING_CFG_SET command.
+
+   \param GSW_trunkingCfg_t Pointer to a
+      configuration \ref GSW_trunkingCfg_t
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_TRUNKING_CFG_SET	_IOW(GSW_TRUNKING_MAGIC, 0x02, GSW_trunkingCfg_t)
+/**
+   \brief Read out the port trunking state of a given physical Ethernet switch port 'nPortId'.
+   Switch API sets the boolean flag 'bAggregateEnable' and the aggregated trunking
+   port 'nAggrPortId' in case trunking is enabled on the port.
+
+   Port trunking can be configures by using the command \ref GSW_TRUNKING_PORT_CFG_GET.
+
+   \param GSW_trunkingPortCfg_t Pointer to a
+      configuration \ref GSW_trunkingPortCfg_t
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_TRUNKING_PORT_CFG_GET	_IOWR(GSW_TRUNKING_MAGIC, 0x03, GSW_trunkingPortCfg_t)
+/**
+   \brief Configure the port trunking on two physical Ethernet switch ports.
+   A new port trunking group of two groups could be placed or removed.
+   The two port index number are given with the parameter 'nPortId' and 'nAggrPortId'.
+
+   The current trunking port state can be read out by using the command \ref GSW_TRUNKING_PORT_CFG_GET.
+
+   \param GSW_trunkingPortCfg_t Pointer to a
+      configuration \ref GSW_trunkingPortCfg_t
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_TRUNKING_PORT_CFG_SET	_IOW(GSW_TRUNKING_MAGIC, 0x04, GSW_trunkingPortCfg_t)
+/*@}*/ /* GSW_IOCTL_BRIDGE */
+
+/** \addtogroup GSW_IOCTL_VLAN */
+/*@{*/
+
+/**
+   \brief Add VLAN ID to a reserved VLAN list.
+   The switch supports replacing the VID of received packets with the PVID of
+   the receiving port. This function adds a VID to the list of VIDs to replace.
+   All switch devices support adding VID=0, VID=1 and VID=FFF to be replaced.
+   Some devices also allow adding other VIDs to be replaced.
+   An added VID could be removed again by
+   calling \ref GSW_VLAN_RESERVED_REMOVE.
+   This configuration applies to the whole switch device.
+
+   \param GSW_VLAN_reserved_t Pointer to
+      an \ref GSW_VLAN_reserved_t structure element.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_VLAN_RESERVED_ADD	_IOW(GSW_VLAN_MAGIC, 0x0A, GSW_VLAN_reserved_t)
+/**
+   \brief Remove VLAN ID from a reserved VLAN group list.
+   This function removes a VID replacement configuration from the switch
+   hardware. This replacement configuration replaces the VID of received
+   packets with the PVID of the receiving port. This configuration can be
+   added using \ref GSW_VLAN_RESERVED_ADD.
+   This configuration applies to the whole switch device.
+
+   \param GSW_VLAN_reserved_t Pointer to
+      an \ref GSW_VLAN_reserved_t structure element.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_VLAN_RESERVED_REMOVE	_IOW(GSW_VLAN_MAGIC, 0x0B, GSW_VLAN_reserved_t)
+
+/**
+   \brief Get VLAN Port Configuration.
+   This function returns the VLAN configuration of the given Port 'nPortId'.
+
+   \param GSW_VLAN_portCfg_t Pointer to an
+      \ref GSW_VLAN_portCfg_t structure element. Based on the parameter
+      'nPortId', the switch API implementation fills out the remaining structure
+      elements.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_VLAN_PORT_CFG_GET	_IOWR(GSW_VLAN_MAGIC, 0x05, GSW_VLAN_portCfg_t)
+
+/**
+   \brief Set VLAN Port Configuration.
+   This function sets the VLAN configuration of the given Port 'nPortId'.
+
+   \param GSW_VLAN_portCfg_t Pointer to an \ref GSW_VLAN_portCfg_t
+      structure element.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_VLAN_PORT_CFG_SET	_IOW(GSW_VLAN_MAGIC, 0x06, GSW_VLAN_portCfg_t)
+/**
+   \brief Add a VLAN ID group to the active VLAN set of the
+   Ethernet switch hardware.
+   Based on this configuration, VLAN group port members can
+   be added using \ref GSW_VLAN_PORT_MEMBER_ADD.
+   The VLAN ID configuration can be removed again by
+   calling \ref GSW_VLAN_ID_DELETE.
+
+   \param GSW_VLAN_IdCreate_t Pointer to
+      an \ref GSW_VLAN_IdCreate_t structure element.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_VLAN_ID_CREATE	_IOW(GSW_VLAN_MAGIC, 0x02, GSW_VLAN_IdCreate_t)
+/**
+   \brief Remove a VLAN ID group from the active VLAN set of the switch
+   hardware. The VLAN ID group was set
+   using \ref GSW_VLAN_ID_CREATE. A VLAN ID group can only be
+   removed when no port group members are currently configured on the hardware.
+   This VLAN ID group membership configuration is done
+   using \ref GSW_VLAN_PORT_MEMBER_ADD and can be
+   removed again using \ref GSW_VLAN_PORT_MEMBER_REMOVE.
+
+   \param GSW_VLAN_IdDelete_t Pointer to an
+          \ref GSW_VLAN_IdDelete_t structure element.
+
+   \remarks A VLAN ID can only be removed in case it was created by
+         \ref GSW_VLAN_ID_CREATE and is currently not assigned
+         to any Ethernet port (done using \ref GSW_VLAN_PORT_MEMBER_ADD).
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_VLAN_ID_DELETE	_IOW(GSW_VLAN_MAGIC, 0x03, GSW_VLAN_IdDelete_t)
+/**
+   \brief Add Ethernet port to port members of a given CTAG VLAN group.
+   The assignment can be removed using \ref GSW_VLAN_PORT_MEMBER_REMOVE.
+
+   \param GSW_VLAN_portMemberAdd_t Pointer to
+      an \ref GSW_VLAN_portMemberAdd_t structure element.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_VLAN_PORT_MEMBER_ADD	_IOW(GSW_VLAN_MAGIC, 0x07, GSW_VLAN_portMemberAdd_t)
+/**
+   \brief Remove Ethernet port from port members of a given CTAG VLAN group.
+   This assignment was done using \ref GSW_VLAN_PORT_MEMBER_ADD.
+
+   \param GSW_VLAN_portMemberRemove_t Pointer to
+      an \ref GSW_VLAN_portMemberRemove_t structure element.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_VLAN_PORT_MEMBER_REMOVE          _IOW(GSW_VLAN_MAGIC, 0x09, GSW_VLAN_portMemberRemove_t)
+/**
+   \brief Read out all given CTAG VLAN group port memberships. Every command call
+   returns one VLAN and port membership pair with the corresponding
+   egress traffic tag behavior. Call the command in a loop till
+   Switch API sets the 'bLast' variable to read all VLAN port memberships.
+   Please set the 'bInitial' parameter for the first call starting the
+   read operation at the beginning of the VLAN table.
+
+   \param GSW_VLAN_portMemberRead_t Pointer to
+      an \ref GSW_VLAN_portMemberRead_t structure element.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_VLAN_PORT_MEMBER_READ	_IOWR(GSW_VLAN_MAGIC, 0x08, GSW_VLAN_portMemberRead_t)
+/**
+   \brief Read out the FID of a given CTAG VLAN ID.
+   This VLAN ID can be added using \ref GSW_VLAN_ID_CREATE.
+   This function returns an error in case no valid configuration is
+   available for the given VLAN ID.
+
+   \param GSW_VLAN_IdGet_t Pointer to \ref GSW_VLAN_IdGet_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_VLAN_ID_GET	_IOWR(GSW_VLAN_MAGIC, 0x04, GSW_VLAN_IdGet_t)
+/**
+   \brief This function initializes the VLAN membership and the egress tagged
+   portmap of all unconfigured VLAN groups. A VLAN group is defined as
+   unconfigured in case it is not configured
+   through \ref GSW_VLAN_ID_CREATE.
+
+   \param GSW_VLAN_memberInit_t Pointer to \ref GSW_VLAN_memberInit_t.
+
+   \remarks
+   This API is only supported in case the device support 4k VLAN entries
+   (capability retrieved by \ref GSW_CAP_GET).
+   Devices with a smaller VLAN group table do not support this API,
+   because that table does not contain unconfigured entries.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_VLAN_MEMBER_INIT	_IOW(GSW_VLAN_MAGIC, 0x01, GSW_VLAN_memberInit_t)
+/**
+   \brief Get The current STAG VLAN global device configuration.
+   The configuration can be modified by \ref GSW_SVLAN_CFG_SET.
+
+   \param GSW_SVLAN_cfg_t Pointer to an \ref GSW_SVLAN_cfg_t
+      structure element.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_SVLAN_CFG_GET	 _IOWR(GSW_VLAN_MAGIC, 0x10, GSW_SVLAN_cfg_t)
+/**
+   \brief Set STAG VLAN global device configuration.
+   The current configuration can be retrieved by \ref GSW_SVLAN_CFG_GET.
+
+   \param GSW_SVLAN_cfg_t Pointer to an \ref GSW_SVLAN_cfg_t
+      structure element.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_SVLAN_CFG_SET	_IOW(GSW_VLAN_MAGIC, 0x11, GSW_SVLAN_cfg_t)
+/**
+   \brief Get STAG VLAN Port Configuration.
+   This function returns the STAG VLAN configuration of the given Port 'nPortId'.
+
+   \param GSW_SVLAN_portCfg_t Pointer to an
+      \ref GSW_SVLAN_portCfg_t structure element. Based on the parameter
+      'nPortId', the switch API implementation fills out the remaining structure
+      elements.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_SVLAN_PORT_CFG_GET	_IOWR(GSW_VLAN_MAGIC, 0x12, GSW_SVLAN_portCfg_t)
+/**
+   \brief Set STAG VLAN Port Configuration.
+   This function sets the STAG VLAN configuration of the given Port 'nPortId'.
+
+   \param GSW_SVLAN_portCfg_t Pointer to an \ref GSW_SVLAN_portCfg_t
+      structure element.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_SVLAN_PORT_CFG_SET	_IOW(GSW_VLAN_MAGIC, 0x13, GSW_SVLAN_portCfg_t)
+/**
+   \brief This command writes Egress VLAN Treatment settings of PCE for given egress Port.
+   The egress VLAN Config can be read using the command \ref GSW_PCE_EG_VLAN_CFG_GET.
+
+   \param GSW_PCE_EgVLAN_Cfg_t Pointer to \ref GSW_PCE_EgVLAN_Cfg_t.
+
+   \remarks The function returns an error code in case of overlapping VLAN Block configuration.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_SUCCESS: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PCE_EG_VLAN_CFG_SET	_IOW(GSW_VLAN_MAGIC, 0x0C, GSW_PCE_EgVLAN_Cfg_t)
+
+/**
+   \brief This command reads Egress VLAN Treatment settings of PCE for given egress Port.
+   An entry can be written using the command \ref GSW_PCE_EG_VLAN_CFG_SET.
+
+   \param GSW_PCE_EgVLAN_Cfg_t Pointer to \ref GSW_PCE_EgVLAN_Cfg_t.
+
+   \remarks The function returns an error code in case of overlapping VLAN Block configuration.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_SUCCESS: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PCE_EG_VLAN_CFG_GET	_IOWR(GSW_VLAN_MAGIC, 0x0D, GSW_PCE_EgVLAN_Cfg_t)
+
+/**
+   \brief This command writes Egress VLAN Treatment entry of PCE for given index (corresponding to FID or SubInterfaceIdGroup (Bits 12-to-8)).
+   The egress VLAN Entry can be read using the command \ref GSW_PCE_EG_VLAN_ENTRY_READ.
+
+   \param GSW_PCE_EgVLAN_Entry_t Pointer to \ref GSW_PCE_EgVLAN_Entry_t.
+
+   \remarks The function returns an error code in case of out of range VLAN Entries configuration.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_SUCCESS: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PCE_EG_VLAN_ENTRY_WRITE	_IOW(GSW_VLAN_MAGIC, 0x0E, GSW_PCE_EgVLAN_Entry_t)
+
+/**
+   \brief This command reads Egress VLAN Treatment entry of PCE for given index (corresponding to FID or SubInterfaceIdGroup (Bits 12-to-8)).
+   The egress VLAN Entry can be written using the command \ref GSW_PCE_EG_VLAN_ENTRY_WRITE.
+
+   \param GSW_PCE_EgVLAN_Entry_t Pointer to \ref GSW_PCE_EgVLAN_Entry_t.
+
+   \remarks The function returns an error code in case of out of range VLAN Entries configuration.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_SUCCESS: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PCE_EG_VLAN_ENTRY_READ	_IOWR(GSW_VLAN_MAGIC, 0x0F, GSW_PCE_EgVLAN_Entry_t)
+
+/*@}*/ /* GSW_IOCTL_VLAN */
+
+/** \addtogroup GSW_IOCTL_QOS */
+/*@{*/
+
+/**
+   \brief Configures the Ethernet port based traffic class assignment of ingress packets.
+   It is used to identify the packet priority and the related egress
+   priority queue. For DSCP, the priority to queue assignment is done
+   using \ref GSW_QOS_DSCP_CLASS_SET.
+   For VLAN, the priority to queue assignment is done
+   using \ref GSW_QOS_PCP_CLASS_SET. The current port configuration can be
+   read using \ref GSW_QOS_PORT_CFG_GET.
+
+   \param GSW_QoS_portCfg_t Pointer to a
+      QOS port priority control configuration \ref GSW_QoS_portCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_PORT_CFG_SET	_IOW(GSW_QOS_MAGIC, 0x13, GSW_QoS_portCfg_t)
+
+/**
+   \brief Read out the current Ethernet port traffic class of ingress packets.
+   It is used to identify the packet priority and the related egress
+   priority queue. The port configuration can be set
+   using \ref GSW_QOS_PORT_CFG_SET.
+
+   \param GSW_QoS_portCfg_t Pointer to a
+      QOS port priority control configuration \ref GSW_QoS_portCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_PORT_CFG_GET	_IOWR(GSW_QOS_MAGIC, 0x12, GSW_QoS_portCfg_t)
+
+/**
+   \brief Initialize the QoS 64 DSCP mapping to the switch priority queues.
+   This configuration applies for the whole switch device. The table
+   configuration can be read using \ref GSW_QOS_DSCP_CLASS_GET.
+
+   \param GSW_QoS_DSCP_ClassCfg_t Pointer to the QoS filter parameters
+   \ref GSW_QoS_DSCP_ClassCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_DSCP_CLASS_SET	_IOW(GSW_QOS_MAGIC, 0x07, GSW_QoS_DSCP_ClassCfg_t)
+
+/**
+   \brief Read out the QoS 64 DSCP mapping to the switch priority queues.
+   The table configuration can be set using \ref GSW_QOS_DSCP_CLASS_SET.
+
+   \param GSW_QoS_DSCP_ClassCfg_t Pointer to the QoS filter parameters
+   \ref GSW_QoS_DSCP_ClassCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_DSCP_CLASS_GET	_IOWR(GSW_QOS_MAGIC, 0x06, GSW_QoS_DSCP_ClassCfg_t)
+
+/**
+   \brief Configure the incoming PCP to traffic class mapping table.
+   This configuration applies to the entire switch device.
+   The table configuration can be read using \ref GSW_QOS_PCP_CLASS_GET.
+
+   \param GSW_QoS_PCP_ClassCfg_t Pointer to the QoS filter parameters
+   \ref GSW_QoS_PCP_ClassCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_PCP_CLASS_SET	_IOW(GSW_QOS_MAGIC, 0x11, GSW_QoS_PCP_ClassCfg_t)
+
+/**
+   \brief Read out the incoming PCP to traffic class mapping table.
+   The table configuration can be set using \ref GSW_QOS_PCP_CLASS_SET.
+
+   \param GSW_QoS_PCP_ClassCfg_t Pointer to the QoS filter parameters
+   \ref GSW_QoS_PCP_ClassCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_PCP_CLASS_GET	_IOWR(GSW_QOS_MAGIC, 0x10, GSW_QoS_PCP_ClassCfg_t)
+
+/**
+   \brief Configures the DSCP to Drop Precedence assignment mapping table.
+   This mapping table is used to identify the switch internally used drop
+   precedence based on the DSCP value of the incoming packet.
+   The current mapping table configuration can be read
+   using \ref GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_GET.
+
+   \param GSW_QoS_DSCP_DropPrecedenceCfg_t Pointer to the QoS
+   DSCP drop precedence parameters
+   \ref GSW_QoS_DSCP_DropPrecedenceCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_SET _IOW(GSW_QOS_MAGIC, 0x0B, GSW_QoS_DSCP_DropPrecedenceCfg_t)
+
+/**
+   \brief Read out the current DSCP to Drop Precedence assignment mapping table.
+   The table can be configured
+   using \ref GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_SET.
+
+   \param GSW_QoS_DSCP_DropPrecedenceCfg_t Pointer to the QoS
+   DSCP drop precedence parameters
+   \ref GSW_QoS_DSCP_DropPrecedenceCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_GET _IOWR(GSW_QOS_MAGIC, 0x0A, GSW_QoS_DSCP_DropPrecedenceCfg_t)
+
+/**
+   \brief Port Remarking Configuration. Ingress and Egress remarking options for
+   DSCP and PCP. Remarking is done either on the used traffic class or
+   the drop precedence.
+   The current configuration can be read
+   using \ref GSW_QOS_PORT_REMARKING_CFG_GET.
+
+   \param GSW_QoS_portRemarkingCfg_t Pointer to the remarking configuration
+   \ref GSW_QoS_portRemarkingCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_PORT_REMARKING_CFG_SET	_IOW(GSW_QOS_MAGIC, 0x0D, GSW_QoS_portRemarkingCfg_t)
+
+/**
+   \brief Read out the Port Remarking Configuration. Ingress and Egress remarking options for
+   DSCP and PCP. Remarking is done either on the used traffic class or
+   the drop precedence.
+   The current configuration can be set
+   using \ref GSW_QOS_PORT_REMARKING_CFG_SET.
+
+   \param GSW_QoS_portRemarkingCfg_t Pointer to the QoS filter parameters
+   \ref GSW_QoS_portRemarkingCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_PORT_REMARKING_CFG_GET	_IOWR(GSW_QOS_MAGIC, 0x0C, GSW_QoS_portRemarkingCfg_t)
+
+/**
+   \brief Configure the traffic class to DSCP mapping table.
+   This table is global and valid for the entire switch device.
+   The table can be read using \ref GSW_QOS_CLASS_DSCP_GET.
+
+   \param GSW_QoS_ClassDSCP_Cfg_t Pointer to the DSCP mapping parameter
+   \ref GSW_QoS_ClassDSCP_Cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_CLASS_DSCP_SET	_IOW(GSW_QOS_MAGIC, 0x09, GSW_QoS_ClassDSCP_Cfg_t)
+
+/**
+   \brief Read out the current traffic class to DSCP mapping table.
+   The table can be written using \ref GSW_QOS_CLASS_DSCP_SET.
+
+   \param GSW_QoS_ClassDSCP_Cfg_t Pointer to the DSCP mapping parameter
+   \ref GSW_QoS_ClassDSCP_Cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_CLASS_DSCP_GET	_IOWR(GSW_QOS_MAGIC, 0x08, GSW_QoS_ClassDSCP_Cfg_t)
+
+/**
+   \brief Configure the traffic class to outgoing 802.1P (PCP) priority mapping table.
+   This table is global and valid for the entire switch device.
+   The table can be read using \ref GSW_QOS_CLASS_PCP_GET.
+
+   \param GSW_QoS_ClassPCP_Cfg_t Pointer to the PCP priority mapping parameter
+   \ref GSW_QoS_ClassPCP_Cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_CLASS_PCP_SET	_IOWR(GSW_QOS_MAGIC, 0x0F, GSW_QoS_ClassPCP_Cfg_t)
+
+/**
+   \brief Read out the current traffic class to outgoing 802.1P (PCP) priority mapping table.
+   This table is global and valid for the entire switch device.
+   The table can be written using \ref GSW_QOS_CLASS_PCP_SET.
+
+   \param GSW_QoS_ClassPCP_Cfg_t Pointer to the PCP priority mapping parameter
+   \ref GSW_QoS_ClassPCP_Cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_CLASS_PCP_GET	_IOWR(GSW_QOS_MAGIC, 0x0E, GSW_QoS_ClassPCP_Cfg_t)
+
+/** \brief This command configures a rate shaper instance with the rate and the
+    burst size. This instance can be assigned to QoS queues by
+    using \ref GSW_QOS_SHAPER_QUEUE_ASSIGN.
+    The total number of available rate shapers can be retrieved by the
+    capability list using \ref GSW_CAP_GET.
+
+   \param GSW_QoS_ShaperCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_ShaperCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_SHAPER_CFG_SET	_IOW(GSW_QOS_MAGIC, 0x19, GSW_QoS_ShaperCfg_t)
+
+/** \brief This command retrieves the rate and the burst size configuration of a
+    rate shaper instance. A configuration can be modified
+    using \ref GSW_QOS_SHAPER_CFG_SET.
+    The total number of available rate shapers can be retrieved by the
+    capability list using \ref GSW_CAP_GET.
+
+   \param GSW_QoS_ShaperCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_ShaperCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_SHAPER_CFG_GET	_IOWR(GSW_QOS_MAGIC, 0x18, GSW_QoS_ShaperCfg_t)
+
+/** \brief Assign one rate shaper instance to a QoS queue. The function returns with an
+    error in case there already are too many shaper instances assigned to a queue.
+    The queue instance can be enabled and configured
+    using \ref GSW_QOS_SHAPER_CFG_SET.
+    To remove a rate shaper instance from a QoS queue,
+    please use \ref GSW_QOS_SHAPER_QUEUE_DEASSIGN.
+    The total number of available rate shaper instances can be retrieved by the
+    capability list using \ref GSW_CAP_GET.
+
+   \param GSW_QoS_ShaperQueue_t Pointer to the parameters
+   structure \ref GSW_QoS_ShaperQueue_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_SHAPER_QUEUE_ASSIGN          _IOW(GSW_QOS_MAGIC, 0x1A, GSW_QoS_ShaperQueue_t)
+
+/** \brief De-assign or Unassign one rate shaper instance from a QoS queue. The function returns
+    with an error in case the requested instance is not currently assigned
+    to the queue.
+    The queue instance can be enabled and configured by
+    using \ref GSW_QOS_SHAPER_CFG_SET.
+    To assign a rate shaper instance to a QoS queue,
+    please use \ref GSW_QOS_SHAPER_QUEUE_ASSIGN.
+    The total number of available rate shapers can be retrieved by the
+    capability list using \ref GSW_CAP_GET.
+
+   \param GSW_QoS_ShaperQueue_t Pointer to the parameters
+   structure \ref GSW_QoS_ShaperQueue_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_SHAPER_QUEUE_DEASSIGN        _IOW(GSW_QOS_MAGIC, 0x1B, GSW_QoS_ShaperQueue_t)
+
+/** \brief Check whether a rate shaper instance is assigned to the egress queue.
+    The egress queue index is the function input parameter.
+    The switch API sets the boolean parameter 'bAssigned == 1' in case a
+    rate shaper is assigned and then sets 'nRateShaperId' to describe the rater
+    shaper instance.
+    The parameter 'bAssigned == 0' in case no rate shaper instance
+    is currently assigned to the queue instance.
+    The commands \ref GSW_QOS_SHAPER_QUEUE_ASSIGN allow a
+    rate shaper instance to be assigned, and \ref GSW_QOS_SHAPER_CFG_SET allows
+    for configuration of a shaper instance.
+    The total number of available rate shapers can be retrieved by the
+    capability list using \ref GSW_CAP_GET.
+
+   \param GSW_QoS_ShaperQueueGet_t Pointer to the parameters
+   structure \ref GSW_QoS_ShaperQueueGet_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_SHAPER_QUEUE_GET	_IOWR(GSW_QOS_MAGIC, 0x1C, GSW_QoS_ShaperQueueGet_t)
+
+/** \brief Configures the global WRED drop probability profile and thresholds of the device.
+    Given parameters are rounded to the segment size of the HW platform.
+    The supported segment size is given by the capability list by
+    using \ref GSW_CAP_GET.
+
+   \param GSW_QoS_WRED_Cfg_t Pointer to the parameters
+   structure \ref GSW_QoS_WRED_Cfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_WRED_CFG_SET	_IOW(GSW_QOS_MAGIC, 0x20, GSW_QoS_WRED_Cfg_t)
+
+/** \brief Read out the global WRED drop probability profile and thresholds of the device.
+    Given parameters are rounded to the segment size of the HW platform.
+    The supported segment size is given by the capability list by
+    using \ref GSW_CAP_GET.
+
+   \param GSW_QoS_WRED_Cfg_t Pointer to the parameters
+   structure \ref GSW_QoS_WRED_Cfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_WRED_CFG_GET	_IOWR(GSW_QOS_MAGIC, 0x1F, GSW_QoS_WRED_Cfg_t)
+
+/** \brief Configures the WRED drop thresholds for a dedicated egress queue.
+    Given parameters are rounded to the segment size of the HW platform.
+    The supported segment size is given by the capability list by
+    using \ref GSW_CAP_GET.
+    The command \ref GSW_QOS_WRED_QUEUE_CFG_GET retrieves the current
+    configuration.
+
+   \param GSW_QoS_WRED_QueueCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_WRED_QueueCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_WRED_QUEUE_CFG_SET           _IOW(GSW_QOS_MAGIC, 0x22, GSW_QoS_WRED_QueueCfg_t)
+
+/** \brief Read out the WRED drop thresholds for a dedicated egress queue.
+    Given parameters are rounded to the segment size of the HW platform.
+    The supported segment size is given by the capability list by
+    using \ref GSW_CAP_GET.
+    The configuration can be changed by
+    using \ref GSW_QOS_WRED_QUEUE_CFG_SET.
+
+   \param GSW_QoS_WRED_QueueCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_WRED_QueueCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_WRED_QUEUE_CFG_GET           _IOWR(GSW_QOS_MAGIC, 0x21, GSW_QoS_WRED_QueueCfg_t)
+
+/** \brief Configures the WRED drop thresholds for a dedicated egress port.
+    Given parameters are rounded to the segment size of the HW platform.
+    The supported segment size is given by the capability list by
+    using \ref GSW_CAP_GET.
+    The command \ref GSW_QOS_WRED_PORT_CFG_GET retrieves the current
+    configuration.
+
+   \param GSW_QoS_WRED_PortCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_WRED_PortCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_WRED_PORT_CFG_SET	_IOW(GSW_QOS_MAGIC, 0x24, GSW_QoS_WRED_PortCfg_t)
+
+/** \brief Read out the WRED drop thresholds for a dedicated egress port.
+    Given parameters are rounded to the segment size of the HW platform.
+    The supported segment size is given by the capability list by
+    using \ref GSW_CAP_GET.
+    The configuration can be changed by
+    using \ref GSW_QOS_WRED_PORT_CFG_SET.
+
+   \param GSW_QoS_WRED_PortCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_WRED_PortCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_WRED_PORT_CFG_GET	_IOWR(GSW_QOS_MAGIC, 0x23, GSW_QoS_WRED_PortCfg_t)
+
+/** \brief Configures the global flow control thresholds for conforming and non-conforming packets.
+    The configured thresholds apply to the global switch segment buffer.
+    The current configuration can be retrieved by \ref GSW_QOS_FLOWCTRL_CFG_GET.
+    Given parameters are rounded to the segment size of the HW platform.
+    The supported segment size is given by the capability list by
+    using \ref GSW_CAP_GET.
+
+   \param GSW_QoS_FlowCtrlCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_FlowCtrlCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_FLOWCTRL_CFG_SET	_IOW(GSW_QOS_MAGIC, 0x26, GSW_QoS_FlowCtrlCfg_t)
+
+/** \brief Read out the global flow control thresholds for conforming and non-conforming packets.
+    The configured thresholds apply to the global switch segment buffer.
+    The configuration can be changed by \ref GSW_QOS_FLOWCTRL_CFG_SET.
+    Given parameters are rounded to the segment size of the HW platform.
+    The supported segment size is given by the capability list by
+    using \ref GSW_CAP_GET.
+
+   \param GSW_QoS_FlowCtrlCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_FlowCtrlCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_FLOWCTRL_CFG_GET	_IOWR(GSW_QOS_MAGIC, 0x25, GSW_QoS_FlowCtrlCfg_t)
+
+/** \brief Configures the ingress port flow control thresholds for occupied buffer segments.
+    The current configuration can be retrieved by \ref GSW_QOS_FLOWCTRL_PORT_CFG_GET.
+    Given parameters are rounded to the segment size of the HW platform.
+    The supported segment size is given by the capability list by
+    using \ref GSW_CAP_GET.
+
+   \param GSW_QoS_FlowCtrlPortCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_FlowCtrlPortCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_FLOWCTRL_PORT_CFG_SET        _IOW(GSW_QOS_MAGIC, 0x28, GSW_QoS_FlowCtrlPortCfg_t)
+
+/** \brief Read out the ingress port flow control thresholds for occupied buffer segments.
+    The configuration can be changed by \ref GSW_QOS_FLOWCTRL_PORT_CFG_SET.
+    Given parameters are rounded to the segment size of the HW platform.
+    The supported segment size is given by the capability list by
+    using \ref GSW_CAP_GET.
+
+   \param GSW_QoS_FlowCtrlPortCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_FlowCtrlPortCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_FLOWCTRL_PORT_CFG_GET        _IOWR(GSW_QOS_MAGIC, 0x27, GSW_QoS_FlowCtrlPortCfg_t)
+
+/** \brief This command configures the parameters of a rate meter instance.
+    This instance can be assigned to an ingress/egress port by
+    using \ref GSW_QOS_METER_PORT_ASSIGN. It can also be used by the
+    flow classification engine.
+    The total number of available rate meters can be retrieved by the
+    capability list using \ref GSW_CAP_GET.
+    The current configuration of a meter instance can be retrieved
+    using \ref GSW_QOS_METER_CFG_GET.
+
+   \param GSW_QoS_meterCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_meterCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_METER_CFG_SET	_IOW(GSW_QOS_MAGIC, 0x02, GSW_QoS_meterCfg_t)
+
+/** \brief Configure the parameters of a rate meter instance.
+    This instance can be assigned to an ingress/egress port
+    using \ref GSW_QOS_METER_PORT_ASSIGN. It can also be used by the
+    flow classification engine.
+    The total number of available rate meters can be retrieved by the
+    capability list using \ref GSW_CAP_GET.
+    The current configuration of a meter instance can be retrieved
+    using \ref GSW_QOS_METER_CFG_GET.
+
+   \param GSW_QoS_meterCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_meterCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_METER_CFG_GET	_IOWR(GSW_QOS_MAGIC, 0x01, GSW_QoS_meterCfg_t)
+
+/** \brief Assign a rate meter instance to an ingress and/or egress port.
+    A maximum of two meter IDs can be assigned to one single ingress port.
+    This meter instance to port assignment can be removed
+    using \ref GSW_QOS_METER_PORT_DEASSIGN. A list of all available
+    assignments can be read using \ref GSW_QOS_METER_PORT_GET.
+
+   \param GSW_QoS_meterPort_t Pointer to the parameters
+   structure \ref GSW_QoS_meterPort_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_METER_PORT_ASSIGN	_IOW(GSW_QOS_MAGIC, 0x03, GSW_QoS_meterPort_t)
+
+/** \brief Deassign a rate meter instance from an ingress and/or egress port.
+    A maximum of two meter IDs can be assigned to one single ingress port.
+    The meter instance is given to the command and the port configuration is
+    returned. An instance to port assignment can be done
+    using \ref GSW_QOS_METER_PORT_ASSIGN. A list of all available
+    assignments can be read using \ref GSW_QOS_METER_PORT_GET.
+
+   \param GSW_QoS_meterPort_t Pointer to the parameters
+   structure \ref GSW_QoS_meterPort_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_METER_PORT_DEASSIGN          _IOW(GSW_QOS_MAGIC, 0x04, GSW_QoS_meterPort_t)
+
+/** \brief Reads out all meter instance to port assignments that are done
+    using \ref GSW_QOS_METER_PORT_ASSIGN. All assignments are read from an
+    internal table where every read call retrieves the next entry of the table.
+    Setting the parameter 'bInitial' starts the read operation at the beginning
+    of the table. The returned parameter 'bLast' indicates that the last
+    element of the table was returned.
+
+   \param GSW_QoS_meterPortGet_t Pointer to the parameters
+   structure \ref GSW_QoS_meterPortGet_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_METER_PORT_GET	_IOWR(GSW_QOS_MAGIC, 0x05, GSW_QoS_meterPortGet_t)
+
+/** \brief This command configures one meter instances for storm control.
+    These instances can be used for ingress broadcast-, multicast- and
+    unknown unicast- packets. Some platforms support addition of additional meter
+    instances for this type of packet.
+    Repeated calls of \ref GSW_QOS_STORM_CFG_SET allow addition of
+    additional meter instances.
+    An assignment can be retrieved using \ref GSW_QOS_STORM_CFG_GET.
+    Setting the broadcast, multicast and unknown unicast packets boolean switch to zero
+    deletes all metering instance assignments.
+
+   \param GSW_QoS_stormCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_stormCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_STORM_CFG_SET	_IOW(GSW_QOS_MAGIC, 0x1D, GSW_QoS_stormCfg_t)
+
+/** \brief Reads out the current meter instance assignment for storm control. This
+    configuration can be modified using \ref GSW_QOS_STORM_CFG_SET.
+
+   \param GSW_QoS_stormCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_stormCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_STORM_CFG_GET	_IOWR(GSW_QOS_MAGIC, 0x1E, GSW_QoS_stormCfg_t)
+
+/** \brief GSWIP-3.0 provides two sets of metering actions support for CPU/MPE traffic.
+    This command provides Control Action for triggering metering action from
+ CPU users [(CPU or MPE) or (CPU-1 & CPU-2) ]. This control trigger action performs metering and returns output color.
+
+   \param GSW_QoS_mtrAction_t Pointer to the Metering Action parameters
+   structure \ref GSW_QoS_mtrAction_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_METER_ACT	_IOWR(GSW_QOS_MAGIC, 0x2B, GSW_QoS_mtrAction_t)
+
+/** \brief This configuration decides how the egress queues, attached to a single port,
+    are scheduled to transmit the queued Ethernet packets.
+    The configuration differentiates between 'Strict Priority' and
+    'weighted fair queuing'. This applies when multiple egress queues are
+    assigned to an Ethernet port.
+    Using the WFQ feature on a port requires the configuration of weights on all
+    given queues that are assigned to that port.
+    Strict Priority means that no dedicated weight is configured and the
+    queue can transmit following its priority status.
+    The given configuration can be read out
+    using \ref GSW_QOS_SCHEDULER_CFG_GET.
+
+   \param GSW_QoS_schedulerCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_schedulerCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_SCHEDULER_CFG_SET	_IOW(GSW_QOS_MAGIC, 0x17, GSW_QoS_schedulerCfg_t)
+
+/** \brief Read out the current scheduler configuration of a given egress port. This
+    configuration can be modified
+    using \ref GSW_QOS_SCHEDULER_CFG_SET.
+
+   \param GSW_QoS_schedulerCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_schedulerCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_SCHEDULER_CFG_GET	_IOWR(GSW_QOS_MAGIC, 0x16, GSW_QoS_schedulerCfg_t)
+
+/** \brief Sets the Queue ID for one traffic class of one port.
+    The total amount of supported ports, queues and traffic classes can be
+    retrieved from the capability list using \ref GSW_CAP_GET.
+    Please note that the device comes along with a
+    default configuration and assignment.
+
+   \param GSW_QoS_queuePort_t Pointer to the parameters
+   structure \ref GSW_QoS_queuePort_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_QUEUE_PORT_SET	_IOW(GSW_QOS_MAGIC, 0x15, GSW_QoS_queuePort_t)
+
+/** \brief Read out the traffic class and port assignment done
+    using \ref GSW_QOS_QUEUE_PORT_SET.
+    Please note that the device comes along with a
+    default configuration and assignment.
+
+   \param GSW_QoS_queuePort_t Pointer to the parameters
+   structure \ref GSW_QoS_queuePort_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_QUEUE_PORT_GET	_IOWR(GSW_QOS_MAGIC, 0x14, GSW_QoS_queuePort_t)
+/** \brief Configure the egress queue buffer reservation.
+    WRED GREEN packets are never dropped by any WRED algorithm (queue,
+    port or global buffer level) in case they are below this reservation threshold.
+    The amount of reserved segments cannot be occupied by other queues of the switch.
+    The egress queue related configuration can be retrieved by
+    calling \ref GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_GET.
+
+    \remarks
+    The command \ref GSW_QOS_QUEUE_PORT_SET allows to assign egress queue to ports with related traffic classes.
+
+   \param GSW_QoS_QueueBufferReserveCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_QueueBufferReserveCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_SET _IOW(GSW_QOS_MAGIC, 0x2A, GSW_QoS_QueueBufferReserveCfg_t)
+
+/** \brief Read out the egress queue specific buffer reservation.
+    Configuration can be read by \ref GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_SET.
+
+   \param GSW_QoS_QueueBufferReserveCfg_t Pointer to the parameters
+   structure \ref GSW_QoS_QueueBufferReserveCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_GET _IOWR(GSW_QOS_MAGIC, 0x29, GSW_QoS_QueueBufferReserveCfg_t)
+/**
+   \brief Configure the egress port related traffic class to STAG VLAN 802.1P (PCP) priority mapping table.
+   One table is given for each egress port.
+   The table can be read using \ref GSW_QOS_SVLAN_CLASS_PCP_PORT_GET.
+
+   \param GSW_QoS_SVLAN_ClassPCP_PortCfg_t Pointer to the PCP priority mapping parameter
+   \ref GSW_QoS_SVLAN_ClassPCP_PortCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_SVLAN_CLASS_PCP_PORT_SET	_IOWR(GSW_QOS_MAGIC, 0x37, GSW_QoS_SVLAN_ClassPCP_PortCfg_t)
+
+/**
+   \brief Read out the current egress port related traffic class to 802.1P (PCP) priority mapping table.
+   One table is given for each egress port.
+   The table can be written using \ref GSW_QOS_SVLAN_CLASS_PCP_PORT_SET.
+
+   \param GSW_QoS_SVLAN_ClassPCP_PortCfg_t Pointer to the PCP priority mapping parameter
+   \ref GSW_QoS_SVLAN_ClassPCP_PortCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_SVLAN_CLASS_PCP_PORT_GET	_IOWR(GSW_QOS_MAGIC, 0x36, GSW_QoS_SVLAN_ClassPCP_PortCfg_t)
+
+/**
+   \brief Configure the PCP to traffic class mapping table.
+   This configuration applies to the entire switch device.
+   The table configuration can be read using \ref GSW_QOS_SVLAN_PCP_CLASS_GET.
+
+   \param GSW_QoS_SVLAN_PCP_ClassCfg_t Pointer to the QoS filter parameters
+   \ref GSW_QoS_SVLAN_PCP_ClassCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_SVLAN_PCP_CLASS_SET	_IOW(GSW_QOS_MAGIC, 0x39, GSW_QoS_SVLAN_PCP_ClassCfg_t)
+
+/**
+   \brief Read out the PCP to traffic class mapping table.
+   The table configuration can be set using \ref GSW_QOS_SVLAN_PCP_CLASS_SET.
+
+   \param GSW_QoS_SVLAN_PCP_ClassCfg_t Pointer to the QoS filter parameters
+   \ref GSW_QoS_SVLAN_PCP_ClassCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_SVLAN_PCP_CLASS_GET	_IOWR(GSW_QOS_MAGIC, 0x38, GSW_QoS_SVLAN_PCP_ClassCfg_t)
+
+/*@}*/ /* GSW_IOCTL_QOS */
+
+/** \addtogroup GSW_IOCTL_MULTICAST */
+/*@{*/
+
+/**
+   \brief Configure the switch multicast configuration. The currently used
+   configuration can be read using \ref GSW_MULTICAST_SNOOP_CFG_GET.
+
+   \param GSW_multicastSnoopCfg_t Pointer to the
+   multicast configuration \ref GSW_multicastSnoopCfg_t.
+
+   \remarks IGMP/MLD snooping is disabled when
+   'eIGMP_Mode = GSW_MULTICAST_SNOOP_MODE_SNOOPFORWARD'.
+   Then all other structure parameters are unused.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MULTICAST_SNOOP_CFG_SET	_IOW(GSW_MULTICAST_MAGIC, 0x05, GSW_multicastSnoopCfg_t)
+
+/**
+   \brief Read out the current switch multicast configuration.
+   The configuration can be set using \ref GSW_MULTICAST_SNOOP_CFG_SET.
+
+   \param GSW_multicastSnoopCfg_t Pointer to the
+   multicast configuration \ref GSW_multicastSnoopCfg_t.
+
+   \remarks IGMP/MLD snooping is disabled when
+   'eIGMP_Mode = GSW_MULTICAST_SNOOP_MODE_SNOOPFORWARD'.
+   Then all other structure parameters are unused.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MULTICAST_SNOOP_CFG_GET	_IOWR(GSW_MULTICAST_MAGIC, 0x04, GSW_multicastSnoopCfg_t)
+
+/**
+   \brief Add static router port to the switch hardware multicast table.
+   These added router ports will not be removed by the router port learning aging process.
+   The router port learning is enabled over the parameter 'bLearningRouter'
+   over the \ref GSW_MULTICAST_SNOOP_CFG_GET command.
+   Router port learning and static added entries can both be used together.
+   In case of a software IGMP stack/daemon environment, the router port learning does
+   not have to be configured on the switch hardware. Instead the router port
+   management is handled by the IGMP stack/daemon.
+   A port can be removed using \ref GSW_MULTICAST_ROUTER_PORT_REMOVE.
+
+   \param GSW_multicastRouter_t Pointer to \ref GSW_multicastRouter_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MULTICAST_ROUTER_PORT_ADD	_IOW(GSW_MULTICAST_MAGIC, 0x01, GSW_multicastRouter_t)
+
+/**
+   \brief Remove an Ethernet router port from the switch hardware multicast table.
+   A port can be added using \ref GSW_MULTICAST_ROUTER_PORT_ADD.
+
+   \param GSW_multicastRouter_t Pointer to \ref GSW_multicastRouter_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs (e.g. Ethernet port parameter out of range)
+*/
+#define GSW_MULTICAST_ROUTER_PORT_REMOVE	_IOW(GSW_MULTICAST_MAGIC, 0x03, GSW_multicastRouter_t)
+
+/**
+   \brief Check if a port has been selected as a router port, either by automatic learning or by manual setting.
+   A port can be added using \ref GSW_MULTICAST_ROUTER_PORT_ADD.
+   A port can be removed again using \ref GSW_MULTICAST_ROUTER_PORT_REMOVE.
+
+   \param GSW_multicastRouterRead_t Pointer to \ref GSW_multicastRouterRead_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs (e.g. Ethernet port parameter out of range)
+*/
+#define GSW_MULTICAST_ROUTER_PORT_READ	_IOWR(GSW_MULTICAST_MAGIC, 0x02, GSW_multicastRouterRead_t)
+
+/**
+   \brief Adds a multicast group configuration to the multicast table.
+   No new entry is added in case this multicast group already
+   exists in the table. This commands adds a host member to
+   the multicast group.
+   A member can be removed again using \ref GSW_MULTICAST_TABLE_ENTRY_REMOVE.
+
+   \param GSW_multicastTable_t Pointer
+      to \ref GSW_multicastTable_t.
+
+   \remarks The Source IP parameter is ignored in case IGMPv3 support is
+      not enabled in the hardware.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MULTICAST_TABLE_ENTRY_ADD	_IOW(GSW_MULTICAST_MAGIC, 0x06, GSW_multicastTable_t)
+
+/**
+   \brief Remove an host member from a multicast group. The multicast group entry
+   is completely removed from the multicast table in case it has no
+   host member port left.
+   Group members can be added using \ref GSW_MULTICAST_TABLE_ENTRY_ADD.
+
+   \param GSW_multicastTable_t Pointer
+      to \ref GSW_multicastTable_t.
+
+   \remarks The Source IP parameter is ignored in case IGMPv3 support is
+      not enabled in the hardware.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MULTICAST_TABLE_ENTRY_REMOVE	_IOWR(GSW_MULTICAST_MAGIC, 0x08, GSW_multicastTable_t)
+
+/**
+   \brief Read out the multicast membership table that is located inside the switch
+   hardware. The 'bInitial' parameter restarts the read operation at the beginning of
+   the table. Every following \ref GSW_MULTICAST_TABLE_ENTRY_READ call reads out
+   the next found entry. The 'bLast' parameter is set by the switch API in case
+   the last entry of the table is reached.
+
+   \param GSW_multicastTableRead_t Pointer
+      to \ref GSW_multicastTableRead_t.
+
+   \remarks The 'bInitial' parameter is reset during the read operation.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MULTICAST_TABLE_ENTRY_READ	_IOWR(GSW_MULTICAST_MAGIC, 0x07, GSW_multicastTableRead_t)
+
+/*@}*/ /* GSW_IOCTL_MULTICAST */
+
+/** \addtogroup GSW_IOCTL_OAM */
+/*@{*/
+
+/** \brief Hardware Initialization. This command should be called right after the
+    Switch API software module is initialized and loaded.
+    It accesses the hardware platform, retrieving platform capabilities and
+    performing the first basic configuration.
+
+   \param GSW_HW_Init_t Pointer to pre-allocated initialization structure
+   \ref GSW_HW_Init_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_HW_INIT	_IOW(GSW_COMMON_MAGIC, 0x0E, GSW_HW_Init_t)
+
+/**
+   \brief Retrieve the version string of the currently version index. The returned
+   string format might vary between the device platforms used. This
+   means that the version information cannot be compared between different
+   device platforms.
+   All returned version information is in the form of zero-terminated character strings.
+   The returned strings are empty ('') in case the given version
+   index is out of range.
+
+   \param GSW_version_t* The parameter points to a
+   \ref GSW_version_t structure.
+
+   \return Returns value as follows:
+   - GSW_statusOk: if successful
+   - LTQ_ERROR: in case of an error
+
+   \code
+   GSW_version_t param;
+   int fd;
+
+   memset (&param, 0, sizeof(GSW_version_t));
+
+   while (1)
+   {
+      if (ioctl(fd, GSW_VERSION_GET, (int) &param)
+         != GSW_statusOk)
+      {
+         printf("ERROR: SW-API version request failed!\n);
+         return LTQ_ERROR;
+      }
+
+      if ((strlen(param.cName) == 0) || (strlen(param.cVersion) == 0))
+         // No more version entries found
+         break;
+
+      printf("%s version: %s", param.cName, param.cVersion);
+      param.nId++;
+   }
+
+   return GSW_statusOk;
+   \endcode
+*/
+#define GSW_VERSION_GET	_IOWR(GSW_COMMON_MAGIC, 0x0A, GSW_version_t)
+
+/** \brief This service returns the capability referenced by the provided index
+    (zero-based counting index value). The Switch API uses the index to return
+    the capability parameter from an internal list. For instance,
+    the capability list contains information about the amount of supported
+    features like number of supported VLAN groups or MAC table entries.
+    The command returns zero-length strings ('') in case the
+    requested index number is out of range.
+
+   \param GSW_cap_t Pointer to pre-allocated capability
+      list structure \ref GSW_cap_t.
+      The switch API implementation fills out the structure with the supported
+      features, based on the provided 'nCapType' parameter.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+   \code
+   GSW_cap_t param;
+   int fd;
+   int i;
+
+   // Open SWAPI file descriptor *
+   fd = open("/dev/switchapi/1", O_RDWR, 0x644);
+
+   for (i = 0; i < GSW_CAP_TYPE_LAST, i++)
+   {
+      memset(&param, 0, sizeof(param));
+      param.nCapType = i;
+      //Get the cap list
+      if (ioctl(fd, GSW_CAP_GET, (int) &param) == LTQ_ERROR)
+         return LTQ_ERROR;
+
+      printf("%s: %d\n", param.cDesc, param.nCap);
+   }
+
+   // Close open fd
+   close(fd);
+   return GSW_statusOk;
+   \endcode
+*/
+#define GSW_CAP_GET	_IOWR(GSW_COMMON_MAGIC, 0x0B, GSW_cap_t)
+
+/**
+   \brief Modify the switch configuration.
+   The configuration can be read using \ref GSW_CFG_GET.
+   The switch can be enabled using \ref GSW_ENABLE.
+
+   \param GSW_cfg_t Pointer to an \ref GSW_cfg_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_CFG_SET	_IOW(GSW_COMMON_MAGIC, 0x0D, GSW_cfg_t)
+
+/**
+   \brief Read the global switch configuration.
+   This configuration can be set using \ref GSW_CFG_SET.
+
+   \param GSW_cfg_t Pointer to an \ref GSW_cfg_t structure.
+      The structure is filled out by the switch implementation.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_CFG_GET	_IOWR(GSW_COMMON_MAGIC, 0x0C, GSW_cfg_t)
+
+/**
+   \brief Enables the whole switch. The switch device is enabled with the default
+   configuration in case no other configuration is applied.
+   The switch can be disabled using the \ref GSW_DISABLE command
+
+   \param void This command does not require any parameter structure
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_ENABLE	_IO(GSW_COMMON_MAGIC, 0x07)
+
+/**
+   \brief Disables the whole switch.
+   The switch can be enabled using the \ref GSW_ENABLE command
+
+   \param void This command does not require any parameter structure
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_DISABLE	_IO(GSW_COMMON_MAGIC, 0x09)
+
+/**
+   \brief Read out the current Ethernet port configuration.
+
+   \param GSW_portCfg_t Pointer to a port configuration
+   \ref GSW_portCfg_t structure to fill out by the driver.
+   The parameter 'nPortId' tells the driver which port parameter is requested.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PORT_CFG_GET	_IOWR(GSW_COMMON_MAGIC, 0x20, GSW_portCfg_t)
+
+/**
+   \brief Set the Ethernet port configuration.
+
+   \param GSW_portCfg_t Pointer to an \ref GSW_portCfg_t structure
+   to configure the switch port hardware.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PORT_CFG_SET	_IOW(GSW_COMMON_MAGIC, 0x21, GSW_portCfg_t)
+
+/**
+   \brief Defines one port that is directly connected to the software running on a CPU.
+   This allows for the redirecting of protocol-specific packets to the CPU port and
+   special packet treatment when sent by the CPU.
+   If the CPU port cannot be set, the function returns an error code.
+
+   \param GSW_CPU_PortCfg_t Pointer to
+      an \ref GSW_CPU_PortCfg_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_CPU_PORT_CFG_SET	_IOW(GSW_COMMON_MAGIC, 0x18, GSW_CPU_PortCfg_t)
+
+/**
+   \brief Get the port that is directly connected to the software running on a CPU and defined as
+   CPU port. This port assignment can be set using \ref GSW_CPU_PORT_CFG_SET
+   if it is not fixed and defined by the switch device architecture.
+
+   \param GSW_CPU_PortCfg_t Pointer to
+      an \ref GSW_CPU_PortCfg_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_CPU_PORT_CFG_GET	_IOWR(GSW_COMMON_MAGIC, 0x17, GSW_CPU_PortCfg_t)
+
+/**
+   \brief Configure an additional CPU port configuration. This configuration applies to
+   devices where the CPU port is fixed to one dedicated port.
+
+   \param GSW_CPU_PortExtendCfg_t Pointer to
+      an \ref GSW_CPU_PortExtendCfg_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_CPU_PORT_EXTEND_CFG_SET	_IOW(GSW_COMMON_MAGIC, 0x1A, GSW_CPU_PortExtendCfg_t)
+
+/**
+   \brief Reads out additional CPU port configuration. This configuration applies to
+   devices where the CPU port is fixed to one dedicated port.
+
+   \param GSW_CPU_PortExtendCfg_t Pointer to
+      an \ref GSW_CPU_PortExtendCfg_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+#define GSW_CPU_PORT_EXTEND_CFG_GET	_IOWR(GSW_COMMON_MAGIC, 0x19, GSW_CPU_PortExtendCfg_t)
+
+/**
+   \brief Read out the Ethernet port's speed, link status, and flow control status.
+   The information for one single port 'nPortId' is returned.
+   An error code is returned if the selected port does not exist.
+
+   \param GSW_portLinkCfg_t Pointer to
+      an \ref GSW_portLinkCfg_t structure to read out the port status.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PORT_LINK_CFG_GET	_IOWR(GSW_COMMON_MAGIC, 0x0F, GSW_portLinkCfg_t)
+
+/**
+   \brief Set the Ethernet port link, speed status and flow control status.
+   The configuration applies to a single port 'nPortId'.
+
+   \param GSW_portLinkCfg_t Pointer to
+      an \ref GSW_portLinkCfg_t structure to set the port configuration.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PORT_LINK_CFG_SET	_IOW(GSW_COMMON_MAGIC, 0x10, GSW_portLinkCfg_t)
+
+/**
+   \brief Configure the RGMII clocking parameter in case the Ethernet port is configured in RGMII mode.
+   The configuration can be read by calling \ref GSW_PORT_RGMII_CLK_CFG_GET.
+   It applies to a single port 'nPortId'.
+
+   \param GSW_portRGMII_ClkCfg_t Pointer to
+      an \ref GSW_portRGMII_ClkCfg_t structure to set the port configuration.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PORT_RGMII_CLK_CFG_SET	_IOW(GSW_COMMON_MAGIC, 0x14, GSW_portRGMII_ClkCfg_t)
+
+/**
+   \brief Read the RGMII clocking parameter in case the Ethernet port is configured in RGMII mode.
+   The configuration can be set by calling \ref GSW_PORT_RGMII_CLK_CFG_SET.
+   It applies to a single port 'nPortId'.
+
+   \param GSW_portRGMII_ClkCfg_t Pointer to
+      an \ref GSW_portRGMII_ClkCfg_t structure to set the port configuration.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PORT_RGMII_CLK_CFG_GET	_IOWR(GSW_COMMON_MAGIC, 0x13, GSW_portRGMII_ClkCfg_t)
+
+/**
+   \brief Check whether the Ethernet switch hardware has detected an Ethernet PHY connected
+   to the given Ethernet port 'nPortId'.
+
+   \param GSW_portPHY_Query_t Pointer to
+      an \ref GSW_portPHY_Query_t structure to set the port configuration.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PORT_PHY_QUERY	_IOWR(GSW_COMMON_MAGIC, 0x12, GSW_portPHY_Query_t)
+
+/**
+   \brief Read out the MDIO device address of an Ethernet PHY that is connected to
+   an Ethernet port. This device address is useful when accessing PHY
+   registers using the commands \ref GSW_MDIO_DATA_WRITE,
+   \ref GSW_MDIO_DATA_READ, \ref GSW_MMD_DATA_WRITE
+        and \ref GSW_MMD_DATA_READ.
+
+   \param GSW_portPHY_Addr_t Pointer to \ref GSW_portPHY_Addr_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PORT_PHY_ADDR_GET	_IOWR(GSW_COMMON_MAGIC, 0x11, GSW_portPHY_Addr_t)
+
+/**
+   \brief Ingress and egress packets of one specific Ethernet port can be redirected to
+   the CPU port. The ingress and egress packet redirection can be configured
+   individually. This command reads out the current configuration of a
+   dedicated port. A new configuration can be applied
+   by calling \ref GSW_PORT_REDIRECT_SET.
+
+   \param GSW_portRedirectCfg_t Pointer
+          to \ref GSW_portRedirectCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+   \remarks Not all hardware platforms support this feature. The function
+            returns an error if this feature is not supported.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PORT_REDIRECT_GET	_IOWR(GSW_COMMON_MAGIC, 0x15, GSW_portRedirectCfg_t)
+
+/**
+   \brief Select ingress and egress packets of one specific Ethernet port that can be
+   redirected to a port that is configured as the 'CPU port'. The ingress and
+   egress packet direction can be configured individually.
+   The packet filter of the original port still
+   applies to the packet (for example, MAC address learning is done for the
+   selected port and not for the CPU port).
+   On CPU port side, no additional learning, forwarding look up,
+   VLAN processing and queue selection is performed for redirected packets.
+   Depending on the hardware platform used, the CPU port has to be set in
+   advance using \ref GSW_CPU_PORT_CFG_SET.
+   The currently used configuration can be read
+   using \ref GSW_PORT_REDIRECT_GET.
+
+   \param GSW_portRedirectCfg_t Pointer
+          to \ref GSW_portRedirectCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+   \remarks Not all hardware platforms support this feature. The function
+            returns an error if this feature is not supported.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PORT_REDIRECT_SET	_IOW(GSW_COMMON_MAGIC, 0x16, GSW_portRedirectCfg_t)
+
+/**
+   \brief Reads out the current monitor options for a
+   dedicated Ethernet port. This configuration can be set
+   using \ref GSW_MONITOR_PORT_CFG_SET.
+
+   \param GSW_monitorPortCfg_t Pointer
+          to \ref GSW_monitorPortCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MONITOR_PORT_CFG_GET	_IOWR(GSW_COMMON_MAGIC, 0x1B, GSW_monitorPortCfg_t)
+
+/**
+   \brief Configures the monitor options for a
+   dedicated Ethernet port. This current configuration can be read back
+   using \ref GSW_MONITOR_PORT_CFG_GET.
+
+   \param GSW_monitorPortCfg_t Pointer
+          to \ref GSW_monitorPortCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MONITOR_PORT_CFG_SET	_IOW(GSW_COMMON_MAGIC, 0x1C, GSW_monitorPortCfg_t)
+
+
+
+/**
+   \brief Read the MDIO interface configuration.
+   The parameters can be modified using \ref GSW_MDIO_CFG_SET.
+
+   \param GSW_MDIO_cfg_t Pointer to \ref GSW_MDIO_cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+
+
+#define GSW_MDIO_CFG_GET	_IOWR(GSW_COMMON_MAGIC, 0x22, GSW_MDIO_cfg_t)
+
+/**
+   \brief Set the MDIO interface configuration.
+   The parameters can be read using \ref GSW_MDIO_CFG_GET.
+   The given frequency is rounded off to fitting to the hardware support.
+   \ref GSW_MDIO_CFG_GET will return the exact programmed (rounded) frequency value.
+
+   \param GSW_MDIO_cfg_t Pointer to \ref GSW_MDIO_cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MDIO_CFG_SET	_IOW(GSW_COMMON_MAGIC, 0x23, GSW_MDIO_cfg_t)
+
+/**
+   \brief Read data from the MDIO Interface of the switch device. This function allows
+   various kinds of information to be read out for any attached device by register and
+   device addressing.
+   The 'nData' value (\ref GSW_MDIO_data_t) contains the read
+   device register.
+   A write operation can be done using \ref GSW_MDIO_DATA_WRITE.
+
+   \param GSW_MDIO_data_t Pointer to \ref GSW_MDIO_data_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MDIO_DATA_READ	_IOWR(GSW_COMMON_MAGIC, 0x24, GSW_MDIO_data_t)
+
+/**
+   \brief Write data to the MDIO Interface of the switch device. This function allows
+   for configuration of any attached device by register and device addressing.
+   This applies to external and internal Ethernet PHYs as well.
+   The 'nData' value (\ref GSW_MDIO_data_t) is directly written to the
+   device register.
+   A read operation can be performed using \ref GSW_MDIO_DATA_READ.
+
+   \param GSW_MDIO_data_t Pointer to \ref GSW_MDIO_data_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+   \code
+   GSW_MDIO_data_t         phy;
+
+   // access the device 2
+   phy.nAddressDev = 2;
+   // PHY register 0
+   phy.nAddressReg = 0;
+   // copy the helper PHY register union to the data field to configure
+   phy.nData = 0x1235;
+
+   if (ioctl(fd, GSW_MDIO_DATA_WRITE, (int)&phy))
+      return LTQ_ERROR;
+
+   // access the device 5
+   phy.nAddressDev = 5;
+   // Device specific register 20
+   phy.nAddressReg = 20;
+   // set the data field to configure
+   phy.nData = 0x1234;
+
+   if (ioctl(fd, GSW_MDIO_DATA_WRITE, (int)&phy))
+      return LTQ_ERROR;
+
+   return GSW_statusOk;
+   \endcode
+*/
+#define GSW_MDIO_DATA_WRITE	_IOW(GSW_COMMON_MAGIC, 0x25, GSW_MDIO_data_t)
+
+/**
+   \brief Read MMD Ethernet PHY register over the MDIO Interface
+   attached to the switch device. This function allows various
+   kinds of information to be read out for any attached device
+   by register and device addressing. The 'nData' value (\ref
+   GSW_MMD_data_t) contains the read MMD device register.
+   A write operation can be done using \ref
+   GSW_MMD_DATA_WRITE.
+
+   \param GSW_MMD_data_t Pointer to
+          \ref GSW_MMD_data_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MMD_DATA_READ	_IOWR(GSW_COMMON_MAGIC, 0x26, GSW_MMD_data_t)
+
+/**
+   \brief Write MMD Ethernet PHY register over the MDIO Interface
+   attached to the switch device. This function allows
+   configuration of any attached device by MMD register and
+   device addressing. This applies to external and internal
+   Ethernet PHYs as well. The 'nData' value (\ref
+   GSW_MMD_data_t) is directly written to the device
+   register. A read operation can be performed using \ref
+   GSW_MMD_DATA_READ.
+
+   \param GSW_MMD_data_t Pointer to \ref
+          GSW_MMD_data_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MMD_DATA_WRITE	_IOW(GSW_COMMON_MAGIC, 0x27, GSW_MMD_data_t)
+
+
+/**
+   \brief Set the Wake-on-LAN configuration.
+   The parameters can be read using \ref GSW_WOL_CFG_GET.
+
+   \param GSW_WoL_Cfg_t Pointer to \ref GSW_WoL_Cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_WOL_CFG_SET	_IOW(GSW_WOL_MAGIC, 0x02, GSW_WoL_Cfg_t)
+
+/**
+   \brief Read the Wake-on-LAN configuration.
+   The parameters can be modified using \ref GSW_WOL_CFG_SET.
+
+   \param GSW_WoL_Cfg_t Pointer to \ref GSW_WoL_Cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_WOL_CFG_GET	_IOWR(GSW_WOL_MAGIC, 0x01, GSW_WoL_Cfg_t)
+
+/**
+   \brief Set the current Wake-On-LAN status for a dedicated port. The
+   Wake-On-LAN specific parameter can be configured
+   using \ref GSW_WOL_CFG_SET.
+
+   \param GSW_WoL_PortCfg_t Pointer to \ref GSW_WoL_PortCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_WOL_PORT_CFG_SET	_IOW(GSW_WOL_MAGIC, 0x04, GSW_WoL_PortCfg_t)
+
+/**
+   \brief Read out the current status of the Wake-On-LAN feature
+   on a dedicated port. This status can be changed
+   using \ref GSW_WOL_PORT_CFG_SET.
+   The Wake-On-LAN specific parameter can be configured
+   using \ref GSW_WOL_CFG_SET.
+
+   \param GSW_WoL_PortCfg_t Pointer to \ref GSW_WoL_PortCfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_WOL_PORT_CFG_GET	_IOWR(GSW_WOL_MAGIC, 0x03, GSW_WoL_PortCfg_t)
+
+/*@}*/ /* GSW_IOCTL_OAM */
+
+/** \addtogroup GSW_IOCTL_RMON */
+/*@{*/
+
+/**
+   \brief Read out the Ethernet port statistic counter (RMON counter).
+   The zero-based 'nPortId' structure element describes the physical switch
+   port for the requested statistic information.
+
+   \param GSW_RMON_Port_cnt_t  Pointer to pre-allocated
+   \ref GSW_RMON_Port_cnt_t structure. The structure element 'nPortId' is
+   an input parameter that describes from which port to read the RMON counter.
+   All remaining structure elements are filled with the counter values.
+
+   \remarks The function returns an error in case the given 'nPortId' is
+   out of range.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_RMON_PORT_GET	_IOWR(GSW_RMON_MAGIC, 0x1, GSW_RMON_Port_cnt_t)
+
+/**
+   \brief Clears all or specific identifier (e.g. Port Id or Meter Id) Statistic counter (RMON counter).
+
+   \param GSW_RMON_clear_t  Pointer to a pre-allocated
+   \ref GSW_RMON_clear_t structure. The structure element 'nRmonId' is
+   an input parameter stating on which identifier to clear RMON counters.
+
+   \remarks The function returns an error in case the given 'nRmonId' is
+   out of range for given 'nRmonType'
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_RMON_CLEAR	_IOW(GSW_RMON_MAGIC, 0x07, GSW_RMON_clear_t)
+
+/**
+   \brief Clears all or specific identifier (e.g. Port Id or Meter Id) Statistic counter (RMON counter).
+
+   \param GSW_RMON_extendGet_t  Pointer to a pre-allocated
+   \ref GSW_RMON_clear_t structure. The structure element 'nRmonId' is
+   an input parameter stating on which identifier to clear RMON counters.
+
+   \remarks The function returns an error in case the given 'nRmonId' is
+   out of range for given 'nRmonType'
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_RMON_TFLOW_CLEAR _IOW(GSW_RMON_MAGIC, 0x0A, GSW_RMON_extendGet_t)
+
+/**
+   \brief Sets TFLOW counter mode type.
+
+   \param GSW_TflowCmodeConf_t  Pointer to a pre-allocated
+   \ref GSW_RMON_clear_t structure.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_TFLOW_COUNT_MODE_SET _IOW(GSW_RMON_MAGIC, 0x0B, GSW_TflowCmodeConf_t)
+
+/**
+   \brief Sets TFLOW counter mode type.
+
+   \param GSW_TflowCmodeConf_t  Pointer to a pre-allocated
+   \ref GSW_RMON_clear_t structure.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_TFLOW_COUNT_MODE_GET _IOW(GSW_RMON_MAGIC, 0x0C, GSW_TflowCmodeConf_t)
+
+/**
+   \brief Configures a Traffic Statistic Counter (RMON counter).
+
+   \param GSW_RMON_mode_t  Pointer to a pre-allocated
+   \ref GSW_RMON_mode_t structure. The structure elements 'eRmonType' and 'eRmonMode' are input parameters to set RMON counting mode to bytes or Packet based.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+
+#define GSW_RMON_MODE_SET	_IOW(GSW_RMON_MAGIC, 0x02, GSW_RMON_mode_t)
+
+/**
+   \brief Read out an Interface statistic counter (RMON counter).
+
+   \param GSW_RMON_If_cnt_t  Pointer to pre-allocated Statistics placeholder
+   \ref GSW_RMON_If_cnt_t structure. The Interface Counter Index element 'nIfId' is an input parameter that describes which Interface RMON counters to be read.
+   All remaining structure elements will be returned filled with the counter values.
+
+   \remarks The function returns an error in case the given 'nIfId' is
+   out of range.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_RMON_IF_GET	_IOWR(GSW_RMON_MAGIC, 0x05, GSW_RMON_If_cnt_t)
+
+/**
+   \brief Read out the Redirected statistic counter (RMON counter).
+
+   \param GSW_RMON_Redirect_cnt_t  Pointer to pre-allocated stats placeholder
+   \ref GSW_RMON_Redirect_cnt_t structure. There is no input and all combined redirected counters are returned back.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_RMON_REDIRECT_GET	_IOWR(GSW_RMON_MAGIC, 0x04, GSW_RMON_Redirect_cnt_t)
+
+/**
+   \brief Read out the Routed statistic counter (RMON counter) on Routed port. These counters are applicable to PAE only.
+
+   \param GSW_RMON_Route_cnt_t  Pointer to pre-allocated stats placeholder
+   \ref GSW_RMON_Route_cnt_t structure. The Redirected Port Id element 'nRoutedPortId' is an input parameter for which  RMON counters to be read.
+   All remaining structure elements will be returned filled with the counter values.
+
+   \remarks The function returns an error in case the given 'nRoutedPortId' is
+   out of range.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_RMON_ROUTE_GET	_IOWR(GSW_RMON_MAGIC, 0x06, GSW_RMON_Route_cnt_t)
+
+/**
+   \brief Read out the Meter Instance statistic counter (RMON counter).
+   The zero-based 'nMeterId' structure element describes the Meter Identifier
+   instance for the requested statistic information.
+
+   \param GSW_RMON_Meter_cnt_t  Pointer to pre-allocated stats placeholder
+   \ref GSW_RMON_Meter_cnt_t structure. The structure element 'nMeterId' is
+   an input parameter that describes from which Meter to read the RMON counter.
+   All remaining structure elements are filled with the counter values.
+
+   \remarks The function returns an error in case the given 'nMeterId' is
+   out of range.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+
+#define GSW_RMON_METER_GET	_IOWR(GSW_RMON_MAGIC, 0x03, GSW_RMON_Meter_cnt_t)
+
+/*@}*/ /* GSW_IOCTL_RMON */
+/** \addtogroup GSW_IOCTL_PMAC */
+/*@{*/
+
+/**
+   \brief Configures the Backpressure Mapping Table for PMAC.
+   It is used to configure backpressure mapping table between Tx Queues for Egress and Rx Ports for Ingress congestion on given DMA channel.
+   The Backpressure mapping can also be read using \ref GSW_PMAC_BM_CFG_GET.
+
+   \param GSW_PMAC_BM_Cfg_t Pointer to a
+      Backpressure mapping configuration \ref GSW_PMAC_BM_Cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PMAC_BM_CFG_SET	_IOW(GSW_PMAC_MAGIC, 0x04, GSW_PMAC_BM_Cfg_t)
+
+/**
+   \brief Queries the Backpressure Mapping Table for PMAC.
+   It is used to read backpressure mapping table between Tx Queues for Egress and Rx Ports for Ingress congestion on given DMA channel.
+   The mapping config can be written using \ref GSW_PMAC_BM_CFG_SET.
+
+   \param GSW_PMAC_BM_Cfg_t Pointer to a
+      Backpressure mapping configuration \ref GSW_PMAC_BM_Cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PMAC_BM_CFG_GET	_IOWR(GSW_PMAC_MAGIC, 0x05, GSW_PMAC_BM_Cfg_t)
+
+/**
+   \brief Configures the Ingress PMAC Attributes Config for Receive DMA Channel.
+   It is used to configure ingress attributes on given Receive DMA channel.
+   The PMAC Ingress config can also be read using \ref GSW_PMAC_IG_CFG_GET.
+
+   \param GSW_PMAC_Ig_Cfg_t Pointer to a
+      Ingress PMAC Attributes configuration \ref GSW_PMAC_Ig_Cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PMAC_IG_CFG_SET	_IOWR(GSW_PMAC_MAGIC, 0x06, GSW_PMAC_Ig_Cfg_t)
+
+/**
+   \brief Queries the Ingress PMAC Attributes Config for given receive DMA channel.
+   It is used to read ingress PMAC attributes config on given DMA Rx channel.
+   The PMAC Ingress config can also be set using \ref GSW_PMAC_IG_CFG_SET.
+
+   \param GSW_PMAC_Ig_Cfg_t Pointer to a
+      Ingress PMAC Attributes configuration \ref GSW_PMAC_Ig_Cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PMAC_IG_CFG_GET	_IOWR(GSW_PMAC_MAGIC, 0x07, GSW_PMAC_Ig_Cfg_t)
+
+/**
+   \brief Configures the Egress Attributes Config for a given PMAC port.
+   It is used to configure egress attributes on given PMAC port.
+   The PMAC Egress config can also be read using \ref GSW_PMAC_EG_CFG_GET.
+
+   \param GSW_PMAC_Eg_Cfg_t Pointer to a
+      Egress PMAC Attributes configuration \ref GSW_PMAC_Eg_Cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PMAC_EG_CFG_SET	_IOWR(GSW_PMAC_MAGIC, 0x08, GSW_PMAC_Eg_Cfg_t)
+
+/**
+   \brief Queries the Egress Attributes Config for given PMAC port.
+   It is used to read egress attributes config on given PMAC port.
+   The PMAC Egress config can also be set using \ref GSW_PMAC_EG_CFG_SET.
+
+   \param GSW_PMAC_Eg_Cfg_t Pointer to a
+      Egress PMAC Attributes configuration \ref GSW_PMAC_Eg_Cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PMAC_EG_CFG_GET	_IOWR(GSW_PMAC_MAGIC, 0x09, GSW_PMAC_Eg_Cfg_t)
+
+/**
+   \brief Reads the Counters for given DMA Channel Identifier associated to PMAC.
+   It is used to read ingress statistics counters providing discarded packets and bytes on given PMAC port.
+
+   \param GSW_PMAC_Cnt_t Pointer to a
+      Statistics Counters of DMA channel associated to PMAC \ref GSW_PMAC_Cnt_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PMAC_COUNT_GET	_IOWR(GSW_PMAC_MAGIC, 0x01, GSW_PMAC_Cnt_t)
+
+/**
+   \brief Writes the global PMAC settings applicable to GSWIP-3.0 PMAC ports.
+   It is used to configure the global settings such as Padding, Checksum, Length and Egress PMAC Selector fields.
+
+   \param GSW_PMAC_Glbl_Cfg_t Pointer to a
+      global config of PMAC \ref GSW_PMAC_Glbl_Cfg_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PMAC_GLBL_CFG_SET	_IOWR(GSW_PMAC_MAGIC, 0x02, GSW_PMAC_Glbl_Cfg_t)
+
+/**
+   \brief Reads the global PMAC settings currently configured to GSWIP-3.0 PMAC ports.
+   It is used to configure the global stetinsg such as PAdding, Checksum, Length and Egress PMAC Selector fields.
+
+   \param GSW_PMAC_Glbl_Cfg_t Pointer to a
+      current global config of PMAC \ref GSW_PMAC_Glbl_Cfg_t (returned).
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PMAC_GLBL_CFG_GET	_IOR(GSW_PMAC_MAGIC, 0x03, GSW_PMAC_Glbl_Cfg_t)
+
+
+/*@}*/ /* GSW_IOCTL_PMAC */
+
+/** \addtogroup GSW_IOCTL_GSWIP31 */
+/*@{*/
+/**
+   \brief Allocate Extended VLAN Configuration block. Valid for GSWIP-3.1.
+   It allocates consecutive VLAN configuration entries and return the block ID
+   for further operations: \ref GSW_EXTENDEDVLAN_FREE, \ref GSW_EXTENDEDVLAN_SET
+   and \ref GSW_EXTENDEDVLAN_GET.
+
+   \param GSW_EXTENDEDVLAN_alloc_t Pointer to \ref GSW_EXTENDEDVLAN_alloc_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_EXTENDEDVLAN_ALLOC	_IOWR(GSW_EXVLAN_MAGIC, 0x01, GSW_EXTENDEDVLAN_alloc_t)
+/**
+   \brief Release Extended VLAN Configuration block. Valid for GSWIP-3.1.
+   It is used to release Extended VLAN Configuration block allocated by
+   \ref GSW_EXTENDEDVLAN_ALLOC.
+
+   \param GSW_EXTENDEDVLAN_alloc_t Pointer to \ref GSW_EXTENDEDVLAN_alloc_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_EXTENDEDVLAN_FREE	_IOWR(GSW_EXVLAN_MAGIC, 0x04, GSW_EXTENDEDVLAN_alloc_t)
+
+/**
+   \brief Set Extended VLAN Configuration entry. Valid for GSWIP-3.1.
+   It is used to set Extended VLAN Configuration entry with index
+   \ref GSW_EXTENDEDVLAN_config_t::nEntryIndex, ranging between 0 and
+   \ref GSW_EXTENDEDVLAN_alloc_t::nNumberOfEntries - 1, with valid
+   \ref GSW_EXTENDEDVLAN_config_t::nExtendedVlanBlockId returned by
+   \ref GSW_EXTENDEDVLAN_ALLOC.
+   If \ref GSW_EXTENDEDVLAN_config_t::nExtendedVlanBlockId is
+   \ref INVALID_HANDLE, this is absolute index of Extended VLAN Configuration
+   entry in hardware, used for debugging purpose.
+
+   \param GSW_EXTENDEDVLAN_config_t Pointer to \ref GSW_EXTENDEDVLAN_config_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_EXTENDEDVLAN_SET	_IOWR(GSW_EXVLAN_MAGIC, 0x02, GSW_EXTENDEDVLAN_config_t)
+
+/**
+   \brief Get Extended VLAN Configuration entry. Valid for GSWIP-3.1.
+   It is used to get Extended VLAN Configuration entry with index
+   \ref GSW_EXTENDEDVLAN_config_t::nEntryIndex, ranging between 0 and
+   \ref GSW_EXTENDEDVLAN_alloc_t::nNumberOfEntries - 1, with valid
+   \ref GSW_EXTENDEDVLAN_config_t::nExtendedVlanBlockId returned by
+   \ref GSW_EXTENDEDVLAN_ALLOC.
+   If \ref GSW_EXTENDEDVLAN_config_t::nExtendedVlanBlockId is
+   \ref INVALID_HANDLE, this is absolute index of Extended VLAN Configuration
+   entry in hardware, used for debugging purpose.
+
+   \param GSW_EXTENDEDVLAN_config_t Pointer to \ref GSW_EXTENDEDVLAN_config_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_EXTENDEDVLAN_GET	_IOWR(GSW_EXVLAN_MAGIC, 0x03, GSW_EXTENDEDVLAN_config_t)
+
+/**
+   \brief Allocate VLAN Filter block. Valid for GSWIP-3.1.
+   It allocates consecutive VLAN Filter entries and return the block ID
+   for further operations: \ref GSW_VLANFILTER_FREE, \ref GSW_VLANFILTER_SET
+   and \ref GSW_VLANFILTER_GET.
+
+   \param GSW_VLANFILTER_alloc_t Pointer to \ref GSW_VLANFILTER_alloc_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_VLANFILTER_ALLOC	_IOWR(GSW_VLANFILTER_MAGIC, 0x01, GSW_VLANFILTER_alloc_t)
+
+/**
+   \brief Delete VLAN Filter Block. Valid for GSWIP-3.1.
+   It is used to release VLAN Filter block allocated by
+   \ref GSW_VLANFILTER_ALLOC.
+
+   \param GSW_VLANFILTER_alloc_t Pointer to \ref GSW_VLANFILTER_alloc_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+
+#define GSW_VLANFILTER_FREE	_IOWR(GSW_VLANFILTER_MAGIC, 0x04, GSW_VLANFILTER_alloc_t)
+
+/**
+   \brief Set VLAN Filter entry. Valid for GSWIP-3.1.
+   It is used to set VLAN Filter entry with index
+   \ref GSW_VLANFILTER_config_t::nEntryIndex, ranging between 0 and
+   \ref GSW_VLANFILTER_alloc_t::nNumberOfEntries - 1, with valid
+   \ref GSW_VLANFILTER_config_t::nVlanFilterBlockId returned by
+   \ref GSW_VLANFILTER_ALLOC.
+   If \ref GSW_VLANFILTER_config_t::nVlanFilterBlockId is \ref INVALID_HANDLE,
+   this is absolute index of VLAN Filter entry in hardware, used for debugging
+   purpose.
+
+   \param GSW_VLANFILTER_config_t Pointer to \ref GSW_VLANFILTER_config_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+
+#define GSW_VLANFILTER_SET	_IOWR(GSW_VLANFILTER_MAGIC, 0x02, GSW_VLANFILTER_config_t)
+
+/**
+   \brief Get VLAN Filter Entry. Valid for GSWIP-3.1.
+   It is used to get VLAN filter entry with index
+   \ref GSW_VLANFILTER_config_t::nEntryIndex, ranging between 0 and
+   \ref GSW_VLANFILTER_alloc_t::nNumberOfEntries - 1, with valid
+   \ref GSW_VLANFILTER_config_t::nVlanFilterBlockId returned by
+   \ref GSW_VLANFILTER_ALLOC.
+   If \ref GSW_VLANFILTER_config_t::nVlanFilterBlockId is \ref INVALID_HANDLE,
+   this is absolute index of VLAN Filter entry in hardware, used for debugging
+   purpose.
+
+   \param GSW_VLANFILTER_config_t Pointer to \ref GSW_VLANFILTER_config_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+
+#define GSW_VLANFILTER_GET	_IOWR(GSW_VLANFILTER_MAGIC, 0x03, GSW_VLANFILTER_config_t)
+
+/**
+   \brief Config CTP Port. Valid for GSWIP-3.1.
+   It is used to setup CTP port.
+
+   \param GSW_CTP_portConfig_t Pointer to \ref GSW_CTP_portConfig_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+
+//#define GSW_CTP_PORT_CONFIG_SET	_IOW(GSW_CTP_MAGIC, 0x05, GSW_CTP_portConfig_t)
+#define GSW_CTP_PORT_CONFIG_SET	_IOWR(GSW_CTP_MAGIC, 0x05, GSW_CTP_portConfig_t)
+/**
+   \brief get configuration of CTP Port. Valid for GSWIP-3.1.
+   It is used to retrieve CTP port configuration.
+
+   \param GSW_CTP_portConfig_t Pointer to \ref GSW_CTP_portConfig_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_CTP_PORT_CONFIG_GET	_IOWR(GSW_CTP_MAGIC, 0x06, GSW_CTP_portConfig_t)
+
+/**
+   \brief Reset configuration of CTP (Connectivity Termination Point). Valid for GSWIP-3.1.
+   It is used to reset CTP configuration and, if necessary, release resources
+   such as Extended VLAN, Meter, etc. Bridge Port ID will not be changed.
+   If \ref GSW_CTP_portConfig_t::eMask has
+   \ref GSW_CtpPortConfigMask_t::GSW_CTP_PORT_CONFIG_MASK_FORCE,
+   \ref GSW_CTP_portConfig_t::nLogicalPortId is ignored and
+   \ref GSW_CTP_portConfig_t::nSubIfIdGroup is absolute index of CTP in hardware
+   for debug purpose, bypassing any check.
+
+   \param GSW_CTP_portConfig_t Pointer to \ref GSW_CTP_portConfig_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_CTP_PORT_CONFIG_RESET _IOWR(GSW_CTP_MAGIC, 0x07, GSW_CTP_portConfig_t)
+
+/**
+   \brief Allocate Bridge Port. Valid for GSWIP-3.1.
+   It is used to allocate a bridge port.
+
+   \param GSW_BRIDGE_portAlloc_t Pointer to \ref GSW_BRIDGE_portAlloc_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_BRIDGE_PORT_ALLOC	_IOWR(GSW_BRDGPORT_MAGIC, 0x01, GSW_BRIDGE_portAlloc_t)
+
+/**
+   \brief Delete Bridge Port. Valid for GSWIP-3.1.
+   It is used to release bridge port allocated with
+   \ref GSW_BRIDGE_PORT_CONFIG_SET.
+
+   \param GSW_BRIDGE_portAlloc_t Pointer to \ref GSW_BRIDGE_portAlloc_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+
+#define GSW_BRIDGE_PORT_FREE	_IOWR(GSW_BRDGPORT_MAGIC, 0x04, GSW_BRIDGE_portAlloc_t)
+
+/**
+   \brief Config Bridge Port. Valid for GSWIP-3.1.
+   It is used to configure bridge port. If \ref GSW_BRIDGE_portConfig_t::eMask
+   has \ref GSW_BridgePortConfigMask_t::GSW_BRIDGE_PORT_CONFIG_MASK_FORCE,
+   \ref GSW_BRIDGE_portConfig_t::nBridgePortId is absolute index of Bridge Port
+   in hardware for debug purpose, bypassing any check.
+
+   \param GSW_BRIDGE_portConfig_t Pointer to \ref GSW_BRIDGE_portConfig_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+
+//#define GSW_BRIDGE_PORT_CONFIG_SET	_IOW(GSW_BRDGPORT_MAGIC, 0x02, GSW_BRIDGE_portConfig_t)
+#define GSW_BRIDGE_PORT_CONFIG_SET	_IOWR(GSW_BRDGPORT_MAGIC, 0x02, GSW_BRIDGE_portConfig_t)
+
+/**
+   \brief get configuration of Bridge Port. Valid for GSWIP-3.1.
+   It is used to retrieve bridge port configuration.
+   If \ref GSW_BRIDGE_portConfig_t::eMask has
+   \ref GSW_BridgePortConfigMask_t::GSW_BRIDGE_PORT_CONFIG_MASK_FORCE,
+   \ref GSW_BRIDGE_portConfig_t::nBridgePortId is absolute index of Bridge Port
+   in hardware for debug purpose, bypassing any check
+
+   \param GSW_BRIDGE_portConfig_t Pointer to \ref GSW_BRIDGE_portConfig_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_BRIDGE_PORT_CONFIG_GET	_IOWR(GSW_BRDGPORT_MAGIC, 0x03, GSW_BRIDGE_portConfig_t)
+
+/**
+   \brief Allocate Bridge. Valid for GSWIP-3.1.
+   It is used to allocate a bridge. Bridge 0 is always available as default
+   bridge.
+
+   \param GSW_BRIDGE_alloc_t Pointer to \ref GSW_BRIDGE_alloc_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_BRIDGE_ALLOC _IOWR(GSW_BRDG_MAGIC, 0x01, GSW_BRIDGE_alloc_t)
+
+/**
+   \brief Delete Bridge. Valid for GSWIP-3.1.
+   It is used to release bridge allocated with \ref GSW_BRIDGE_ALLOC.
+
+   \param GSW_BRIDGE_alloc_t Pointer to \ref GSW_BRIDGE_alloc_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+
+#define GSW_BRIDGE_FREE	_IOWR(GSW_BRDG_MAGIC, 0x04, GSW_BRIDGE_alloc_t)
+
+/**
+   \brief Config Bridge. Valid for GSWIP-3.1.
+   It is used to configure bridge. If \ref GSW_BRIDGE_config_t::eMask has
+   \ref GSW_BridgeConfigMask_t::GSW_BRIDGE_CONFIG_MASK_FORCE,
+   \ref GSW_BRIDGE_config_t::nBridgeId is absolute index of Bridge (FID) in
+   hardware for debug purpose, bypassing any check.
+
+   \param GSW_BRIDGE_config_t Pointer to \ref GSW_BRIDGE_config_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_BRIDGE_CONFIG_SET	_IOW(GSW_BRDG_MAGIC, 0x02, GSW_BRIDGE_config_t)
+
+/**
+   \brief get configuration of Bridge. Valid for GSWIP-3.1.
+   It is used to retrieve bridge configuration.
+   If \ref GSW_BRIDGE_config_t::eMask has
+   \ref GSW_BridgeConfigMask_t::GSW_BRIDGE_CONFIG_MASK_FORCE,
+   \ref GSW_BRIDGE_config_t::nBridgeId is absolute index of Bridge (FID) in
+   hardware for debug purpose, bypassing any check.
+
+   \param GSW_BRIDGE_config_t Pointer to \ref GSW_BRIDGE_config_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+
+#define GSW_BRIDGE_CONFIG_GET	_IOWR(GSW_BRDG_MAGIC, 0x03, GSW_BRIDGE_config_t)
+/**
+   \brief Assign CTP to Logical Port. Valid for GSWIP-3.1.
+   It is used to allocate a range of CTP and associate them to Logical Port.
+   Apart from setting proper mode, it will do basic mapping between CTP and
+   Bridge Port, then enable SDMA to allow ingress traffic from this port.
+
+   \param GSW_CTP_portAssignment_t Pointer to \ref GSW_CTP_portAssignment_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_CTP_PORT_ASSIGNMENT_ALLOC	_IOWR(GSW_CTP_MAGIC, 0x01, GSW_CTP_portAssignment_t)
+
+/**
+   \brief Free CTP from Logical Port. Valid for GSWIP-3.1.
+   It is used to stop association between CTP and Logical port. And it will stop
+   SDMA so that the ingress traffic from this port is stopped.
+*/
+#define GSW_CTP_PORT_ASSIGNMENT_FREE	_IOW(GSW_CTP_MAGIC, 0x02, GSW_CTP_portAssignment_t)
+
+/**
+   \brief Assign CTP Ports to logical port. Valid for GSWIP-3.1.
+   It is used to associate a range of CTP ports to logical port and set proper
+   mode.
+
+   \param GSW_CTP_portAssignment_t Pointer to \ref GSW_CTP_portAssignment_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_CTP_PORT_ASSIGNMENT_SET	_IOW(GSW_CTP_MAGIC, 0x03, GSW_CTP_portAssignment_t)
+
+/**
+   \brief Get CTP Ports assignment from logical port. Valid for GSWIP-3.1.
+   It is used to retrieve CTP ports range of logical port and the mode of port.
+
+   \param GSW_CTP_portAssignment_t Pointer to \ref GSW_CTP_portAssignment_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_CTP_PORT_ASSIGNMENT_GET	_IOWR(GSW_CTP_MAGIC, 0x04, GSW_CTP_portAssignment_t)
+
+/**
+   \brief Allocate Meter.
+   This is a part of APIs to manage meters. This API works in 2 modes. If
+   \ref GSW_QoS_meterCfg_t::nMeterId is \ref INVALID_HANDLE, this API will
+   allocate a free meter, config it with all parameters in
+   \ref GSW_QoS_meterCfg_t, and return the meter ID in
+   \ref GSW_QoS_meterCfg_t::nMeterId. Otherwise,
+   \ref GSW_QoS_meterCfg_t::nMeterId should be a valid meter ID, and this API
+   increase the reference counter of this meter. Other fields are ignored.
+   This API is wrapper of \ref GSW_QOS_METER_CFG_SET with meter resource
+   management.
+
+   \param GSW_QoS_meterCfg_t Pointer to \ref GSW_QoS_meterCfg_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_METER_ALLOC   _IOWR(GSW_QOS_MAGIC, 0x30, GSW_QoS_meterCfg_t)
+
+/**
+   \brief Free Meter.
+   Decrease reference counter of the meter. If reference counter is 0, disable
+   the meter then free it.
+
+   \param u32 Meter ID.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_METER_FREE   _IOW(GSW_QOS_MAGIC, 0x31, u32)
+
+/**
+   \brief Update Color Marking Table.
+   Should be used to setup color marking table at early stage.
+
+   \param GSW_QoS_colorMarkingEntry_t Pointer to \ref GSW_QoS_colorMarkingEntry_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+//#define GSW_QOS_COLOR_MARKING_TABLE_SET   _IOW(GSW_QOS_MAGIC, 0x2C, GSW_QoS_colorMarkingEntry_t)
+#define GSW_QOS_COLOR_MARKING_TABLE_SET   _IOWR(GSW_QOS_MAGIC, 0x2C, GSW_QoS_colorMarkingEntry_t)
+
+/**
+   \brief Get Color Marking Table.
+
+   \param GSW_QoS_colorMarkingEntry_t Pointer to \ref GSW_QoS_colorMarkingEntry_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_COLOR_MARKING_TABLE_GET   _IOWR(GSW_QOS_MAGIC, 0x2D, GSW_QoS_colorMarkingEntry_t)
+
+/**
+   \brief Update Color Remarking Table.
+   Should be used to setup color remarking table at early stage.
+
+   \param GSW_QoS_colorRemarkingEntry_t Pointer to \ref GSW_QoS_colorRemarkingEntry_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_COLOR_REMARKING_TABLE_SET   _IOW(GSW_QOS_MAGIC, 0x2E, GSW_QoS_colorRemarkingEntry_t)
+
+/**
+   \brief Get Color Remarking Table.
+
+   \param GSW_QoS_colorRemarkingEntry_t Pointer to \ref GSW_QoS_colorRemarkingEntry_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_QOS_COLOR_REMARKING_TABLE_GET   _IOWR(GSW_QOS_MAGIC, 0x2F, GSW_QoS_colorRemarkingEntry_t)
+
+/**
+   \brief Get DSCP to PCP Mapping Table.
+
+   \param GSW_DSCP2PCP_map_t Pointer to \ref GSW_DSCP2PCP_map_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_DSCP2PCP_MAP_SET _IOWR(GSW_QOS_MAGIC, 0x32, GSW_DSCP2PCP_map_t)
+
+#define GSW_DSCP2PCP_MAP_GET _IOWR(GSW_QOS_MAGIC, 0x33, GSW_DSCP2PCP_map_t)
+
+/**
+   \brief Get P-mapper Configuration.
+
+   \param GSW_PMAPPER_t Pointer to \ref GSW_PMAPPER_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PMAPPER_SET _IOWR(GSW_QOS_MAGIC, 0x34, GSW_PMAPPER_t)
+
+#define GSW_PMAPPER_GET _IOWR(GSW_QOS_MAGIC, 0x35, GSW_PMAPPER_t)
+
+/**
+   \brief Set Default MAC Filter.
+
+   \param GSW_MACFILTER_default_t Pointer to \ref GSW_MACFILTER_default_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_DEFAUL_MAC_FILTER_SET _IOW(GSW_MAC_MAGIC, 0x06, GSW_MACFILTER_default_t)
+
+/**
+   \brief Get Default MAC Filter.
+
+   \param GSW_MACFILTER_default_t Pointer to \ref GSW_MACFILTER_default_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_DEFAUL_MAC_FILTER_GET _IOWR(GSW_MAC_MAGIC, 0x07, GSW_MACFILTER_default_t)
+/*@}*/ /* GSW_IOCTL_GSWIP31 */
+
+
+
+/**
+	\brief Following are for Debug purpose only
+
+	\param GSW_debug_t Pointer to \ref GSW_debug_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+
+#define GSW_DEBUG_CTPTABLE_STATUS 			_IOWR(GSW_DEBUG_MAGIC, 0x01, GSW_debug_t)
+#define GSW_DEBUG_BRDGPORTTABLE_STATUS 		_IOWR(GSW_DEBUG_MAGIC, 0x02, GSW_debug_t)
+#define GSW_DEBUG_BRDGTABLE_STATUS 			_IOWR(GSW_DEBUG_MAGIC, 0x03, GSW_debug_t)
+#define GSW_DEBUG_EXVLANTABLE_STATUS		_IOWR(GSW_DEBUG_MAGIC, 0x04, GSW_debug_t)
+#define GSW_DEBUG_VLANFILTERTABLE_STATUS	_IOWR(GSW_DEBUG_MAGIC, 0x05, GSW_debug_t)
+#define GSW_DEBUG_METERTABLE_STATUS 		_IOWR(GSW_DEBUG_MAGIC, 0x06, GSW_debug_t)
+#define GSW_DEBUG_DSCP2PCPTABLE_STATUS		_IOWR(GSW_DEBUG_MAGIC, 0x07, GSW_debug_t)
+#define GSW_DEBUG_PMAPPER_STATUS 			_IOWR(GSW_DEBUG_MAGIC, 0x08, GSW_debug_t)
+#define GSW_DEBUG_PMAC_EG					_IOWR(GSW_DEBUG_MAGIC, 0x09, GSW_debug_t)
+#define GSW_DEBUG_PMAC_IG 					_IOWR(GSW_DEBUG_MAGIC, 0x0A, GSW_debug_t)
+#define GSW_DEBUG_DEF_QMAP					_IOWR(GSW_DEBUG_MAGIC, 0x0B, GSW_debug_t)
+#define GSW_DEBUG_DEF_BYP_QMAP 				_IOWR(GSW_DEBUG_MAGIC, 0x0C, GSW_debug_t)
+#define GSW_DEBUG_PMAC_BP 					_IOWR(GSW_DEBUG_MAGIC, 0x0D, GSW_debug_t)
+#define GSW_DEBUG_LP_STATISTICS 			_IOWR(GSW_DEBUG_MAGIC, 0x0E, GSW_debug_t)
+#define GSW_DEBUG_CTP_STATISTICS 			_IOWR(GSW_DEBUG_MAGIC, 0x0F, GSW_debug_t)
+/**
+   \brief XGMAC Cfg Commands to Read and write operation
+   GSW_XGMAC_CFG.
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_XGMAC_CFG	_IOWR(GSW_DEBUG_MAGIC, 0x10, GSW_MAC_cfg_t)
+
+/**
+   \brief GSWSS Cfg Commands to Read and write operation
+   GSW_GSWSS_CFG.
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_GSWSS_CFG	_IOWR(GSW_DEBUG_MAGIC, 0x11, GSW_MAC_cfg_t)
+
+/**
+   \brief LMAC Cfg Commands to Read and write operation
+   GSW_LMAC_CFG.
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_LMAC_CFG	_IOWR(GSW_DEBUG_MAGIC, 0x12, GSW_MAC_cfg_t)
+
+/**
+   \brief MACSEC Cfg Commands to Read and write operation
+   GSW_MACSEC_CFG.
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_MACSEC_CFG	_IOWR(GSW_DEBUG_MAGIC, 0x13, GSW_MAC_cfg_t)
+/**
+   \brief DUMP MEM operation
+   GSW_DUMP_MEM.
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_DUMP_MEM	_IOWR(GSW_DEBUG_MAGIC, 0x14, GSW_table_t)
+
+#define GSW_DEBUG_PRINT_PCEIRQ_LIST 		_IO(GSW_DEBUG_MAGIC, 0x15)
+#define GSW_DEBUG_RMON_PORT_GET				_IOWR(GSW_DEBUG_MAGIC, 0x16, GSW_Debug_RMON_Port_cnt_t)
+
+/**
+	\brief Following are for GSWIP IRQ operation
+
+	\param GSW_Irq_Op_t Pointer to \ref GSW_Irq_Op_t.
+*/
+
+#define GSW_IRQ_REGISTER 	_IOWR(GSW_IRQ_MAGIC, 0x01, GSW_Irq_Op_t)
+#define GSW_IRQ_UNREGISTER 	_IOWR(GSW_IRQ_MAGIC, 0x02, GSW_Irq_Op_t)
+#define GSW_IRQ_ENABLE 		_IOWR(GSW_IRQ_MAGIC, 0x03, GSW_Irq_Op_t)
+#define GSW_IRQ_DISBALE 	_IOWR(GSW_IRQ_MAGIC, 0x04, GSW_Irq_Op_t)
+
+#endif    /* _LANTIQ_GSW_H_ */
diff --git a/include/net/switch_api/lantiq_gsw_api.h b/include/net/switch_api/lantiq_gsw_api.h
new file mode 100644
index 000000000000..a51f510c5d72
--- /dev/null
+++ b/include/net/switch_api/lantiq_gsw_api.h
@@ -0,0 +1,91 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+
+#ifndef _LTQ_GSW_KERNEL_API_H_
+#define _LTQ_GSW_KERNEL_API_H_
+
+#include "gsw_ioctlcmd_type.h"
+#include "lantiq_gsw.h"
+#include "lantiq_gsw_flow.h"
+#include "lantiq_gsw_routing.h"
+#include "gsw_irq.h"
+#include "gsw_tbl_rw.h"
+
+
+/* Group definitions for Doxygen */
+/** \defgroup ETHSW_KERNELAPI Ethernet Switch Linux Kernel Interface
+    This chapter describes the entire interface to access and
+    configure the various services of the Ethernet switch module of xRX200/xRX300/xRX500 family within the Linux kernel space. */
+
+/*@{*/
+
+/** Definition of the device handle that is retrieved during
+    the \ref gsw_api_kopen call. This handle is used to access the switch
+    device while calling \ref gsw_api_kioctl. */
+typedef unsigned int GSW_API_HANDLE;
+
+/**
+   Request a device handle for a dedicated Ethernet switch device. The switch
+   device is identified by the given device name (e.g. "/dev/switch/1").
+   The device handle is the return value of this function. This handle is
+   used to access the switch parameter and features while
+   calling \ref gsw_api_kioctl. Please call the function
+   \ref gsw_api_kclose to release a device handle that is not needed anymore.
+
+   \param name Pointer to the device name of the requested Ethernet switch device.
+
+   \remarks The client kernel module should check the function return value.
+   A returned zero indicates that the resource allocation failed.
+
+   \return Return the device handle in case the requested device is available.
+   It returns a zero in case the device does not exist or is blocked
+   by another application.
+*/
+GSW_API_HANDLE gsw_api_kopen(char *name);
+
+/**
+   Calls the switch API driver implementation with the given command and the
+   parameter argument. The called Ethernet switch device is identified by the
+   given device handle. This handle was previously requested by
+   calling gsw_api_kopen function.
+
+   \param handle Ethernet switch device handle, given by \ref gsw_api_kopen.
+   \param command Switch API command to perform.
+   \param arg Command arguments. This argument is basically a reference to
+   the command parameter structure.
+
+   \remarks The commands and arguments are the same as normally used over
+   the Linux ioctl interface from user space.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurred.
+*/
+int gsw_api_kioctl(GSW_API_HANDLE handle, unsigned int command, unsigned int arg);
+
+/**
+   Releases an Ethernet switch device handle which was previously
+   allocated by \ref gsw_api_kopen.
+
+   \param handle Ethernet switch device handle, given by \ref gsw_api_kopen.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurred.
+*/
+int gsw_api_kclose(GSW_API_HANDLE handle);
+
+/*@}*/ /* GSWIP_ROUTE_IOCTL */
+
+extern void gsw_api_disable_switch_ports(void);
+
+#endif /* _LTQ_GSW_KERNEL_API_H_ */
diff --git a/include/net/switch_api/lantiq_gsw_flow.h b/include/net/switch_api/lantiq_gsw_flow.h
new file mode 100644
index 000000000000..eef7c2b3b3f0
--- /dev/null
+++ b/include/net/switch_api/lantiq_gsw_flow.h
@@ -0,0 +1,1344 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+
+#ifndef _LANTIQ_ETHSW_FLOW_H_
+#define _LANTIQ_ETHSW_FLOW_H_
+
+/* =================================== */
+/* Global typedef forward declarations */
+/* =================================== */
+
+/* ============================= */
+/* Local Macros & Definitions    */
+/* ============================= */
+
+
+/* Group definitions for Doxygen */
+/** \defgroup GSW_FLOW_GROUP GSWIP Packet Classification Engine (PCE) related APIs
+    \brief This chapter describes the GSWIP's PCE and other low level related APIs.
+*/
+/*@{*/
+
+/** \defgroup GSW_IOCTL_DEBUG Debug Features
+   \brief Switch Registers write and read for any low level operations including debug.
+*/
+/** \defgroup GSW_IOCTL_IRQ Interrupt Handling
+    \brief Configure GSWIP support to configure and read out the interrupt mask and sources.
+*/
+/** \defgroup GSW_IOCTL_SYS GSWIP System Functions
+    \brief This chapter summarizes the functions that are provided to handle system aspects of GSWIP.
+*/
+/** \defgroup GSW_IOCTL_CLASS Packet Classification Engine
+    \brief Configures and controls the classification unit of the GSWIP.
+*/
+
+/*@}*/
+
+/* -------------------------------------------------------------------------- */
+/*                 Structure and Enumeration Type Defintions                  */
+/* -------------------------------------------------------------------------- */
+
+/** \addtogroup GSW_IOCTL_DEBUG */
+/*@{*/
+
+/** \brief Register access parameter to directly read or write switch
+    internal registers.
+    Used by \ref GSW_REGISTER_SET and \ref GSW_REGISTER_GET. */
+typedef struct {
+	/** Register Address Offset for read or write access. */
+	u16	nRegAddr;
+	/** Value to write to or read from 'nRegAddr'. */
+	u16	nData;
+} GSW_register_t;
+
+/*@}*/ /* GSW_IOCTL_DEBUG */
+
+/** \addtogroup GSW_IOCTL_IRQ */
+/*@{*/
+
+/** \brief Interrupt Source Selector.
+    Used by \ref GSW_irq_t. */
+typedef enum {
+	/** Wake-on-LAN Interrupt. The configured packet flow will trigger WoL interrupt.
+	    The parameter 'nPortId' specifies the relative MAC port. */
+	GSW_IRQ_WOL	= 0,
+	/** Port Limit Alert Interrupt. This interrupt is asserted when the number
+	    of learned MAC addresses exceeds the configured limit for
+	    the ingress port.
+	    The parameter 'nPortId' specifies the relative MAC port. */
+	GSW_IRQ_LIMIT_ALERT	= 1,
+	/** Port Lock Alert Interrupt.
+	    This interrupt is asserted when a source MAC address is learned on a
+	    locked port and is received on another port.
+	    The parameter 'nPortId' specifies the relative MAC port. */
+	GSW_IRQ_LOCK_ALERT	= 2
+} GSW_irqSrc_t;
+
+/** \brief Interrupt bits. Depending on the hardware device type, not all interrupts might be available.
+    Used by \ref GSW_IRQ_MASK_GET, \ref GSW_IRQ_MASK_SET,
+    \ref GSW_IRQ_GET and \ref GSW_IRQ_STATUS_CLEAR. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware dependent.
+	    An error code is delivered if the selected port is not
+	    available. This port parameter is needed for some interrupts
+	    that are specified by 'nIrqSrc'. For all other interrupts, this
+	    parameter is "don't care". */
+	u32	nPortId;
+	/** Interrupt Source Type. */
+	GSW_irqSrc_t	eIrqSrc;
+} GSW_irq_t;
+
+/*@}*/ /* GSW_IOCTL_IRQ */
+
+/** \addtogroup GSW_IOCTL_CLASS */
+/*@{*/
+
+/** \brief Rule selection for IPv4/IPv6.
+    Used by \ref GSW_PCE_pattern_t. */
+typedef enum {
+	/** Rule Pattern for IP selection disabled. */
+	GSW_PCE_IP_DISABLED	= 0,
+	/** Rule Pattern for IPv4. */
+	GSW_PCE_IP_V4	= 1,
+	/** Rule Pattern for IPv6. */
+	GSW_PCE_IP_V6	= 2
+} GSW_PCE_IP_t;
+
+/** \brief Select Mode of Sub-Interface ID Field.
+    Used by \ref GSW_PCE_pattern_t. */
+typedef enum {
+	/** Sub Interface ID as defined by GSWIP-3.0. */
+	GSW_PCE_SUBIFID_TYPE_SUBIFID = 0,
+	/** Sub Interface ID group as defined by GSWIP-3.1. */
+	GSW_PCE_SUBIFID_TYPE_GROUP = 1,
+	/** Bridge Port ID as defined by GSWIP-3.1. */
+	GSW_PCE_SUBIFID_TYPE_BRIDGEPORT = 2
+} GSW_PCE_SUBIFID_TYPE_t;
+
+/** \brief Packet Classification Engine Pattern Configuration.
+     GSWIP-3.0 has additional patterns such as Inner IP, Inner DSCP, Inner Protocol, Exclude Mode etc.
+    Used by \ref GSW_PCE_rule_t. */
+typedef struct {
+	/** PCE Rule Index (Upto 512 rules supported in GSWIP-3.0, whereas 64 rules supported in GSWIP-2.x) */
+	int	nIndex;
+
+	/** Index is used (enabled) or set to unused (disabled) */
+	ltq_bool_t	bEnable;
+
+	/** Port ID used  for ingress packet classification */
+	ltq_bool_t	bPortIdEnable;
+	/** Port ID value of incoming packets used for classification */
+	u8	nPortId;
+	/** Exclude Port Id Value - When set exclusion of specified nPortId takes effect.  Available for GSWIP-3.0 only */
+	ltq_bool_t	bPortId_Exclude;
+
+	/** Select mode of sub-interface ID field */
+	GSW_PCE_SUBIFID_TYPE_t eSubIfIdType;
+	/** Incoming Sub-Interface ID Enable - used for GSWIP-3.0 only */
+	ltq_bool_t	bSubIfIdEnable;
+	/** Incoming Sub-Interface ID value - used for GSWIP-3.0 only */
+	u16	nSubIfId;
+	/** Exclude of specified Sub-Interface Id value in nSubIfId - used for GSWIP-3.0 only */
+	ltq_bool_t	bSubIfId_Exclude;
+
+	/** DSCP value used (Outer for GSWIP-3.0) */
+	ltq_bool_t	bDSCP_Enable;
+	/** DSCP value (Outer for GSWIP-3.0) */
+	u8		nDSCP;
+	/** Exclude (Outer) DSCP value used for GSWIP-3.0 only */
+	ltq_bool_t	bDSCP_Exclude;
+
+	/** Inner DSCP value used for GSWIP-3.0 only */
+	ltq_bool_t	bInner_DSCP_Enable;
+	/** Inner DSCP value  for GSWIP-3.0 only */
+	u8		nInnerDSCP;
+	/** Exclude of Inner DSCP (nInnerDSCP) value used for GSWIP-3.0 only */
+	ltq_bool_t	bInnerDSCP_Exclude;
+
+	/** CTAG VLAN PCP n DEI value used */
+	ltq_bool_t	bPCP_Enable;
+	/** CTAG VLAN PCP n DEI value */
+	u8		nPCP;
+	/* Exclude CTAG  value used for GSWIP-3.0 only */
+//   ltq_bool_t	bCTAG_Exclude;
+	/** Exclude CTAG PCP & DEI value used for GSWIP-3.0 only */
+	ltq_bool_t	bCTAG_PCP_DEI_Exclude;
+
+	/** STAG VLAN PCP/DEI value used */
+	ltq_bool_t	bSTAG_PCP_DEI_Enable;
+	/** STAG VLAN PCP value */
+	u8		nSTAG_PCP_DEI;
+	/* Exclude STAG  value used for GSWIP-3.0 only */
+//   ltq_bool_t	bSTAG_Exclude;
+	/** Exclude STAG PCP & DEI value used for GSWIP-3.0 only */
+	ltq_bool_t	bSTAG_PCP_DEI_Exclude;
+
+	/** Packet length used for classification */
+	ltq_bool_t	bPktLngEnable;
+	/** Packet length in bytes */
+	u16		nPktLng;
+	/** Packet length Range (from nPktLng to nPktLngRange) */
+	u16		nPktLngRange;
+	/** Exclude of Packet Length or range value used for GSWIP-3.0 only */
+	ltq_bool_t	bPktLng_Exclude;
+
+	/** Destination MAC address used */
+	ltq_bool_t	bMAC_DstEnable;
+	/** Destination MAC address */
+	u8		nMAC_Dst[6];
+	/** Destination MAC address nibble mask.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u16	nMAC_DstMask;
+	/** Exclude Destination MAC Address used for GSWIP-3.0 only */
+	ltq_bool_t	bDstMAC_Exclude;
+
+	/** Source MAC address used */
+	ltq_bool_t	bMAC_SrcEnable;
+	/** Source MAC address */
+	u8	nMAC_Src[6];
+	/** Source MAC address nibble mask.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u16	nMAC_SrcMask;
+	/** Exclude Source MAC Address used for GSWIP-3.0 only */
+	ltq_bool_t	bSrcMAC_Exclude;
+
+	/** MSB Application field used */
+	ltq_bool_t	bAppDataMSB_Enable;
+	/** MSB Application field.
+	    The first 2 bytes of the packet content following the IP header
+	    for TCP/UDP packets (source port field), or the first 2 bytes of packet content
+	    following the Ethertype for non-IP packets. Any part of this
+	    content can be masked-out by a programmable bit
+	    mask 'nAppMaskRangeMSB'. */
+	u16	nAppDataMSB;
+	/** MSB Application mask/range selection.
+	    If set to LTQ_TRUE, the field 'nAppMaskRangeMSB' is used as a
+	    range parameter, otherwise it is used as a nibble mask field. */
+	ltq_bool_t	bAppMaskRangeMSB_Select;
+	/** MSB Application mask/range. When used as a range parameter,
+	    1 bit represents 1 nibble mask of the 'nAppDataMSB' field.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u16	nAppMaskRangeMSB;
+	/** MSB Application Data Exclude - for GSWIP-3.0 only */
+	ltq_bool_t	bAppMSB_Exclude;
+
+	/** LSB Application used */
+	ltq_bool_t	bAppDataLSB_Enable;
+	/** LSB Application field.
+	    The following 2 bytes of the packet behind the 'nAppDataMSB' field.
+	    This is the destination port field for TCP/UDP packets,
+	    or byte 3 and byte 4 of the packet content following the Ethertype
+	    for non-IP packets. Any part of this content can be masked-out
+	    by a programmable bit mask 'nAppMaskRangeLSB'. */
+	u16	nAppDataLSB;
+	/** LSB Application mask/range selection.
+	    If set to LTQ_TRUE, the field 'nAppMaskRangeLSB' is used as
+	    a range parameter, otherwise it is used as a nibble mask field. */
+	ltq_bool_t	bAppMaskRangeLSB_Select;
+	/** LSB Application mask/range. When used as a range parameter,
+	    1 bit represents 1 nibble mask of the 'nAppDataLSB' field.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u16	nAppMaskRangeLSB;
+	/** LSB Application Data Exclude - for GSWIP-3.0 only */
+	ltq_bool_t	bAppLSB_Exclude;
+
+	/** Destination IP Selection (Outer for GSWIP-3.0). */
+	GSW_PCE_IP_t	eDstIP_Select;
+	/** Destination IP (Outer for GSWIP-3.0) */
+	GSW_IP_t	nDstIP;
+	/** Destination IP Nibble Mask.
+	    1 bit represents 1 nibble mask of the 'nDstIP' field.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u32	nDstIP_Mask;
+	/** Exclude Destination IP Value - used for GSWIP-3.0 only */
+	ltq_bool_t	bDstIP_Exclude;
+
+	/** Inner Destination IP Selection - for GSWIP-3.0 only. */
+	GSW_PCE_IP_t	eInnerDstIP_Select;
+	/** Inner Destination IP  - for GSWIP-3.0 only.*/
+	GSW_IP_t	nInnerDstIP;
+	/** Inner Destination IP Nibble Mask - for GSWIP-3.0 only.
+	    1 bit represents 1 nibble mask of the 'nInnerDstIP' field.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u32	nInnerDstIP_Mask;
+	/** Exclude Inner Destination IP Value - used for GSWIP-3.0 only */
+	ltq_bool_t	bInnerDstIP_Exclude;
+
+	/** Source IP Selection (Outer for GSWIP-3.0). */
+	GSW_PCE_IP_t	eSrcIP_Select;
+	/** Source IP  (Outer for GSWIP-3.0) */
+	GSW_IP_t	nSrcIP;
+	/** Source IP Nibble Mask (Outer for GSWIP-3.0).
+	    1 bit represents 1 nibble mask of the 'nSrcIP' field.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u32	nSrcIP_Mask;
+	/** Exclude Source IP Value - used for GSWIP-3.0 only */
+	ltq_bool_t	bSrcIP_Exclude;
+
+	/** Inner Source IP Selection - for GSWIP-3.0 only. */
+	GSW_PCE_IP_t	eInnerSrcIP_Select;
+	/** Inner Source IP  - for GSWIP-3.0 only*/
+	GSW_IP_t	nInnerSrcIP;
+	/** Inner Src IP Nibble Mask - for GSWIP-3.0 only.
+	    1 bit represents 1 nibble mask of the 'nInnerSrcIP' field.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u32	nInnerSrcIP_Mask;
+	/** Exclude Inner Source IP Value - used for GSWIP-3.0 only */
+	ltq_bool_t	bInnerSrcIP_Exclude;
+
+	/** Ethertype used. */
+	ltq_bool_t	bEtherTypeEnable;
+	/** Ethertype */
+	u16	nEtherType;
+	/** Ethertype Mask.
+	    1 bit represents 1 nibble mask of the 'nEtherType' field.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u16	nEtherTypeMask;
+	/** Exclude for Ether Type Value - used for GSWIP-3.0 only. */
+	ltq_bool_t	bEtherType_Exclude;
+
+	/** IP protocol used */
+	ltq_bool_t	bProtocolEnable;
+	/** IP protocol Value */
+	u8	nProtocol;
+	/** IP protocol Mask.
+	    1 bit represents 1 nibble mask of the 'nProtocol' field.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits i.e. a set bit 1 indicates that bit is masked out (not compared).
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u8	nProtocolMask;
+	/** Exclude for IP Protocol Value - used for GSWIP-3.0 only. */
+	ltq_bool_t	bProtocol_Exclude;
+
+	/** Inner IP protocol used - for GSWIP-3.0 only. */
+	ltq_bool_t	bInnerProtocolEnable;
+	/** Inner IP protocol Value - for GSWIP-3.0 only. */
+	u8	nInnerProtocol;
+	/** Inner IP protocol Bit Mask - for GSWIP-3.0 only. */
+	u8	nInnerProtocolMask;
+	/** Exclude for Inner IP Protocol Value - used for GSWIP-3.0 only. */
+	ltq_bool_t	bInnerProtocol_Exclude;
+
+	/** PPPoE used. */
+	ltq_bool_t	bSessionIdEnable;
+	/** PPPoE Session Id */
+	u16	nSessionId;
+	/** Exclude for PPPoE Session Value - used for GSWIP-3.0 only. */
+	ltq_bool_t	bSessionId_Exclude;
+
+	/** PPP Protocol used - used for GSWIP-3.0 only */
+	ltq_bool_t	bPPP_ProtocolEnable;
+	/** PPP Protocol Value  - used for GSWIP-3.0 only*/
+	u16	nPPP_Protocol;
+	/** PPP protocol Bit Mask (Positional bit 1 signifies masking of corresponding bit value in nPPP_Protocol) - for GSWIP-3.0 only. */
+	u16	nPPP_ProtocolMask;
+	/** Exclude for PPP Protocol Value - used for GSWIP-3.0 only. */
+	ltq_bool_t	bPPP_Protocol_Exclude;
+
+	/** VLAN ID (CVID) used.
+
+	    \remarks
+	    CVID is inner VLAN as defined in GSWIP-3.1 */
+	ltq_bool_t	bVid;
+	/** VLAN ID (CVID) */
+	u16	nVid;
+	/** VID mask/range selection.
+	    If set to 1, the field 'nVidRange' is used as
+	    a range parameter, otherwise it is used as a mask field.
+
+	    \remarks
+	    This must be range in GSWIP-3.1 */
+	ltq_bool_t	bVidRange_Select;
+	/** VLAN ID Range (CVID). Gets used as mask to nVid in case bVidRange_Select is set to 0 */
+	u16	nVidRange;
+	/** Exclude for VLAN Id (CVLAN) - used for GSWIP-3.0 only. */
+	ltq_bool_t	bVid_Exclude;
+	/** If this field is TRUE, use original VLAN ID as key even it's modified in
+	    any stage before flow table process. Used for GSWIP-3.1 only. */
+	ltq_bool_t bVid_Original;
+
+	/** STAG VLAN ID used.
+
+	    \remarks
+	    SLAN is outer VLAN as defined GSWIP-3.1 */
+	ltq_bool_t	bSLAN_Vid;
+	/** STAG VLAN ID */
+	u16	nSLAN_Vid;
+	/** Exclude for SVLAN Id (SVLAN) - used for GSWIP-3.0 only. */
+	ltq_bool_t	bSLANVid_Exclude;
+	/** VID mask/range selection.
+	    If set to 1, the field 'nVidRange' is used as
+	    a range parameter, otherwise it is used as a mask field.
+
+	    \remarks
+	    This must be range in GSWIP-3.1 */
+	ltq_bool_t	bSVidRange_Select;
+	/** VLAN ID Range for outer VLAN tag. Used for GSWIP-3.1 only. */
+	u16 nOuterVidRange;
+	/** If this field is TRUE, use original VLAN ID as key even it's modified in
+	    any stage before flow table process. Used for GSWIP-3.1 only. */
+	ltq_bool_t bOuterVid_Original;
+
+	/** Payload-1 used - for GSWIP-3.0 PAE only */
+	ltq_bool_t	bPayload1_SrcEnable;
+	/** Payload-1 Value (16-bits) - for GSWIP-3.0 PAE only */
+	u16	nPayload1;
+	/** Payload1 mask/range selection.
+	    If set to LTQ_TRUE, the field 'nPayload1' is used as
+	    a range parameter, otherwise it is used as a bit mask field. */
+	ltq_bool_t	bPayload1MaskRange_Select;
+	/** Payload-1 Bit mask - for GSWIP-3.0 PAE only */
+	u16	nPayload1_Mask;
+	/** Exclude Payload-1 used for GSWIP-3.0 PAE only */
+	ltq_bool_t	bPayload1_Exclude;
+
+	/** Payload-2 used - for GSWIP-3.0 PAE only */
+	ltq_bool_t	bPayload2_SrcEnable;
+	/** Payload-2 Value (16-bits) - for GSWIP-3.0 PAE only */
+	u16	nPayload2;
+	/** Payload2 mask/range selection.
+	    If set to LTQ_TRUE, the field 'nPayload2' is used as
+	    a range parameter, otherwise it is used as a bit mask field. */
+	ltq_bool_t	bPayload2MaskRange_Select;
+	/** Payload-2 Bit mask - for GSWIP-3.0 PAE only */
+	u16	nPayload2_Mask;
+	/** Exclude Payload-2 used for GSWIP-3.0 PAE only */
+	ltq_bool_t	bPayload2_Exclude;
+
+	/** Parser Flag LSW (Bit position 15 to 0) is used - for GSWIP 3.0 only */
+	ltq_bool_t	bParserFlagLSB_Enable;
+	/** Parser Flag LSW Value - each bit indicates specific parsed result */
+	u16	nParserFlagLSB;
+	/** Corresponding LSW Parser Flag Mask - when the bit is set to 1 corresponding flag gets masked out (ignored). */
+	u16	nParserFlagLSB_Mask;
+	/** Exclude for Parser Flag LSW specified in nParserFlagLSB */
+	ltq_bool_t	bParserFlagLSB_Exclude;
+
+	/** Parser Flag MSW (Bit 31 to 16) is used - for GSWIP 3.0 only */
+	ltq_bool_t	bParserFlagMSB_Enable;
+	/** Parser Flag MSW Value - each bit indicates specific parsed result */
+	u16	nParserFlagMSB;
+	/** Corresponding Parser Flag MSW Mask - when the bit is set to 1 corresponding flag gets masked out (ignored). */
+	u16	nParserFlagMSB_Mask;
+	/** Exclude for Parser Flag MSW specified in nParserFlagMSB */
+	ltq_bool_t	bParserFlagMSB_Exclude;
+
+	/** Parser Flag LSW (Bit position 47 to 32) is used - for GSWIP 3.1 only */
+	ltq_bool_t	bParserFlag1LSB_Enable;
+	/** Parser Flag LSW Value - each bit indicates specific parsed result */
+	u16	nParserFlag1LSB;
+	/** Corresponding LSW Parser Flag Mask - when the bit is set to 1 corresponding flag gets masked out (ignored). */
+	u16	nParserFlag1LSB_Mask;
+	/** Exclude for Parser Flag LSW specified in nParserFlagLSB */
+	ltq_bool_t	bParserFlag1LSB_Exclude;
+
+	/** Parser Flag MSW (Bit 63 to 48) is used - for GSWIP 3.1 only */
+	ltq_bool_t	bParserFlag1MSB_Enable;
+	/** Parser Flag MSW Value - each bit indicates specific parsed result */
+	u16	nParserFlag1MSB;
+	/** Corresponding Parser Flag MSW Mask - when the bit is set to 1 corresponding flag gets masked out (ignored). */
+	u16	nParserFlag1MSB_Mask;
+	/** Exclude for Parser Flag MSW specified in nParserFlagMSB */
+	ltq_bool_t	bParserFlag1MSB_Exclude;
+
+	/** nInsertionFlag is used. For GSWIP-3.1 only */
+	ltq_bool_t bInsertionFlag_Enable;
+	/** Inserted packet by CPU to data path. For GSWIP-3.1 only */
+	u16 nInsertionFlag;
+} GSW_PCE_pattern_t;
+
+/** \brief IGMP Snooping Control.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disabled. IGMP Snooping is disabled. */
+	GSW_PCE_ACTION_IGMP_SNOOP_DISABLE	= 0,
+	/** Default. Regular Packet. No IGMP Snooping action required. */
+	GSW_PCE_ACTION_IGMP_SNOOP_REGULAR	= 1,
+	/** IGMP Report/Join Message. */
+	GSW_PCE_ACTION_IGMP_SNOOP_REPORT	= 2,
+	/** IGMP Leave Message. */
+	GSW_PCE_ACTION_IGMP_SNOOP_LEAVE	= 3,
+	/**  Router Solicitation/Advertisement message. */
+	GSW_PCE_ACTION_IGMP_SNOOP_AD	= 4,
+	/** IGMP Query Message. */
+	GSW_PCE_ACTION_IGMP_SNOOP_QUERY	= 5,
+	/** IGMP Group Specific Query Message. */
+	GSW_PCE_ACTION_IGMP_SNOOP_QUERY_GROUP	= 6,
+	/** IGMP General Query message without Router Solicitation. */
+	GSW_PCE_ACTION_IGMP_SNOOP_QUERY_NO_ROUTER = 7
+} GSW_PCE_ActionIGMP_Snoop_t;
+
+/** \brief MAC Address Learning control.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Learning is based on the forwarding decision. If the packet is discarded,
+	    the address is not learned. If the packet is forwarded to any egress port,
+	    the address is learned. */
+	GSW_PCE_ACTION_LEARNING_DISABLE	= 0,
+	/** Reserved */
+	GSW_PCE_ACTION_LEARNING_REGULAR	= 1,
+	/** Force No Learning. The address is not learned; forwarding decision
+	    ignored. */
+	GSW_PCE_ACTION_LEARNING_FORCE_NOT = 2,
+	/** Force Learning. The address is learned, the forwarding decision ignored.
+	    Note: The MAC Learning Control signals delivered to Port-Map filtering
+	    and combined with Final Forwarding Decision. The result is used as a
+	    feedback for MAC Address learning in the Bridging Table. */
+	GSW_PCE_ACTION_LEARNING_FORCE	= 3
+} GSW_PCE_ActionLearning_t;
+
+/** \brief Flow Meter Assignment control.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Action Disable. */
+	GSW_PCE_ACTION_METER_DISABLE	= 0,
+	/** Action Enable.
+	    The action is enabled but no dedicated metering instance is assigned by the rule. */
+	GSW_PCE_ACTION_METER_REGULAR	= 1,
+	/** Action Enable. Assign one meter instance as given in parameter "nMeterId". */
+	GSW_PCE_ACTION_METER_1	= 2,
+	/** Action Enable. Assign pair of meter instances.
+	    These instances are "nMeterId" and the next following meter instance index. */
+	GSW_PCE_ACTION_METER_1_2	= 3
+} GSW_PCE_ActionMeter_t;
+
+/** \brief Traffic Class Action Selector.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disabled. Traffic class action is disabled. */
+	GSW_PCE_ACTION_TRAFFIC_CLASS_DISABLE	= 0,
+	/** Regular Class. Traffic class action is enabled and the CoS
+	    classification traffic class is used. */
+	GSW_PCE_ACTION_TRAFFIC_CLASS_REGULAR	= 1,
+	/** Alternative Class. Traffic class action is enabled and the
+	    class of the 'nTrafficClassAlter' field is used. */
+	GSW_PCE_ACTION_TRAFFIC_CLASS_ALTERNATIVE	= 2,
+} GSW_PCE_ActionTrafficClass_t;
+
+/** \brief Interrupt Control Action Selector.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disabled. Interrupt Control Action is disabled for this rule. */
+	GSW_PCE_ACTION_IRQ_DISABLE	= 0,
+	/** Regular Packet. The Interrupt Control Action is enabled, the packet is
+	    treated as a regular packet and no interrupt event is generated. */
+	GSW_PCE_ACTION_IRQ_REGULAR	= 1,
+	/** Interrupt Event. The Interrupt Control Action is enabled and an
+	    interrupt event is generated. */
+	GSW_PCE_ACTION_IRQ_EVENT	= 2
+} GSW_PCE_ActionIrq_t;
+
+/** \brief Cross State Action Selector.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disable. The Cross State Action is disabled. */
+	GSW_PCE_ACTION_CROSS_STATE_DISABLE	= 0,
+	/** Regular Packet. The Cross State Action is enabled and the packet is
+	    treated as a non-Cross-State packet (regular packet). Therefore it does
+	    not ignore Port-State filtering rules. */
+	GSW_PCE_ACTION_CROSS_STATE_REGULAR	= 1,
+	/** Cross-State packet. The Cross State Action is enabled and the packet is
+	    treated as a Cross-State packet. It ignores the Port-State
+	    filtering rules. */
+	GSW_PCE_ACTION_CROSS_STATE_CROSS	= 2
+} GSW_PCE_ActionCrossState_t;
+
+/** \brief Critical Frame Action Selector.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disable. The Critical Frame Action is disabled. */
+	GSW_PCE_ACTION_CRITICAL_FRAME_DISABLE	= 0,
+	/** Regular Packet. The Critical Frame Action is enabled and the packet is
+	    treated as a non-Critical Frame. */
+	GSW_PCE_ACTION_CRITICAL_FRAME_REGULAR	= 1,
+	/** Critical Packet. The Critical Frame Action is enabled and the packet is
+	    treated as a Critical Frame. */
+	GSW_PCE_ACTION_CRITICAL_FRAME_CRITICAL	= 2
+} GSW_PCE_ActionCriticalFrame_t;
+
+/** \brief Color Frame Action Selector.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disable. No color frame action. */
+	GSW_PCE_ACTION_COLOR_FRAME_DISABLE = 0,
+	/** Do not change color. */
+	GSW_PCE_ACTION_COLOR_FRAME_NO_CHANGE = 1,
+	/** Idendity packet as critical which bypass active congestion
+	    management (ACM). */
+	GSW_PCE_ACTION_COLOR_FRAME_CRITICAL = 2,
+	/** Change to green color. */
+	GSW_PCE_ACTION_COLOR_FRAME_GREEN = 3,
+	/** Change to yellow color. */
+	GSW_PCE_ACTION_COLOR_FRAME_YELLOW = 4,
+	/** Change to red color. */
+	GSW_PCE_ACTION_COLOR_FRAME_RED = 5
+} GSW_PCE_ActionColorFrame_t;
+
+/** \brief Timestamp Action Selector.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disable. Timestamp Action is disabled for this rule. */
+	GSW_PCE_ACTION_TIMESTAMP_DISABLE	= 0,
+	/** Regular Packet. The Timestamp Action is enabled for this rule.
+	    The packet is treated as a regular packet and no timing information
+	    is stored. */
+	GSW_PCE_ACTION_TIMESTAMP_REGULAR	= 1,
+	/** Receive/Transmit Timing packet. Ingress and Egress Timestamps for
+	    this packet should be stored. */
+	GSW_PCE_ACTION_TIMESTAMP_STORED	= 2
+} GSW_PCE_ActionTimestamp_t;
+
+/** \brief Forwarding Group Action Selector.
+    This flow table action and the 'bFlowID_Action' action
+    can be used exclusively.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disable. Forwarding Group Action is disabled. */
+	GSW_PCE_ACTION_PORTMAP_DISABLE	= 0,
+	/** Regular Packet. Forwarding Action enabled. Select Default
+	    Port-Map (result of Default Forwarding Classification). */
+	GSW_PCE_ACTION_PORTMAP_REGULAR	= 1,
+	/** Discard. Discard the packets. */
+	GSW_PCE_ACTION_PORTMAP_DISCARD	= 2,
+	/** Forward to the CPU port. This requires that the CPU port is previously
+	    set by calling \ref GSW_CPU_PORT_CFG_SET. */
+	GSW_PCE_ACTION_PORTMAP_CPU	= 3,
+	/** Forward to a portmap, selected by the parameter 'nForwardPortMap'.
+	    Please note that this feature is not supported by all
+	    hardware platforms. */
+	GSW_PCE_ACTION_PORTMAP_ALTERNATIVE	= 4,
+	/** The packet is treated as Multicast Router
+	    Solicitation/Advertisement or Query packet. */
+	GSW_PCE_ACTION_PORTMAP_MULTICAST_ROUTER	= 5,
+	/** The packet is interpreted as Multicast packet and learned in the
+	    multicast group table. */
+	GSW_PCE_ACTION_PORTMAP_MULTICAST_HW_TABLE = 6,
+	/** The CTAG VLAN portmap classification result is replaced by the
+	    portmap parameter 'nForwardPortMap'. All other classification
+	    results stay unchanged and will be combined together with
+	    the overwritten portmap. */
+	GSW_PCE_ACTION_PORTMAP_ALTERNATIVE_VLAN	= 7,
+	/** Add STAG VLAN portmap 'nForwardPortMap' to the overall portmap
+	    classification result (AND'ed with the portmap). */
+	GSW_PCE_ACTION_PORTMAP_ALTERNATIVE_STAG_VLAN	= 8
+} GSW_PCE_ActionPortmap_t;
+
+/** \brief VLAN Group Action Selector.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disabled. The VLAN Action is disabled. */
+	GSW_PCE_ACTION_VLAN_DISABLE	= 0,
+	/** Regular VLAN. VLAN Action enabled. Select Default VLAN ID. */
+	GSW_PCE_ACTION_VLAN_REGULAR	= 1,
+	/** Alternative VLAN. VLAN Action enabled.
+	    Select Alternative VLAN as configured in 'nVLAN_Id'
+	    or 'nSVLAN_Id'. For CTAG VLAN it requires that this VLAN ID
+	    is configured by calling
+	    \ref GSW_VLAN_ID_CREATE in advance.
+	    This additional call is not required for STAG VLAN. */
+	GSW_PCE_ACTION_VLAN_ALTERNATIVE	= 2
+} GSW_PCE_ActionVLAN_t;
+
+/** \brief Cross VLAN Action Selector.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disabled. The Cross VLAN Action is disabled. */
+	GSW_PCE_ACTION_CROSS_VLAN_DISABLE	= 0,
+	/** Regular VLAN Packet. Do not ignore VLAN filtering rules. */
+	GSW_PCE_ACTION_CROSS_VLAN_REGULAR	= 1,
+	/** Cross-VLAN packet. Ignore VLAN filtering  rules.*/
+	GSW_PCE_ACTION_CROSS_VLAN_CROSS	= 2
+} GSW_PCE_ActionCrossVLAN_t;
+
+/** \brief Port Filter Action-1/2/3/4/5/6 Selector - used for GSWIP-3.0 only.
+     This can be used only along with PortMember config.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Port Filter Action is Unused. */
+	GSW_PCE_PORT_FILTER_ACTION_UNUSED = 0,
+	/** Port Filter Action Type-1 is used. */
+	GSW_PCE_PORT_FILTER_ACTION_1	= 1,
+	/** Port Filter Action Type-2 is used. */
+	GSW_PCE_PORT_FILTER_ACTION_2	= 2,
+	/** Port Filter Action Type-3 is used. */
+	GSW_PCE_PORT_FILTER_ACTION_3	= 3,
+	/** Port Filter Action Type-4 is used. */
+	GSW_PCE_PORT_FILTER_ACTION_4	= 4,
+	/** Port Filter Action Type-5 (Unknown Unicast) is used. */
+	GSW_PCE_PORT_FILTER_ACTION_5	= 5,
+	/** Port Filter Action Type-6 (Unknown Multicast) is used. */
+	GSW_PCE_PORT_FILTER_ACTION_6	= 6
+} GSW_PCE_PortFilterAction_t;
+
+/** \brief MPE Processing Path Assignment Selector - used for GSWIP-3.0 only.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Processing Path is not enabled. */
+	GSW_PCE_PROCESSING_PATH_UNUSED = 0,
+	/** Processing Path-1 is used for MPE-1. */
+	GSW_PCE_PROCESSING_PATH_1 = 1,
+	/** Processing Path-2 is used for MPE-2. */
+	GSW_PCE_PROCESSING_PATH_2 = 2,
+	/** Processing Path-1 and -2 are used for MPE-1 & MPE-2. */
+	GSW_PCE_PROCESSING_PATH_BOTH = 3,
+} GSW_PCE_ProcessingPathAction_t;
+
+/** \brief Packet Classification Engine Action Configuration.
+    GSWIP-3.0 extension actions are explicitly indicated.
+    Used by \ref GSW_PCE_rule_t. */
+typedef struct {
+	/** Action "Traffic Class" Group.
+	    Traffic class action enable */
+	GSW_PCE_ActionTrafficClass_t	eTrafficClassAction;
+	/** Alternative Traffic class - used when eTrafficClassAction is set to 2. */
+	u8	nTrafficClassAlternate;
+
+	/** Action "IGMP Snooping" Group.
+	    IGMP Snooping control and enable. Please note that the 'nPortMapAction'
+	    configuration is ignored in case the IGMP snooping is enabled.
+	    Here, on read operations,
+	    'nPortMapAction = GSW_PCE_ACTION_PORTMAP_DISABLE' is returned. */
+	GSW_PCE_ActionIGMP_Snoop_t	eSnoopingTypeAction;
+
+	/** Action "Learning" Group.
+	    Learning action control and enable */
+	GSW_PCE_ActionLearning_t	eLearningAction;
+
+	/** Action "Interrupt" Group.
+	    Interrupt action generate and enable */
+	GSW_PCE_ActionIrq_t	eIrqAction;
+
+	/** Action "Cross State" Group.
+	    Cross state action control and enable */
+	GSW_PCE_ActionCrossState_t	eCrossStateAction;
+
+	/** Action "Critical Frames" Group.
+	    Critical Frame action control and enable */
+	GSW_PCE_ActionCriticalFrame_t	eCritFrameAction;
+
+	/** Action "Color Frames" Group.
+	    This is replacement of eCritFrameAction in GSWIP-3.1. */
+	GSW_PCE_ActionColorFrame_t eColorFrameAction;
+
+	/** Action "Timestamp" Group. Time stamp action control and enable */
+	GSW_PCE_ActionTimestamp_t	eTimestampAction;
+
+	/** Action "Forwarding" Group.
+	    Port map action enable. This port forwarding configuration is ignored
+	    in case the action "IGMP Snooping" is enabled via the
+	    parameter 'nSnoopingTypeAction'. */
+	GSW_PCE_ActionPortmap_t	ePortMapAction;
+	/** Target portmap for forwarded packets, only used if selected by
+	    'ePortMapAction'. Forwarding is done
+	    if 'ePortMapAction = GSW_PCE_ACTION_PORTMAP_ALTERNATIVE'.
+	    Every bit in the portmap represents one port (port 0 = LSB bit). */
+	u16 nForwardPortMap[16];
+
+	/** Target Sub-Interface Id (GSWIP-3.0 only) for forwarded packets,
+	    only used if selected by 'ePortMapAction'. Forwarding is done
+	    if 'ePortMapAction = GSW_PCE_ACTION_PORTMAP_ALTERNATIVE'. */
+	u16	nForwardSubIfId;
+
+	/** Action "Remarking" Group. Remarking action enable. Reserved in
+	    GSWIP-3.1. */
+	ltq_bool_t	bRemarkAction;
+	/** CTAG VLAN PCP remarking enable. Reserved in GSWIP-3.1.
+	    Remarking enabling means that remarking is possible in case
+	    the port configuration or metering enables remarking on that
+	    packet. Disabling remarking means that it is forced to
+	    not remarking this packet, independent of any port remarking of
+	    metering configuration. */
+	ltq_bool_t	bRemarkPCP;
+	/** STAG VLAN PCP remarking enable. Reserved in GSWIP-3.1.
+	    Remarking enabling means that remarking is possible in case
+	    the port configuration or metering enables remarking on that
+	    packet. Disabling remarking means that it is forced to
+	    not remarking this packet, independent of any port remarking of
+	    metering configuration. */
+	ltq_bool_t	bRemarkSTAG_PCP;
+	/** STAG VLAN DEI remarking enable. Reserved in GSWIP-3.1.
+	    Remarking enabling means that remarking is possible in case
+	    the port configuration or metering enables remarking on that
+	    packet. Disabling remarking means that it is forced to
+	    not remarking this packet, independent of any port remarking of
+	    metering configuration. */
+	ltq_bool_t	bRemarkSTAG_DEI;
+	/** DSCP remarking enable. Reserved in GSWIP-3.1.
+	    Remarking enabling means that remarking is possible in case
+	    the port configuration or metering enables remarking on that
+	    packet. Disabling remarking means that it is forced to
+	    not remarking this packet, independent of any port remarking of
+	    metering configuration. */
+	ltq_bool_t	bRemarkDSCP;
+	/** Class remarking enable. Reserved in GSWIP-3.1.
+	    Remarking enabling means that remarking is possible in case
+	    the port configuration or metering enables remarking on that
+	    packet. Disabling remarking means that it is forced to
+	    not remarking this packet, independent of any port remarking of
+	    metering configuration. */
+	ltq_bool_t	bRemarkClass;
+
+	/** Action "Meter" Group. Meter action control and enable.
+	    If metering action enabled, specified metering instance number
+	    overrules any other metering assignment.
+	    Up to two metering instances can be applied to a single packet. */
+	GSW_PCE_ActionMeter_t	eMeterAction;
+	/** Meter ID */
+	u8	nMeterId;
+
+	/** Action "RMON" Group. RMON action enable. Reserved in GSWIP-3.1. */
+	ltq_bool_t	bRMON_Action;
+	/** Counter ID (The index starts counting from zero). */
+	u8	nRMON_Id;
+
+	/** Action "CTAG VLAN" Group. VLAN action enable */
+	GSW_PCE_ActionVLAN_t	eVLAN_Action;
+	/** Alternative CTAG VLAN Id */
+	u16	nVLAN_Id;
+	/** Enable alternative FID */
+	ltq_bool_t bFidEnable;
+	/** Alternative FID. Valid when bFidEnable is TRUE. */
+	u8	nFId;
+	/** Enable extended VLAN operation for traffic match this flow entry. */
+	ltq_bool_t bExtendedVlanEnable;
+	/** Extended VLAN block allocated for traffic match this flow entry. Valid
+	    when bExtendedVlanEnable is TRUE. Only FIRST VLAN operation in this block
+	    is used for flow process. */
+	u32 nExtendedVlanBlockId;
+	/** Action "STAG VLAN" Group. VLAN action enable */
+	GSW_PCE_ActionVLAN_t	eSVLAN_Action;
+	/** Alternative STAG VLAN Id */
+	u16	nSVLAN_Id;
+	/** Action "Cross VLAN" Group. Cross VLAN action enable */
+	GSW_PCE_ActionCrossVLAN_t	eVLAN_CrossAction;
+	/**  CVLAN Ignore control */
+	ltq_bool_t	bCVLAN_Ignore_Control;
+	/** Port BitMap Mux control */
+	ltq_bool_t	bPortBitMapMuxControl;
+	/** Trunking action enable  */
+	ltq_bool_t	bPortTrunkAction;
+	/**  Port Link Selection control */
+	ltq_bool_t	bPortLinkSelection;
+	/** Action "Flow ID".
+	 The Switch supports enhancing the egress packets by a device specific
+	 special tag header. This header contains detailed switch classification
+	 results. One header file is a 'Flow ID', which can be explicitly set as
+	 flow table action when hitting a table rule.
+	 If selected, the Flow ID is given by the parameter 'nFlowID'. */
+	ltq_bool_t	bFlowID_Action;
+	/** Flow ID */
+	u16	nFlowID;
+
+	/** Routing Extension Id Action Selector - for GSWIP-3.0 only.
+	  When enabled, it expects a valid nRoutExtId value to be supplied. */
+	ltq_bool_t	bRoutExtId_Action;
+	/** Routing Extension Id Value - for GSWIP-3.0 only. (8-bits range) */
+	u8	nRoutExtId;
+	/** Routing Destination Port Mask Comparison - for GSWIP-3.0 only. If not enabled this field is not considered for routing session pattern lookup.*/
+	ltq_bool_t	bRtDstPortMaskCmp_Action;
+	/** Routing Source Port Mask Comparison - for GSWIP-3.0 only. If not enabled, this field is not considered for routing session pattern lookup.*/
+	ltq_bool_t	bRtSrcPortMaskCmp_Action;
+	/** Routing Destination IP Address Mask Comparison - for GSWIP-3.0 only. If not enabled, this field is not considered for routing session pattern lookup.*/
+	ltq_bool_t	bRtDstIpMaskCmp_Action;
+	/** Routing Source IP Address Mask Comparison - for GSWIP-3.0 only. If not enabled, this field is not considered for routing session pattern lookup.*/
+	ltq_bool_t	bRtSrcIpMaskCmp_Action;
+	/** Selector of IP in Tunneled IP header (Outer or Inner) - for GSWIP-3.0 only. */
+	ltq_bool_t	bRtInnerIPasKey_Action;
+	/** Routing Acceleration Enable Action - for GSWIP-3.0 only. This variable decides whether to accelerate the Routing session or not */
+	ltq_bool_t	bRtAccelEna_Action;
+	/** Routing Control Enable Action - for GSWIP-3.0 only. This variable is selector of Routing Accelerate action*/
+	ltq_bool_t	bRtCtrlEna_Action;
+	/** Assignment of flow to MPE Processing Path-1 or -2 or both - for GSWIP-3.0 only. */
+	GSW_PCE_ProcessingPathAction_t eProcessPath_Action;
+	/** Port Filter Action Config for this flow - for GSWIP-3.0 only. */
+	GSW_PCE_PortFilterAction_t	ePortFilterType_Action;
+
+	/** Enable Extraction. For GSWIP-3.1 only.
+	    Packet is identified to be extracted at extraction point defined by
+	    nRecordId. */
+	ltq_bool_t bExtractEnable;
+	/** Enable OAM. For GSWIP-3.1 only.
+	    Packet is identified for OAM process. */
+	ltq_bool_t bOamEnable;
+	/** Record ID is information used by extraction (bExtractEnable is set)
+	    and/or OAM process (bOamEnable is set). For GSWIP-3.1 only. Refer to
+	    GSWIP-3.1 Hardware Architecture Spec (HAS) for more detail. */
+	u32 nRecordId;
+} GSW_PCE_action_t;
+
+/** \brief Parameter to add/read a rule to/from the packet classification engine.
+    Used by \ref GSW_PCE_RULE_WRITE and \ref GSW_PCE_RULE_READ. */
+typedef struct {
+	/** PCE Rule Pattern Part. */
+	GSW_PCE_pattern_t	pattern;
+	/** PCE Rule Action Part. */
+	GSW_PCE_action_t	action;
+} GSW_PCE_rule_t;
+
+/** \brief Parameter to delete a rule from the packet classification engine.
+    Used by \ref GSW_PCE_RULE_DELETE. */
+typedef struct {
+	/** Rule Index in the PCE Table. */
+	u32	nIndex;
+} GSW_PCE_ruleDelete_t;
+
+/*@}*/ /* GSW_IOCTL_CLASS */
+
+/** \addtogroup GSW_IOCTL_SYS */
+/*@{*/
+
+/** \brief Reset selection.
+    Used by \ref GSW_reset_t. */
+typedef enum {
+	/** Switch Macro reset */
+	GSW_RESET_SWITCH	= 0,
+	/** MDIO master interface reset */
+	GSW_RESET_MDIO	= 1,
+} GSW_resetMode_t;
+
+/** \brief Reset selection.
+    Used by \ref GSW_RESET. */
+typedef struct {
+	/** Reset selection. */
+	GSW_resetMode_t	eReset;
+} GSW_reset_t;
+
+/** Number of extended RMON counter. */
+#define GSW_RMON_EXTEND_NUM	24
+
+
+/**
+   \brief Hardware platform extended RMON Counters. GSWIP-2.2/3.0 only.
+   This structure contains additional RMON counters of one Ethernet Switch Port.
+   These counters can be used by the packet classification engine and can be
+   freely assigned to dedicated packet rules and flows.
+    Used by \ref GSW_RMON_EXTEND_GET. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u8		nPortId;
+	/** Traffic flow counters */
+	u32	nTrafficFlowCnt[GSW_RMON_EXTEND_NUM];
+} GSW_RMON_extendGet_t;
+
+/**
+   \brief Hardware platform extended RMON Counters. GSWIP-3.1 only.
+   This structure contains additional RMON counters. These counters can be
+   used by the packet classification engine and can be freely assigned to
+   dedicated packet rules and flows.
+    Used by \ref GSW_RMON_FLOW_GET. */
+typedef struct {
+	/** If TRUE, use \ref GSW_RMON_flowGet_t::nIndex to access the Flow Counter,
+	    otherwise, use \ref GSW_TFLOW_COUNT_MODE_GET to determine mode and use
+	    \ref GSW_RMON_flowGet_t::nPortId and \ref GSW_RMON_flowGet_t::nFlowId
+	    to calculate index of the Flow Counter. */
+	ltq_bool_t bIndex;
+	/** Absolute index of Flow Counter. */
+	u16 nIndex;
+	/** Port ID. This could be Logical Port, CTP or Bridge Port. It depends
+	    on the mode set by \ref GSW_TFLOW_COUNT_MODE_SET. */
+	u16 nPortId;
+	/** \ref GSW_PCE_action_t::nFlowID. The range depends on the mode set
+	    by \ref GSW_TFLOW_COUNT_MODE_SET. */
+	u16 nFlowId;
+
+	/** Rx Packet Counter */
+	u32 nRxPkts;
+	/** Tx Packet Counter (non-PCE-Bypass) */
+	u32 nTxPkts;
+	/** Tx Packet Counter (PCE-Bypass) */
+	u32 nTxPceBypassPkts;
+} GSW_RMON_flowGet_t;
+
+/** \brief Used for getting metering RMON counters.
+    Used by \ref GSW_RMON_METER_GET */
+typedef enum {
+	/* Resereved */
+	GSW_RMON_METER_COLOR_RES = 0,
+	/* Green color */
+	GSW_RMON_METER_COLOR_GREEN = 1,
+	/* Yellow color */
+	GSW_RMON_METER_COLOR_YELLOW = 2,
+	/* Red color */
+	GSW_RMON_METER_COLOR_RED = 3,
+} GSW_RmonMeterColor_t;
+
+/**
+   \brief Hardware platform TFLOW counter mode.
+   Supported modes include, Global (default), Logical, CTP, Bridge port mode.
+   The number of counters that can be assigned varies based these mode type.
+    Used by \ref GSW_TFLOW_COUNT_MODE_SET and GSW_TFLOW_COUNT_MODE_GET. */
+typedef struct {
+	//Counter type. PCE Rx/Tx/Bp-Tx.
+	GSW_TflowCountConfType_t eCountType;
+	//Counter mode. Global/Logical/CTP/BrP.
+	GSW_TflowCmodeType_t eCountMode;
+	//The below params are valid only for CTP/BrP types.
+	//A group of ports matching MS (9-n) bits. n is nCtpLsb or nBrpLsb.
+	u16 nPortMsb;
+	//Number of valid bits in CTP port counter mode.
+	GSW_TflowCtpValBits_t nCtpLsb;
+	//Number of valid bits in bridge port counter mode.
+	GSW_TflowBrpValBits_t nBrpLsb;
+} GSW_TflowCmodeConf_t;
+
+/** \brief This structure describes the second, nano second and fractional
+    nano second counterpart of the switch reference timer. This
+    reference counter can be read by
+    using \ref GSW_TIMESTAMP_TIMER_GET , and it can be modified
+    by using \ref GSW_TIMESTAMP_TIMER_SET . */
+typedef struct {
+	/** Second. Absolute second timer count. */
+	u32	nSec;
+	/** Nano Second. Absolute nanosecond timer count. */
+	u32	nNanoSec;
+	/** Fractional NanoSecond. Absolute fractional nanosecond timer count.
+	    This counter specifis a 2^32 fractional 'nNanoSec'. */
+	u32	nFractionalNanoSec;
+} GSW_TIMESTAMP_Timer_t;
+
+/** \brief This structure describes the port related time stamp.
+    Used by \ref GSW_TIMESTAMP_PORT_READ.
+*/
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u8		nPortId;
+	/** Second. Absolute second timer count. */
+	u32	nIngressSec;
+	/** Nano Second. Absolute nano second timer count. */
+	u32	nIngressNanoSec;
+	/** Second. Absolute second timer count. */
+	u32	nEgressSec;
+	/** Nano Second. Absolute nano second timer count. */
+	u32	nEgressNanoSec;
+} GSW_TIMESTAMP_PortRead_t;
+
+/*@}*/ /* GSW_IOCTL_SYS */
+
+/* -------------------------------------------------------------------------- */
+/*                        IOCTL Command Definitions                           */
+/* -------------------------------------------------------------------------- */
+
+/** \addtogroup GSW_IOCTL_DEBUG */
+/*@{*/
+
+/**
+   \brief Write to an internal register. The register offset defines which register to access in
+   which table. This routine only accesses the M4599_PDI and
+   the ETHSW_PDI of the switch. All PHY registers are accessed
+   via \ref GSW_MDIO_DATA_WRITE and \ref GSW_MDIO_DATA_READ.
+   Note that the switch API implementation checks whether the given address is
+   inside the valid address range. It returns with an error in case an invalid
+   address is given.
+
+   \param GSW_register_t Pointer to \ref GSW_register_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_REGISTER_SET	_IOW(GSW_COMMON_MAGIC, 0x02, GSW_register_t)
+
+/**
+   \brief Read an internal register. The register offset defines which register to access in
+   which table. This routine only accesses the ETHSW_PDI of the switch.
+   All PHY registers are accessed via \ref GSW_MDIO_DATA_WRITE and \ref GSW_MDIO_DATA_READ.
+   Note that the switch API implementation checks whether the given address is
+   inside the valid address range. It returns with an error in case an invalid
+   address is given.
+
+   \param GSW_register_t Pointer to \ref GSW_register_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_REGISTER_GET	_IOWR(GSW_COMMON_MAGIC, 0x01, GSW_register_t)
+
+/*@}*/ /* GSW_IOCTL_DEBUG */
+
+/** \addtogroup GSW_IOCTL_IRQ */
+/*@{*/
+/**
+   \brief Get the interrupt enable configuration. This assignment can be set using \ref GSW_IRQ_MASK_SET.
+
+   \param GSW_irq_t Pointer to an \ref GSW_irq_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+#define GSW_IRQ_MASK_GET	_IOWR(GSW_COMMON_MAGIC, 0x04, GSW_irq_t)
+
+/**
+   \brief Set the interrupt enable configuration. This assignment can be read using \ref GSW_IRQ_MASK_GET.
+   Setting interrupts that are not supported by hardware results in an error response.
+
+   \param GSW_irq_t Pointer to
+      an \ref GSW_irq_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+#define GSW_IRQ_MASK_SET	_IOW(GSW_COMMON_MAGIC, 0x05, GSW_irq_t)
+
+/**
+   \brief Read the interrupt status. Interrupt status indications can be cleared using \ref GSW_IRQ_STATUS_CLEAR.
+
+   \param GSW_irq_t Pointer to
+      an \ref GSW_irq_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+#define GSW_IRQ_GET	_IOWR(GSW_COMMON_MAGIC, 0x03, GSW_irq_t)
+
+/**
+   \brief Clear individual interrupt status bits. Interrupt status indications can be read using \ref GSW_IRQ_GET.
+
+   \param GSW_irq_t Pointer to
+      an \ref GSW_irq_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+#define GSW_IRQ_STATUS_CLEAR _IOW(GSW_COMMON_MAGIC, 0x06, GSW_irq_t)
+
+/*@}*/ /* GSW_IOCTL_IRQ */
+
+/** \addtogroup GSW_IOCTL_CLASS */
+/*@{*/
+
+/**
+   \brief This command writes a rule pattern and action to the table of the packet
+   classification engine. The pattern part describes the parameter to identify an
+   incoming packet to which the dedicated actions should be applied.
+   A rule can be read using the command \ref GSW_PCE_RULE_WRITE.
+
+   \param GSW_PCE_rule_t Pointer to \ref GSW_PCE_rule_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PCE_RULE_WRITE	_IOWR(GSW_TFLOW_MAGIC, 0x03, GSW_PCE_rule_t)
+
+/**
+   \brief This command allows the reading out of a rule pattern and action of the
+   packet classification engine.
+   A rule can be written using the command \ref GSW_PCE_RULE_WRITE.
+
+   \param GSW_PCE_rule_t Pointer to \ref GSW_PCE_rule_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PCE_RULE_READ	_IOWR(GSW_TFLOW_MAGIC, 0x02, GSW_PCE_rule_t)
+
+/**
+   \brief This command deletes a complete rule from the packet classification engine.
+   A delete operation is done on the rule of a dedicated index 'nIndex'.
+   A rule can be written over using the command \ref GSW_PCE_RULE_WRITE.
+
+   \param GSW_PCE_ruleDelete_t Pointer to \ref GSW_PCE_ruleDelete_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PCE_RULE_DELETE  _IOWR(GSW_TFLOW_MAGIC, 0x01, GSW_PCE_ruleDelete_t)
+
+
+/*@}*/ /* GSW_IOCTL_CLASS */
+
+/** \addtogroup GSW_IOCTL_SYS */
+/*@{*/
+
+/**
+   \brief Forces a hardware reset of the switch device or switch macro. The device
+   automatically comes back out of reset and contains the initial values.
+   All previous configurations and statistics counters info are lost.
+
+   \param GSW_reset_t Pointer to an \ref GSW_reset_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+   \remarks Not supported for all devices
+*/
+#define GSW_RESET	_IOW(GSW_COMMON_MAGIC, 0x08, GSW_reset_t)
+
+/**
+   \brief Read out additional traffic flow (RMON) counters.
+   The zero-based 'nPortId' structure element describes the physical switch
+   port for the requested statistic information.
+   This API is replaced by
+	  \ref GSW_RMON_FLOW_GET for GSWIP-3.1.
+
+   \param GSW_RMON_extendGet_t  Pointer to a pre-allocated
+   \ref GSW_RMON_extendGet_t structure. The structure element 'nPortId' is
+   an input parameter that describes from which port to read the RMON counter.
+   All remaining structure elements are filled with the counter values.
+   The counter assignment needs to be done during the flow definition,
+   for example in \ref GSW_PCE_RULE_WRITE.
+
+   \remarks The function returns an error in case the given 'nPortId' is
+   out of range.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_RMON_EXTEND_GET	_IOWR(GSW_RMON_MAGIC, 0x08, GSW_RMON_extendGet_t)
+
+/** \brief This command sets the packet timestamp reference counter.
+    This reference timer is a switch global timer which is used by the
+    packet timestamp capture when sending and receiving Ethernet port level.
+
+    The command \ref GSW_TIMESTAMP_TIMER_GET allows to read out
+    the current reference timer.
+
+   \param GSW_TIMESTAMP_Timer_t Pointer to an \ref GSW_TIMESTAMP_Timer_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_TIMESTAMP_TIMER_SET _IOW(GSW_COMMON_MAGIC, 0x1D, GSW_TIMESTAMP_Timer_t)
+
+/** \brief This command reads out the switch global reference timer counter that is
+    used by the packet timestamp capture when sending and receiving Ethernet port level.
+
+    This reference timer is useful when processing the packet related
+    timestamp information for delay calculation.
+
+    The reference timer can be configured by \ref GSW_TIMESTAMP_TIMER_SET.
+
+   \param GSW_TIMESTAMP_Timer_t Pointer to an \ref GSW_TIMESTAMP_Timer_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_TIMESTAMP_TIMER_GET _IOWR(GSW_COMMON_MAGIC, 0x1E, GSW_TIMESTAMP_Timer_t)
+
+/** \brief This command reads out the port related timestamp values. This timestamp is captured
+    for ingress and egress packets triggered due to a traffic flow table timestamp action.
+    A switch global reference timer is used for the timestamp capture operation.
+    This global timer can be access by using \ref GSW_TIMESTAMP_TIMER_SET
+    and \ref GSW_TIMESTAMP_TIMER_GET.
+
+    A port related packet timestamp is triggered by the flow table
+    action 'eTimestampAction'.
+
+   \param GSW_TIMESTAMP_PortRead_t Pointer to
+      an \ref GSW_TIMESTAMP_PortRead_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_TIMESTAMP_PORT_READ _IOWR(GSW_COMMON_MAGIC, 0x1F, GSW_TIMESTAMP_PortRead_t)
+
+/**
+   \brief Read out additional traffic flow (RMON) counters. GSWIP-3.1 only.
+
+   \param GSW_RMON_flowGet_t  Pointer to a pre-allocated
+   \ref GSW_RMON_flowGet_t structure.
+
+   \remarks The function returns an error in case the given 'nIndex' is
+   out of range.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_RMON_FLOW_GET _IOWR(GSW_RMON_MAGIC, 0x09, GSW_RMON_flowGet_t)
+
+/*@}*/ /* GSW_IOCTL_SYS */
+
+#endif /* _LANTIQ_GSW_FLOW_H_ */
diff --git a/include/net/switch_api/lantiq_gsw_routing.h b/include/net/switch_api/lantiq_gsw_routing.h
new file mode 100644
index 000000000000..c9e491df65d5
--- /dev/null
+++ b/include/net/switch_api/lantiq_gsw_routing.h
@@ -0,0 +1,395 @@
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+#ifndef _LANTIQ_GSW_ROUTE_H_
+#define _LANTIQ_GSW_ROUTE_H_
+
+
+#include "gsw_types.h"
+
+
+/** \defgroup PAE_API GSWIP-Routing/PAE specific APIs
+    \brief  GSWIP-Routing (PAE) APIs definition applicable to GSWIP-3.0 only.
+*/
+
+/** \addtogroup  PAE_API */
+/*@{*/
+
+/** \brief Unused flag status conveyed through value of Zero */
+#define GSW_ROUTE_F_NO_STATUS  0
+/** \brief Flag to indicate existent Entry got swapped to allow High-Priority entry creation */
+#define GSW_ROUTE_F_SWAP_OUT  1
+
+/** \brief Error Code indicating no availability in MTU Table */
+#define GSW_ROUTE_ERROR_MTU_FULL  -20
+/** \brief Error Code indicating no availability in PPPoE Table */
+#define GSW_ROUTE_ERROR_PPPOE_FULL  -21
+/** \brief Error Code indicating no availability in RTP Assignment Table */
+#define GSW_ROUTE_ERROR_RTP_FULL  -22
+/** \brief Error Code indicating no availability in IP Address Table */
+#define GSW_ROUTE_ERROR_IP_FULL  -23
+/** \brief Error Code indicating no availability in MAC Address Table */
+#define GSW_ROUTE_ERROR_MAC_FULL  -24
+/** \brief Error Code indicating no availability in Routing Session Table */
+#define GSW_ROUTE_ERROR_RT_SESS_FULL  -25
+/** \brief Error Code indicating no availability in Collision List */
+#define GSW_ROUTE_ERROR_RT_COLL_FULL  -26
+#define GSW_ROUTE_F_SWAP_OUT_ERR	-27
+/*!
+    \brief This is the data structure for PAE 6rd tunnel interface - Outer IPv4.
+*/
+typedef struct {
+	GSW_IP_t nSrcIP4Addr;   /*!< 6rd tunnel Source IPv4 address */
+	GSW_IP_t nDstIP4Addr;   /*!< 6rd tunnel Dest IPv4 address */
+} GSW_ROUTE_Tunnel_6rd;
+
+/*!
+    \brief This is the data structure for PAE DSLite tunnel interface - Outer IPv6.
+*/
+typedef struct {
+	GSW_IP_t nSrcIP6Addr;   /*!< DS-Lite tunnel Source IPv6 address */
+	GSW_IP_t nDstIP6Addr;   /*!< DS-Lite tunnel Dest IPv6 address */
+} GSW_ROUTE_Tunnel_DSLite;
+
+/*!
+    \brief This is the data structure for PAE Tunnel type selector. Used by  \ref GSW_ROUTE_Session_action_t.
+*/
+typedef enum {
+	GSW_ROUTE_TUNL_NULL = 0, /*!< Session routing tunnel type is No Tunnel action */
+	GSW_ROUTE_TUNL_6RD = 1, /*!< Session routing tunnel type is 6rd */
+	GSW_ROUTE_TUNL_DSLITE = 2, /*!< Session routing tunnel type is DSlite */
+	GSW_ROUTE_TUNL_L2TP = 3, /*!< Session routing tunnel type is L2TP */
+	GSW_ROUTE_TUNL_IPSEC = 4, /*!< Session routing tunnel type is IPsec */
+
+} GSW_ROUTE_Session_Tunmode_t;
+
+/*!
+    \brief This is the data structure for GSWIP Tunnel entry configuration Interface.
+*/
+typedef struct {
+	/*@{*/
+	GSW_ROUTE_Session_Tunmode_t eTunnelType; /*!< Tunnel type enum for DSLite, 6RD, IPSec, L2TP */
+	/*@}*/
+	/**
+	 * @name Union tunnel
+	 */
+
+	/*@{*/
+	union {
+		GSW_ROUTE_Tunnel_6rd    tun6RD; /*!< 6RD tunnel configuration */
+		u32                     nTunL2TP; /*!< L2TP tunnel configuration. Just a placeholder in union, since PAE only supports L2TP detunneling only */
+		u32                     nTunIPsec; /*!< IPsec crypto context configuration. GSWIP action not defined */
+		GSW_ROUTE_Tunnel_DSLite tunDSlite; /*!< DSlite tunnel configuration */
+	} t;
+	/*@}*/
+} GSW_ROUTE_Tunnel_t;
+
+
+
+/*!
+    \brief This is the data structure for GSWIP Routing Session Direction. Used by  \ref GSW_ROUTE_Session_action_t.
+*/
+typedef enum {
+	GSW_ROUTE_DIRECTION_DNSTREAM = 0, /*!< Session is LAN egress i.e WAN Downstream */
+	GSW_ROUTE_DIRECTION_UPSTREAM = 1, /*!< Session is LAN ingress i.e. WAN Upstream session */
+} GSW_ROUTE_Session_Direction_t;
+
+
+/*!
+    \brief This is the data structure for GSWIP Routing mode. Used by  \ref GSW_ROUTE_Session_action_t.
+*/
+typedef enum {
+	GSW_ROUTE_MODE_NULL = 0, /*!< Session routing type NULL. Can be used for Bridge sessions in RT table. */
+	GSW_ROUTE_MODE_ROUTING = 1, /*!< Session routing type plain routing without NAT/NAPT*/
+	GSW_ROUTE_MODE_NAT = 2, /*!< Session routing type is Src IP address NAT*/
+	GSW_ROUTE_MODE_NAPT = 3, /*!< Session routing type is Src IP/Port NAT */
+
+} GSW_ROUTE_Session_Routmode_t;
+
+/*!
+    \brief This is the data structure for GSWIP Routing Outer DSCP remarking action. Used by \ref GSW_ROUTE_Session_action_t.
+*/
+typedef enum {
+	GSW_ROUTE_OUT_DSCP_NULL = 0, /*!< Session routing no outer DSCP remarking action */
+	GSW_ROUTE_OUT_DSCP_INNER = 1, /*!< Session routing outer DSCP from inner IP header */
+	GSW_ROUTE_OUT_DSCP_SESSION = 2, /*!< Session routing outer DSCP from session action table */
+	GSW_ROUTE_OUT_DSCP_RES = 3, /*!< Session routing outer DSCP action reserved */
+
+} GSW_ROUTE_Session_Outer_DSCP_Remarking_t;
+
+/** \brief Routing Session selection for IP Address - IPv4/IPv6/Unused.
+    Used by \ref GSW_PCE_pattern_t. */
+typedef enum {
+	GSW_RT_IP_DISABLED	= 0, /*!< Routing IP selection disabled. */
+	GSW_RT_IP_V4	= 1, /*!< Routing IP selection type is IPv4. */
+	GSW_RT_IP_V6	= 2 /*!< Routing IP selection type is IPv6. */
+} GSW_RT_IP_t;
+
+/*!
+    \brief This is the data structure for GSWIP Routing Session Pattern Interface. SrcIP, DstIP, SrcPort, DstPort & RoutingExtensionId together is used as input keys for lookup of Routing sessions. Except RoutingExtensionId other fields in pattern are optional and decided through PCE rule - IP and Port Compare Selector.
+*/
+typedef struct {
+	GSW_RT_IP_t eIpType; /*!< IP Address Type - IPv4 or IPv6 or Unused */
+	GSW_IP_t nSrcIP;  /*!< The session source IPv4/v6 address used for hash computation. Internally this gets mapped to Routing IP Addr table. */
+	GSW_IP_t nDstIP; /*!< The session destination IPv4/v6 address for hash computation. Internally this gets mapped to Routing IP Addr table.  */
+	u16 nSrcPort;      /*!< TCP/UDP source port information - used in hash computation*/
+	u16 nDstPort;      /*!< TCP/UDP destination port information - used in hash computation*/
+	u8  nRoutExtId; /*!< Routing extension Id from Flow Table action. Valid value any 8-bit integer also matching to output of Flow rule. Used in hash index computation */
+	ltq_bool_t bValid;       /*!< Indicate, if a particular routing entry is valid or not */
+} GSW_ROUTE_Session_pattern_t;
+
+
+/*!
+    \brief This is the data structure for GSWIP Routing Session Action Interface.
+*/
+typedef struct {
+
+	u32 nDstPortMap;     /*!< Session destination port map specified in form of bitmask. E.g. Starting with least significant -  0th Bit position denotes port no. 0, 1st bit position denotes port no. 1 and so on. Bit vale of 1 indicates port is specified and 0 indicates port is not specified*/
+	u16 nDstSubIfId;     /*!< Session destination sub-interace Id. For multicast stream this field's GroupIndex part may carry the corresponding Group Id value.  */
+	GSW_RT_IP_t eIpType; /*!< IP Address Type - IPv4 or IPv6 or Unused */
+	GSW_IP_t nNATIPaddr;  /*!< Session new IP address after NAT for eIPType. */
+	u16  nTcpUdpPort;     /*!< Session new TCP/UDP port number. Used if eSessionRoutingMode is NAPT */
+	u16  nMTUvalue;       /*!< Session MTU value.*/
+	ltq_bool_t	bMAC_SrcEnable; /*!< Source MAC address used */
+	u8   nSrcMAC[6];      /*!< New source MAC address for the session. */
+	ltq_bool_t	bMAC_DstEnable; /*!< Destination MAC address used */
+	u8   nDstMAC[6];      /*!< New destination MAC address for the session */
+	ltq_bool_t bPPPoEmode;       /*!< Session PPPoE mode. Value
+                                     0:PPPoE Mode transparent.
+                                     1:PPPoE Mode Termination*/
+	u16 nPPPoESessId;      /*!< Session PPPoE Session Identifier used */
+	ltq_bool_t	bTunnel_Enable; /*!< Tunnel used selector */
+	GSW_ROUTE_Session_Tunmode_t eTunType; /*!< Session Tunnel type used*/
+	u8  nTunnelIndex;        /*!< Preconfigured tunnel Index. The tunnel Index maps to Tunnel table. First configure Tunnel entry and then set Index here (0..15) */
+	ltq_bool_t bMeterAssign;    /*!< MeterId assignment action. Value
+				     0:Assignment disabled.
+				     1:Assignment Enabled */
+	u8  nMeterId;         /*!< Meter Id used for the session. The metering configuration can be done using differnt switch api function */
+	ltq_bool_t bRTPMeasEna;     /*!< RTP Multicast session's sequence number counter Action. Value
+				     0:Counting Disabled .
+				     1:Counting Enabled */
+	u16 nRTPSeqNumber;      /*!< 16 bit RTP sequence number for which the multicast packet will be counted */
+	u16 nRTPSessionPktCnt;  /*!< 16 bit RTP packet Rolling Counter. R-O */
+	u8  nFID;  /*!< Session FID. Value 0-63, Session FID is used for Egress VLAN action */
+	u8  nFlowId; /*!< Flow Id value. Value 0-255. Default value is 0. */
+	GSW_ROUTE_Session_Outer_DSCP_Remarking_t eOutDSCPAction; /*!< Outer DSCP remarking action - Valid for Tunnel associated entries */
+	ltq_bool_t bInnerDSCPRemark; /*!< Session routing inner DSCP remarking action. Value
+				      0: No remarking.
+				      1: remarking based on session */
+	u8  nDSCP;  /*!< DSCP remarking value for the session */
+	ltq_bool_t bTCremarking; /*!< Routing session traffic class remarking action. Value
+				  0: No remarking.
+				  1: TC remarking enabled */
+	u8  nTrafficClass; /*!< Traffic class remarking value for the session */
+	u32 nSessionCtrs;   /*!< Session MIB Counters. - R-O */
+	GSW_ROUTE_Session_Direction_t eSessDirection; /*!<Session direction WAN-Downnstream or WAN-Upstream */
+	GSW_ROUTE_Session_Routmode_t eSessRoutingMode; /*!< Session routing action mode */
+	ltq_bool_t bTTLDecrement; /*!< Enable TTL decrement action for the session. Value
+				  0: TTL decrement disabled.
+				  1: TTL decrement enabled.*/
+	ltq_bool_t  bHitStatus;  /*!< Session hit Status - RW.*/
+
+} GSW_ROUTE_Session_action_t;
+
+/*!
+    \brief This is the data structure for GSWIP Routing Session Destination Information.
+*/
+typedef struct {
+	u16 nRtIdx;          /*!< Session Index */
+	u32 nDstPortMap;     /*!< Session destination port map specified in form of bit-mask with every bit position indicating corresponding port number.*/
+	u16 nDstSubIfId;     /*!< Session destination sub-interace Id.  */
+} GSW_ROUTE_Session_Dest_t;
+
+/*!
+    \brief This is the data structure for configuring Source L2NAT on egress port of PAE.
+*/
+typedef struct {
+	ltq_bool_t bL2NATEna;   /*!< Enable L2NAT on this egress port of PAE*/
+	u16  nEgPortId;     /*!< Egress Port Id */
+	u8   nNatMAC[6];    /*!< New source MAC address for L2NAT on this egress port*/
+
+} GSW_ROUTE_EgPort_L2NAT_Cfg_t;
+
+/*!
+    \brief This is the data structure for GSWIP Routing Session Entry.
+*/
+typedef struct {
+	GSW_ROUTE_Session_pattern_t    pattern; /*!< The structure for routing session pattern parameters */
+	GSW_ROUTE_Session_action_t     action;  /*!< The structure for routing session action associated with the above pattern */
+} GSW_ROUTE_session_t;
+
+/*!
+    \brief This is the data structure for GSWIP Routing Session Table Entry.
+*/
+typedef struct {
+	int                  nHashVal; /*!< Routing Session Entry Hash Value - optional (valid range : 0..4095). When not supplied, carries a special value of (-1) */
+	int                  nRtIndex; /*!< Routing Session Entry Index Value - returned in ADD operation. Mandatorily, to be passed for the rest of operations */
+	GSW_ROUTE_session_t  routeEntry; /*!< Routing Session pattern and action values. */
+	ltq_bool_t           bPrio;    /*!< Indicate it is a priority session - mandatorily used in ADD. If set then it can replace normal session if table is full*/
+	u32                  nFlags;   /*!< Flags to indicate special status E.g. - Swap done (1), Free (2),  etc. */
+
+} GSW_ROUTE_Entry_t;
+
+
+/*!
+    \brief This is the data structure for GSWIP Routing Tunnel Table Entry.
+*/
+typedef struct {
+	int                 nTunIndex; /*!< Tunnel table entry index, optional in case of Add operation (-1). When (-1) is supplied the API would return assigned index */
+	GSW_ROUTE_Tunnel_t  tunnelEntry; /*!< Tunnel Table Entry */
+
+} GSW_ROUTE_Tunnel_Entry_t;
+
+
+/*!
+    \brief This is the enumeration for GSWIP Routing Hit Status action. Used by  \ref GSW_ROUTE_Session_Hit_t.
+*/
+typedef enum {
+	GSW_ROUTE_HIT_READ = 0, /*!< Session routing Hit Status Read Action */
+	GSW_ROUTE_HIT_CLEAR = 1, /*!< Session routing Hit Status Clear Action */
+	GSW_ROUTE_HIT_N_CNTR_READ = 2, /*!< Session routing Hit Status & Session Counters Read Action */
+	GSW_ROUTE_HIT_N_CNTR_CLEAR = 3 /*!< Session routing Hit Status & Session Counters Clear Action */
+} GSW_ROUTE_Session_HitOp_t;
+
+/*!
+    \brief This is the data structure for handling Session Hit Status in PAE.
+*/
+typedef struct {
+	GSW_ROUTE_Session_HitOp_t eHitOper; /*!< Session Hit Operation */
+	int                       nRtIndex; /*!< Routing Session Index */
+	ltq_bool_t                bHitStatus; /*!< Session Hit Status*/
+	u32                       nSessCntr; /*!< Session Counter - Packet or Bytes programmed using RMON API */
+} GSW_ROUTE_Session_Hit_t;
+
+/**
+   \brief This command adds a routing session of specified pattern and action. The pattern part describes the parameters to identify an incoming packet session to which the dedicated actions should be applied. Packets having the same pattern field belongs to same session and applied to same action.  A routing rule and action can be read using the command \ref GSW_ROUTE_ENTRY_READ.
+
+   \remarks If a priority session addition is attempted and there is no space for new session then one of the existing normal session would be replaced by this new priority session. The replaced entry is returned in this case through GSW_Route_Entry_t pointer.
+   \param GSW_ROUTE_Entry_t Pointer to \ref GSW_ROUTE_Entry_t containing the session information filled by ioctl caller. This structure carries the config of replaced entry when swapped by high priority entry.
+
+   \remarks If any error happens during creation of session or configuring the individual unit tables, this error code of negative value is conveyed back to caller.
+
+   \return Return value as follows:
+   - GSW_SUCCESS: if successful
+   - An error code <0, in case an error occurs
+*/
+#define GSW_ROUTE_ENTRY_ADD _IOWR(GSW_ROUTE_MAGIC, 0x01, GSW_ROUTE_Entry_t)
+
+/**
+   \brief This command deletes an earlier added routing session of specified index and pattern. It is must specify the index returned during creation. The pattern part is only used for comparing with the pattern stored in index. A routing rule and action of specified index can be read using the command \ref GSW_ROUTE_ENTRY_READ.
+
+   \param GSW_ROUTE_Entry_t Pointer to \ref GSW_ROUTE_Entry_t containing the session information filled by ioctl caller. This structure carries the config of replaced entry when swapped by high prirority entry.
+
+   \return Return value as follows:
+   - GSW_SUCCESS: if successful
+   - An error code <0, in case an error occurs E.g. Invalid index, Non-matching pattern at specified index.
+*/
+#define GSW_ROUTE_ENTRY_DELETE _IOW(GSW_ROUTE_MAGIC, 0x02, GSW_ROUTE_Entry_t)
+
+/**
+   \brief This command reads a Routing session config (pattern and action info) for the given index.
+   A routing session (pattern and action) can be added using the command \ref GSW_ROUTE_ENTRY_ADD.
+
+   \param GSW_ROUTE_Entry_t Pointer to \ref GSW_ROUTE_Entry_t containing the index. The stored session configuration is returned to caller.
+
+
+   \return Return value as follows:
+   - GSW_SUCCESS: if successful
+   - An error code <0, in case an error occurs
+*/
+#define GSW_ROUTE_ENTRY_READ _IOWR(GSW_ROUTE_MAGIC, 0x03, GSW_ROUTE_Entry_t)
+
+
+/**
+   \brief This command adds a new Tunnel entry in the Routing Tunnel table. The Tunnel entry can be read using the command \ref GSW_ROUTE_TUNNEL_ENTRY_READ.
+
+   \param GSW_ROUTE_Tunnel_Entry_t Pointer to \ref GSW_ROUTE_Tunnel_Entry_t containing the values of a tunnel type and associated attributes.
+
+   \return Return value as follows:
+   - GSW_SUCCESS: if successful
+   - An error code <0, in case any error occurs (e.g. Tunnel table is full error)
+*/
+#define GSW_ROUTE_TUNNEL_ENTRY_ADD _IOW(GSW_ROUTE_MAGIC, 0x04, GSW_ROUTE_Tunnel_Entry_t)
+
+/**
+   \brief This command deletes  a specified Tunnel entry in the Routing Tunnel table. The Tunnel entry can be read using the command \ref GSW_ROUTE_TUNNEL_ENTRY_READ.
+
+   \param GSW_ROUTE_Tunnel_Entry_t Pointer to \ref GSW_ROUTE_Tunnel_Entry_t containing the Tunnel-Index and tunnel config values. The values are used to match and perform verification with stored values in Tunnel table at specified index.
+
+   \return Return value as follows:
+   - GSW_SUCCESS: if successful
+   - An error code <0, in case any error occurs (e.g. Invalid Tunnel Index, Tunnel value is not matching with what is stored in Tunnel table etc.)
+*/
+#define GSW_ROUTE_TUNNEL_ENTRY_DELETE _IOW(GSW_ROUTE_MAGIC, 0x06, GSW_ROUTE_Tunnel_Entry_t)
+
+/**
+   \brief This command reads the Tunnel values from the routing Tunnel table at a given specified Tunnel Index.
+   A Tunnel entry can be written using the command \ref GSW_ROUTE_TUNNEL_ENTRY_ADD.
+
+   \param GSW_ROUTE_Tunnel_Entry_t Pointer to \ref GSW_ROUTE_Tunnel_Entry_t containing the Tunnel-Index as input. The tunnel config values at specified index is returned back to caller.
+
+   \return Return value as follows:
+   - GSW_SUCCESS: if successful
+   - An error code <0, in case an error occurs
+*/
+#define GSW_ROUTE_TUNNEL_ENTRY_READ _IOWR(GSW_ROUTE_MAGIC, 0x05, GSW_ROUTE_Tunnel_Entry_t)
+
+/**
+   \brief This command configures L2NAT on egress port of PAE. When enabled the Source MAC Address of
+          traffic leaving specified egress port would be NAT-ed with configured MAC address.
+
+   \param  GSW_ROUTE_EgPort_L2NAT_Cfg_t  L2NAT Attributes as defined in \ref GSW_ROUTE_EgPort_L2NAT_Cfg_t.
+
+   \return Return value as follows:
+   - GSW_SUCCESS: if successful
+   - An error code in case any error occurs
+*/
+#define GSW_ROUTE_L2NAT_CFG_WRITE _IOW(GSW_ROUTE_MAGIC, 0x07, GSW_ROUTE_EgPort_L2NAT_Cfg_t)
+
+/**
+   \brief This command reads L2NAT configurations on specified egress port of PAE.
+
+   \param  GSW_ROUTE_EgPort_L2NAT_Cfg_t  L2NAT Attributes as defined in \ref GSW_ROUTE_EgPort_L2NAT_Cfg_t.
+
+   \return Return value as follows:
+   - GSW_SUCCESS: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_ROUTE_L2NAT_CFG_READ _IOWR(GSW_ROUTE_MAGIC, 0x08, GSW_ROUTE_EgPort_L2NAT_Cfg_t)
+
+/**
+   \brief This command reads or reads-n-clears Hit-Status for high priority sessions.
+
+   \param  GSW_ROUTE_Session_Hit_t  Hit Status Data struct carrying operation.
+
+   \return Return value is Session Hit Status:
+   - 1 : if session status is Hit (before cleared).
+   - 0 : if session status is Not-Hit (before cleared).
+   - (-1) : if any error is encountered.
+*/
+
+#define GSW_ROUTE_SESSION_HIT_OP _IOWR(GSW_ROUTE_MAGIC, 0x09, GSW_ROUTE_Session_Hit_t)
+
+/**
+   \brief This command modifies the destination of an existing Routing session.
+
+   \param  GSW_ROUTE_Session_Dest_t  Data struct carrying Routing session index and destination portmap & sub-interface configuration.
+
+   \return Return value is
+   - GSW_SUCCESS : if successful.
+   - An error code in case an error occurs
+*/
+
+#define GSW_ROUTE_SESSION_DEST_MOD _IOWR(GSW_ROUTE_MAGIC, 0x0A, GSW_ROUTE_Session_Dest_t)
+
+/*@}*/ /* PAE_API */
+
+#endif /* _LANTIQ_GSW_ROUTE_H_ */
