From acbb9f9d9caa07ad1d66f47fcafcb32b15f31abc Mon Sep 17 00:00:00 2001
From: Li Yin <yin1.li@intel.com>
Date: Mon, 13 May 2019 11:38:28 +0800
Subject: [PATCH] DRVLIV_SW-2222 merge dp_get_port_info() changes from
 lgm-dev-x64

---
 drivers/net/datapath/dpm/datapath.h                |  34 ++-
 drivers/net/datapath/dpm/datapath_api.c            | 331 ++++++++++-----------
 drivers/net/datapath/dpm/datapath_logical_dev.c    |  11 +-
 drivers/net/datapath/dpm/datapath_misc.c           |   8 +-
 drivers/net/datapath/dpm/datapath_notifier.c       |  24 +-
 drivers/net/datapath/dpm/datapath_proc.c           | 119 ++++----
 drivers/net/datapath/dpm/datapath_proc_qos.c       |  22 +-
 drivers/net/datapath/dpm/datapath_qos.c            |   2 +-
 drivers/net/datapath/dpm/datapath_swdev.c          |  20 +-
 drivers/net/datapath/dpm/gswip30/datapath_mib.c    |  60 ++--
 drivers/net/datapath/dpm/gswip30/datapath_misc.c   |  29 +-
 drivers/net/datapath/dpm/gswip30/datapath_proc.c   |  61 ++--
 drivers/net/datapath/dpm/gswip30/datapath_rx.c     |  58 ++--
 drivers/net/datapath/dpm/gswip30/datapath_tx.c     |  24 +-
 drivers/net/datapath/dpm/gswip31/datapath_gswip.c  |  36 +--
 .../datapath/dpm/gswip31/datapath_lookup_proc.c    |   2 +-
 drivers/net/datapath/dpm/gswip31/datapath_misc.c   | 122 ++++----
 .../net/datapath/dpm/gswip31/datapath_ppv4_api.c   |   8 +-
 drivers/net/datapath/dpm/gswip31/datapath_proc.c   |  17 +-
 drivers/net/datapath/dpm/gswip31/datapath_rx.c     |  61 ++--
 .../net/datapath/dpm/gswip31/datapath_switchdev.c  |  17 +-
 drivers/net/datapath/dpm/gswip31/datapath_tx.c     |  26 +-
 drivers/net/datapath/dpm/gswip32/datapath_gswip.c  |  20 +-
 drivers/net/datapath/dpm/gswip32/datapath_misc.c   |  49 +--
 drivers/net/datapath/dpm/gswip32/datapath_proc.c   |   9 +-
 .../net/datapath/dpm/gswip32/datapath_switchdev.c  |   2 +-
 26 files changed, 592 insertions(+), 580 deletions(-)

diff --git a/drivers/net/datapath/dpm/datapath.h b/drivers/net/datapath/dpm/datapath.h
index ba6878a0c240..17b24b599faf 100644
--- a/drivers/net/datapath/dpm/datapath.h
+++ b/drivers/net/datapath/dpm/datapath.h
@@ -128,12 +128,6 @@
 #define STATS_SET(atomic, val) atomic_set(&(atomic), val)
 #define DP_CB(i, x) dp_port_prop[i].info.x
 
-#define PORT(inst, ep) &dp_port_info[inst][ep]
-#define PORT_INFO(inst, ep, x) dp_port_info[inst][ep].x
-#define PORT_SUBIF(inst, ep, ix, x) dp_port_info[inst][ep].subif_info[ix].x
-#define PORT_VAP_MIB(i, ep, vap, x) dp_port_info[i][ep].subif_info[vap].mib.x
-#define PORT_VAP(i, ep, vap, x) dp_port_info[i][ep].subif_info[vap].x
-
 #define dp_set_val(reg, val, mask, offset) do {\
 	(reg) &= ~(mask);\
 	(reg) |= (((val) << (offset)) & (mask));\
@@ -743,6 +737,32 @@ extern struct dp_sched_info dp_sched_tbl[DP_MAX_INST][DP_MAX_SCHED_NUM];
 extern struct cqm_port_info dp_deq_port_tbl[DP_MAX_INST][DP_MAX_CQM_DEQ];
 extern struct bp_pmapper_dev dp_bp_dev_tbl[DP_MAX_INST][DP_MAX_BP_NUM];
 extern struct dma_chan_info *dp_dma_chan_tbl[DP_MAX_INST];
+
+static inline struct inst_property *get_dp_port_prop(int inst)
+{
+	if (inst >= 0)
+		return &dp_port_prop[inst];
+	return NULL;
+}
+
+static inline struct pmac_port_info *get_dp_port_info(int inst, int index)
+{
+	if (index < dp_port_prop[inst].info.cap.max_num_dp_ports)
+		return &dp_port_info[inst][index];
+	return NULL;
+}
+
+static inline struct dp_subif_info *get_dp_port_subif(
+	const struct pmac_port_info *port, u16 subif_id)
+{
+	return &port->subif_info[subif_id];
+}
+
+static inline struct dev_mib *get_dp_port_subif_mib(struct dp_subif_info *sif)
+{
+	return &sif->mib;
+}
+
 extern u32 dp_dbg_flag;
 extern unsigned int dp_dbg_err;
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_DBG)
@@ -839,8 +859,6 @@ int get_vlan_info(struct net_device *dev, struct vlan_info *vinfo);
 int dp_basic_proc(void);
 
 struct inst_property *get_dp_port_prop(int inst);
-struct pmac_port_info *get_dp_port_info(int inst, int index);
-struct pmac_port_info *get_port_info(int inst, int index);
 struct pmac_port_info *get_port_info_via_dp_port(int inst, int dp_port);
 
 void set_dp_dbg_flag(uint32_t flags);
diff --git a/drivers/net/datapath/dpm/datapath_api.c b/drivers/net/datapath/dpm/datapath_api.c
index f4c279c86a36..d61c30746695 100644
--- a/drivers/net/datapath/dpm/datapath_api.c
+++ b/drivers/net/datapath/dpm/datapath_api.c
@@ -167,35 +167,10 @@ int parser_enabled(int ep, struct dma_rx_desc_1 *desc_1)
 	return 0;
 }
 
-struct inst_property *get_dp_port_prop(int inst)
-{
-	if (!((inst < 0) || (inst >= DP_MAX_INST)))
-		return &dp_port_prop[inst];
-	return NULL;
-}
-EXPORT_SYMBOL(get_dp_port_prop);
-
-struct pmac_port_info *get_dp_port_info(int inst, int index)
-{
-	if (!((inst < 0) || (inst >= DP_MAX_INST)) &&
-	    (index < dp_port_prop[inst].info.cap.max_num_dp_ports))
-		return &dp_port_info[inst][index];
-	return NULL;
-}
-EXPORT_SYMBOL(get_dp_port_info);
-
-struct pmac_port_info *get_port_info(int inst, int index)
-{
-	if (index < dp_port_prop[inst].info.cap.max_num_dp_ports)
-		return &dp_port_info[inst][index];
-
-	return NULL;
-}
-
 u32 *get_port_flag(int inst, int index)
 {
 	if (index < dp_port_prop[inst].info.cap.max_num_dp_ports)
-		return &dp_port_info[inst][index].alloc_flags;
+		return &get_dp_port_info(inst, index)->alloc_flags;
 
 	return NULL;
 }
@@ -206,9 +181,11 @@ struct pmac_port_info *get_port_info_via_dp_port(int inst, int dp_port)
 	int i;
 
 	for (i = 0; i < dp_port_prop[inst].info.cap.max_num_dp_ports; i++) {
-		if ((dp_port_info[inst][i].status & PORT_DEV_REGISTERED) &&
-		    (dp_port_info[inst][i].port_id == dp_port))
-			return &dp_port_info[inst][i];
+		struct pmac_port_info *port = get_dp_port_info(inst, i);
+
+		if ((port->status & PORT_DEV_REGISTERED) &&
+		    (port->port_id == dp_port))
+			return port;
 	}
 
 	return NULL;
@@ -220,9 +197,10 @@ struct pmac_port_info *get_port_info_via_dev(struct net_device *dev)
 	int inst = dp_get_inst_via_dev(dev, NULL, 0);
 
 	for (i = 0; i < dp_port_prop[inst].info.cap.max_num_dp_ports; i++) {
-		if ((dp_port_info[inst][i].status & PORT_DEV_REGISTERED) &&
-		    (dp_port_info[inst][i].dev == dev))
-			return &dp_port_info[inst][i];
+		struct pmac_port_info *port = get_dp_port_info(inst, i);
+
+		if ((port->status & PORT_DEV_REGISTERED) && (port->dev == dev))
+			return port;
 	}
 	return NULL;
 }
@@ -344,6 +322,7 @@ static int32_t dp_alloc_port_private(int inst,
 {
 	int i;
 	struct cbm_dp_alloc_data cbm_data = {0};
+	struct pmac_port_info *port;
 
 	if (!owner) {
 		PR_ERR("Allocate port failed for owner NULL\n");
@@ -370,32 +349,32 @@ static int32_t dp_alloc_port_private(int inst,
 #endif
 	cbm_data.dp_inst = inst;
 	cbm_data.cbm_inst = dp_port_prop[inst].cbm_inst;
+	port = get_dp_port_info(inst, port_id);
 
 	if (flags & DP_F_DEREGISTER) {	/*De-register */
-		if (dp_port_info[inst][port_id].status != PORT_ALLOCATED) {
+		if (port->status != PORT_ALLOCATED) {
 			PR_ERR
 			    ("No Deallocate for module %s w/o deregistered\n",
 			     owner->name);
 			return DP_FAILURE;
 		}
-		cbm_data.deq_port = dp_port_info[inst][port_id].deq_port_base;
-		cbm_data.dma_chan = dp_port_info[inst][port_id].dma_chan;
+		cbm_data.deq_port = port->deq_port_base;
+		cbm_data.dma_chan = port->dma_chan;
 		cbm_dp_port_dealloc(owner, dev_port, port_id, &cbm_data, flags);
 		dp_inst_insert_mod(owner, port_id, inst, 0);
 		DP_DEBUG(DP_DBG_FLAG_REG, "de-alloc port %d\n", port_id);
 		DP_CB(inst, port_platform_set)(inst, port_id, data, flags);
 		/* Only clear those fields we need to clear */
-		memset(&dp_port_info[inst][port_id], 0,
-		       offsetof(struct pmac_port_info, tail));
+		memset(port, 0, offsetof(struct pmac_port_info, tail));
 		return DP_SUCCESS;
 	}
 	if (port_id) { /*with specified port_id */
-		if (dp_port_info[inst][port_id].status != PORT_FREE) {
+		if (port->status != PORT_FREE) {
 			PR_ERR("%s %s(%s %d) fail: port %d used by %s %d\n",
 			       "module", owner->name,
 			       "dev_port", dev_port, port_id,
-			       dp_port_info[inst][port_id].owner->name,
-			       dp_port_info[inst][port_id].dev_port);
+			       port->owner->name,
+			       port->dev_port);
 			return DP_FAILURE;
 		}
 	}
@@ -417,30 +396,30 @@ static int32_t dp_alloc_port_private(int inst,
 		 "cbm alloc dpport:%d deq:%d dmachan=0x%x deq_num:%d\n",
 		 cbm_data.dp_port, cbm_data.deq_port, cbm_data.dma_chan,
 		 cbm_data.deq_port_num);
-	
+
 	port_id = cbm_data.dp_port;
 	/* Only clear those fields we need to clear */
-	memset(&dp_port_info[inst][port_id], 0,
-	       offsetof(struct pmac_port_info, tail));
+	port = get_dp_port_info(inst, port_id);
+	memset(port, 0, offsetof(struct pmac_port_info, tail));
 	/*save info from caller */
-	dp_port_info[inst][port_id].owner = owner;
-	dp_port_info[inst][port_id].dev = dev;
-	dp_port_info[inst][port_id].dev_port = dev_port;
-	dp_port_info[inst][port_id].alloc_flags = flags;
-	dp_port_info[inst][port_id].status = PORT_ALLOCATED;
+	port->owner = owner;
+	port->dev = dev;
+	port->dev_port = dev_port;
+	port->alloc_flags = flags;
+	port->status = PORT_ALLOCATED;
 	/*save info from cbm_dp_port_alloc*/
-	dp_port_info[inst][port_id].flag_other = cbm_data.flags;
-	dp_port_info[inst][port_id].port_id = cbm_data.dp_port;
-	dp_port_info[inst][port_id].deq_port_base = cbm_data.deq_port;
-	dp_port_info[inst][port_id].deq_port_num = cbm_data.deq_port_num;
+	port->flag_other = cbm_data.flags;
+	port->port_id = cbm_data.dp_port;
+	port->deq_port_base = cbm_data.deq_port;
+	port->deq_port_num = cbm_data.deq_port_num;
 	DP_DEBUG(DP_DBG_FLAG_REG,
 		 "cbm alloc dp_port:%d deq:%d deq_num:%d\n",
 		 cbm_data.dp_port, cbm_data.deq_port, cbm_data.deq_port_num);
 
-	dp_port_info[inst][port_id].num_dma_chan = cbm_data.num_dma_chan;
+	port->num_dma_chan = cbm_data.num_dma_chan;
 #if 1  /* TODO: Hardcorded currently, later need to align with CQM */
-	dp_port_info[inst][port_id].policy_base = 0;
-	dp_port_info[inst][port_id].policy_num = 4;
+	port->policy_base = 0;
+	port->policy_num = 4;
 #endif
 	if (cbm_data.num_dma_chan) {
 		u16 dma_ch_base;
@@ -451,30 +430,30 @@ static int32_t dp_alloc_port_private(int inst,
 			cbm_dp_port_dealloc(owner, dev_port, port_id, &cbm_data,
 					    flags | DP_F_DEREGISTER);
 			/* Only clear those fields we need to clear */
-			memset(&dp_port_info[inst][port_id], 0,
+			memset(port, 0,
 			       offsetof(struct pmac_port_info, tail));
 			return DP_FAILURE;
 		}
-		dp_port_info[inst][port_id].dma_ch_base = dma_ch_base;
+		port->dma_ch_base = dma_ch_base;
 	}
 	/*save info to port data*/
-	data->deq_port_base = dp_port_info[inst][port_id].deq_port_base;
-	data->deq_num = dp_port_info[inst][port_id].deq_port_num;
+	data->deq_port_base = port->deq_port_base;
+	data->deq_num = port->deq_port_num;
 	if (cbm_data.flags & CBM_PORT_DMA_CHAN_SET)
-		dp_port_info[inst][port_id].dma_chan = cbm_data.dma_chan;
+		port->dma_chan = cbm_data.dma_chan;
 	if (cbm_data.flags & CBM_PORT_PKT_CRDT_SET)
-		dp_port_info[inst][port_id].tx_pkt_credit =
+		port->tx_pkt_credit =
 				cbm_data.tx_pkt_credit;
 	if (cbm_data.flags & CBM_PORT_BYTE_CRDT_SET)
-		dp_port_info[inst][port_id].tx_b_credit = cbm_data.tx_b_credit;
+		port->tx_b_credit = cbm_data.tx_b_credit;
 	if (cbm_data.flags & CBM_PORT_RING_ADDR_SET) {
-		dp_port_info[inst][port_id].tx_ring_addr = cbm_data.tx_ring_addr;
-		dp_port_info[inst][port_id].tx_ring_addr_push = cbm_data.tx_ring_addr_txpush;
+		port->tx_ring_addr = cbm_data.tx_ring_addr;
+		port->tx_ring_addr_push = cbm_data.tx_ring_addr_txpush;
 	}
 	if (cbm_data.flags & CBM_PORT_RING_SIZE_SET)
-	dp_port_info[inst][port_id].tx_ring_size = cbm_data.tx_ring_size;
+	port->tx_ring_size = cbm_data.tx_ring_size;
 	if (cbm_data.flags & CBM_PORT_RING_OFFSET_SET)
-		dp_port_info[inst][port_id].tx_ring_offset =
+		port->tx_ring_offset =
 				cbm_data.tx_ring_offset;
 	if((cbm_data.num_dma_chan > 1) && (cbm_data.deq_port_num !=
 	   cbm_data.num_dma_chan)) {
@@ -490,7 +469,7 @@ static int32_t dp_alloc_port_private(int inst,
 		cbm_dp_port_dealloc(owner, dev_port, port_id, &cbm_data,
 				    flags | DP_F_DEREGISTER);
 		/* Only clear those fields we need to clear */
-		memset(&dp_port_info[inst][port_id], 0,
+		memset(port, 0,
 		       offsetof(struct pmac_port_info, tail));
 		return DP_FAILURE;
 	}
@@ -500,8 +479,7 @@ static int32_t dp_alloc_port_private(int inst,
 	if (!inst && dp_port_prop[inst].info.init_dma_pmac_template)
 		dp_port_prop[inst].info.init_dma_pmac_template(port_id, flags);
 	for (i = 0; i < dp_port_prop[inst].info.cap.max_num_subif_per_port; i++)
-		INIT_LIST_HEAD(&dp_port_info[inst][port_id].
-			subif_info[i].logic_dev);
+		INIT_LIST_HEAD(&get_dp_port_subif(port, i)->logic_dev);
 	dp_inst_insert_mod(owner, port_id, inst, 0);
 
 	DP_DEBUG(DP_DBG_FLAG_REG,
@@ -522,9 +500,10 @@ int32_t dp_register_subif_private(int inst, struct module *owner,
 	struct pmac_port_info *port_info;
 	struct cbm_dp_en_data cbm_data = {0};
 	struct subif_platform_data platfrm_data = {0};
+	struct dp_subif_info *sif;
 
 	port_id = subif_id->port_id;
-	port_info = &dp_port_info[inst][port_id];
+	port_info = get_dp_port_info(inst, port_id);
 	subif_id->inst = inst;
 	subif_id->subif_num = 1;
 	platfrm_data.subif_data = data;
@@ -572,7 +551,8 @@ int32_t dp_register_subif_private(int inst, struct module *owner,
 		u32 cqm_deq_port;
 		u32 dma_ch_offset;
 
-		if (port_info->subif_info[i].flags) /*used already & not free*/
+		sif = get_dp_port_subif(port_info, i);
+		if (sif->flags) /*used already & not free*/
 			continue;
 
 		/*now find a free subif or valid subif
@@ -593,30 +573,30 @@ int32_t dp_register_subif_private(int inst, struct module *owner,
 			PR_ERR("port info status fail for 0\n");
 			return res;
 		}
-		cqm_deq_port = port_info->subif_info[i].cqm_deq_port;
+		cqm_deq_port = sif->cqm_deq_port;
 		dma_ch_offset =
 			dp_deq_port_tbl[inst][cqm_deq_port].dma_ch_offset;
 
-		port_info->subif_info[i].flags = 1;
-		port_info->subif_info[i].netif = dev;
+		sif->flags = 1;
+		sif->netif = dev;
 		port_info->port_id = port_id;
 
 		if (subif_id->subif < 0) /*dynamic:shift bits as HW defined*/
-			port_info->subif_info[i].subif =
+			sif->subif =
 				SET_VAP(i, port_info->vap_offset,
 					port_info->vap_mask);
 		else /*provided by caller since it is alerady shifted properly*/
-			port_info->subif_info[i].subif =
+			sif->subif =
 			    subif_id->subif;
-		strncpy(port_info->subif_info[i].device_name,
+		strncpy(sif->device_name,
 			subif_name,
-		       sizeof(port_info->subif_info[i].device_name) - 1);
-		port_info->subif_info[i].flags = PORT_SUBIF_REGISTERED;
-		port_info->subif_info[i].subif_flag = flags;
-		STATS_SET(port_info->subif_info[i].rx_flag, 1);
+		       sizeof(sif->device_name) - 1);
+		sif->flags = PORT_SUBIF_REGISTERED;
+		sif->subif_flag = flags;
+		STATS_SET(sif->rx_flag, 1);
 		port_info->status = PORT_SUBIF_REGISTERED;
 		subif_id->port_id = port_id;
-		subif_id->subif = port_info->subif_info[i].subif;
+		subif_id->subif = sif->subif;
 		/* set port as LCT port */
 		if (data->flag_ops & DP_F_DATA_LCT_SUBIF)
 			port_info->lct_idx = i;
@@ -669,12 +649,11 @@ int32_t dp_register_subif_private(int inst, struct module *owner,
 
 	if (i < end) {
 		res = DP_SUCCESS;
-		if (dp_bp_dev_tbl[inst][port_info->subif_info[i].bp].
-		    ref_cnt > 1)
+		if (dp_bp_dev_tbl[inst][sif->bp].ref_cnt > 1)
 			return res;
 		dp_inst_add_dev(dev, subif_name,
 				subif_id->inst, subif_id->port_id,
-				port_info->subif_info[i].bp,
+				sif->bp,
 				subif_id->subif, flags);
 	} else {
 		DP_DEBUG(DP_DBG_FLAG_REG,
@@ -696,9 +675,10 @@ int32_t dp_deregister_subif_private(int inst, struct module *owner,
 	struct pmac_port_info *port_info;
 	struct cbm_dp_en_data cbm_data = {0};
 	struct subif_platform_data platfrm_data = {0};
+	struct dp_subif_info *sif;
 
 	port_id = subif_id->port_id;
-	port_info = &dp_port_info[inst][port_id];
+	port_info = get_dp_port_info(inst, port_id);
 	platfrm_data.subif_data = data;
 	platfrm_data.dev = dev;
 
@@ -718,8 +698,8 @@ int32_t dp_deregister_subif_private(int inst, struct module *owner,
 	}
 
 	for (i = 0; i < port_info->ctp_max; i++) {
-		if (port_info->subif_info[i].subif ==
-		    subif_id->subif) {
+		sif = get_dp_port_subif(port_info, i);
+		if (sif->subif == subif_id->subif) {
 			find = 1;
 			break;
 		}
@@ -730,28 +710,27 @@ int32_t dp_deregister_subif_private(int inst, struct module *owner,
 	DP_DEBUG(DP_DBG_FLAG_REG,
 		 "Found matched subif: port_id=%d subif=%x vap=%d\n",
 		 subif_id->port_id, subif_id->subif, i);
-	if (port_info->subif_info[i].netif != dev) {
+	if (sif->netif != dev) {
 		/* device not match. Maybe it is unexplicit logical dev */
-		res = del_logic_dev(inst, &port_info->subif_info[i].logic_dev,
+		res = del_logic_dev(inst, &sif->logic_dev,
 				    dev, flags);
 		return res;
 	}
 	/* reset LCT port */
 	if (data->flag_ops & DP_F_DATA_LCT_SUBIF)
 		port_info->lct_idx = 0;
-	if (!list_empty(&port_info->subif_info[i].logic_dev)) {
+	if (!list_empty(&sif->logic_dev)) {
 		DP_DEBUG(DP_DBG_FLAG_REG,
 			 "Unregister fail: logic_dev of %s not empty yet!\n",
 			 subif_name);
 		return res;
 	}
-	cqm_port = port_info->subif_info[i].cqm_deq_port;
-	bp = port_info->subif_info[i].bp;
+	cqm_port = sif->cqm_deq_port;
+	bp = sif->bp;
 	/* reset mib, flag, and others */
-	memset(&port_info->subif_info[i].mib, 0,
-	       sizeof(port_info->subif_info[i].mib));
-	port_info->subif_info[i].flags = 0;
-	port_info->subif_info[i].netif = NULL;
+	memset(&sif->mib, 0, sizeof(sif->mib));
+	sif->flags = 0;
+	sif->netif = NULL;
 	port_info->num_subif--;
 	if (dp_port_prop[inst].info.subif_platform_set(inst,
 						       port_id, i,
@@ -939,7 +918,7 @@ int32_t dp_register_dev_ext(int inst, struct module *owner, uint32_t port_id,
 
 		return DP_FAILURE;
 	}
-	port_info = &dp_port_info[inst][port_id];
+	port_info = get_dp_port_info(inst, port_id);
 
 	DP_LIB_LOCK(&dp_lock);
 	if (flags & DP_F_DEREGISTER) {	/*de-register */
@@ -1056,7 +1035,7 @@ int32_t dp_register_subif_ext(int inst, struct module *owner,
 		return DP_FAILURE;
 	}
 	port_id = subif_id->port_id;
-	port_info = &dp_port_info[inst][port_id];
+	port_info = get_dp_port_info(inst, port_id);
 
 	if (((!dev) && !(port_info->alloc_flags & DP_F_FAST_DSL)) ||
 	    !subif_name) {
@@ -1088,7 +1067,7 @@ int32_t dp_register_subif_ext(int inst, struct module *owner,
 					  subif_id, data, flags);
 	if (!(flags & DP_F_SUBIF_LOGICAL))
 		subifid_fn_t = port_info->cb.get_subifid_fn;
-	
+
 	subif_id_sync = kmalloc(sizeof(*subif_id_sync) * 2, GFP_KERNEL);
 	if (!subif_id_sync) {
 		PR_ERR("Failed to alloc %zu bytes\n",
@@ -1240,42 +1219,42 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 #endif
 	subif->flag_pmapper = 0;
 	for (k = start; k < end; k++) {
-		if (dp_port_info[inst][k].status != PORT_SUBIF_REGISTERED)
+		struct pmac_port_info *port = get_dp_port_info(inst, k);
+
+		if (port->status != PORT_SUBIF_REGISTERED)
 			continue;
 
 		/*Workaround for VRX318 */
-		if (subif_data &&
-		    (dp_port_info[inst][k].alloc_flags & DP_F_FAST_DSL)) {
+		if (subif_data && (port->alloc_flags & DP_F_FAST_DSL)) {
 			/*VRX318 should overwritten them later if necessary */
 			port_id = k;
 			break;
 		}
 
 		/*search sub-interfaces/VAP */
-		for (i = 0; i < dp_port_info[inst][k].ctp_max; i++) {
-			if (!dp_port_info[inst][k].subif_info[i].flags)
+		for (i = 0; i < port->ctp_max; i++) {
+			struct dp_subif_info *sif = get_dp_port_subif(port, i);
+
+			if (!sif->flags)
 				continue;
-			if (dp_port_info[inst][k].subif_info[i].ctp_dev ==
-				netif) { /*for PON pmapper case*/
+			if (sif->ctp_dev == netif) { /*for PON pmapper case*/
 				match = 1;
 				port_id = k;
 				if (num > 0) {
 					PR_ERR("Multiple same ctp_dev exist\n");
 					goto EXIT;
 				}
-				subifs[num] = PORT_SUBIF(inst, k, i, subif);
-				subif_flag[num] = PORT_SUBIF(inst, k, i,
-							subif_flag);
-				bport = PORT_SUBIF(inst, k, i, bp);
+				subifs[num] = sif->subif;
+				subif_flag[num] = sif->subif_flag;
+				bport = sif->bp;
 				subif->flag_bp = 0;
-				gpid = PORT_SUBIF(inst, k, i, gpid);
-				subif->def_qid = PORT_SUBIF(inst, k, i, qid);
+				gpid = sif->gpid;
+				subif->def_qid = sif->qid;
 				num++;
 				break;
 			}
 
-			if (dp_port_info[inst][k].subif_info[i].netif ==
-			    netif) {
+			if (sif->netif == netif) {
 				if ((subif->port_id > 0) &&
 				    (subif->port_id != k)) {
 					DP_DEBUG(DP_DBG_FLAG_REG,
@@ -1294,45 +1273,32 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 					/* some dev may have multiple
 					 * subif,like pon
 					 */
-					subifs[num] = PORT_SUBIF(inst, k, i,
-								 subif);
-					gpid = PORT_SUBIF(inst, k, i, gpid);
-					subif->def_qid = PORT_SUBIF(inst, k, i,
-							     qid);
-					subif_flag[num] = PORT_SUBIF(inst, k, i,
-								subif_flag);
-					if (dp_port_info[inst][k].subif_info[i].
-						ctp_dev)
+					subifs[num] = sif->subif;
+					gpid = sif->gpid;
+					subif->def_qid = sif->qid;
+					subif_flag[num] = sif->subif_flag;
+					if (sif->ctp_dev)
 						subif->flag_pmapper = 1;
-					bport = PORT_SUBIF(inst, k, i, bp);
-					if (num &&
-					    (bport != dp_port_info[inst][k].
-					     subif_info[i].bp)) {
+					bport = sif->bp;
+					if (num && (bport != sif->bp)) {
 						PR_ERR("%s:Why many bp:%d %d\n",
 						       netif ? netif->name : "",
-						       dp_port_info[inst][k].
-							  subif_info[i].bp,
-						       bport);
+						       sif->bp, bport);
 						goto EXIT;
 					}
 					num++;
 				}
 			}
 			/*continue search non-explicate logical device */
-			list_for_each_entry(tmp,
-					    &dp_port_info[inst][k].
-					    subif_info[i].logic_dev,
-					    list) {
+			list_for_each_entry(tmp, &sif->logic_dev, list) {
 				if (tmp->dev == netif) {
 					subif->subif_num = 1;
 					subif->subif_list[0] = tmp->ctp;
 					subif->inst = inst;
 					subif->port_id = k;
 					subif->bport = tmp->bp;
-					subif->gpid = dp_port_info[inst][k].
-					    subif_info[i].gpid;
-					subif->def_qid = dp_port_info[inst][k].
-					    subif_info[i].qid;
+					subif->gpid = sif->gpid;
+					subif->def_qid = sif->qid;
 					res = 0;
 					/*note: logical device no callback */
 					goto EXIT;
@@ -1359,7 +1325,7 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 	subif->port_id = port_id;
 	subif->bport = bport;
 	subif->gpid = gpid;
-	subif->alloc_flag = dp_port_info[inst][port_id].alloc_flags;
+	subif->alloc_flag = get_dp_port_info(inst, port_id)->alloc_flags;
 	subif->subif_num = num;
 	for (i = 0; i < num; i++) {
 		subif->subif_list[i] = subifs[i];
@@ -1382,22 +1348,24 @@ int dp_get_port_subitf_via_dev_private(struct net_device *dev,
 	int inst;
 
 	inst = dp_get_inst_via_dev(dev, NULL, 0);
-	for (i = 0; i < dp_port_prop[inst].info.cap.max_num_dp_ports; i++)
-		for (j = 0; j < dp_port_info[inst][i].ctp_max; j++) {
-			if (!dp_port_info[inst][i].subif_info[j].flags)
+	for (i = 0; i < dp_port_prop[inst].info.cap.max_num_dp_ports; i++) {
+		struct pmac_port_info *port = get_dp_port_info(inst, i);
+
+		for (j = 0; j < port->ctp_max; j++) {
+			struct dp_subif_info *sif = get_dp_port_subif(port, j);
+
+			if (!sif->flags)
 				continue;
-			if (dp_port_info[inst][i].subif_info[j].netif != dev)
+			if (sif->netif != dev)
 				continue;
 			subif->port_id = i;
-			subif->subif =
-				SET_VAP(j,
-					PORT_INFO(inst, i, vap_offset),
-					PORT_INFO(inst, i, vap_mask));
+			subif->subif = SET_VAP(j, port->vap_offset,
+					       port->vap_mask);
 			subif->inst = inst;
-			subif->bport = dp_port_info[inst][i].
-				subif_info[j].bp;
+			subif->bport = sif->bp;
 			return DP_SUCCESS;
 		}
+	}
 	return DP_FAILURE;
 }
 
@@ -1420,18 +1388,17 @@ int dp_get_port_subitf_via_ifname_private(char *ifname, dp_subif_t *subif)
 	inst = dp_get_inst_via_dev(NULL, ifname, 0);
 
 	for (i = 0; i < dp_port_prop[inst].info.cap.max_num_dp_ports; i++) {
-		for (j = 0; j < dp_port_info[inst][i].ctp_max; j++) {
-			if (strcmp
-			    (dp_port_info[inst][i].subif_info[j].device_name,
-			     ifname) == 0) {
+		struct pmac_port_info *port = get_dp_port_info(inst, i);
+
+		for (j = 0; j < port->ctp_max; j++) {
+			struct dp_subif_info *sif = get_dp_port_subif(port, j);
+
+			if (strcmp(sif->device_name, ifname) == 0) {
 				subif->port_id = i;
-				subif->subif =
-					SET_VAP(j,
-						PORT_INFO(inst, i, vap_offset),
-						PORT_INFO(inst, i, vap_mask));
+				subif->subif = SET_VAP(j, port->vap_offset,
+						       port->vap_mask);
 				subif->inst = inst;
-				subif->bport = dp_port_info[inst][i].
-					subif_info[j].bp;
+				subif->bport = sif->bp;
 				return DP_SUCCESS;
 			}
 		}
@@ -1480,7 +1447,7 @@ int32_t dp_check_if_netif_fastpath_fn(struct net_device *netif,
 	if (tmp_subif.port_id <= 0 && tmp_subif.port_id >=
 	    dp_port_prop[tmp_subif.inst].info.cap.max_num_dp_ports)
 		res = 0;
-	else if (!(dp_port_info[tmp_subif.inst][tmp_subif.port_id].alloc_flags &
+	else if (!(get_dp_port_info(tmp_subif.inst, tmp_subif.port_id)->alloc_flags &
 		 (DP_F_FAST_DSL || DP_F_FAST_ETH_LAN ||
 		 DP_F_FAST_ETH_WAN || DP_F_FAST_WLAN)))
 		res = 0;
@@ -1501,7 +1468,7 @@ struct module *dp_get_module_owner(int ep)
 	}
 
 	if ((ep >= 0) && (ep < dp_port_prop[inst].info.cap.max_num_dp_ports))
-		return dp_port_info[inst][ep].owner;
+		return get_dp_port_info(inst, ep)->owner;
 
 	return NULL;
 }
@@ -1521,7 +1488,7 @@ void dp_clear_mib(dp_subif_t *subif, uint32_t flag)
 	}
 
 	i = subif->port_id;
-	port_info = &dp_port_info[subif->inst][i];
+	port_info = get_dp_port_info(subif->inst, i);
 
 	if (subif->subif == -1) {
 		start_vap = 0;
@@ -1533,10 +1500,12 @@ void dp_clear_mib(dp_subif_t *subif, uint32_t flag)
 	}
 
 	for (j = start_vap; j < end_vap; j++) {
+		struct dp_subif_info *sif = get_dp_port_subif(port_info, i);
+		struct dev_mib *mib = get_dp_port_subif_mib(sif);
+
 		STATS_SET(port_info->tx_err_drop, 0);
 		STATS_SET(port_info->rx_err_drop, 0);
-		memset(&port_info->subif_info[j].mib, 0,
-		       sizeof(port_info->subif_info[j].mib));
+		memset(mib, 0, sizeof(struct dev_mib));
 		reset_mib_fn = port_info->cb.reset_mib_fn;
 
 		if (reset_mib_fn)
@@ -1563,6 +1532,7 @@ int dp_get_drv_mib(dp_subif_t *subif, dp_drv_mib_t *mib, uint32_t flag)
 	dp_drv_mib_t tmp;
 	int i, vap;
 	struct pmac_port_info *port_info;
+	struct dp_subif_info *sif;
 
 	if (unlikely(!dp_init_ok)) {
 		DP_DEBUG(DP_DBG_FLAG_DBG,
@@ -1573,7 +1543,7 @@ int dp_get_drv_mib(dp_subif_t *subif, dp_drv_mib_t *mib, uint32_t flag)
 	if (!subif || !mib)
 		return -1;
 	memset(mib, 0, sizeof(*mib));
-	port_info = &dp_port_info[subif->inst][subif->port_id];
+	port_info = get_dp_port_info(subif->inst, subif->port_id);
 	vap = GET_VAP(subif->subif, port_info->vap_offset,
 		      port_info->vap_mask);
 	get_mib_fn = port_info->cb.get_mib_fn;
@@ -1584,11 +1554,11 @@ int dp_get_drv_mib(dp_subif_t *subif, dp_drv_mib_t *mib, uint32_t flag)
 	if (!(flag & DP_F_STATS_SUBIF)) {
 		/*get all VAP's  mib counters if it is -1 */
 		for (i = 0; i < port_info->ctp_max; i++) {
-			if (!port_info->subif_info[i].flags)
+			sif = get_dp_port_subif(port_info, i);
+			if (!sif->flags)
 				continue;
 
-			subif->subif =
-			    port_info->subif_info[i].subif;
+			subif->subif = sif->subif;
 			memset(&tmp, 0, sizeof(tmp));
 			get_mib_fn(subif, &tmp, flag);
 			mib->rx_drop_pkts += tmp.rx_drop_pkts;
@@ -1597,7 +1567,8 @@ int dp_get_drv_mib(dp_subif_t *subif, dp_drv_mib_t *mib, uint32_t flag)
 			mib->tx_error_pkts += tmp.tx_error_pkts;
 		}
 	} else {
-		if (port_info->subif_info[vap].flags)
+		sif = get_dp_port_subif(port_info, vap);
+		if (sif->flags)
 			get_mib_fn(subif, mib, flag);
 	}
 
@@ -1870,6 +1841,7 @@ int dp_lan_wan_bridging(int port_id, struct sk_buff *skb)
 	struct net_device *dev;
 	static int lan_port = 4;
 	int inst = 0;
+	struct dp_subif_info *sif;
 
 	if (!skb)
 		return DP_FAILURE;
@@ -1890,9 +1862,10 @@ int dp_lan_wan_bridging(int port_id, struct sk_buff *skb)
 		return DP_FAILURE;
 	}
 
-	dev = dp_port_info[inst][subif.port_id].subif_info[0].netif;
+	sif = get_dp_port_subif(get_dp_port_info(inst, subif.port_id), 0);
+	dev = sif->netif;
 
-	if (!dp_port_info[inst][subif.port_id].subif_info[0].flags || !dev) {
+	if (!sif->flags || !dev) {
 		dev_kfree_skb_any(skb);
 		return DP_FAILURE;
 	}
@@ -1976,11 +1949,11 @@ int dp_rx_enable(struct net_device *netif, char *ifname, uint32_t flags)
 			 netif ? netif->name : "NULL");
 		return DP_FAILURE;
 	}
-	port_info = PORT(subif.inst, subif.port_id);
+	port_info = get_dp_port_info(subif.inst, subif.port_id);
 	vap = GET_VAP(subif.subif, port_info->vap_offset,
 		      port_info->vap_mask);
-	
-	STATS_SET(port_info->subif_info[vap].rx_flag, flags ? 1 : 0);
+
+	STATS_SET(get_dp_port_subif(port_info, vap)->rx_flag, flags ? 1 : 0);
 
 	return DP_SUCCESS;
 }
@@ -1994,14 +1967,14 @@ int dp_vlan_set(struct dp_tc_vlan *vlan, int flags)
 
 	if (dp_get_netif_subifid(vlan->dev, NULL, NULL, NULL, &subif, 0))
 		return DP_FAILURE;
-	port_info = PORT(subif.inst, subif.port_id);
+	port_info = get_dp_port_info(subif.inst, subif.port_id);
 	info.subix = GET_VAP(subif.subif, port_info->vap_offset,
 			     port_info->vap_mask);
 	info.bp = subif.bport;
 	info.dp_port = subif.port_id;
 	info.inst = subif.inst;
-	
-	if ((vlan->def_apply == DP_VLAN_APPLY_CTP) && 
+
+	if ((vlan->def_apply == DP_VLAN_APPLY_CTP) &&
 				(subif.flag_pmapper == 1)) {
 		PR_ERR("cannot apply VLAN rule for pmapper device\n");
 		return DP_FAILURE;
@@ -2010,7 +1983,7 @@ int dp_vlan_set(struct dp_tc_vlan *vlan, int flags)
 	} else {
 		info.dev_type |= subif.flag_bp;
 	}
-	if (vlan->mcast_flag == DP_MULTICAST_SESSION) 
+	if (vlan->mcast_flag == DP_MULTICAST_SESSION)
 		info.dev_type |= 0x02;
 	DP_DEBUG(DP_DBG_FLAG_PAE, "dev_type:0x%x\n", info.dev_type);
 	if (DP_CB(subif.inst, dp_tc_vlan_set))
diff --git a/drivers/net/datapath/dpm/datapath_logical_dev.c b/drivers/net/datapath/dpm/datapath_logical_dev.c
index c6c89db269da..90dbaf1c6a6d 100644
--- a/drivers/net/datapath/dpm/datapath_logical_dev.c
+++ b/drivers/net/datapath/dpm/datapath_logical_dev.c
@@ -127,6 +127,7 @@ int add_logic_dev(int inst, int port_id, struct net_device *dev,
 	dp_subif_t subif;
 	int masked_subif;
 	struct pmac_port_info *port_info;
+	struct dp_subif_info *sif;
 
 	if (!dev) {
 		PR_ERR("dev NULL\n");
@@ -145,14 +146,13 @@ int add_logic_dev(int inst, int port_id, struct net_device *dev,
 			 "Not registered base dev %s in DP\n", dev->name);
 		return -1;
 	}
-	port_info = &dp_port_info[inst][port_id];
+	port_info = get_dp_port_info(inst, port_id);
 	masked_subif = GET_VAP(subif.subif,
 			       port_info->vap_offset,
 			       port_info->vap_mask);
 	DP_DEBUG(DP_DBG_FLAG_LOGIC, "masked_subif=%x\n", masked_subif);
-	logic_dev_tmp = logic_list_lookup(
-		&port_info->subif_info[masked_subif].logic_dev,
-		dev);
+	sif = get_dp_port_subif(port_info, masked_subif);
+	logic_dev_tmp = logic_list_lookup(&sif->logic_dev, dev);
 	if (logic_dev_tmp) {
 		DP_DEBUG(DP_DBG_FLAG_LOGIC, "Device already exist: %s\n",
 			 dev->name);
@@ -175,8 +175,7 @@ int add_logic_dev(int inst, int port_id, struct net_device *dev,
 		return -1;
 	}
 	DP_DEBUG(DP_DBG_FLAG_LOGIC, "add logic dev list\n");
-	list_add(&logic_dev_tmp->list,
-		 &port_info->subif_info[masked_subif].logic_dev);
+	list_add(&logic_dev_tmp->list, &sif->logic_dev);
 
 	subif_id->bport = logic_dev_tmp->bp;
 	subif_id->subif = subif.subif;
diff --git a/drivers/net/datapath/dpm/datapath_misc.c b/drivers/net/datapath/dpm/datapath_misc.c
index f0ab26631967..5a6a0cbd0989 100644
--- a/drivers/net/datapath/dpm/datapath_misc.c
+++ b/drivers/net/datapath/dpm/datapath_misc.c
@@ -1536,14 +1536,14 @@ u32 alloc_dp_port_subif_info(int inst)
 		return DP_FAILURE;
 	}
 	for (port_id = 0; port_id < max_dp_ports; port_id++) {
-		dp_port_info[inst][port_id].subif_info =
+		get_dp_port_info(inst, port_id)->subif_info =
 			kzalloc(sizeof(struct dp_subif_info) * max_subif,
 				GFP_KERNEL);
-		if (!dp_port_info[inst][port_id].subif_info) {
+		if (!get_dp_port_info(inst, port_id)->subif_info) {
 			PR_ERR("Failed for kmalloc: %zu bytes\n",
 			       max_subif * sizeof(struct dp_subif_info));
 			while (--port_id >= 0)
-				kfree(dp_port_info[inst][port_id].subif_info);
+				kfree(get_dp_port_info(inst, port_id)->subif_info);
 			return DP_FAILURE;
 		}
 	}
@@ -1577,7 +1577,7 @@ void free_dp_port_subif_info(int inst)
 
 	if (dp_port_info[inst]) {
 		for (port_id = 0; port_id < max_dp_ports; port_id++) {
-			port_info = &dp_port_info[inst][port_id];
+			port_info = get_dp_port_info(inst, port_id);
 			kfree(port_info->subif_info);
 		}
 		kfree(dp_port_info[inst]);
diff --git a/drivers/net/datapath/dpm/datapath_notifier.c b/drivers/net/datapath/dpm/datapath_notifier.c
index 9e4ef9918df2..659c6b83c384 100644
--- a/drivers/net/datapath/dpm/datapath_notifier.c
+++ b/drivers/net/datapath/dpm/datapath_notifier.c
@@ -48,6 +48,7 @@ int dp_event(struct notifier_block *this, unsigned long event, void *ptr)
 	u32 idx;
 	struct pmac_port_info *port;
 	struct inst_property *prop;
+	struct dp_subif_info *sif;
 
 	dev = netdev_notifier_info_to_dev(ptr);
 	if (!dev)
@@ -69,22 +70,24 @@ int dp_event(struct notifier_block *this, unsigned long event, void *ptr)
 		return 0;
 	}
 	inst = dp_dev->inst;
-	port = &dp_port_info[inst][dp_dev->ep];
+	port = get_dp_port_info(inst, dp_dev->ep);
 	prop = &dp_port_prop[inst];
+	sif = get_dp_port_subif(port, vap);
 	switch (event) {
 	case NETDEV_GOING_DOWN:
 		DP_DEBUG(DP_DBG_FLAG_NOTIFY,
 			 "%s%d %s%d %s%s %s%02x%02x%02x%02x%02x%02x\n",
 			 "Rem MAC with BP:",
-			 port->subif_info[vap].bp, "FID:", dp_dev->fid,
+			 sif->bp, "FID:", dp_dev->fid,
 			 "dev:", dev ? dev->name : "NULL",
 			 "MAC:", addr[0], addr[1], addr[2],
 			 addr[3], addr[4], addr[5]);
 		for (i = 0; i < prop->info.cap.max_num_subif_per_port; i++) {
-			if (port->subif_info[i].netif == dev) {
+			if (get_dp_port_subif(port, i)->netif == dev) {
 				vap = i;
+				sif = get_dp_port_subif(port, vap);
 				DP_DEBUG(DP_DBG_FLAG_NOTIFY, "vap:%d\n", vap);
-				port->subif_info[vap].fid = 0;
+				sif->fid = 0;
 			}
 		}
 		prop->info.dp_mac_reset(0,
@@ -100,7 +103,7 @@ int dp_event(struct notifier_block *this, unsigned long event, void *ptr)
 		DP_DEBUG(DP_DBG_FLAG_NOTIFY,
 			 "%s%d %s%d %s%s %s%02x%02x%02x%02x%02x%02x\n",
 			 "Rem MAC with BP:",
-			 port->subif_info[vap].bp, "FID:", dp_dev->fid,
+			 sif->bp, "FID:", dp_dev->fid,
 			 "dev:", dev ? dev->name : "NULL",
 			 "MAC:", addr[0], addr[1], addr[2],
 			 addr[3], addr[4], addr[5]);
@@ -116,7 +119,7 @@ int dp_event(struct notifier_block *this, unsigned long event, void *ptr)
 				 * bport
 				 */
 			dp_dev->fid = 0;
-			port->subif_info[vap].fid = dp_dev->fid;
+			sif->fid = dp_dev->fid;
 			goto dev_status;
 		}
 		/* Get respective FID when bport attached to bridge
@@ -141,10 +144,11 @@ int dp_event(struct notifier_block *this, unsigned long event, void *ptr)
 			}
 		}
 		for (i = 0; i < prop->info.cap.max_num_subif_per_port; i++) {
-			if (port->subif_info[i].netif == dev) {
+			if (get_dp_port_subif(port, i)->netif == dev) {
 				vap = i;
+				sif = get_dp_port_subif(port, vap);
 				DP_DEBUG(DP_DBG_FLAG_NOTIFY, "vap:%d\n", vap);
-				port->subif_info[vap].fid = dp_dev->fid;
+				sif->fid = dp_dev->fid;
 			}
 		}
  dev_status:
@@ -153,7 +157,7 @@ int dp_event(struct notifier_block *this, unsigned long event, void *ptr)
 				 "%s%s%d%s%d %s%s %s%02x%02x%02x%02x%02x%02x\n",
 				 "link UP,",
 				 "ADD MAC with BP:",
-				 port->subif_info[vap].bp, " FID:", dp_dev->fid,
+				 sif->bp, " FID:", dp_dev->fid,
 				 "dev:", dev ? dev->name : "NULL",
 				 "MAC:", addr[0], addr[1], addr[2],
 				 addr[3], addr[4], addr[5]);
@@ -175,7 +179,7 @@ int dp_event(struct notifier_block *this, unsigned long event, void *ptr)
 		DP_DEBUG(DP_DBG_FLAG_NOTIFY,
 			 "%s%d %s%d %s%s %s%02x%02x%02x%02x%02x%02x\n",
 			 "ADD MAC with BP:",
-			 port->subif_info[vap].bp, "FID:", dp_dev->fid,
+			 sif->bp, "FID:", dp_dev->fid,
 			 "dev:", dev ? dev->name : "NULL",
 			 "MAC:", addr[0], addr[1], addr[2],
 			 addr[3], addr[4], addr[5]);
diff --git a/drivers/net/datapath/dpm/datapath_proc.c b/drivers/net/datapath/dpm/datapath_proc.c
index 37c864386308..e9d24c9ece1c 100644
--- a/drivers/net/datapath/dpm/datapath_proc.c
+++ b/drivers/net/datapath/dpm/datapath_proc.c
@@ -61,7 +61,7 @@ int proc_port_dump(struct seq_file *s, int pos)
 	int (*print_ctp_bp)(struct seq_file *s, int inst,
 			    struct pmac_port_info *port,
 			    int subif_index, u32 flag);
-	struct pmac_port_info *port = get_port_info(tmp_inst, pos);
+	struct pmac_port_info *port = get_dp_port_info(tmp_inst, pos);
 	u16 start = 0;
 	u32 cid, pid, nid;
 	int loop;
@@ -79,6 +79,8 @@ int proc_port_dump(struct seq_file *s, int pos)
 
 	if (port->status == PORT_FREE) {
 		if (pos == 0) {
+			struct dp_subif_info *sif = get_dp_port_subif(port, 0);
+
 			seq_printf(s,
 				   "Reserved Port: rx_err_drop=0x%08x  tx_err_drop=0x%08x\n",
 				   STATS_GET(port->rx_err_drop),
@@ -88,14 +90,13 @@ int proc_port_dump(struct seq_file *s, int pos)
 						  * CPU port no ctp/bridge port
 						  */
 				print_ctp_bp(s, tmp_inst, port, 0, 0);
-			i = 0;
 			seq_printf(s, "          : qid/node:    %d/%d\n",
-				   port->subif_info[i].qid,
-				   port->subif_info[i].q_node);
+				   sif->qid,
+				   sif->q_node);
 			seq_printf(s, "          : port/node:    %d/%d\n",
-				   port->subif_info[i].cqm_deq_port,
-				   port->subif_info[i].qos_deq_port);
-			
+				   sif->cqm_deq_port,
+				   sif->qos_deq_port);
+
 
 		} else
 			seq_printf(s,
@@ -136,13 +137,11 @@ int proc_port_dump(struct seq_file *s, int pos)
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_SWITCHDEV)
 	seq_printf(s, "    Swdev:             %d\n", port->swdev_en);
 #endif
-	seq_printf(s, "    cb->rx_fn:         0x%0x\n", (u32)port->cb.rx_fn);
-	seq_printf(s, "    cb->restart_fn:    0x%0x\n",
-		   (u32)port->cb.restart_fn);
-	seq_printf(s, "    cb->stop_fn:       0x%0x\n",
-		   (u32)port->cb.stop_fn);
-	seq_printf(s, "    cb->get_subifid_fn:0x%0x\n",
-		   (u32)port->cb.get_subifid_fn);
+	seq_printf(s, "    cb->rx_fn:         0x%px\n", port->cb.rx_fn);
+	seq_printf(s, "    cb->restart_fn:    0x%px\n", port->cb.restart_fn);
+	seq_printf(s, "    cb->stop_fn:       0x%px\n", port->cb.stop_fn);
+	seq_printf(s, "    cb->get_subifid_fn:0x%px\n",
+		   port->cb.get_subifid_fn);
 	seq_printf(s, "    num_subif:         %d\n", port->num_subif);
 	seq_printf(s, "    vap_offset/mask:   %d/0x%x\n", port->vap_offset,
 		   port->vap_mask);
@@ -167,58 +166,61 @@ int proc_port_dump(struct seq_file *s, int pos)
 	else 
 		loop = port->ctp_max;
 	for (i = 0; i < loop; i++) {
-		if (!port->subif_info[i].flags)
+		struct dp_subif_info *sif = get_dp_port_subif(port, i);
+		struct dev_mib *mib = get_dp_port_subif_mib(sif);
+
+		if (!sif->flags)
 			continue;
 		seq_printf(s,
 			   "      [%02d]:%s=0x%04x %s=0x%0lx(%s=%s),%s=%s\n",
 			i,
 			"subif",
-			port->subif_info[i].subif,
+			sif->subif,
 			"netif",
-			(uintptr_t)port->subif_info[i].netif,
+			(uintptr_t)sif->netif,
 			"netif",
-			port->subif_info[i].netif ?
-			port->subif_info[i].netif->name : "NULL/DSL",
+			sif->netif ?
+			sif->netif->name : "NULL/DSL",
 			"device_name",
-			port->subif_info[i].device_name);
+			sif->device_name);
 		seq_puts(s, "          : subif_flag = ");
 		for (j = 0; j < get_dp_port_type_str_size(); j++) {
-			if (!port->subif_info[i].subif_flag) {
+			if (!sif->subif_flag) {
 				seq_printf(s, "%s ", "NULL");
 				break;
 			}
-			if (port->subif_info[i].subif_flag & dp_port_flag[j])
+			if (sif->subif_flag & dp_port_flag[j])
 				seq_printf(s, "%s ", dp_port_type_str[j]);
 		}
 		seq_puts(s, "\n");
 		seq_printf(s, "          : rx_fn_rxif_pkt =0x%08x\n",
-			   STATS_GET(port->subif_info[i].mib.rx_fn_rxif_pkt));
+			   STATS_GET(mib->rx_fn_rxif_pkt));
 		seq_printf(s, "          : rx_fn_txif_pkt =0x%08x\n",
-			   STATS_GET(port->subif_info[i].mib.rx_fn_txif_pkt));
+			   STATS_GET(mib->rx_fn_txif_pkt));
 		seq_printf(s, "          : rx_fn_dropped  =0x%08x\n",
-			   STATS_GET(port->subif_info[i].mib.rx_fn_dropped));
+			   STATS_GET(mib->rx_fn_dropped));
 		seq_printf(s, "          : tx_cbm_pkt     =0x%08x\n",
-			   STATS_GET(port->subif_info[i].mib.tx_cbm_pkt));
+			   STATS_GET(mib->tx_cbm_pkt));
 		seq_printf(s, "          : tx_tso_pkt     =0x%08x\n",
-			   STATS_GET(port->subif_info[i].mib.tx_tso_pkt));
+			   STATS_GET(mib->tx_tso_pkt));
 		seq_printf(s, "          : tx_pkt_dropped =0x%08x\n",
-			   STATS_GET(port->subif_info[i].mib.tx_pkt_dropped));
+			   STATS_GET(mib->tx_pkt_dropped));
 		seq_printf(s, "          : tx_clone_pkt   =0x%08x\n",
-			   STATS_GET(port->subif_info[i].mib.tx_clone_pkt));
+			   STATS_GET(mib->tx_clone_pkt));
 		seq_printf(s, "          : tx_hdr_room_pkt=0x%08x\n",
-			   STATS_GET(port->subif_info[i].mib.tx_hdr_room_pkt));
+			   STATS_GET(mib->tx_hdr_room_pkt));
 		if (print_ctp_bp)
 			print_ctp_bp(s, tmp_inst, port, i, 0);
 		seq_printf(s, "          : qid/node:    %d/%d\n",
-			   port->subif_info[i].qid,
-			   port->subif_info[i].q_node);
-		cqm_p = port->subif_info[i].cqm_deq_port;
+			   sif->qid,
+			   sif->q_node);
+		cqm_p = sif->cqm_deq_port;
 		seq_printf(s, "          : port/node:    %d/%d(ref=%d)\n",
 			   cqm_p,
-			   port->subif_info[i].qos_deq_port,
+			   sif->qos_deq_port,
 			   dp_deq_port_tbl[tmp_inst][cqm_p].ref_cnt);
 		seq_printf(s, "          : mac_learn_dis:    %d\n",
-			   port->subif_info[i].mac_learn_dis);
+			   sif->mac_learn_dis);
 		cid = _DMA_CONTROLLER(dp_deq_port_tbl[tmp_inst][cqm_p].dma_chan);
 		pid = _DMA_PORT(dp_deq_port_tbl[tmp_inst][cqm_p].dma_chan);
 		nid = _DMA_CHANNEL(dp_deq_port_tbl[tmp_inst][cqm_p].dma_chan);
@@ -232,15 +234,15 @@ int proc_port_dump(struct seq_file *s, int pos)
 				cid, pid, nid);
 		}
 		seq_printf(s, "          : gpid:           %d\n",
-			   port->subif_info[i].gpid);
-		if (port->subif_info[i].ctp_dev &&
-		    port->subif_info[i].ctp_dev->name)
+			   sif->gpid);
+		if (sif->ctp_dev &&
+		    sif->ctp_dev->name)
 			seq_printf(s, "          : ctp_dev = %s\n",
-				   port->subif_info[i].ctp_dev->name);
+				   sif->ctp_dev->name);
 		else
 			seq_puts(s, "          : ctp_dev = NULL\n");
 		seq_printf(s, "          : rx_en_flag = %d\n",
-			   STATS_GET(port->subif_info[i].rx_flag));
+			   STATS_GET(sif->rx_flag));
 	}
 	seq_printf(s, "    rx_err_drop=0x%08x  tx_err_drop=0x%08x\n",
 		   STATS_GET(port->rx_err_drop),
@@ -261,7 +263,7 @@ int display_port_info(int inst, u8 pos, int start_vap, int end_vap, u32 flag)
 {
 	int i;
 	int ret;
-	struct pmac_port_info *port = get_port_info(inst, pos);
+	struct pmac_port_info *port = get_dp_port_info(inst, pos);
 	u16 start = 0;
 
 	if (!port) {
@@ -321,41 +323,38 @@ int display_port_info(int inst, u8 pos, int start_vap, int end_vap, u32 flag)
 	}
 
 	for (i = start_vap; i < end_vap; i++) {
-		if (port->subif_info[i].flags) {
+		struct dp_subif_info *sif = get_dp_port_subif(port, i);
+		struct dev_mib *mib = get_dp_port_subif_mib(sif);
+
+		if (sif->flags) {
 			PR_INFO
 			    ("      [%02d]:%s=0x%04x %s=0x%0lx(%s=%s),%s=%s\n",
 			     i,
 			     "subif",
-			     port->subif_info[i].subif,
+			     sif->subif,
 			     "netif",
-			     (uintptr_t)port->subif_info[i].netif,
+			     (uintptr_t)sif->netif,
 			     "device_name",
-			     port->subif_info[i].netif ? port->subif_info[i].
+			     sif->netif ? sif->
 			     netif->name : "NULL/DSL",
 			     "name",
-			     port->subif_info[i].device_name);
+			     sif->device_name);
 			PR_INFO("          : rx_fn_rxif_pkt =0x%08x\n",
-				STATS_GET(port->subif_info[i].mib.
-				rx_fn_rxif_pkt));
+				STATS_GET(mib->rx_fn_rxif_pkt));
 			PR_INFO("          : rx_fn_txif_pkt =0x%08x\n",
-				STATS_GET(port->subif_info[i].mib.
-				rx_fn_txif_pkt));
+				STATS_GET(mib->rx_fn_txif_pkt));
 			PR_INFO("          : rx_fn_dropped  =0x%08x\n",
-				STATS_GET(port->subif_info[i].mib.
-				rx_fn_dropped));
+				STATS_GET(mib->rx_fn_dropped));
 			PR_INFO("          : tx_cbm_pkt     =0x%08x\n",
-				STATS_GET(port->subif_info[i].mib.tx_cbm_pkt));
+				STATS_GET(mib->tx_cbm_pkt));
 			PR_INFO("          : tx_tso_pkt     =0x%08x\n",
-				STATS_GET(port->subif_info[i].mib.tx_tso_pkt));
+				STATS_GET(mib->tx_tso_pkt));
 			PR_INFO("          : tx_pkt_dropped =0x%08x\n",
-				STATS_GET(port->subif_info[i].mib.
-				tx_pkt_dropped));
+				STATS_GET(mib->tx_pkt_dropped));
 			PR_INFO("          : tx_clone_pkt   =0x%08x\n",
-				STATS_GET(port->subif_info[i].mib.
-				tx_clone_pkt));
+				STATS_GET(mib->tx_clone_pkt));
 			PR_INFO("          : tx_hdr_room_pkt=0x%08x\n",
-				STATS_GET(port->subif_info[i].mib.
-				tx_hdr_room_pkt));
+				STATS_GET(mib->tx_hdr_room_pkt));
 		}
 	}
 
diff --git a/drivers/net/datapath/dpm/datapath_proc_qos.c b/drivers/net/datapath/dpm/datapath_proc_qos.c
index 839bd961671d..dd7542d43170 100644
--- a/drivers/net/datapath/dpm/datapath_proc_qos.c
+++ b/drivers/net/datapath/dpm/datapath_proc_qos.c
@@ -660,7 +660,7 @@ static char *port_flag_str(int inst, int dp_port)
 	int i;
 	struct pmac_port_info *port_info;
 
-	port_info = get_port_info(inst, dp_port);
+	port_info = get_dp_port_info(inst, dp_port);
 	if (!port_info)
 		return "";
 	for (i = 0; i < get_dp_port_type_str_size(); i++) {
@@ -677,15 +677,17 @@ char *dp_port_flag_str(int cqm_deq_port, int flag)
 
 	port_flag[0] = 0;
 	for (i = 0; i < dp_port_prop[inst].info.cap.max_num_dp_ports; i++) {
-		if ((cqm_deq_port >= dp_port_info[inst][i].deq_port_base) &&
-		    (cqm_deq_port < (dp_port_info[inst][i].deq_port_base +
-		     dp_port_info[inst][i].deq_port_num)))  {
+		struct pmac_port_info *pi = get_dp_port_info(inst, i);
+
+		if ((cqm_deq_port >= pi->deq_port_base) &&
+		    (cqm_deq_port < (pi->deq_port_base +
+		     pi->deq_port_num)))  {
 			if (i == 0) {
 				snprintf(port_flag, sizeof(port_flag),
 					 "CPU:%d", i);
 				return port_flag;
 			}
-			if (!dp_port_info[inst][i].alloc_flags)
+			if (!pi->alloc_flags)
 				continue;
 
 			snprintf(port_flag, sizeof(port_flag),
@@ -706,14 +708,16 @@ char *dp_port_dma_tx_str(int cqm_deq_port, int flag)
 
 	dma_flag[0] = 0;
 	for (i = 0; i < dp_port_prop[inst].info.cap.max_num_dp_ports; i++) {
-		if ((cqm_deq_port >= dp_port_info[inst][i].deq_port_base) &&
-		    (cqm_deq_port < (dp_port_info[inst][i].deq_port_base +
-		     dp_port_info[inst][i].deq_port_num))) {
+		struct pmac_port_info *pi = get_dp_port_info(inst, i);
+
+		if ((cqm_deq_port >= pi->deq_port_base) &&
+		    (cqm_deq_port < (pi->deq_port_base +
+		     pi->deq_port_num))) {
 			if (i == 0) {
 				snprintf(dma_flag, sizeof(dma_flag), "-");
 				return dma_flag;
 			}
-			if (!dp_port_info[inst][i].alloc_flags)
+			if (!pi->alloc_flags)
 				continue;
 			snprintf(dma_flag, sizeof(dma_flag), "CH%x",
 				 dp_deq_port_tbl[inst][cqm_deq_port].dma_chan);
diff --git a/drivers/net/datapath/dpm/datapath_qos.c b/drivers/net/datapath/dpm/datapath_qos.c
index bac3eec3d356..24ae57f46e5a 100644
--- a/drivers/net/datapath/dpm/datapath_qos.c
+++ b/drivers/net/datapath/dpm/datapath_qos.c
@@ -165,7 +165,7 @@ int dp_deq_port_res_get(struct dp_dequeue_res *res, int flag)
 		kfree(subif);
 		subif = NULL;
 	}
-	port_info = &dp_port_info[res->inst][res->dp_port];
+	port_info = get_dp_port_info(res->inst, res->dp_port);
 	DP_DEBUG(DP_DBG_FLAG_QOS_DETAIL,
 		 "dp_deq_port_res_get: dp_port=%d tconf_idx=%d\n",
 		 res->dp_port, res->cqm_deq_idx);
diff --git a/drivers/net/datapath/dpm/datapath_swdev.c b/drivers/net/datapath/dpm/datapath_swdev.c
index 4d9a88e585ff..782137186061 100644
--- a/drivers/net/datapath/dpm/datapath_swdev.c
+++ b/drivers/net/datapath/dpm/datapath_swdev.c
@@ -254,7 +254,7 @@ static int dp_swdev_clr_gswip_cfg(struct bridge_id_entry_item *br_item,
 	if (!br_info)
 		return 0;
 	if (dp_swdev_del_bport_from_list(br_info, br_item->portid)) {
-		if (dp_port_info[br_item->inst][br_item->dp_port].
+		if (get_dp_port_info(br_item->inst, br_item->dp_port)->
 							swdev_en == 1) {
 			ret = dp_port_prop[br_item->inst].info.
 				swdev_bridge_port_cfg_reset(br_info,
@@ -296,8 +296,8 @@ static int dp_swdev_cfg_vlan(struct bridge_id_entry_item *br_item,
 		}
 		inst = br_item->inst;
 		vap = GET_VAP(dp_dev->ctp,
-			      dp_port_info[inst][dp_dev->ep].vap_offset,
-			      dp_port_info[inst][dp_dev->ep].vap_mask);
+			      get_dp_port_info(inst, dp_dev->ep)->vap_offset,
+			      get_dp_port_info(inst, dp_dev->ep)->vap_mask);
 		DP_DEBUG(DP_DBG_FLAG_SWDEV, "vap=%d ep=%d bp=%d\n",
 			 vap, dp_dev->ep, dp_dev->bp);
 		dp_port_prop[br_item->inst].info.dp_cfg_vlan(br_item->inst,
@@ -355,7 +355,7 @@ static int dp_swdev_cfg_gswip(struct bridge_id_entry_item *br_item, u8 *addr)
 
 	DP_DEBUG(DP_DBG_FLAG_SWDEV, "britem flags:%x\n", br_item->flags);
 	if (br_item->flags & ADD_BRENTRY) {
-		if (dp_port_info[br_item->inst][br_item->dp_port].
+		if (get_dp_port_info(br_item->inst, br_item->dp_port)->
 							swdev_en == 0) {
 			DP_DEBUG(DP_DBG_FLAG_SWDEV, "swdev disable for bp %d\n",
 				 br_item->portid);
@@ -411,7 +411,7 @@ static int dp_swdev_cfg_gswip(struct bridge_id_entry_item *br_item, u8 *addr)
 		if (br_item->flags & LOGIC_DEV_REGISTER)
 			br_info->flag = LOGIC_DEV_REGISTER;
 		dp_swdev_add_bport_to_list(br_info, br_item->portid);
-		if (dp_port_info[br_item->inst][br_item->dp_port].
+		if (get_dp_port_info(br_item->inst, br_item->dp_port)->
 							swdev_en == 1) {
 			dp_port_prop[br_item->inst].info.
 				swdev_bridge_port_cfg_set(br_info,
@@ -468,8 +468,7 @@ static int dp_swdev_add_if(struct net_device *dev,
 				port = subif.port_id;
 				inst = subif.inst;
 				subif.subif = -1;
-				if (dp_register_subif(dp_port_info[inst][port]
-						      .owner,
+				if (dp_register_subif(get_dp_port_info(inst, port)->owner,
 						      dev, dev->name, &subif,
 						      DP_F_SUBIF_LOGICAL)) {
 					PR_ERR("dp_register_subif fail: %s\n",
@@ -501,8 +500,8 @@ static int dp_swdev_add_if(struct net_device *dev,
 			br_item->flags = flag;
 		} else {
 			br_item->flags = ADD_BRENTRY | flag;
-			if (dp_port_info[br_item->inst]
-					[br_item->dp_port].swdev_en == 1) {
+			if (get_dp_port_info(br_item->inst, br_item->dp_port)->
+			    swdev_en == 1) {
 				br_id = dp_port_prop[br_item->inst].info.
 					swdev_alloc_bridge_id(br_item->inst);
 				if (br_id) {
@@ -634,8 +633,7 @@ static int dp_swdev_del_if(struct net_device *dev,
 			}
 			port = subif.port_id;
 			inst = subif.inst;
-			if (dp_register_subif(dp_port_info[inst][port]
-						.owner,
+			if (dp_register_subif(get_dp_port_info(inst, port)->owner,
 						dev, dev->name, &subif,
 						DP_F_DEREGISTER)) {
 				PR_ERR("dp_register_subif fail: %s\n",
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_mib.c b/drivers/net/datapath/dpm/gswip30/datapath_mib.c
index 6552c62a18cd..94e3d6396949 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_mib.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_mib.c
@@ -406,9 +406,9 @@ static int vap_mib_wraparound(dp_subif_t *subif,
 } while (0)
 
 	int ep = subif->port_id;
-	int vap = GET_VAP(subif->subif,
-			  PORT_INFO(0, subif->port_id, vap_offset),
-			  PORT_INFO(0, subif->port_id, vap_mask));
+	struct dp_port_info *pi = get_dp_port_info(0, subif->port_id);
+	int vap = GET_VAP(subif->subif, pi->vap_offset, pi->vap_mask);
+
 	if ((ep <= 0) ||
 	    (ep >= PMAC_MAX_NUM))
 		return -1;
@@ -516,7 +516,7 @@ int get_gsw_interface_base(int port_id)
 		return -1;
 	}
 
-	port_info = get_port_info(port_id);
+	port_info = get_dp_port_info(0, port_id);
 	if (!port_info)
 		return -1;
 	if (!port_info->itf_info)
@@ -616,14 +616,14 @@ static int update_port_mib_lower_lvl(dp_subif_t *subif, u32 flag)
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_MIB_TMU_MPE_MIB)
 	/* collect all mib per VAP for TMU and MPE MIB */
 	tmu_hal_get_qos_m_local = tmu_hal_get_qos_mib_hook_fn;
-	port = get_port_info(tmp.port_id);
+	port = get_dp_port_info(0, tmp.port_id);
 	if (tmu_hal_get_qos_m_local &&
 	    port && port->status) { /*get all VAP's TMU MIB*/
 		for (i = 0; i < MAX_SUBIF_PER_PORT; i++) {
 			DP_DEBUG(DP_DBG_FLAG_MIB,
 				 "tmu_hal_get_qos_m_local: %d/%d\n",
 				 tmp.port_id, tmp.subif);
-			if (!port->subif_info[i].flags) {
+			if (!get_dp_port_subif(port, i)->flags) {
 				ret = -1;
 			} else {
 				tmp.subif = SET_VAP(i, port->vap_offset,
@@ -703,9 +703,9 @@ static void mib_wraparound_timer_poll(unsigned long data)
 	/* update vap if necessary */
 	if (port) {
 		for (i = 0; i < MAX_SUBIF_PER_PORT; i++) {
-			subif.subif = SET_VAP(i,
-					      PORT_INFO(0, port, vap_offset),
-					      PORT_INFO(0, port, vap_mask));
+			struct dp_port_info *pi = get_dp_port_info(0, port);
+
+			subif.subif = SET_VAP(i, pi->vap_offset, pi->vap_mask);
 			/* update sub-interface/vap mib only */
 			if (update_vap_mib_lower_lvl(&subif, 0))
 				break;
@@ -729,6 +729,7 @@ static int update_vap_mib_lower_lvl(dp_subif_t *subif, u32 flag)
 	int itf_base;
 	struct mibs_low_lvl_vap *curr;
 	int port_id;
+	struct dp_port_info *pi;
 
 	/*update struct pmac_port_info[subif->ep].net_mib */
 	if (!subif || (subif->port_id <= 0) || (subif->port_id >= PMAC_MAX_NUM))
@@ -739,9 +740,8 @@ static int update_vap_mib_lower_lvl(dp_subif_t *subif, u32 flag)
 		return -1;
 	memset(curr, 0, sizeof(*curr));
 	port_id = subif->port_id;
-	vap = GET_VAP(subif->subif,
-		      PORT_INFO(0, subif->port_id, vap_offset),
-		      PORT_INFO(0, subif->port_id, vap_mask));
+	pi = get_dp_port_info(0, subif->port_id);
+	vap = GET_VAP(subif->subif, pi->vap_offset, pi->vap_mask);
 	/* get gsw PAE interface mib counter */
 	itf_base = get_gsw_interface_base(port_id);
 	if (itf_base < 0) {
@@ -1053,10 +1053,8 @@ int dp_get_port_vap_mib_30(dp_subif_t *subif, void *priv,
 		return -1;
 	spin_lock_bh(&dp_mib_lock);
 	port_id = subif->port_id;
-	vap = GET_VAP(subif->subif,
-		      PORT_INFO(0, subif->port_id, vap_offset),
-		      PORT_INFO(0, subif->port_id, vap_mask));
-	port_info = get_port_info(port_id);
+	port_info = get_dp_port_info(0, port_id);
+	vap = GET_VAP(subif->subif, port_info->vap_offset, port_info->vap_mask);
 	memset(net_mib, 0, sizeof(*net_mib));
 
 	if ((flag & DP_F_STATS_SUBIF)) {	/*only sub-interface/VAP's
@@ -1576,13 +1574,12 @@ int clear_gsw_itf_mib(dp_subif_t *subif, u32 flag)
 	}
 
 	if (subif) {
-		port_info = get_port_info(subif->port_id);
+		port_info = get_dp_port_info(0, subif->port_id);
 		if (!port_info || !port_info->itf_info)
 			return 0;
 		start = port_info->itf_info->start +
-			GET_VAP(subif->subif,
-				PORT_INFO(0, subif->port_id, vap_offset),
-				PORT_INFO(0, subif->port_id, vap_mask));
+			GET_VAP(subif->subif, port_info->vap_offset,
+				port_info->vap_mask);
 		end = start + 1;
 	}
 	rmon.eRmonType = GSW_RMON_IF_TYPE;
@@ -1607,6 +1604,7 @@ int dp_clear_netif_mib_30(dp_subif_t *subif, void *priv, u32 flag)
 	int i;
 	dp_subif_t tmp_subif;
 	struct core_ops *gsw_l, *gsw_r;
+	struct dp_port_info *pi;
 
 	gsw_l = dp_port_prop[inst].ops[GSWIP_L];
 	gsw_r = dp_port_prop[inst].ops[GSWIP_R];
@@ -1644,9 +1642,8 @@ int dp_clear_netif_mib_30(dp_subif_t *subif, void *priv, u32 flag)
 		return -1;
 
 	port_id = subif->port_id;
-	vap = GET_VAP(subif->subif,
-		      PORT_INFO(0, port_id, vap_offset),
-		      PORT_INFO(0, port_id, vap_mask));
+	pi = get_dp_port_info(0, port_id);
+	vap = GET_VAP(subif->subif, pi->vap_offset, pi->vap_mask);
 	if ((flag & DP_F_STATS_SUBIF)) {
 		spin_lock_bh(&dp_mib_lock);
 		/*clear the specific subif mib counter */
@@ -1682,12 +1679,11 @@ int dp_clear_netif_mib_30(dp_subif_t *subif, void *priv, u32 flag)
 	 */
 	tmp_subif = *subif;
 	for (i = 0; i < MAX_SUBIF_PER_PORT; i++) {
+		pi = get_dp_port_info(0, tmp_subif.port_id);
 		DP_DEBUG(DP_DBG_FLAG_MIB, "dp_clear_netif_mib: %d/%d\n",
 			 tmp_subif.port_id, i);
 		tmp_subif.subif =
-			SET_VAP(i,
-				PORT_INFO(0, tmp_subif.port_id, vap_offset),
-				PORT_INFO(0, tmp_subif.port_id, vap_mask));
+			SET_VAP(i, pi->vap_offset, pi->vap_mask);
 		dp_clear_netif_mib_30(&tmp_subif, NULL, DP_F_STATS_SUBIF);
 	}
 
@@ -1858,11 +1854,11 @@ ssize_t proc_mib_port_write(struct file *file, const char *buf, size_t count,
 		}
 		for (k = 0; k < ARRAY_SIZE(port_list); k++) {
 			tmp.port_id = port_list[k];
-			port = get_port_info(tmp.port_id);
+			port = get_dp_port_info(0, tmp.port_id);
 			if (!port)
 				continue;
 			for (i = 0; i < MAX_SUBIF_PER_PORT; i++) {
-				if (!port->subif_info[i].flags)
+				if (!get_dp_port_subif(port, i)->flags)
 					continue;
 				tmp.subif = SET_VAP(i, port->vap_offset,
 						    port->vap_mask);
@@ -1990,20 +1986,18 @@ int proc_mib_vap_dump(struct seq_file *s, int pos)
 			   "VAP", "IfID", "Rx_PKTS", "Tx_PKTS",
 			   "Rx_DROP_PKTS", "Tx_DROP_PKTS\n");
 	}
-	port = get_port_info(pos);
+	port = get_dp_port_info(0, pos);
 
 	if (!port || !port->status)		/*not allocated yet*/
 		goto EXIT;
 
 	for (j = 0; j <= (MAX_SUBIF_PER_PORT - 1); j++) {
 		subif.port_id = pos;
-		subif.subif = SET_VAP(j,
-				      PORT_INFO(0, pos, vap_offset),
-				      PORT_INFO(0, pos, vap_mask));
+		subif.subif = SET_VAP(j, port->vap_offset, port->vap_mask);
 		itf_base = get_gsw_interface_base(pos);
 		if (itf_base < 0)	/*no GSW itf assigned*/
 			continue;
-		if (!port->subif_info[j].flags)	/*not registered yet*/
+		if (!get_dp_port_subif(port, j)->flags)	/*not registered yet*/
 			continue;
 		if (dp_get_port_vap_mib_30
 		    (&subif, NULL, &stats_mib,
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_misc.c b/drivers/net/datapath/dpm/gswip30/datapath_misc.c
index 5558c51b78e7..4ed789731d23 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_misc.c
@@ -69,7 +69,7 @@ static void init_dma_desc_mask(void)
 static void init_dma_pmac_template(int portid, u32 flags)
 {
 	int i;
-	struct pmac_port_info *dp_info = &dp_port_info[0][portid];
+	struct pmac_port_info *dp_info = get_dp_port_info(0, portid);
 
 	/*Note:
 	 * final tx_dma0 = (tx_dma0 & dma0_mask_template) | dma0_template
@@ -468,11 +468,11 @@ static int port_platform_set(int inst, u8 ep, struct dp_port_data *data,
 {
 	int idx, i;
 	u32 dma_chan, dma_ch_base;
-	struct pmac_port_info *port_info = &dp_port_info[inst][ep];
+	struct pmac_port_info *port_info = get_dp_port_info(inst, ep);
 
-	dp_port_info[inst][ep].ctp_max = MAX_SUBIF_PER_PORT;
-	dp_port_info[inst][ep].vap_offset = 8;
-	dp_port_info[inst][ep].vap_mask = 0xF;
+	port_info->ctp_max = MAX_SUBIF_PER_PORT;
+	port_info->vap_offset = 8;
+	port_info->vap_mask = 0xF;
 	idx = port_info->deq_port_base;
 	dma_chan =  port_info->dma_chan;
 	dma_ch_base = port_info->dma_ch_base;
@@ -498,7 +498,7 @@ static int port_platform_set(int inst, u8 ep, struct dp_port_data *data,
 		return 0;
 	}
 
-	dp_port_info[inst][ep].itf_info = get_free_itf(ep, flags);
+	port_info->itf_info = get_free_itf(ep, flags);
 	return 0;
 #else
 	return 0;
@@ -525,7 +525,7 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 		PR_ERR("dp_dma_chan_tbl[%d] NULL\n", inst);
 		return DP_FAILURE;
 	}
-	port_info = &dp_port_info[inst][portid];
+	port_info = get_dp_port_info(inst, portid);
 	if (data->subif_data)
 		deq_port_idx = data->subif_data->deq_port_idx;
 	if (port_info->deq_port_num < deq_port_idx + 1) {
@@ -535,7 +535,7 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 	}
 	cqe_deq = port_info->deq_port_base + deq_port_idx;
 	dma_ch_offset = dp_deq_port_tbl[inst][cqe_deq].dma_ch_offset;
-	port_info->subif_info[subif_ix].cqm_deq_port = cqe_deq;
+	get_dp_port_subif(port_info, subif_ix)->cqm_deq_port = cqe_deq;
 	dp_deq_port_tbl[inst][cqe_deq].ref_cnt++;
 	if (port_info->num_dma_chan)
 		atomic_inc(&(dp_dma_chan_tbl[inst] + dma_ch_offset)->ref_cnt);
@@ -561,7 +561,7 @@ static int subif_hw_reset(int inst, int portid, int subif_ix,
 		PR_ERR("dp_dma_chan_tbl[%d] NULL\n", inst);
 		return DP_FAILURE;
 	}
-	port_info = &dp_port_info[inst][portid];
+	port_info = get_dp_port_info(inst, portid);
 	if (data->subif_data)
 		deq_port_idx = data->subif_data->deq_port_idx;
 	if (port_info->deq_port_num < deq_port_idx + 1) {
@@ -618,19 +618,20 @@ static void update_port_vap(int inst, u32 *ep, int *vap,
 			    struct sk_buff *skb,
 			    struct pmac_rx_hdr *pmac, char *decryp)
 {
+	struct pmac_port_info *pi;
+
 	*ep = pmac->sppid; /*get the port_id from pmac's sppid */
-	if (dp_port_info[inst][*ep].alloc_flags & DP_F_LOOPBACK) {
+	pi = get_dp_port_info(inst, *ep);
+	if (pi->alloc_flags & DP_F_LOOPBACK) {
 		*ep = GET_VAP((u32)pmac->src_sub_inf_id2 +
 			(u32)(pmac->src_sub_inf_id << 8),
-			PORT_INFO(inst, *ep, vap_offset),
-			PORT_INFO(inst, *ep, vap_mask));
+			pi->vap_offset, pi->vap_mask);
 		*vap = 0;
 		*decryp = 1;
 	} else
 		*vap = GET_VAP((u32)pmac->src_sub_inf_id2 +
 			(u32)(pmac->src_sub_inf_id << 8),
-			PORT_INFO(inst, *ep, vap_offset),
-			PORT_INFO(inst, *ep, vap_mask));
+			pi->vap_offset, pi->vap_mask);
 }
 
 static void get_dma_pmac_templ(int index, struct pmac_tx_hdr *pmac,
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_proc.c b/drivers/net/datapath/dpm/gswip30/datapath_proc.c
index fbd9434f739a..0aa479a2d9cc 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_proc.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_proc.c
@@ -814,72 +814,65 @@ static int proc_gsw_port_rmon_dump(struct seq_file *s, int pos)
 		u64 other_rx = 0, other_tx = 0;
 		int i, j;
 		struct pmac_port_info *port;
+		struct dev_mib *mib;
 
 		for (i = 1; i < PMAC_MAX_NUM; i++) {
-			port = get_port_info(tmp_inst, i);
+			port = get_dp_port_info(tmp_inst, i);
 
 			if (!port)
 				continue;
 
 			if (i < 6) {
 				for (j = 0; j < 16; j++) {
+					mib = get_dp_port_subif_mib(
+						get_dp_port_subif(port, j));
 					eth0_rx +=
-					    STATS_GET(port->subif_info[j].mib.
-					    rx_fn_rxif_pkt);
+					    STATS_GET(mib->rx_fn_rxif_pkt);
 					eth0_rx +=
-					    STATS_GET(port->subif_info[j].mib.
-					    rx_fn_txif_pkt);
+					    STATS_GET(mib->rx_fn_txif_pkt);
 					eth0_tx +=
-					    STATS_GET(port->subif_info[j].mib.
-					    tx_cbm_pkt);
+					    STATS_GET(mib->tx_cbm_pkt);
 					eth0_tx +=
-					    STATS_GET(port->subif_info[j].mib.
-					    tx_tso_pkt);
+					    STATS_GET(mib->tx_tso_pkt);
 				}
 			} else if (i == 15) {
 				for (j = 0; j < 16; j++) {
+					mib = get_dp_port_subif_mib(
+						get_dp_port_subif(port, j));
 					eth1_rx +=
-					    STATS_GET(port->subif_info[j].mib.
-					    rx_fn_rxif_pkt);
+					    STATS_GET(mib->rx_fn_rxif_pkt);
 					eth1_rx +=
-					    STATS_GET(port->subif_info[j].mib.
-					    rx_fn_txif_pkt);
+					    STATS_GET(mib->rx_fn_txif_pkt);
 					eth1_tx +=
-					    STATS_GET(port->subif_info[j].mib.
-					    tx_cbm_pkt);
+					    STATS_GET(mib->tx_cbm_pkt);
 					eth1_tx +=
-					    STATS_GET(port->subif_info[j].mib.
-					    tx_tso_pkt);
+					    STATS_GET(mib->tx_tso_pkt);
 				}
 			} else if (port->alloc_flags & DP_F_FAST_DSL) {
 				for (j = 0; j < 16; j++) {
+					mib = get_dp_port_subif_mib(
+						get_dp_port_subif(port, j));
 					dsl_rx +=
-					    STATS_GET(port->subif_info[j].mib.
-					    rx_fn_rxif_pkt);
+					    STATS_GET(mib->rx_fn_rxif_pkt);
 					dsl_rx +=
-					    STATS_GET(port->subif_info[j].mib.
-					    rx_fn_txif_pkt);
+					    STATS_GET(mib->rx_fn_txif_pkt);
 					dsl_tx +=
-					    STATS_GET(port->subif_info[j].mib.
-					    tx_cbm_pkt);
+					    STATS_GET(mib->tx_cbm_pkt);
 					dsl_tx +=
-					    STATS_GET(port->subif_info[j].mib.
-					    tx_tso_pkt);
+					    STATS_GET(mib->tx_tso_pkt);
 				}
 			} else {
 				for (j = 0; j < 16; j++) {
+					mib = get_dp_port_subif_mib(
+						get_dp_port_subif(port, j));
 					other_rx +=
-					    STATS_GET(port->subif_info[j].mib.
-					    rx_fn_rxif_pkt);
+					    STATS_GET(mib->rx_fn_rxif_pkt);
 					other_rx +=
-					    STATS_GET(port->subif_info[j].mib.
-					    rx_fn_txif_pkt);
+					    STATS_GET(mib->rx_fn_txif_pkt);
 					other_tx +=
-					    STATS_GET(port->subif_info[j].mib.
-					    tx_cbm_pkt);
+					    STATS_GET(mib->tx_cbm_pkt);
 					other_tx +=
-					    STATS_GET(port->subif_info[j].mib.
-					    tx_tso_pkt);
+					    STATS_GET(mib->tx_tso_pkt);
 				}
 			}
 		}
@@ -1055,7 +1048,7 @@ int proc_ep_dump(struct seq_file *s, int pos)
 	cbm_tmu_res_t *res = NULL;
 	u32 flag = 0;
 	int i;
-	struct pmac_port_info *port = get_port_info(0, pos);
+	struct pmac_port_info *port = get_dp_port_info(0, pos);
 #endif
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_rx.c b/drivers/net/datapath/dpm/gswip30/datapath_rx.c
index 5a66f66d2939..b7d99bbae1c9 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_rx.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_rx.c
@@ -88,15 +88,19 @@ static int dp_handle_lct(struct pmac_port_info *dp_port,
 			 struct sk_buff *skb, dp_rx_fn_t rx_fn)
 {
 	struct sk_buff *lct_skb;
+	struct dp_subif_info *sif;
+	struct dev_mib *mib;
 	int vap, ret;
 
 	vap = dp_port->lct_idx;
-	skb->dev = dp_port->subif_info[vap].netif;
+	sif = get_dp_port_subif(dp_port, vap);
+	mib = get_dp_port_subif_mib(sif);
+	skb->dev = sif->netif;
 	if (skb->data[PMAC_SIZE] & 0x1) {
 		/* multicast/broadcast */
 		DP_DEBUG(DP_DBG_FLAG_PAE, "LCT mcast or broadcast\n");
-		if((STATS_GET(dp_port->subif_info[vap].rx_flag) <= 0)) {
-			UP_STATS(dp_port->subif_info[vap].mib.rx_fn_dropped);
+		if((STATS_GET(sif->rx_flag) <= 0)) {
+			UP_STATS(mib->rx_fn_dropped);
 			return 1;
 		}
 		lct_skb = skb_clone(skb, GFP_ATOMIC);
@@ -104,8 +108,8 @@ static int dp_handle_lct(struct pmac_port_info *dp_port,
 			PR_ERR("LCT mcast/bcast skb clone fail\n");
 			return -1;
 		}
-		lct_skb->dev = dp_port->subif_info[vap].netif;	
-		UP_STATS(dp_port->subif_info[vap].mib.rx_fn_rxif_pkt);
+		lct_skb->dev = sif->netif;
+		UP_STATS(mib->rx_fn_rxif_pkt);
 		DP_DEBUG(DP_DBG_FLAG_PAE, "pkt sent lct(%s) ret(%d)\n",
 			 lct_skb->dev->name ? lct_skb->dev->name : "NULL",
 			 ret);
@@ -116,13 +120,13 @@ static int dp_handle_lct(struct pmac_port_info *dp_port,
 		DP_DEBUG(DP_DBG_FLAG_PAE, "LCT unicast\n");
 		DP_DEBUG(DP_DBG_FLAG_PAE, "unicast pkt sent lct(%s) ret(%d)\n",
 				 skb->dev->name ? skb->dev->name : "NULL", ret);
-		if((STATS_GET(dp_port->subif_info[vap].rx_flag) <= 0)) {
-			UP_STATS(dp_port->subif_info[vap].mib.rx_fn_dropped);
+		if((STATS_GET(sif->rx_flag) <= 0)) {
+			UP_STATS(mib->rx_fn_dropped);
 			dev_kfree_skb_any(skb);
 			return 0;
 		}
 		rx_fn(skb->dev, NULL, skb, skb->len);
-		UP_STATS(dp_port->subif_info[vap].mib.rx_fn_rxif_pkt);
+		UP_STATS(mib->rx_fn_rxif_pkt);
 		return 0;
 	}
 	return 1;
@@ -149,8 +153,10 @@ int32_t dp_rx_30(struct sk_buff *skb, u32 flags)
 	struct pmac_port_info *dp_port;
 	struct mac_ops *ops;
 	int ret_lct = 1;
+	struct dp_subif_info *sif;
+	struct dev_mib *mib;
 
-	dp_port = &dp_port_info[inst][0];
+	dp_port = get_dp_port_info(inst, 0);
 	if (!skb) {
 		PR_ERR("skb NULL\n");
 		return DP_FAILURE;
@@ -197,15 +203,17 @@ int32_t dp_rx_30(struct sk_buff *skb, u32 flags)
 	} else {		/*GSWIP-R already know the destination */
 		rx_tx_flag = 1;
 		vap = GET_VAP(desc_0->field.dest_sub_if_id,
-			      dp_port_info[inst][port_id].vap_offset,
-			      dp_port_info[inst][port_id].vap_mask);
+			      get_dp_port_info(inst, port_id)->vap_offset,
+			      get_dp_port_info(inst, port_id)->vap_mask);
 	}
 	if (unlikely(!port_id)) { /*Normally shouldnot go to here */
 		rx_dbg_zero_port(skb, desc_0, desc_1, desc_2, desc_3, parser,
 				 pmac, paser_exist, ep, port_id, vap);
 		goto RX_DROP;
 	}
-	dp_port = &dp_port_info[inst][port_id];
+	dp_port = get_dp_port_info(inst, port_id);
+	sif = get_dp_port_subif(dp_port, vap);
+	mib = get_dp_port_subif_mib(sif);
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_PTP1588)
 	if (dp_port->f_ptp) {
 		ops = dp_port_prop[inst].mac_ops[port_id];
@@ -230,15 +238,15 @@ int32_t dp_rx_30(struct sk_buff *skb, u32 flags)
 		//desc_1->all &= dma_rx_desc_mask1.all;
 		desc_3->all &= dma_rx_desc_mask3.all;
 		skb->priority = desc_1->field.classid;
-		skb->dev = dp_port->subif_info[vap].netif;
-		dev = dp_port->subif_info[vap].netif;
+		skb->dev = sif->netif;
+		dev = sif->netif;
 		if (decryp) { /*workaround mark for bypass xfrm policy*/
 			desc_1->field.dec = 1;
 			desc_1->field.enc = 1;
 		}
 		if (!dev &&
 		    ((dp_port->alloc_flags & DP_F_FAST_DSL) == 0)) {
-			UP_STATS(dp_port->subif_info[vap].mib.rx_fn_dropped);
+			UP_STATS(mib->rx_fn_dropped);
 			goto RX_DROP;
 		}
 
@@ -275,31 +283,27 @@ int32_t dp_rx_30(struct sk_buff *skb, u32 flags)
 		 *avoid forwarding duplicate packets from linux
 		 */
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_SWITCHDEV)
-			if (dp_port->subif_info[vap].fid > 0)
+			if (sif->fid > 0)
 				skb->offload_fwd_mark = 1;
 #endif
 		if (rx_tx_flag == 0) {
 			if (dp_port->lct_idx > 0)
 				ret_lct = dp_handle_lct(dp_port, skb, rx_fn);
 			if (ret_lct) {
-				if((STATS_GET(dp_port->subif_info[vap].
-								rx_flag) <= 0)) {
-					UP_STATS(dp_port->subif_info[vap].
-							mib.rx_fn_dropped);
+				if((STATS_GET(sif->rx_flag) <= 0)) {
+					UP_STATS(mib->rx_fn_dropped);
 					goto RX_DROP2;
 				}
 				rx_fn(dev, NULL, skb, skb->len);
-				UP_STATS(dp_port->subif_info[vap].mib.
-								rx_fn_rxif_pkt);
+				UP_STATS(mib->rx_fn_rxif_pkt);
 			}
 		} else {
-			if((STATS_GET(dp_port->subif_info[vap].rx_flag) <= 0)) {
-				UP_STATS(dp_port->subif_info[vap].mib.
-						rx_fn_dropped);
+			if((STATS_GET(sif->rx_flag) <= 0)) {
+				UP_STATS(mib->rx_fn_dropped);
 				goto RX_DROP2;
 			}
 			rx_fn(NULL, dev, skb, skb->len);
-			UP_STATS(dp_port->subif_info[vap].mib.rx_fn_txif_pkt);
+			UP_STATS(mib->rx_fn_txif_pkt);
 		}
 
 		return DP_SUCCESS;
@@ -318,7 +322,7 @@ int32_t dp_rx_30(struct sk_buff *skb, u32 flags)
 		DP_DEBUG(DP_DBG_FLAG_DUMP_RX,
 			 "Drop for subif of port %u not registered yet\n",
 			 port_id);
-		UP_STATS(dp_port->subif_info[vap].mib.rx_fn_dropped);
+		UP_STATS(mib->rx_fn_dropped);
 		goto RX_DROP2;
 	} else {
 		pr_info("Unknown issue\n");
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_tx.c b/drivers/net/datapath/dpm/gswip30/datapath_tx.c
index ae9669e5b210..30343dca192c 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_tx.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_tx.c
@@ -113,7 +113,7 @@ int32_t dp_xmit_30(struct net_device *rx_if, dp_subif_t *rx_subif,
 		struct dma_tx_desc_1 *desc_1;
 		struct dma_tx_desc_2 *desc_2;
 		struct dma_tx_desc_3 *desc_3;
-		struct pmac_port_info *dp_info = NULL;
+		struct pmac_port_info *dp_info;
 		struct pmac_tx_hdr pmac = {0};
 		u32 ip_offset, tcp_h_offset, tcp_type;
 		char tx_chksum_flag = 0; /*check csum cal can be supported or not */
@@ -127,6 +127,7 @@ int32_t dp_xmit_30(struct net_device *rx_if, dp_subif_t *rx_subif,
 		struct mac_ops *ops;
 		int rec_id = 0;
 #endif
+		struct dev_mib *mib;
 	
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_EXTRA_DEBUG)
 		if (unlikely(!dp_init_ok)) {
@@ -153,8 +154,9 @@ int32_t dp_xmit_30(struct net_device *rx_if, dp_subif_t *rx_subif,
 			goto lbl_err_ret;
 		}
 #endif
-		dp_info = &dp_port_info[inst][ep];
+		dp_info = get_dp_port_info(inst, ep);
 		vap = GET_VAP(rx_subif->subif, dp_info->vap_offset, dp_info->vap_mask);
+		mib = get_dp_port_subif_mib(get_dp_port_subif(dp_info, vap));
 		if (unlikely(!rx_if && /*For atm pppoa case, rx_if is NULL now */
 			     !(dp_info->alloc_flags & DP_F_FAST_DSL))) {
 			err_ret = DP_XMIT_ERR_NULL_IF;
@@ -359,7 +361,7 @@ int32_t dp_xmit_30(struct net_device *rx_if, dp_subif_t *rx_subif,
 #if IS_ENABLED(CONFIG_LTQ_TOE_DRIVER)
 		if (skb_is_gso(skb)) {
 			res = ltq_tso_xmit(skb, &pmac, sizeof(pmac), 0);
-			UP_STATS(dp_info->subif_info[vap].mib.tx_tso_pkt);
+			UP_STATS(mib->tx_tso_pkt);
 			return res;
 		}
 #endif /* CONFIG_LTQ_TOE_DRIVER */
@@ -382,7 +384,7 @@ int32_t dp_xmit_30(struct net_device *rx_if, dp_subif_t *rx_subif,
 			data.dp_inst = 0;
 		}
 		res = cbm_cpu_pkt_tx(skb, &data, 0);
-		UP_STATS(dp_info->subif_info[vap].mib.tx_cbm_pkt);
+		UP_STATS(mib->tx_cbm_pkt);
 		return res;
 	
 	lbl_err_ret:
@@ -395,18 +397,19 @@ int32_t dp_xmit_30(struct net_device *rx_if, dp_subif_t *rx_subif,
 			break;
 		case DP_XMIT_ERR_NULL_SUBIF:
 			PR_RATELIMITED("dp_xmit failed for rx_subif null\n");
-			UP_STATS(PORT_INFO(inst, 0, tx_err_drop));
+			UP_STATS(get_dp_port_info(inst, 0)->tx_err_drop);
 			break;
 		case DP_XMIT_ERR_PORT_TOO_BIG:
-			UP_STATS(PORT_INFO(inst, 0, tx_err_drop));
+			UP_STATS(get_dp_port_info(inst, 0)->tx_err_drop);
 			PR_RATELIMITED("rx_subif->port_id >= max_ports");
 			break;
 		case DP_XMIT_ERR_NULL_SKB:
 			PR_RATELIMITED("skb NULL");
-			UP_STATS(PORT_INFO(inst, rx_subif->port_id, tx_err_drop));
+			UP_STATS(get_dp_port_info(inst, rx_subif->port_id)->
+				 tx_err_drop);
 			break;
 		case DP_XMIT_ERR_NULL_IF:
-			UP_STATS(PORT_VAP_MIB(inst, ep, vap, tx_pkt_dropped));
+			UP_STATS(mib->tx_pkt_dropped);
 			PR_RATELIMITED("rx_if NULL");
 			break;
 		case DP_XMIT_ERR_REALLOC_SKB:
@@ -425,9 +428,8 @@ int32_t dp_xmit_30(struct net_device *rx_if, dp_subif_t *rx_subif,
 		case DP_XMIT_PTP_ERR:
 			break;
 		default:
-			UP_STATS(dp_info->subif_info[vap].mib.tx_pkt_dropped);
-			PR_INFO_ONCE("Why come to here:%x\n",
-				     dp_port_info[inst][ep].status);
+			UP_STATS(mib->tx_pkt_dropped);
+			PR_INFO_ONCE("Why come to here:%x\n", dp_info->status);
 		}
 		if (skb)
 			dev_kfree_skb_any(skb);
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
index 7bf82fe30406..445603d4fdf4 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
@@ -584,10 +584,11 @@ struct gsw_itf *ctp_port_assign(int inst, u8 ep, int bp_default,
 	int i, alloc_flag;
 	u16 num;
 	struct core_ops *gsw_handle;
+	struct pmac_port_info *port_info = get_dp_port_info(inst, ep);
 
 	memset(&ctp_assign, 0, sizeof(ctp_assign));
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
-	alloc_flag = dp_port_info[inst][ep].alloc_flags;
+	alloc_flag = port_info->alloc_flags;
 
 	if (flags & DP_F_DEREGISTER) {
 		PR_ERR("Need to Free CTP Port here for ep=%d\n", ep);
@@ -639,11 +640,11 @@ struct gsw_itf *ctp_port_assign(int inst, u8 ep, int bp_default,
 	itf_assign[ep].end = ctp_assign.nFirstCtpPortId +
 		 ctp_assign.nNumberOfCtpPort - 1;
 	itf_assign[ep].ep = ep;
-	dp_port_info[inst][ep].ctp_max = ctp_assign.nNumberOfCtpPort;
-	dp_port_info[inst][ep].vap_offset = assign->vap_offset;
-	dp_port_info[inst][ep].vap_mask = assign->vap_mask;
+	port_info->ctp_max = ctp_assign.nNumberOfCtpPort;
+	port_info->vap_offset = assign->vap_offset;
+	port_info->vap_mask = assign->vap_mask;
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_SWITCHDEV)
-	dp_port_info[inst][ep].swdev_en = assign->swdev_enable;
+	port_info->swdev_en = assign->swdev_enable;
 #endif
 	return &itf_assign[ep];
 }
@@ -652,8 +653,9 @@ int set_port_lookup_mode_31(int inst, u8 ep, u32 flags)
 {
 	int i, alloc_flag;	
 	struct ctp_assign *assign = &ctp_assign_def;
+	struct pmac_port_info *port_info = get_dp_port_info(inst, ep);
 
-	alloc_flag = dp_port_info[inst][ep].alloc_flags;
+	alloc_flag = port_info->alloc_flags;
 	for (i = 0; i < ARRAY_SIZE(ctp_assign_info); i++) {
 		if ((ctp_assign_info[i].flag & alloc_flag) ==
 			ctp_assign_info[i].flag) {
@@ -661,8 +663,8 @@ int set_port_lookup_mode_31(int inst, u8 ep, u32 flags)
 			break;
 		}
 	}
-	dp_port_info[inst][ep].cqe_lu_mode = assign->lookup_mode;
-	dp_port_info[inst][ep].gsw_mode = (u32)assign->emode;
+	port_info->cqe_lu_mode = assign->lookup_mode;
+	port_info->gsw_mode = (u32)assign->emode;
 	return 0;
 }
 
@@ -694,8 +696,8 @@ int alloc_bridge_port(int inst, int port_id, int subif_ix,
 	/* By default Disable src mac learning for registered
 	 * non CPU bridge port with DP
 	 */
-	if (dp_port_info[inst][port_id].subif_info[subif_ix].mac_learn_dis ==
-							DP_MAC_LEARNING_DIS)
+	if (get_dp_port_subif(get_dp_port_info(inst, port_id), subif_ix)->
+	    mac_learn_dis == DP_MAC_LEARNING_DIS)
 		bp_cfg.bSrcMacLearningDisable = 1;
 	else
 		bp_cfg.bSrcMacLearningDisable = 0;
@@ -905,7 +907,7 @@ int dp_set_gsw_pmapper_31(int inst, int bport, int lport,
 	GSW_return_t ret;
 	int i, index;
 	int ctp;
-	struct pmac_port_info *port_info = &dp_port_info[inst][lport];
+	struct pmac_port_info *port_info = get_dp_port_info(inst, lport);
 
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
 
@@ -971,7 +973,7 @@ int dp_get_gsw_pmapper_31(int inst, int bport, int lport,
 	int i, index;
 	struct hal_priv *priv;
 	u16 dest;
-	struct pmac_port_info *info = &dp_port_info[inst][lport];
+	struct pmac_port_info *info = get_dp_port_info(inst, lport);
 
 	priv = (struct hal_priv *)dp_port_prop[inst].priv_hal;
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
@@ -1091,8 +1093,8 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 			PR_ERR("can't use CTP,pmapper is enable\n");
 			return -1;
 		}
-		port_info = &dp_port_info[mtr_subif->subif.inst]
-					[mtr_subif->subif.port_id];
+		port_info = get_dp_port_info(mtr_subif->subif.inst,
+					     mtr_subif->subif.port_id);
 		ctp_cfg.nLogicalPortId = mtr_subif->subif.port_id;
 		ctp_cfg.nSubIfIdGroup  = GET_VAP(mtr_subif->subif.subif,
 						 port_info->vap_offset,
@@ -1242,7 +1244,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			goto err;
 		}
 		port_info =
-		&dp_port_info[mtr_subif->subif.inst][mtr_subif->subif.port_id];
+		get_dp_port_info(mtr_subif->subif.inst, mtr_subif->subif.port_id);
 		if (!port_info) {
 			PR_ERR(" port_info is NULL\n");
 			bret = -1;
@@ -1437,8 +1439,8 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			bret = -1;
 			goto err;
 		}
-		port_info = &dp_port_info[mtr_subif->subif.inst]
-					[mtr_subif->subif.port_id];
+		port_info = get_dp_port_info(mtr_subif->subif.inst,
+					     mtr_subif->subif.port_id);
 		if (!port_info) {
 			PR_ERR(" port_info is NULL\n");
 			bret = -1;
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_lookup_proc.c b/drivers/net/datapath/dpm/gswip31/datapath_lookup_proc.c
index 26863e2b34d1..3bb69d412d0a 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_lookup_proc.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_lookup_proc.c
@@ -331,7 +331,7 @@ int find_pattern(int port_id, struct seq_file *s, int qid)
 	int arr[] = {13, 12, 11, 10, 9, 8, /*7,6,5,4, */ 3, 2, 1, 0 };
 	int inst = 0;
 	struct hal_priv *priv = (struct hal_priv *)dp_port_prop[inst].priv_hal;
-	u32 mode = dp_port_info[inst][port_id].cqe_lu_mode;
+	u32 mode = get_dp_port_info(inst, port_id)->cqe_lu_mode;
 
 	left_n = 1 << (LOOKUP_FIELD_BITS - 4);	/*maximum lookup entried */
 	lookup_match_num = 0;
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_misc.c b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
index 6ed9d0f6c568..aa6f14ea6e38 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
@@ -73,7 +73,7 @@ static void init_dma_desc_mask(void)
 static void init_dma_pmac_template(int portid, u32 flags)
 {
 	int i;
-	struct pmac_port_info *dp_info = &dp_port_info[0][portid];
+	struct pmac_port_info *dp_info = get_dp_port_info(0, portid);
 
 	/*Note:
 	 * final tx_dma0 = (tx_dma0 & dma0_mask_template) | dma0_template
@@ -275,6 +275,7 @@ void dump_tx_dma_desc(struct dma_tx_desc_0 *desc_0,
 	int lookup;
 	int inst = 0;
 	int dp_port;
+	struct pmac_port_info *port_info;
 
 	if (!desc_0 || !desc_1 || !desc_2 || !desc_3) {
 		PR_ERR("tx desc_0/1/2/3 NULL\n");
@@ -304,7 +305,8 @@ void dump_tx_dma_desc(struct dma_tx_desc_0 *desc_0,
 		desc_3->field.policy, desc_3->field.res,
 		desc_3->field.pool, desc_3->field.data_len);
 	dp_port = desc_1->field.ep;
-	if (dp_port_info[inst][dp_port].cqe_lu_mode == CQE_LU_MODE0)
+	port_info = get_dp_port_info(inst, dp_port);
+	if (port_info->cqe_lu_mode == CQE_LU_MODE0)
 		/*Flow[7:6] DEC ENC MPE2 MPE1 EP Class */
 		lookup = ((desc_0->field.flow_id >> 6) << 12) |
 			 ((desc_1->field.dec) << 11) |
@@ -313,14 +315,14 @@ void dump_tx_dma_desc(struct dma_tx_desc_0 *desc_0,
 			 ((desc_1->field.mpe1) << 8) |
 			 ((desc_1->field.ep) << 4) |
 			 desc_1->field.classid;
-	else if (dp_port_info[inst][dp_port].cqe_lu_mode == CQE_LU_MODE1)
+	else if (port_info->cqe_lu_mode == CQE_LU_MODE1)
 		/*Subif[7:4] MPE2 MPE1 EP Subif[3:0] */
 		lookup = ((desc_0->field.dest_sub_if_id >> 4) << 10) |
 			 ((desc_1->field.mpe2) << 9) |
 			 ((desc_1->field.mpe1) << 8) |
 			 ((desc_1->field.ep) << 4) |
 			 (desc_0->field.dest_sub_if_id & 0xf);
-	else if (dp_port_info[inst][dp_port].cqe_lu_mode == CQE_LU_MODE2)
+	else if (port_info->cqe_lu_mode == CQE_LU_MODE2)
 		/*Subif[7:4] MPE2 MPE1 EP Class */
 		lookup = ((desc_0->field.dest_sub_if_id >> 4) << 10) |
 			 ((desc_1->field.mpe2) << 9) |
@@ -456,6 +458,7 @@ int alloc_q_to_port(struct ppv4_q_sch_port *info, u32 flag)
 	struct ppv4_port port;
 	int inst = info->inst;
 	struct hal_priv *priv = HAL(inst);
+	struct dp_subif_info *subif;
 
 	if (!priv) {
 		PR_ERR("why priv NULL ???\n");
@@ -493,8 +496,10 @@ int alloc_q_to_port(struct ppv4_q_sch_port *info, u32 flag)
 		       "dp_pp_alloc_queue");
 		return -1;
 	}
-	PORT_VAP(info->inst, info->dp_port, info->ctp, qid) = q.qid;
-	PORT_VAP(info->inst, info->dp_port, info->ctp, q_node) = q.node_id;
+	subif = get_dp_port_subif(get_dp_port_info(info->inst, info->dp_port),
+			   info->ctp);
+	subif->qid = q.qid;
+	subif->q_node = q.qid;
 	info->qid = q.qid;
 	info->q_node = q.node_id;
 	priv->qos_queue_stat[q.qid].deq_port = info->cqe_deq;
@@ -1066,7 +1071,7 @@ int dp_platform_queue_set(int inst, u32 flag)
 	struct hal_priv *priv = (struct hal_priv *)dp_port_prop[inst].priv_hal;
 	struct pmac_port_info *port_info;
 
-	port_info = &dp_port_info[inst][CPU_PORT];
+	port_info = get_dp_port_info(inst, CPU_PORT);
 	if ((flag & DP_PLATFORM_DE_INIT) == DP_PLATFORM_DE_INIT) {
 		PR_ERR("Need to free resoruce in the future\n");
 		return 0;
@@ -1097,7 +1102,7 @@ int dp_platform_queue_set(int inst, u32 flag)
 			  CBM_QUEUE_MAP_F_TC_DONTCARE);
 
 	/*Set CPU port to Mode0 only*/
-	dp_port_info[inst][0].cqe_lu_mode = CQE_LU_MODE0;
+	port_info->cqe_lu_mode = CQE_LU_MODE0;
 	mode = CQE_LU_MODE0;
 	lookup.ep = PMAC_CPU_ID;
 	cqm_mode_table_set(dp_port_prop[inst].cbm_inst, &lookup,
@@ -1124,6 +1129,8 @@ int dp_platform_queue_set(int inst, u32 flag)
 	port_info->deq_port_base = 0;
 	port_info->deq_port_num = 4;  /*need improve later*/
 	for (i = 0; i < ARRAY_SIZE(cpu_data.dq_tx_push_info); i++) {
+		struct dp_subif_info *sif;
+
 		if (cpu_data.dq_tx_push_info[i].deq_port == (u32)-1)
 			continue;
 		DP_DEBUG(DP_DBG_FLAG_QOS, "cpu(%d) deq_port=%d",
@@ -1164,10 +1171,11 @@ int dp_platform_queue_set(int inst, u32 flag)
 			return -1;
 		}
 		port_info->deq_port_num++;
-		port_info->subif_info[i].qid = q_port.qid;
-		port_info->subif_info[i].q_node = q_port.q_node;
-		port_info->subif_info[i].qos_deq_port = q_port.port_node;
-		port_info->subif_info[i].cqm_deq_port = q_port.cqe_deq;
+		sif = get_dp_port_subif(port_info, i);
+		sif->qid = q_port.qid;
+		sif->q_node = q_port.q_node;
+		sif->qos_deq_port = q_port.port_node;
+		sif->cqm_deq_port = q_port.cqe_deq;
 		if (!f_cpu_q) {
 			f_cpu_q = 1;
 			/*Map all CPU port's lookup to its 1st queue only */
@@ -1206,6 +1214,8 @@ static int dp_platform_set(int inst, u32 flag)
 
 	/* For initialize */
 	if ((flag & DP_PLATFORM_INIT) == DP_PLATFORM_INIT) {
+		struct dp_subif_info *sif;
+
 		dp_port_prop[inst].priv_hal =
 			kzalloc(sizeof(*priv), GFP_KERNEL);
 		if (!dp_port_prop[inst].priv_hal) {
@@ -1227,10 +1237,10 @@ static int dp_platform_set(int inst, u32 flag)
 			dp_sub_proc_install_31();
 		init_qos_fn();
 		/*just for debugging purpose */
-		dp_port_info[inst][0].subif_info[0].bp = CPU_BP;
-		dp_port_info[inst][0].subif_info[0].mac_learn_dis = 
-							DP_MAC_LEARNING_DIS;
-		INIT_LIST_HEAD(&dp_port_info[inst][0].subif_info[0].logic_dev);
+		sif = get_dp_port_subif(get_dp_port_info(inst, 0), 0);
+		sif->bp = CPU_BP;
+		sif->mac_learn_dis = DP_MAC_LEARNING_DIS;
+		INIT_LIST_HEAD(&sif->logic_dev);
 
 		priv->bp_def = alloc_bridge_port(inst, CPU_PORT, CPU_SUBIF,
 						 CPU_FID, CPU_BP);
@@ -1361,7 +1371,7 @@ static int dev_platform_set(int inst, u8 ep, struct dp_dev_data *data,
 	}
 	itf = ctp_port_assign(inst, ep, priv->bp_def, flags, data);
 	/*reset_gsw_itf(ep); */
-	dp_port_info[inst][ep].itf_info = itf;
+	get_dp_port_info(inst, ep)->itf_info = itf;
 	return 0;
 }
 
@@ -1372,7 +1382,7 @@ static int port_platform_set(int inst, u8 ep, struct dp_port_data *data,
 	u32 mode;
 	cbm_queue_map_entry_t lookup = {0};
 	struct hal_priv *priv = (struct hal_priv *)dp_port_prop[inst].priv_hal;
-	struct pmac_port_info *port_info = &dp_port_info[inst][ep];
+	struct pmac_port_info *port_info = get_dp_port_info(inst, ep);
 	u32 dma_chan, dma_ch_base;
 
 	if (!priv) {
@@ -1416,7 +1426,7 @@ static int port_platform_set(int inst, u8 ep, struct dp_port_data *data,
 		DP_DEBUG(DP_DBG_FLAG_DBG, "deq_port_tbl[%d][%d].dma_chan=%x\n",
 			 inst, (i + idx), dma_chan);
 	}
-	mode = dp_port_info[inst][ep].cqe_lu_mode;
+	mode = port_info->cqe_lu_mode;
 	lookup.ep = ep;
 	/*Set all mode based on MPE1/2 to same single mode as specified */
 	cqm_mode_table_set(dp_port_prop[inst].cbm_inst, &lookup,
@@ -1505,6 +1515,7 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 	int subif, deq_port_idx = 0, bp = -1;
 	int dma_ch_offset = 0;
 	struct pmac_port_info *port_info;
+	struct dp_subif_info *sif;
 	struct hal_priv *priv = HAL(inst);
 	int q_flag = 0;
 
@@ -1516,9 +1527,10 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 		PR_ERR("dp_dma_chan_tbl[%d] NULL\n", inst);
 		return DP_FAILURE;
 	}
-	port_info = &dp_port_info[inst][portid];
+	port_info = get_dp_port_info(inst, portid);
 	subif = SET_VAP(subif_ix, port_info->vap_offset,
 			port_info->vap_mask);
+	sif = get_dp_port_subif(port_info, subif_ix);
 
 	if (data->subif_data->ctp_dev) /* for pmapper later */
 		bp = bp_pmapper_dev_get(inst, data->dev);
@@ -1532,8 +1544,7 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 			 data->dev ? data->dev->name : "NULL",
 			 data->subif_data->ctp_dev ?
 				data->subif_data->ctp_dev->name : "NULL");
-		port_info->subif_info[subif_ix].mac_learn_dis =
-				data->subif_data->mac_learn_disable;
+		sif->mac_learn_dis = data->subif_data->mac_learn_disable;
 		bp = alloc_bridge_port(inst, portid,
 				       subif_ix, CPU_FID, CPU_BP);
 		if (bp < 0) {
@@ -1541,9 +1552,8 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 			return -1;
 		}
 	}
-	port_info->subif_info[subif_ix].bp = bp;
-	set_ctp_bp(inst, subif_ix, portid,
-		   port_info->subif_info[subif_ix].bp);
+	sif->bp = bp;
+	set_ctp_bp(inst, subif_ix, portid, sif->bp);
 	data->act = 0;
 	if (flags & DP_F_SUBIF_LOGICAL) {
 		PR_ERR("need more for logical dev??\n");
@@ -1557,8 +1567,7 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 		dp_bp_dev_tbl[inst][bp].dev = data->dev;
 		dp_bp_dev_tbl[inst][bp].ref_cnt++;
 		dp_bp_dev_tbl[inst][bp].flag = 1;
-		port_info->subif_info[subif_ix].ctp_dev =
-			data->subif_data->ctp_dev;
+		sif->ctp_dev = data->subif_data->ctp_dev;
 	}
 	DP_DEBUG(DP_DBG_FLAG_DBG,
 		 "inst=%d portid=%d dp numsubif=%d subif_ix=%d pmapper.cnt=%d\n",
@@ -1732,21 +1741,21 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 	/* update caller dp_subif_data.q_id with allocated queue number */
 	data->subif_data->q_id = q_port.qid;
 	/*update subif table */
-	port_info->subif_info[subif_ix].qid = q_port.qid;
-	port_info->subif_info[subif_ix].q_node = q_port.q_node;
-	port_info->subif_info[subif_ix].qos_deq_port = q_port.port_node;
-	port_info->subif_info[subif_ix].cqm_deq_port = q_port.cqe_deq;
-	port_info->subif_info[subif_ix].cqm_port_idx = deq_port_idx;
+	sif->qid = q_port.qid;
+	sif->q_node = q_port.q_node;
+	sif->qos_deq_port = q_port.port_node;
+	sif->cqm_deq_port = q_port.cqe_deq;
+	sif->cqm_port_idx = deq_port_idx;
 
 	/* Map this port's lookup to its 1st queue only */
-	//lookup.mode = dp_port_info[inst][portid].cqe_lu_mode; /*no need */
+	//lookup.mode = get_dp_port_info(inst, portid)->cqe_lu_mode; /*no need */
 	lookup.ep = portid;
 	lookup.sub_if_id = subif; /* Note:CQM API need full subif(15bits) */
 	/* For 1st subif and mode 0, use CBM_QUEUE_MAP_F_SUBIF_DONTCARE,
 	 * otherwise, don't use this flag
 	 */
-	if (!dp_port_info[inst][portid].num_subif &&
-	    (dp_port_info[inst][portid].cqe_lu_mode == CQE_LU_MODE0))
+	if (!port_info->num_subif &&
+	    (port_info->cqe_lu_mode == CQE_LU_MODE0))
 		lookup_f |= CBM_QUEUE_MAP_F_SUBIF_DONTCARE;
 	cbm_queue_map_set(dp_port_prop[inst].cbm_inst,
 			  q_port.qid,
@@ -1757,8 +1766,8 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 		 "cbm_queue_map_set",
 		 "qid", q_port.qid,
 		 "for dp_port", lookup.ep,
-		 "num_subif", dp_port_info[inst][portid].num_subif,
-		 "lu_mode", dp_port_info[inst][portid].cqe_lu_mode,
+		 "num_subif", port_info->num_subif,
+		 "lu_mode", port_info->cqe_lu_mode,
 		 "flag", lookup_f,
 		 "subif", subif, subif_ix);
 	return 0;
@@ -1770,14 +1779,15 @@ static int subif_hw_reset(int inst, int portid, int subif_ix,
 	int qid;
 	int cqm_deq_port;
 	int dma_ch_offset;
-	struct pmac_port_info *port_info = &dp_port_info[inst][portid];
+	struct pmac_port_info *port_info = get_dp_port_info(inst, portid);
 	struct dp_node_alloc node;
-	int bp = port_info->subif_info[subif_ix].bp;
+	struct dp_subif_info *sif = get_dp_port_subif(port_info, subif_ix);
+	int bp = sif->bp;
 
-	qid = port_info->subif_info[subif_ix].qid;
-	cqm_deq_port = port_info->subif_info[subif_ix].cqm_deq_port;
+	qid = sif->qid;
+	cqm_deq_port = sif->cqm_deq_port;
 	dma_ch_offset = dp_deq_port_tbl[inst][cqm_deq_port].dma_ch_offset;
-	bp = port_info->subif_info[subif_ix].bp;
+	bp = sif->bp;
 
 	if (!dp_dma_chan_tbl[inst]) {
 		PR_ERR("dp_dma_chan_tbl[%d] NULL\n", inst);
@@ -1794,7 +1804,7 @@ static int subif_hw_reset(int inst, int portid, int subif_ix,
 		       inst, cqm_deq_port);
 		return DP_FAILURE;
 	}
-	if ((port_info->subif_info[subif_ix].ctp_dev) &&
+	if ((sif->ctp_dev) &&
 	    !dp_bp_dev_tbl[inst][bp].ref_cnt) {
 		PR_ERR("Why dp_bp_dev_tbl[%d][%d].ref_cnt =%d\n",
 		       inst, bp, dp_bp_dev_tbl[inst][bp].ref_cnt);
@@ -1805,15 +1815,15 @@ static int subif_hw_reset(int inst, int portid, int subif_ix,
 	dp_deq_port_tbl[inst][cqm_deq_port].ref_cnt--;
 	if (port_info->num_dma_chan)
 		atomic_dec(&(dp_dma_chan_tbl[inst] + dma_ch_offset)->ref_cnt);
-	if (port_info->subif_info[subif_ix].ctp_dev) { /* pmapper */
-		port_info->subif_info[subif_ix].ctp_dev = NULL;
+	if (sif->ctp_dev) { /* pmapper */
+		sif->ctp_dev = NULL;
 		dp_bp_dev_tbl[inst][bp].ref_cnt--;
 		if (!dp_bp_dev_tbl[inst][bp].ref_cnt) {
 			dp_bp_dev_tbl[inst][bp].dev = NULL;
 			dp_bp_dev_tbl[inst][bp].flag = 0;
 			DP_DEBUG(DP_DBG_FLAG_REG,
 				 "ctp ref_cnt becomes zero:%s\n",
-				 port_info->subif_info[subif_ix].device_name);
+				 sif->device_name);
 		}
 	}
 
@@ -1824,7 +1834,7 @@ static int subif_hw_reset(int inst, int portid, int subif_ix,
 		free_bridge_port(inst, bp);
 	}
 #ifdef CONFIG_INTEL_DATAPATH_QOS_HAL
-	qid = port_info->subif_info[subif_ix].qid;
+	qid = sif->qid;
 	cqm_deq_port = dp_q_tbl[inst][qid].cqm_dequeue_port;
 
 	if (dp_q_tbl[inst][qid].flag &&
@@ -1864,12 +1874,10 @@ static int subif_hw_reset(int inst, int portid, int subif_ix,
 		 atomic_read(&(dp_dma_chan_tbl[inst] +
 			     dma_ch_offset)->ref_cnt));
 #else
-	qos_queue_flush(priv->qdev, port_info->subif_info[subif_ix].q_node);
-	qos_queue_remove(priv->qdev, port_info->subif_info[subif_ix].q_node);
-	qos_port_remove(priv->qdev,
-			port_info->subif_info[subif_ix].qos_deq_port);
-	priv->deq_port_stat[port_info->subif_info[subif_ix].cqm_deq_port].flag =
-		PP_NODE_FREE;
+	qos_queue_flush(priv->qdev, sif->q_node);
+	qos_queue_remove(priv->qdev, sif->q_node);
+	qos_port_remove(priv->qdev, sif->qos_deq_port);
+	priv->deq_port_stat[sif->cqm_deq_port].flag = PP_NODE_FREE;
 #endif /* CONFIG_INTEL_DATAPATH_QOS_HAL */
 
 	if (!port_info->num_subif &&
@@ -1971,17 +1979,19 @@ static void update_port_vap(int inst, u32 *ep, int *vap,
 			    struct sk_buff *skb,
 			    struct pmac_rx_hdr *pmac, char *decryp)
 {
+	struct pmac_port_info *pi;
+
 	//*ep = pmac->igp_egp; /*get the port_id from pmac's sppid */
 #if defined(DP_SKB_HACK)
 	*ep = (skb->DW1 >> 4) & 0xF; /*get the port_id from pmac's sppid */
 #endif
-	if (dp_port_info[inst][*ep].alloc_flags & DP_F_LOOPBACK) {
+	pi = get_dp_port_info(inst, *ep);
+	if (pi->alloc_flags & DP_F_LOOPBACK) {
 		/*get the real source port from VAP for ipsec */
 		/* related tunnel decap case */
 		*ep = GET_VAP((u32)pmac->src_dst_subif_id_lsb +
 			(u32)(pmac->src_dst_subif_id_msb << 8),
-			PORT_INFO(inst, *ep, vap_offset),
-			PORT_INFO(inst, *ep, vap_mask));
+			pi->vap_offset, pi->vap_mask);
 		*vap = 0;
 		*decryp = 1;
 	} else {
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c b/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
index 16ecda329382..ae6bbc23db43 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
@@ -2599,7 +2599,7 @@ int dp_deq_port_res_get_31(struct dp_dequeue_res *res, int flag)
 		PR_ERR("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
-	port_info = &dp_port_info[res->inst][res->dp_port];
+	port_info = get_dp_port_info(res->inst, res->dp_port);
 	if (!port_info->deq_port_num)
 		return DP_FAILURE;
 	if (res->cqm_deq_idx == DEQ_PORT_OFFSET_ALL) {
@@ -4094,7 +4094,7 @@ int dp_queue_map_set_31(struct dp_queue_map_set *cfg, int flag)
 		cqm_flags |= CBM_QUEUE_MAP_F_EP_DONTCARE;
 	if (cfg->mask.subif) {
 		cqm_flags |= CBM_QUEUE_MAP_F_SUBIF_DONTCARE;
-		if (dp_port_info[cfg->inst][cfg->map.dp_port].gsw_mode ==
+		if (get_dp_port_info(cfg->inst, cfg->map.dp_port)->gsw_mode ==
 				GSW_LOGICAL_PORT_9BIT_WLAN)
 			cqm_flags |= CBM_QUEUE_MAP_F_SUBIF_LSB_DONTCARE;
 	}
@@ -4195,7 +4195,7 @@ int ppv4_queue_port_example(int inst, int dp_port, int t_cont, int q_node)
 	int cqm_deq_port;
 	struct pmac_port_info *port_info;
 
-	port_info = &dp_port_info[inst][dp_port];
+	port_info = get_dp_port_info(inst, dp_port);
 	cqm_deq_port = port_info->deq_port_base + t_cont;
 
 	/* Allocate qos dequeue port's node id via cqm_deq_port */
@@ -4269,7 +4269,7 @@ int ppv4_queue_scheduler(int inst, int dp_port, int t_cont, int q_node,
 	int cqm_deq_port;
 	struct pmac_port_info *port_info;
 
-	port_info = &dp_port_info[inst][dp_port];
+	port_info = get_dp_port_info(inst, dp_port);
 	cqm_deq_port = port_info->deq_port_base + t_cont;
 
 	/* Allocate qos dequeue port's node id via cqm_deq_port */
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_proc.c b/drivers/net/datapath/dpm/gswip31/datapath_proc.c
index 53e519507009..232e167a1dba 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_proc.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_proc.c
@@ -268,13 +268,13 @@ int proc_print_ctp_bp_info(struct seq_file *s, int inst,
 			   int subif_index, u32 flag)
 {
 	struct logic_dev *tmp;
-	int bp = port->subif_info[subif_index].bp;
+	struct dp_subif_info *sif = get_dp_port_subif(port, subif_index);
+	int bp = sif->bp;
 	unsigned char *buf = kmalloc(MAX_BP_NUM * 5 + 1, GFP_KERNEL);
 
 	seq_printf(s, "          : bp=%d(member:%s)\n", bp,
 		   get_bp_member_string(inst, bp, buf));
-	list_for_each_entry(tmp, &port->subif_info[subif_index].logic_dev,
-			    list) {
+	list_for_each_entry(tmp, &sif->logic_dev, list) {
 		seq_printf(s, "             %s: bp=%d(member:%s\n",
 			   tmp->dev->name, tmp->bp,
 			   get_bp_member_string(inst, tmp->bp, buf));
@@ -328,10 +328,11 @@ char *get_dma_flags_str31(u32 epn, char *buf, int buf_len)
 	tmp[0] = '\0';
 	f_found = 0;
 	for (i = 0; i < ARRAY_SIZE(dp_port_info); i++) {
-		if ((dp_port_info[inst][i].flag_other &
-		    CBM_PORT_DMA_CHAN_SET) &&
-		    (dp_port_info[inst][i].deq_port_base == epn)) {
-			tx_ch = dp_port_info[inst][i].dma_chan;
+		struct pmac_port_info *port = get_dp_port_info(inst, i);
+
+		if ((port->flag_other & CBM_PORT_DMA_CHAN_SET) &&
+		    (port->deq_port_base == epn)) {
+			tx_ch = port->dma_chan;
 			break;
 		}
 	}
@@ -369,7 +370,7 @@ char *get_dma_flags_str31(u32 epn, char *buf, int buf_len)
 
 		for (i = 3; i <= 4; i++) {	/*2 LAN port */
 			num = 0;
-			port = get_port_info(inst, i);
+			port = get_dp_port_info(inst, i);
 			if (!port)
 				continue;
 			if (cbm_dp_port_resources_get
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_rx.c b/drivers/net/datapath/dpm/gswip31/datapath_rx.c
index c4c71c5e8b3e..5a6dc0b304e5 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_rx.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_rx.c
@@ -86,15 +86,19 @@ static int dp_handle_lct(struct pmac_port_info *dp_port,
 			 struct sk_buff *skb, dp_rx_fn_t rx_fn)
 {
 	struct sk_buff *lct_skb;
+	struct dp_subif_info *sif;
+	struct dev_mib *mib;
 	int vap, ret;
 
 	vap = dp_port->lct_idx;
-	skb->dev = dp_port->subif_info[vap].netif;
+	sif = get_dp_port_subif(dp_port, vap);
+	mib = get_dp_port_subif_mib(sif);
+	skb->dev = sif->netif;
 	if (skb->data[PMAC_SIZE] & 0x1) {
 		/* multicast/broadcast */
 		DP_DEBUG(DP_DBG_FLAG_PAE, "LCT mcast or broadcast\n");
-		if((STATS_GET(dp_port->subif_info[vap].rx_flag) <= 0)) {
-			UP_STATS(dp_port->subif_info[vap].mib.rx_fn_dropped);
+		if((STATS_GET(sif->rx_flag) <= 0)) {
+			UP_STATS(mib->rx_fn_dropped);
 			return 1;
 		}
 		lct_skb = skb_clone(skb, GFP_ATOMIC);
@@ -102,8 +106,8 @@ static int dp_handle_lct(struct pmac_port_info *dp_port,
 			PR_ERR("LCT mcast/bcast skb clone fail\n");
 			return -1;
 		}
-		lct_skb->dev = dp_port->subif_info[vap].netif;	
-		UP_STATS(dp_port->subif_info[vap].mib.rx_fn_rxif_pkt);
+		lct_skb->dev = sif->netif;
+		UP_STATS(mib->rx_fn_rxif_pkt);
 		DP_DEBUG(DP_DBG_FLAG_PAE, "pkt sent lct(%s) ret(%d)\n",
 			 lct_skb->dev->name ? lct_skb->dev->name : "NULL",
 			 ret);
@@ -114,13 +118,13 @@ static int dp_handle_lct(struct pmac_port_info *dp_port,
 		DP_DEBUG(DP_DBG_FLAG_PAE, "LCT unicast\n");
 		DP_DEBUG(DP_DBG_FLAG_PAE, "unicast pkt sent lct(%s) ret(%d)\n",
 			 skb->dev->name ? skb->dev->name : "NULL", ret);
-		if ((STATS_GET(dp_port->subif_info[vap].rx_flag) <= 0)) {
-			UP_STATS(dp_port->subif_info[vap].mib.rx_fn_dropped);
+		if((STATS_GET(sif->rx_flag) <= 0)) {
+			UP_STATS(mib->rx_fn_dropped);
 			dev_kfree_skb_any(skb);
 			return 0;
 		}
 		rx_fn(skb->dev, NULL, skb, skb->len);
-		UP_STATS(dp_port->subif_info[vap].mib.rx_fn_rxif_pkt);
+		UP_STATS(mib->rx_fn_rxif_pkt);
 		return 0;
 	}
 	return 1;
@@ -149,8 +153,10 @@ int32_t dp_rx_31(struct sk_buff *skb, u32 flags)
 	struct pmac_port_info *dp_port;
 	struct mac_ops *ops;
 	int ret_lct = 1;
+	struct dp_subif_info *sif;
+	struct dev_mib *mib;
 
-	dp_port = &dp_port_info[inst][0];
+	dp_port = get_dp_port_info(inst, 0);
 	if (!skb) {
 		PR_ERR("skb NULL\n");
 		return DP_FAILURE;
@@ -197,15 +203,17 @@ int32_t dp_rx_31(struct sk_buff *skb, u32 flags)
 	} else {		/*GSWIP-R already know the destination */
 		rx_tx_flag = 1;
 		vap = GET_VAP(desc_0->field.dest_sub_if_id,
-			      dp_port_info[inst][port_id].vap_offset,
-			      dp_port_info[inst][port_id].vap_mask);
+			      get_dp_port_info(inst, port_id)->vap_offset,
+			      get_dp_port_info(inst, port_id)->vap_mask);
 	}
 	if (unlikely(!port_id)) { /*Normally shouldnot go to here */
 		rx_dbg_zero_port(skb, desc_0, desc_1, desc_2, desc_3, parser,
 				 pmac, paser_exist, ep, port_id, vap);
 		goto RX_DROP;
 	}
-	dp_port = &dp_port_info[inst][port_id];
+	dp_port = get_dp_port_info(inst, port_id);
+	sif = get_dp_port_subif(dp_port, vap);
+	mib = get_dp_port_subif_mib(sif);
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_PTP1588)
 	if (dp_port->f_ptp) {
 		ops = dp_port_prop[inst].mac_ops[port_id];
@@ -230,10 +238,10 @@ int32_t dp_rx_31(struct sk_buff *skb, u32 flags)
 		//desc_1->all &= dma_rx_desc_mask1.all;
 		desc_3->all &= dma_rx_desc_mask3.all;
 		skb->priority = desc_1->field.classid;
-		skb->dev = dp_port->subif_info[vap].netif;
+		skb->dev = sif->netif;
 		if (((dp_port->alloc_flags & DP_F_FAST_DSL) == 0) && /*non-dsl*/
-			dp_port->subif_info[vap].flags) { /*not de-registered */
-			dev = dp_port->subif_info[vap].netif;
+			sif->flags) { /*not de-registered */
+			dev = sif->netif;
 		}
 		if (decryp) { /*workaround mark for bypass xfrm policy*/
 			desc_1->field.dec = 1;
@@ -241,7 +249,7 @@ int32_t dp_rx_31(struct sk_buff *skb, u32 flags)
 		}
 		if (!dev &&
 		    ((dp_port->alloc_flags & DP_F_FAST_DSL) == 0)) {
-			UP_STATS(dp_port->subif_info[vap].mib.rx_fn_dropped);
+			UP_STATS(mib->rx_fn_dropped);
 			goto RX_DROP;
 		}
 
@@ -278,36 +286,31 @@ int32_t dp_rx_31(struct sk_buff *skb, u32 flags)
 		 *avoid forwarding duplicate packets from linux
 		 */
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_SWITCHDEV)
-			if (dp_port->subif_info[vap].fid > 0)
+			if (sif->fid > 0)
 				skb->offload_fwd_mark = 1;
 		#endif
 		if (rx_tx_flag == 0) {
 			if (dp_port->lct_idx > 0)
 				ret_lct = dp_handle_lct(dp_port, skb, rx_fn);
 			if (ret_lct) {
-				if ((STATS_GET(dp_port->subif_info[vap].
-					rx_flag) <= 0) &&
+				if ((STATS_GET(sif->rx_flag) <= 0) &&
 					((dp_port->alloc_flags & DP_F_FAST_DSL)
 						== 0)) {
-					UP_STATS(dp_port->subif_info[vap].
-							mib.rx_fn_dropped);
+					UP_STATS(mib->rx_fn_dropped);
 					goto RX_DROP2;
 				}
 				rx_fn(dev, NULL, skb, skb->len);
-				UP_STATS(dp_port->subif_info[vap].mib.
-								rx_fn_rxif_pkt);
+				UP_STATS(mib->rx_fn_rxif_pkt);
 			}
 		} else {
-			if ((STATS_GET(dp_port->subif_info[vap].
-					rx_flag) <= 0) &&
+			if ((STATS_GET(sif->rx_flag) <= 0) &&
 					((dp_port->alloc_flags & DP_F_FAST_DSL)
 						== 0)) {
-				UP_STATS(dp_port->subif_info[vap].mib.
-						rx_fn_dropped);
+				UP_STATS(mib->rx_fn_dropped);
 				goto RX_DROP2;
 			}
 			rx_fn(NULL, dev, skb, skb->len);
-			UP_STATS(dp_port->subif_info[vap].mib.rx_fn_txif_pkt);
+			UP_STATS(mib->rx_fn_txif_pkt);
 		}
 
 		return DP_SUCCESS;
@@ -326,7 +329,7 @@ int32_t dp_rx_31(struct sk_buff *skb, u32 flags)
 		DP_DEBUG(DP_DBG_FLAG_DUMP_RX,
 			 "Drop for subif of port %u not registered yet\n",
 			 port_id);
-		UP_STATS(dp_port->subif_info[vap].mib.rx_fn_dropped);
+		UP_STATS(mib->rx_fn_dropped);
 		goto RX_DROP2;
 	} else {
 		pr_info("Unknown issue\n");
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_switchdev.c b/drivers/net/datapath/dpm/gswip31/datapath_switchdev.c
index 0166b32ed685..7e36b615fa55 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_switchdev.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_switchdev.c
@@ -271,9 +271,10 @@ int dp_gswip_ext_vlan(int inst, int vap, int ep)
 	struct logic_dev *tmp = NULL;
 	int flag = 0, ret, i = 0;
 	int v1 = 0, v2 = 0;
+	struct dp_subif_info *sif;
 
 	gsw_handle = dp_port_prop[inst].ops[0];
-	port = &dp_port_info[inst][ep];
+	port = get_dp_port_info(inst, ep);
 	vlan = kzalloc(sizeof(*vlan), GFP_KERNEL);
 	if (!vlan) {
 		PR_ERR("failed to alloc ext_vlan of %d bytes\n", sizeof(*vlan));
@@ -291,8 +292,8 @@ int dp_gswip_ext_vlan(int inst, int vap, int ep)
 		       sizeof(*vlan->vlan1_list));
 		goto EXIT;
 	}
-	list_for_each_entry(tmp, &dp_port_info[inst][ep].
-			    subif_info[vap].logic_dev, list) {
+	sif = get_dp_port_subif(port, vap);
+	list_for_each_entry(tmp, &sif->logic_dev, list) {
 		DP_DEBUG(DP_DBG_FLAG_SWDEV, "tmp dev name:%s\n",
 			 tmp->dev ? tmp->dev->name : "NULL");
 		if (!tmp->dev) {
@@ -335,17 +336,17 @@ int dp_gswip_ext_vlan(int inst, int vap, int ep)
 		 v1, v2, i);
 	vlan->n_vlan1 = v1;
 	vlan->n_vlan2 = v2;
-	vlan->bp = port->subif_info[vap].bp;
+	vlan->bp = sif->bp;
 	vlan->logic_port = port->port_id;
-	vlan->subif_grp = port->subif_info[vap].subif;/*subif value*/
+	vlan->subif_grp = sif->subif;/*subif value*/
 
-	if (port->subif_info[vap].swdev_priv)
-		vlan->priv = port->subif_info[vap].swdev_priv;
+	if (sif->swdev_priv)
+		vlan->priv = sif->swdev_priv;
 	else
 		vlan->priv = NULL;
 	ret = set_gswip_ext_vlan(gsw_handle, vlan, flag);
 	if (ret == 0)
-		port->subif_info[vap].swdev_priv = vlan->priv;
+		sif->swdev_priv = vlan->priv;
 	else
 		PR_ERR("set gswip ext vlan return error\n");
 
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_tx.c b/drivers/net/datapath/dpm/gswip31/datapath_tx.c
index f9fc791d951b..961fa9dddde9 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_tx.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_tx.c
@@ -113,7 +113,7 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 		struct dma_tx_desc_1 *desc_1;
 		struct dma_tx_desc_2 *desc_2;
 		struct dma_tx_desc_3 *desc_3;
-		struct pmac_port_info *dp_info = NULL;
+		struct pmac_port_info *dp_info;
 		struct pmac_tx_hdr pmac = {0};
 		u32 ip_offset, tcp_h_offset, tcp_type;
 		char tx_chksum_flag = 0; /*check csum cal can be supported or not */
@@ -127,7 +127,8 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 		struct mac_ops *ops;
 		int rec_id = 0;
 #endif
-	
+		struct dev_mib *mib;
+
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_EXTRA_DEBUG)
 		if (unlikely(!dp_init_ok)) {
 			err_ret = DP_XMIT_ERR_NOT_INIT;
@@ -153,8 +154,9 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 			goto lbl_err_ret;
 		}
 #endif
-		dp_info = &dp_port_info[inst][ep];
+		dp_info = get_dp_port_info(inst, ep);
 		vap = GET_VAP(rx_subif->subif, dp_info->vap_offset, dp_info->vap_mask);
+		mib = get_dp_port_subif_mib(get_dp_port_subif(dp_info, vap));
 		if (unlikely(!rx_if && /*For atm pppoa case, rx_if is NULL now */
 			     !(dp_info->alloc_flags & DP_F_FAST_DSL))) {
 			err_ret = DP_XMIT_ERR_NULL_IF;
@@ -359,7 +361,7 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 #if IS_ENABLED(CONFIG_LTQ_TOE_DRIVER)
 		if (skb_is_gso(skb)) {
 			res = ltq_tso_xmit(skb, &pmac, sizeof(pmac), 0);
-			UP_STATS(dp_info->subif_info[vap].mib.tx_tso_pkt);
+			UP_STATS(mib->tx_tso_pkt);
 			return res;
 		}
 #endif /* CONFIG_LTQ_TOE_DRIVER */
@@ -382,7 +384,7 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 			data.dp_inst = 0;
 		}
 		res = cbm_cpu_pkt_tx(skb, &data, 0);
-		UP_STATS(dp_info->subif_info[vap].mib.tx_cbm_pkt);
+		UP_STATS(mib->tx_cbm_pkt);
 		return res;
 	
 	lbl_err_ret:
@@ -395,18 +397,19 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 			break;
 		case DP_XMIT_ERR_NULL_SUBIF:
 			PR_RATELIMITED("dp_xmit failed for rx_subif null\n");
-			UP_STATS(PORT_INFO(inst, 0, tx_err_drop));
+			UP_STATS(get_dp_port_info(inst, 0)->tx_err_drop);
 			break;
 		case DP_XMIT_ERR_PORT_TOO_BIG:
-			UP_STATS(PORT_INFO(inst, 0, tx_err_drop));
+			UP_STATS(get_dp_port_info(inst, 0)->tx_err_drop);
 			PR_RATELIMITED("rx_subif->port_id >= max_ports");
 			break;
 		case DP_XMIT_ERR_NULL_SKB:
 			PR_RATELIMITED("skb NULL");
-			UP_STATS(PORT_INFO(inst, rx_subif->port_id, tx_err_drop));
+			UP_STATS(get_dp_port_info(inst, rx_subif->port_id)->
+				 tx_err_drop);
 			break;
 		case DP_XMIT_ERR_NULL_IF:
-			UP_STATS(PORT_VAP_MIB(inst, ep, vap, tx_pkt_dropped));
+			UP_STATS(mib->tx_pkt_dropped);
 			PR_RATELIMITED("rx_if NULL");
 			break;
 		case DP_XMIT_ERR_REALLOC_SKB:
@@ -425,9 +428,8 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 		case DP_XMIT_PTP_ERR:
 			break;
 		default:
-			UP_STATS(dp_info->subif_info[vap].mib.tx_pkt_dropped);
-			PR_INFO_ONCE("Why come to here:%x\n",
-				     dp_port_info[inst][ep].status);
+			UP_STATS(mib->tx_pkt_dropped);
+			PR_INFO_ONCE("Why come to here:%x\n", dp_info->status);
 		}
 		if (skb)
 			dev_kfree_skb_any(skb);
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_gswip.c b/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
index 35f363794424..76ab8d390127 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
@@ -587,10 +587,11 @@ struct gsw_itf *ctp_port_assign_32(int inst, u8 ep, int bp_default,
 	int i, alloc_flag;
 	u16 num;
 	struct core_ops *gsw_handle;
+	struct pmac_port_info *port_info = get_dp_port_info(inst, ep);
 
 	memset(&ctp_assign, 0, sizeof(ctp_assign));
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
-	alloc_flag = get_dp_port_info(inst, ep)->alloc_flags;
+	alloc_flag = port_info->alloc_flags;
 
 	if (flags & DP_F_DEREGISTER) {
 		PR_ERR("Need to Free CTP Port here for ep=%d\n", ep);
@@ -642,11 +643,11 @@ struct gsw_itf *ctp_port_assign_32(int inst, u8 ep, int bp_default,
 	itf_assign[ep].end = ctp_assign.nFirstCtpPortId +
 		 ctp_assign.nNumberOfCtpPort - 1;
 	itf_assign[ep].ep = ep;
-	get_dp_port_info(inst, ep)->ctp_max = ctp_assign.nNumberOfCtpPort;
-	get_dp_port_info(inst, ep)->vap_offset = assign->vap_offset;
-	get_dp_port_info(inst, ep)->vap_mask = assign->vap_mask;
+	port_info->ctp_max = ctp_assign.nNumberOfCtpPort;
+	port_info->vap_offset = assign->vap_offset;
+	port_info->vap_mask = assign->vap_mask;
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_SWITCHDEV)
-	get_dp_port_info(inst, ep)->swdev_en = assign->swdev_enable;
+	port_info->swdev_en = assign->swdev_enable;
 #endif
 	return &itf_assign[ep];
 }
@@ -655,8 +656,9 @@ int set_port_lookup_mode_32(int inst, u8 ep, u32 flags)
 {
 	int i, alloc_flag;
 	struct ctp_assign *assign = &ctp_assign_def;
+	struct pmac_port_info *port_info = get_dp_port_info(inst, ep);
 
-	alloc_flag = get_dp_port_info(inst, ep)->alloc_flags;
+	alloc_flag = port_info->alloc_flags;
 	for (i = 0; i < ARRAY_SIZE(ctp_assign_info); i++) {
 		if ((ctp_assign_info[i].flag & alloc_flag) ==
 		    ctp_assign_info[i].flag) {
@@ -664,9 +666,9 @@ int set_port_lookup_mode_32(int inst, u8 ep, u32 flags)
 			break;
 		}
 	}
-	get_dp_port_info(inst, ep)->cqe_lu_mode = assign->lookup_mode;
-	get_dp_port_info(inst, ep)->gsw_mode = (u32)assign->emode;
-	return	0;
+	port_info->cqe_lu_mode = assign->lookup_mode;
+	port_info->gsw_mode = (u32)assign->emode;
+	return 0;
 }
 
 /*Allocate a bridge port with specified FID and hardcoded CPU port member */
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_misc.c b/drivers/net/datapath/dpm/gswip32/datapath_misc.c
index 313df55c5f79..982f17c68270 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_misc.c
@@ -221,6 +221,7 @@ void dump_tx_dma_desc_32(struct dma_tx_desc_0 *desc_0,
 	int dp_port;
 	struct hal_priv *priv = HAL(inst);
 	struct cbm_lookup cbm_lookup;
+	struct pmac_port_info *port_info;
 
 	if (!desc_0 || !desc_1 || !desc_2 || !desc_3) {
 		PR_ERR("tx desc_0/1/2/3 NULL\n");
@@ -251,47 +252,48 @@ void dump_tx_dma_desc_32(struct dma_tx_desc_0 *desc_0,
 		desc_3->field.sp, desc_3->field.pool_policy,
 		desc_3->field.data_len);
 	dp_port = priv->gp_dp_map[desc_1->field.ep].dpid; /* get lpid */
-	if (get_dp_port_info(inst, dp_port)->cqe_lu_mode == CQE_LU_MODE0)
+	port_info = get_dp_port_info(inst, dp_port);
+	if (port_info->cqe_lu_mode == CQE_LU_MODE0)
 		/* Eg Lpid[3:0] Sub_If_Id[13:8] Class[1:0] */
 		lookup = ((desc_0->field.dest_sub_if_id >> 8) << 2) |
 			 ((desc_1->field.classid & 0x3)) |
 			 ((dp_port & 0x0F) << 8) |
 			 ((desc_1->field.redir) << 12);
-	else if (get_dp_port_info(inst, dp_port)->cqe_lu_mode == CQE_LU_MODE1)
+	else if (port_info->cqe_lu_mode == CQE_LU_MODE1)
 		/* Eg Lpid[3:0] Sub_If_Id[7:0] */
 		lookup = (desc_0->field.dest_sub_if_id) |
 			 ((dp_port & 0x0F) << 8) |
 			 ((desc_1->field.redir) << 12);
-	else if (get_dp_port_info(inst, dp_port)->cqe_lu_mode == CQE_LU_MODE2)
+	else if (port_info->cqe_lu_mode == CQE_LU_MODE2)
 		/* Eg Lpid[3:0] Sub_If_Id[11:8] Class[3:0] */
 		lookup = ((desc_0->field.dest_sub_if_id >> 8) << 4) |
 			 (desc_1->field.classid) |
 			 ((dp_port & 0x0F) << 8) |
 			 ((desc_1->field.redir) << 12);
-	else if (get_dp_port_info(inst, dp_port)->cqe_lu_mode == CQE_LU_MODE3)
+	else if (port_info->cqe_lu_mode == CQE_LU_MODE3)
 		/* Eg Lpid[3:0] Sub_If_Id[4:0] Class[2:0] */
 		lookup = ((desc_0->field.dest_sub_if_id & 0x1F) << 3) |
 			 (desc_1->field.classid & 0x7) |
 			 ((dp_port & 0x0F) << 8) |
 			 ((desc_1->field.redir) << 12);
-	else if (get_dp_port_info(inst, dp_port)->cqe_lu_mode == CQE_LU_MODE4)
+	else if (port_info->cqe_lu_mode == CQE_LU_MODE4)
 		/* Eg Lpid[3:0] Class[1:0] Sub_If_Id[5:0] */
 		lookup = ((desc_0->field.dest_sub_if_id & 0x1F) << 3) |
 			 (desc_1->field.classid & 0x7) |
 			 ((dp_port & 0x0F) << 8) |
 			 ((desc_1->field.redir) << 12);
-	else if (get_dp_port_info(inst, dp_port)->cqe_lu_mode == CQE_LU_MODE5)
+	else if (port_info->cqe_lu_mode == CQE_LU_MODE5)
 		/* Eg Lpid[3:0] Sub_If_Id[15:8] */
 		lookup = ((desc_0->field.dest_sub_if_id & 0xFF00) >> 8) |
 			 ((dp_port & 0x0F) << 8) |
 			 ((desc_1->field.redir) << 12);
-	else if (get_dp_port_info(inst, dp_port)->cqe_lu_mode == CQE_LU_MODE6)
+	else if (port_info->cqe_lu_mode == CQE_LU_MODE6)
 		/* Eg Lpid[3:0] Sub_If_Id[1:0] Class[3:0] Color[1:0] */
 		lookup = ((desc_0->field.dest_sub_if_id & 0x2) << 6) |
 			 ((desc_1->field.classid) << 2) |
 			 ((dp_port & 0x0F) << 8) |
 			 ((desc_1->field.redir) << 12);
-	else if (get_dp_port_info(inst, dp_port)->cqe_lu_mode == CQE_LU_MODE7)
+	else if (port_info->cqe_lu_mode == CQE_LU_MODE7)
 		/* Eg Lpid[3:0] Sub_If_Id[14:8] Class[0] */
 		lookup = ((desc_0->field.dest_sub_if_id >> 8) << 1) |
 			 (desc_1->field.classid & 0x1) |
@@ -299,7 +301,7 @@ void dump_tx_dma_desc_32(struct dma_tx_desc_0 *desc_0,
 			 ((desc_1->field.redir) << 12);
 	else {
 		PR_INFO("Invalid Lookup Mode: %d\n",
-			get_dp_port_info(inst, dp_port)->cqe_lu_mode);
+			port_info->cqe_lu_mode);
 		return;
 	}
 	cbm_lookup.index = lookup;
@@ -1097,8 +1099,8 @@ int dp_platform_queue_set_32(int inst, u32 flag)
 
 	/*Set CPU port to Mode0 only*/
 	mode = cpu_assign->lookup_mode;
-	get_dp_port_info(inst, 0)->cqe_lu_mode = mode;
-	get_dp_port_info(inst, 0)->status = PORT_DEV_REGISTERED;
+	port_info->cqe_lu_mode = mode;
+	port_info->status = PORT_DEV_REGISTERED;
 	lookup.ep = PMAC_CPU_ID;
 	cqm_mode_table_set(dp_port_prop[inst].cbm_inst, &lookup,
 			   mode,
@@ -1274,11 +1276,11 @@ static int dp_platform_set(int inst, u32 flag)
 	GSW_QoS_portRemarkingCfg_t port_remark;
 	struct core_ops *gsw_handle;
 	struct hal_priv *priv;
+	struct pmac_port_info *pi = get_dp_port_info(inst, CPU_PORT);
 
 	/* For initialize */
 	if ((flag & DP_PLATFORM_INIT) == DP_PLATFORM_INIT) {
 		struct dp_subif_info *sif;
-
 		dp_port_prop[inst].priv_hal =
 			kzalloc(sizeof(*priv), GFP_KERNEL);
 		if (!dp_port_prop[inst].priv_hal) {
@@ -1300,9 +1302,9 @@ static int dp_platform_set(int inst, u32 flag)
 			dp_sub_proc_install_32();
 		init_qos_fn_32();
 		/*just for debugging purpose */
-		sif = get_dp_port_subif(get_dp_port_info(inst, 0), 0);
+		sif = get_dp_port_subif(pi, 0);
 		sif->bp = CPU_BP;
-		get_dp_port_info(inst, 0)->alloc_flags = DP_F_CPU;
+		pi->alloc_flags = DP_F_CPU;
 		sif->mac_learn_dis = DP_MAC_LEARNING_DIS;
 		INIT_LIST_HEAD(&sif->logic_dev);
 
@@ -1361,9 +1363,8 @@ static int dp_platform_set(int inst, u32 flag)
 		free_bridge_port_32(inst, priv->bp_def);
 	init_ppv4_qos_32(inst, flag); /*de-initialize qos */
 	kfree(priv);
-	free_gpid(inst, get_dp_port_info(inst, CPU_PORT)->gpid_base,
-		  get_dp_port_info(inst, CPU_PORT)->gpid_num);
-	get_dp_port_info(inst, CPU_PORT)->gpid_num = 0;
+	free_gpid(inst, pi->gpid_base, pi->gpid_num);
+	pi->gpid_num = 0;
 	dp_port_prop[inst].priv_hal = NULL;
 
 	return 0;
@@ -1505,7 +1506,7 @@ static int port_platform_set(int inst, u8 ep, struct dp_port_data *data,
 		DP_DEBUG(DP_DBG_FLAG_DBG, "deq_port_tbl[%d][%d].dma_chan=%x\n",
 			 inst, (i + idx), dma_chan);
 	}
-	mode = get_dp_port_info(inst, ep)->cqe_lu_mode;
+	mode = port_info->cqe_lu_mode;
 	lookup.ep = ep;
 	/*Set all mode based on MPE1/2 to same single mode as specified */
 	cqm_mode_table_set(dp_port_prop[inst].cbm_inst, &lookup,
@@ -1851,8 +1852,8 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 	/* For 1st subif and mode 0, use CBM_QUEUE_MAP_F_SUBIF_DONTCARE,
 	 * otherwise, don't use this flag
 	 */
-	if (!get_dp_port_info(inst, portid)->num_subif &&
-	    (get_dp_port_info(inst, portid)->cqe_lu_mode == CQE_LU_MODE0))
+	if (!port_info->num_subif &&
+	    (port_info->cqe_lu_mode == CQE_LU_MODE0))
 		lookup_f |= CBM_QUEUE_MAP_F_SUBIF_DONTCARE;
 	lookup.egflag = 0;
 	cbm_queue_map_set(dp_port_prop[inst].cbm_inst,
@@ -1864,8 +1865,8 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 		 "subif_hw_set",
 		 "qid", q_port.qid,
 		 "for dp_port", lookup.ep,
-		 "num_subif", get_dp_port_info(inst, portid)->num_subif,
-		 "lu_mode", get_dp_port_info(inst, portid)->cqe_lu_mode,
+		 "num_subif", port_info->num_subif,
+		 "lu_mode", port_info->cqe_lu_mode,
 		 "flag", lookup_f,
 		 "subif", subif, subif_ix,
 		 "egflag", lookup.egflag);
@@ -1879,8 +1880,8 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 		 "subif_hw_set",
 		 "qid", q_port.qid,
 		 "for dp_port", lookup.ep,
-		 "num_subif", get_dp_port_info(inst, portid)->num_subif,
-		 "lu_mode", get_dp_port_info(inst, portid)->cqe_lu_mode,
+		 "num_subif", port_info->num_subif,
+		 "lu_mode", port_info->cqe_lu_mode,
 		 "flag", lookup_f,
 		 "subif", subif, subif_ix,
 		 "egflag", lookup.egflag);
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_proc.c b/drivers/net/datapath/dpm/gswip32/datapath_proc.c
index a14fd7bd5e64..3baae69e70a8 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_proc.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_proc.c
@@ -332,10 +332,11 @@ char *get_dma_flags_str32(u32 epn, char *buf, int buf_len)
 	tmp[0] = '\0';
 	f_found = 0;
 	for (i = 0; i < ARRAY_SIZE(dp_port_info); i++) {
-		if ((get_dp_port_info(inst, i)->flag_other &
-		    CBM_PORT_DMA_CHAN_SET) &&
-		    (get_dp_port_info(inst, i)->deq_port_base == epn)) {
-			tx_ch = get_dp_port_info(inst, i)->dma_chan;
+		struct pmac_port_info *port = get_dp_port_info(inst, i);
+
+		if ((port->flag_other & CBM_PORT_DMA_CHAN_SET) &&
+		    (port->deq_port_base == epn)) {
+			tx_ch = port->dma_chan;
 			break;
 		}
 	}
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_switchdev.c b/drivers/net/datapath/dpm/gswip32/datapath_switchdev.c
index 7d15c166aa8c..cc0e2de45325 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_switchdev.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_switchdev.c
@@ -271,7 +271,7 @@ int dp_gswip_ext_vlan_32(int inst, int vap, int ep)
 	struct logic_dev *tmp = NULL;
 	int flag = 0, ret, i = 0;
 	int v1 = 0, v2 = 0;
-	struct pmac_subif_info *sif;
+	struct dp_subif_info *sif;
 
 	gsw_handle = dp_port_prop[inst].ops[0];
 	port = get_dp_port_info(inst, ep);
