From e6f48ce3cb4a0fb40be7cc3034d0314053231f7f Mon Sep 17 00:00:00 2001
From: anishkhx <anishx.khurana@intel.com>
Date: Tue, 7 Aug 2018 16:58:54 +0800
Subject: [PATCH] DRVLIB_SW-853: dp metering API implementation and checkpatch
 fixes

---
 .../ethernet/lantiq/datapath/datapath_proc_qos.c   | 117 +++++-
 .../lantiq/datapath/gswip31/datapath_gswip.c       | 467 +++++++++++++++++++++
 .../lantiq/datapath/gswip31/datapath_misc.c        |   3 +
 .../lantiq/datapath/gswip31/datapath_misc.h        |   3 +
 include/net/datapath_inst.h                        |   6 +
 5 files changed, 595 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_proc_qos.c b/drivers/net/ethernet/lantiq/datapath/datapath_proc_qos.c
index 085091aa1900..3ae3f770b359 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_proc_qos.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_proc_qos.c
@@ -11,13 +11,18 @@
 #include <net/datapath_proc_api.h>
 #include "datapath.h"
 
+/*meter alloc,add macros*/
+#define DP_MTR_ALC(id, flag) \
+	dp_port_prop[0].info.dp_meter_alloc(&(id), (flag))
+#define DP_MTR_CFGAPI(func, dev, meter, flag) \
+	dp_port_prop[0].info.func((dev), &(meter), (flag))
+
 #define PROC_MAX_BOX_LVL (DP_MAX_SCH_LVL + 1) /* Sched/Port both map to a box */
 /* max direct child per scheduler/port */
 #define PROC_DP_MAX_CHILD_PER_SCH_PORT DP_MAX_CHILD_PER_NODE
 #define PROC_MAX_Q_PER_PORT 16 /* max queues per port */
 #define PROC_DP_MAX_SCH_PER_PORT 4 /* max schedulers per port */
 #define PROC_DP_MAX_LEAF 8 /* max leaf per scheduler */
-
 struct location {
 	int x1, y1; /* start axis */
 	int x2, y2; /* end axis */
@@ -948,6 +953,20 @@ void qos_create_qos_help(void)
 		"resume/suspend");
 	PR_INFO("                enable/disable: only for queue/port\n");
 	PR_INFO("                resume/suspend: for all nodes\n");
+	PR_INFO(" METER ADD/DELETE: echo meter <dev> %s",
+		"<alloc/dealloc/add/delete>\n");
+	PR_INFO("<port_flag> <trfic_dir> <trfic_type> <cir> <pir> <cbs> %s",
+		"<pbs> <type> > /sys/kernel/debug/dp/qos");
+	PR_INFO("     dev: CTP/BP/Bridge device name\n");
+	PR_INFO("     alloc/deallc/add/del: meter operation\n");
+	PR_INFO("     port_flag: opt flag for CTP/BP/br/clrMrk/CPUtrfic\n");
+	PR_INFO("     trfic_dir: opt ingress or egress data\n");
+	PR_INFO("     trfic_type: traffic flow type(unicast,multicast,..\n");
+	PR_INFO("     cir: opt committed information rate in bit/s\n");
+	PR_INFO("     pir: opt Peak information rate in bit/s\n");
+	PR_INFO("     cbs: opt committed burst size in bytes\n");
+	PR_INFO("     pbs: opt peak burst size in bytes\n");
+	PR_INFO("     type:opt type single/dual rate(strTCM,trTCM\n");
 }
 
 ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
@@ -1190,6 +1209,102 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 			PR_ERR("dp_shaper_conf_set failed\n");
 			return count;
 		}
+	} else if (dp_strncmpi(param_list[0], "meter",
+			       strlen("meter")) == 0) {
+		struct dp_meter_cfg meter = {
+			.type = srTCM,
+			.cir = 5000000,
+			.pir = 5000000,
+			.cbs = 1023,
+			.pbs = 1023,
+			.col_mode = 0,
+			.dir = DP_DIR_EGRESS,
+			.mode = DP_PCP_8P0D,
+			.flow = DP_UKNOWN_UNICAST
+			};
+			struct net_device *dev;
+			int ret;
+			int meter_flag = DP_METER_ATTACH_CTP, meterid = -1;
+
+		dev = dev_get_by_name(&init_net, param_list[1]);
+		if (!dev) {
+			PR_ERR(" dev NULL\n");
+			return count;
+		}
+		if (dp_strncmpi(param_list[2], "dealloc",
+				strlen("dealloc")) == 0) {
+			meterid = dp_atoi(param_list[3]);
+			ret = DP_MTR_ALC(meterid, DP_F_DEREGISTER);
+			if (ret < 0) {
+				PR_ERR("Fail to get meter dealloc\n");
+				return count;
+			}
+			PR_INFO("Meter dealloc succes, MeterId:=%d\n",
+				meterid);
+		} else if (dp_strncmpi(param_list[2], "alloc",
+				strlen("alloc")) == 0) {
+			ret = DP_MTR_ALC(meterid, 0);
+			if (ret < 0) {
+				PR_ERR("Fail to get meter alloc\n");
+				return count;
+			}
+			PR_INFO("Meter alloc succes, MeterId:=%d\n", meterid);
+		} else if ((dp_strncmpi(param_list[2], "del",
+			   strlen("del")) == 0) ||
+			   (dp_strncmpi(param_list[2], "add",
+			   strlen("add")) == 0)) {
+			int param_val;
+
+			if (!param_list[3]) {
+				PR_ERR("meterid NULLL\n");
+				return count;
+			}
+			param_val = dp_atoi(param_list[3]);
+			if (param_val < 0) {
+				PR_ERR("meterid less then 0");
+				return count;
+			}
+			meter.meter_id = param_val;
+			param_val = dp_atoi(param_list[4]);
+			if (param_val)
+				meter_flag = param_val;
+			param_val = dp_atoi(param_list[5]);
+			if (param_val)
+				meter.dir = param_val;
+			param_val = dp_atoi(param_list[6]);
+			if (param_val)
+				meter.flow = param_val;
+			param_val = dp_atoi(param_list[7]);
+			if (param_val)
+				meter.cir = param_val;
+			param_val = dp_atoi(param_list[8]);
+			if (param_val)
+				meter.pir = param_val;
+			param_val = dp_atoi(param_list[9]);
+			if (param_val)
+				meter.cbs = param_val;
+			param_val = dp_atoi(param_list[10]);
+			if (param_val)
+				meter.pbs = param_val;
+			param_val = dp_atoi(param_list[11]);
+			if (param_val)
+				meter.type =  param_val;
+			meter.mode = DP_PCP_8P0D;
+			if (dp_strncmpi(param_list[2], "add",
+					strlen("add")) == 0)
+				ret = DP_MTR_CFGAPI(dp_meter_add, dev,
+						    meter, meter_flag);
+			else
+				ret = DP_MTR_CFGAPI(dp_meter_del, dev,
+						    meter, meter_flag);
+			if (ret < 0) {
+				PR_ERR("meter %s failed\n",
+				       param_list[2]);
+				return count;
+			}
+			PR_ERR("meterid:=%d %s success\n",
+			       meter.meter_id, param_list[2]);
+		}
 	} else if (dp_strncmpi(param_list[0], "set_node",
 			       strlen("set_node")) == 0) {
 		struct dp_node_link_enable en_node = {0};
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_gswip.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_gswip.c
index 9e2608d37e7a..eece876502ff 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_gswip.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_gswip.c
@@ -19,6 +19,22 @@
 #include "datapath_gswip_simulate.h"
 #endif
 
+#define GSW_CORE_API(_handle, a, b) ({ \
+	typeof(_handle) (handle) = (_handle); \
+	gsw_core_api((dp_gsw_cb)(handle)->a, (handle), (b)); })
+
+#define BP_CFG(_bp_cfg, _index, bflag, id) ({ \
+	typeof(_bp_cfg) (bp_cfg) = (_bp_cfg); \
+	typeof(_index) (index) = (_index); \
+	(bp_cfg)->bEgressSubMeteringEnable[(index)] = bflag; \
+	(bp_cfg)->nEgressTrafficSubMeterId[(index)] = id; })
+
+#define BR_CFG(_br_cfg, _index, bflag, id) ({\
+	typeof(_br_cfg) (br_cfg) = (_br_cfg); \
+	typeof(_index) (index) = (_index); \
+	(br_cfg)->bSubMeteringEnable[(index)] = bflag; \
+	(br_cfg)->nTrafficSubMeterId[(index)] = id; })
+
 struct ctp_assign {
 	u32 flag; /*Datapath Device Flag */
 	GSW_LogicalPortMode_t emode; /*mapped GSWIP CTP flag */
@@ -980,3 +996,454 @@ int dp_get_gsw_pmapper_31(int inst, int bport, int lport,
 	}
 	return 0;
 }
+
+int dp_meter_alloc_31(int *meterid, int flag)
+{
+	struct core_ops *gsw_handle;
+	GSW_QoS_meterCfg_t meter_cfg = {0};
+	GSW_return_t ret;
+
+	gsw_handle = dp_port_prop[0].ops[GSWIP_L];
+	if (!gsw_handle)
+		return -1;
+	if (flag == DP_F_DEREGISTER && *meterid >= 0) {
+		meter_cfg.nMeterId = *meterid;
+		ret = GSW_CORE_API(gsw_handle, gsw_qos_ops.QOS_MeterAlloc,
+				   &meter_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("Meter dealloc failed: %d\n", ret);
+			return -1;
+		}
+		return 0;
+	}
+	memset(&meter_cfg, 0, sizeof(meter_cfg));
+	meter_cfg.nMeterId = 0xFFFF;
+	ret = GSW_CORE_API(gsw_handle, gsw_qos_ops.QOS_MeterAlloc,
+			   &meter_cfg);
+	if ((ret != GSW_statusOk) || (meter_cfg.nMeterId < 0)) {
+		PR_ERR("Failed to get a meter alloc\n");
+		*meterid = -1;
+		return -1;
+	}
+	*meterid = meter_cfg.nMeterId;
+	return 0;
+}
+
+int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
+		    int flag)
+{
+	struct core_ops *gsw_handle;
+	GSW_QoS_meterCfg_t meter_cfg;
+	GSW_BRIDGE_portConfig_t *bp_cfg = NULL;
+	GSW_PCE_rule_t *pce_rule = NULL;
+	GSW_CTP_portConfig_t *ctp_cfg = NULL;
+	GSW_BRIDGE_config_t *br_cfg = NULL;
+	GSW_return_t ret;
+	dp_subif_t subif = {0};
+	int bret = 0;
+
+	if (flag & DP_METER_ATTACH_CTP || flag & DP_METER_ATTACH_BRPORT) {
+		ret = dp_get_netif_subifid(dev, NULL, NULL, NULL, &subif, 0);
+		if (ret < 0) {
+			PR_ERR("dp_get_netif_subifid fail:%s\n", dev->name);
+			return -1;
+		}
+	}
+	gsw_handle = dp_port_prop[subif.inst].ops[GSWIP_L];
+	if (!gsw_handle)
+		return -1;
+
+	memset(&meter_cfg, 0, sizeof(GSW_QoS_meterCfg_t));
+	meter_cfg.nCbs = meter->cbs;
+	meter_cfg.nRate = meter->cir / 1000;
+	meter_cfg.nEbs = meter->cbs;
+	meter_cfg.nPiRate = meter->pir / 1000;
+	meter_cfg.bEnable = 1;
+	if (meter->type == srTCM)
+		meter_cfg.eMtrType = GSW_QOS_Meter_srTCM;
+	else
+		meter_cfg.eMtrType = GSW_QOS_Meter_trTCM;
+	meter_cfg.nMeterId = meter->meter_id;
+	if (flag & DP_METER_COL_MARKING_ONLY)
+		meter_cfg.nColourBlindMode = 7 ; //meter->mode;
+	ret = GSW_CORE_API(gsw_handle, gsw_qos_ops.QoS_MeterCfgSet,
+			   &meter_cfg);
+	if (ret != GSW_statusOk) {
+		PR_ERR("MeterCfgSet API failed:%d\n", ret);
+		return -1;
+	}
+
+	if (flag & DP_METER_ATTACH_FLOW) {
+		int pci_rule_id = 0;
+
+		/* pattern setting */
+		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_KERNEL);
+		if (!pce_rule) {
+			PR_ERR("ctp_cfg alloc failed\n");
+			bret = -1;
+			goto err;
+		}
+		pce_rule->pattern.nIndex = pci_rule_id;
+		pce_rule->pattern.bEnable = 1;
+		/* action setting */
+		pce_rule->action.eMeterAction = GSW_PCE_ACTION_METER_1;
+		pce_rule->action.nMeterId =  meter->meter_id;
+		ret = GSW_CORE_API(gsw_handle, gsw_tflow_ops.TFLOW_PceRuleWrite,
+				   pce_rule);
+		if (ret != GSW_statusOk) {
+			PR_ERR("PceRule Write API failed :%d\n", ret);
+			goto err_flow;
+		}
+	}
+	if (flag & DP_METER_ATTACH_CTP) {/* CTP port Flag */
+		struct pmac_port_info *port_info;
+
+		if (subif.flag_pmapper) {
+			PR_ERR("can't use CTP,pmapper is enable\n");
+			bret = -1;
+			goto err_flow;
+		}
+		ctp_cfg = kzalloc(sizeof(GSW_CTP_portConfig_t), GFP_KERNEL);
+		if (!ctp_cfg) {
+			PR_ERR("ctp_cfg alloc failed\n");
+			bret = -1;
+			goto err_flow;
+		}
+		port_info = get_port_info_via_dp_name(dev);
+		if (!port_info) {
+			PR_ERR(" port_info is NULL\n");
+			bret = -1;
+			goto err_ctp;
+		}
+		ctp_cfg->nLogicalPortId = subif.port_id;
+		ctp_cfg->nSubIfIdGroup  = GET_VAP(subif.subif,
+							port_info->vap_offset,
+							port_info->vap_mask);
+		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigGet,
+				   ctp_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("PortConfigGet API failed :%d\n", ret);
+			bret = -1;
+			goto err_ctp;
+		}
+		if (meter->dir == DP_DIR_EGRESS) {
+			ctp_cfg->eMask = GSW_CTP_PORT_CONFIG_EGRESS_METER;
+			ctp_cfg->bEgressMeteringEnable = 1;
+			ctp_cfg->nEgressTrafficMeterId =  meter->meter_id;
+		} else if (meter->dir == DP_DIR_INGRESS) {
+			ctp_cfg->eMask = GSW_CTP_PORT_CONFIG_INGRESS_METER;
+			ctp_cfg->bIngressMeteringEnable = 1;
+			ctp_cfg->nIngressTrafficMeterId =  meter->meter_id;
+		}
+		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigSet,
+				   ctp_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("PortConfigSet API failed :%d\n", ret);
+			bret = -1;
+			goto err_ctp;
+		}
+	}
+	if (flag & DP_METER_ATTACH_BRPORT) {/*BRIDGE port Flag*/
+		if (!subif.flag_bp) {
+			PR_ERR("flag_bp value 0\n");
+			bret = -1;
+			goto err_ctp;
+		}
+		bp_cfg = kzalloc(sizeof(GSW_BRIDGE_portConfig_t), GFP_KERNEL);
+		if (!bp_cfg) {
+			PR_ERR("bp_cfg alloc failed\n");
+			bret = -1;
+			goto err_ctp;
+		}
+		bp_cfg->nBridgePortId = subif.bport;
+		ret = GSW_CORE_API(gsw_handle,
+				   gsw_brdgport_ops.BridgePort_ConfigGet,
+				   bp_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("BridgePort_ConfigGet API failed :%d\n", ret);
+			bret = -1;
+			goto err_bp;
+		}
+		if (meter->dir & DP_DIR_EGRESS) {
+			bp_cfg->eMask =
+				GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_SUB_METER;
+			if (meter->flow == DP_UKNOWN_UNICAST)
+				BP_CFG(bp_cfg,
+				       GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_UC,
+				       meter->meter_id, 1);
+			else if (meter->flow == DP_US_MULTICAST)
+				BP_CFG(bp_cfg,
+				       GSW_BRIDGE_PORT_EGRESS_METER_MULTICAST,
+				       meter->meter_id, 1);
+			else if (meter->flow == DP_US_BROADCAST)
+				BP_CFG(bp_cfg,
+				       GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST,
+				       meter->meter_id, 1);
+		}
+		if (meter->dir & DP_DIR_INGRESS) {
+			bp_cfg->eMask =
+				GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_METER;
+			bp_cfg->bIngressMeteringEnable = 1;
+			bp_cfg->nIngressTrafficMeterId = meter->meter_id;
+		}
+		ret = GSW_CORE_API(gsw_handle,
+				   gsw_brdgport_ops.BridgePort_ConfigSet,
+				   bp_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("BridgePort_ConfigSet API failed :%d\n", ret);
+			bret = -1;
+			goto err_bp;
+		}
+	} else if (flag & DP_METER_ATTACH_BRIDGE) {
+		int fid;
+
+		fid = dp_get_fid_by_brname(dev);
+		if (fid < 0) {
+			PR_ERR("fid less then 0\n");
+			bret = -1;
+			goto err_bp;
+		}
+		br_cfg = kzalloc(sizeof(GSW_BRIDGE_config_t), GFP_KERNEL);
+		if (!br_cfg) {
+			PR_ERR("br_cfg alloc failed\n");
+			bret = -1;
+			goto err_bp;
+		}
+		br_cfg->nBridgeId = fid;
+		ret = GSW_CORE_API(gsw_handle,
+				   gsw_brdg_ops.Bridge_ConfigGet,
+				   br_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("Bridge_ConfigGet API failed :%d\n", ret);
+			bret = -1;
+			goto err_br;
+		}
+		br_cfg->eMask = GSW_BRIDGE_CONFIG_MASK_SUB_METER;
+		if (meter->flow == DP_UKNOWN_UNICAST)
+			BR_CFG(br_cfg,
+			       GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_UC,
+			       meter->meter_id, 1);
+		else if (meter->flow == DP_US_MULTICAST)
+			BR_CFG(br_cfg,
+			       GSW_BRIDGE_PORT_EGRESS_METER_MULTICAST,
+			       meter->meter_id, 1);
+		else if (meter->flow == DP_US_BROADCAST)
+			BR_CFG(br_cfg,
+			       GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST,
+			       meter->meter_id, 1);
+		ret = GSW_CORE_API(gsw_handle, gsw_brdg_ops.Bridge_ConfigSet,
+				   br_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("Bridge_ConfigSet API failed :%d\n", ret);
+			bret = -1;
+			goto err_br;
+		}
+	}
+err_br:
+	kfree(br_cfg);
+err_bp:
+	kfree(bp_cfg);
+err_ctp:
+	kfree(ctp_cfg);
+err_flow:
+	kfree(pce_rule);
+err:
+	return bret;
+}
+
+int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
+		    int flag)
+{
+	struct core_ops *gsw_handle;
+	GSW_BRIDGE_portConfig_t *bp_cfg = NULL;
+	GSW_PCE_rule_t *pce_rule = NULL;
+	GSW_CTP_portConfig_t *ctp_cfg = NULL;
+	GSW_BRIDGE_config_t *br_cfg = NULL;
+	GSW_return_t ret;
+	dp_subif_t subif = {0};
+	int bret = 0;
+
+	if (flag & DP_METER_ATTACH_CTP || flag & DP_METER_ATTACH_BRPORT) {
+		ret = dp_get_netif_subifid(dev, NULL, NULL, NULL, &subif, 0);
+		if (ret < 0) {
+			PR_ERR("dp_get_netif_subifid fail:%s\n", dev->name);
+			return -1;
+		}
+	}
+	gsw_handle = dp_port_prop[subif.inst].ops[GSWIP_L];
+	if (!gsw_handle)
+		return -1;
+
+	if (meter->dir & DP_METER_ATTACH_FLOW) {
+		int pci_rule_id = 0;
+
+		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_KERNEL);
+		if (!pce_rule) {
+			PR_ERR("ctp_cfg alloc failed\n");
+			bret = -1;
+			goto err;
+		}
+		/* pattern setting */
+		pce_rule->pattern.nIndex = pci_rule_id;
+		pce_rule->pattern.bEnable = 0;
+		ret = GSW_CORE_API(gsw_handle, gsw_tflow_ops.TFLOW_PceRuleWrite,
+				   pce_rule);
+		if (ret != GSW_statusOk) {
+			PR_ERR("PceRule Write API failed :%d\n", ret);
+			bret = -1;
+			goto err_flow;
+		}
+	}
+	if (flag & DP_METER_ATTACH_CTP) {
+		struct pmac_port_info *port_info;
+
+		if (subif.flag_pmapper) {
+			PR_ERR("flag_pmapper is set\n");
+			bret = -1;
+			goto err_flow;
+		}
+		ctp_cfg = kzalloc(sizeof(GSW_CTP_portConfig_t), GFP_KERNEL);
+		if (!ctp_cfg) {
+			PR_ERR("ctp_cfg alloc failed\n");
+			bret = -1;
+			goto err_flow;
+		}
+		port_info = get_port_info_via_dp_name(dev);
+		if (!port_info) {
+			PR_ERR(" port_info is NULL\n");
+			bret = -1;
+			goto err_ctp;
+		}
+		ctp_cfg->nLogicalPortId = subif.port_id;
+		ctp_cfg->nSubIfIdGroup = GET_VAP(subif.subif,
+							port_info->vap_offset,
+							port_info->vap_mask);
+		if (meter->dir == DP_DIR_EGRESS)
+			ctp_cfg->nEgressTrafficMeterId =  meter->meter_id;
+		else if (meter->dir == DP_DIR_INGRESS)
+			ctp_cfg->nIngressTrafficMeterId =  meter->meter_id;
+		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigGet,
+				   ctp_cfg);
+		if (ret != GSW_statusOk) {
+			bret = -1;
+			goto err_ctp;
+		}
+		if (meter->dir == DP_DIR_EGRESS) {
+			ctp_cfg->eMask = GSW_CTP_PORT_CONFIG_EGRESS_METER;
+			ctp_cfg->bEgressMeteringEnable = 0;
+		} else if (meter->dir == DP_DIR_INGRESS) {
+			ctp_cfg->eMask = GSW_CTP_PORT_CONFIG_INGRESS_METER;
+			ctp_cfg->bIngressMeteringEnable = 0;
+		}
+		ret = GSW_CORE_API(gsw_handle, gsw_ctp_ops.CTP_PortConfigSet,
+				   ctp_cfg);
+		if (ret != GSW_statusOk) {
+			bret = -1;
+			goto err_ctp;
+		}
+	}
+	if (flag & DP_METER_ATTACH_BRPORT) {
+		if (!subif.flag_bp) {
+			PR_ERR("flag_bp is 0\n");
+			bret = -1;
+			goto err_ctp;
+		}
+		bp_cfg = kzalloc(sizeof(GSW_BRIDGE_portConfig_t), GFP_KERNEL);
+		if (!bp_cfg) {
+			PR_ERR("bp_cfg alloc failed\n");
+			bret = -1;
+			goto err_ctp;
+		}
+		bp_cfg->nBridgePortId = subif.bport;
+		ret = GSW_CORE_API(gsw_handle,
+				   gsw_brdgport_ops.BridgePort_ConfigGet,
+				   bp_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("BridgePort_ConfigGet API failed\n");
+			bret = -1;
+			goto err_bp;
+		}
+		if (meter->dir == DP_DIR_EGRESS) {
+			bp_cfg->eMask =
+				GSW_BRIDGE_PORT_CONFIG_MASK_EGRESS_SUB_METER;
+			if (meter->flow == DP_UKNOWN_UNICAST)
+				BP_CFG(bp_cfg,
+				       GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_UC,
+				       meter->meter_id, 0);
+			else if (meter->flow == DP_US_MULTICAST)
+				BP_CFG(bp_cfg,
+				       GSW_BRIDGE_PORT_EGRESS_METER_MULTICAST,
+				       meter->meter_id, 0);
+			else if (meter->flow == DP_US_BROADCAST)
+				BP_CFG(bp_cfg,
+				       GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST,
+				       meter->meter_id, 0);
+		} else {
+			bp_cfg->eMask =
+				GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_METER;
+			bp_cfg->bIngressMeteringEnable = 0;
+		}
+		ret = GSW_CORE_API(gsw_handle,
+				   gsw_brdgport_ops.BridgePort_ConfigSet,
+				   bp_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("BridgePort_ConfigSet API failed\n");
+			bret = -1;
+			goto err_bp;
+		}
+	}
+	if (flag & DP_METER_ATTACH_BRIDGE) {
+		int fid;
+
+		fid = dp_get_fid_by_brname(dev);
+		if (fid < 0) {
+			PR_ERR("fid less then 0\n");
+			bret = -1;
+			goto err_bp;
+		}
+		br_cfg = kzalloc(sizeof(GSW_BRIDGE_config_t), GFP_KERNEL);
+		if (!br_cfg) {
+			PR_ERR("br_cfg alloc failed\n");
+			bret = -1;
+			goto err_bp;
+		}
+		br_cfg->nBridgeId = fid;
+		ret = GSW_CORE_API(gsw_handle, gsw_brdg_ops.Bridge_ConfigGet,
+				   br_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("Bridge_ConfigGet API failed :%d\n", ret);
+			bret = -1;
+			goto err_br;
+		}
+		br_cfg->eMask = GSW_BRIDGE_CONFIG_MASK_SUB_METER;
+		if (meter->flow == DP_UKNOWN_UNICAST)
+			BR_CFG(br_cfg,
+			       GSW_BRIDGE_PORT_EGRESS_METER_UNKNOWN_UC,
+			       meter->meter_id, 0);
+		else if (meter->flow == DP_US_MULTICAST)
+			BR_CFG(br_cfg,
+			       GSW_BRIDGE_PORT_EGRESS_METER_MULTICAST,
+			       meter->meter_id, 0);
+		else if (meter->flow == DP_US_BROADCAST)
+			BR_CFG(br_cfg,
+			       GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST,
+			       meter->meter_id, 0);
+		ret = GSW_CORE_API(gsw_handle, gsw_brdg_ops.Bridge_ConfigSet,
+				   br_cfg);
+		if (ret != GSW_statusOk) {
+			PR_ERR("Bridge_ConfigSet API failed :%d\n", ret);
+			bret = -1;
+			goto err_br;
+		}
+	}
+err_br:
+	kfree(br_cfg);
+err_bp:
+	kfree(bp_cfg);
+err_ctp:
+	kfree(ctp_cfg);
+err_flow:
+	kfree(pce_rule);
+err:
+	return bret;
+}
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
index 7233da841036..f195cddc3798 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
@@ -1467,6 +1467,9 @@ int register_dp_cap_gswip31(int flag)
 	cap.info.dp_set_gsw_pmapper = dp_set_gsw_pmapper_31;
 	cap.info.dp_get_gsw_pmapper = dp_get_gsw_pmapper_31;
 	cap.info.dp_ctp_tc_map_set = ctp_tc_map_set;
+	cap.info.dp_meter_alloc = dp_meter_alloc_31;
+	cap.info.dp_meter_add = dp_meter_add_31;
+	cap.info.dp_meter_del = dp_meter_del_31;
 #ifdef CONFIG_LTQ_DATAPATH_HAL_GSWIP31_MIB
 	cap.info.dp_get_port_vap_mib = dp_get_port_vap_mib_31;
 	cap.info.dp_clear_netif_mib = dp_clear_netif_mib_31;
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.h b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.h
index d59d80a167ee..e7935ef72c77 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.h
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.h
@@ -164,6 +164,9 @@ int dp_children_get_31(struct dp_node_child *cfg, int flag);
 int dp_free_children_via_parent_31(struct dp_node_alloc *node, int flag);
 int dp_node_reserve(int inst, int ep, struct dp_port_data *data, int flags);
 int dp_qos_level_get_31(struct dp_qos_level *dp, int flag);
+int dp_meter_alloc_31(int *meterid, int flag);
+int dp_meter_add_31(struct net_device *dev, struct dp_meter_cfg *meter, int flag);
+int dp_meter_del_31(struct net_device *dev, struct dp_meter_cfg *meter, int flag);
 
 #if IS_ENABLED(CONFIG_LTQ_DATAPATH_DDR_SIMULATE_GSWIP31)
 GSW_return_t gsw_core_api_ddr_simu31(dp_gsw_cb func, void *ops, void *param);
diff --git a/include/net/datapath_inst.h b/include/net/datapath_inst.h
index d67274f3929f..7833bfd4ea62 100644
--- a/include/net/datapath_inst.h
+++ b/include/net/datapath_inst.h
@@ -109,6 +109,12 @@ struct inst_info {
 	int (*dp_get_gsw_pmapper)(int inst, int bport, int lport,
 				  struct dp_pmapper *mapper, u32 flag);
 	int (*dp_ctp_tc_map_set)(struct dp_tc_cfg *tc, int flag);
+	int (*dp_meter_alloc)(int *meterid, int flag);
+	int (*dp_meter_add)(struct net_device *dev,
+			    struct dp_meter_cfg *meter, int flag);
+	int (*dp_meter_del)(struct net_device *dev,
+			    struct dp_meter_cfg *meter, int flag);
+
 #if IS_ENABLED(CONFIG_LTQ_DATAPATH_SWITCHDEV)
 	int swdev_flag;
 	int (*swdev_alloc_bridge_id)(int inst);
