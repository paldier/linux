From c59b2995a99d5ef76658e9dd9e8404204037573c Mon Sep 17 00:00:00 2001
From: thampan <joby.thampan@intel.com>
Date: Thu, 9 Aug 2018 00:57:11 +0800
Subject: [PATCH] Fixes after testing External timestamp and frequeny
 adjustment with Paragon

---
 .../net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c | 36 ++++++++--------------
 1 file changed, 12 insertions(+), 24 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c
index ff3ac69d0450..e3cb28bba002 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c
@@ -96,21 +96,15 @@ static int xgmac_adj_freq(struct ptp_clock_info *ptp, s32 ppb)
 	struct mac_ops *hw_if = &pdata->ops;
 	u64 adj, diff;
 	u32 addend;
-	int neg_adj = 0;
 
 	pr_debug("Calling adjust_freq: %d\n", ppb);
 
-	if (ppb < 0) {
-		neg_adj = 1;
-		ppb = -ppb;
-	}
-
 	/* Frequency adjustment is feq_delta = ppb / 1.000.000.000
 	 * addend = def_addend / ( 1 - ppb/1.000.000.000)
 	 * So addend in integer arithmetic becomes
 	 * addend = (def_addend * 1.000.000.000) / (1.000.000.000 - ppb)
 	 */
-	adj = (pdata->def_addend * NSEC_TO_SEC);
+	adj = ((u64)pdata->def_addend * NSEC_TO_SEC);
 	diff = (NSEC_TO_SEC - ppb);
 
 	addend = div_u64(adj, diff);
@@ -484,7 +478,7 @@ static void xgmac_get_rx_tstamp(struct mac_prv_data *pdata,
 	skb_copy_bits(skb, skb->len - 8, tmpregval, 8);
 	__pskb_trim(skb, skb->len - ts_hdr_len);
 
-        regval = tmpregval[0];
+	regval = tmpregval[0];
 
 
 	/* The timestamp is recorded in little endian format, and is stored at
@@ -495,7 +489,7 @@ static void xgmac_get_rx_tstamp(struct mac_prv_data *pdata,
 	 */
 	ns = le64_to_cpu(regval);
 
-        printk("ns = %llx\n",ns);
+	printk("ns = %llx\n", ns);
 	shhwtstamp = skb_hwtstamps(skb);
 	memset(shhwtstamp, 0, sizeof(struct skb_shared_hwtstamps));
 	shhwtstamp->hwtstamp = ns_to_ktime(ns);
@@ -608,9 +602,12 @@ static u64 xgmac_get_auxtimestamp(struct mac_prv_data *pdata)
 {
 	u64 nsec;
 
-	nsec = XGMAC_RGRD(pdata, MAC_AUX_SEC);
-	nsec *= NSEC_TO_SEC;
-	nsec += XGMAC_RGRD(pdata, MAC_AUX_NSEC);
+	/* First read nanoseconds and then seconds.
+	 * On reading seconds register the FIFO top
+	 * entry gets removed.
+	 */
+	nsec = XGMAC_RGRD(pdata, MAC_AUX_NSEC);
+	nsec += (u64)XGMAC_RGRD(pdata, MAC_AUX_SEC) * NSEC_TO_SEC;
 
 	return nsec;
 }
@@ -622,17 +619,14 @@ static void xgmac_extts_isr_handler(struct mac_prv_data *pdata,
 #ifdef CONFIG_PTP_1588_CLOCK
 	struct ptp_clock_event event;
 
+	if (val)
+		event.timestamp = xgmac_get_auxtimestamp(pdata);
+
 	if (val & AUX_TRIG_0) {
 		if (pdata->exts0_enabled) {
 			event.type = PTP_CLOCK_EXTTS;
 			event.index = 0;
-			event.timestamp = xgmac_get_auxtimestamp(pdata);
 			ptp_clock_event(pdata->ptp_clock, &event);
-		} else {
-			/* Make sure timestamp fifo is cleared
-			 * if any event happens after the testptp is exited
-			 */
-			xgmac_get_auxtimestamp(pdata);
 		}
 	}
 
@@ -640,13 +634,7 @@ static void xgmac_extts_isr_handler(struct mac_prv_data *pdata,
 		if (pdata->exts1_enabled) {
 			event.type = PTP_CLOCK_EXTTS;
 			event.index = 1;
-			event.timestamp = xgmac_get_auxtimestamp(pdata);
 			ptp_clock_event(pdata->ptp_clock, &event);
-		} else {
-			/* Make sure timestamp fifo is cleared
-			 * if any event happens after the testptp is exited
-			 */
-			xgmac_get_auxtimestamp(pdata);
 		}
 	}
 
