From f00370e6e9b9a76cc269f7a100be905421b26180 Mon Sep 17 00:00:00 2001
From: Gu Chao <gux.chao@intel.com>
Date: Thu, 18 Jul 2019 16:36:47 +0800
Subject: [PATCH] DRVLIB_SW-2625: Fix DP module coding style with code
 modification

---
 drivers/net/datapath/dpm/datapath_api.c            |  90 +++++++------
 drivers/net/datapath/dpm/datapath_swdev.c          | 140 +++++++++++----------
 drivers/net/datapath/dpm/datapath_tx.c             |   2 +-
 drivers/net/datapath/dpm/gswip30/datapath_proc.c   |  19 ++-
 drivers/net/datapath/dpm/gswip30/datapath_rx.c     |  19 ++-
 drivers/net/datapath/dpm/gswip30/datapath_tx.c     |  18 +--
 drivers/net/datapath/dpm/gswip31/datapath_gswip.c  |  19 +--
 drivers/net/datapath/dpm/gswip31/datapath_misc.c   |   8 +-
 .../net/datapath/dpm/gswip31/datapath_ppv4_api.c   |   7 +-
 drivers/net/datapath/dpm/gswip31/datapath_rx.c     |  15 +--
 .../net/datapath/dpm/gswip31/datapath_switchdev.c  |  20 +--
 drivers/net/datapath/dpm/gswip31/datapath_tx.c     |  16 +--
 drivers/net/datapath/dpm/gswip32/datapath_gswip.c  |  26 ++--
 drivers/net/datapath/dpm/gswip32/datapath_misc.c   | 120 ++++++++----------
 drivers/net/datapath/dpm/gswip32/datapath_ppv4.c   |   1 -
 .../net/datapath/dpm/gswip32/datapath_ppv4_api.c   |   2 +-
 .../datapath/dpm/gswip32/datapath_ppv4_session.c   |   5 +-
 drivers/net/datapath/dpm/gswip32/datapath_rx.c     |   8 +-
 .../net/datapath/dpm/gswip32/datapath_switchdev.c  |  23 ++--
 19 files changed, 276 insertions(+), 282 deletions(-)

diff --git a/drivers/net/datapath/dpm/datapath_api.c b/drivers/net/datapath/dpm/datapath_api.c
index 23c548377266..52817b5340a2 100644
--- a/drivers/net/datapath/dpm/datapath_api.c
+++ b/drivers/net/datapath/dpm/datapath_api.c
@@ -320,12 +320,10 @@ void dp_parser_info_refresh(u32 cpu, u32 mpe1, u32 mpe2,
 	pinfo[3].v = mpe3;
 
 	for (i = 0; i < ARRAY_SIZE(pinfo); i++) {
-		if (verify &&
-		    (pinfo[i].size != parser_size(pinfo[i].v)))
-			PR_ERR
-			 ("Lcal parser pinfo[%d](%d) != register cfg(%d)??\n",
-			 i, pinfo[i].size,
-			 parser_size(pinfo[i].v));
+		if (verify && (pinfo[i].size != parser_size(pinfo[i].v)))
+			PR_ERR("%s[%d](%d) != %s(%d)??\n",
+			       "Lcal parser pinfo", i, pinfo[i].size,
+			       "register cfg", parser_size(pinfo[i].v));
 
 		/*force to update */
 		pinfo[i].size = parser_size(pinfo[i].v);
@@ -343,14 +341,10 @@ void print_parser_status(struct seq_file *s)
 	if (!s)
 		return;
 
-	seq_printf(s, "REG.cpu  value=%u size=%u\n", pinfo[0].v,
-		   pinfo[0].size);
-	seq_printf(s, "REG.MPE1 value=%u size=%u\n", pinfo[1].v,
-		   pinfo[1].size);
-	seq_printf(s, "REG.MPE2 value=%u size=%u\n", pinfo[2].v,
-		   pinfo[2].size);
-	seq_printf(s, "REG.MPE3 value=%u size=%u\n", pinfo[3].v,
-		   pinfo[3].size);
+	seq_printf(s, "REG.cpu  value=%u size=%u\n", pinfo[0].v, pinfo[0].size);
+	seq_printf(s, "REG.MPE1 value=%u size=%u\n", pinfo[1].v, pinfo[1].size);
+	seq_printf(s, "REG.MPE2 value=%u size=%u\n", pinfo[2].v, pinfo[2].size);
+	seq_printf(s, "REG.MPE3 value=%u size=%u\n", pinfo[3].v, pinfo[3].size);
 }
 
 /*note: dev can be NULL */
@@ -395,9 +389,8 @@ static int32_t dp_alloc_port_private(int inst,
 
 	if (flags & DP_F_DEREGISTER) {	/*De-register */
 		if (port->status != PORT_ALLOCATED) {
-			PR_ERR
-			    ("No Deallocate for module %s w/o deregistered\n",
-			     owner->name);
+			PR_ERR("No Deallocate for module %s w/o deregistered\n",
+			       owner->name);
 			return DP_FAILURE;
 		}
 		cbm_data.deq_port = port->deq_port_base;
@@ -422,9 +415,8 @@ static int32_t dp_alloc_port_private(int inst,
 	}
 	if (cbm_dp_port_alloc(owner, dev, dev_port, port_id,
 			      &cbm_data, flags)) {
-		PR_ERR
-		    ("cbm_dp_port_alloc fail for %s/dev_port %d: %d\n",
-		     owner->name, dev_port, port_id);
+		PR_ERR("cbm_dp_port_alloc fail for %s/dev_port %d: %d\n",
+		       owner->name, dev_port, port_id);
 		return DP_FAILURE;
 	} else if (!(cbm_data.flags & CBM_PORT_DP_SET) &&
 		   !(cbm_data.flags & CBM_PORT_DQ_SET)) {
@@ -772,8 +764,7 @@ int32_t dp_deregister_subif_private(int inst, struct module *owner,
 	sif->flags = 0;
 	sif->netif = NULL;
 	port_info->num_subif--;
-	if (dp_port_prop[inst].info.subif_platform_set(inst,
-						       port_id, i,
+	if (dp_port_prop[inst].info.subif_platform_set(inst, port_id, i,
 						       &platfrm_data, flags)) {
 		PR_ERR("subif_platform_set fail\n");
 		/*return res;*/
@@ -1224,9 +1215,8 @@ int32_t dp_get_netif_subifid(struct net_device *netif, struct sk_buff *skb,
 	rcu_read_unlock_bh();
 	if (subifid_fn_t) {
 		/*subif->subif will be set by callback api itself */
-		res =
-		    subifid_fn_t(netif, skb, subif_data, dst_mac, subif,
-				 flags);
+		res = subifid_fn_t(netif, skb, subif_data, dst_mac, subif,
+				   flags);
 		if (res != 0)
 			PR_ERR("get_netif_subifid callback function failed\n");
 	} else {
@@ -1507,17 +1497,25 @@ static int dp_register_dc(int inst, uint32_t port_id,
 	umt_param.daddr = (u32)data->umt->umt_msg_paddr;
 
 	if (dp_umt_request(&umt_param, 0)) {
-		PR_ERR("UMT request Fail!! DMA ID %x CQM_PID %d MSG_MODE %d "
-		       "PERIOD %d SW_MSG %d DADDR 0x%08x\n", umt_param.dma_id,
-		       umt_param.cqm_dq_pid, umt_param.msg_mode,
-		       umt_param.period, umt_param.sw_msg, umt_param.daddr);
+		PR_ERR("%s %s %x %s %d %s %d %s %d %s %d %s 0x%08x\n",
+		       "UMT request Fail!!",
+		       "DMA_ID", umt_param.dma_id,
+		       "CQM_PID", umt_param.cqm_dq_pid,
+		       "MSG_MODE", umt_param.msg_mode,
+		       "PERIOD", umt_param.period,
+		       "SW_MSG", umt_param.sw_msg,
+		       "DADDR", umt_param.daddr);
 		return DP_FAILURE;
 	}
 	if (dp_umt_set(&umt_param, 0)) {
-		PR_ERR("UMT port set fail !! DMA ID %x CQM_PID %d MSG_MODE %d "
-		       "PERIOD %d SW_MSG %d DADDR 0x%08x\n", umt_param.dma_id,
-		       umt_param.cqm_dq_pid, umt_param.msg_mode,
-		       umt_param.period, umt_param.sw_msg, umt_param.daddr);
+		PR_ERR("%s %s %x %s %d %s %d %s %d %s %d %s 0x%08x\n",
+		       "UMT port set fail!!",
+		       "DMA_ID", umt_param.dma_id,
+		       "CQM_PID", umt_param.cqm_dq_pid,
+		       "MSG_MODE", umt_param.msg_mode,
+		       "PERIOD", umt_param.period,
+		       "SW_MSG", umt_param.sw_msg,
+		       "DADDR", umt_param.daddr);
 		return DP_FAILURE;
 	}
 
@@ -1616,8 +1614,10 @@ int32_t dp_check_if_netif_fastpath_fn(struct net_device *netif,
 				      dp_subif_t *subif, char *ifname,
 				      uint32_t flags)
 {
-	int res = 1;
 	dp_subif_t tmp_subif = { 0 };
+	struct pmac_port_info *p_info;
+	int max_dp_ports;
+	int dp_flags;
 
 	DP_LIB_LOCK(&dp_lock);
 	if (unlikely(!dp_init_ok)) {
@@ -1632,17 +1632,16 @@ int32_t dp_check_if_netif_fastpath_fn(struct net_device *netif,
 	} else if (ifname) {
 		dp_get_port_subitf_via_ifname_private(ifname, &tmp_subif);
 	}
-
-	if (tmp_subif.port_id <= 0 && tmp_subif.port_id >=
-	    dp_port_prop[tmp_subif.inst].info.cap.max_num_dp_ports)
-		res = 0;
-	else if (!(get_dp_port_info(tmp_subif.inst, tmp_subif.port_id)->alloc_flags &
-		 (DP_F_FAST_DSL || DP_F_FAST_ETH_LAN ||
-		 DP_F_FAST_ETH_WAN || DP_F_FAST_WLAN)))
-		res = 0;
-
+	max_dp_ports = dp_port_prop[tmp_subif.inst].info.cap.max_num_dp_ports;
+	if (tmp_subif.port_id <= 0 || tmp_subif.port_id >= max_dp_ports)
+		return 0;
+	p_info = get_dp_port_info(tmp_subif.inst, tmp_subif.port_id);
+	dp_flags = DP_F_FAST_DSL || DP_F_FAST_ETH_LAN ||
+		   DP_F_FAST_ETH_WAN || DP_F_FAST_WLAN;
+	if (!(p_info->alloc_flags & dp_flags))
+		return 0;
 	DP_LIB_UNLOCK(&dp_lock);
-	return res;
+	return 1;
 }
 EXPORT_SYMBOL(dp_check_if_netif_fastpath_fn);
 
@@ -1651,8 +1650,7 @@ struct module *dp_get_module_owner(int ep)
 	int inst = 0; /*here hardcode for PPA only */
 
 	if (unlikely(!dp_init_ok)) {
-		PR_ERR
-		    ("dp_get_module_owner failed for datapath not init yet\n");
+		PR_ERR("dp_get_module_owner failed for dp not init yet\n");
 		return NULL;
 	}
 
diff --git a/drivers/net/datapath/dpm/datapath_swdev.c b/drivers/net/datapath/dpm/datapath_swdev.c
index 605ce0cde625..6b48502917e7 100644
--- a/drivers/net/datapath/dpm/datapath_swdev.c
+++ b/drivers/net/datapath/dpm/datapath_swdev.c
@@ -242,6 +242,8 @@ static int dp_swdev_clr_gswip_cfg(struct bridge_id_entry_item *br_item,
 				  u8 *addr)
 {
 	struct br_info *br_info;
+	struct pmac_port_info *p_info;
+	struct inst_info *i_info;
 	int ret;
 
 	if (br_item->flags == BRIDGE_NO_ACTION) {
@@ -252,26 +254,21 @@ static int dp_swdev_clr_gswip_cfg(struct bridge_id_entry_item *br_item,
 	br_info = dp_swdev_bridge_entry_lookup(br_item->br_device_name);
 	if (!br_info)
 		return 0;
-	if (dp_swdev_del_bport_from_list(br_info, br_item->portid)) {
-		if (get_dp_port_info(br_item->inst,
-				     br_item->dp_port)->swdev_en == 1) {
-			ret = dp_port_prop[br_item->inst].info.swdev_bridge_port_cfg_reset(
-							br_info, br_item->inst,
-							br_item->portid);
-			if (ret == DEL_BRENTRY) {
-				dp_port_prop[br_item->inst].info.swdev_free_brcfg(
-						br_item->inst, br_item->fid);
-				dp_swdev_remove_bridge_id_entry(br_info);
-				DP_DEBUG(DP_DBG_FLAG_SWDEV,
-					 "rem bport(%d),bridge(%s)\n",
-					 br_item->portid,
-					 br_item->br_device_name);
-			}
-			DP_DEBUG(DP_DBG_FLAG_SWDEV, "rem bport(%d)\n",
-				 br_item->portid);
-			return 0;
-		}
+	if (!dp_swdev_del_bport_from_list(br_info, br_item->portid))
+		return 0;
+	p_info = get_dp_port_info(br_item->inst, br_item->dp_port);
+	if (p_info->swdev_en != 1)
+		return 0;
+	i_info = &dp_port_prop[br_item->inst].info;
+	ret = i_info->swdev_bridge_port_cfg_reset(br_info, br_item->inst,
+						  br_item->portid);
+	if (ret == DEL_BRENTRY) {
+		i_info->swdev_free_brcfg(br_item->inst, br_item->fid);
+		dp_swdev_remove_bridge_id_entry(br_info);
+		DP_DEBUG(DP_DBG_FLAG_SWDEV, "rem bport(%d),bridge(%s)\n",
+			 br_item->portid, br_item->br_device_name);
 	}
+	DP_DEBUG(DP_DBG_FLAG_SWDEV, "rem bport(%d)\n", br_item->portid);
 	return 0;
 }
 
@@ -350,19 +347,25 @@ static int dp_swdev_filter_vlan(struct net_device *dev,
 static int dp_swdev_cfg_gswip(struct bridge_id_entry_item *br_item, u8 *addr)
 {
 	struct br_info *br_info;
+	struct pmac_port_info *p_info;
+	struct inst_info *i_info;
+	int ret;
 
+	p_info = get_dp_port_info(br_item->inst, br_item->dp_port);
+	i_info = &dp_port_prop[br_item->inst].info;
 	DP_DEBUG(DP_DBG_FLAG_SWDEV, "britem flags:%x\n", br_item->flags);
+
 	if (br_item->flags & ADD_BRENTRY) {
-		if (get_dp_port_info(br_item->inst,
-				     br_item->dp_port)->swdev_en == 0) {
+		if (p_info->swdev_en == 0) {
 			DP_DEBUG(DP_DBG_FLAG_SWDEV, "swdev disable for bp %d\n",
 				 br_item->portid);
 			return 0;
 		}
 		DP_DEBUG(DP_DBG_FLAG_SWDEV, "Add br entry %s\n",
 			 br_item->br_device_name);
-		if ((dp_port_prop[br_item->inst].info.swdev_bridge_cfg_set(
-				br_item->inst, br_item->fid) == 0)) {
+
+		ret = i_info->swdev_bridge_cfg_set(br_item->inst, br_item->fid);
+		if (ret == 0) {
 			br_info = kmalloc(sizeof(*br_info), GFP_KERNEL);
 			if (!br_info) {
 				PR_ERR
@@ -387,11 +390,11 @@ static int dp_swdev_cfg_gswip(struct bridge_id_entry_item *br_item, u8 *addr)
 			       br_item->br_device_name);
 			INIT_LIST_HEAD(&br_info->bp_list);
 			dp_swdev_insert_bridge_id_entry(br_info);
-			dp_swdev_add_bport_to_list(br_info,
-						   br_item->portid);
-			dp_port_prop[br_item->inst].info.swdev_bridge_port_cfg_set(
-							br_info, br_item->inst,
-							br_item->portid);
+			dp_swdev_add_bport_to_list(br_info, br_item->portid);
+
+			i_info->swdev_bridge_port_cfg_set(br_info,
+							  br_item->inst,
+							  br_item->portid);
 			br_item->flags &= ~ADD_BRENTRY;
 			DP_DEBUG(DP_DBG_FLAG_SWDEV,
 				 "added bport(%d),bridge(%s)\n",
@@ -407,11 +410,10 @@ static int dp_swdev_cfg_gswip(struct bridge_id_entry_item *br_item, u8 *addr)
 		if (br_item->flags & LOGIC_DEV_REGISTER)
 			br_info->flag = LOGIC_DEV_REGISTER;
 		dp_swdev_add_bport_to_list(br_info, br_item->portid);
-		if (get_dp_port_info(br_item->inst,
-				     br_item->dp_port)->swdev_en == 1) {
-			dp_port_prop[br_item->inst].info.swdev_bridge_port_cfg_set(
-							br_info, br_item->inst,
-							br_item->portid);
+		if (p_info->swdev_en == 1) {
+			i_info->swdev_bridge_port_cfg_set(br_info,
+							  br_item->inst,
+							  br_item->portid);
 		}
 		DP_DEBUG(DP_DBG_FLAG_SWDEV, "added bport(%d)\n",
 			 br_item->portid);
@@ -427,6 +429,8 @@ static int dp_swdev_add_if(struct net_device *dev,
 			   struct net_device *br_dev)
 {
 	struct br_info *br_info;
+	struct pmac_port_info *p_info;
+	struct inst_info *i_info;
 	struct bridge_id_entry_item *br_item;
 	int br_id = 0;
 	struct net_device *base;
@@ -434,11 +438,13 @@ static int dp_swdev_add_if(struct net_device *dev,
 	u32 flag = 0;
 	int port, inst;
 	u8 *addr = (u8 *)dev->dev_addr;
+	int32_t res;
 
 	/* SWITCHDEV_TRANS_PREPARE phase */
 	if (switchdev_trans_ph_prepare(trans)) {
 		/*Get current BPORT ID,instance from DP*/
-		if (dp_get_netif_subifid(dev, NULL, NULL, NULL, &subif, 0)) {
+		res = dp_get_netif_subifid(dev, NULL, NULL, NULL, &subif, 0);
+		if (res) {
 			DP_DEBUG(DP_DBG_FLAG_SWDEV,
 				 "get subifid failed for %s, chk if vlan dev\n",
 				 dev->name);
@@ -447,37 +453,36 @@ static int dp_swdev_add_if(struct net_device *dev,
 			 *VLAN interface
 			 */
 			/*Check if dev is a VLAN device */
-			if (is_vlan_dev(dev)) {
-				base = get_base_dev(dev, -1);
-				DP_DEBUG(DP_DBG_FLAG_SWDEV,
-					 "base dev name:%s\n",
-					 base ? base->name : "NULL");
-				if (!base)
-					base = dev;
-				if (dp_get_netif_subifid(base, NULL, NULL,
-							 NULL, &subif, 0)) {
-					PR_ERR("dp_get_netif_subifid fail:%s\n",
-					       base->name);
-					return -EOPNOTSUPP;
-				}
-				port = subif.port_id;
-				inst = subif.inst;
-				subif.subif = -1;
-				if (dp_register_subif(
-					get_dp_port_info(inst, port)->owner,
-					dev, dev->name, &subif,
-					DP_F_SUBIF_LOGICAL)) {
-					PR_ERR("dp_register_subif fail: %s\n",
-					       dev->name);
-					return -EOPNOTSUPP;
-				}
-				flag = LOGIC_DEV_REGISTER;
-				DP_DEBUG(DP_DBG_FLAG_SWDEV,
-					 "registered subif,bp=%d port=%d\n",
-					 subif.bport, subif.port_id);
-			} else {
+			if (!is_vlan_dev(dev))
+				return -EOPNOTSUPP;
+
+			base = get_base_dev(dev, -1);
+			DP_DEBUG(DP_DBG_FLAG_SWDEV, "base dev name:%s\n",
+				 base ? base->name : "NULL");
+			if (!base)
+				base = dev;
+			res = dp_get_netif_subifid(base, NULL, NULL, NULL,
+						   &subif, 0);
+			if (res) {
+				PR_ERR("dp_get_netif_subifid fail:%s\n",
+				       base->name);
 				return -EOPNOTSUPP;
 			}
+			port = subif.port_id;
+			inst = subif.inst;
+			subif.subif = -1;
+			if (dp_register_subif(
+				get_dp_port_info(inst, port)->owner,
+				dev, dev->name, &subif,
+				DP_F_SUBIF_LOGICAL)) {
+				PR_ERR("dp_register_subif fail: %s\n",
+				       dev->name);
+				return -EOPNOTSUPP;
+			}
+			flag = LOGIC_DEV_REGISTER;
+			DP_DEBUG(DP_DBG_FLAG_SWDEV,
+				 "registered subif,bp=%d port=%d\n",
+				 subif.bport, subif.port_id);
 		}
 		br_item = kmalloc(sizeof(*br_item), GFP_KERNEL);
 		if (!br_item)
@@ -489,6 +494,8 @@ static int dp_swdev_add_if(struct net_device *dev,
 		br_item->dp_port = subif.port_id;
 		swdev_lock();
 		br_info = dp_swdev_bridge_entry_lookup(br_dev->name);
+		p_info = get_dp_port_info(br_item->inst, br_item->dp_port);
+		i_info = &dp_port_prop[br_item->inst].info;
 		if (br_info) {
 			strcpy(br_item->br_device_name,
 			       br_info->br_device_name);
@@ -496,10 +503,9 @@ static int dp_swdev_add_if(struct net_device *dev,
 			br_item->flags = flag;
 		} else {
 			br_item->flags = ADD_BRENTRY | flag;
-			if (get_dp_port_info(br_item->inst,
-					     br_item->dp_port)->swdev_en == 1) {
-				br_id = dp_port_prop[br_item->inst].info.swdev_alloc_bridge_id(
-								br_item->inst);
+			if (p_info->swdev_en == 1) {
+				br_id = i_info->swdev_alloc_bridge_id(
+							br_item->inst);
 				if (br_id) {
 					/* Store bridge information
 					 * to add in the table.
diff --git a/drivers/net/datapath/dpm/datapath_tx.c b/drivers/net/datapath/dpm/datapath_tx.c
index 86ea8e1b5c28..c5a488216ae7 100644
--- a/drivers/net/datapath/dpm/datapath_tx.c
+++ b/drivers/net/datapath/dpm/datapath_tx.c
@@ -88,7 +88,7 @@ void dp_tx_dbg(char *title, struct sk_buff *skb, s32 ep, s32 len, u32 flags,
 	else
 		DP_DEBUG(DP_DBG_FLAG_DUMP_TX_SUM,
 			 "ip start=0x%lx(%d), transport=0x%lx(%d)\n",
-			 (unsigned long) skb_network_header(skb),
+			 (unsigned long)skb_network_header(skb),
 			 (int)(skb_network_header(skb) - skb->data),
 			 (unsigned long)skb_transport_header(skb),
 			 (int)(skb_transport_header(skb) -
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_proc.c b/drivers/net/datapath/dpm/gswip30/datapath_proc.c
index 9771d4083a29..e2256aee7b49 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_proc.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_proc.c
@@ -679,6 +679,7 @@ static int proc_gsw_port_rmon_dump(struct seq_file *s, int pos)
 	int i;
 	int ret = 0;
 	struct core_ops *gsw_handle;
+	struct rmon_ops *rmon;
 	char flag_buf[20];
 
 	if (!capable(CAP_NET_ADMIN))
@@ -689,12 +690,11 @@ static int proc_gsw_port_rmon_dump(struct seq_file *s, int pos)
 
 		/*read gswip-r rmon counter */
 		gsw_handle = dp_port_prop[0].ops[GSWIP_R];
-
+		rmon = &gsw_handle->gsw_rmon_ops;
 		for (i = 0; i < ARRAY_SIZE(gsw_r_rmon_mib); i++) {
 			gsw_r_rmon_mib[i].nPortId = i;
-			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_handle->gsw_rmon_ops.RMON_Port_Get,
-				gsw_handle, &gsw_r_rmon_mib[i]);
+			ret = gsw_core_api((dp_gsw_cb)rmon->RMON_Port_Get,
+					   gsw_handle, &gsw_r_rmon_mib[i]);
 
 			if (ret != GSW_statusOk) {
 				PR_ERR("RMON_PORT_GET fail for Port %d\n", i);
@@ -704,9 +704,8 @@ static int proc_gsw_port_rmon_dump(struct seq_file *s, int pos)
 
 		/*read pmac rmon redirect mib */
 		memset(&gswr_rmon_redirect, 0, sizeof(gswr_rmon_redirect));
-		ret = gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_rmon_ops.RMON_Redirect_Get,
-			gsw_handle, &gswr_rmon_redirect);
+		ret = gsw_core_api((dp_gsw_cb)rmon->RMON_Redirect_Get,
+				   gsw_handle, &gswr_rmon_redirect);
 
 		if (ret != GSW_statusOk) {
 			PR_ERR("GSW_RMON_REDIRECT_GET fail for Port %d\n", i);
@@ -715,11 +714,11 @@ static int proc_gsw_port_rmon_dump(struct seq_file *s, int pos)
 
 		/*read gswip-l rmon counter */
 		gsw_handle = dp_port_prop[0].ops[GSWIP_L];
+		rmon = &gsw_handle->gsw_rmon_ops;
 		for (i = 0; i < ARRAY_SIZE(gsw_l_rmon_mib); i++) {
 			gsw_l_rmon_mib[i].nPortId = i;
-			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_handle->gsw_rmon_ops.RMON_Port_Get,
-				gsw_handle, &gsw_l_rmon_mib[i]);
+			ret = gsw_core_api((dp_gsw_cb)rmon->RMON_Port_Get,
+					   gsw_handle, &gsw_l_rmon_mib[i]);
 			if (ret != GSW_statusOk) {
 				PR_ERR("RMON_PORT_GET fail for Port %d\n", i);
 				return -1;
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_rx.c b/drivers/net/datapath/dpm/gswip30/datapath_rx.c
index eec5e3afdfad..3cb6a46f2de7 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_rx.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_rx.c
@@ -23,20 +23,17 @@ static void rx_dbg(u32 f, struct sk_buff *skb, struct dma_rx_desc_0 *desc0,
 		   struct pmac_rx_hdr *pmac, int paser_exist)
 {
 	int inst = 0;
+	int data_len = skb->len > dp_print_len ? skb->len : dp_print_len;
 
 	DP_DEBUG(DP_DBG_FLAG_DUMP_RX,
 		 "\ndp_rx:skb->data=%p Loc=%x offset=%d skb->len=%d\n",
 		 skb->data, desc2->field.data_ptr,
 		 desc3->field.byte_offset, skb->len);
 	if ((f) & DP_DBG_FLAG_DUMP_RX_DATA)
-		dp_dump_raw_data(skb->data,
-				(skb->len >
-				(dp_print_len)) ? skb->len : (dp_print_len),
-				"Original Data");
-	DP_DEBUG(DP_DBG_FLAG_DUMP_RX, "parse hdr size = %d\n",
-		 paser_exist);
+		dp_dump_raw_data(skb->data, data_len, "Original Data");
+	DP_DEBUG(DP_DBG_FLAG_DUMP_RX, "parse hdr size = %d\n", paser_exist);
 	if ((f) & DP_DBG_FLAG_DUMP_RX_DESCRIPTOR)
-		dp_port_prop[inst].info.dump_rx_dma_desc(desc0, (desc1),
+		dp_port_prop[inst].info.dump_rx_dma_desc(desc0, desc1,
 							 desc2, desc3);
 	if (paser_exist && (dp_dbg_flag & DP_DBG_FLAG_DUMP_RX_PASER))
 		dump_parser_flag(parser);
@@ -73,9 +70,8 @@ static void rx_dbg_zero_port(struct sk_buff *skb, struct dma_rx_desc_0 *desc0,
 	if (pmac)
 		dp_port_prop[inst].info.dump_rx_pmac(pmac);
 	dp_dump_raw_data((char *)(skb->data),
-			(skb->len >
-			 dp_print_len) ? skb->len : dp_print_len,
-			"Recv Data");
+			 skb->len > dp_print_len ? skb->len : dp_print_len,
+			 "Recv Data");
 }
 
 /* clone skb to send one copy to lct dev for multicast/broadcast
@@ -244,8 +240,7 @@ int32_t dp_rx_30(struct sk_buff *skb, u32 flags)
 			desc_1->field.dec = 1;
 			desc_1->field.enc = 1;
 		}
-		if (!dev &&
-		    ((dp_port->alloc_flags & DP_F_FAST_DSL) == 0)) {
+		if (!dev && ((dp_port->alloc_flags & DP_F_FAST_DSL) == 0)) {
 			UP_STATS(mib->rx_fn_dropped);
 			goto RX_DROP;
 		}
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_tx.c b/drivers/net/datapath/dpm/gswip30/datapath_tx.c
index aa3c734e70ef..3b820a202edc 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_tx.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_tx.c
@@ -27,6 +27,8 @@ void dp_xmit_dbg(
 	int gso,
 	int checksum)
 {
+	int data_len;
+
 #ifdef DP_SKB_HACK
 	DP_DEBUG(DP_DBG_FLAG_DUMP_TX,
 		 "%s: dp_xmit:skb->data/len=0x%p/%d data_ptr=%x from port=%d and subitf=%d\n",
@@ -35,18 +37,10 @@ void dp_xmit_dbg(
 		 ep, rx_subif->subif);
 #endif
 	if (dp_dbg_flag & DP_DBG_FLAG_DUMP_TX_DATA) {
-		if (pmac) {
+		data_len = skb->len > dp_print_len ? skb->len : dp_print_len;
+		if (pmac)
 			dp_dump_raw_data((char *)pmac, PMAC_SIZE, "Tx Data");
-			dp_dump_raw_data(skb->data,
-					(skb->len > dp_print_len) ?
-					skb->len :
-					dp_print_len,
-					"Tx Data");
-		} else
-			dp_dump_raw_data(skb->data,
-					(skb->len > dp_print_len) ?
-					skb->len : dp_print_len,
-					"Tx Data");
+		dp_dump_raw_data(skb->data, data_len, "Tx Data");
 	}
 	DP_DEBUG(DP_DBG_FLAG_DUMP_TX_SUM,
 		 "ip_summed=%s(%d) encapsulation=%s\n",
@@ -241,7 +235,7 @@ int32_t dp_xmit_30(struct net_device *rx_if, dp_subif_t *rx_subif,
 		if (dp_info->f_ptp)
 #else
 		if (dp_info->f_ptp &&
-			(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP))
+		    (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP))
 #endif
 		{
 			ops = dp_port_prop[inst].mac_ops[dp_info->port_id];
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
index e006eeeeb860..a09f9ece2102 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
@@ -55,7 +55,8 @@ static struct ctp_assign ctp_assign_info[] = {
 	{DP_F_FAST_ETH_LAN, GSW_LOGICAL_PORT_8BIT_WLAN, 4, 4, 8, 0xF,
 		CQE_LU_MODE2, 1},
 	{DP_F_VUNI, GSW_LOGICAL_PORT_8BIT_WLAN, 2, 2, 8, 0xF, CQE_LU_MODE2, 1},
-	{DP_F_FAST_WLAN, GSW_LOGICAL_PORT_8BIT_WLAN, 16, 16, 8, 0xF, CQE_LU_MODE2, 1},
+	{DP_F_FAST_WLAN, GSW_LOGICAL_PORT_8BIT_WLAN, 16, 16, 8, 0xF,
+		CQE_LU_MODE2, 1},
 	{DP_F_FAST_DSL, GSW_LOGICAL_PORT_8BIT_WLAN, 1, 16, 8, 0xF,
 		CQE_LU_MODE0, 0},
 	{DP_F_FAST_WLAN_EXT, GSW_LOGICAL_PORT_9BIT_WLAN, 8, 8, 9, 0x7,
@@ -514,10 +515,12 @@ struct gsw_itf *ctp_port_assign(int inst, u8 ep, int bp_default,
 	int i, alloc_flag;
 	u16 num;
 	struct core_ops *gsw_handle;
+	struct ctp_ops *gsw_ctp;
 	struct pmac_port_info *port_info = get_dp_port_info(inst, ep);
 
 	memset(&ctp_assign, 0, sizeof(ctp_assign));
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
+	gsw_ctp = &gsw_handle->gsw_ctp_ops;
 	alloc_flag = port_info->alloc_flags;
 
 	if (flags & DP_F_DEREGISTER) {
@@ -527,7 +530,7 @@ struct gsw_itf *ctp_port_assign(int inst, u8 ep, int bp_default,
 		ctp_assign.nFirstCtpPortId = itf_assign[ep].start;
 		ctp_assign.nNumberOfCtpPort = itf_assign[ep].n;
 		if (gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_ctp_ops.CTP_PortAssignmentFree,
+			(dp_gsw_cb)gsw_ctp->CTP_PortAssignmentFree,
 			gsw_handle,
 			&ctp_assign) != 0) {
 			PR_ERR("Failed to allc CTP for ep=%d blk=%d mode=%d\n",
@@ -554,7 +557,7 @@ struct gsw_itf *ctp_port_assign(int inst, u8 ep, int bp_default,
 	ctp_assign.nFirstCtpPortId = 0;
 	ctp_assign.nNumberOfCtpPort = num;
 	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_ctp_ops.CTP_PortAssignmentAlloc,
+		(dp_gsw_cb)gsw_ctp->CTP_PortAssignmentAlloc,
 		gsw_handle,
 		&ctp_assign) != 0) {
 		PR_ERR("Failed CTP Assignment for ep=%d blk size=%d mode=%s\n",
@@ -695,8 +698,10 @@ int free_bridge_port(int inst, int bp)
 	int i, j;
 	GSW_return_t ret;
 	struct core_ops *gsw_handle;
+	struct brdgport_ops *gsw_bp;
 
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	if (bp == CPU_BP)
 		return 0;
 
@@ -709,7 +714,7 @@ int free_bridge_port(int inst, int bp)
 	tmp->nBridgePortId = bp;
 	tmp->eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
+		(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
 		gsw_handle, tmp);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_GET: %d\n", bp);
@@ -726,7 +731,7 @@ int free_bridge_port(int inst, int bp)
 				GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 			tmp2->nBridgePortId = i * 16 + j;
 			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
+				(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
 				gsw_handle, tmp2);
 			if (ret != GSW_statusOk) {
 				PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_GET\n");
@@ -734,7 +739,7 @@ int free_bridge_port(int inst, int bp)
 			}
 			UNSET_BP_MAP(tmp2->nBridgePortMap, bp);
 			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigSet,
+				(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
 				gsw_handle, tmp2);
 			if (ret != GSW_statusOk) {
 				PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_SET\n");
@@ -748,7 +753,7 @@ int free_bridge_port(int inst, int bp)
 	tmp->nBridgePortId = bp;
 	tmp->eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_Free,
+		(dp_gsw_cb)gsw_bp->BridgePort_Free,
 		gsw_handle, tmp);
 	if (ret != GSW_statusOk)
 		PR_ERR("Failed to GSW_BRIDGE_PORT_FREE:%d\n", bp);
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_misc.c b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
index 5b5be341f47b..cdbfcb8cb814 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
@@ -1103,7 +1103,7 @@ int dp_platform_queue_set(int inst, u32 flag)
 		DP_DEBUG(DP_DBG_FLAG_QOS, "Store CPU ring info\n");
 		DP_DEBUG(DP_DBG_FLAG_QOS, "  ring_address[%d]=0x%p\n",
 			 q_port.cqe_deq,
-			 (void *)dp_deq_port_tbl[inst][q_port.cqe_deq].txpush_addr);
+			 dp_deq_port_tbl[inst][q_port.cqe_deq].txpush_addr);
 		DP_DEBUG(DP_DBG_FLAG_QOS, "  ring_address_push[%d]=0x%px\n",
 			 q_port.cqe_deq,
 			 dp_deq_port_tbl[inst][q_port.cqe_deq].txpush_addr_qos);
@@ -1164,6 +1164,7 @@ static int dp_platform_set(int inst, u32 flag)
 {
 	GSW_QoS_portRemarkingCfg_t port_remark;
 	struct core_ops *gsw_handle;
+	struct qos_ops *gsw_qos;
 	struct hal_priv *priv;
 
 	/* For initialize */
@@ -1180,6 +1181,7 @@ static int dp_platform_set(int inst, u32 flag)
 		priv = (struct hal_priv *)dp_port_prop[inst].priv_hal;
 		priv->ppv4_drop_q = MAX_QUEUE - 1; /*Need change later */
 		gsw_handle = dp_port_prop[inst].ops[0];
+		gsw_qos = &gsw_handle->gsw_qos_ops;
 		if (!inst)/*only inst zero need DMA descriptor */
 			init_dma_desc_mask();
 		if (!dp_port_prop[inst].ops[0] ||
@@ -1210,14 +1212,14 @@ static int dp_platform_set(int inst, u32 flag)
 		/*disable egress VLAN modification for CPU port*/
 		port_remark.nPortId = 0;
 		if (gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_PortRemarkingCfgGet,
+			(dp_gsw_cb)gsw_qos->QoS_PortRemarkingCfgGet,
 			gsw_handle, &port_remark)) {
 			PR_ERR("GSW_QOS_PORT_REMARKING_CFG_GET failed\n");
 			return -1;
 		}
 		port_remark.bPCP_EgressRemarkingEnable = 0;
 		if (gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_PortRemarkingCfgGet,
+			(dp_gsw_cb)gsw_qos->QoS_PortRemarkingCfgGet,
 			gsw_handle, &port_remark)) {
 			PR_ERR("GSW_QOS_PORT_REMARKING_CFG_GET failed\n");
 			return -1;
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c b/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
index c580c7a75c6a..1ee3e0f5b127 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
@@ -2264,11 +2264,10 @@ static int dp_map_qid_to_cqmdeq(struct dp_node_link *info, int flag)
 					 q_link.cqm_deq_port, "child", idx, "Q",
 					 node.child[idx].id.q_id);
 				break;
-			} else {
-				node_info.node_type = node.child[idx].type;
-				node_info.node_id = node.child[idx].id;
-				dp_map_qid_to_cqmdeq(&node_info, flag);
 			}
+			node_info.node_type = node.child[idx].type;
+			node_info.node_id = node.child[idx].id;
+			dp_map_qid_to_cqmdeq(&node_info, flag);
 		}
 	}
 	return DP_SUCCESS;
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_rx.c b/drivers/net/datapath/dpm/gswip31/datapath_rx.c
index 53b7cf00059d..f6c4bda65cda 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_rx.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_rx.c
@@ -21,20 +21,18 @@ static void rx_dbg(u32 f, struct sk_buff *skb, struct dma_rx_desc_0 *desc0,
 
 {
 	int inst = 0;
+	int data_len = skb->len > dp_print_len ? skb->len : dp_print_len;
 
 	DP_DEBUG(DP_DBG_FLAG_DUMP_RX,
 		 "\ndp_rx:skb->data=%p Loc=%x offset=%d skb->len=%d\n",
 		 skb->data, desc2->field.data_ptr,
 		 desc3->field.byte_offset, skb->len);
 	if ((f) & DP_DBG_FLAG_DUMP_RX_DATA)
-		dp_dump_raw_data(skb->data,
-				(skb->len >
-				(dp_print_len)) ? skb->len : (dp_print_len),
-				"Original Data");
+		dp_dump_raw_data(skb->data, data_len, "Original Data");
 	DP_DEBUG(DP_DBG_FLAG_DUMP_RX, "parse hdr size = %d\n",
 		 paser_exist);
 	if ((f) & DP_DBG_FLAG_DUMP_RX_DESCRIPTOR)
-		dp_port_prop[inst].info.dump_rx_dma_desc(desc0, (desc1),
+		dp_port_prop[inst].info.dump_rx_dma_desc(desc0, desc1,
 							 desc2, desc3);
 	if (paser_exist && (dp_dbg_flag & DP_DBG_FLAG_DUMP_RX_PASER))
 		dump_parser_flag(parser);
@@ -70,10 +68,9 @@ static void rx_dbg_zero_port(struct sk_buff *skb, struct dma_rx_desc_0 *desc0,
 		dump_parser_flag(parser);
 	if (pmac)
 		dp_port_prop[inst].info.dump_rx_pmac(pmac);
-	dp_dump_raw_data((char *)(skb->data),
-			(skb->len >
-			 dp_print_len) ? skb->len : dp_print_len,
-			"Recv Data");
+	dp_dump_raw_data(skb->data,
+			 skb->len > dp_print_len ? skb->len : dp_print_len,
+			 "Recv Data");
 }
 
 /* clone skb to send one copy to lct dev for multicast/broadcast
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_switchdev.c b/drivers/net/datapath/dpm/gswip31/datapath_switchdev.c
index 8e7b7231bd9e..5228decad4d8 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_switchdev.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_switchdev.c
@@ -40,8 +40,10 @@ int dp_swdev_bridge_port_cfg_set(struct br_info *br_item,
 	struct bridge_member_port *bport_list = NULL;
 	GSW_BRIDGE_portConfig_t brportcfg;
 	struct core_ops *gsw_handle;
+	struct brdgport_ops *gsw_bp;
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	/*To set other members to the current bport*/
 	memset(&brportcfg, 0, sizeof(GSW_BRIDGE_portConfig_t));
 	brportcfg.nBridgePortId = bport;
@@ -49,7 +51,7 @@ int dp_swdev_bridge_port_cfg_set(struct br_info *br_item,
 		 brportcfg.nBridgePortId, inst);
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
+		(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
 		gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("fail in getting bridge port config\r\n");
@@ -66,7 +68,7 @@ int dp_swdev_bridge_port_cfg_set(struct br_info *br_item,
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
 		GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigSet,
+		(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
 		gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Fail in allocating/configuring bridge port\n");
@@ -84,7 +86,7 @@ int dp_swdev_bridge_port_cfg_set(struct br_info *br_item,
 			brportcfg.eMask =
 				GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
+				(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
 				gsw_handle, &brportcfg);
 			if (ret != GSW_statusOk) {
 				PR_ERR
@@ -98,7 +100,7 @@ int dp_swdev_bridge_port_cfg_set(struct br_info *br_item,
 				GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
 				GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigSet,
+				(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
 				gsw_handle, &brportcfg);
 			if (ret != GSW_statusOk) {
 				PR_ERR("Fail alloc/cfg bridge port\n");
@@ -117,8 +119,10 @@ int dp_swdev_bridge_port_cfg_reset(struct br_info *br_item,
 	int i, cnt = 0, bp = 0;
 	GSW_return_t ret;
 	struct core_ops *gsw_handle;
+	struct brdgport_ops *gsw_bp;
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	memset(&brportcfg, 0, sizeof(GSW_BRIDGE_portConfig_t));
 	brportcfg.nBridgePortId = bport;
 	DP_DEBUG(DP_DBG_FLAG_SWDEV, "Reset BP=%d inst:%d\n",
@@ -126,7 +130,7 @@ int dp_swdev_bridge_port_cfg_reset(struct br_info *br_item,
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	/*Reset other members from current bport map*/
 	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
+		(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
 		gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
 		/* Note: here may fail if this device is not removed from
@@ -164,7 +168,7 @@ int dp_swdev_bridge_port_cfg_reset(struct br_info *br_item,
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
 			  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigSet,
+		(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
 		gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Fail in configuring GSW_BRIDGE_portConfig_t in %s\r\n",
@@ -184,7 +188,7 @@ int dp_swdev_bridge_port_cfg_reset(struct br_info *br_item,
 				 GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP |
 				 GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID;
 			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
+				(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
 				gsw_handle, &brportcfg);
 			if (ret != GSW_statusOk) {
 				PR_ERR("failed getting br port cfg\r\n");
@@ -196,7 +200,7 @@ int dp_swdev_bridge_port_cfg_reset(struct br_info *br_item,
 				 GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
 				 GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigSet,
+				(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
 				gsw_handle, &brportcfg);
 			if (ret != GSW_statusOk) {
 				PR_ERR("Fail alloc/cfg br port\n");
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_tx.c b/drivers/net/datapath/dpm/gswip31/datapath_tx.c
index 33d6a3708507..0b220c6ae35a 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_tx.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_tx.c
@@ -27,6 +27,8 @@ void dp_xmit_dbg(
 	int gso,
 	int checksum)
 {
+	int data_len;
+
 #if defined(DP_SKB_HACK)
 	DP_DEBUG(DP_DBG_FLAG_DUMP_TX,
 		 "%s: dp_xmit:skb->data/len=0x%p/%d data_ptr=%x from port=%d and subitf=%d\n",
@@ -35,18 +37,10 @@ void dp_xmit_dbg(
 		 ep, rx_subif->subif);
 #endif
 	if (dp_dbg_flag & DP_DBG_FLAG_DUMP_TX_DATA) {
-		if (pmac) {
+		data_len = skb->len > dp_print_len ? skb->len : dp_print_len;
+		if (pmac)
 			dp_dump_raw_data((char *)pmac, PMAC_SIZE, "Tx Data");
-			dp_dump_raw_data(skb->data,
-					(skb->len > dp_print_len) ?
-					skb->len :
-					dp_print_len,
-					"Tx Data");
-		} else
-			dp_dump_raw_data(skb->data,
-					(skb->len > dp_print_len) ?
-					skb->len : dp_print_len,
-					"Tx Data");
+		dp_dump_raw_data(skb->data, data_len, "Tx Data");
 	}
 	DP_DEBUG(DP_DBG_FLAG_DUMP_TX_SUM,
 		 "ip_summed=%s(%d) encapsulation=%s\n",
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_gswip.c b/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
index cecd892ef381..784860def527 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
@@ -515,10 +515,12 @@ struct gsw_itf *ctp_port_assign_32(int inst, u8 ep, int bp_default,
 	int i, alloc_flag;
 	u16 num;
 	struct core_ops *gsw_handle;
+	struct ctp_ops *gsw_ctp;
 	struct pmac_port_info *port_info = get_dp_port_info(inst, ep);
 
 	memset(&ctp_assign, 0, sizeof(ctp_assign));
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
+	gsw_ctp = &gsw_handle->gsw_ctp_ops;
 	alloc_flag = port_info->alloc_flags;
 
 	if (flags & DP_F_DEREGISTER) {
@@ -528,7 +530,7 @@ struct gsw_itf *ctp_port_assign_32(int inst, u8 ep, int bp_default,
 		ctp_assign.nFirstCtpPortId = itf_assign[ep].start;
 		ctp_assign.nNumberOfCtpPort = itf_assign[ep].n;
 		if (gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_ctp_ops.CTP_PortAssignmentFree,
+			(dp_gsw_cb)gsw_ctp->CTP_PortAssignmentFree,
 			gsw_handle, &ctp_assign) != 0) {
 			PR_ERR("Failed to allc CTP for ep=%d blk=%d mode=%d\n",
 			       ep, assign->num, assign->emode);
@@ -554,7 +556,7 @@ struct gsw_itf *ctp_port_assign_32(int inst, u8 ep, int bp_default,
 	ctp_assign.nFirstCtpPortId = 0;
 	ctp_assign.nNumberOfCtpPort = num;
 	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_ctp_ops.CTP_PortAssignmentAlloc,
+		(dp_gsw_cb)gsw_ctp->CTP_PortAssignmentAlloc,
 		gsw_handle,
 		&ctp_assign) != 0) {
 		PR_ERR("Failed CTP Assignment for ep=%d blk size=%d mode=%s\n",
@@ -696,8 +698,10 @@ int free_bridge_port_32(int inst, int bp)
 	int i, j;
 	GSW_return_t ret;
 	struct core_ops *gsw_handle;
+	struct brdgport_ops *gsw_bp;
 
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	if (bp == CPU_BP)
 		return 0;
 
@@ -710,7 +714,7 @@ int free_bridge_port_32(int inst, int bp)
 	tmp->nBridgePortId = bp;
 	tmp->eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
+		(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
 		gsw_handle, tmp);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_GET: %d\n", bp);
@@ -727,7 +731,7 @@ int free_bridge_port_32(int inst, int bp)
 				GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 			tmp2->nBridgePortId = i * 16 + j;
 			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
+				(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
 				gsw_handle, tmp2);
 			if (ret != GSW_statusOk) {
 				PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_GET\n");
@@ -735,7 +739,7 @@ int free_bridge_port_32(int inst, int bp)
 			}
 			UNSET_BP_MAP(tmp2->nBridgePortMap, bp);
 			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigSet,
+				(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
 				gsw_handle, tmp2);
 			if (ret != GSW_statusOk) {
 				PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_SET\n");
@@ -749,7 +753,7 @@ int free_bridge_port_32(int inst, int bp)
 	tmp->nBridgePortId = bp;
 	tmp->eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_Free,
+		(dp_gsw_cb)gsw_bp->BridgePort_Free,
 		gsw_handle, tmp);
 	if (ret != GSW_statusOk)
 		PR_ERR("Failed to GSW_BRIDGE_PORT_FREE:%d\n", bp);
@@ -1533,6 +1537,7 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 	const struct ctp_assign *assign;
 	struct cbm_gpid_lpid cbm_gpid = {0};
 	struct hal_priv *priv;
+	struct gpid_ops *gsw_gpid;
 
 	priv = (struct hal_priv *)dp_port_prop[inst].priv_hal;
 	if (!priv) {
@@ -1545,6 +1550,7 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 	}
 	memset(&lp_gp_assign, 0, sizeof(GSW_LPID_to_GPID_Assignment_t));
 	memset(&gp_lp_assign, 0, sizeof(GSW_GPID_to_LPID_Assignment_t));
+	gsw_gpid = &gsw_handle->gsw_gpid_ops;
 
 	if (flags & DP_F_DEREGISTER) {
 		lp_gp_assign.nLogicalPortId = ep;
@@ -1552,7 +1558,7 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 		gpid_num = get_dp_port_info(inst, ep)->gpid_num;
 
 		if (gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_gpid_ops.LpidToGpid_AssignmentSet,
+			(dp_gsw_cb)gsw_gpid->LpidToGpid_AssignmentSet,
 			gsw_handle, &lp_gp_assign) != 0) {
 			PR_ERR("Fail to assign Lpid->Gpid table %d in GSWIP\n",
 			       ep);
@@ -1563,7 +1569,7 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 		gp_lp_assign.nGlobalPortId = gpid_base;
 
 		if (gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_gpid_ops.GpidToLpid_AssignmentSet,
+			(dp_gsw_cb)gsw_gpid->GpidToLpid_AssignmentSet,
 			gsw_handle, &gp_lp_assign) != 0) {
 			PR_ERR("Fail to assign GPID->LPID table %d in GSWIP\n",
 			       ep);
@@ -1597,7 +1603,7 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 	lp_gp_assign.nNumberOfGlobalPort = gpid_num;
 
 	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_gpid_ops.LpidToGpid_AssignmentSet,
+		(dp_gsw_cb)gsw_gpid->LpidToGpid_AssignmentSet,
 		gsw_handle, &lp_gp_assign) != 0) {
 #if 0
 		PR_ERR("Fail to assign Lpid->Gpid table %d in GSWIP\n",
@@ -1612,7 +1618,7 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 	gp_lp_assign.nGlobalPortId = gpid_base;
 
 	if (gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_gpid_ops.GpidToLpid_AssignmentSet,
+		(dp_gsw_cb)gsw_gpid->GpidToLpid_AssignmentSet,
 		gsw_handle, &gp_lp_assign) != 0) {
 		PR_ERR("Fail to assign Gpid->Lpid table %d in GSWIP\n",
 		       ep);
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_misc.c b/drivers/net/datapath/dpm/gswip32/datapath_misc.c
index 7e3ee6bde45b..4930874c32cb 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_misc.c
@@ -193,9 +193,8 @@ void dump_rx_dma_desc_32(struct dma_rx_desc_0 *desc_0,
 		desc_0->field.dw0bit31,
 		desc_0->field.flow_id, desc_0->field.dw0bit16,
 		"subif", desc_0->field.dest_sub_if_id);
-	PR_INFO("  DW1: redir=%d header_mode=%d pmac=%d ts=%d pre_l2=%d"
-		" classen=%d fcs=%d pkt_type=%d src_pool=%d dec=%d enc=%d"
-		" lro_type=%d color=%d port=%d classid=%d\n",
+	PR_INFO(
+		"  DW1: redir=%d header_mode=%d pmac=%d ts=%d pre_l2=%d classen=%d fcs=%d pkt_type=%d src_pool=%d dec=%d enc=%d lro_type=%d color=%d port=%d classid=%d\n",
 		desc_1->field.redir, desc_1->field.header_mode,
 		desc_1->field.pmac, desc_1->field.ts, desc_1->field.pre_l2,
 		desc_1->field.classen, desc_1->field.fcs,
@@ -204,8 +203,8 @@ void dump_rx_dma_desc_32(struct dma_rx_desc_0 *desc_0,
 		desc_1->field.color, desc_1->field.ep, desc_1->field.classid);
 	PR_INFO("  DW2: data_ptr=0x%08x ByteOffset=%d\n",
 		desc_2->field.data_ptr, desc_2->field.byte_offset);
-	PR_INFO("  DW3: own=%d c=%d sop=%d eop=%d dic=%d haddr=0x%08x"
-		" sp=%d pool_policy=%d data_len=%d\n",
+	PR_INFO(
+		"  DW3: own=%d c=%d sop=%d eop=%d dic=%d haddr=0x%08x sp=%d pool_policy=%d data_len=%d\n",
 		desc_3->field.own, desc_3->field.c, desc_3->field.sop,
 		desc_3->field.eop, desc_3->field.dic, desc_3->field.haddr,
 		desc_3->field.sp, desc_3->field.pool_policy,
@@ -235,9 +234,8 @@ void dump_tx_dma_desc_32(struct dma_tx_desc_0 *desc_0,
 		desc_0->field.dw0bit31,
 		desc_0->field.flow_id, desc_0->field.dw0bit16,
 		"subif", desc_0->field.dest_sub_if_id);
-	PR_INFO("  DW1:redir=%d header_mode=%d pmac=%d ts=%d pre_l2=%d"
-		" classen=%d fcs=%d pkt_type=%d src_pool=%d dec=%d enc=%d"
-		" lro_type=%d color=%d port=%d classid=%d\n",
+	PR_INFO(
+		"  DW1:redir=%d header_mode=%d pmac=%d ts=%d pre_l2=%d classen=%d fcs=%d pkt_type=%d src_pool=%d dec=%d enc=%d lro_type=%d color=%d port=%d classid=%d\n",
 		desc_1->field.redir, desc_1->field.header_mode,
 		desc_1->field.pmac, desc_1->field.ts, desc_1->field.pre_l2,
 		desc_1->field.classen, desc_1->field.fcs,
@@ -246,8 +244,8 @@ void dump_tx_dma_desc_32(struct dma_tx_desc_0 *desc_0,
 		desc_1->field.color, desc_1->field.ep, desc_1->field.classid);
 	PR_INFO("  DW2:data_ptr=0x%08x ByteOffset=%d\n", desc_2->field.data_ptr,
 		desc_2->field.byte_offset);
-	PR_INFO("  DW3:own=%d c=%d sop=%d eop=%d dic=%d haddr=0x%08x"
-		" sp=%d pool_policy=%d data_len=%d\n",
+	PR_INFO(
+		"  DW3:own=%d c=%d sop=%d eop=%d dic=%d haddr=0x%08x sp=%d pool_policy=%d data_len=%d\n",
 		desc_3->field.own, desc_3->field.c, desc_3->field.sop,
 		desc_3->field.eop, desc_3->field.dic, desc_3->field.haddr,
 		desc_3->field.sp, desc_3->field.pool_policy,
@@ -338,9 +336,10 @@ static void dump_rx_pmac(struct pmac_rx_hdr *pmac)
 	PR_INFO("  byte 2:class=%d res=%d src_dst_subif_id_14_12=%d\n",
 		pmac->class, pmac->res2, pmac->src_dst_subif_id_14_12);
 	/*byte 3 */
-	PR_INFO("  byte 3:pkt_type=%d ext=%d ins=%d pre_l2=%d oam=%d res32=%d\n",
-		pmac->pkt_type, pmac->ext, pmac->ins, pmac->pre_l2,
-		pmac->oam, pmac->res32);
+	PR_INFO("  byte 3:%s=%d %s=%d %s=%d %s=%d %s=%d %s=%d\n",
+		"pkt_type", pmac->pkt_type, "ext", pmac->ext,
+		"ins", pmac->ins, "pre_12", pmac->pre_l2,
+		"oam", pmac->oam, "res32", pmac->res32);
 	/*byte 4 */
 	PR_INFO("  byte 4:fcs=%d ptp=%d one_step=%d src_dst_subif_id_msb=%d\n",
 		pmac->fcs, pmac->ptp, pmac->one_step,
@@ -382,12 +381,9 @@ static void dump_tx_pmac(struct pmac_tx_hdr *pmac)
 		pmac->res2);
 	/*byte 3 */
 	PR_INFO("  byte 3:%s=%d %s=%d %s=%d %s=%d %s=%d %s=%d %s=%d\n",
-		"pkt_type", pmac->pkt_type,
-		"ext", pmac->ext,
-		"ins", pmac->ins,
-		"res3", pmac->res3,
-		"oam", pmac->oam,
-		"lrnmd", pmac->lrnmd,
+		"pkt_type", pmac->pkt_type, "ext", pmac->ext,
+		"ins", pmac->ins, "res3", pmac->res3,
+		"oam", pmac->oam, "lrnmd", pmac->lrnmd,
 		"class_en", pmac->class_en);
 	/*byte 4 */
 	PR_INFO("  byte 4:%s=%d ptp=%d one_step=%d src_dst_subif_id_msb=%d\n",
@@ -1043,6 +1039,8 @@ int dp_platform_queue_set_32(int inst, u32 flag)
 	struct dp_dflt_hostif hostif = {0};
 	int vap_num = 0;
 	const struct ctp_assign *cpu_assign = get_ctp_assign(DP_F_CPU);
+	struct cqm_port_info *c_info;
+	struct cbm_tx_push *tx_push;
 
 	if (!cpu_assign) {
 		DP_ERR("cpu_assign NULL\n");
@@ -1139,58 +1137,48 @@ int dp_platform_queue_set_32(int inst, u32 flag)
 	port_info->deq_port_base = 0;
 	for (i = 0; i < CQM_MAX_CPU; i++) {
 		for (j = 0; j < PER_CPU_PORTS; j++) {
-			if (cpu.dq_tx_push_info[i][j].deq_port == (s32)-1)
+			tx_push = &cpu.dq_tx_push_info[i][j];
+			if (tx_push->deq_port == (s32)-1)
 				continue;
+			c_info = &dp_deq_port_tbl[inst][q_port.cqe_deq];
 			vap_num++;
 			DP_DEBUG(DP_DBG_FLAG_QOS, "cpu(%d)(%d) deq_port=%d",
-				 i, j, cpu.dq_tx_push_info[i][j].deq_port);
-			q_port.cqe_deq = cpu.dq_tx_push_info[i][j].deq_port;
-			q_port.tx_pkt_credit =
-				cpu.dq_tx_push_info[i][j].tx_pkt_credit;
-			q_port.tx_ring_addr =
-				cpu.dq_tx_push_info[i][j].txpush_addr_qos;
-			q_port.tx_ring_addr_push =
-				cpu.dq_tx_push_info[i][j].txpush_addr;
-			q_port.tx_ring_size =
-				cpu.dq_tx_push_info[i][j].tx_ring_size;
+				 i, j, tx_push->deq_port);
+			q_port.cqe_deq = tx_push->deq_port;
+			q_port.tx_pkt_credit = tx_push->tx_pkt_credit;
+			q_port.tx_ring_addr = tx_push->txpush_addr_qos;
+			q_port.tx_ring_addr_push = tx_push->txpush_addr;
+			q_port.tx_ring_size = tx_push->tx_ring_size;
 
 			/*Sotre Ring Info */
-			dp_deq_port_tbl[inst][q_port.cqe_deq].tx_pkt_credit =
-				cpu.dq_tx_push_info[i][j].tx_pkt_credit;
-			dp_deq_port_tbl[inst][q_port.cqe_deq].txpush_addr =
-				cpu.dq_tx_push_info[i][j].txpush_addr;
-			dp_deq_port_tbl[inst][q_port.cqe_deq].txpush_addr_qos =
-				cpu.dq_tx_push_info[i][j].txpush_addr_qos;
-			dp_deq_port_tbl[inst][q_port.cqe_deq].tx_ring_size =
-				cpu.dq_tx_push_info[i][j].tx_ring_size;
-			dp_deq_port_tbl[inst][q_port.cqe_deq].dp_port =
-				CPU_PORT;
+			c_info->tx_pkt_credit = tx_push->tx_pkt_credit;
+			c_info->txpush_addr = tx_push->txpush_addr;
+			c_info->txpush_addr_qos = tx_push->txpush_addr_qos;
+			c_info->tx_ring_size = tx_push->tx_ring_size;
+			c_info->dp_port = CPU_PORT;
 			DP_DEBUG(DP_DBG_FLAG_QOS, "Store CPU ring info\n");
 			DP_DEBUG(DP_DBG_FLAG_QOS, "  ring_address[%d]=0x%px\n",
-				 q_port.cqe_deq,
-				 dp_deq_port_tbl[inst][q_port.cqe_deq].txpush_addr);
-			DP_DEBUG(DP_DBG_FLAG_QOS, "  ring_address_push[%d]=0x%px\n",
-				 q_port.cqe_deq,
-				 dp_deq_port_tbl[inst][q_port.cqe_deq].txpush_addr_qos);
+				 q_port.cqe_deq, c_info->txpush_addr);
+			DP_DEBUG(DP_DBG_FLAG_QOS,
+				 "  ring_address_push[%d]=0x%px\n",
+				 q_port.cqe_deq, c_info->txpush_addr_qos);
 			DP_DEBUG(DP_DBG_FLAG_QOS, "  ring_size[%d]=%d\n",
-				 q_port.cqe_deq,
-				 dp_deq_port_tbl[inst][q_port.cqe_deq].tx_ring_size);
+				 q_port.cqe_deq, c_info->tx_ring_size);
 			DP_DEBUG(DP_DBG_FLAG_QOS, "  credit[%d]=%d\n",
-				 q_port.cqe_deq,
-				 dp_deq_port_tbl[inst][q_port.cqe_deq].tx_pkt_credit);
+				 q_port.cqe_deq, c_info->tx_pkt_credit);
 			q_port.inst = inst;
 			q_port.dp_port = PMAC_CPU_ID;
 			DP_DEBUG(DP_DBG_FLAG_QOS, "CPU[%d] ring addr=%px\n", i,
-				 cpu.dq_tx_push_info[i][j].txpush_addr);
+				 tx_push->txpush_addr);
 			DP_DEBUG(DP_DBG_FLAG_QOS,
 				 "CPU[%d] ring addr push=%px\n", i,
-				 cpu.dq_tx_push_info[i][j].txpush_addr_qos);
+				 tx_push->txpush_addr_qos);
 			/* fake CTP for CPU port to store its qid */
 			q_port.ctp = i;
 			DP_DEBUG(DP_DBG_FLAG_QOS, "alloc_q_to_port_32...\n");
 			if (alloc_q_to_port_32(&q_port, 0)) { /* q_port.qid */
-				PR_ERR("alloc_q_to_port_32 fail for dp_port=%d\n",
-				       q_port.dp_port);
+				PR_ERR("%s fail for dp_port=%d\n",
+				       "alloc_q_to_port_32", q_port.dp_port);
 				return -1;
 			}
 			port_info->deq_port_num++;
@@ -1248,8 +1236,8 @@ int dp_platform_queue_set_32(int inst, u32 flag)
 				hostif.qid = q_port.qid;
 				hostif.color = PP_COLOR_GREEN;
 				if (dp_add_dflt_hostif(&hostif, 0)) {
-					DP_ERR("dp_add_dflt_hostif fail for CPU VAP=%d\n",
-					       vap);
+					DP_ERR("%s fail for CPU VAP=%d\n",
+					       "dp_add_dflt_hostif", vap);
 					return -1;
 				}
 			}
@@ -1259,7 +1247,7 @@ int dp_platform_queue_set_32(int inst, u32 flag)
 			 */
 			en_data.cbm_inst = dp_port_prop[inst].cbm_inst;
 			en_data.dp_inst = inst;
-			en_data.deq_port = cpu.dq_tx_push_info[i][j].deq_port;
+			en_data.deq_port = tx_push->deq_port;
 			if (cbm_dp_enable(NULL, PMAC_CPU_ID, &en_data, 0, 0)) {
 				PR_ERR("Fail to enable CPU[%d]\n",
 				       en_data.deq_port);
@@ -1278,6 +1266,7 @@ static int dp_platform_set(int inst, u32 flag)
 	struct core_ops *gsw_handle;
 	struct hal_priv *priv;
 	struct pmac_port_info *pi = get_dp_port_info(inst, CPU_PORT);
+	struct qos_ops *qos;
 
 	/* For initialize */
 	if ((flag & DP_PLATFORM_INIT) == DP_PLATFORM_INIT) {
@@ -1293,6 +1282,7 @@ static int dp_platform_set(int inst, u32 flag)
 		priv = (struct hal_priv *)dp_port_prop[inst].priv_hal;
 		priv->ppv4_drop_q = MAX_QUEUE - 1; /*Need change later */
 		gsw_handle = dp_port_prop[inst].ops[0];
+		qos = &gsw_handle->gsw_qos_ops;
 		if (!inst)/*only inst zero need DMA descriptor */
 			init_dma_desc_mask();
 		if (!dp_port_prop[inst].ops[0] ||
@@ -1324,16 +1314,14 @@ static int dp_platform_set(int inst, u32 flag)
 #endif
 		/*disable egress VLAN modification for CPU port*/
 		port_remark.nPortId = 0;
-		if (gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_PortRemarkingCfgGet,
-			gsw_handle, &port_remark)) {
+		if (gsw_core_api((dp_gsw_cb)qos->QoS_PortRemarkingCfgGet,
+				 gsw_handle, &port_remark)) {
 			PR_ERR("GSW_QOS_PORT_REMARKING_CFG_GET failed\n");
 			return -1;
 		}
 		port_remark.bPCP_EgressRemarkingEnable = 0;
-		if (gsw_core_api(
-			(dp_gsw_cb)gsw_handle->gsw_qos_ops.QoS_PortRemarkingCfgGet,
-			gsw_handle, &port_remark)) {
+		if (gsw_core_api((dp_gsw_cb)qos->QoS_PortRemarkingCfgGet,
+				 gsw_handle, &port_remark)) {
 			PR_ERR("GSW_QOS_PORT_REMARKING_CFG_GET failed\n");
 			return -1;
 		}
@@ -1501,11 +1489,11 @@ static int port_platform_set(int inst, u8 ep, struct dp_port_data *data,
 			port_info->tx_pkt_credit;
 		dp_deq_port_tbl[inst][i + idx].dp_port = ep;
 		if (port_info->num_dma_chan > 1) {
-			dp_deq_port_tbl[inst][i	+ idx].dma_chan = dma_chan++;
+			dp_deq_port_tbl[inst][i + idx].dma_chan = dma_chan++;
 			dp_deq_port_tbl[inst][i + idx].dma_ch_offset =
 								dma_ch_base + i;
 		} else if (port_info->num_dma_chan == 1) {
-			dp_deq_port_tbl[inst][i	+ idx].dma_chan	= dma_chan;
+			dp_deq_port_tbl[inst][i + idx].dma_chan	= dma_chan;
 			dp_deq_port_tbl[inst][i + idx].dma_ch_offset =
 								dma_ch_base;
 		}
@@ -1525,8 +1513,8 @@ static int port_platform_set(int inst, u8 ep, struct dp_port_data *data,
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_DBG)
 	if (DP_DBG_FLAG_QOS & dp_dbg_flag) {
 		for (i = 0; i < port_info->deq_port_num; i++) {
-			PR_INFO("cqm[%d]: addr/push=%px/%px credit=%d size==%d\n",
-				i + idx,
+			PR_INFO("cqm[%d]: %s/%s=%px/%px credit=%d size=%d\n",
+				i + idx, "addr", "push",
 				dp_deq_port_tbl[inst][i + idx].txpush_addr,
 				dp_deq_port_tbl[inst][i + idx].txpush_addr_qos,
 				dp_deq_port_tbl[inst][i + idx].tx_pkt_credit,
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_ppv4.c b/drivers/net/datapath/dpm/gswip32/datapath_ppv4.c
index 7be63d54cc2a..c0293bff4960 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_ppv4.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_ppv4.c
@@ -46,7 +46,6 @@ int (*qos_port_info_get_32)(struct pp_qos_dev *qdev, unsigned int id,
 			    struct pp_qos_port_info *info);
 struct pp_qos_dev *(*qos_dev_open_32)(unsigned int id);
 
-
 void init_qos_fn_32(void)
 {
 #if (IS_ENABLED(CONFIG_LTQ_PPV4_QOS) || IS_ENABLED(CONFIG_PPV4))
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c b/drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c
index d7786a2fefda..ecb6935d2572 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c
@@ -1393,7 +1393,7 @@ static int dp_alloc_qos_port(struct dp_node_alloc *node, int flag)
 	/* Configure QOS dequeue port */
 	qos_port_conf_set_default_32(&port_cfg);
 	port_cfg.ring_address =
-		(unsigned long)dp_deq_port_tbl[inst][cqm_deq_port].txpush_addr_qos;
+		dp_deq_port_tbl[inst][cqm_deq_port].txpush_addr_qos;
 	port_cfg.ring_size = dp_deq_port_tbl[inst][cqm_deq_port].tx_ring_size;
 	port_cfg.credit = dp_deq_port_tbl[inst][cqm_deq_port].tx_pkt_credit;
 	if (port_cfg.credit)
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_ppv4_session.c b/drivers/net/datapath/dpm/gswip32/datapath_ppv4_session.c
index e80c7d2e6847..12f2dac05877 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_ppv4_session.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_ppv4_session.c
@@ -65,7 +65,8 @@ void init_gpid_map_table(int inst)
 		 * Later Caller will change this
 		 */
 		if (i >= DP_SPL_GPID_START)
-			priv->gp_dp_map[i].dpid = (12 + (i-DP_SPL_GPID_START));
+			priv->gp_dp_map[i].dpid =
+				(12 + (i - DP_SPL_GPID_START));
 	}
 }
 
@@ -405,7 +406,7 @@ int dp_add_hostif(int inst, int dpid, int vap)
 		struct dp_subif_info *sif;
 
 		sif = get_dp_port_subif(cpu_info, 2 * i + 1);
-		if (sif->flags) { /* vaid VAP */
+		if (sif->flags) { /* valid VAP */
 			hif.dp.eg[i].qos_q = dp_get_q_logic_32(inst, sif->qid);
 			hif.dp.eg[i].pid = sif->gpid;
 		} else {
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_rx.c b/drivers/net/datapath/dpm/gswip32/datapath_rx.c
index c24fd7a9b5a1..f0cc2257d8b8 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_rx.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_rx.c
@@ -123,11 +123,13 @@ int32_t dp_rx_32(struct sk_buff *skb, u32 flags)
 			  gpid, dpid);
 
 	if (unlikely(!dpid)) { /*Normally shouldnot go to here */
-		DP_ERR("Impossible: DPID Invalid (0), Desc rx'd: D0: %08x D1: %08x D2: %08x D3: %08x\n",
+		DP_ERR("%s %s D0: %08x D1: %08x D2: %08x D3: %08x\n",
+		       "Impossible: DPID Invalid (0),", "Desc rx'd:",
 		       *(u32 *)desc_0, *(u32 *)desc_1,
 		       *(u32 *)desc_2, *(u32 *)desc_3);
-		DP_ERR("QoS Descriptor at buf_base %px Desc rx'd: D0: %08x D1: %08x D2: %08x D3: %08x\n",
-		       skb->buf_base, *(skb->buf_base),
+		DP_ERR("%s %px %s D0: %08x D1: %08x D2: %08x D3: %08x\n",
+		       "QoS Descriptor at buf_base", skb->buf_base,
+		       "Desc rx'd:", *skb->buf_base,
 		       *(skb->buf_base + sizeof(u32)),
 		       *(skb->buf_base + (2 * sizeof(u32))),
 		       *(skb->buf_base + (3 * sizeof(u32))));
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_switchdev.c b/drivers/net/datapath/dpm/gswip32/datapath_switchdev.c
index 0d87f846a167..a119baed4b30 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_switchdev.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_switchdev.c
@@ -40,8 +40,10 @@ int dp_swdev_bridge_port_cfg_set_32(struct br_info *br_item,
 	struct bridge_member_port *bport_list = NULL;
 	GSW_BRIDGE_portConfig_t brportcfg;
 	struct core_ops *gsw_handle;
+	struct brdgport_ops *gsw_bp;
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	/*To set other members to the current bport*/
 	memset(&brportcfg, 0, sizeof(GSW_BRIDGE_portConfig_t));
 	brportcfg.nBridgePortId = bport;
@@ -49,7 +51,7 @@ int dp_swdev_bridge_port_cfg_set_32(struct br_info *br_item,
 		 brportcfg.nBridgePortId, inst);
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
+		(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
 		gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("fail in getting bridge port config\r\n");
@@ -66,7 +68,7 @@ int dp_swdev_bridge_port_cfg_set_32(struct br_info *br_item,
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
 		GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigSet,
+		(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
 		gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Fail in allocating/configuring bridge port\n");
@@ -84,7 +86,7 @@ int dp_swdev_bridge_port_cfg_set_32(struct br_info *br_item,
 			brportcfg.eMask =
 				GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
+				(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
 				gsw_handle, &brportcfg);
 			if (ret != GSW_statusOk) {
 				PR_ERR
@@ -98,7 +100,7 @@ int dp_swdev_bridge_port_cfg_set_32(struct br_info *br_item,
 				GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
 				GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigSet,
+				(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
 				gsw_handle, &brportcfg);
 			if (ret != GSW_statusOk) {
 				PR_ERR("Fail alloc/cfg bridge port\n");
@@ -117,8 +119,10 @@ int dp_swdev_bridge_port_cfg_reset_32(struct br_info *br_item,
 	int i, cnt = 0, bp = 0;
 	GSW_return_t ret;
 	struct core_ops *gsw_handle;
+	struct brdgport_ops *gsw_bp;
 
 	gsw_handle = dp_port_prop[inst].ops[0];
+	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	memset(&brportcfg, 0, sizeof(GSW_BRIDGE_portConfig_t));
 	brportcfg.nBridgePortId = bport;
 	DP_DEBUG(DP_DBG_FLAG_SWDEV, "Reset BP=%d inst:%d\n",
@@ -126,7 +130,7 @@ int dp_swdev_bridge_port_cfg_reset_32(struct br_info *br_item,
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	/*Reset other members from current bport map*/
 	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
+		(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
 		gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
 		/* Note: here may fail if this device is not removed from
@@ -164,7 +168,7 @@ int dp_swdev_bridge_port_cfg_reset_32(struct br_info *br_item,
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
 			  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_core_api(
-		(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigSet,
+		(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
 		gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
 		PR_ERR("Fail in configuring GSW_BRIDGE_portConfig_t in %s\r\n",
@@ -184,7 +188,7 @@ int dp_swdev_bridge_port_cfg_reset_32(struct br_info *br_item,
 				 GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP |
 				 GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID;
 			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigGet,
+				(dp_gsw_cb)gsw_bp->BridgePort_ConfigGet,
 				gsw_handle, &brportcfg);
 			if (ret != GSW_statusOk) {
 				PR_ERR("failed getting br port cfg\r\n");
@@ -196,7 +200,7 @@ int dp_swdev_bridge_port_cfg_reset_32(struct br_info *br_item,
 				 GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID |
 				 GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 			ret = gsw_core_api(
-				(dp_gsw_cb)gsw_handle->gsw_brdgport_ops.BridgePort_ConfigSet,
+				(dp_gsw_cb)gsw_bp->BridgePort_ConfigSet,
 				gsw_handle, &brportcfg);
 			if (ret != GSW_statusOk) {
 				PR_ERR("Fail alloc/cfg br port\n");
@@ -278,7 +282,8 @@ int dp_gswip_ext_vlan_32(int inst, int vap, int ep)
 	port = get_dp_port_info(inst, ep);
 	vlan = kzalloc(sizeof(*vlan), GFP_KERNEL);
 	if (!vlan) {
-		PR_ERR("failed to alloc ext_vlan of %zd bytes\n", sizeof(*vlan));
+		PR_ERR("failed to alloc ext_vlan of %zd bytes\n",
+		       sizeof(*vlan));
 		return 0;
 	}
 	vlan->vlan2_list = kzalloc(sizeof(*vlan->vlan2_list), GFP_KERNEL);
