From e6d8bb09fc5703b34ecfe4b9c2a64bab451b6cdc Mon Sep 17 00:00:00 2001
From: kavitha3 <k.subramanian@intel.com>
Date: Fri, 22 Mar 2019 17:49:43 +0800
Subject: [PATCH] DRVLIB_SW-1535:CQM and BM driver to support both A1 and B0
 SoCs

---
 drivers/net/ethernet/lantiq/cqm/cqm_dev.c       | 19 ++++++++++++--
 drivers/net/ethernet/lantiq/cqm/cqm_dev.h       |  3 +++
 drivers/net/ethernet/lantiq/cqm/prx300/cqm.c    | 34 +++++++++++++++++--------
 drivers/net/ethernet/lantiq/ppv4/bm/pp_bm_drv.c | 34 ++++++++++++++++++++++---
 drivers/net/ethernet/lantiq/ppv4/bm/pp_bm_drv.h |  2 ++
 5 files changed, 76 insertions(+), 16 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/cqm/cqm_dev.c b/drivers/net/ethernet/lantiq/cqm/cqm_dev.c
index 65f9174a13db..0bbf9af61766 100644
--- a/drivers/net/ethernet/lantiq/cqm/cqm_dev.c
+++ b/drivers/net/ethernet/lantiq/cqm/cqm_dev.c
@@ -88,6 +88,22 @@ struct device_node *parse_dts(int j, void **pdata, struct resource **res,
 		return NULL;
 	}
 
+	pool_size = 0;
+	of_property_for_each_u32(node, "intel,bm-buff-num-a1", prop, p,
+				 buf_num) {
+		cqm_pdata->pool_ptrs_a1[cqm_pdata->num_pools_a1++] = buf_num;
+	}
+
+	of_property_for_each_u32(node, "intel,bm-buff-size-a1", prop, p,
+				 buf_num) {
+		cqm_pdata->pool_size_a1[pool_size++] = buf_num;
+	}
+
+	if (cqm_pdata->num_pools_a1 != pool_size) {
+		pr_err("buff num and buff size mismatch\n");
+		return NULL;
+	}
+
 	for_each_available_child_of_node(node, cpu_deq_port) {
 		if (of_property_count_u32_elems(cpu_deq_port, "intel,deq-port")
 						!= MAX_CPU_DQ_PORT_ARGS) {
@@ -195,9 +211,8 @@ static int cqm_platdev_parse_dts(void)
 	int i, dev_add = 0;
 
 	for (i = 0; i < CQM_NUM_DEV_SUPP; i++) {
-		if (!add_cqm_dev(i)) {
+		if (!add_cqm_dev(i))
 			dev_add++;
-		}
 	}
 	if (!dev_add)
 		pr_err("Not Even 1 CBM device registered\n");
diff --git a/drivers/net/ethernet/lantiq/cqm/cqm_dev.h b/drivers/net/ethernet/lantiq/cqm/cqm_dev.h
index 2f4febbe3247..384814d391c7 100644
--- a/drivers/net/ethernet/lantiq/cqm/cqm_dev.h
+++ b/drivers/net/ethernet/lantiq/cqm/cqm_dev.h
@@ -41,8 +41,11 @@ struct cqm_data {
 	struct regmap *syscfg;
 	bool force_xpcs;
 	int num_pools;
+	int num_pools_a1;
 	unsigned int pool_ptrs[MAX_NUM_POOLS];
 	unsigned int pool_size[MAX_NUM_POOLS];
+	unsigned int pool_ptrs_a1[MAX_NUM_POOLS];
+	unsigned int pool_size_a1[MAX_NUM_POOLS];
 	u32  dq_port[MAX_CPU_DQ_PORT_N_TYPE];
 	u32 num_dq_port;
 	u32 gsw_mode;
diff --git a/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c b/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
index 2b1987072f11..d914e9560953 100644
--- a/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
+++ b/drivers/net/ethernet/lantiq/cqm/prx300/cqm.c
@@ -3041,6 +3041,7 @@ static int bm_init(struct platform_device *pdev)
 		 */
 		p_params.base_addr_high = 0;
 		p_params.flags = POOL_ENABLE_FOR_MIN_GRNT_POLICY_CALC;
+		p_params.num_pools = cqm_ctrl->num_pools;
 		bmgr_pool_configure(&p_params, &i);
 	}
 
@@ -3645,13 +3646,30 @@ static int conf_bm(struct cqm_data *pdata)
 	memcpy(cqm_ctrl->prx300_pool_size, pdata->pool_size
 		, sizeof(cqm_ctrl->prx300_pool_size));
 	cqm_ctrl->num_pools = pdata->num_pools;
+
+	/*Handle A1*/
+	dev_dbg(cqm_ctrl->dev, "soc rev %d\n", ltq_get_soc_rev());
+	if (ltq_get_soc_rev() == 0) {
+		memcpy(cqm_ctrl->prx300_pool_ptrs, pdata->pool_ptrs_a1,
+		       sizeof(cqm_ctrl->prx300_pool_ptrs));
+		memcpy(cqm_ctrl->prx300_pool_size, pdata->pool_size_a1,
+		       sizeof(cqm_ctrl->prx300_pool_size));
+		cqm_ctrl->num_pools = pdata->num_pools_a1;
+	}
+
+	/* check prx300 pool and policy */
+	if (cqm_ctrl->num_pools > CQM_PRX300_NUM_BM_POOLS) {
+		pr_err("prx300 pools %u\n", cqm_ctrl->num_pools);
+		return CBM_FAILURE;
+	}
 	/* Pool Index loop*/
-	for (i = 0; i < pdata->num_pools; i++) {
+	for (i = 0; i < cqm_ctrl->num_pools; i++) {
 		/* Validate pool and policy */
-		if ((pdata->pool_ptrs[i] <= 0) ||
-		    (pdata->pool_size[i] <= 0)) {
+		if ((cqm_ctrl->prx300_pool_ptrs[i] <= 0) ||
+		    (cqm_ctrl->prx300_pool_size[i] <= 0)) {
 			pr_err("Idx %u 0x%x 0x%x\n"
-				, i, pdata->pool_ptrs[i], pdata->pool_ptrs[i]);
+				, i, cqm_ctrl->prx300_pool_ptrs[i],
+				cqm_ctrl->prx300_pool_size[i]);
 			return result;
 		}
 
@@ -3679,7 +3697,7 @@ static int conf_bm(struct cqm_data *pdata)
 		}
 
 		/* Config no of policy */
-		p_param[i].num_pools_in_policy = pdata->num_pools - i;
+		p_param[i].num_pools_in_policy = cqm_ctrl->num_pools - i;
 
 		/* group_id default value */
 		p_param[i].group_id = 0;
@@ -3916,12 +3934,6 @@ static int cqm_prx300_probe(struct platform_device *pdev)
 	cqm_ctrl->force_xpcs = pdata->force_xpcs;
 	cqm_ctrl->gint_mode = pdata->gint_mode;
 
-	/* check prx300 pool and policy */
-	if (pdata->num_pools > CQM_PRX300_NUM_BM_POOLS) {
-		pr_err("prx300 pools %u\n", pdata->num_pools);
-		return CBM_FAILURE;
-	}
-
 	if (conf_bm(pdata) != CBM_SUCCESS) {
 		pr_err("conf_BMpool_and_policy failed\n");
 		return CBM_FAILURE;
diff --git a/drivers/net/ethernet/lantiq/ppv4/bm/pp_bm_drv.c b/drivers/net/ethernet/lantiq/ppv4/bm/pp_bm_drv.c
index 2742b8b721fb..ea514be6c687 100644
--- a/drivers/net/ethernet/lantiq/ppv4/bm/pp_bm_drv.c
+++ b/drivers/net/ethernet/lantiq/ppv4/bm/pp_bm_drv.c
@@ -500,6 +500,24 @@ static s32 bmgr_wait_for_init_completion(void)
 	return RC_SUCCESS;
 }
 
+static int is_pow_2(int num)
+{
+	int pow;
+
+	if (num == 0)
+		return 0;
+
+	for (pow = 1; pow > 0; pow <<= 1)
+	{
+		if (pow == num)
+			return 1;
+		if (pow > num)
+			return 0;
+	}
+
+	return 0;
+}
+
 /**************************************************************************
  *! \fn	bmgr_is_pool_params_valid
  **************************************************************************
@@ -553,6 +571,13 @@ static s32 bmgr_is_pool_params_valid(
 		return -EINVAL;
 	}
 
+	if (pool_params->num_pools > PP_BMGR_MAX_POOLS ||
+	    !is_pow_2(pool_params->num_pools)) {
+		pr_err("bmgr_is_pool_params_valid: max_pools %d is not valid\n",
+		       pool_params->num_pools);
+		return -EINVAL;
+	}
+
 	return RC_SUCCESS;
 }
 
@@ -1954,14 +1979,15 @@ s32 bmgr_pool_configure(const struct bmgr_pool_params * const pool_params,
 	if (status != RC_SUCCESS)
 		goto free_memory;
 
+	val = BMGR_DEFAULT_PCU_FIFO_SIZE;
+	val /= pool_params->num_pools;
 	status = bmgr_set_pcu_fifo_base_address(*pool_id,
 						BMGR_START_PCU_FIFO_SRAM_ADDR +
-						(*pool_id *
-						BMGR_DEFAULT_PCU_FIFO_SIZE));
+						(*pool_id * val));
 	if (status != RC_SUCCESS)
 		goto free_memory;
 
-	status = bmgr_set_pcu_fifo_size(*pool_id, BMGR_DEFAULT_PCU_FIFO_SIZE);
+	status = bmgr_set_pcu_fifo_size(*pool_id, val);
 	if (status != RC_SUCCESS)
 		goto free_memory;
 
@@ -1970,11 +1996,13 @@ s32 bmgr_pool_configure(const struct bmgr_pool_params * const pool_params,
 		goto free_memory;
 
 	val = BMGR_DEFAULT_PCU_FIFO_LOW_THRESHOLD;
+	val /= pool_params->num_pools;
 	status = bmgr_set_pcu_fifo_prog_empty(*pool_id, val);
 	if (status != RC_SUCCESS)
 		goto free_memory;
 
 	val = BMGR_DEFAULT_PCU_FIFO_HIGH_THRESHOLD;
+	val /= pool_params->num_pools;
 	status = bmgr_set_pcu_fifo_prog_full(*pool_id, val);
 	if (status != RC_SUCCESS)
 		goto free_memory;
diff --git a/drivers/net/ethernet/lantiq/ppv4/bm/pp_bm_drv.h b/drivers/net/ethernet/lantiq/ppv4/bm/pp_bm_drv.h
index f033d3a903a5..6cb9c9de31b2 100644
--- a/drivers/net/ethernet/lantiq/ppv4/bm/pp_bm_drv.h
+++ b/drivers/net/ethernet/lantiq/ppv4/bm/pp_bm_drv.h
@@ -81,6 +81,8 @@ struct bmgr_pool_params {
 	u32	base_addr_low;
 	//!< Base address of the pool (high)
 	u32	base_addr_high;
+	//!< Total number of pools
+	u32	num_pools;
 };
 
 /**************************************************************************
