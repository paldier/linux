From e2c7a842e5a8ec211464a2b3601ea44f344b7dc1 Mon Sep 17 00:00:00 2001
From: Li Yin <yin1.li@intel.com>
Date: Thu, 9 May 2019 11:11:51 +0800
Subject: [PATCH] datapath: use generic TX error handling in LGM platform

---
 drivers/net/datapath/dpm/gswip32/datapath_tx.c | 121 +++++--------------------
 1 file changed, 22 insertions(+), 99 deletions(-)

diff --git a/drivers/net/datapath/dpm/gswip32/datapath_tx.c b/drivers/net/datapath/dpm/gswip32/datapath_tx.c
index 9602ea3feb08..1a32c6a2b46e 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_tx.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_tx.c
@@ -185,7 +185,7 @@ int32_t dp_xmit_32(struct net_device *rx_if, dp_subif_t *rx_subif,
 	struct pmac_tx_hdr pmac = {0};
 	u32 ip_offset, tcp_h_offset, tcp_type;
 	char tx_chksum_flag = 0; /*check csum cal can be supported or not */
-	enum dp_xmit_errors err_ret = 0;
+	enum dp_xmit_errors err_ret;
 	int inst = 0;
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_PTP1588)
 	struct mac_ops *ops;
@@ -201,34 +201,22 @@ int32_t dp_xmit_32(struct net_device *rx_if, dp_subif_t *rx_subif,
 	};
 
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_EXTRA_DEBUG)
-	if (unlikely(!dp_init_ok)) {
-		err_ret = DP_XMIT_ERR_NOT_INIT;
-		goto lbl_err_ret;
-	}
-
-	if (unlikely(!rx_subif)) {
-		err_ret = DP_XMIT_ERR_NULL_SUBIF;
-		goto lbl_err_ret;
-	}
+	if (unlikely(!dp_init_ok))
+		return dp_tx_err(skb, &tx.cmn, DP_XMIT_ERR_NOT_INIT);
 
-	if (unlikely(!skb)) {
-		err_ret = DP_XMIT_ERR_NULL_SKB;
-		goto lbl_err_ret;
-	}
+	if (unlikely(!rx_subif))
+		return dp_tx_err(skb, &tx.cmn, DP_XMIT_ERR_NULL_SUBIF);
 
+	if (unlikely(!skb))
+		return dp_tx_err(skb, &tx.cmn, DP_XMIT_ERR_NULL_SKB);
 #endif
 	if (unlikely(tx.cmn.dpid >=
-		     dp_port_prop[inst].info.cap.max_num_dp_ports)) {
-		err_ret = DP_XMIT_ERR_PORT_TOO_BIG;
-		goto lbl_err_ret;
-	}
+		     dp_port_prop[inst].info.cap.max_num_dp_ports))
+		return dp_tx_err(skb, &tx.cmn, DP_XMIT_ERR_PORT_TOO_BIG);
 
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_EXTRA_DEBUG)
-	if (unlikely(in_irq())) {
-		err_ret = DP_XMIT_ERR_IN_IRQ;
-		goto lbl_err_ret;
-	}
-
+	if (unlikely(in_irq()))
+		return dp_tx_err(skb, &tx.cmn, DP_XMIT_ERR_IN_IRQ);
 #endif
 	tx.port = get_dp_port_info(inst, tx.cmn.dpid);
 	tx.cmn.vap = GET_VAP(rx_subif->subif, tx.port->vap_offset,
@@ -240,10 +228,8 @@ int32_t dp_xmit_32(struct net_device *rx_if, dp_subif_t *rx_subif,
 		tx.cmn.flags &= ~DP_TX_FLAG_INSERT_PMAC;
 
 	if (unlikely(!rx_if && /*For atm pppoa case, rx_if is NULL now */
-		     !(tx.port->alloc_flags & DP_F_FAST_DSL))) {
-		err_ret = DP_XMIT_ERR_NULL_IF;
-		goto lbl_err_ret;
-	}
+		     !(tx.port->alloc_flags & DP_F_FAST_DSL)))
+		return dp_tx_err(skb, &tx.cmn, DP_XMIT_ERR_NULL_IF);
 
 	if (unlikely(dp_dbg_flag))
 		dp_xmit_dbg("\nOrig", skb, tx.cmn.dpid, len, flags,
@@ -263,8 +249,8 @@ int32_t dp_xmit_32(struct net_device *rx_if, dp_subif_t *rx_subif,
 		int ret_flg;
 
 		if (!dp_port_prop[inst].info.check_csum_cap()) {
-			err_ret = DP_XMIT_ERR_CSM_NO_SUPPORT;
-			goto lbl_err_ret;
+			return dp_tx_err(skb, &tx.cmn,
+					 DP_XMIT_ERR_CSM_NO_SUPPORT);
 		}
 
 		ret_flg = get_offset_clear_chksum(skb, &ip_offset,
@@ -321,17 +307,13 @@ int32_t dp_xmit_32(struct net_device *rx_if, dp_subif_t *rx_subif,
 		{
 			ops = dp_port_prop[inst].mac_ops[tx.port->port_id];
 
-			if (!ops) {
-				err_ret = DP_XMIT_PTP_ERR;
-				goto lbl_err_ret;
-			}
+			if (!ops)
+				return dp_tx_err(skb, &tx.cmn, DP_XMIT_PTP_ERR);
 
 			rec_id = ops->do_tx_hwts(ops, skb);
 
-			if (rec_id < 0) {
-				err_ret = DP_XMIT_PTP_ERR;
-				goto lbl_err_ret;
-			}
+			if (rec_id < 0)
+				return dp_tx_err(skb, &tx.cmn, DP_XMIT_PTP_ERR);
 
 			DP_CB(inst, get_dma_pmac_templ)(TEMPL_PTP, &pmac,
 							desc_0, desc_1,
@@ -425,68 +407,9 @@ int32_t dp_xmit_32(struct net_device *rx_if, dp_subif_t *rx_subif,
 	}
 
 	err_ret = dp_tx_start(skb, &tx.cmn);
-	if (!err_ret)
+	if (unlikely(err_ret))
+		return dp_tx_err(skb, &tx.cmn, err_ret);
+	else
 		return 0;
-
-lbl_err_ret:
-
-	switch (err_ret) {
-	case DP_XMIT_ERR_NOT_INIT:
-		PR_RATELIMITED("dp_xmit failed for dp no init yet\n");
-		break;
-
-	case DP_XMIT_ERR_IN_IRQ:
-		PR_RATELIMITED("dp_xmit not allowed in interrupt context\n");
-		break;
-
-	case DP_XMIT_ERR_NULL_SUBIF:
-		PR_RATELIMITED("dp_xmit failed for rx_subif null\n");
-		UP_STATS(get_dp_port_info(inst, 0)->tx_err_drop);
-		break;
-
-	case DP_XMIT_ERR_PORT_TOO_BIG:
-		UP_STATS(get_dp_port_info(inst, 0)->tx_err_drop);
-		PR_RATELIMITED("rx_subif->port_id >= max_ports");
-		break;
-
-	case DP_XMIT_ERR_NULL_SKB:
-		PR_RATELIMITED("skb NULL");
-		UP_STATS(tx.port->tx_err_drop);
-		break;
-
-	case DP_XMIT_ERR_NULL_IF:
-		UP_STATS(tx.cmn.mib->tx_pkt_dropped);
-		PR_RATELIMITED("rx_if NULL");
-		break;
-
-	case DP_XMIT_ERR_REALLOC_SKB:
-		PR_INFO_ONCE("dp_create_new_skb failed\n");
-		break;
-
-	case DP_XMIT_ERR_EP_ZERO:
-		PR_ERR("Why ep zero in dp_xmit for %s\n",
-		       skb->dev ? skb->dev->name : "NULL");
-		break;
-
-	case DP_XMIT_ERR_GSO_NOHEADROOM:
-		PR_ERR("No enough skb headerroom(GSO). Need tune SKB buffer\n");
-		break;
-
-	case DP_XMIT_ERR_CSM_NO_SUPPORT:
-		PR_RATELIMITED("dp_xmit not support checksum\n");
-		break;
-
-	case DP_XMIT_PTP_ERR:
-		break;
-
-	default:
-		UP_STATS(tx.cmn.mib->tx_pkt_dropped);
-		PR_INFO_ONCE("Why come to here:%x\n", tx.port->status);
-	}
-
-	if (skb)
-		dev_kfree_skb_any(skb);
-
-	return DP_FAILURE;
 }
 
