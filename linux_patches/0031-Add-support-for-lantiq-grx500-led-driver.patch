From 5f421ffab7b2727863112f8e69bbec07a36fe1c2 Mon Sep 17 00:00:00 2001
From: Hua Ma <hua.ma@linux.intel.com>
Date: Thu, 21 Jun 2018 17:37:57 +0800
Subject: [PATCH] Add support for lantiq grx500 led driver

---
 drivers/leds/leds-xrx500-config.h | 277 +++++++++++++
 drivers/leds/leds-xrx500-proc.c   | 828 ++++++++++++++++++++++++++++++++++++++
 drivers/leds/leds-xrx500.c        | 508 +++++++++++++++++++++++
 3 files changed, 1613 insertions(+)

diff --git a/drivers/leds/leds-xrx500-config.h b/drivers/leds/leds-xrx500-config.h
new file mode 100644
index 000000000000..ddaeba530c58
--- /dev/null
+++ b/drivers/leds/leds-xrx500-config.h
@@ -0,0 +1,277 @@
+#ifndef __LEDS_XRX500_CONFIG_H
+#define __LEDS_XRX500_CONFIG_H
+
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/leds.h>
+#include <lantiq_soc.h>
+#include <linux/gpio/driver.h>
+
+#define NUM_LEDS 32
+
+/*
+ *  Definition of Operation MASK
+ */
+/*!
+  \def XRX500_SSO_CFG_OP_UPDATE_SHADOW
+  \brief field "operation_mask" of struct "xrx500_sso_config_param" - Predefined LED ON bits.
+ */
+#define XRX500_SSO_CFG_OP_UPDATE_SHADOW       0x0001
+/*!
+  \def XRX500_SSO_CFG_OP_BLINK_MASK
+  \brief field "operation_mask" of struct "xrx500_sso_config_param" - Reserve the bits needed for HW blink.
+ */
+#define XRX500_SSO_CFG_OP_BLINK_MASK         0x0002
+/*!
+  \def XRX500_SSO_CFG_OP_UPDATE_CLOCK
+  \brief field "operation_mask" of struct "xrx500_sso_config_param" - Select update clock source
+ */
+#define XRX500_SSO_CFG_OP_UPDATE_CLOCK        0x0004
+/*!
+  \def XRX500_SSO_CFG_OP_UPDATE_FPID
+  \brief field "operation_mask" of struct "xrx500_sso_config_param" - Select the FPID value
+ */
+#define XRX500_SSO_CFG_OP_UPDATE_FPID      0x0008
+/*!
+  \def XRX500_SSO_CFG_OP_UPDATE_FCDSC
+  \brief field "operation_mask" of struct "xrx500_sso_config_param" - Select the FCDSC value
+ */
+#define XRX500_SSO_CFG_OP_UPDATE_FCDSC      0x0010
+/*!
+  \def XRX500_SSO_CFG_OP_UPDATE_GPTD
+  \brief field "operation_mask" of struct "xrx500_sso_config_param" - Select the GPTD value
+ */
+#define XRX500_SSO_CFG_OP_UPDATE_GPTD      0x0020
+/*!
+  \def XRX500_SSO_CFG_OP_BLINK_RATE
+  \brief field "operation_mask" of struct "xrx500_sso_config_param" - Blink rate can be different from update rate for LEDs 0-23
+ */
+#define XRX500_SSO_CFG_OP_BLINK_RATE      0x0040
+/*!
+  \def XRX500_SSO_CFG_OP_INDIVIDUAL_BLINK_SOURCE
+  \brief field "operation_mask" of struct "xrx500_sso_config_param" - Blink rate can be unique for each of the LEDs from 24-31
+ */
+#define XRX500_SSO_CFG_OP_INDIVIDUAL_BLINK_SOURCE      0x0080
+/*!
+  \def XRX500_SSO_CFG_OP_BLINK_SOURCE_0_23
+  \brief field "operation_mask" of struct "xrx500_sso_config_param" - Blink rate for leds 0-23, if the blink rate has to be different from update rate
+ */
+#define XRX500_SSO_CFG_OP_BLINK_SOURCE_0_23             0x0100
+/*
+* The Serial Shift Output (SSO) is found on MIPS based Lantiq xrx500 socs.
+*It is a peripheral controller used to drive external shift register
+*cascades. At most 4 groups of 8 bits can be driven.
+*/
+
+/* control register 0 */
+#define XRX500_SSO_CON0		0x2B0
+/* control register 1 */
+#define XRX500_SSO_CON1		0x2B4
+/* data register 0 */
+#define XRX500_SSO_CPU0		0x2B8
+/* data register 1 */
+#define XRX500_SSO_CPU1		0x2BC
+/* access register */
+#define XRX500_SSO_AR		0x2C0
+/* control register 2 */
+#define XRX500_SSO_CON2		0x2C4
+/* control register 3 */
+#define XRX500_SSO_CON3		0x2C8
+
+/*blink control*/
+#define XRX500_SSO_BLINK_H8_0    0x0
+#define XRX500_SSO_BLINK_H8_1    0x4
+#define XRX500_SSO_BLINK_SOURCE_SHIFT 22
+/*Dutycycle register*/
+#define XRX500_SSO_DUTYCYCLE_BASE      0x8
+#define XRX500_SSO_DUTYCYCLE_OFFSET    0x4
+
+/* software or hardware update select bit */
+#define XRX500_SSO_CON_SWU	BIT(31)
+
+/* Blink rate select bit */
+#define XRX500_SSO_BLINK_RATE_SHIFT	30
+#define XRX500_SSO_BLINK_RATE_MASK	BIT(30)
+
+/* clock source for update */
+#define XRX500_SSO_UPD_SHIFT	30
+#define XRX500_SSO_UPD_MASK	0xc0000000
+
+
+/* FPID */
+#define XRX500_SSO_FPID_SHIFT	23
+#define XRX500_SSO_FPID_MASK	0x1800000
+
+/* FCDSE */
+#define XRX500_SSO_FCDSC_SHIFT	20
+#define XRX500_SSO_FCDSC_MASK	0x300000
+
+/* GPTD */
+#define XRX500_SSO_GPTD_SHIFT	25
+#define XRX500_SSO_GPTD_MASK	0x6000000
+
+/*PHY control*/
+#define XRX500_SSO_PHY_MASK     0x7
+#define XRX500_SSO_LD0_MASK 	0x1F
+#define XRX500_SSO_LD1_MASK     0x1F00
+#define XRX500_SSO_LD2_MASK     0x1F0000
+
+#define XRX500_SSO_LD0_SHIFT	0
+#define XRX500_SSO_LD1_SHIFT	8
+#define XRX500_SSO_LD2_SHIFT	16
+
+#define XRX500_SSO_PHY6_SHIFT_FACTOR	0
+#define XRX500_SSO_PHY2_SHIFT_FACTOR	1
+#define XRX500_SSO_PHY3_SHIFT_FACTOR	2
+#define XRX500_SSO_PHY4_SHIFT_FACTOR    3
+#define XRX500_SSO_PHY5_SHIFT_FACTOR    4
+
+#define XRX500_SSO_LD0_PATTERN(phy6, phy2, phy3, phy4, phy5) \
+						(((phy6 & BIT(0))\
+						| ((phy2 & BIT(0)) << 1)\
+						| ((phy3 & BIT(0)) << 2)\
+						|((phy4 & BIT(0)) << 3)\
+						|((phy5 & BIT(0)) << 4)\
+						) << XRX500_SSO_LD0_SHIFT)
+#define XRX500_SSO_LD1_PATTERN(phy6, phy2, phy3, phy4, phy5) \
+					((((phy6 & BIT(1)) >> 1)\
+					| (((phy2 & BIT(1)) >> 1) << 1)\
+					| (((phy3 & BIT(1)) >> 1) << 2)\
+					| (((phy4 & BIT(1)) >> 1) << 3)\
+					| (((phy5 & BIT(1)) >> 1) << 4)\
+					) << XRX500_SSO_LD1_SHIFT)
+#define XRX500_SSO_LD2_PATTERN(phy6, phy2, phy3, phy4, phy5) \
+					((((phy6 & BIT(2)) >> 2)\
+					| (((phy2 & BIT(2)) >> 2) << 1)\
+					| (((phy3 & BIT(2)) >> 2) << 2)\
+					| (((phy4 & BIT(2)) >> 2) << 3)\
+					| (((phy5 & BIT(2)) >> 2) << 4)\
+					) << XRX500_SSO_LD2_SHIFT)
+
+/*WLAN control*/
+#define XRX500_SSO_WLAN_MASK	0x7
+#define XRX500_SSO_W1_W2_W3_MASK	0xE0
+#define XRX500_SSO_W4_W5_W6_MASK	0xE000
+
+#define XRX500_SSO_W1_W2_W3_SHIFT	5
+#define XRX500_SSO_W4_W5_W6_SHIFT	13
+
+#define XRX500_SSO_W1_W2_W3_PATTERN(wlan)	\
+	((wlan & 0x7) << XRX500_SSO_W1_W2_W3_SHIFT)
+#define XRX500_SSO_W4_W5_W6_PATTERN(wlan)	\
+	(((wlan & 0x38) >> 7) << XRX500_SSO_W4_W5_W6_SHIFT)
+
+/*SSO has 3 groups of 8 bits */
+#define XRX500_SSO_GROUP0		BIT(0)
+#define XRX500_SSO_GROUP1		BIT(1)
+#define XRX500_SSO_GROUP2		BIT(2)
+#define XRX500_SSO_GROUP3		BIT(3)
+#define XRX500_SSO_GROUP_MASK		(0xF)
+
+/* Edge configuration bits */
+#define XRX500_SSO_FALLING	BIT(26)
+#define XRX500_SSO_EDGE_MASK	BIT(26)
+#define XRX500_SSO_EDGE_SHIFT 26
+
+/*Dutycycle configuration bit*/
+#define XRX500_SSO_DUTYCYCLE(led)	\
+	(XRX500_SSO_DUTYCYCLE_BASE + (led * XRX500_SSO_DUTYCYCLE_OFFSET))
+
+/*Auto Dimming function*/
+#define XRX500_SSO_DIMM_ENABLE_MASK 0x8000000
+#define XRX500_SSO_DIMM_ENABLE_SHIFT 27
+#define XRX500_SSO_LUX_INTERVAL_MASK 0xF00
+#define XRX500_SSO_LUX_INTERVAL_SHIFT 8
+#define XRX500_SSO_LUX_DISCHARGE_MASK 0x3F000
+#define XRX500_SSO_LUX_DISCHARGE_SHIFT 12
+#define XRX500_SSO_LUX_LEVEL_MASK 0xFF
+#define XRX500_SSO_LUX_LEVEL_SHIFT 0
+
+/*Data offset*/
+#define XRX500_SSO_DATA_OFFSET_MASK 0xc0000
+#define XRX500_SSO_DATA_OFFSET_SHIFT 18
+
+/*Store Mode*/
+#define XRX500_SSO_STORE_MODE_MASK 0x10000000
+#define XRX500_SSO_STORE_MODE_SHIFT 28
+
+#define xrx500_sso_r32(m, reg)		__raw_readl(m + reg)
+#define xrx500_sso_w32(m, val, reg)	__raw_writel(val, m + reg)
+#define xrx500_sso_w32_mask(m, clear, set, reg) \
+		ltq_w32((ltq_r32(m + reg) & ~(clear)) | (set), \
+		m + reg)
+		
+enum xrx500_sso_CON1_us
+{
+	LED_CON1_UPDATE_SRC_SW = 0,
+	LED_CON1_UPDATE_SRC_GPTD2,
+	LED_CON1_UPDATE_SRC_FPID,
+};
+
+enum xrx500_sso_H8_us
+{
+	LED_H8_UPDATE_SRC_FPID = 0,
+	LED_H8_UPDATE_SRC_GPTD,
+	LED_H8_UPDATE_SRC_VIM,
+};
+
+enum xrx500_sso_fsc_divider 
+{
+	LED_FSC_2HZ = 0,
+	LED_FSC_4HZ,
+	LED_FSC_8HZ,
+	LED_FSC_10HZ,
+};
+
+enum xrx500_sso_gptd_divider
+{
+	LED_GPTD_50HZ = 0,
+	LED_GPTD_100HZ,
+	LED_GPTD_200HZ,
+	LED_GPTD_250HZ,
+};
+
+
+struct xrx500_sso_freq_table {
+	u32 value;
+	u32 range_start;
+	u32 range_end;
+};
+
+struct xrx500_sso {
+	struct gpio_chip gc;
+	void __iomem *virt;
+	u32 edge;	/* rising or falling edge triggered shift register */
+	u32 shadow;	/* shadow the shift registers state */
+	u8 groups;	/* we can drive 1 groups of 8bit each */
+	u8 phy2;	/* 3 bits can be driven by phy2 */
+	u8 phy3;	/* 3 bits can be driven by phy3 */
+	u8 phy4;	/* 3 bits can be driven by phy4 */
+	u8 phy5;	/* 3 bits can be driven by phy5 */
+	u8 phy6;	/* 3 bits can be driven by phy6 */
+	u8 upd;	/* 2 bits for update source*/
+	u32 blink_mask;
+	u32 blink_rate;
+	u32 blink_source_24_31[8];
+	u32 blink_source_0_23;
+	u8 wlan;	/*6 bits for WLAN*/
+	u8 reserved;	/* mask out the hw driven bits in gpio_request */
+};
+
+struct xrx500_sso_led {
+	struct led_classdev     device;             /*!< LED device */
+	const char *name;
+	const char *default_trigger;
+	unsigned	phys_id;
+	unsigned	active_low:1;
+	unsigned	retain_state_suspended:1;
+	unsigned	default_state:2;
+	struct work_struct work;
+	u8 new_level;
+	u8 can_sleep;
+	u8 blinking;
+};
+
+int get_cpu_select(void);
+int grx500_register_sysfs(struct platform_device *pdev);
+#endif
diff --git a/drivers/leds/leds-xrx500-proc.c b/drivers/leds/leds-xrx500-proc.c
new file mode 100644
index 000000000000..8c801f648308
--- /dev/null
+++ b/drivers/leds/leds-xrx500-proc.c
@@ -0,0 +1,828 @@
+
+#include "leds-xrx500-config.h"
+
+#ifdef CONFIG_LEDS_CLASS
+struct led_sysfs_help {
+	char *cmd;		
+	char *help;	
+	char *usage;	
+};
+static struct led_sysfs_help help_entries[] = {
+{"hw_blink_en",
+ "\r\nA mask to enable or disable the HW blink for all the individual LEDs\r\n",
+ "\r\ncat hw_blink_en -> prints the HW blink mask\r\n \
+      echo 0x2A0 > hw_blink_en -> e.g)To enable HW blink for leds 5, 7, 9"},
+{"auto_dimming_en",
+ "\r\nEnable/Disable HW dimming function\r\n",
+ "\r\ncat auto_dimming_en -> prints the current status of HW dimming feature\r\n \
+      echo 0x1 > auto_dimming_en -> e.g)To enable HW dimming\r\n \
+	  echo 0x0 > auto_dimming_en -> e.g)To disable HW dimming"},
+{"blink_rate",
+"\r\nSet this bit to have a blink rate different from update rate for LEDs[0-23]\r\n",
+"\r\ncat blink_rate -> prints the Blink rate Update control\r\n \
+echo 0x1 > blink_rate -> e.g)Blink rate is different from Update rate\r\n \
+echo 0x0 > blink_rate -> e.g)Blink rate is same as Update rate" },
+{"cpu_select",
+"\r\nselect cpu for data source\r\n",
+"\r\ncat cpu_select -> prints the data source \r\n \
+echo 0 > cpu_select -> sets cpu 0 as the source\r\n \
+echo 1 > cpu_select -> sets cpu 1 as the source\r\n"},
+{"data_offset",
+"\r\nset the offset of the LED shift clock before data out\r\n",
+"\r\ncat data_offset -> prints the data_offset setting\r\n \
+echo  0 > data_offset ->possible input values are 0,1,2,3"},
+{"fpi_shift",
+"\r\nFixed Divider Shift Clock\r\n",
+"\r\ncat fpi_shift -> prints the current fpi_shift setting\r\n \
+echo  0 > fpi_shift ->possible input values are 0,1,2,3"},
+{"fpi_update",
+"\r\nFSC Divider for LED [23:0]\r\n",
+"\r\ncat fpi_update -> prints the current fpi_update setting\r\n \
+echo  0 > fpi_update ->possible input values are 0,1,2,3"},
+{"gptc_divider",
+"\r\nGPT Divider for LED[23:0]\r\n",
+"\r\ncat gptc_divider -> prints the current gptc_divider setting\r\n \
+echo  0 > gptc_divider ->possible input values are 0,1,2,3"},
+{"number_of_leds",
+"\r\nLED group information (Read Only)\r\n",
+"\r\ncat number_of_leds -> prints one of the following values 0, 8, 16, 24, 32\r\n"},
+{"lux_dis", 
+"\r\ndischarge time is this programmed 6 bitvalue x LUX_CNV_INT period programmed\r\n",
+"\r\ncat lux_dis -> prints the current value\r\n \
+echo 10 > lux_dis -> sets the current value to 10\r\n"},
+{"lux_cnv_interval", 
+"\r\nProgrammable divider for intervals used by LUX conversion\r\n",
+"\r\ncat lux_cnv_interval ->prints the current LUX interval value\r\n \
+echo 0 > lux_cnv_interval -> writes 0 to lux_cnv_interval, possible values are the following \
+0  DO no division of 2560Hz\r\n \
+1  D1 division of 2, equals to 1280Hz\r\n \
+2  D2 Division of 4, equals to 640Hz\r\n \
+3  D3 Division of 8, equals to 320Hz\r\n \
+4  D4 Division of 16, equals to 160Hz\r\n \
+5  D5 Division of 32, equals to 80Hz\r\n \
+6  D6 Division of 64, equals to 40HZ\r\n \
+7  D7 Division of 128, equals to 20Hz\r\n \
+8  D8 Division of 256, equals to 10 Hz\r\n \
+9  D9 Division of 512, equals to 5Hz\r\n \
+A  D10 Division of 1024, equals to 2.5Hz\r\n \
+B  D11 Division of 2048, equals to 1.25Hz\r\n \
+"},
+{"lux_lvl",
+"\r\nLUX Level Converted by Hardware (Read Only)\r\n",
+"\r\ncat lux_lvl -> prints the current calculated value of LUX level\r\n"},
+{"store_mode",
+"\r\nSetting to switch between LED single pulse mode or inverted shift clock during update",
+"\r\ncat store_mode -> prints the current store _mode\r\n \
+echo 1 > store_mode ->sets the value to 1, possible values are the following \
+0 Single\r\n \
+1 Clock \r\n"},
+{"update_clock_source",
+"\r\nUpdate Source for LEDS\r\n",
+"\r\ncat update_clock_source -> prints the current update source\r\n \
+echo SW > update_clock_source, possible values are the following \
+SW\r\n\
+GPT\r\n\
+FPI\r\n \
+"},
+{"update_edge",
+"\r\nData Clocking Edge\r\n",
+"\r\ncat update_edge ->prints the data clocking edge\r\n \
+echo 0 > update_edge -> to define if the data output is clocked at rising edge\r\n \
+echo 1 > update_edge -> to define if the data output is clocked at falling edge\r\n"},
+/*{"update_src",
+"\r\nSwitch the LED source between LEDc and External hardware\r\n",
+"\r\ncat update_src -> prints the current setting\r\n \
+echo ledc > update_src ->LED to be controlled by LEDc\r\n\
+echo ext > update_src ->LED to be controlled by the External HW"},*/
+{"blink_src",
+"\r\nselect the blink source corresponding to each LED in the range of 24 - 31\r\n",
+"\r\ncat blink_src -> prints the current blink source for that LED\r\n \
+echo FPID > blink_src ->sets the blink source to FPID, possible values are\r\n \
+FPID ->blink at FPID output rate\r\n \
+GPTD ->blink at GPT output rate\r\n \
+V1M ->blink at GPT high speed output rate\r\n \
+LEDS[24-31] have individual setting for blink source"},
+{"blink_src_0_23",
+"\r\nselect the blink source for LEDs in the range of LEDs 0 - 23\r\n",
+"\r\ncat blink_src -> prints the current blink source for LEDs 0 - 23\r\n \
+echo FPID > blink_src ->sets the blink source to FPID, possible values are\r\n \
+FPID ->blink at FPID output rate\r\n \
+GPTD ->blink at GPT output rate\r\n \
+V1M ->blink at GPT high speed output rate\r\n \
+LEDS[0-23] have a common setting for blink source which is only valid if blink_rate is set to 1"}
+};
+static struct xrx500_sso *g_chip;
+static int cpu_select = 0;
+static ssize_t grx500_blink_src_0_23_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf);	
+static ssize_t grx500_blink_src_0_23_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len);
+static DEVICE_ATTR(blink_src_0_23, S_IRUGO | S_IWUSR,
+		grx500_blink_src_0_23_show, grx500_blink_src_0_23_store);
+	
+int get_cpu_select() {
+	return cpu_select;
+}
+
+static ssize_t grx500_led_usage_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	ssize_t status = 0, temp = 0;
+	int i, n;
+	char *str = buf;
+	n = sprintf(str, "%s         %s\r\n","Command", "Description");	
+	str += n;
+	status += n;
+
+	for (i = 0; i < sizeof(help_entries) / sizeof(help_entries[0]);
+	     i++) {
+		temp = sprintf(str, "%s  %s\r\n", help_entries[i].cmd, help_entries[i].help);
+		str += temp;
+		status += temp;
+		
+	}
+	return status;
+}
+
+static ssize_t grx500_led_usage_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t len)
+{
+	ssize_t   status = 0;
+	int i;
+	char *buff = (char *)buf;
+	char *token = NULL;
+	token = strsep(&buff, " "); 
+	if (token != 0) {
+		for (i = 0; i < sizeof(help_entries) / sizeof(help_entries[0]);
+	     i++) {
+			//if(strncmp(help_entries[i].cmd, token, strlen(help_entries[i].cmd)) == 0) {
+			if(strncmp(help_entries[i].cmd, token, strlen(token) - 1) == 0) {
+
+				printk("%s\r\n", help_entries[i].usage);	
+				break;
+			}				
+		}
+	} else {
+		status = -EINVAL;
+		pr_err("Invalid Command\r\n");
+	
+	}
+	return status ? : len;
+}
+
+static DEVICE_ATTR(led_usage, S_IRUGO | S_IWUSR,
+		grx500_led_usage_show, grx500_led_usage_store);
+			
+static ssize_t grx500_blink_rate_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	ssize_t status = 0;
+	g_chip->blink_rate = (xrx500_sso_r32(g_chip->virt, XRX500_SSO_CON0) & XRX500_SSO_BLINK_RATE_MASK) >> XRX500_SSO_BLINK_RATE_SHIFT;
+	status = sprintf(buf, "0x%x\n", g_chip->blink_rate);
+	return status;
+}
+
+static ssize_t grx500_blink_rate_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t len)
+{
+	ssize_t   status = 0;
+	int rc;
+	long value;
+	status = kstrtol(buf, 0, &value);
+	if (status == 0) {
+		if ((value >= 0) && (value <= 1)) {
+			g_chip->blink_rate = value;
+			xrx500_sso_w32_mask(g_chip->virt,
+			XRX500_SSO_BLINK_RATE_MASK,
+			g_chip->blink_rate << XRX500_SSO_BLINK_RATE_SHIFT,
+			XRX500_SSO_CON0);
+			if(value) {
+				rc = device_create_file(dev, &dev_attr_blink_src_0_23);
+				if (rc)
+					pr_err("Error creating attribute blink_src_0_23");
+			} else {
+				device_remove_file(dev, &dev_attr_blink_src_0_23);
+			}
+		} else {
+			status = -EINVAL;
+			pr_err("Valid input is 0 or 1\r\n");
+		}
+	}
+	return status ? : len;
+}
+
+static DEVICE_ATTR(blink_rate, S_IRUGO | S_IWUSR,
+		grx500_blink_rate_show, grx500_blink_rate_store);
+		
+static ssize_t grx500_blink_en_show(struct device *dev,
+	struct device_attribute *attr,
+	char *buf)
+{
+	ssize_t status = 0;
+	status = sprintf(buf, "0x%x\n", g_chip->blink_mask);
+	return status;
+}
+
+static ssize_t grx500_blink_en_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t len)
+{
+	ssize_t   status = 0;
+	unsigned long value;
+	status = kstrtoul(buf, 0, &value);
+	if (status == 0) {
+		if ((value >= 0) && (value <= 0xffffffff)) {
+			g_chip->blink_mask = value;
+		} else {
+			status = -EINVAL;
+			pr_err("Valid input is from 0x0 - 0xffffffff\r\n");
+		}
+	}
+	return status ? : len;
+}
+
+static DEVICE_ATTR(hw_blink_en, S_IRUGO | S_IWUSR,
+		grx500_blink_en_show, grx500_blink_en_store);
+		
+static ssize_t grx500_cpu_select_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	ssize_t status = 0;
+	status = sprintf(buf, "%d\n", cpu_select);
+	return status;
+}
+
+static ssize_t grx500_cpu_select_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t len)
+{
+	ssize_t   status = 0;
+	long value;
+	status = kstrtol(buf, 0, &value);
+	if (status == 0) {
+		if ((value >= 0) && (value <= 1)) {
+			cpu_select = value;
+		} else {
+			status = -EINVAL;
+			pr_err("Valid input is 0 or 1\r\n");
+		}
+	}
+	return status ? : len;
+}
+
+static DEVICE_ATTR(cpu_select, S_IRUGO | S_IWUSR,
+		grx500_cpu_select_show, grx500_cpu_select_store);
+		
+static ssize_t grx500_gptc_divider_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	u32 reg;
+	ssize_t status = 0;
+	reg = xrx500_sso_r32(g_chip->virt, XRX500_SSO_CON1);
+	status = sprintf(buf, "%d\n",
+	(reg & XRX500_SSO_GPTD_MASK)  >> XRX500_SSO_GPTD_SHIFT);
+	return status;
+}
+
+static ssize_t grx500_gptc_divider_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t len)
+{
+	ssize_t   status = 0;
+	long value;
+	status = kstrtol(buf, 0, &value);
+	if (status == 0) {
+		if ((value >= 0) && (value <= 3)) {
+			xrx500_sso_w32_mask(g_chip->virt,
+			XRX500_SSO_GPTD_MASK,
+			value << XRX500_SSO_GPTD_SHIFT, XRX500_SSO_CON1);
+		} else {
+			status = -EINVAL;
+		}
+	}
+	return status ? : len;
+
+}
+
+static DEVICE_ATTR(gptc_divider, S_IRUGO | S_IWUSR,
+		grx500_gptc_divider_show, grx500_gptc_divider_store);
+
+static ssize_t grx500_fpi_shift_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	u32 reg;
+	ssize_t status = 0;
+	reg = xrx500_sso_r32(g_chip->virt, XRX500_SSO_CON1);
+	status = sprintf(buf, "%d\n",
+	(reg & XRX500_SSO_FCDSC_MASK)  >> XRX500_SSO_FCDSC_SHIFT);
+	return status;
+}
+
+static ssize_t grx500_fpi_shift_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	ssize_t status = 0;
+	long value;
+	status = kstrtol(buf, 0, &value);
+	if (status == 0) {
+		if ((value >= 0) && (value <= 3)) {
+			xrx500_sso_w32_mask(g_chip->virt,
+			XRX500_SSO_FCDSC_MASK,
+			value << XRX500_SSO_FCDSC_SHIFT, XRX500_SSO_CON1);
+		} else {
+			status = -EINVAL;
+		}
+	}
+	return status ? : len;
+
+}
+
+static DEVICE_ATTR(fpi_shift, S_IRUGO | S_IWUSR,
+		grx500_fpi_shift_show, grx500_fpi_shift_store);
+
+static ssize_t grx500_fpi_update_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	u32 reg;
+	ssize_t status = 0;
+
+	reg = xrx500_sso_r32(g_chip->virt, XRX500_SSO_CON1);
+	status = sprintf(buf, "%d\n",
+	(reg & XRX500_SSO_FPID_MASK) >> XRX500_SSO_FPID_SHIFT);
+	return status;
+}
+
+static ssize_t grx500_fpi_update_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	ssize_t status = 0;
+	long value;
+	status = kstrtol(buf, 0, &value);
+
+
+	if (status == 0) {
+		if ((value >= 0) && (value <= 3)) {
+			xrx500_sso_w32_mask(g_chip->virt,
+			XRX500_SSO_FPID_MASK,
+			value << XRX500_SSO_FPID_SHIFT, XRX500_SSO_CON1);
+		} else {
+			status = -EINVAL;
+		}
+	}
+	return status ? : len;
+}
+
+static DEVICE_ATTR(fpi_update, S_IRUGO | S_IWUSR,
+		grx500_fpi_update_show, grx500_fpi_update_store);
+
+static ssize_t grx500_update_edge_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	u32 reg;
+	ssize_t status = 0;
+	reg = xrx500_sso_r32(g_chip->virt, XRX500_SSO_CON0);
+	status = sprintf(buf, "%lu\n",
+	(reg & XRX500_SSO_EDGE_MASK) >> XRX500_SSO_EDGE_SHIFT);
+	return status;
+}
+
+static ssize_t grx500_update_edge_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	ssize_t status = 0;
+	long value;
+	status = kstrtol(buf, 0, &value);
+	if (status == 0) {
+		if ((value >= 0) && (value <= 1)) {
+			xrx500_sso_w32_mask(g_chip->virt, XRX500_SSO_EDGE_MASK,
+			value << XRX500_SSO_EDGE_SHIFT, XRX500_SSO_CON0);
+		} else {
+			status = -EINVAL;
+		}
+	}
+	return status ? : len;
+}
+
+static DEVICE_ATTR(update_edge, S_IRUGO | S_IWUSR,
+		grx500_update_edge_show, grx500_update_edge_store);
+
+static ssize_t grx500_led_number_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	u32 reg;
+	ssize_t   status = 0;
+
+	reg = xrx500_sso_r32(g_chip->virt, XRX500_SSO_CON1);
+	if ((reg & 0xF) == 0xF)
+		reg = 32;
+	if ((reg & 0x7) == 0x7)
+		reg = 24;
+	if ((reg & 0x3) == 0x3)
+		reg = 16;
+	if ((reg & 0x1) == 0x1)
+		reg = 8;
+	status = sprintf(buf, "%d\n", reg);
+	return status;
+}
+#if 0
+static ssize_t grx500_led_number_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	ssize_t   status = 0;
+	u32 bits = 0, i = 0;
+	long value;
+	status = kstrtol(buf, 0, &value);
+
+
+	if (status == 0) {
+		if (!(((value%8) == 0) && ((value >= 0) && (value <= 32))))
+			return -EINVAL;
+		if (value) {
+			while (value/8) {
+				bits |= BIT(i);
+				i++;
+				value -= 8;
+			}
+			xrx500_sso_w32_mask(g_chip->virt, bits,
+				bits, XRX500_SSO_CON1);
+		} else {
+			xrx500_sso_w32_mask(g_chip->virt, XRX500_SSO_GROUP_MASK,
+				0, XRX500_SSO_CON1);
+		}
+	}
+	return status ? : len;
+
+}
+#endif
+static DEVICE_ATTR(number_of_leds, S_IRUGO | S_IWUSR,
+		grx500_led_number_show, NULL);
+
+static ssize_t grx500_update_clock_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	u32 reg;
+	ssize_t status = 0;
+	reg = xrx500_sso_r32(g_chip->virt, XRX500_SSO_CON1);
+	reg = reg >> XRX500_SSO_UPD_SHIFT;
+	if (reg == 0)
+		status = sprintf(buf, "%s\n", "SW");
+	else if (reg == 1)
+		status = sprintf(buf, "%s\n", "GPT");
+	else if (reg == 2)
+		status = sprintf(buf, "%s\n", "FPI");
+	else
+		status = sprintf(buf, "%s\n", "INVALID");
+	return status;
+}
+
+static ssize_t grx500_update_clock_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	ssize_t status = 0;
+	u32 value;
+	if (sysfs_streq(buf, "SW"))
+		value = 0;
+	else if (sysfs_streq(buf, "GPT"))
+		value = 1;
+	else if (sysfs_streq(buf, "FPI"))
+		value = 2;
+	else
+		status = -EINVAL;
+
+
+	if (status == 0) {
+		xrx500_sso_w32_mask(g_chip->virt,
+			XRX500_SSO_UPD_MASK,
+			value << XRX500_SSO_UPD_SHIFT, XRX500_SSO_CON1);
+		g_chip->upd = value;
+	}
+	return status ? : len;
+}
+static DEVICE_ATTR(update_clock_source, S_IRUGO | S_IWUSR,
+		grx500_update_clock_show, grx500_update_clock_store);
+
+static ssize_t grx500_store_mode_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	u32 reg;
+	ssize_t status = 0;
+	reg = xrx500_sso_r32(g_chip->virt, XRX500_SSO_CON1);
+	reg = (reg & XRX500_SSO_STORE_MODE_MASK) >> XRX500_SSO_STORE_MODE_SHIFT;
+	status = sprintf(buf, "%d\n", reg);
+	return status;
+}
+
+static ssize_t grx500_store_mode_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	ssize_t status = 0;
+	long value;
+
+	status = kstrtol(buf, 0, &value);
+	if (status == 0) {
+		if ((value >= 0) && (value <= 0x1)) {
+			xrx500_sso_w32_mask(g_chip->virt,
+			XRX500_SSO_STORE_MODE_MASK,
+			value << XRX500_SSO_STORE_MODE_SHIFT, XRX500_SSO_CON1);
+		} else {
+			pr_err("Valid input is 0 or 1\r\n");
+			status = -EINVAL;
+		}
+	}
+	return status ? : len;
+}
+
+static DEVICE_ATTR(store_mode, S_IRUGO | S_IWUSR,
+		grx500_store_mode_show, grx500_store_mode_store);
+		
+static ssize_t grx500_data_offset_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	u32 reg;
+	ssize_t status = 0;
+	reg = xrx500_sso_r32(g_chip->virt, XRX500_SSO_CON1);
+	reg = (reg & XRX500_SSO_DATA_OFFSET_MASK)  >> XRX500_SSO_DATA_OFFSET_SHIFT;
+	status = sprintf(buf, "%d\n", reg);
+	return status;
+}
+
+static ssize_t grx500_data_offset_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	ssize_t status = 0;
+	long value;
+
+	status = kstrtol(buf, 0, &value);
+	if (status == 0) {
+		if ((value >= 0) && (value <= 0x3)) {
+			xrx500_sso_w32_mask(g_chip->virt,
+			XRX500_SSO_DATA_OFFSET_MASK,
+			value << XRX500_SSO_DATA_OFFSET_SHIFT, XRX500_SSO_CON1);
+		} else {
+			pr_err("Valid input range is 0x0 - 0x3\r\n");
+			status = -EINVAL;
+		}
+	}
+	return status ? : len;
+}
+
+static DEVICE_ATTR(data_offset, S_IRUGO | S_IWUSR,
+		grx500_data_offset_show, grx500_data_offset_store);
+
+
+static ssize_t grx500_lux_level_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	u32 reg;
+	ssize_t status = 0;
+	reg = xrx500_sso_r32(g_chip->virt, XRX500_SSO_CON0);
+	reg = (reg >> XRX500_SSO_LUX_LEVEL_SHIFT)  & XRX500_SSO_LUX_LEVEL_MASK;
+	status = sprintf(buf, "%d\n", reg);
+	return status;
+}
+
+static DEVICE_ATTR(lux_lvl, S_IRUGO | S_IWUSR,
+		grx500_lux_level_show, NULL);
+
+static ssize_t grx500_lux_discharge_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	u32 reg;
+	ssize_t status = 0;
+	reg = xrx500_sso_r32(g_chip->virt, XRX500_SSO_CON0);
+	reg = (reg & XRX500_SSO_LUX_DISCHARGE_MASK) >> XRX500_SSO_LUX_DISCHARGE_SHIFT;
+	status = sprintf(buf, "%d\n", reg);
+	return status;
+}
+
+static ssize_t grx500_lux_discharge_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	ssize_t status = 0;
+	long value;
+
+	status = kstrtol(buf, 0, &value);
+	if (status == 0) {
+		if ((value >= 0) && (value <= 0x3F)) {
+			xrx500_sso_w32_mask(g_chip->virt,
+			XRX500_SSO_LUX_DISCHARGE_MASK,
+			value << XRX500_SSO_LUX_DISCHARGE_SHIFT, XRX500_SSO_CON0);
+		} else {
+			pr_err("Valid input range is 0x0 - 0x3F\r\n");
+			status = -EINVAL;
+		}
+	}
+	return status ? : len;
+}
+
+static DEVICE_ATTR(lux_dis, S_IRUGO | S_IWUSR,
+		grx500_lux_discharge_show, grx500_lux_discharge_store);
+
+static ssize_t grx500_lux_interval_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	u32 reg;
+	ssize_t status = 0;
+	reg = xrx500_sso_r32(g_chip->virt, XRX500_SSO_CON0);
+	reg = (reg & XRX500_SSO_LUX_INTERVAL_MASK) >> XRX500_SSO_LUX_INTERVAL_SHIFT;
+	status = sprintf(buf, "%d\n", reg);
+	return status;
+}
+
+static ssize_t grx500_lux_interval_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	ssize_t status = 0;
+	long value;
+
+	status = kstrtol(buf, 0, &value);
+	if (status == 0) {
+		if ((value >= 0) && (value <= 0xB)) {
+			xrx500_sso_w32_mask(g_chip->virt,
+			XRX500_SSO_LUX_INTERVAL_MASK,
+			value << XRX500_SSO_LUX_INTERVAL_SHIFT, XRX500_SSO_CON0);
+		} else {
+			status = -EINVAL;
+			pr_err("Valid input range is 0x0 - 0xB\r\n");
+
+		}
+	}
+	return status ? : len;
+}
+
+static DEVICE_ATTR(lux_cnv_interval, S_IRUGO | S_IWUSR,
+		grx500_lux_interval_show, grx500_lux_interval_store);
+
+static ssize_t grx500_dimm_enable_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	u32 reg;
+	ssize_t status = 0;
+	reg = xrx500_sso_r32(g_chip->virt, XRX500_SSO_CON0);
+	reg = (reg & XRX500_SSO_DIMM_ENABLE_MASK) >> XRX500_SSO_DIMM_ENABLE_SHIFT;
+	status = sprintf(buf, "%d\n", reg);
+	return status;
+}
+
+static ssize_t grx500_dimm_enable_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	ssize_t status = 0;
+	long value;
+
+	status = kstrtol(buf, 0, &value);
+	if (status == 0) {
+		if ((value >= 0) && (value <= 0x1)) {
+			xrx500_sso_w32_mask(g_chip->virt,
+			XRX500_SSO_DIMM_ENABLE_MASK,
+			value << XRX500_SSO_DIMM_ENABLE_SHIFT, XRX500_SSO_CON0);
+		} else {
+			pr_err("Valid input is 0 or 1\r\n");
+			status = -EINVAL;
+		}
+	}
+	return status ? : len;
+}
+
+static DEVICE_ATTR(auto_dimming_en, S_IRUGO | S_IWUSR,
+		grx500_dimm_enable_show, grx500_dimm_enable_store);
+
+#if 0
+
+static DEVICE_ATTR(blink_src, S_IRUGO | S_IWUSR,
+		grx500_blink_src_show, grx500_blink_src_store);
+#endif		
+static ssize_t grx500_blink_src_0_23_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	ssize_t status = 0;
+	u32 value;
+	int i;
+	struct xrx500_sso_led *led = (struct xrx500_sso_led *) dev;
+	
+	if (sysfs_streq(buf, "FPID"))
+		value = 0;
+	else if (sysfs_streq(buf, "GPTD"))
+		value = 1;
+	else if (sysfs_streq(buf, "V1M"))
+		value = 2;
+	else
+		status = -EINVAL;
+
+
+	if (status == 0) {
+		if((led->phys_id >= 0) && (led->phys_id <= 23)) {
+			xrx500_sso_w32_mask(g_chip->virt,
+			0x3 << XRX500_SSO_BLINK_SOURCE_SHIFT,
+			value << XRX500_SSO_BLINK_SOURCE_SHIFT,
+			XRX500_SSO_BLINK_H8_1);
+		} else {
+			i = led->phys_id % 24;
+			xrx500_sso_w32_mask(g_chip->virt,
+			0x3 << (((i%5) * 6) + 4),
+			value << (((i%5) * 6) + 4),
+			((i < 5) ?
+			XRX500_SSO_BLINK_H8_0 : XRX500_SSO_BLINK_H8_1));	
+		}
+	}
+	return status ? : len;
+}
+
+static ssize_t grx500_blink_src_0_23_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	u32 reg;
+	ssize_t status = 0;
+	int i;
+
+	struct xrx500_sso_led *led = (struct xrx500_sso_led *) dev;
+	if((led->phys_id >= 0) && (led->phys_id <= 23)) {
+		reg = xrx500_sso_r32(g_chip->virt, XRX500_SSO_BLINK_H8_1);
+		reg = (reg >> XRX500_SSO_BLINK_SOURCE_SHIFT) & 0x3;
+	} else {
+		i = led->phys_id % 24;
+		reg = xrx500_sso_r32(g_chip->virt, ((i < 5) ? XRX500_SSO_BLINK_H8_0 : XRX500_SSO_BLINK_H8_1));
+		reg = (reg >> (((i%5) * 6) + 4)) & 0x3;
+	}
+	switch (reg) {
+		case 0:
+			status = sprintf(buf, "%s\n", "FPID");
+		break;
+		case 1:
+			status = sprintf(buf, "%s\n", "GPTD");
+		break;
+		case 2:
+			status = sprintf(buf, "%s\n", "V1M");
+		break;
+	}
+	return status;
+}
+
+
+static struct attribute *grx500_led_attributes[] = {
+	&dev_attr_update_clock_source.attr,
+	&dev_attr_number_of_leds.attr,
+	&dev_attr_update_edge.attr,
+	&dev_attr_fpi_update.attr,
+	&dev_attr_fpi_shift.attr,
+	&dev_attr_gptc_divider.attr,
+	&dev_attr_auto_dimming_en.attr,
+	&dev_attr_lux_cnv_interval.attr,
+	&dev_attr_lux_dis.attr,
+	&dev_attr_lux_lvl.attr,
+	&dev_attr_data_offset.attr,
+	&dev_attr_store_mode.attr,
+	&dev_attr_cpu_select.attr,
+	&dev_attr_hw_blink_en.attr,
+	&dev_attr_blink_rate.attr,
+	&dev_attr_led_usage.attr,
+	NULL,
+};
+
+static const struct attribute_group grx500_attr_group = {
+	.attrs = grx500_led_attributes,
+};
+
+int grx500_register_sysfs(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct device *dev;
+	g_chip = (struct xrx500_sso *)platform_get_drvdata(pdev);
+	dev = g_chip->gc.parent;
+	ret = sysfs_create_group(&dev->kobj, &grx500_attr_group);
+	return ret;
+
+}
+#endif
+
diff --git a/drivers/leds/leds-xrx500.c b/drivers/leds/leds-xrx500.c
new file mode 100755
index 000000000000..c4fb1b73f4e1
--- /dev/null
+++ b/drivers/leds/leds-xrx500.c
@@ -0,0 +1,508 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2014 Kavitha  Subramanian <s.kavitha.EE@lantiq.com>
+ *	Copyright (C) 2017 Kavitha  Subramanian <k.subramanian@intel.com>
+ */
+
+
+#include "leds-xrx500-config.h"
+
+static struct xrx500_sso_freq_table fpid_table[] = {
+	{0, 251, 500},
+	{1, 126, 250},
+	{2, 101, 125},
+	{3, 1, 100}
+};
+
+static struct xrx500_sso_freq_table gptd_table[] = {
+	{0, 11, 20},
+	{1, 6, 10},
+	{2, 5, 5},
+	{3, 1, 4}
+};
+
+static struct xrx500_sso *g_chip;
+static struct xrx500_sso_led g_xrx500_sso_led_config[NUM_LEDS];
+
+/**
+ * xrx500_sso_set() - gpio_chip->set - set gpios.
+ * @gc:     Pointer to gpio_chip device structure.
+ * @gpio:   GPIO signal number.
+ * @val:    Value to be written to specified signal.
+ *
+ * Set the shadow value and call ltq_ebu_apply.
+ */
+static void xrx500_sso_set(struct gpio_chip *gc, unsigned gpio, int val)
+{
+	struct xrx500_sso *chip =
+		container_of(gc, struct xrx500_sso, gc);
+	/*normal LED ON/OFF*/
+	pr_debug(" %s shadow 0x%x gpio %d val %d\r\n", __func__,
+		chip->shadow, gpio, val);
+	if (val)
+		chip->shadow |= BIT(gpio);
+	else
+		chip->shadow &= ~BIT(gpio);
+	xrx500_sso_w32(chip->virt, chip->shadow, (get_cpu_select()? XRX500_SSO_CPU1:XRX500_SSO_CPU0));
+	xrx500_sso_w32(chip->virt, val ? LED_FULL : LED_OFF,
+		       XRX500_SSO_DUTYCYCLE(gpio));
+	xrx500_sso_w32_mask(chip->virt, 0, XRX500_SSO_CON_SWU, XRX500_SSO_CON0);
+
+}
+/**
+ * xrx_sso_dir_out() - gpio_chip->dir_out - set gpio direction.
+ * @gc:     Pointer to gpio_chip device structure.
+ * @gpio:   GPIO signal number.
+ * @val:    Value to be written to specified signal.
+ *
+ * Same as xrx500_sso_set, always returns 0.
+ */
+static int xrx500_sso_dir_out(struct gpio_chip *gc, unsigned gpio, int val)
+{
+	xrx500_sso_set(gc, gpio, val);
+	return 0;
+}
+
+/**
+ * xrx500_sso_request() - gpio_chip->request
+ * @gc:     Pointer to gpio_chip device structure.
+ * @gpio:   GPIO signal number.
+ *
+ * We mask out the HW driven pins
+ */
+static int xrx500_sso_request(struct gpio_chip *gc, unsigned gpio)
+{
+	struct xrx500_sso *chip =
+		container_of(gc, struct xrx500_sso, gc);
+
+	if (/*(gpio < 15) && */(chip->reserved & BIT(gpio))) {
+		pr_err("GPIO %d is driven by hardware\n", gpio);
+		return -ENODEV;
+	}
+	if ((BIT(gpio) & chip->blink_mask) == BIT(gpio)) {
+		chip->upd = (xrx500_sso_r32(chip->virt,XRX500_SSO_CON1) & 
+            XRX500_SSO_UPD_MASK) >> XRX500_SSO_UPD_SHIFT;
+
+		/*Its a blink masked gpio, so check the US*/
+		if (chip->upd == LED_CON1_UPDATE_SRC_SW) {
+			/*throw a warning, the update source is sw*/
+			pr_err(
+			"GPIO %d configure the update source to be FPID or GPTD\n",
+			gpio);
+		}
+	}
+	return 0;
+}
+
+#define find_range(delay_on, delay_off, table, value) \
+for (j = 0; j < 4; j++) { \
+	if ( \
+	(delay_on >= table[j].range_start \
+	&& delay_on <= table[j].range_end) \
+	|| \
+	(delay_off >= table[j].range_start \
+	&& delay_off <= table[j].range_end)) { \
+		value = j; \
+		break;\
+	} \
+} \
+
+/* LED Related Code */
+static void xrx500_sso_program_delay(
+	int phys_id,
+	unsigned long delay_on,
+	unsigned long delay_off) {
+
+	int j = 0, k = 0;
+	int value = 0;
+	/*program the individual programmable rate if
+	proper range is found or fallback to default values*/
+	g_chip->blink_rate = (xrx500_sso_r32(g_chip->virt, XRX500_SSO_CON0) & XRX500_SSO_BLINK_RATE_MASK) >> XRX500_SSO_BLINK_RATE_SHIFT;
+	g_chip->upd = (xrx500_sso_r32(g_chip->virt,XRX500_SSO_CON1) & 
+            XRX500_SSO_UPD_MASK) >> XRX500_SSO_UPD_SHIFT;
+
+	if (!g_chip->blink_rate) {
+		if (g_chip->upd == LED_CON1_UPDATE_SRC_FPID) {
+			find_range(delay_on, delay_off, fpid_table, value);
+			pr_debug("delay %lu %lu value from table %d %d\r\n",
+			delay_on, delay_off, value, fpid_table[value].value);
+			xrx500_sso_w32_mask(g_chip->virt,
+			XRX500_SSO_FPID_MASK,
+			fpid_table[value].value << XRX500_SSO_FPID_SHIFT,
+			XRX500_SSO_CON1);
+		} else if (g_chip->upd == LED_CON1_UPDATE_SRC_GPTD2) {
+			find_range(delay_on, delay_off, gptd_table, value);
+			pr_debug("delay %lu %lu value from table %d %d\r\n",
+			delay_on, delay_off,
+			value, gptd_table[value].value);
+			xrx500_sso_w32_mask(g_chip->virt,
+			XRX500_SSO_GPTD_MASK,
+			gptd_table[value].value << XRX500_SSO_GPTD_SHIFT,
+			XRX500_SSO_CON1);
+		}
+		return;
+	}
+	if ((phys_id >= 24) && (phys_id <= 31)) {
+		k = phys_id - 24;
+		g_chip->blink_source_24_31[k] = (xrx500_sso_r32(g_chip->virt,(k < 5) ? XRX500_SSO_BLINK_H8_0 : XRX500_SSO_BLINK_H8_1) & 0x3) >> (((k % 5) * 6) + 4);
+		if (g_chip->blink_source_24_31[k] == LED_H8_UPDATE_SRC_FPID) {
+			find_range(delay_on, delay_off, fpid_table, value);
+			xrx500_sso_w32_mask(g_chip->virt,
+			0x3 << ((k%5) * 6),
+			fpid_table[value].value << ((k%5) * 6),
+			((phys_id < 29) ?
+			XRX500_SSO_BLINK_H8_0 : XRX500_SSO_BLINK_H8_1));
+		} else if (g_chip->blink_source_24_31[k]
+			== LED_H8_UPDATE_SRC_GPTD) {
+			find_range(delay_on, delay_off, gptd_table, value);
+			xrx500_sso_w32_mask(g_chip->virt,
+			0x3 << (((k%5) * 6) + 2),
+			gptd_table[value].value << (((k%5) * 6) + 2),
+			((phys_id < 29) ?
+			XRX500_SSO_BLINK_H8_0 : XRX500_SSO_BLINK_H8_1));
+		}
+	} else if ((phys_id >= 0) && (phys_id <= 23)) {
+		k = 3;
+		g_chip->blink_source_0_23 = (xrx500_sso_r32(g_chip->virt,XRX500_SSO_BLINK_H8_1) & 0x3) >> XRX500_SSO_BLINK_SOURCE_SHIFT;
+		if (g_chip->blink_source_0_23 == LED_H8_UPDATE_SRC_FPID) {
+			find_range(delay_on, delay_off, fpid_table, value);
+			xrx500_sso_w32_mask(g_chip->virt,
+			0x3 << (k * 6),
+			fpid_table[value].value << (k * 6),
+			XRX500_SSO_BLINK_H8_1);
+		} else if (g_chip->blink_source_0_23
+			== LED_H8_UPDATE_SRC_GPTD) {
+			find_range(delay_on, delay_off, gptd_table, value);
+			xrx500_sso_w32_mask(g_chip->virt,
+			0x3 << ((k * 6) + 2),
+			gptd_table[value].value << ((k * 6) + 2),
+			XRX500_SSO_BLINK_H8_1);
+		}
+	}
+}
+static int xrx500_sso_led_blink_set(struct led_classdev *device,
+				unsigned long *delay_on,
+				unsigned long *delay_off)
+
+{
+	struct xrx500_sso_led *led = (struct xrx500_sso_led *) device;
+	u32 reg;
+	if ((BIT(led->phys_id) & g_chip->blink_mask) == BIT(led->phys_id)) {
+		reg = xrx500_sso_r32(g_chip->virt, XRX500_SSO_CON2);
+		reg |= BIT(led->phys_id);
+		xrx500_sso_program_delay(led->phys_id, *delay_on, *delay_off);
+		xrx500_sso_w32(g_chip->virt, reg, XRX500_SSO_CON2);
+		led->blinking = 1;
+		return 0;
+	} else{
+		/*pr_err("blink mask not enabled\r\n");*/
+		return -1;
+	}
+}
+
+static void ledc_brightness_set(struct led_classdev *device,
+	enum led_brightness value)
+{
+	u32 reg;
+	struct xrx500_sso_led *led = (struct xrx500_sso_led *) device;
+	g_chip->upd = (xrx500_sso_r32(g_chip->virt,XRX500_SSO_CON1) & 
+            XRX500_SSO_UPD_MASK) >> XRX500_SSO_UPD_SHIFT;
+	xrx500_sso_w32(g_chip->virt, value, XRX500_SSO_DUTYCYCLE(led->phys_id));
+	/*normal LED ON/OFF*/
+	if (led->blinking && (value == 0)) {
+			reg = xrx500_sso_r32(g_chip->virt, XRX500_SSO_CON2);
+			reg &= ~BIT(led->phys_id);
+			xrx500_sso_w32(g_chip->virt, reg, XRX500_SSO_CON2);
+			led->blinking = 0;
+	}
+	if (!led->blinking) {
+		if (value)
+			g_chip->shadow |= BIT(led->phys_id);
+		else
+			g_chip->shadow &= ~BIT(led->phys_id);
+
+		xrx500_sso_w32(g_chip->virt, g_chip->shadow, (get_cpu_select()? XRX500_SSO_CPU1:XRX500_SSO_CPU0));
+		if (g_chip->upd == LED_CON1_UPDATE_SRC_SW)
+			xrx500_sso_w32_mask(g_chip->virt,
+			0, XRX500_SSO_CON_SWU, XRX500_SSO_CON0);
+	}
+}
+static char* blink_src_get_24_31(int phys_id) {
+	int i = phys_id % 24;
+	u32 reg;
+	reg = xrx500_sso_r32(g_chip->virt, ((i < 5) ?	XRX500_SSO_BLINK_H8_0 : XRX500_SSO_BLINK_H8_1));
+	reg = (reg >> (((i%5) * 6) + 4)) & 0x3;
+	switch (reg) {
+		case 0:
+			return "FPID";
+		break;
+		case 1:
+			return "GPTD";
+		break;
+		case 2:
+			return "V1M";
+		break;
+		default:
+			return "Error";
+	}
+}
+static void blink_src_set_24_31(char *source, int phys_id) {
+	int i = phys_id % 24;
+	int src = 0;
+	if (!strcmp(source, "FPID")) {
+		src = 0;
+	} else if (!strcmp(source, "GPTD")) {
+		src = 1;
+	} else if (!strcmp(source, "V1M")) {
+		src = 2;
+	}
+	xrx500_sso_w32_mask(g_chip->virt,
+	0x3 << (((i%5) * 6) + 4),
+	src << (((i%5) * 6) + 4),
+	((i < 5) ?
+	XRX500_SSO_BLINK_H8_0 : XRX500_SSO_BLINK_H8_1));		
+
+}
+static void blink_src_set(struct led_classdev *device, char *source)
+{
+	struct xrx500_sso_led *led = (struct xrx500_sso_led *) device;
+	if(led->phys_id <= 23) {
+		pr_err("blink_src is not supported for LEDS 0-23 instead use blink_src_0_23 in the top directory\r\n");
+	} else {
+		blink_src_set_24_31(source, led->phys_id);
+	}
+	
+}
+static char *blink_src_get(struct led_classdev *device)
+{
+	struct xrx500_sso_led *led = (struct xrx500_sso_led *) device;
+	if(led->phys_id <= 23)
+		return "blink_src is not supported for LEDS 0-23 instead use blink_src_0_23 in the top directory\r\n";
+	else
+		return blink_src_get_24_31(led->phys_id);
+}
+
+/* Code to create from OpenFirmware platform devices */
+static int gpio_leds_create_of(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node, *child;
+	int count, i = 0;
+
+	/* count LEDs in this device, so we know how much to allocate */
+	count = of_get_child_count(np);
+	if (!count)
+		return -ENODEV;
+
+	for_each_child_of_node(np, child) {
+		struct xrx500_sso_led *led_dat = &g_xrx500_sso_led_config[i];
+		led_dat->device.name = of_get_property(child, "label",
+						     NULL) ? : child->name;
+		pr_debug("name %s\r\n", led_dat->device.name);
+		led_dat->device.default_trigger = of_get_property(child,
+						"linux,default-trigger", NULL);
+		of_property_read_u32(child, "max-brightness",
+				&led_dat->device.max_brightness);
+
+		of_property_read_u32(child, "reg", &led_dat->phys_id);
+		led_dat->device.brightness_set = ledc_brightness_set;
+		led_dat->device.blink_src_set = blink_src_set;
+		led_dat->device.blink_src_get = blink_src_get;
+		
+		led_dat->device.blink_set = xrx500_sso_led_blink_set;
+		led_dat->device.brightness = LED_OFF;
+		led_dat->device.flags |= LED_CORE_SUSPENDRESUME;
+		if ((led_classdev_register(&pdev->dev, &led_dat->device)) != 0)
+			return -ENODEV;
+		else
+			pr_debug("classdev registered successfully\r\n");
+		
+		i++;
+	}
+
+	return 0;
+}
+
+static int sso_led_init(struct platform_device *pdev)
+{
+	struct pinctrl *pinctrl;
+
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl))
+		pr_warn("pins are not configured from the driver\n");
+	gpio_leds_create_of(pdev);
+
+	return 0;
+}
+
+/**
+ * xrx500_sso_hw_init() - Configure the SSO unit and enable the clock gate
+ * @virt: pointer to the remapped register range
+ */
+static int xrx500_sso_hw_init(struct xrx500_sso *chip)
+{
+	/* sane defaults */
+	xrx500_sso_w32(chip->virt, 0, XRX500_SSO_AR);
+	xrx500_sso_w32(chip->virt, 0, XRX500_SSO_CPU0);
+	xrx500_sso_w32(chip->virt, 0, XRX500_SSO_CPU1);
+	xrx500_sso_w32(chip->virt, 0, XRX500_SSO_CON1);
+	xrx500_sso_w32(chip->virt, 0, XRX500_SSO_CON0);
+	/* apply edge trigger settings for the shift register */
+	xrx500_sso_w32_mask(chip->virt, XRX500_SSO_EDGE_MASK,
+				chip->edge, XRX500_SSO_CON0);
+	/* apply led group settings */
+	xrx500_sso_w32_mask(chip->virt, XRX500_SSO_GROUP_MASK,
+				chip->groups, XRX500_SSO_CON1);
+
+	/* tell the hardware which pins are controlled by the PHY*/
+	xrx500_sso_w32_mask(chip->virt,
+	XRX500_SSO_LD0_MASK,
+	XRX500_SSO_LD0_PATTERN(chip->phy6, chip->phy2,
+	chip->phy3, chip->phy4, chip->phy5),
+	XRX500_SSO_CON3);
+	xrx500_sso_w32_mask(chip->virt,
+	XRX500_SSO_LD1_MASK,
+	XRX500_SSO_LD1_PATTERN(chip->phy6, chip->phy2,
+	chip->phy3, chip->phy4, chip->phy5),
+	XRX500_SSO_CON3);
+	xrx500_sso_w32_mask(chip->virt,
+	XRX500_SSO_LD2_MASK,
+	XRX500_SSO_LD2_PATTERN(chip->phy6, chip->phy2,
+	chip->phy3, chip->phy4, chip->phy5),
+	XRX500_SSO_CON3);
+	/* tell the hardware which pins are controlled by the WLAN*/
+	xrx500_sso_w32_mask(chip->virt,
+	XRX500_SSO_W1_W2_W3_MASK,
+	XRX500_SSO_W1_W2_W3_PATTERN(chip->wlan),
+	XRX500_SSO_CON3);
+	xrx500_sso_w32_mask(chip->virt,
+	XRX500_SSO_W4_W5_W6_MASK,
+	XRX500_SSO_W4_W5_W6_PATTERN(chip->wlan),
+	XRX500_SSO_CON3);
+
+
+	/* mask out the hw driven bits in gpio_request */
+	chip->reserved =
+	XRX500_SSO_LD0_PATTERN(chip->phy6, chip->phy2,
+	chip->phy3, chip->phy4, chip->phy5)
+	| XRX500_SSO_LD1_PATTERN(chip->phy6, chip->phy2,
+	chip->phy3, chip->phy4, chip->phy5)
+	| XRX500_SSO_LD2_PATTERN(chip->phy6, chip->phy2,
+	chip->phy3, chip->phy4, chip->phy5);
+	/*WLAN pins are mapped to SOUT4 as per the registers specification*/
+	if (chip->wlan)
+		chip->reserved |= (1 << 4);
+	return 0;
+}
+static int xrx500_sso_probe(struct platform_device *pdev)
+{
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	const __be32 *groups, *phy, *wlan;
+	struct clk *clk;
+
+	int ret = 0;
+	if (!res) {
+		pr_err("failed to request SSO resource\n");
+		return -ENOENT;
+	}
+
+	g_chip = devm_kzalloc(&pdev->dev, sizeof(*g_chip), GFP_KERNEL);
+	if (!g_chip)
+		return -ENOMEM;
+
+	g_chip->virt = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(g_chip->virt))
+		return PTR_ERR(g_chip->virt);
+
+	g_chip->gc.parent = &pdev->dev;
+	g_chip->gc.label = "sso-xrx500";
+	g_chip->gc.direction_output = xrx500_sso_dir_out;
+	g_chip->gc.set = xrx500_sso_set;
+	g_chip->gc.request = xrx500_sso_request;
+	g_chip->gc.base = -1;
+	g_chip->gc.owner = THIS_MODULE;
+
+	/* find out which gpio groups should be enabled */
+	groups = of_get_property(pdev->dev.of_node, "lantiq,groups", NULL);
+	if (groups)
+		g_chip->groups = be32_to_cpu(*groups) & XRX500_SSO_GROUP_MASK;
+	else
+		g_chip->groups = XRX500_SSO_GROUP0;
+	g_chip->gc.ngpio = fls(g_chip->groups) * 8;
+		phy = of_get_property(pdev->dev.of_node, "lantiq,phy2", NULL);
+		if (phy)
+			g_chip->phy2 = be32_to_cpu(*phy) & XRX500_SSO_PHY_MASK;
+		phy = of_get_property(pdev->dev.of_node, "lantiq,phy3", NULL);
+		if (phy)
+			g_chip->phy3 = be32_to_cpu(*phy) & XRX500_SSO_PHY_MASK;
+		phy = of_get_property(pdev->dev.of_node, "lantiq,phy4", NULL);
+		if (phy)
+			g_chip->phy4 = be32_to_cpu(*phy) & XRX500_SSO_PHY_MASK;
+		phy = of_get_property(pdev->dev.of_node, "lantiq,phy5", NULL);
+		if (phy)
+			g_chip->phy5 = be32_to_cpu(*phy) & XRX500_SSO_PHY_MASK;
+		phy = of_get_property(pdev->dev.of_node, "lantiq,phy6", NULL);
+		if (phy)
+			g_chip->phy6 = be32_to_cpu(*phy) & XRX500_SSO_PHY_MASK;
+		wlan = of_get_property(pdev->dev.of_node, "lantiq,wlan", NULL);
+		if (wlan)
+			g_chip->wlan = be32_to_cpu(*wlan)
+			& XRX500_SSO_WLAN_MASK;
+
+	/* check which edge trigger we should use, default to a falling edge */
+	if (!of_find_property(pdev->dev.of_node, "lantiq,rising", NULL))
+		g_chip->edge = XRX500_SSO_FALLING;
+#ifndef CONFIG_USE_EMULATOR
+	/* get the clock */
+	clk = devm_clk_get(&pdev->dev, "sso");
+	if (IS_ERR(clk)) {
+		dev_err(&pdev->dev, "Failed to get clock\n");
+		return PTR_ERR(clk);
+	}
+	clk_prepare_enable(clk);
+#endif
+
+	ret = xrx500_sso_hw_init(g_chip);
+	if (!ret)
+		ret = gpiochip_add(&g_chip->gc);
+
+	sso_led_init(pdev);
+	platform_set_drvdata(pdev, g_chip);
+	if (!ret) {
+		ret = grx500_register_sysfs(pdev);
+	if (ret) {
+			dev_err(&pdev->dev, "registering config sysfs failed\n");
+			return ret;
+	}
+
+		dev_info(&pdev->dev, "Init done\n");
+	}
+	/*set update source to GPT*/
+	xrx500_sso_w32_mask(g_chip->virt,
+	XRX500_SSO_UPD_MASK,
+	1 << XRX500_SSO_UPD_SHIFT, XRX500_SSO_CON1);
+	return ret;
+}
+
+static const struct of_device_id xrx500_sso_match[] = {
+	{ .compatible = "lantiq,gpio-sso-xrx500" },
+	{},
+};
+
+static struct platform_driver xrx500_sso_driver = {
+	.probe = xrx500_sso_probe,
+	.driver = {
+		.name = "gpio-sso-xrx500",
+		.owner = THIS_MODULE,
+		.of_match_table = xrx500_sso_match,
+	},
+};
+
+int __init xrx500_sso_init(void)
+{
+	return platform_driver_register(&xrx500_sso_driver);
+}
+module_platform_driver(xrx500_sso_driver);
+
