From 2dd298c9006df32290f679d74849e6cf42324de5 Mon Sep 17 00:00:00 2001
From: Hua Ma <hua.ma@linux.intel.com>
Date: Thu, 21 Jun 2018 17:38:29 +0800
Subject: [PATCH] Add support for intel xps phy support

---
 .../devicetree/bindings/phy/phy-intel-wan-xpcs.txt |   42 +
 drivers/net/ethernet/lantiq/xpcs/Makefile          |    8 +
 drivers/net/ethernet/lantiq/xpcs/xpcs.c            | 1064 +++++++++++++++++
 drivers/net/ethernet/lantiq/xpcs/xpcs.h            |  762 ++++++++++++
 drivers/net/ethernet/lantiq/xpcs/xpcs_sysfs.c      |  540 +++++++++
 drivers/phy/intel/Kconfig                          |   32 +
 drivers/phy/intel/Makefile                         |    3 +
 drivers/phy/intel/phy-intel-combo.c                | 1242 ++++++++++++++++++++
 drivers/phy/intel/phy-intel-slim.c                 |  390 ++++++
 drivers/phy/intel/phy-intel-wan-xpcs.c             |  218 ++++
 10 files changed, 4301 insertions(+)

diff --git a/Documentation/devicetree/bindings/phy/phy-intel-wan-xpcs.txt b/Documentation/devicetree/bindings/phy/phy-intel-wan-xpcs.txt
new file mode 100644
index 000000000000..a08080683599
--- /dev/null
+++ b/Documentation/devicetree/bindings/phy/phy-intel-wan-xpcs.txt
@@ -0,0 +1,42 @@
+Intel WAN XPCS PHY controller
+
+This file documents the dt bindings for the WAN XPCS PHY
+
+Required properties:
+- compatible	: should be "intel,wanxpcsphy-falconmx"
+- clocks	: frequency clock.
+		  Optionally we can include gate clock
+- clock-names	: should be "freq".
+		  Optionally we can include "xpcs" and "hwclken" for gate clock
+- clock-frequency	: frequency of pll3. This is necessary so that clk
+			  framework can select the correct parent
+- #phy-cells	: should be <0>
+- intel,wanxpcsphy-syscon	: phandle to sysconf chiptop
+- resets	: list of phandle and reset specifier pairs.
+- reset-names	: list of reset signal names. Should be "phy".
+		  See: Documentation/devicetree/bindings/reset/reset.txt
+
+Note that WAN XPCS and PON are exclusive; one must be disabled to use the other
+one.
+
+Example:
+
+wan_xpcs_phy: phy {
+	compatible = "intel,wanxpcsphy-falconmx";
+	clocks = <&ponclk>, <&clkgate1 GATE_AON_CLK>, <&clkgate3 GATE_SW_REF>;
+	clock-names = "freq", "xpcs", "hwclken";
+	clock-frequency = <156250000>;
+	#phy-cells = <0>;
+	status = "okay";
+	resets = <&rcu0 10>;
+	reset-names = "phy";
+	intel,wanxpcsphy-syscon = <&sysconf>; /* chiptop */
+};
+
+Example to use this phy in driver:
+
+test_driver@0 {
+	...
+	phys = <&wan_xpcs_phy>;
+	phy-names = "wan_xpcs"
+}
diff --git a/drivers/net/ethernet/lantiq/xpcs/Makefile b/drivers/net/ethernet/lantiq/xpcs/Makefile
new file mode 100644
index 000000000000..678abe8b24bd
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/xpcs/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for XPCS
+#
+
+obj-$(CONFIG_INTEL_XPCS) += ixpcs.o
+
+ixpcs-objs += xpcs.o
+ixpcs-objs += xpcs_sysfs.o
diff --git a/drivers/net/ethernet/lantiq/xpcs/xpcs.c b/drivers/net/ethernet/lantiq/xpcs/xpcs.c
new file mode 100644
index 000000000000..b45ef8ce2add
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/xpcs/xpcs.c
@@ -0,0 +1,1064 @@
+/*
+ * Intel XPCS driver
+ *
+ * Copyright (C) 2018 Intel, Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/phy/phy.h>
+#include <linux/reset.h>
+#include "xpcs.h"
+
+#define MAX_BUSY_RETRY	2000
+#define XPCS_IRQ_NAME "xpcs_irq"
+#define XPCS_RES_NAME "xpcs_reg"
+#define XPCS_MOD_NAME "xpcs-name"
+#define XPCS_CONN_TYPE "xpcs-conn"
+#define XPCS_MODE_NAME "xpcs-mode"
+#define XPCS_RESET_NAME "xpcs_reset"
+
+static void xpcs_cl37_an(struct xpcs_prv_data *pdata);
+static void xpcs_cl73_an(struct xpcs_prv_data *pdata);
+static void xpcs_cl72_startup(struct xpcs_prv_data *pdata);
+static int xpcs_vs_reset(struct xpcs_prv_data *pdata);
+static int xpcs_oneg_xaui_mode(struct xpcs_prv_data *pdata);
+static int xpcs_teng_xaui_mode(struct xpcs_prv_data *pdata);
+static int xpcs_teng_kr_mode(struct xpcs_prv_data *pdata);
+static int xpcs_2p5g_xaui_mode(struct xpcs_prv_data *pdata);
+static int xpcs_synphy_reset_sts(struct xpcs_prv_data *pdata);
+
+struct xpcs_mode_cfg mode_cfg[MAX_XPCS_MODE] = {
+	{
+		.id = TENG_KR_MODE,
+		.pma_type = PMA_TYPE_10G_BASE_KR,
+		.pcs_type = PCS_TYPE_10G_BASE_R,
+		.lane = LANE_1,
+		.mplla_mult = 0x21,
+		.mplla_bw = 0x7B,
+		.vco_ld_val[0] = 0x549,
+		.vco_ref_ld[0] = 0x29,
+		.afe_en = 1,
+		.dfe_en = 1,
+		.cont_adapt0 = 1,
+		.tx_rate[0] = 0,
+		.rx_rate[0] = 0,
+		.tx_width[0] = 2,	//2'b10 - 16 bit
+		.rx_width[0] = 2,	//2'b10 - 16 bit
+		.mplla_div165_clk_en = 1,
+		.mplla_div10_clk_en = 0,
+		.mplla_div8_clk_en = 1,
+		.tx_eq_main = 0x1E,
+		.tx_eq_pre = 0x14,
+		.tx_eq_post = 0x14,
+		.tx_eq_ovrride = 1,
+		.ref_clk_ctrl = 0,
+		.los_thr = 4,
+		.phy_boost_gain_val = 0x774a,
+		.rx_vref_ctrl = 0,
+		.vboost_lvl = 0x5,
+		.tx_iboost[0] = 0xF,
+		.set_mode = xpcs_teng_kr_mode,
+	},
+	{
+		.id = TENG_XAUI_MODE,
+		.pma_type = PMA_TYPE_10G_BASE_KR,
+		.pcs_type = PCS_TYPE_10G_BASE_X,
+		.lane = LANE_1,
+		.mplla_mult = 0x28,
+		.mplla_bw = 0x56,
+		.mpllb_mult = 0x28,
+		.mpllb_bw = 0x56,
+		.vco_ld_val[0] = 0x0550,
+		.vco_ref_ld[0] = 0x22,
+		.afe_en = 0,
+		.afe_en_31 = 0,
+		.dfe_en = 0,
+		.dfe_en_31 = 0,
+		.cont_adapt0 = 0,
+		.tx_rate[0] = 2,	//2'b10
+		.rx_rate[0] = 2,	//2'b10
+		.tx_width[0] = 1,
+		.rx_width[0] = 1,
+		.mplla_div165_clk_en = 0,
+		.mplla_div10_clk_en = 0,
+		.mplla_div8_clk_en = 0,
+		.mpllb_div_clk_en = 0,
+		.mpllb_div10_clk_en = 1,
+		.mpllb_div8_clk_en = 0,
+		.tx_eq_main = 0x28,
+		.tx_eq_pre = 0,
+		.tx_eq_post = 0,
+		.tx_eq_ovrride = 1,
+		.ref_clk_ctrl = 0,
+		.los_thr = 1,
+		.phy_boost_gain_val = 0x7706,
+		.rx_vref_ctrl = 0xF,	//Setting BIT12:8 = 5'd15
+		.vboost_lvl = 0x5,
+		.tx_iboost[0] = 0xF,
+		.set_mode = xpcs_teng_xaui_mode,
+	},
+	{
+		.id = ONEG_XAUI_MODE,
+		.pma_type = PMA_TYPE_1G_BASE_KX,
+		.pcs_type = PCS_TYPE_10G_BASE_X,
+		.lane = LANE_1,
+		.mplla_mult = 0x20,
+		.mplla_bw = 0x6E,
+		.vco_ld_val[0] = 0x0540,
+		.vco_ref_ld[0] = 0x002a,
+		.afe_en = 0,
+		.dfe_en = 0,
+		.cont_adapt0 = 0,
+		.tx_rate[0] = 3,
+		.rx_rate[0] = 3,
+		.tx_width[0] = 1,	//2'b01 - 10 bit
+		.rx_width[0] = 1,	//2'b01 - 10 bit
+		.mplla_div165_clk_en = 0,
+		.mplla_div10_clk_en = 1,
+		.mplla_div8_clk_en = 0,
+		.tx_eq_main = 0x28,
+		.tx_eq_pre = 0,
+		.tx_eq_post = 0,
+		.tx_eq_ovrride = 1,
+		.los_thr = 0,
+		.ref_clk_ctrl = 0,
+		.los_thr = 4,
+		.phy_boost_gain_val = 0x7706,
+		.rx_vref_ctrl = 0xF,	//Setting BIT12:8 = 5'd15
+		.vboost_lvl = 0x5,
+		.tx_iboost[0] = 0xF,
+		.set_mode = xpcs_oneg_xaui_mode,
+	},
+	{
+		.id = TWOP5G_GMII_MODE,
+		.pma_type = PMA_TYPE_1G_BASE_KX,
+		.pcs_type = 0,
+		.lane = LANE_1,
+		.mplla_mult = 0,
+		.mplla_bw = 0,
+		.vco_ld_val[0] = 2,
+		.vco_ref_ld[0] = 2,
+		.afe_en = 0,
+		.dfe_en = 0,
+		.cont_adapt0 = 0,
+		.tx_rate[0] = 0,
+		.rx_rate[0] = 0,
+		.tx_width[0] = 0,
+		.rx_width[0] = 0,
+		.mplla_div165_clk_en = 0,
+		.mplla_div10_clk_en = 0,
+		.mplla_div8_clk_en = 0,
+		.tx_eq_main = 0,
+		.tx_eq_pre = 0,
+		.tx_eq_post = 0,
+		.tx_eq_ovrride = 0,
+		.los_thr = 0,
+		.ref_clk_ctrl = 0,
+		.los_thr = 0,
+		.phy_boost_gain_val = 0,
+		.rx_vref_ctrl = 0,
+		.vboost_lvl = 0x5,
+		.tx_iboost[0] = 0xF,
+		.set_mode = xpcs_2p5g_xaui_mode,
+	},
+};
+
+static int xpcs_rxtx_stable(struct xpcs_prv_data *pdata)
+{
+	int i = 0;
+	u32 pseq_state = 0;
+
+	do {
+		pseq_state = XPCS_RGRD_VAL(pdata, PCS_DIG_STS, PSEQ_STATE);
+
+		if (pseq_state == 4) {
+			dev_info(pdata->dev,
+				 "%s: Tx/Rx stable (Power_Good State)\n",
+				 pdata->name);
+			break;
+		}
+
+		usleep_range(10, 20);
+	} while (i <= MAX_BUSY_RETRY);
+
+	if (i > MAX_BUSY_RETRY) {
+		dev_info(pdata->dev, "%s: TX/RX Stable TIMEOUT\n",
+			 pdata->name);
+		return -1;
+	}
+
+	return XPCS_SUCCESS;
+}
+
+static int xpcs_byp_pwrupseq(struct xpcs_prv_data *pdata)
+{
+	int ret = XPCS_SUCCESS;
+
+	XPCS_RGWR_VAL(pdata, PCS_DIG_CTRL1, BYP_PWRUP, 1);
+
+	ret = xpcs_vs_reset(pdata);
+
+	ret = xpcs_rxtx_stable(pdata);
+
+	return ret;
+}
+
+static int xpcs_enable_pwrupseq(struct xpcs_prv_data *pdata)
+{
+	int ret = XPCS_SUCCESS;
+
+	XPCS_RGWR_VAL(pdata, PCS_DIG_CTRL1, BYP_PWRUP, 0);
+
+	ret = xpcs_vs_reset(pdata);
+
+	/* This Synopsys PHY reset is selfcleared when PSEQ_STATE
+	 * is equal to 3'b100, that is, Tx/Rx clocks are stable and in
+	 * Power_Good state.
+	 */
+	if (xpcs_synphy_reset_sts(pdata) != XPCS_SUCCESS)
+		return XPCS_FAILURE;
+
+	return ret;
+}
+
+/* 10G Mode */
+static int xpcs_teng_mode(struct xpcs_prv_data *pdata)
+{
+	u32 pma_ctrl = XPCS_RGRD(pdata, PMA_CTRL1);
+	u32 pcs_ctrl = XPCS_RGRD(pdata, PCS_CTRL1);
+
+	if (pdata->pcs_mode == BACKPL_ETH_PCS) {
+		XPCS_SET_VAL(pma_ctrl, PMA_CTRL1, SS13, 1);
+		XPCS_RGWR(pdata, PMA_CTRL1, pma_ctrl);
+	} else {
+		XPCS_SET_VAL(pcs_ctrl, PCS_CTRL1, SS13, 1);
+		XPCS_RGWR(pdata, PCS_CTRL1, pcs_ctrl);
+	}
+
+	return XPCS_SUCCESS;
+}
+
+/* 1G Mode */
+static int xpcs_oneg_mode(struct xpcs_prv_data *pdata)
+{
+	u32 pma_ctrl = XPCS_RGRD(pdata, PMA_CTRL1);
+	u32 pcs_ctrl = XPCS_RGRD(pdata, PCS_CTRL1);
+
+	if (pdata->pcs_mode == BACKPL_ETH_PCS) {
+		XPCS_SET_VAL(pma_ctrl, PMA_CTRL1, SS13, 0);
+		XPCS_RGWR(pdata, PMA_CTRL1, pma_ctrl);
+	} else {
+		XPCS_SET_VAL(pcs_ctrl, PCS_CTRL1, SS13, 0);
+		XPCS_RGWR(pdata, PCS_CTRL1, pcs_ctrl);
+	}
+
+	return XPCS_SUCCESS;
+}
+
+/* 2.5G Mode */
+static int xpcs_2p5g_mode(struct xpcs_prv_data *pdata)
+{
+	u32 pma_ctrl = XPCS_RGRD(pdata, PMA_CTRL1);
+	u32 pcs_ctrl = XPCS_RGRD(pdata, PCS_CTRL1);
+
+	if (pdata->pcs_mode == BACKPL_ETH_PCS) {
+		XPCS_SET_VAL(pma_ctrl, PMA_CTRL1, SS13, 0);
+		XPCS_RGWR(pdata, PMA_CTRL1, pma_ctrl);
+	} else {
+		XPCS_SET_VAL(pcs_ctrl, PCS_CTRL1, SS13, 0);
+		XPCS_RGWR(pdata, PCS_CTRL1, pcs_ctrl);
+	}
+
+	return XPCS_SUCCESS;
+}
+
+/* XPCS Vendor Specific Soft Reset
+ * When the host sets this bit, the CSR block triggers the software reset
+ * process in which all internal blocks are reset, except the Management
+ * Interface block and CSR block.
+ * When this bit is set, it also resets the PHY.
+ * This bit is self cleared
+ */
+static int xpcs_vs_reset(struct xpcs_prv_data *pdata)
+{
+	u32 reset = 0;
+	u32 idx = 0;
+
+	XPCS_RGWR_VAL(pdata, PCS_DIG_CTRL1, VR_RST, 1);
+
+	do {
+		reset = XPCS_RGRD_VAL(pdata, PCS_DIG_CTRL1, VR_RST);
+
+		if (reset == 0)
+			break;
+
+		idx++;
+
+		/* To put a small delay and make sure previous operations
+		 * are complete
+		 */
+		usleep_range(100, 200);
+	} while (idx <= MAX_BUSY_RETRY);
+
+	if (idx > MAX_BUSY_RETRY) {
+		dev_info(pdata->dev,
+			 "%s: XPCS Vendor Specific Soft Reset %d times\n",
+			 pdata->name, MAX_BUSY_RETRY);
+		return XPCS_FAILURE;
+	}
+
+	return XPCS_SUCCESS;
+}
+
+static int xpcs_synphy_reset_sts(struct xpcs_prv_data *pdata)
+{
+	u32 reset = 0;
+	u32 idx = 0;
+
+	/* Make sure synopys phy is out of reset */
+	do {
+		reset = XPCS_RGRD_VAL(pdata, PCS_CTRL1, RST);
+
+		if ((reset & 0x8000) == 0)
+			break;
+
+		idx++;
+
+		/* To put a small delay and make sure previous operations
+		 * are complete
+		 */
+		usleep_range(10, 20);
+	} while (idx <= MAX_BUSY_RETRY);
+
+	if (idx > MAX_BUSY_RETRY) {
+		dev_info(pdata->dev,
+			 "%s: Synopsys Phy reset check reached %d times\n",
+			 pdata->name, MAX_BUSY_RETRY);
+		return XPCS_FAILURE;
+	}
+
+	return XPCS_SUCCESS;
+}
+
+static void xpcs_cfg_table(struct xpcs_prv_data *pdata)
+{
+	u32 mplla_ctrl2 = 0;
+	u32 tx_eq0, tx_eq1;
+	u32 val = 0;
+
+	if (pdata->mpllb) {
+		XPCS_RGWR_VAL(pdata, PMA_MPLLB_C0, MPLLB_MULTIPLIER,
+			      pdata->mode_cfg->mpllb_mult);
+
+		XPCS_RGWR_VAL(pdata, PMA_MPLLB_C3, MPPLB_BANDWIDTH,
+			      pdata->mode_cfg->mpllb_bw);
+	} else {
+		XPCS_RGWR_VAL(pdata, PMA_MPLLA_C0, MPLLA_MULTIPLIER,
+			      pdata->mode_cfg->mplla_mult);
+
+		XPCS_RGWR_VAL(pdata, PMA_MPLLA_C3, MPPLA_BANDWIDTH,
+			      pdata->mode_cfg->mplla_bw);
+	}
+
+	switch (pdata->mode_cfg->lane) {
+	case LANE_4:
+		XPCS_RGWR_VAL(pdata, PMA_VCO_CAL_LD3, VCO_LD_VAL_3,
+			      pdata->mode_cfg->vco_ld_val[3]);
+		XPCS_RGWR_VAL(pdata, PMA_VCO_CAL_REF1, VCO_REF_LD_3,
+			      pdata->mode_cfg->vco_ref_ld[3]);
+		XPCS_RGWR_VAL(pdata, PMA_TX_RATE_CTRL, TX_RATE_3,
+			      pdata->mode_cfg->tx_rate[3]);
+		XPCS_RGWR_VAL(pdata, PMA_RX_RATE_CTRL, RX_RATE_3,
+			      pdata->mode_cfg->rx_rate[3]);
+		XPCS_RGWR_VAL(pdata, PMA_TX_GENCTRL2, TX_WIDTH_3,
+			      pdata->mode_cfg->tx_width[3]);
+		XPCS_RGWR_VAL(pdata, PMA_RX_GENCTRL2, RX_WIDTH_3,
+			      pdata->mode_cfg->rx_width[3]);
+		XPCS_RGWR_VAL(pdata, PMA_TX_BOOST_CTRL, TX3_IBOOST,
+			      pdata->mode_cfg->tx_iboost[3]);
+
+	case LANE_3:
+		XPCS_RGWR_VAL(pdata, PMA_VCO_CAL_LD2, VCO_LD_VAL_2,
+			      pdata->mode_cfg->vco_ld_val[2]);
+		XPCS_RGWR_VAL(pdata, PMA_VCO_CAL_REF1, VCO_REF_LD_2,
+			      pdata->mode_cfg->vco_ref_ld[2]);
+		XPCS_RGWR_VAL(pdata, PMA_TX_RATE_CTRL, TX_RATE_2,
+			      pdata->mode_cfg->tx_rate[2]);
+		XPCS_RGWR_VAL(pdata, PMA_RX_RATE_CTRL, RX_RATE_2,
+			      pdata->mode_cfg->rx_rate[2]);
+		XPCS_RGWR_VAL(pdata, PMA_TX_GENCTRL2, TX_WIDTH_2,
+			      pdata->mode_cfg->tx_width[2]);
+		XPCS_RGWR_VAL(pdata, PMA_RX_GENCTRL2, RX_WIDTH_2,
+			      pdata->mode_cfg->rx_width[2]);
+		XPCS_RGWR_VAL(pdata, PMA_TX_BOOST_CTRL, TX2_IBOOST,
+			      pdata->mode_cfg->tx_iboost[2]);
+
+	case LANE_2:
+		XPCS_RGWR_VAL(pdata, PMA_VCO_CAL_LD1, VCO_LD_VAL_1,
+			      pdata->mode_cfg->vco_ld_val[1]);
+		XPCS_RGWR_VAL(pdata, PMA_VCO_CAL_REF0, VCO_REF_LD_1,
+			      pdata->mode_cfg->vco_ref_ld[1]);
+		XPCS_RGWR_VAL(pdata, PMA_TX_RATE_CTRL, TX_RATE_1,
+			      pdata->mode_cfg->tx_rate[1]);
+		XPCS_RGWR_VAL(pdata, PMA_RX_RATE_CTRL, RX_RATE_1,
+			      pdata->mode_cfg->rx_rate[1]);
+		XPCS_RGWR_VAL(pdata, PMA_TX_GENCTRL2, TX_WIDTH_1,
+			      pdata->mode_cfg->tx_width[1]);
+		XPCS_RGWR_VAL(pdata, PMA_RX_GENCTRL2, RX_WIDTH_1,
+			      pdata->mode_cfg->rx_width[1]);
+		XPCS_RGWR_VAL(pdata, PMA_TX_BOOST_CTRL, TX1_IBOOST,
+			      pdata->mode_cfg->tx_iboost[1]);
+
+	case LANE_1:
+		XPCS_RGWR_VAL(pdata, PMA_VCO_CAL_LD0, VCO_LD_VAL_0,
+			      pdata->mode_cfg->vco_ld_val[0]);
+		XPCS_RGWR_VAL(pdata, PMA_VCO_CAL_REF0, VCO_REF_LD_0,
+			      pdata->mode_cfg->vco_ref_ld[0]);
+		XPCS_RGWR_VAL(pdata, PMA_TX_RATE_CTRL, TX_RATE_0,
+			      pdata->mode_cfg->tx_rate[0]);
+		XPCS_RGWR_VAL(pdata, PMA_RX_RATE_CTRL, RX_RATE_0,
+			      pdata->mode_cfg->rx_rate[0]);
+		XPCS_RGWR_VAL(pdata, PMA_TX_GENCTRL2, TX_WIDTH_0,
+			      pdata->mode_cfg->tx_width[0]);
+		XPCS_RGWR_VAL(pdata, PMA_RX_GENCTRL2, RX_WIDTH_0,
+			      pdata->mode_cfg->rx_width[0]);
+		XPCS_RGWR_VAL(pdata, PMA_TX_BOOST_CTRL, TX0_IBOOST,
+			      pdata->mode_cfg->tx_iboost[0]);
+
+		break;
+
+	default:
+		break;
+	}
+
+	val = XPCS_RGRD(pdata, PMA_AFE_DFE_EN_CTRL);
+
+	XPCS_SET_VAL(val, PMA_AFE_DFE_EN_CTRL, AFE_EN_0,
+		     pdata->mode_cfg->afe_en);
+	XPCS_SET_VAL(val, PMA_AFE_DFE_EN_CTRL, AFE_EN_3_1,
+		     pdata->mode_cfg->afe_en_31);
+	XPCS_SET_VAL(val, PMA_AFE_DFE_EN_CTRL, DFE_EN_0,
+		     pdata->mode_cfg->dfe_en);
+	XPCS_SET_VAL(val, PMA_AFE_DFE_EN_CTRL, DFE_EN_3_1,
+		     pdata->mode_cfg->dfe_en_31);
+
+	XPCS_RGWR(pdata, PMA_AFE_DFE_EN_CTRL, val);
+
+	XPCS_RGWR_VAL(pdata, PMA_RX_EQ_CTRL4, CONT_ADAPT_0,
+		      pdata->mode_cfg->cont_adapt0);
+	XPCS_RGWR_VAL(pdata, PMA_RX_EQ_CTRL4, CONT_ADAPT_3_1,
+		      pdata->mode_cfg->cont_adapt31);
+
+	if (pdata->mpllb) {
+		mplla_ctrl2 = XPCS_RGRD(pdata, PMA_MPLLB_C2);
+
+		XPCS_SET_VAL(mplla_ctrl2, PMA_MPLLB_C2, MPLLB_DIV_CLK_EN,
+			     pdata->mode_cfg->mpllb_div_clk_en);
+		XPCS_SET_VAL(mplla_ctrl2, PMA_MPLLB_C2, MPLLB_DIV10_CLK_EN,
+			     pdata->mode_cfg->mpllb_div10_clk_en);
+		XPCS_SET_VAL(mplla_ctrl2, PMA_MPLLB_C2, MPLLB_DIV8_CLK_EN,
+			     pdata->mode_cfg->mpllb_div8_clk_en);
+
+		XPCS_RGWR(pdata, PMA_MPLLB_C2, mplla_ctrl2);
+	} else {
+		mplla_ctrl2 = XPCS_RGRD(pdata, PMA_MPLLA_C2);
+
+		XPCS_SET_VAL(mplla_ctrl2, PMA_MPLLA_C2, MPLLA_DIV16P5_CLK_EN,
+			     pdata->mode_cfg->mplla_div165_clk_en);
+		XPCS_SET_VAL(mplla_ctrl2, PMA_MPLLA_C2, MPLLA_DIV10_CLK_EN,
+			     pdata->mode_cfg->mplla_div10_clk_en);
+		XPCS_SET_VAL(mplla_ctrl2, PMA_MPLLA_C2, MPLLA_DIV8_CLK_EN,
+			     pdata->mode_cfg->mplla_div8_clk_en);
+
+		XPCS_RGWR(pdata, PMA_MPLLA_C2, mplla_ctrl2);
+	}
+
+	tx_eq0 = XPCS_RGRD(pdata, PMA_TX_EQ_C0);
+
+	XPCS_SET_VAL(tx_eq0, PMA_TX_EQ_C0, TX_EQ_MAIN,
+		     pdata->mode_cfg->tx_eq_main);
+	XPCS_SET_VAL(tx_eq0, PMA_TX_EQ_C0, TX_EQ_PRE,
+		     pdata->mode_cfg->tx_eq_pre);
+
+	XPCS_RGWR(pdata, PMA_TX_EQ_C0, tx_eq0);
+
+	tx_eq1 = XPCS_RGRD(pdata, PMA_TX_EQ_C1);
+
+	XPCS_SET_VAL(tx_eq1, PMA_TX_EQ_C1, TX_EQ_POST,
+		     pdata->mode_cfg->tx_eq_post);
+	XPCS_SET_VAL(tx_eq1, PMA_TX_EQ_C1, TX_EQ_OVR_RIDE,
+		     pdata->mode_cfg->tx_eq_ovrride);
+
+	XPCS_RGWR(pdata, PMA_TX_EQ_C1, tx_eq1);
+
+	/* Tx Voltage Boost Maximum level,
+	 * maximum achievable Tx swing in the PHY
+	 */
+	XPCS_RGWR_VAL(pdata, PMA_TX_GENCTRL1, VBOOST_EN_0, 1);
+
+	XPCS_RGWR_VAL(pdata, PMA_TX_GENCTRL1, VBOOST_LVL,
+		      pdata->mode_cfg->vboost_lvl);
+}
+
+/* Switch to 10G XAUI Mode in 12G gen5 PHY */
+static int xpcs_teng_xaui_mode(struct xpcs_prv_data *pdata)
+{
+	if (xpcs_byp_pwrupseq(pdata) != XPCS_SUCCESS)
+		return XPCS_FAILURE;
+
+	/* Use internal clock */
+	XPCS_RGWR_VAL(pdata, PMA_REF_CLK_CTRL, REF_USE_PAD, 0);
+
+	/* Setting SS13 bit PMA side */
+	xpcs_teng_mode(pdata);
+
+	XPCS_RGWR_VAL(pdata, PCS_XAUI_CTRL, XAUI_MODE, 0);
+
+	XPCS_RGWR_VAL(pdata, PCS_CTRL2, PCS_TYPE_SEL,
+		      pdata->mode_cfg->pcs_type);
+
+	/* Setting SS13 bit of PCS side */
+	XPCS_RGWR_VAL(pdata, PCS_CTRL1, SS13, 1);
+
+	/* Select MPLLB for XAUI/10GBASE-KX4
+	 * When this bit is set, PHY selects MPLLB to generate
+	 * Tx analog clocks on lane 0
+	 */
+	if (pdata->mpllb) {
+		XPCS_RGWR_VAL(pdata, PMA_MPLL_CMN_CTRL, MPLLB_SEL_3_1, 0);
+		XPCS_RGWR_VAL(pdata, PMA_MPLL_CMN_CTRL, MPLLB_SEL_0, 1);
+	} else {
+		XPCS_RGWR_VAL(pdata, PMA_MPLL_CMN_CTRL, MPLLB_SEL_3_1, 0);
+		XPCS_RGWR_VAL(pdata, PMA_MPLL_CMN_CTRL, MPLLB_SEL_0, 0);
+	}
+
+	xpcs_cfg_table(pdata);
+
+	/* PHY LOS threshold register */
+	XPCS_RGWR(pdata, PMA_RX_GENCTRL3, pdata->mode_cfg->los_thr);
+
+	/* PHY ctle_pole and boost and gain register */
+	XPCS_RGWR(pdata, PMA_RX_EQ_CTRL0, pdata->mode_cfg->phy_boost_gain_val);
+
+	/* Rx Biasing Current Control for Rx analog front end */
+	XPCS_RGWR_VAL(pdata, PMA_MISC_C0, RX_VREF_CTRL,
+		      pdata->mode_cfg->rx_vref_ctrl);
+
+	/* Link Up and Down, No Configuration reset */
+	if (xpcs_vs_reset(pdata) != XPCS_SUCCESS)
+		return XPCS_FAILURE;
+
+	if (pdata->conntype == CONN_TYPE_SFP) {
+		/* Disable Autoneg */
+		XPCS_RGWR_VAL(pdata, AN_CTRL, AN_EN, 0);
+	} else {
+		xpcs_cl73_an(pdata);
+	}
+
+	return XPCS_SUCCESS;
+}
+
+/* Switch to 10G KR Mode in 12G gen5 PHY */
+static int xpcs_teng_kr_mode(struct xpcs_prv_data *pdata)
+{
+	if (xpcs_byp_pwrupseq(pdata) != XPCS_SUCCESS)
+		return XPCS_FAILURE;
+
+	/* Use internal clock */
+	XPCS_RGWR_VAL(pdata, PMA_REF_CLK_CTRL, REF_USE_PAD, 0);
+
+	/* Setting SS13 bit PMA side */
+	xpcs_teng_mode(pdata);
+
+	if (xpcs_enable_pwrupseq(pdata) != XPCS_SUCCESS)
+		return XPCS_FAILURE;
+
+	XPCS_RGWR_VAL(pdata, PCS_CTRL2, PCS_TYPE_SEL,
+		      pdata->mode_cfg->pcs_type);
+
+	/* 10GBASE-KR PMA or PMD type */
+	XPCS_RGWR_VAL(pdata, PMA_CTRL2, PMA_TYPE,
+		      pdata->mode_cfg->pma_type);
+
+	xpcs_cfg_table(pdata);
+
+	/* PHY LOS threshold register */
+	XPCS_RGWR(pdata, PMA_RX_GENCTRL3, pdata->mode_cfg->los_thr);
+
+	/* PHY ctle_pole and boost and gain register */
+	XPCS_RGWR(pdata, PMA_RX_EQ_CTRL0, pdata->mode_cfg->phy_boost_gain_val);
+
+	/* Link Up and Down, No Configuration reset */
+	if (xpcs_vs_reset(pdata) != XPCS_SUCCESS)
+		return XPCS_FAILURE;
+
+	/* If connected to SFP module CL73 Auto-negotiation need to be
+	 * disabled
+	 */
+	if (pdata->conntype == CONN_TYPE_SFP) {
+		/* Disable Autoneg */
+		XPCS_RGWR_VAL(pdata, AN_CTRL, AN_EN, 0);
+	} else {
+		xpcs_cl73_an(pdata);
+	}
+
+	return XPCS_SUCCESS;
+}
+
+/*
+ * Speed     mode  SS6 SS13
+ * 1000 Mbps SGMII 1   0
+ * 100 Mbps  SGMII 0   1
+ * 10 Mbps   SGMII 0   0
+ */
+/* 1G XAUI Mode */
+static int xpcs_oneg_xaui_mode(struct xpcs_prv_data *pdata)
+{
+	pdata->sgmii_type = PHY_SIDE_SGMII;
+
+	if (xpcs_byp_pwrupseq(pdata) != XPCS_SUCCESS)
+		return XPCS_FAILURE;
+
+	/* Use internal clock */
+	XPCS_RGWR_VAL(pdata, PMA_REF_CLK_CTRL, REF_USE_PAD, 0);
+
+	xpcs_oneg_mode(pdata);
+
+	if (xpcs_enable_pwrupseq(pdata) != XPCS_SUCCESS)
+		return XPCS_FAILURE;
+
+	/* Set to XAUI mode */
+	XPCS_RGWR_VAL(pdata, PCS_XAUI_CTRL, XAUI_MODE, 0);
+
+	/* When this field is written with 2'b00, the KR
+	 * speed mode is selected. When this field is written with a value other
+	 * than 2'b00, the KR speed mode is de-selected and non-KR speed
+	 * mode (KX4 or KX) is selected
+	 */
+	XPCS_RGWR_VAL(pdata, PCS_CTRL2, PCS_TYPE_SEL,
+		      pdata->mode_cfg->pcs_type);
+
+	/* PMA_TYPE_1G_BASE_KX */
+	XPCS_RGWR_VAL(pdata, PMA_CTRL2, PMA_TYPE,
+		      pdata->mode_cfg->pma_type);
+
+	/* 1Gbps SGMII Mode */
+	XPCS_RGWR_VAL(pdata, SR_MII_CTRL, SS13, 0);
+	XPCS_RGWR_VAL(pdata, SR_MII_CTRL, SS6, 1);
+
+	xpcs_cfg_table(pdata);
+
+	/* PHY LOS threshold register */
+	XPCS_RGWR(pdata, PMA_RX_GENCTRL3, pdata->mode_cfg->los_thr);
+
+	/* PHY ctle_pole and boost and gain register */
+	XPCS_RGWR(pdata, PMA_RX_EQ_CTRL0, pdata->mode_cfg->phy_boost_gain_val);
+
+	/* Rx Biasing Current Control for Rx analog front end */
+	XPCS_RGWR_VAL(pdata, PMA_MISC_C0, RX_VREF_CTRL,
+		      pdata->mode_cfg->rx_vref_ctrl);
+
+	/* Link Up and Down, No Configuration reset */
+	if (xpcs_vs_reset(pdata) != XPCS_SUCCESS)
+		return XPCS_FAILURE;
+
+	/* Enable Clause 37 Auto-negotiation */
+	xpcs_cl37_an(pdata);
+
+	return XPCS_SUCCESS;
+}
+
+/* 2.5G XAUI Mode */
+static int xpcs_2p5g_xaui_mode(struct xpcs_prv_data *pdata)
+{
+	if (xpcs_byp_pwrupseq(pdata) != XPCS_SUCCESS)
+		return XPCS_FAILURE;
+
+	/* Use internal clock */
+	XPCS_RGWR_VAL(pdata, PMA_REF_CLK_CTRL, REF_USE_PAD, 0);
+
+	xpcs_2p5g_mode(pdata);
+
+	if (xpcs_enable_pwrupseq(pdata) != XPCS_SUCCESS)
+		return XPCS_FAILURE;
+
+	/* XAUI Mode to 0 to disable RXAUI Mode */
+	XPCS_RGWR_VAL(pdata, PCS_XAUI_CTRL, XAUI_MODE, 0);
+
+	/* Set PCS_Type=1 to disable KR Mode */
+	XPCS_RGWR_VAL(pdata, PCS_CTRL2, PCS_TYPE_SEL,
+		      pdata->mode_cfg->pcs_type);
+
+	/* Set PMA_Type=1 10GBASE-X PCS Type */
+	XPCS_RGWR_VAL(pdata, PMA_CTRL2, PMA_TYPE,
+		      pdata->mode_cfg->pma_type);
+
+	/* 2.5G GMII Mode operation for 1000BaseX PCS Configuration */
+	XPCS_RGWR_VAL(pdata, VR_MII_DIG_CTRL1, EN_2_5G_MODE, 1);
+
+	/* Enable 2.5G GMII Mode GMII port
+	 * operating at 312.5MHz instead of 125MHz) of operation for all other
+	 * configurations other than 1000 Base X
+	 */
+	XPCS_RGWR_VAL(pdata, PCS_DIG_CTRL1, EN_2_5G_MODE, 1);
+
+	/* SGMII Mode */
+	XPCS_RGWR_VAL(pdata, SR_MII_CTRL, SS13, 0);
+	XPCS_RGWR_VAL(pdata, SR_MII_CTRL, SS6, 1);
+
+	/* TODO: Need to double check this setting is needed, default is 0
+	 * Setting Bit7:4 to 4'b0000 to de-select MPLLB
+	 */
+	XPCS_RGWR_VAL(pdata, PMA_MPLL_CMN_CTRL, MPLLB_SEL_3_1, 0);
+	XPCS_RGWR_VAL(pdata, PMA_MPLL_CMN_CTRL, MPLLB_SEL_0, 0);
+
+	xpcs_cfg_table(pdata);
+
+	/* PHY LOS threshold register */
+	XPCS_RGWR(pdata, PMA_RX_GENCTRL3, pdata->mode_cfg->los_thr);
+
+	/* PHY ctle_pole and boost and gain register */
+	XPCS_RGWR(pdata, PMA_RX_EQ_CTRL0, pdata->mode_cfg->phy_boost_gain_val);
+
+	/* Rx Biasing Current Control for Rx analog front end */
+	XPCS_RGWR_VAL(pdata, PMA_MISC_C0, RX_VREF_CTRL,
+		      pdata->mode_cfg->rx_vref_ctrl);
+
+	XPCS_RGWR(pdata, PMA_REF_CLK_CTRL, pdata->mode_cfg->ref_clk_ctrl);
+
+	/* Link Up and Down, No Configuration reset */
+	if (xpcs_vs_reset(pdata) != XPCS_SUCCESS)
+		return XPCS_FAILURE;
+
+	/* Enable Clause 37 Auto-negotiation */
+	xpcs_cl37_an(pdata);
+
+	return XPCS_SUCCESS;
+}
+
+/* Programming seq to enable Clause 37 Autonegotiation */
+static void xpcs_cl37_an(struct xpcs_prv_data *pdata)
+{
+	/* Disable CL73 Autoneg */
+	XPCS_RGWR_VAL(pdata, AN_CTRL, AN_EN, 0);
+
+	/* Enable Backplane CL37 Autonegotiation */
+	XPCS_RGWR_VAL(pdata, PCS_DIG_CTRL1, CL37_BP, 1);
+
+	/* Enable CL37 Autoneg */
+	XPCS_RGWR_VAL(pdata, SR_MII_CTRL, AN_ENABLE, 1);
+
+	/* PCS_Mode = 2 SGMII Mode */
+	XPCS_RGWR_VAL(pdata, VR_MII_AN_CTRL, PCS_MODE, 2);
+
+	/* Enables the generation of Clause 37 autonegotiation complete
+	 * interrupt output
+	 */
+	XPCS_RGWR_VAL(pdata, VR_MII_AN_CTRL, MII_AN_INTR_EN, 1);
+
+	/* We are using PHY_SIDE_SGMII */
+	if (pdata->sgmii_type == PHY_SIDE_SGMII) {
+		/* PHY Side SGMII */
+		XPCS_RGWR_VAL(pdata, VR_MII_AN_CTRL, TX_CONFIG, 1);
+		/* 1 Full Duplex, 0 Half Duplex */
+		XPCS_RGWR_VAL(pdata, SR_MII_CTRL, DUPLEX_MODE, 1);
+
+	} else {
+		/* MAC Side SGMII */
+		XPCS_RGWR_VAL(pdata, VR_MII_AN_CTRL, TX_CONFIG, 0);
+	}
+
+	/* 8-BIT MII Interface */
+	XPCS_RGWR_VAL(pdata, VR_MII_AN_CTRL, MII_CONTROL, 1);
+
+	/* Automatic Speed Mode Change after CL37 AN, xpcs automatically
+	 * switches to the negotiated SGMII/USXGMII/QSGMII(port0) speed, after
+	 * the completion of Clause 37 auto-negotiation.
+	 */
+	XPCS_RGWR_VAL(pdata, VR_MII_DIG_CTRL1, MAC_AUTO_SW, 0);
+
+	/* 2.5G Mode */
+	if (pdata->mode == TWOP5G_GMII_MODE) {
+		/* Link timer runs for 1.6 ms */
+		XPCS_RGWR(pdata, VR_MII_LINK_TIMER_CTRL, 0x07A1);
+
+		/* If this bit is set, the value programmed to
+		 * VR MII MMD Link Timer Control Register will be used to
+		 * compute the duration of Link Timer.
+		 */
+		XPCS_RGWR_VAL(pdata, VR_MII_DIG_CTRL1, CL37_TMR_OVR_RIDE, 1);
+	}
+}
+
+/* Programming seq to enable Clause 73 Autonegotiation */
+static void xpcs_cl73_an(struct xpcs_prv_data *pdata)
+{
+	/* Enable Autoneg */
+	XPCS_RGWR_VAL(pdata, AN_CTRL, AN_EN, 1);
+
+	/* Link Fail Inhibit/Autoneg Wait Timer Value for
+	 * Clause 73 autonegotiation.
+	 */
+	XPCS_RGWR_VAL(pdata, AN_TIMER_CTRL1, INHBT_OR_WAIT_TIME, 0xF);
+
+	/* Over-Ride Control for Clause 73 Auto-negotiation Timers. */
+	XPCS_RGWR_VAL(pdata, AN_DIG_CTRL, CL73_TMR_OVR_RIDE, 1);
+
+	/* Enable the AN Complete Interrupt, An Incompatible Link
+	 * Interrupt, An page received Interrupt enable
+	 */
+	XPCS_RGWR(pdata, AN_INTR_MSK, 7);
+
+	/* Restart Autoneg */
+	XPCS_RGWR_VAL(pdata, AN_CTRL, RSTRT_AN, 1);
+
+	/* Start Training */
+	xpcs_cl72_startup(pdata);
+}
+
+/* If this bit is set before or during Clause 73 auto-negotiation, the
+ * training starts after all pages have been exchanged during Clause
+ * 73 auto-negotiation.
+ */
+static void xpcs_cl72_startup(struct xpcs_prv_data *pdata)
+{
+	/* Enable the 10G-Base-KR start up protocol */
+	XPCS_RGWR_VAL(pdata, PMA_KR_PMD_CTRL, TR_EN, 1);
+}
+
+static int xpcs_init(struct xpcs_prv_data *pdata)
+{
+	int ret = XPCS_SUCCESS, i = 0;
+
+	pdata->pcs_mode = BACKPL_ETH_PCS;
+
+	/* Default all 3 XPCS in 10G KR Mode, if need to change, Change DT */
+	for (i = 0; i < MAX_XPCS_MODE; i++) {
+		if (mode_cfg[i].id == pdata->mode) {
+			pdata->mode_cfg = &mode_cfg[i];
+			ret = pdata->mode_cfg->set_mode(pdata);
+
+			if (ret != XPCS_SUCCESS)
+				dev_info(pdata->dev, "%s: %d :: Failed ::\n",
+					 pdata->name, pdata->mode);
+
+			break;
+		}
+	}
+
+	if (i >= MAX_XPCS_MODE) {
+		dev_dbg(pdata->dev, "%s: Invalid Mode Selection!\n",
+			pdata->name);
+		return -EINVAL;
+	}
+
+	if (xpcs_sysfs_init(pdata)) {
+		dev_dbg(pdata->dev, "%s: sysfs init failed!\n", pdata->name);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_OF
+static int xpcs_parse_dts(struct platform_device *pdev,
+			  struct xpcs_prv_data **pdata)
+{
+	struct device *dev = &pdev->dev;
+	u32 prop = 0;
+
+	(*pdata) = devm_kzalloc(dev, sizeof(pdata), GFP_KERNEL);
+
+	if (!(*pdata))
+		return -ENOMEM;
+
+	/* Retrieve the xpcs name */
+	if (device_property_read_string(dev, XPCS_MOD_NAME, &(*pdata)->name)) {
+		dev_err(dev, "Xpcs name: cannot get property\n");
+		return -EINVAL;
+	}
+
+	/* Retrieve the xpcs mode */
+	if (!device_property_read_u32(dev, XPCS_MODE_NAME, &prop)) {
+		(*pdata)->mode = prop;
+
+		if ((*pdata)->mode >= MAX_XPCS_MODE) {
+			dev_err(dev, "Xpcs mode: %u is invalid\n",
+				(*pdata)->mode);
+			return -EINVAL;
+		}
+	} else {
+		dev_err(dev, "Xpcs mode: cannot get property\n");
+		return -EINVAL;
+	}
+
+	/* Retrieve the connection type */
+	if (!device_property_read_u32(dev, XPCS_CONN_TYPE, &prop)) {
+		(*pdata)->conntype = prop;
+
+		if ((*pdata)->conntype >= CONN_TYPE_MAX) {
+			dev_err(dev, "Xpcs conntype: %u is invalid\n",
+				(*pdata)->conntype);
+			return -EINVAL;
+		}
+	} else {
+		dev_err(dev, "Xpcs conn: cannot get property\n");
+		return -EINVAL;
+	}
+
+	platform_set_drvdata(pdev, (void *)(*pdata));
+
+	return XPCS_SUCCESS;
+}
+
+#else
+static int xpcs_parse_dts(struct platform_device *pdev,
+			  struct xpcs_prv_data *pdata,
+			  struct resource *res)
+{
+	return -1;
+}
+#endif
+
+static int xpcs_reset(struct platform_device *pdev)
+{
+	struct reset_control *xpcs_rst;
+
+	xpcs_rst = devm_reset_control_get(&pdev->dev, XPCS_RESET_NAME);
+
+	if (IS_ERR(xpcs_rst))
+		return -1;
+
+	reset_control_assert(xpcs_rst);
+	udelay(1);
+	reset_control_deassert(xpcs_rst);
+
+	return 0;
+}
+
+static int xpcs_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct xpcs_prv_data *pdata = NULL;
+	struct device *dev = &pdev->dev;
+	int ret = XPCS_SUCCESS;
+
+	if (dev->of_node) {
+		if (xpcs_parse_dts(pdev, &pdata) != XPCS_SUCCESS) {
+			dev_dbg(dev, "xpcs dt parse failed!\n");
+			return -EINVAL;
+		}
+	} else { /* Read private data from end point */
+		pdata = dev_get_drvdata(dev);
+
+		if (!pdata) {
+			dev_dbg(dev,
+				"Get private data from end point failed!\n");
+			return -EINVAL;
+		}
+	}
+
+	pdata->id = pdev->id;
+	pdata->dev = dev;
+
+	pdata->irq_num = platform_get_irq_byname(pdev, XPCS_IRQ_NAME);
+
+	if (pdata->irq_num <= 0) {
+		dev_dbg(dev, "Cannot get xpcs irq !!\n");
+		return -ENODEV;
+	}
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, XPCS_RES_NAME);
+
+	if (!res) {
+		dev_err(dev, "Failed to get %s iomem res!\n", XPCS_RES_NAME);
+		return -ENOENT;
+	}
+
+	dev_dbg(dev, "%s iomem: %pr !\n", res->name, res);
+
+	pdata->phy = devm_phy_get(&pdev->dev, "phy");
+
+	if (IS_ERR(pdata->phy)) {
+		dev_dbg(dev, "No phy for %s\n", pdata->name);
+		return PTR_ERR(pdata->phy);
+	}
+
+	ret = phy_init(pdata->phy);
+
+	if (ret < 0) {
+		dev_dbg(dev, "phy_init err %s.\n", pdata->name);
+		return ret;
+	}
+
+	phy_power_on(pdata->phy);
+
+	pdata->addr_base = devm_ioremap_resource(dev, res);
+
+	if (IS_ERR(pdata->addr_base)) {
+		dev_err(dev, "Failed to ioremap resource: %pr !\n", res);
+		return -EINVAL;
+	}
+
+	if (xpcs_reset(pdev)) {
+		dev_err(dev, "Failed to do %s reset:\n", pdata->name);
+		return -EINVAL;
+	}
+
+	/* Initialize XPCS */
+	if (xpcs_init(pdata)) {
+		dev_err(dev, "%s Initialization Failed!!\n", pdata->name);
+		return -EINVAL;
+	}
+
+	dev_info(dev, "%s Initialized!!\n", pdata->name);
+
+	return XPCS_SUCCESS;
+}
+
+static int xpcs_release(struct platform_device *pdev)
+{
+	struct xpcs_prv_data *priv = platform_get_drvdata(pdev);
+
+	if (!IS_ERR(priv->phy)) {
+		phy_power_off(priv->phy);
+		phy_exit(priv->phy);
+	}
+
+	return 0;
+}
+
+static const struct of_device_id intel_xpcs_dev_match[] = {
+	{ .compatible = "intel,xpcs" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, intel_xpcs_dev_match);
+
+static struct platform_driver intel_xpcs_driver = {
+	.probe = xpcs_probe,
+	.remove = xpcs_release,
+	.driver = {
+		.name = XPCS_DEV_NAME,
+		.of_match_table = of_match_ptr(intel_xpcs_dev_match),
+	}
+};
+
+module_platform_driver(intel_xpcs_driver);
+
+MODULE_AUTHOR("Joby Thampan");
+MODULE_DESCRIPTION("Intel XPCS Device driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/ethernet/lantiq/xpcs/xpcs.h b/drivers/net/ethernet/lantiq/xpcs/xpcs.h
new file mode 100644
index 000000000000..22d097bea96a
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/xpcs/xpcs.h
@@ -0,0 +1,762 @@
+#ifndef _XPCS_H_
+#define _XPCS_H_
+
+#include <linux/types.h>
+
+#define XPCS_SUCCESS			0
+#define XPCS_FAILURE			-1
+
+#define XPCS_DEV_NAME			"intel_xpcs"
+
+#define WAN_XPCS_BASE_ADD		0x18C42000
+#define XPCS0_BASE_ADD			0x1A342000
+#define XPCS1_BASE_ADD			0x1A842000
+
+/* XPCS register offsets */
+#define PMA_CTRL1			0x40000
+#define PMA_STS1			0x40004
+#define PMA_DEV1			0x40008
+#define PMA_DEV2			0x4000C
+#define PMA_SPD_ABL			0x40010
+#define PMA_DEV_PKG1			0x40014
+#define PMA_DEV_PKG2			0x40018
+#define PMA_CTRL2			0x4001C
+#define PMA_STS2			0x40020
+#define PMA_TXDIS			0x40024
+#define PMA_RXSIG_DET			0x40028
+#define PMA_EXT_ABL			0x4002C
+#define PMA_PKG1			0x40038
+#define PMA_PKG2			0x4003C
+#define PMA_KR_PMD_CTRL			0x40258
+#define PMA_KR_PMD_STS			0x4025C
+#define PMA_KR_LP_CEU			0x40260
+#define PMA_KR_LP_CESTS			0x40264
+#define PMA_KR_LD_CEU			0x40268
+#define PMA_KR_LD_CESTS			0x4026C
+#define PMA_KX_CTRL			0x40280
+#define PMA_KX_STS			0x40284
+#define PMA_KR_ABL			0x402A8
+#define PMA_KR_CTRL			0x402AC
+#define PMA_KR_CORR_BLK1		0x402B0
+#define PMA_KR_CORR_BLK2		0x402B4
+#define PMA_KR_UCORR_BLK1		0x402B8
+#define PMA_KR_UCORR_BLK2		0x402BC
+#define PMA_TS_PMA_ABL			0x41C20
+#define PMA_TS_TMAX_L			0x41C24
+#define PMA_TS_TMAX_U			0x41C28
+#define PMA_TS_TMIN_L			0x41C2C
+#define PMA_TS_TMIN_U			0x41C30
+#define PMA_TS_RMAX_L			0x41C34
+#define PMA_TS_RMAX_U			0x41C38
+#define PMA_TS_RMIN_L			0x41C3C
+#define PMA_TS_RMIN_U			0x41C40
+
+/* Gen5 12G */
+#define PMA_DIG_CTRL1			0x60000
+#define PMA_KRTR_PRBS_C0		0x6000C
+#define PMA_KRTR_PRBS_C1		0x60010
+#define PMA_KRTR_PRBS_C2		0x60014
+#define PMA_KRTR_TR_C0			0x60018
+#define PMA_KRTR_TR_C1			0x6001C
+#define PMA_KRTR_TR_C2			0x60020
+#define PMA_KRTR_RXEQ			0x60024
+#define PMA_KRTR_TXEQ_S			0x6002C
+#define PMA_KRTR_TXEQ_CFF		0x60030
+#define PMA_PHY_TXEQ_S			0x60034
+#define PMA_DIG_STS			0x60040
+#define PMA_RX_LSTS			0x60080
+#define PMA_TX_GENCTRL0			0x600C0
+#define PMA_TX_GENCTRL1			0x600C4
+#define PMA_TX_GENCTRL2			0x600C8
+#define PMA_TX_BOOST_CTRL		0x600CC
+#define PMA_TX_RATE_CTRL		0x600D0
+#define PMA_TX_PS_CTRL			0x600D4
+#define PMA_TX_EQ_C0			0x600D8
+#define PMA_TX_EQ_C1			0x600DC
+#define PMA_TX_EQ_C2			0x600E0
+#define PMA_TX_EQ_C3			0x600E4
+#define PMA_EQ_INIT_CTRL0		0x600E8
+#define PMA_EQ_INIT_CTRL1		0x600EC
+#define PMA_TX_STS			0x60100
+#define PMA_RX_GENCTRL0			0x60140
+#define PMA_RX_GENCTRL1			0x60144
+#define PMA_RX_GENCTRL2			0x60148
+#define PMA_RX_GENCTRL3			0x6014C
+#define PMA_RX_RATE_CTRL		0x60150
+#define PMA_RX_PS_CTRL			0x60154
+#define PMA_RX_CDR_CTRL			0x60158
+#define PMA_RX_ATTN_CTRL		0x6015C
+#define PMA_RX_EQ_CTRL0			0x60160
+#define PMA_RX_EQ_CTRL1			0x60164
+#define PMA_RX_EQ_CTRL2			0x60168
+#define PMA_RX_EQ_CTRL3			0x6016C
+#define PMA_RX_EQ_CTRL4			0x60170
+#define PMA_AFE_DFE_EN_CTRL		0x60174
+#define PMA_DFE_TAP_CTRL0		0x60178
+#define PMA_DFE_TAP_CTRL1		0x6017C
+#define PMA_RX_STS			0x60180
+#define PMA_MPLL_CMN_CTRL		0x601C0
+#define PMA_MPLLA_C0			0x601C4
+#define PMA_MPLLA_C1			0x601C8
+#define PMA_MPLLA_C2			0x601CC
+#define PMA_MPLLB_C0			0x601D0
+#define PMA_MPLLB_C1			0x601D4
+#define PMA_MPLLB_C2			0x601D8
+#define PMA_MPLLA_C3			0x601DC
+#define PMA_MPLLB_C3			0x601E0
+#define PMA_MISC_C0			0x60240
+#define PMA_REF_CLK_CTRL		0x60244
+#define PMA_VCO_CAL_LD0			0x60248
+#define PMA_VCO_CAL_LD1			0x6024C
+#define PMA_VCO_CAL_LD2			0x60250
+#define PMA_VCO_CAL_LD3			0x60254
+#define PMA_VCO_CAL_REF0		0x60258
+#define PMA_VCO_CAL_REF1		0x6025C
+#define PMA_MISC_STS			0x60260
+#define PMA_MISC_CTRL1			0x60264
+#define PMA_EEE_CTRL			0x60268
+#define PMA_SRAM			0x6026C
+#define PMA_SNPS_CR_CTRL		0x60280
+#define PMA_SNPS_CR_ADDR		0x60284
+#define PMA_SNPS_CR_DATA		0x60288
+
+/* PCS */
+#define PCS_CTRL1			0xC0000
+#define PCS_STS1			0xC0004
+#define PCS_DEV1			0xC0008
+#define PCS_DEV2			0xC000C
+#define PCS_SPD_ABL			0xC0010
+#define PCS_DEV_PKG1			0xC0014
+#define PCS_DEV_PKG2			0xC0018
+#define PCS_CTRL2			0xC001C
+#define PCS_STS2			0xC0020
+#define PCS_PKG1			0xC0038
+#define PCS_PKG2			0xC003C
+#define PCS_EEE_ABL			0xC0050
+#define PCS_EEE_WKERR			0xC0058
+#define PCS_LSTS			0xC0060
+#define PCS_TCTRL			0xC0064
+#define PCS_KR_STS1			0xC0080
+#define PCS_KR_STS2			0xC0084
+#define PCS_TP_A0			0xC0088
+#define PCS_TP_A1			0xC008C
+#define PCS_TP_A2			0xC0090
+#define PCS_TP_A3			0xC0094
+#define PCS_TP_B0			0xC0098
+#define PCS_TP_B1			0xC009C
+#define PCS_TP_B2			0xC00A0
+#define PCS_TP_B3			0xC00A4
+#define PCS_TP_CTRL			0xC00A8
+#define PCS_TP_ERRCR			0xC00AC
+#define PCS_TS_PCS_ABL			0xC1C20
+#define PCS_TS_TMAX_L			0xC1C24
+#define PCS_TS_TMAX_U			0xC1C28
+#define PCS_TS_TMIN_L			0xC1C2C
+#define PCS_TS_TMIN_U			0xC1C30
+#define PCS_TS_RMAX_L			0xC1C34
+#define PCS_TS_RMAX_U			0xC1C38
+#define PCS_TS_RMIN_L			0xC1C3C
+#define PCS_TS_RMIN_U			0xC1C40
+#define PCS_DIG_CTRL1			0xE0000
+#define PCS_DIG_CTRL2			0xE0004
+#define PCS_DIG_ERRCNT_SEL		0xE0008
+#define PCS_XAUI_CTRL			0xE0010
+#define PCS_DBG_CTRL			0xE0014
+#define PCS_EEE_MCTRL0			0xE0018
+#define PCS_KR_CTRL			0xE001C
+#define PCS_EEE_TXTIMER			0xE0020
+#define PCS_EEE_RXTIMER			0xE0024
+#define PCS_EEE_MCTRL1			0xE002C
+#define PCS_DIG_STS			0xE0040
+#define PCS_ICG_ERRCNT1			0xE0044
+#define PCS_ICG_ERRCNT2			0xE0048
+#define PCS_DSKW_ERRCTR			0xE004C
+#define PCS_TPM_ERRCTR			0xE0050
+#define PCS_GPIO			0xE0054
+
+/* Auto Negotiation */
+#define AN_CTRL				0x1C0000
+#define AN_STS				0x1C0004
+#define AN_DEV_ID1			0x1C0008
+#define AN_DEV_ID2			0x1C000C
+#define AN_DEV_PKG1			0x1C0014
+#define AN_DEV_PKG2			0x1C0018
+#define AN_PKG1				0x1C0038
+#define AN_PKG2				0x1C003C
+#define AN_ADV1				0x1C0040
+#define AN_ADV2				0x1C0044
+#define AN_ADV3				0x1C0048
+#define AN_LP_ABL1			0x1C004C
+#define AN_LP_ABL2			0x1C0050
+#define AN_LP_ABL3			0x1C0054
+#define AN_XNP_TX1			0x1C0058
+#define AN_XNP_TX2			0x1C005C
+#define AN_XNP_TX3			0x1C0060
+#define AN_LP_XNP_ABL1			0x1C0064
+#define AN_LP_XNP_ABL2			0x1C0068
+#define AN_LP_XNP_ABL3			0x1C006C
+#define AN_COMP_STS			0x1C00C0
+#define AN_EEE_ABL			0x1C00F0
+#define AN_EEE_LP_ABL			0x1C00F4
+#define AN_DIG_CTRL			0x1E0000
+#define AN_INTR_MSK			0x1E0004
+#define AN_INTR				0x1E0008
+#define AN_KR_MODE_CTRL			0x1E000C
+#define AN_TIMER_CTRL0			0x1E0010
+#define AN_TIMER_CTRL1			0x1E0014
+
+/* MII 0,1,2,3 */
+#define MII_CTRL(idx)			(0x680000 + ((idx) * 0x40000))
+#define MII_STS(idx)			(0x680000 + ((idx) * 0x40000))
+#define MII_DEV_ID1(idx)		(0x680000 + ((idx) * 0x40000))
+#define MII_DEV_ID2(idx)		(0x680000 + ((idx) * 0x40000))
+#define MII_AN_ADV(idx)			(0x680000 + ((idx) * 0x40000))
+#define MII_LP_BABL(idx)		(0x680000 + ((idx) * 0x40000))
+#define MII_EXPN(idx)			(0x680000 + ((idx) * 0x40000))
+#define MII_EXT_STS(idx)		(0x680000 + ((idx) * 0x40000))
+#define MII_DIG_CTRL1(idx)		(0x680000 + ((idx) * 0x40000))
+#define MII_AN_CTRL(idx)		(0x680000 + ((idx) * 0x40000))
+#define MII_AN_INTR_STS(idx)		(0x680000 + ((idx) * 0x40000))
+#define MII_DBG_CTRL(idx)		(0x680000 + ((idx) * 0x40000))
+#define MII_LINK_TIMER_CTRL(idx)	(0x680000 + ((idx) * 0x40000))
+#define MII_DIG_STS(idx)		(0x680000 + ((idx) * 0x40000))
+#define MII_ICG_ERRCNT1(idx)		(0x680000 + ((idx) * 0x40000))
+#define MII_DIG_ERRCNT_SEL(idx)		(0x680000 + ((idx) * 0x40000))
+
+/* MMD */
+#define MMD_PMA_ID1			0x780000
+#define MMD_PMA_ID2			0x780004
+#define MMD_DEV_ID1			0x780008
+#define MMD_DEV_ID2			0x78000C
+#define MMD_PCS_ID1			0x780010
+#define MMD_PCS_ID2			0x780014
+#define MMD_AN_ID1			0x780018
+#define MMD_AN_ID2			0x78001C
+#define MMD_STS				0x780020
+#define MMD_CTRL			0x780024
+#define MMD_PKGID1			0x780038
+#define MMD_PKGID2			0x78003C
+
+#define SR_MII_CTRL			0x7C0000
+#define SR_MII_STS			0x7C0004
+#define SR_MII_DEV_ID1			0x7C0008
+#define SR_MII_DEV_ID2			0x7C000C
+#define SR_MII_AN_ADV			0x7C0010
+#define SR_MII_LP_BABL			0x7C0014
+#define SR_MII_EXPN			0x7C0018
+#define SR_MII_EXT_STS			0x7C003C
+#define VR_MII_DIG_CTRL1		0x7E0000
+#define VR_MII_AN_CTRL			0x7E0004
+#define VR_MII_AN_INTR_STS		0x7E0008
+#define VR_MII_LINK_TIMER_CTRL		0x7E0028
+
+#define AN_CTRL_AN_EN_POS			12
+#define AN_CTRL_AN_EN_WIDTH			1
+#define AN_CTRL_RSTRT_AN_POS			9
+#define AN_CTRL_RSTRT_AN_WIDTH			1
+
+#define AN_INTR_AN_INT_CMPLT_POS		0
+#define AN_INTR_AN_INT_CMPLT_WIDTH		1
+#define AN_INTR_AN_INC_LINK_POS			1
+#define AN_INTR_AN_INC_LINK_WIDTH		1
+#define AN_INTR_AN_PG_RCV_POS			2
+#define AN_INTR_AN_PG_RCV_WIDTH			1
+
+#define AN_STS_LP_AN_ABL_POS			0
+#define AN_STS_LP_AN_ABL_WIDTH			1
+#define AN_STS_AN_LS_POS			2
+#define AN_STS_AN_LS_WIDTH			1
+#define AN_STS_AN_ABL_POS			3
+#define AN_STS_AN_ABL_WIDTH			1
+#define AN_STS_AN_RF_POS			4
+#define AN_STS_AN_RF_WIDTH			1
+#define AN_STS_ANC_POS				5
+#define AN_STS_ANC_WIDTH			1
+#define AN_STS_PR_POS				6
+#define AN_STS_PR_WIDTH				1
+#define AN_STS_PR_POS				6
+#define AN_STS_PR_WIDTH				1
+#define AN_STS_EXT_NP_STS_POS			7
+#define AN_STS_EXT_NP_STS_WIDTH			1
+#define AN_STS_PDF_POS				9
+#define AN_STS_PDF_WIDTH			1
+
+#define AN_TIMER_CTRL1_INHBT_OR_WAIT_TIME_POS	0
+#define AN_TIMER_CTRL1_INHBT_OR_WAIT_TIME_WIDTH	16
+
+#define AN_DIG_CTRL_CL73_TMR_OVR_RIDE_POS	3
+#define AN_DIG_CTRL_CL73_TMR_OVR_RIDE_WIDTH	1
+
+#define SR_MII_STS_LINK_STS_POS			2
+#define SR_MII_STS_LINK_STS_WIDTH		1
+
+#define SR_MII_CTRL_SS13_POS			13
+#define SR_MII_CTRL_SS13_WIDTH			1
+#define SR_MII_CTRL_SS6_POS			6
+#define SR_MII_CTRL_SS6_WIDTH			1
+#define SR_MII_CTRL_SS5_POS			5
+#define SR_MII_CTRL_SS5_WIDTH			1
+#define SR_MII_CTRL_DUPLEX_MODE_POS		8
+#define SR_MII_CTRL_DUPLEX_MODE_WIDTH		1
+#define SR_MII_CTRL_AN_ENABLE_POS		12
+#define SR_MII_CTRL_AN_ENABLE_WIDTH		1
+
+#define VR_MII_AN_CTRL_PCS_MODE_POS		1
+#define VR_MII_AN_CTRL_PCS_MODE_WIDTH		2
+#define VR_MII_AN_CTRL_TX_CONFIG_POS		3
+#define VR_MII_AN_CTRL_TX_CONFIG_WIDTH		1
+#define VR_MII_AN_CTRL_MII_CONTROL_POS		8
+#define VR_MII_AN_CTRL_MII_CONTROL_WIDTH	1
+#define VR_MII_AN_CTRL_MII_AN_INTR_EN_POS	0
+#define VR_MII_AN_CTRL_MII_AN_INTR_EN_WIDTH	1
+#define VR_MII_AN_CTRL_SGMII_LINK_STS_POS	4
+#define VR_MII_AN_CTRL_SGMII_LINK_STS_WIDTH	1
+
+#define VR_MII_DIG_CTRL1_PHY_MODE_CTRL_POS	0
+#define VR_MII_DIG_CTRL1_PHY_MODE_CTRL_WIDTH	1
+#define VR_MII_DIG_CTRL1_MAC_AUTO_SW_POS	9
+#define VR_MII_DIG_CTRL1_MAC_AUTO_SW_WIDTH	1
+#define VR_MII_DIG_CTRL1_EN_2_5G_MODE_POS	2
+#define VR_MII_DIG_CTRL1_EN_2_5G_MODE_WIDTH	1
+#define VR_MII_DIG_CTRL1_CL37_TMR_OVR_RIDE_POS		3
+#define VR_MII_DIG_CTRL1_CL37_TMR_OVR_RIDE_WIDTH	1
+
+#define PMA_KR_PMD_CTRL_TR_EN_POS		1
+#define PMA_KR_PMD_CTRL_TR_EN_WIDTH		1
+#define PMA_KR_PMD_CTRL_RS_TR_POS		0
+#define PMA_KR_PMD_CTRL_RS_TR_WIDTH		1
+
+#define PMA_MPLL_CMN_CTRL_MPLLB_SEL_3_1_POS	5
+#define PMA_MPLL_CMN_CTRL_MPLLB_SEL_3_1_WIDTH	3
+#define PMA_MPLL_CMN_CTRL_MPLLB_SEL_0_POS	4
+#define PMA_MPLL_CMN_CTRL_MPLLB_SEL_0_WIDTH	1
+
+#define PMA_CTRL1_SS13_POS			13
+#define PMA_CTRL1_SS13_WIDTH			1
+
+#define PMA_MPLLA_C0_MPLLA_MULTIPLIER_POS	0
+#define PMA_MPLLA_C0_MPLLA_MULTIPLIER_WIDTH	8
+
+#define PMA_MPLLB_C0_MPLLB_MULTIPLIER_POS	0
+#define PMA_MPLLB_C0_MPLLB_MULTIPLIER_WIDTH	8
+
+#define PMA_MPLLA_C3_MPPLA_BANDWIDTH_POS	0
+#define PMA_MPLLA_C3_MPPLA_BANDWIDTH_WIDTH	11
+
+#define PMA_MPLLB_C3_MPPLB_BANDWIDTH_POS	0
+#define PMA_MPLLB_C3_MPPLB_BANDWIDTH_WIDTH	11
+
+#define PMA_VCO_CAL_LD0_VCO_LD_VAL_0_POS	0
+#define PMA_VCO_CAL_LD0_VCO_LD_VAL_0_WIDTH	13
+#define PMA_VCO_CAL_LD1_VCO_LD_VAL_1_POS	0
+#define PMA_VCO_CAL_LD1_VCO_LD_VAL_1_WIDTH	13
+#define PMA_VCO_CAL_LD2_VCO_LD_VAL_2_POS	0
+#define PMA_VCO_CAL_LD2_VCO_LD_VAL_2_WIDTH	13
+#define PMA_VCO_CAL_LD3_VCO_LD_VAL_3_POS	0
+#define PMA_VCO_CAL_LD3_VCO_LD_VAL_3_WIDTH	13
+
+#define PMA_VCO_CAL_REF0_VCO_REF_LD_0_POS	0
+#define PMA_VCO_CAL_REF0_VCO_REF_LD_0_WIDTH	6
+#define PMA_VCO_CAL_REF0_VCO_REF_LD_1_POS	8
+#define PMA_VCO_CAL_REF0_VCO_REF_LD_1_WIDTH	6
+#define PMA_VCO_CAL_REF1_VCO_REF_LD_2_POS	0
+#define PMA_VCO_CAL_REF1_VCO_REF_LD_2_WIDTH	6
+#define PMA_VCO_CAL_REF1_VCO_REF_LD_3_POS	8
+#define PMA_VCO_CAL_REF1_VCO_REF_LD_3_WIDTH	6
+
+#define PMA_AFE_DFE_EN_CTRL_AFE_EN_0_POS	0
+#define PMA_AFE_DFE_EN_CTRL_AFE_EN_0_WIDTH	1
+#define PMA_AFE_DFE_EN_CTRL_AFE_EN_3_1_POS	1
+#define PMA_AFE_DFE_EN_CTRL_AFE_EN_3_1_WIDTH	3
+
+#define PMA_AFE_DFE_EN_CTRL_DFE_EN_0_POS	4
+#define PMA_AFE_DFE_EN_CTRL_DFE_EN_0_WIDTH	1
+#define PMA_AFE_DFE_EN_CTRL_DFE_EN_3_1_POS	5
+#define PMA_AFE_DFE_EN_CTRL_DFE_EN_3_1_WIDTH	3
+
+#define PMA_RX_EQ_CTRL4_CONT_ADAPT_0_POS	0
+#define PMA_RX_EQ_CTRL4_CONT_ADAPT_0_WIDTH	1
+#define PMA_RX_EQ_CTRL4_CONT_ADAPT_3_1_POS	1
+#define PMA_RX_EQ_CTRL4_CONT_ADAPT_3_1_WIDTH	3
+
+#define PMA_TX_RATE_CTRL_TX_RATE_0_POS		0
+#define PMA_TX_RATE_CTRL_TX_RATE_0_WIDTH	3
+#define PMA_TX_RATE_CTRL_TX_RATE_1_POS		4
+#define PMA_TX_RATE_CTRL_TX_RATE_1_WIDTH	3
+#define PMA_TX_RATE_CTRL_TX_RATE_2_POS		8
+#define PMA_TX_RATE_CTRL_TX_RATE_2_WIDTH	3
+#define PMA_TX_RATE_CTRL_TX_RATE_3_POS		12
+#define PMA_TX_RATE_CTRL_TX_RATE_3_WIDTH	3
+
+#define PMA_RX_RATE_CTRL_RX_RATE_0_POS		0
+#define PMA_RX_RATE_CTRL_RX_RATE_0_WIDTH	2
+#define PMA_RX_RATE_CTRL_RX_RATE_1_POS		4
+#define PMA_RX_RATE_CTRL_RX_RATE_1_WIDTH	2
+#define PMA_RX_RATE_CTRL_RX_RATE_2_POS		8
+#define PMA_RX_RATE_CTRL_RX_RATE_2_WIDTH	2
+#define PMA_RX_RATE_CTRL_RX_RATE_3_POS		12
+#define PMA_RX_RATE_CTRL_RX_RATE_3_WIDTH	2
+
+#define PMA_TX_GENCTRL1_VBOOST_EN_0_POS		4
+#define PMA_TX_GENCTRL1_VBOOST_EN_0_WIDTH	1
+#define PMA_TX_GENCTRL1_VBOOST_LVL_POS		8
+#define PMA_TX_GENCTRL1_VBOOST_LVL_WIDTH	3
+
+#define PMA_TX_GENCTRL2_TX_WIDTH_0_POS		8
+#define PMA_TX_GENCTRL2_TX_WIDTH_0_WIDTH	2
+#define PMA_TX_GENCTRL2_TX_WIDTH_1_POS		10
+#define PMA_TX_GENCTRL2_TX_WIDTH_1_WIDTH	2
+#define PMA_TX_GENCTRL2_TX_WIDTH_2_POS		12
+#define PMA_TX_GENCTRL2_TX_WIDTH_2_WIDTH	2
+#define PMA_TX_GENCTRL2_TX_WIDTH_3_POS		14
+#define PMA_TX_GENCTRL2_TX_WIDTH_3_WIDTH	2
+
+#define PMA_RX_GENCTRL2_RX_WIDTH_0_POS		8
+#define PMA_RX_GENCTRL2_RX_WIDTH_0_WIDTH	2
+#define PMA_RX_GENCTRL2_RX_WIDTH_1_POS		10
+#define PMA_RX_GENCTRL2_RX_WIDTH_1_WIDTH	2
+#define PMA_RX_GENCTRL2_RX_WIDTH_2_POS		12
+#define PMA_RX_GENCTRL2_RX_WIDTH_2_WIDTH	2
+#define PMA_RX_GENCTRL2_RX_WIDTH_3_POS		14
+#define PMA_RX_GENCTRL2_RX_WIDTH_3_WIDTH	2
+
+#define PMA_MPLLA_C2_MPLLA_DIV16P5_CLK_EN_POS	10
+#define PMA_MPLLA_C2_MPLLA_DIV16P5_CLK_EN_WIDTH	1
+#define PMA_MPLLA_C2_MPLLA_DIV10_CLK_EN_POS	9
+#define PMA_MPLLA_C2_MPLLA_DIV10_CLK_EN_WIDTH	1
+#define PMA_MPLLA_C2_MPLLA_DIV8_CLK_EN_POS	8
+#define PMA_MPLLA_C2_MPLLA_DIV8_CLK_EN_WIDTH	1
+
+#define PMA_MPLLB_C2_MPLLB_DIV_CLK_EN_POS	7
+#define PMA_MPLLB_C2_MPLLB_DIV_CLK_EN_WIDTH	1
+#define PMA_MPLLB_C2_MPLLB_DIV10_CLK_EN_POS	9
+#define PMA_MPLLB_C2_MPLLB_DIV10_CLK_EN_WIDTH	1
+#define PMA_MPLLB_C2_MPLLB_DIV8_CLK_EN_POS	8
+#define PMA_MPLLB_C2_MPLLB_DIV8_CLK_EN_WIDTH	1
+
+#define PMA_TX_EQ_C0_TX_EQ_MAIN_POS		8
+#define PMA_TX_EQ_C0_TX_EQ_MAIN_WIDTH		6
+#define PMA_TX_EQ_C0_TX_EQ_PRE_POS		0
+#define PMA_TX_EQ_C0_TX_EQ_PRE_WIDTH		6
+
+#define PMA_TX_EQ_C1_TX_EQ_POST_POS		0
+#define PMA_TX_EQ_C1_TX_EQ_POST_WIDTH		6
+#define PMA_TX_EQ_C1_TX_EQ_OVR_RIDE_POS		6
+#define PMA_TX_EQ_C1_TX_EQ_OVR_RIDE_WIDTH	1
+
+#define PMA_MISC_C0_RX_VREF_CTRL_POS		8
+#define PMA_MISC_C0_RX_VREF_CTRL_WIDTH		5
+
+#define PMA_REF_CLK_CTRL_REF_USE_PAD_POS	1
+#define PMA_REF_CLK_CTRL_REF_USE_PAD_WIDTH	1
+
+#define PMA_CTRL2_PMA_TYPE_POS			0
+#define PMA_CTRL2_PMA_TYPE_WIDTH		4
+
+#define PMA_TX_BOOST_CTRL_TX0_IBOOST_POS	0
+#define PMA_TX_BOOST_CTRL_TX0_IBOOST_WIDTH	3
+#define PMA_TX_BOOST_CTRL_TX1_IBOOST_POS	4
+#define PMA_TX_BOOST_CTRL_TX1_IBOOST_WIDTH	3
+#define PMA_TX_BOOST_CTRL_TX2_IBOOST_POS	8
+#define PMA_TX_BOOST_CTRL_TX2_IBOOST_WIDTH	3
+#define PMA_TX_BOOST_CTRL_TX3_IBOOST_POS	12
+#define PMA_TX_BOOST_CTRL_TX3_IBOOST_WIDTH	3
+
+#define PMA_TX_STS_TX_ACK_0_POS			0
+#define PMA_TX_STS_TX_ACK_0_WIDTH		1
+#define PMA_TX_STS_DETRX_RSLT_0_POS		4
+#define PMA_TX_STS_DETRX_RSLT_0_WIDTH		1
+
+#define PMA_TX_PS_CTRL_TX0_PSTATE_POS		0
+#define PMA_TX_PS_CTRL_TX0_PSTATE_WIDTH		3
+
+#define PMA_STS1_RLU_POS			2
+#define PMA_STS1_RLU_WIDTH			1
+
+#define PMA_STS2_RF_POS				10
+#define PMA_STS2_RF_WIDTH			1
+#define PMA_STS2_TF_POS				11
+#define PMA_STS2_TF_WIDTH			1
+
+#define PMA_KR_PMD_STS_RCV_STS_POS		0
+#define PMA_KR_PMD_STS_RCV_STS_WIDTH		1
+#define PMA_KR_PMD_STS_FRM_LCK_POS		1
+#define PMA_KR_PMD_STS_FRM_LCK_WIDTH		1
+#define PMA_KR_PMD_STS_SU_PR_DTD_POS		2
+#define PMA_KR_PMD_STS_SU_PR_DTD_WIDTH		1
+#define PMA_KR_PMD_STS_TR_FAIL_POS		3
+#define PMA_KR_PMD_STS_TR_FAIL_WIDTH		1
+
+#define PMA_KR_LP_CEU_LP_INIT_POS		12
+#define PMA_KR_LP_CEU_LP_INIT_WIDTH		1
+#define PMA_KR_LP_CEU_LP_PRST_POS		13
+#define PMA_KR_LP_CEU_LP_PRST_WIDTH		1
+
+#define PMA_KR_LP_CESTS_LP_RR_POS		15
+#define PMA_KR_LP_CESTS_LP_RR_WIDTH		1
+
+#define PMA_KR_LD_CEU_LD_INIT_POS		12
+#define PMA_KR_LD_CEU_LD_INIT_WIDTH		1
+#define PMA_KR_LD_CEU_LD_PRST_POS		13
+#define PMA_KR_LD_CEU_LD_PRST_WIDTH		1
+#define PMA_KR_LD_CESTS_LD_RR_POS		15
+#define PMA_KR_LD_CESTS_LD_RR_WIDTH		1
+
+#define PCS_STS1_RLU_POS			2
+#define PCS_STS1_RLU_WIDTH			1
+#define PCS_STS2_RF_POS				10
+#define PCS_STS2_RF_WIDTH			1
+#define PCS_STS2_TF_POS				11
+#define PCS_STS2_TF_WIDTH			1
+#define PCS_STS2_CAP_EN_POS			0
+#define PCS_STS2_CAP_EN_WIDTH			1
+#define PCS_STS2_CAP_10_1GC_POS			1
+#define PCS_STS2_CAP_10_1GC_WIDTH		1
+#define PCS_STS2_CAP_10GBW_POS			2
+#define PCS_STS2_CAP_10GBW_WIDTH		1
+#define PCS_STS2_CAP_10GBT_POS			3
+#define PCS_STS2_CAP_10GBT_WIDTH		1
+#define PCS_STS2_DS_POS				14
+#define PCS_STS2_DS_WIDTH			2
+
+#define PCS_DIG_CTRL1_VR_RST_POS		15
+#define PCS_DIG_CTRL1_VR_RST_WIDTH		1
+#define PCS_DIG_CTRL1_CL37_BP_POS		12
+#define PCS_DIG_CTRL1_CL37_BP_WIDTH		1
+#define PCS_DIG_CTRL1_EN_2_5G_MODE_POS		2
+#define PCS_DIG_CTRL1_EN_2_5G_MODE_WIDTH	1
+#define PCS_DIG_CTRL1_BYP_PWRUP_POS		1
+#define PCS_DIG_CTRL1_BYP_PWRUP_WIDTH		1
+
+#define PCS_CTRL1_RST_POS			15
+#define PCS_CTRL1_RST_WIDTH			1
+
+#define PCS_XAUI_CTRL_XAUI_MODE_POS		0
+#define PCS_XAUI_CTRL_XAUI_MODE_WIDTH		1
+
+#define PCS_CTRL1_SS13_POS			13
+#define PCS_CTRL1_SS13_WIDTH			1
+
+#define PCS_CTRL2_PCS_TYPE_SEL_POS		0
+#define PCS_CTRL2_PCS_TYPE_SEL_WIDTH		2
+
+#define PCS_DIG_STS_PSEQ_STATE_POS		2
+#define PCS_DIG_STS_PSEQ_STATE_WIDTH		3
+
+enum {
+	BACKPL_ETH_PCS = 0,
+	OTHER_PCS_CONFIG = 1
+};
+
+enum {
+	TENG_KR_MODE = 0,
+	TENG_XAUI_MODE,
+	ONEG_XAUI_MODE,
+	TWOP5G_GMII_MODE,
+	MAX_XPCS_MODE,
+};
+
+enum {
+	LANE_1 = 1,
+	LANE_2,
+	LANE_3,
+	LANE_4,
+	LANE_MAX,
+};
+
+enum {
+	PHY_SIDE_SGMII = 0,
+	MAC_SIDE_SGMII = 1
+};
+
+enum {
+	CONN_TYPE_SFP = 0,
+	CONN_TYPE_PHY = 1,
+	CONN_TYPE_MAX,
+};
+
+enum {
+	PMA_TYPE_10G_BASE_CX4 = 0,
+	PMA_TYPE_10G_BASE_EW,
+	PMA_TYPE_10G_BASE_LW,
+	PMA_TYPE_10G_BASE_SW,
+	PMA_TYPE_10G_BASE_LX4,
+	PMA_TYPE_10G_BASE_ER,
+	PMA_TYPE_10G_BASE_LR,
+	PMA_TYPE_10G_BASE_SR,
+	PMA_TYPE_10G_BASE_LRM,
+	PMA_TYPE_10G_BASE_T,
+	PMA_TYPE_10G_BASE_KX4,
+	PMA_TYPE_10G_BASE_KR,
+	PMA_TYPE_1G_BASE_T,
+	PMA_TYPE_1G_BASE_KX,
+	PMA_TYPE_100_BASE_TX,
+	PMA_TYPE_10_BASE_T
+};
+
+enum {
+	PCS_TYPE_10G_BASE_R = 0,
+	PCS_TYPE_10G_BASE_X,
+	PCS_TYPE_10G_BASE_W,
+	PCS_TYPE_RESERVED,
+};
+
+struct xpcs_prv_data;
+
+/* 10G XAUI Mode Switching */
+struct xpcs_mode_cfg {
+	u32 id;
+	u32 pma_type;
+	u32 pcs_type;
+	u32 xaui_mode;
+	u32 lane;
+	u32 mplla_mult;
+	u32 mplla_bw;
+	u32 mpllb_mult;
+	u32 mpllb_bw;
+	u32 vco_ld_val[4];
+	u32 vco_ref_ld[4];
+	u32 afe_en;
+	u32 afe_en_31;
+	u32 dfe_en;
+	u32 dfe_en_31;
+	u32 cont_adapt0;
+	u32 cont_adapt31;
+	u32 tx_rate[4];
+	u32 rx_rate[4];
+	u32 tx_width[4];
+	u32 rx_width[4];
+	u32 mplla_div165_clk_en;
+	u32 mplla_div10_clk_en;
+	u32 mplla_div8_clk_en;
+	u32 mpllb_div_clk_en;
+	u32 mpllb_div10_clk_en;
+	u32 mpllb_div8_clk_en;
+	u32 tx_eq_main;
+	u32 tx_eq_pre;
+	u32 tx_eq_post;
+	u32 tx_eq_ovrride;
+	u32 los_thr;
+	u32 phy_boost_gain_val;
+	u32 rx_vref_ctrl;
+	u32 ref_clk_ctrl;
+	u32 vboost_lvl;
+	u32 tx_iboost[4];
+	int (*set_mode)(struct xpcs_prv_data *);
+};
+
+struct xpcs_prv_data {
+	u32 id;
+	u32 num_resources;
+
+	/* XPCS registers for indirect accessing */
+	void __iomem *addr_base;
+
+	struct device *dev;
+	struct phy *phy;
+
+	/* XPCS Interface Name */
+	const char *name;
+
+	/* XPCS Mode 10G, 1G, 2.5G */
+	u32 mode;
+
+	/* IRQ number */
+	u32 irq_num;
+
+	/* PCS Mode */
+	u32 pcs_mode;
+
+	u32 sgmii_type;
+	u32 duplex;
+
+	u32 mpllb;
+
+	/* Connection Type SFP or PHY */
+	u32 conntype;
+
+	/* XPCS Mode Switching */
+	struct xpcs_mode_cfg *mode_cfg;
+};
+
+#define xpcs_r32(reg)		readl(reg)
+#define xpcs_w32(val, reg)	writel(val, reg)
+
+static inline u32 XPCS_RGRD(struct xpcs_prv_data *pdata, u32 reg)
+{
+	u32 reg_val;
+	u32 shift_addr;
+
+	void __iomem *addr_reg  =
+		(void __iomem *)((u32)pdata->addr_base + (0xFF << 2));
+	void __iomem *data_reg  =
+		(void __iomem *)((u32)pdata->addr_base | (reg & 0x000003FF));
+
+	shift_addr = (u32)(((reg >> 2) & 0x001FFF00) >> 8);
+
+	xpcs_w32(shift_addr, addr_reg);
+	reg_val = xpcs_r32(data_reg);
+
+	/* Dummy register read */
+	xpcs_w32(shift_addr, addr_reg);
+	reg_val = xpcs_r32(data_reg);
+
+	return reg_val;
+}
+
+static inline void XPCS_RGWR(struct xpcs_prv_data *pdata, u32 reg, u32 val)
+{
+	u32 shift_addr;
+	u32 reg_val;
+	void __iomem *addr_reg  =
+		(void __iomem *)((u32)pdata->addr_base + (0xFF << 2));
+	void __iomem *data_reg  =
+		(void __iomem *)((u32)pdata->addr_base | (reg & 0x000003FF));
+
+	shift_addr = (u32)(((reg >> 2) & 0x001FFF00) >> 8);
+
+	xpcs_w32(shift_addr, addr_reg);
+	xpcs_w32(val, data_reg);
+
+	/* Dummy register read */
+	xpcs_w32(shift_addr, addr_reg);
+	reg_val = xpcs_r32(data_reg);
+}
+
+#define GET_N_BITS(reg, pos, n) \
+	(((reg) >> (pos)) & ((0x1 << (n)) - 1))
+
+#define SET_N_BITS(reg, pos, n, val)					\
+	do {								\
+		(reg) &= ~(((0x1 << (n)) - 1) << (pos));              \
+		(reg) |= (((val) & ((0x1 << (n)) - 1)) << (pos));    \
+	} while (0)
+
+#define XPCS_GET_VAL(var, reg, field)				\
+	GET_N_BITS((var),					\
+		   reg##_##field##_POS,				\
+		   reg##_##field##_WIDTH)
+
+#define XPCS_SET_VAL(var, reg, field, val)			\
+	SET_N_BITS((var),					\
+		   reg##_##field##_POS,				\
+		   reg##_##field##_WIDTH, (val))
+
+#define XPCS_RGRD_VAL(pdata, reg, field)			\
+	GET_N_BITS(XPCS_RGRD(pdata, reg),			\
+		   reg##_##field##_POS,				\
+		   reg##_##field##_WIDTH)
+
+#define XPCS_RGWR_VAL(pdata, reg, field, _val)			\
+	do {							\
+		u32 reg_val = XPCS_RGRD(pdata, reg);		\
+		SET_N_BITS(reg_val,				\
+			   reg##_##field##_POS,			\
+			   reg##_##field##_WIDTH, (_val));	\
+		XPCS_RGWR(pdata, reg, reg_val);			\
+	} while (0)
+
+int xpcs_sysfs_init(struct xpcs_prv_data *priv);
+
+#endif
+
diff --git a/drivers/net/ethernet/lantiq/xpcs/xpcs_sysfs.c b/drivers/net/ethernet/lantiq/xpcs/xpcs_sysfs.c
new file mode 100644
index 000000000000..9a772542a53b
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/xpcs/xpcs_sysfs.c
@@ -0,0 +1,540 @@
+/*
+ * Intel XPCS SysFs
+ *
+ * Copyright (C) 2018 Intel, Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/device.h>
+#include "xpcs.h"
+
+static ssize_t
+xpcs_linksts_show(struct device *dev,
+		  struct device_attribute *attr, char *buf)
+{
+	struct xpcs_prv_data *pdata;
+	int off = 0;
+	u32 val;
+
+	pdata = dev_get_drvdata(dev);
+
+	off = sprintf(buf + off, "\n%s: LINK Status\n", pdata->name);
+	off += sprintf(buf + off, "\n");
+
+	off += sprintf(buf + off, "\nPMA Tx status\n");
+	off += sprintf(buf + off, "\n");
+
+	val = XPCS_RGRD_VAL(pdata, PMA_TX_STS, TX_ACK_0);
+	off += sprintf(buf + off, "\tTX_ACK_0:                            %s\n",
+		       val ? "Tx Acknowledge on Lane 0" :
+		       "Tx NOT Acknowledge on Lane 0");
+
+	val = XPCS_RGRD_VAL(pdata, PMA_TX_STS, DETRX_RSLT_0);
+	off += sprintf(buf + off, "\tRx Detection Result on lane 0:       %s\n",
+		       val ? "Rx Detected on Lane 0" :
+		       "Rx NOT Detected on Lane 0");
+
+	val = XPCS_RGRD_VAL(pdata, PMA_TX_PS_CTRL, TX0_PSTATE);
+	off += sprintf(buf + off,
+		       "\tTX0_PSTATE:                          %08x\n",
+		       val);
+
+	off += sprintf(buf + off, "\nPMA Rx status\n");
+	off += sprintf(buf + off, "\n");
+
+	val = XPCS_RGRD_VAL(pdata, PMA_STS1, RLU);
+	off += sprintf(buf + off, "\tPMA_STS:                             %s\n",
+		       val ? "LINK UP" : "LINK DOWN");
+
+	val = XPCS_RGRD_VAL(pdata, PMA_STS2, RF);
+	off += sprintf(buf + off, "\tPMA_STATUS2 RF:                      %s\n",
+		       val ? "Rx Fault" : "Rx No Fault");
+
+	val = XPCS_RGRD_VAL(pdata, PMA_KR_PMD_STS, RCV_STS);
+	off += sprintf(buf + off, "\tPMA_KR_PMD_STS RCV_STS:              %s\n",
+		       val ? "Received trained and ready to receive data" :
+		       "Rx training");
+
+	val = XPCS_RGRD_VAL(pdata, PMA_KR_PMD_STS, FRM_LCK);
+	off += sprintf(buf + off, "\tPMA_KR_PMD_STS FRM_LCK:              %s\n",
+		       val ? "Training frame delineation detected" :
+		       "Training frame delineation not detected");
+
+	val = XPCS_RGRD_VAL(pdata, PMA_KR_PMD_STS, SU_PR_DTD);
+	off += sprintf(buf + off, "\tPMA_KR_PMD_STS SU_PR_DTD:            %s\n",
+		       val ? "Start-up protocol in progress" :
+		       "Start-up protocol complete");
+
+	val = XPCS_RGRD_VAL(pdata, PMA_KR_PMD_STS, TR_FAIL);
+	off += sprintf(buf + off, "\tPMA_KR_PMD_STS TR_FAIL:              %s\n",
+		       val ? "Training is completed with failure" :
+		       "Training is not yet complete");
+
+	off += sprintf(buf + off, "\n10GBASE-KR LP coeff Update\n");
+	off += sprintf(buf + off, "\n");
+
+	val = XPCS_RGRD_VAL(pdata, PMA_KR_LP_CEU, LP_INIT);
+	off += sprintf(buf + off, "\tPMA_KR_PMD_STS LP_INIT:              %s\n",
+		       val ? "Init the local device tx filter coeff" :
+		       "Normal operation");
+
+	val = XPCS_RGRD_VAL(pdata, PMA_KR_LP_CEU, LP_PRST);
+	off += sprintf(buf + off, "\tPMA_KR_PMD_STS LP_PRST:              %s\n",
+		       val ? "LD Pre-initialize coeffs" :
+		       "Normal operation");
+
+	off += sprintf(buf + off, "\n10GBASE-KR LP coeff Status\n");
+	off += sprintf(buf + off, "\n");
+
+	val = XPCS_RGRD_VAL(pdata, PMA_KR_LP_CESTS, LP_RR);
+	off += sprintf(buf + off, "\tPMA_KR_LP_CESTS LP_RR:               %s\n",
+		       val ? "The LP rx has determined that the training is "
+		       "complete, and it is ready to receive data." :
+		       "The LP rx is requesting that the training "
+		       "should be continued.");
+
+	off += sprintf(buf + off, "\n10GBASE-KR LD coeff Update Local Device "
+		       "requests to Link Partner.\n");
+	off += sprintf(buf + off, "\n");
+
+	val = XPCS_RGRD_VAL(pdata, PMA_KR_LD_CEU, LD_INIT);
+	off += sprintf(buf + off, "\tPMA_KR_LD_CEU LD_INIT:               %s\n",
+		       val ? "Init the link partner tx filter coeff" :
+		       "Normal operation");
+
+	val = XPCS_RGRD_VAL(pdata, PMA_KR_LD_CEU, LD_PRST);
+	off += sprintf(buf + off, "\tPMA_KR_LD_CEU PRST:                  %s\n",
+		       val ? "LP Pre-initialize coeffs" :
+		       "Normal operation");
+
+	off += sprintf(buf + off, "\n10GBASE-KR LD coeff Status\n");
+	off += sprintf(buf + off, "\n");
+
+	val = XPCS_RGRD_VAL(pdata, PMA_KR_LD_CESTS, LD_RR);
+	off += sprintf(buf + off, "\tPMA_KR_LD_CESTS RR:                  %s\n",
+		       val ? "The LD rx has determined that the training is "
+		       "complete, and it is ready to receive data." :
+		       "The LD rx is requesting that the training "
+		       "should be continued.");
+
+	off += sprintf(buf + off, "\nAutonegotiation Status Register\n");
+	off += sprintf(buf + off, "\n");
+
+	val = XPCS_RGRD_VAL(pdata, AN_STS, LP_AN_ABL);
+	off += sprintf(buf + off, "\tLP AN Ability:                       %s\n",
+		       val ? "LP able to participate in AN" :
+		       "LP unable to participate in AN");
+
+	val = XPCS_RGRD_VAL(pdata, AN_STS, AN_LS);
+	off += sprintf(buf + off, "\tAN Link Status:                      %s\n",
+		       val ? "CL73 AN complete and determined a valid link" :
+		       "CL73 not complete and no valid link");
+
+	val = XPCS_RGRD_VAL(pdata, AN_STS, AN_ABL);
+	off += sprintf(buf + off, "\tLD AN Ability:                       %s\n",
+		       val ? "LD supports CL73 AN" :
+		       "LD does not support CL73 AN");
+
+	val = XPCS_RGRD_VAL(pdata, AN_STS, AN_RF);
+	off += sprintf(buf + off, "\tAN Remote Fault:                     %s\n",
+		       val ? "AN process detected a remote fault" :
+		       "No fault detected");
+
+	val = XPCS_RGRD_VAL(pdata, AN_STS, ANC);
+	off += sprintf(buf + off, "\tAN Complete:                         %s\n",
+		       val ? "AN completes" :
+		       "AN not complete");
+
+	val = XPCS_RGRD_VAL(pdata, AN_STS, PR);
+	off += sprintf(buf + off, "\tPage Received:                       %s\n",
+		       val ? "Page is received and the corresponding "
+		       "Link Code Word is stored " : "No page received");
+
+	val = XPCS_RGRD_VAL(pdata, AN_STS, PDF);
+	off += sprintf(buf + off, "\tParallel Detection Fault in CL73 :   %s\n",
+		       val ? "Parallel detection fault detected " :
+		       "No fault detected");
+
+	off += sprintf(buf + off, "\nPCS Rx Status\n");
+	off += sprintf(buf + off, "\n");
+
+	val = XPCS_RGRD_VAL(pdata, PCS_STS1, RLU);
+	off += sprintf(buf + off, "\tPCS_STS:                             %s\n",
+		       val ? "LINK UP" : "LINK DOWN");
+
+	val = XPCS_RGRD_VAL(pdata, PCS_STS2, RF);
+	off += sprintf(buf + off, "\tPCS_STATUS2 RF:                      %s\n",
+		       val ? "Rx Fault" : "Rx No Fault");
+
+	val = XPCS_RGRD_VAL(pdata, PCS_STS2, TF);
+	off += sprintf(buf + off, "\tPCS_STATUS2 TF:                      %s\n",
+		       val ? "Tx Fault" : "Tx No Fault");
+
+	val = XPCS_RGRD_VAL(pdata, PCS_STS2, CAP_EN);
+	off += sprintf(buf + off, "\tCAP_EN:                              %s\n",
+		       val ? "10GBASE-R Capable" : "10GBASE-R Not Capable");
+
+	val = XPCS_RGRD_VAL(pdata, PCS_STS2, CAP_10_1GC);
+	off += sprintf(buf + off, "\tCAP_10_1GC:                          %s\n",
+		       val ? "10GBASE-X Capable" : "10GBASE-X Not Capable");
+
+	val = XPCS_RGRD_VAL(pdata, PCS_STS2, CAP_10GBW);
+	off += sprintf(buf + off, "\tCAP_10GBW:                           %s\n",
+		       val ? "10GBASE-W Capable" : "10GBASE-W Not Capable");
+
+	val = XPCS_RGRD_VAL(pdata, PCS_STS2, CAP_10GBT);
+	off += sprintf(buf + off, "\tCAP_10GBT:                           %s\n",
+		       val ? "10GBASE-T Capable" : "10GBASE-T Not Capable");
+
+	val = XPCS_RGRD_VAL(pdata, PCS_STS2, DS);
+	off += sprintf(buf + off, "\tDS:                                  %s\n",
+		       (val == 2) ?
+		       "MMD is present and responding to this reg addr" :
+		       "MMD is not present or not functioning properly");
+
+	val = XPCS_RGRD(pdata, PCS_KR_STS2);
+	off += sprintf(buf + off,
+		       "\tPCS_KR_STS2 :                        %08X\n", val);
+
+	val = XPCS_RGRD_VAL(pdata, PCS_CTRL2, PCS_TYPE_SEL);
+
+	if (val == 0) {
+		off += sprintf(buf + off,
+			       "\tPCS_TYPE_SEL:                        %s\n",
+			       "10GBASE-R PCS Type");
+	} else if (val == 1) {
+		off += sprintf(buf + off,
+			       "\tPCS_TYPE_SEL:                        %s\n",
+			       "10GBASE-X PCS Type");
+	} else if (val == 2) {
+		off += sprintf(buf + off,
+			       "\tPCS_TYPE_SEL:                        %s\n",
+			       "10GBASE-W PCS Type");
+	} else {
+		off += sprintf(buf + off,
+			       "\tPCS_TYPE_SEL:                        %s\n",
+			       "Reserved");
+	}
+
+	off += sprintf(buf + off, "\nMII Status\n");
+	off += sprintf(buf + off, "\n");
+
+	val = XPCS_RGRD_VAL(pdata, SR_MII_STS, LINK_STS);
+	off += sprintf(buf + off, "\t1000BASE-X mode Rx:                  %s\n",
+		       val ? "LINK UP" : "LINK DOWN");
+
+	val = XPCS_RGRD_VAL(pdata, VR_MII_AN_CTRL, SGMII_LINK_STS);
+	off += sprintf(buf + off, "\tSGMII/QSGMII/USXGMII mode Port0 Rx:  %s\n",
+		       val ? "LINK UP" : "LINK DOWN");
+
+	return off;
+}
+
+static DEVICE_ATTR_RO(xpcs_linksts);
+
+static ssize_t
+xpcs_cl73_info_show(struct device *dev,
+		    struct device_attribute *attr, char *buf)
+{
+	struct xpcs_prv_data *pdata;
+	int off = 0;
+	u32 val;
+
+	pdata = dev_get_drvdata(dev);
+
+	off = sprintf(buf + off, "\n%s: CL 73 Status\n", pdata->name);
+	off += sprintf(buf + off, "\n");
+
+	val = XPCS_RGRD_VAL(pdata, AN_INTR, AN_INT_CMPLT);
+	off += sprintf(buf + off, "AN_INT_COMPL:                          %s\n",
+		       val ? "SET" : "NOT_SET");
+
+	val = XPCS_RGRD_VAL(pdata, AN_INTR, AN_INC_LINK);
+	off += sprintf(buf + off, "AN_INC_LINK:                           %s\n",
+		       val ? "SET" : "NOT_SET");
+
+	val = XPCS_RGRD_VAL(pdata, AN_INTR, AN_PG_RCV);
+	off += sprintf(buf + off, "AN_PG_RCV:                             %s\n",
+		       val ? "SET" : "NOT_SET");
+
+	val = XPCS_RGRD_VAL(pdata, AN_STS, LP_AN_ABL);
+	off += sprintf(buf + off, "AN_STS:                                %s\n",
+		       val ? "LP able to participate in AN" :
+		       "LP unable to participate in AN");
+
+	val = XPCS_RGRD_VAL(pdata, AN_STS, AN_LS);
+	off += sprintf(buf + off, "AN_STS:                                %s\n",
+		       val ? "CL73 AN complete and determined a valid link" :
+		       "CL73 not complete and no valid link");
+
+	val = XPCS_RGRD_VAL(pdata, AN_STS, AN_ABL);
+	off += sprintf(buf + off, "AN_STS:                                %s\n",
+		       val ? "LD supports CL73 AN" :
+		       "LD does not support CL73 AN");
+
+	val = XPCS_RGRD_VAL(pdata, AN_STS, AN_RF);
+	off += sprintf(buf + off, "AN_STS:                                %s\n",
+		       val ? "AN process detected a remote fault" :
+		       "No fault detected");
+
+	val = XPCS_RGRD_VAL(pdata, AN_STS, ANC);
+	off += sprintf(buf + off, "AN_STS:                                %s\n",
+		       val ? "AN completes" :
+		       "AN not complete");
+
+	val = XPCS_RGRD_VAL(pdata, AN_STS, PR);
+	off += sprintf(buf + off, "AN_STS:                                %s\n",
+		       val ? "Parallel detection fault detected " :
+		       "No fault detected");
+
+	val = XPCS_RGRD_VAL(pdata, AN_STS, PDF);
+	off += sprintf(buf + off, "AN_STS:                                %s\n",
+		       val ? "Parallel detection fault detected " :
+		       "No fault detected");
+
+	return off;
+}
+
+static DEVICE_ATTR_RO(xpcs_cl73_info);
+
+static ssize_t
+xpcs_table_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct xpcs_prv_data *pdata;
+	int off = 0;
+	u32 val;
+	u32 mplla_ctrl2 = 0, afe_dfe_ctrl;
+	u32 tx_eq0, tx_eq1;
+
+	pdata = dev_get_drvdata(dev);
+
+	off = sprintf(buf + off, "\n%s: Table Show\n", pdata->name);
+	off += sprintf(buf + off, "\n");
+
+	off += sprintf(buf + off, "ID:                            %d\n",
+		       pdata->mode_cfg->id);
+	off += sprintf(buf + off, "\n");
+
+	val = XPCS_RGRD_VAL(pdata, PMA_MPLLA_C0, MPLLA_MULTIPLIER);
+	off += sprintf(buf + off, "MPLLA_MULTIPLIER:              %x\n", val);
+
+	val = XPCS_RGRD_VAL(pdata, PMA_MPLLA_C3, MPPLA_BANDWIDTH);
+	off += sprintf(buf + off, "MPPLA_BANDWIDTH:               %x\n", val);
+
+	switch (pdata->mode_cfg->lane) {
+	case LANE_4:
+		val = XPCS_RGRD_VAL(pdata, PMA_VCO_CAL_LD3, VCO_LD_VAL_3);
+		off += sprintf(buf + off, "VCO_LD_VAL_3:                  %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_VCO_CAL_REF1, VCO_REF_LD_3);
+		off += sprintf(buf + off, "VCO_REF_LD_3:                  %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_TX_RATE_CTRL, TX_RATE_3);
+		off += sprintf(buf + off, "TX_RATE_3:                     %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_RX_RATE_CTRL, RX_RATE_3);
+		off += sprintf(buf + off, "RX_RATE_3:                     %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_TX_GENCTRL2, TX_WIDTH_3);
+		off += sprintf(buf + off, "TX_WIDTH_3:                    %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_RX_GENCTRL2, RX_WIDTH_3);
+		off += sprintf(buf + off, "RX_WIDTH_3:                    %x\n",
+			       val);
+
+	case LANE_3:
+		val = XPCS_RGRD_VAL(pdata, PMA_VCO_CAL_LD2, VCO_LD_VAL_2);
+		off += sprintf(buf + off, "VCO_LD_VAL_2:                  %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_VCO_CAL_REF1, VCO_REF_LD_2);
+		off += sprintf(buf + off, "VCO_REF_LD_2:                  %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_TX_RATE_CTRL, TX_RATE_2);
+		off += sprintf(buf + off, "TX_RATE_2:                     %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_RX_RATE_CTRL, RX_RATE_2);
+		off += sprintf(buf + off, "RX_RATE_2:                     %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_TX_GENCTRL2, TX_WIDTH_2);
+		off += sprintf(buf + off, "TX_WIDTH_2:                    %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_RX_GENCTRL2, RX_WIDTH_2);
+		off += sprintf(buf + off, "RX_WIDTH_2:                    %x\n",
+			       val);
+
+	case LANE_2:
+		val = XPCS_RGRD_VAL(pdata, PMA_VCO_CAL_LD1, VCO_LD_VAL_1);
+		off += sprintf(buf + off, "VCO_LD_VAL_1:                  %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_VCO_CAL_REF0, VCO_REF_LD_1);
+		off += sprintf(buf + off, "VCO_REF_LD_1:                  %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_TX_RATE_CTRL, TX_RATE_1);
+		off += sprintf(buf + off, "TX_RATE_1:                     %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_RX_RATE_CTRL, RX_RATE_1);
+		off += sprintf(buf + off, "RX_RATE_1:                     %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_TX_GENCTRL2, TX_WIDTH_1);
+		off += sprintf(buf + off, "TX_WIDTH_1:                    %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_RX_GENCTRL2, RX_WIDTH_1);
+		off += sprintf(buf + off, "RX_WIDTH_1:                    %x\n",
+			       val);
+
+	case LANE_1:
+		val = XPCS_RGRD_VAL(pdata, PMA_VCO_CAL_LD0, VCO_LD_VAL_0);
+		off += sprintf(buf + off, "VCO_LD_VAL_0:                  %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_VCO_CAL_REF0, VCO_REF_LD_0);
+		off += sprintf(buf + off, "VCO_REF_LD_0:                  %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_TX_RATE_CTRL, TX_RATE_0);
+		off += sprintf(buf + off, "TX_RATE_0:                     %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_RX_RATE_CTRL, RX_RATE_0);
+		off += sprintf(buf + off, "RX_RATE_0:                     %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_TX_GENCTRL2, TX_WIDTH_0);
+		off += sprintf(buf + off, "TX_WIDTH_0:                    %x\n",
+			       val);
+
+		val = XPCS_RGRD_VAL(pdata, PMA_RX_GENCTRL2, RX_WIDTH_0);
+		off += sprintf(buf + off, "RX_WIDTH_0:                    %x\n",
+			       val);
+
+		break;
+
+	default:
+		break;
+	}
+
+	afe_dfe_ctrl = XPCS_RGRD(pdata, PMA_AFE_DFE_EN_CTRL);
+
+	val = XPCS_GET_VAL(val, PMA_AFE_DFE_EN_CTRL, AFE_EN_0);
+	off += sprintf(buf + off, "AFE_EN_0:                      %x\n", val);
+
+	val = XPCS_GET_VAL(val, PMA_AFE_DFE_EN_CTRL, AFE_EN_3_1);
+	off += sprintf(buf + off, "AFE_EN_3_1:                    %x\n", val);
+
+	val = XPCS_GET_VAL(val, PMA_AFE_DFE_EN_CTRL, DFE_EN_0);
+	off += sprintf(buf + off, "DFE_EN_0:                      %x\n", val);
+
+	val = XPCS_GET_VAL(val, PMA_AFE_DFE_EN_CTRL, DFE_EN_3_1);
+	off += sprintf(buf + off, "DFE_EN_3_1:                    %x\n", val);
+
+	val = XPCS_RGRD_VAL(pdata, PMA_RX_EQ_CTRL4, CONT_ADAPT_0);
+	off += sprintf(buf + off, "CONT_ADAPT_0:                  %x\n", val);
+
+	val = XPCS_RGRD_VAL(pdata, PMA_RX_EQ_CTRL4, CONT_ADAPT_3_1);
+	off += sprintf(buf + off, "CONT_ADAPT_3_1:                %x\n", val);
+
+	mplla_ctrl2 = XPCS_RGRD(pdata, PMA_MPLLA_C2);
+
+	val = XPCS_GET_VAL(mplla_ctrl2, PMA_MPLLA_C2, MPLLA_DIV16P5_CLK_EN);
+	off += sprintf(buf + off, "MPLLA_DIV16P5_CLK_EN:          %x\n", val);
+
+	val = XPCS_GET_VAL(mplla_ctrl2, PMA_MPLLA_C2, MPLLA_DIV10_CLK_EN);
+	off += sprintf(buf + off, "MPLLA_DIV10_CLK_EN:            %x\n", val);
+
+	val = XPCS_GET_VAL(mplla_ctrl2, PMA_MPLLA_C2, MPLLA_DIV8_CLK_EN);
+	off += sprintf(buf + off, "MPLLA_DIV8_CLK_EN:             %x\n", val);
+
+	tx_eq0 = XPCS_RGRD(pdata, PMA_TX_EQ_C0);
+
+	val = XPCS_GET_VAL(tx_eq0, PMA_TX_EQ_C0, TX_EQ_MAIN);
+	off += sprintf(buf + off, "TX_EQ_MAIN:                    %x\n", val);
+
+	val = XPCS_GET_VAL(tx_eq0, PMA_TX_EQ_C0, TX_EQ_PRE);
+	off += sprintf(buf + off, "TX_EQ_PRE:                     %x\n", val);
+
+	tx_eq1 = XPCS_RGRD(pdata, PMA_TX_EQ_C1);
+
+	val = XPCS_GET_VAL(tx_eq1, PMA_TX_EQ_C1, TX_EQ_POST);
+	off += sprintf(buf + off, "TX_EQ_POST:                    %x\n", val);
+
+	val = XPCS_GET_VAL(tx_eq1, PMA_TX_EQ_C1, TX_EQ_OVR_RIDE);
+	off += sprintf(buf + off, "TX_EQ_OVR_RIDE:                %x\n", val);
+
+	return off;
+}
+
+static DEVICE_ATTR_RO(xpcs_table);
+
+static const char *xpcs_status_strings[] = {
+	"Wait for Ack High 0",
+	"Wait for Ack Low 0",
+	"Wait for Ack High 1",
+	"Wait for Ack Low 1",
+	"Tx/Rx Stable (Power_Good state)",
+	"Power Save state",
+	"Power Down state",
+};
+
+static ssize_t xpcs_status_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct xpcs_prv_data *pdata;
+	int off = 0;
+	u32 val = 0;
+
+	pdata = dev_get_drvdata(dev);
+
+	off = sprintf(buf + off, "\n%s: RX/TX Stable Status\n", pdata->name);
+	off += sprintf(buf + off, "\n");
+
+	val = XPCS_RGRD_VAL(pdata, PCS_DIG_STS, PSEQ_STATE);
+
+	if (val < ARRAY_SIZE(xpcs_status_strings))
+		off += sprintf(buf + off, "\tStatus:		      %s\n",
+			       xpcs_status_strings[val]);
+	else
+		off += sprintf(buf + off, "\tStatus:		      %s\n",
+			       "Unknown/Invalid Status");
+
+	return off;
+}
+static DEVICE_ATTR_RO(xpcs_status);
+
+static struct attribute *xpcs_attrs[] = {
+	&dev_attr_xpcs_cl73_info.attr,
+	&dev_attr_xpcs_status.attr,
+	&dev_attr_xpcs_table.attr,
+	&dev_attr_xpcs_linksts.attr,
+	NULL,
+};
+
+ATTRIBUTE_GROUPS(xpcs);
+
+int xpcs_sysfs_init(struct xpcs_prv_data *priv)
+{
+	return sysfs_create_groups(&priv->dev->kobj, xpcs_groups);
+}
+
diff --git a/drivers/phy/intel/Kconfig b/drivers/phy/intel/Kconfig
new file mode 100644
index 000000000000..e59ea4abc4da
--- /dev/null
+++ b/drivers/phy/intel/Kconfig
@@ -0,0 +1,32 @@
+#
+# Phy driver for intel platforms
+#
+
+config PHY_INTEL_WAN_XPCS
+	tristate "Intel WAN XPCS PHY driver"
+	depends on OF
+	depends on SOC_GRX500
+	select GENERIC_PHY
+	help
+	  Enable this to support Intel WAN XPCS PHY
+
+config PHY_INTEL_COMBO
+	bool "Intel Combo PHY driver"
+	depends on OF && HAS_IOMEM
+	depends on SOC_GRX500
+	select MFD_SYSCON
+	select GENERIC_PHY
+	help
+	  Enable this to support Intel Combo-PHY.
+	  Intel Combo-PHY support two separate PCIe,
+	  PCIe x2, two separate ethernet PHYs,
+	  ethernet PHY x2, or PCIe/Ethernet PHY mixed mode.
+
+config PHY_INTEL_SLIM
+	bool "Intel Slim driver"
+	depends on OF
+	depends on SOC_GRX500
+	select MFD_SYSCON
+	select GENERIC_PHY
+	help
+	  Enable this to support Intel GRX500 platform for PCIe PHY.
diff --git a/drivers/phy/intel/Makefile b/drivers/phy/intel/Makefile
new file mode 100644
index 000000000000..36fb5c184e10
--- /dev/null
+++ b/drivers/phy/intel/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_PHY_INTEL_COMBO)		+= phy-intel-combo.o
+obj-$(CONFIG_PHY_INTEL_WAN_XPCS)	+= phy-intel-wan-xpcs.o
+obj-$(CONFIG_PHY_INTEL_SLIM)		+= phy-intel-slim.o
diff --git a/drivers/phy/intel/phy-intel-combo.c b/drivers/phy/intel/phy-intel-combo.c
new file mode 100755
index 000000000000..c511ed8e5fe5
--- /dev/null
+++ b/drivers/phy/intel/phy-intel-combo.c
@@ -0,0 +1,1242 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Intel Combo-PHY driver
+ *
+ * Copyright (C) 2017 Intel Corporation.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/of_address.h>
+#include <linux/of_pci.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/phy/phy.h>
+
+#define CLK_100MHZ	100000000	/* 100MHZ */
+#define CLK_156MHZ	156250000	/* 156.25Mhz */
+#define CLK_78MHZ	78125000	/* 78.125Mhz */
+
+#define PCIE_PHY_GEN_CTRL		0x00
+#define PCIE_PHY_CLK_PAD		17
+#define IFMUX_CFG			0x120
+#define PCIE_RCLK(x)			(22 + (x))
+#define PCIE_SEL(x)			(((x) == 0) ? 20 : 19)
+#define PCIE_PHY_MPLLA_CTRL		0x10
+#define PCIE_PHY_MPLLB_CTRL		0x14
+
+#define COMBO_PHY_ID(x)	((x)->parent->id)
+#define PHY_ID(x)	((x)->id)
+
+static const char * const intel_phy_names[] = {"pcie", "xpcs", "sata"};
+
+static int intel_combo_phy_init(struct phy *phy);
+static int intel_combo_phy_exit(struct phy *phy);
+static int intel_combo_phy_power_on(struct phy *phy);
+static int intel_combo_phy_power_off(struct phy *phy);
+
+enum {
+	PHY_0 = 0,
+	PHY_1 = 1,
+	PHY_MAX_NUM = 2,
+};
+
+enum intel_phy_mode {
+	PHY_PCIE_MODE = 0,
+	PHY_XPCS_MODE,
+	PHY_SATA_MODE,
+	PHY_MAX_MODE
+};
+
+enum combo_phy_mode {
+	PCIE0_PCIE1_MODE = 0,
+	PCIE_DL_MODE, /* PCIe dual lane */
+	RXAUI_MODE,   /* XPCS dual lane */
+	XPCS0_XPCS1_MODE,
+	XPCS0_PCIE1_MODE,
+	PCIE0_XPCS1_MODE,
+	SATA0_XPCS1_MODE,
+	SATA0_PCIE1_MODE,
+	COMBO_PHY_MODE_MAX
+};
+
+enum {
+	PHY_PCIE_CAP = BIT(PHY_PCIE_MODE),
+	PHY_XPCS_CAP = BIT(PHY_XPCS_MODE),
+	PHY_SATA_CAP = BIT(PHY_SATA_MODE),
+};
+
+enum aggregated_mode {
+	PHY_SL_MODE = 1, /* Single Lane mode */
+	PHY_DL_MODE,	/* Dual Lane mode */
+};
+
+enum intel_phy_role {
+	PHY_INDIVIDUAL = 0,	/* Not aggr phy mode */
+	PHY_MASTER,		/* DL mode, PHY 0 */
+	PHY_SLAVE,		/* DL mode, PHY 1 */
+};
+
+struct intel_combo_phy;
+
+struct phy_ctx {
+	u32 id; /* Internal PHY idx 0 - 1 */
+	bool enable;
+	struct intel_combo_phy *parent;
+	enum intel_phy_mode phy_mode;
+	bool power_en;
+	enum intel_phy_role phy_role;
+	struct phy *phy;
+	void __iomem *cr_base;
+	void __iomem *pcie_base;
+	struct clk *phy_freq_clk;
+	struct clk *phy_gate_clk;
+	unsigned long phy_clk_rate[PHY_MAX_MODE];
+	struct reset_control *phy_rst;
+	struct reset_control *core_rst[PHY_MAX_MODE];
+	struct device	*dev;
+	struct platform_device *pdev;
+	struct device_node *np;
+};
+
+struct intel_cbphy_soc_data {
+	char *name;
+	unsigned long (*get_clk_rate)(enum intel_phy_mode mode);
+	u32 (*get_phy_cap)(unsigned int id);
+	int (*reset_ctrl)(struct phy_ctx *iphy, enum intel_phy_mode mode);
+	int (*phy_cr_cfg)(struct phy_ctx *iphy, enum intel_phy_mode mode);
+	void (*combo_phy_mode_set)(struct intel_combo_phy *priv);
+};
+
+struct intel_combo_phy {
+	u32 id; /* Physical COMBO PHY Index */
+	u32 phy_cap; /* phy capability, depends on SoC and PHY ID */
+	enum combo_phy_mode cb_phy_mode;
+	enum aggregated_mode aggr_mode;
+	bool enable[PHY_MAX_NUM];
+	enum intel_phy_mode phy_mode[PHY_MAX_NUM];
+	struct platform_device *pdev;
+	struct device	*dev;
+	struct device_node *np;
+	struct regmap	*syscfg;
+	struct reset_control *phy_global_rst;
+
+	const struct intel_cbphy_soc_data *soc_data;
+	struct phy_ctx phy[PHY_MAX_NUM];
+};
+
+static const struct phy_ops intel_cbphy_ops = {
+	.init = intel_combo_phy_init,
+	.exit = intel_combo_phy_exit,
+	.power_on = intel_combo_phy_power_on,
+	.power_off = intel_combo_phy_power_off,
+};
+
+static ssize_t
+combo_phy_info_show(struct device *dev,
+		    struct device_attribute *attr, char *buf)
+{
+	struct intel_combo_phy *priv;
+	int i, off;
+
+	priv = dev_get_drvdata(dev);
+
+	/* combo phy mode */
+	off = sprintf(buf, "mode: %u\n", priv->cb_phy_mode);
+
+	/* aggr mode */
+	off += sprintf(buf + off, "aggr mode: %s\n",
+		      priv->aggr_mode == PHY_DL_MODE ? "Yes" : "No");
+
+	/* combo phy capability */
+	off += sprintf(buf + off, "capability: ");
+	for (i = PHY_PCIE_MODE; i < PHY_MAX_MODE; i++) {
+		if (BIT(i) & priv->phy_cap)
+			off += sprintf(buf + off, "%s ", intel_phy_names[i]);
+	}
+	off += sprintf(buf + off, "\n");
+
+	/* individual phy mode */
+	for (i = 0; i < PHY_MAX_NUM; i++) {
+		off += sprintf(buf + off, "PHY%d mode: %s, enable: %s\n",
+			       i, intel_phy_names[priv->phy_mode[i]],
+			       priv->enable[i] ? "Yes" : "No");
+	}
+
+	off += sprintf(buf + off, "SoC: %s\n", priv->soc_data->name);
+
+	return off;
+}
+
+static DEVICE_ATTR_RO(combo_phy_info);
+
+static struct attribute *combo_phy_attrs[] = {
+	&dev_attr_combo_phy_info.attr,
+	NULL,
+};
+
+ATTRIBUTE_GROUPS(combo_phy);
+
+/* driver functions */
+static inline u32 combo_phy_r32(void __iomem *base, u32 reg)
+{
+	return readl(base + reg);
+}
+
+static inline void combo_phy_w32(void __iomem *base, u32 val, unsigned int reg)
+{
+	writel(val, base + reg);
+}
+
+static inline void combo_phy_w32_off_mask(void __iomem *base, u32 off,
+					  u32 mask, u32 set, unsigned int reg)
+{
+	u32 val;
+
+	val = combo_phy_r32(base, reg) & (~(mask << off));
+	val |= (set & mask) << off;
+	combo_phy_w32(base, val, reg);
+}
+
+static inline void combo_phy_w32_mask(void __iomem *base, u32 clr,
+				      u32 set, unsigned int reg)
+{
+	combo_phy_w32(base, (combo_phy_r32(base, reg) & ~(clr)) | set, reg);
+}
+
+static inline void combo_phy_reg_bit_set(void __iomem *base, u32 off,
+					 unsigned int reg)
+{
+	combo_phy_w32_off_mask(base, off, 1, 1, reg);
+}
+
+static inline void combo_phy_reg_bit_clr(void __iomem *base, u32 off,
+					 unsigned int reg)
+{
+	combo_phy_w32_off_mask(base, off, 1, 0, reg);
+}
+
+static struct phy_ctx *intel_get_combo_slave(struct phy_ctx *iphy)
+{
+	struct intel_combo_phy *priv = iphy->parent;
+	struct phy_ctx *phy_slave;
+
+	phy_slave = &priv->phy[PHY_1];
+
+	WARN_ON_ONCE(phy_slave->phy_role != PHY_SLAVE);
+	WARN_ON_ONCE(phy_slave == iphy);
+
+	return phy_slave;
+}
+
+static int
+intel_cbphy_cfg(struct phy_ctx *iphy, bool aggr,
+		int (*phy_cfg)(struct phy_ctx *))
+{
+	struct phy_ctx *phy_sl;
+	int ret;
+
+	ret = phy_cfg(iphy);
+	if (ret)
+		return ret;
+
+	if (aggr) {
+		phy_sl = intel_get_combo_slave(iphy);
+		if (!phy_sl)
+			return -ENODEV;
+		return phy_cfg(phy_sl);
+	}
+
+	return 0;
+}
+
+static int intel_phy_rst_assert(struct phy_ctx *iphy)
+{
+	if (iphy->phy_rst)
+		if (reset_control_assert(iphy->phy_rst))
+			return -EINVAL;
+
+	return 0;
+}
+
+static int intel_phy_rst_deassert(struct phy_ctx *iphy)
+{
+	if (iphy->phy_rst) {
+		if (reset_control_deassert(iphy->phy_rst))
+			return -EINVAL;
+	}
+	udelay(1);
+
+	return 0;
+}
+
+static int intel_core_rst_assert(struct phy_ctx *iphy)
+{
+	enum intel_phy_mode phy_mode = iphy->phy_mode;
+
+	if (iphy->core_rst[phy_mode])
+		if (reset_control_assert(iphy->core_rst[phy_mode]))
+			return -EINVAL;
+
+	udelay(1);
+
+	return 0;
+}
+
+static int intel_core_rst_deassert(struct phy_ctx *iphy)
+{
+	enum intel_phy_mode phy_mode = iphy->phy_mode;
+
+	if (iphy->core_rst[phy_mode]) {
+		if (reset_control_deassert(iphy->core_rst[phy_mode]))
+			return -EINVAL;
+	}
+
+	udelay(2);
+
+	return 0;
+}
+
+static int intel_phy_gate_clk_enable(struct phy_ctx *iphy)
+{
+	if (iphy->phy_gate_clk)
+		if (clk_prepare_enable(iphy->phy_gate_clk))
+			return -EINVAL;
+
+	return 0;
+}
+
+static void intel_phy_gate_clk_disable(struct phy_ctx *iphy)
+{
+	if (iphy->phy_gate_clk)
+		clk_disable_unprepare(iphy->phy_gate_clk);
+}
+
+static int intel_phy_freq_clk_enable(struct phy_ctx *iphy)
+{
+	if (iphy->phy_freq_clk)
+		if (clk_prepare_enable(iphy->phy_freq_clk))
+			return -EINVAL;
+
+	return 0;
+}
+
+static void intel_phy_freq_clk_disable(struct phy_ctx *iphy)
+{
+	if (iphy->phy_freq_clk)
+		clk_disable_unprepare(iphy->phy_freq_clk);
+}
+
+static int intel_phy_clk_freq_set(struct phy_ctx *iphy)
+{
+	enum intel_phy_mode phy_mode = iphy->phy_mode;
+
+	if (iphy->phy_freq_clk && iphy->phy_clk_rate[phy_mode]) {
+		if (clk_set_rate(iphy->phy_freq_clk,
+				 iphy->phy_clk_rate[phy_mode]))
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int intel_pcie_set_clk_src(struct phy_ctx *iphy)
+{
+	combo_phy_reg_bit_clr(iphy->pcie_base,
+			      PCIE_PHY_CLK_PAD, PCIE_PHY_GEN_CTRL);
+	/*
+	 * NB, no way to identify gen1/2/3/4 for mppla and mpplb, just delay
+	 * for stable plla(gen1/gen2) or pllb(gen3/gen4)
+	 */
+	usleep_range(50, 100);
+
+	dev_dbg(iphy->dev, "%s PHY%d MPLLA %x MPLLB %x\n",
+		__func__, iphy->id,
+		combo_phy_r32(iphy->pcie_base, PCIE_PHY_MPLLA_CTRL),
+		combo_phy_r32(iphy->pcie_base, PCIE_PHY_MPLLB_CTRL));
+	return 0;
+}
+
+static int intel_phy_power_on(struct phy_ctx *iphy)
+{
+	struct device *dev = iphy->dev;
+	int ret;
+
+	ret = intel_phy_gate_clk_enable(iphy);
+	if (ret) {
+		dev_err(dev, "PHY(%u:%u) gate clock enable failed!\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy));
+		return ret;
+	}
+
+	ret = intel_phy_rst_deassert(iphy);
+	if (ret) {
+		dev_err(dev, "PHY(%u:%u) phy deassert failed!\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy));
+		return ret;
+	}
+
+	ret = intel_phy_freq_clk_enable(iphy);
+	if (ret) {
+		dev_err(dev, "PHY(%u:%u) freq clock enable failed!\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy));
+		return ret;
+	}
+
+	ret = intel_phy_clk_freq_set(iphy);
+	if (ret) {
+		dev_err(dev, "PHY(%u:%u) clock frequency set to %lu failed!\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy),
+			iphy->phy_clk_rate[iphy->phy_mode]);
+		return ret;
+	}
+
+	iphy->power_en = true;
+
+	return 0;
+}
+
+static int intel_phy_power_off(struct phy_ctx *iphy)
+{
+	struct device *dev = iphy->dev;
+	int ret;
+
+	ret = intel_phy_rst_assert(iphy);
+	if (ret) {
+		dev_err(dev, "PHY(%u:%u) phy assert failed!\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy));
+		return ret;
+	}
+
+	ret = intel_core_rst_assert(iphy);
+	if (ret) {
+		dev_err(dev, "PHY(%u:%u) core assert failed!\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy));
+		return ret;
+	}
+
+	intel_phy_gate_clk_disable(iphy);
+	intel_phy_freq_clk_disable(iphy);
+	iphy->power_en = false;
+
+	return 0;
+}
+
+static int intel_phy_cr_config(struct phy_ctx *iphy)
+{
+	struct intel_combo_phy *priv;
+	enum intel_phy_mode phy_mode = iphy->phy_mode;
+
+	priv = iphy->parent;
+
+	if (priv->soc_data->phy_cr_cfg)
+		priv->soc_data->phy_cr_cfg(iphy, phy_mode);
+
+	return 0;
+}
+
+static int intel_combo_phy_start(struct intel_combo_phy *priv)
+{
+	struct phy_ctx *iphy;
+	int i;
+
+	for (i = 0; i < PHY_MAX_NUM; i++) {
+		iphy = &priv->phy[i];
+
+		if (!iphy->enable)
+			continue;
+
+		if (intel_phy_rst_deassert(iphy))
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int intel_combo_phy_init(struct phy *phy)
+{
+	struct phy_ctx *iphy;
+	struct device *dev;
+	bool aggr;
+
+	iphy = phy_get_drvdata(phy);
+	dev = iphy->dev;
+
+	if (iphy->phy_role == PHY_MASTER) {
+		aggr = true;
+	} else if (iphy->phy_role == PHY_INDIVIDUAL) {
+		aggr = false;
+	} else {
+		dev_err(dev, "PHY(%u:%u) dl mode error: %d\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy), iphy->phy_role);
+		return -EINVAL;
+	}
+
+	if (intel_cbphy_cfg(iphy, aggr, intel_core_rst_assert))
+		return -EINVAL;
+
+	if (intel_cbphy_cfg(iphy, aggr, intel_core_rst_deassert))
+		return -EINVAL;
+
+	if (iphy->phy_mode == PHY_PCIE_MODE)
+		intel_cbphy_cfg(iphy, aggr, intel_pcie_set_clk_src);
+
+	if (intel_cbphy_cfg(iphy, aggr, intel_phy_power_on))
+		return -ENOTSUPP;
+
+	intel_cbphy_cfg(iphy, aggr, intel_phy_cr_config);
+
+	return 0;
+}
+
+static int intel_combo_phy_exit(struct phy *phy)
+{
+	struct phy_ctx *iphy;
+	struct device *dev;
+	bool aggr;
+
+	iphy = phy_get_drvdata(phy);
+	dev = iphy->dev;
+
+	if (iphy->phy_role == PHY_MASTER) {
+		aggr = true;
+	} else if (iphy->phy_role == PHY_INDIVIDUAL) {
+		aggr = false;
+	} else {
+		dev_err(dev, "PHY(%u:%u) dl mode error: %d\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy), iphy->phy_role);
+		return -EINVAL;
+	}
+
+	if (iphy->power_en)
+		intel_cbphy_cfg(iphy, aggr, intel_phy_power_off);
+
+	return 0;
+}
+
+static int intel_combo_phy_power_on(struct phy *phy)
+{
+	struct phy_ctx *iphy;
+	struct device *dev;
+	bool aggr;
+	int ret;
+
+	iphy = phy_get_drvdata(phy);
+	dev = iphy->dev;
+
+	if (iphy->phy_role == PHY_MASTER) {
+		aggr = true;
+	} else if (iphy->phy_role == PHY_INDIVIDUAL) {
+		aggr = false;
+	} else {
+		dev_err(dev, "PHY(%u:%u) dl mode error: %d\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy), iphy->phy_role);
+		return -EINVAL;
+	}
+
+	if (!iphy->power_en) {
+		ret = intel_cbphy_cfg(iphy, aggr, intel_phy_power_on);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int intel_combo_phy_power_off(struct phy *phy)
+{
+	struct phy_ctx *iphy;
+	struct device *dev;
+	bool aggr;
+	int ret;
+
+	iphy = phy_get_drvdata(phy);
+	dev = iphy->dev;
+
+	if (iphy->phy_role == PHY_MASTER) {
+		aggr = true;
+	} else if (iphy->phy_role == PHY_INDIVIDUAL) {
+		aggr = false;
+	} else {
+		dev_err(dev, "PHY(%u:%u) dl mode error: %d\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy), iphy->phy_role);
+		return -EINVAL;
+	}
+
+	if (iphy->power_en) {
+		ret = intel_cbphy_cfg(iphy, aggr, intel_phy_power_off);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static void __iomem *
+intel_combo_phy_ioremap(struct phy_ctx *iphy, const char *res_name)
+{
+	struct device *dev = iphy->dev;
+	struct resource *res;
+	void __iomem *base;
+	struct platform_device *pdev = iphy->pdev;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, res_name);
+	if (!res) {
+		dev_err(dev, "Failed to get %s iomem resource!\n", res_name);
+		return ERR_PTR(-EINVAL);
+	}
+	dev_dbg(dev, "%s iomem: %pr !\n", res->name, res);
+
+	base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(base)) {
+		dev_err(dev, "Failed to ioremap resource: %pr !\n", res);
+		return base;
+	}
+
+	return base;
+}
+
+static int intel_combo_phy_mem_resource(struct phy_ctx *iphy)
+{
+	void __iomem *base;
+
+	base = intel_combo_phy_ioremap(iphy, "cr");
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+	iphy->cr_base = base;
+
+	base = intel_combo_phy_ioremap(iphy, "pcie");
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+	iphy->pcie_base = base;
+
+	return 0;
+}
+
+static int intel_combo_phy_get_clks(struct phy_ctx *iphy)
+{
+	int i;
+	struct intel_combo_phy *priv;
+	struct device *dev = iphy->dev;
+
+	priv = iphy->parent;
+
+	iphy->phy_freq_clk = devm_clk_get(dev, "freq");
+	if (IS_ERR(iphy->phy_freq_clk)) {
+		dev_err(dev, "Failed to get combo phy %u:%u freq clock!\n",
+			priv->id, iphy->id);
+		return -EINVAL;
+	}
+
+	iphy->phy_gate_clk = devm_clk_get(dev, "phy");
+
+	if (IS_ERR(iphy->phy_gate_clk))
+		iphy->phy_gate_clk = NULL;
+	else
+		dev_dbg(dev, "PHY[%u:%u] Get PHY gate clk!\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy));
+
+	for (i = PHY_PCIE_MODE; i < PHY_MAX_MODE; i++) {
+		if (priv->soc_data->get_clk_rate)
+			iphy->phy_clk_rate[i]
+				= priv->soc_data->get_clk_rate(i);
+
+		if (iphy->phy_clk_rate[i])
+			dev_dbg(dev, "PHY[%u:%u]  %s clk rate %lu !\n",
+				COMBO_PHY_ID(iphy), PHY_ID(iphy),
+				intel_phy_names[i], iphy->phy_clk_rate[i]);
+	}
+
+	return 0;
+}
+
+static int intel_combo_phy_get_reset(struct phy_ctx *iphy)
+{
+	int i;
+	struct device *dev = iphy->dev;
+	char name[32];
+
+	iphy->phy_rst
+		= devm_reset_control_get_optional(dev, "phy");
+	if (IS_ERR(iphy->phy_rst)) {
+		dev_dbg(dev, "PHY[%u:%u] Get PHY reset ctrl Err!\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy));
+		iphy->phy_rst = NULL;
+	}
+
+	for (i = PHY_PCIE_MODE; i < PHY_MAX_MODE; i++) {
+		if (iphy->phy_role != PHY_SLAVE)
+			continue;
+
+		snprintf(name, sizeof(name) - 1, "%s_core", intel_phy_names[i]);
+		iphy->core_rst[i]
+			= devm_reset_control_get_optional(dev, name);
+		if (IS_ERR(iphy->core_rst[i])) {
+			dev_dbg(dev, "PHY[%u:%u] Get %s reset ctrl Err!\n",
+				COMBO_PHY_ID(iphy), PHY_ID(iphy), name);
+			iphy->core_rst[i] = NULL;
+		} else {
+			dev_dbg(dev, "PHY[%u:%u] Get %s reset ctrl!\n",
+				COMBO_PHY_ID(iphy), PHY_ID(iphy), name);
+		}
+	}
+
+	return 0;
+}
+
+static int intel_phy_dt_parse(struct intel_combo_phy *priv,
+			      struct device_node *np, int idx)
+{
+	struct phy_ctx *iphy = &priv->phy[idx];
+	struct device *dev;
+	struct platform_device *pdev;
+	u32 prop;
+	bool aggregated;
+
+	iphy->parent = priv;
+	iphy->id = idx;
+	iphy->np = np;
+	iphy->enable = false;
+	iphy->power_en = false;
+
+	pdev = of_find_device_by_node(np);
+	if (!pdev) {
+		dev_dbg(priv->dev, "Combo-PHY%u: Failed to find PHY device: %d!\n",
+			priv->id, idx);
+		return 0;
+	}
+	dev = &pdev->dev;
+	iphy->pdev = pdev;
+	iphy->dev = dev;
+	platform_set_drvdata(pdev, iphy);
+
+	if (!device_property_read_u32(dev, "mode", &prop)) {
+		iphy->phy_mode = prop;
+		if (iphy->phy_mode >= PHY_MAX_MODE) {
+			dev_err(dev, "PHY mode: %u is invalid\n",
+				iphy->phy_mode);
+			return -EINVAL;
+		}
+	}
+
+	if (!(BIT(iphy->phy_mode) & priv->phy_cap)) {
+		dev_err(dev,
+			"PHY mode %u is not supported by COMBO PHY id %u of %s soc platform!\n",
+			iphy->phy_mode, priv->id, priv->soc_data->name);
+		return -EINVAL;
+	}
+	priv->phy_mode[idx] = iphy->phy_mode;
+
+	if (iphy->id == 0) {
+		/* Dual lane configuration only required on PHY 0 */
+		if (!device_property_read_u32(dev, "aggregation", &prop))
+			aggregated = !!prop;
+		else
+			aggregated = false;
+
+		if (aggregated) {
+			priv->aggr_mode = PHY_DL_MODE;
+			iphy->phy_role = PHY_MASTER;
+		} else {
+			priv->aggr_mode = PHY_SL_MODE;
+			iphy->phy_role = PHY_INDIVIDUAL;
+		}
+	} else {
+		if (priv->aggr_mode == PHY_DL_MODE)
+			iphy->phy_role = PHY_SLAVE;
+		else
+			iphy->phy_role = PHY_INDIVIDUAL;
+	}
+
+	if (intel_combo_phy_mem_resource(iphy)) {
+		dev_err(dev, "Failed get phy(%u:%u) memory resource!\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy));
+		return -EINVAL;
+	}
+
+	if (intel_combo_phy_get_clks(iphy)) {
+		dev_err(dev, "Get phy(%u:%u) clks failed!\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy));
+		return -EINVAL;
+	}
+
+	if (intel_combo_phy_get_reset(iphy)) {
+		dev_err(dev, "Get phy(%u:%u) resets failed!\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy));
+		return -EINVAL;
+	}
+
+	iphy->enable = of_device_is_available(np);
+	priv->enable[idx] = iphy->enable;
+
+	return 0;
+}
+
+static int intel_dt_sanity_check(struct intel_combo_phy *priv)
+{
+	struct phy_ctx *iphy0, *iphy1;
+
+	iphy0 = &priv->phy[PHY_0];
+	iphy1 = &priv->phy[PHY_1];
+
+	if (!iphy0->enable && !iphy1->enable)
+		return 0;
+
+	if (priv->aggr_mode == PHY_DL_MODE &&
+	    (!iphy0->enable || !iphy1->enable)) {
+		dev_err(priv->dev, "CFG check fail: Dual lane mode while line offline, line0: %d, line1: %d\n",
+			iphy0->enable, iphy1->enable);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int intel_combo_phy_dt_parse(struct intel_combo_phy *priv)
+{
+	struct device *dev = priv->dev;
+	struct device_node *np = priv->np;
+	struct device_node *child;
+	int i, ret;
+
+	/* get global reset */ /* Need update to return error in 4.11 */
+	priv->phy_global_rst = devm_reset_control_get_optional(dev, "phy");
+	if (IS_ERR(priv->phy_global_rst)) {
+		dev_dbg(dev, "COMBO PHY %u get global reset err!\n", priv->id);
+		priv->phy_global_rst = NULL;
+	}
+
+	/* get chiptop regmap */
+	priv->syscfg
+		= syscon_regmap_lookup_by_phandle(np, "intel,cbphy-syscon");
+	if (IS_ERR(priv->syscfg)) {
+		dev_err(dev, "No syscon phandle specified for combo-phy syscon\n");
+		ret = -EINVAL;
+		goto syscfg_err;
+	}
+
+	i = 0;
+	for_each_child_of_node(np, child) {
+		if (i >= PHY_MAX_NUM) {
+			dev_err(dev, "Error: DT child number larger than %d\n",
+				PHY_MAX_NUM);
+			ret = -EINVAL;
+			goto phy_dt_err;
+		}
+		ret = intel_phy_dt_parse(priv, child, i);
+		if (ret) {
+			of_node_put(child);
+			goto phy_dt_err;
+		}
+		i++;
+	}
+
+	ret = intel_dt_sanity_check(priv);
+	if (ret)
+		goto phy_dt_err;
+
+	return 0;
+
+phy_dt_err:
+	/* Set other phys in disabled status */
+	for (i = i - 1; i >= 0; i--)
+		priv->enable[i] = false;
+syscfg_err:
+	return ret;
+}
+
+static void intel_combo_phy_reset(struct intel_combo_phy *priv)
+{
+	if (priv->phy_global_rst) {
+		reset_control_assert(priv->phy_global_rst);
+		udelay(1);
+		reset_control_deassert(priv->phy_global_rst);
+	}
+
+	usleep_range(10, 20);
+}
+
+static int intel_combo_phy_set_mode(struct intel_combo_phy *priv)
+{
+	priv->cb_phy_mode = COMBO_PHY_MODE_MAX;
+	/* aggregation mode */
+	if (priv->aggr_mode == PHY_DL_MODE) {
+		if (!priv->enable[PHY_0] || !priv->enable[PHY_1])
+			return -EINVAL;
+		if (priv->phy_mode[PHY_0] != priv->phy_mode[PHY_1])
+			return -EINVAL;
+		if (priv->phy_mode[PHY_0] == PHY_PCIE_MODE)
+			priv->cb_phy_mode = PCIE_DL_MODE;
+		else if (priv->phy_mode[PHY_0] == PHY_XPCS_MODE)
+			priv->cb_phy_mode = RXAUI_MODE;
+	} else if (priv->aggr_mode == PHY_SL_MODE) {
+		if (priv->phy_mode[PHY_0] == PHY_PCIE_MODE &&
+		    priv->phy_mode[PHY_1] == PHY_PCIE_MODE)
+			priv->cb_phy_mode = PCIE0_PCIE1_MODE;
+
+		else if (priv->phy_mode[PHY_0] == PHY_XPCS_MODE &&
+			 priv->phy_mode[PHY_1] == PHY_XPCS_MODE)
+			priv->cb_phy_mode = XPCS0_XPCS1_MODE;
+
+		else if (priv->phy_mode[PHY_0] == PHY_XPCS_MODE &&
+			 priv->phy_mode[PHY_1] == PHY_PCIE_MODE)
+			priv->cb_phy_mode = XPCS0_PCIE1_MODE;
+
+		else if (priv->phy_mode[PHY_0] == PHY_PCIE_MODE &&
+			 priv->phy_mode[PHY_1] == PHY_XPCS_MODE)
+			priv->cb_phy_mode = PCIE0_XPCS1_MODE;
+
+		else if (priv->phy_mode[PHY_0] == PHY_SATA_MODE &&
+			 priv->phy_mode[PHY_1] == PHY_XPCS_MODE)
+			priv->cb_phy_mode = SATA0_XPCS1_MODE;
+
+		else if (priv->phy_mode[PHY_0] == PHY_SATA_MODE &&
+			 priv->phy_mode[PHY_1] == PHY_PCIE_MODE)
+			priv->cb_phy_mode = SATA0_PCIE1_MODE;
+	}
+
+	if (priv->cb_phy_mode == COMBO_PHY_MODE_MAX)
+		return -EINVAL;
+
+	if (priv->soc_data->combo_phy_mode_set)
+		priv->soc_data->combo_phy_mode_set(priv);
+
+	return 0;
+}
+
+static int intel_phy_create(struct phy_ctx *iphy)
+{
+	struct device *dev = iphy->dev;
+	struct phy_provider *phy_provider;
+
+	if (!iphy->enable) {
+		dev_err(dev, "%s[%u:%u]: Combo PHY not enabled!\n",
+			__func__, COMBO_PHY_ID(iphy), PHY_ID(iphy));
+		return -ENODEV;
+	}
+
+	iphy->phy = devm_phy_create(dev, iphy->np, &intel_cbphy_ops);
+	if (IS_ERR(iphy->phy)) {
+		dev_err(dev,
+			"%s: Failed to create intel combo-phy!\n", __func__);
+		return PTR_ERR(iphy->phy);
+	}
+
+	phy_set_drvdata(iphy->phy, iphy);
+
+	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+	if (IS_ERR(phy_provider)) {
+		dev_err(dev,
+			"%s: Failed to register phy provider!\n", __func__);
+		return PTR_ERR(phy_provider);
+	}
+
+	return 0;
+}
+
+static int intel_combo_phy_create(struct intel_combo_phy *priv)
+{
+	int i;
+	struct phy_ctx *iphy;
+
+	if (priv->aggr_mode == PHY_DL_MODE) {/* Only PHY0 is visible */
+		iphy = &priv->phy[PHY_0];
+		if (intel_phy_create(iphy))
+			return -ENODEV;
+	}
+
+	for (i = 0; i < PHY_MAX_NUM; i++) {
+		if (priv->enable[i]) {
+			iphy = &priv->phy[i];
+			if (intel_phy_create(iphy))
+				return -ENODEV;
+			if (intel_phy_clk_freq_set(iphy)) {
+				dev_err(iphy->dev, "PHY(%u:%u) clock frequency set to %lu failed!\n",
+					COMBO_PHY_ID(iphy), PHY_ID(iphy),
+					iphy->phy_clk_rate[iphy->phy_mode]);
+			} else {
+				dev_err(iphy->dev, "PHY(%u:%u) clock frequency set to %lu Success!\n",
+					COMBO_PHY_ID(iphy), PHY_ID(iphy),
+					iphy->phy_clk_rate[iphy->phy_mode]);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int intel_combo_phy_sysfs_init(struct intel_combo_phy *priv)
+{
+	/* return devm_device_add_groups(priv->dev, combo_phy_groups); */
+	return sysfs_create_groups(&priv->dev->kobj, combo_phy_groups);
+}
+
+static int intel_combo_phy_probe(struct platform_device *pdev)
+{
+	int id;
+	unsigned int cap;
+	struct device *dev = &pdev->dev;
+	struct intel_combo_phy *priv;
+	struct device_node *np = dev->of_node;
+
+	if (!dev->of_node)
+		return -ENODEV;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->soc_data = of_device_get_match_data(dev);
+	if (WARN_ON(!priv->soc_data))
+		return -EINVAL;
+
+	id = of_alias_get_id(np, "combophy");
+	if (id < 0) {
+		dev_err(dev, "failed to get alias id, errno %d\n", id);
+		return -EINVAL;
+	}
+
+	cap = priv->soc_data->get_phy_cap(id);
+	if (!cap) {
+		dev_err(dev, "PHY id: %d is invalid\n", id);
+		return -EINVAL;
+	}
+
+	priv->id = id;
+	priv->phy_cap = cap;
+	priv->pdev = pdev;
+	priv->dev = dev;
+	priv->np = np;
+	platform_set_drvdata(pdev, priv);
+
+	if (intel_combo_phy_dt_parse(priv)) {
+		dev_err(dev, "dt parse failed!\n");
+		return -EINVAL;
+	}
+
+	intel_combo_phy_reset(priv);
+	if (intel_combo_phy_set_mode(priv)) {
+		dev_err(dev, "combo phy mode failed!\n");
+		return -EINVAL;
+	}
+
+	intel_combo_phy_create(priv);
+	intel_combo_phy_start(priv);
+
+	if (intel_combo_phy_sysfs_init(priv))
+		return -EINVAL;
+
+	return 0;
+}
+
+/* TwinHill platform data */
+static unsigned long twh_get_clk_rate(enum intel_phy_mode mode)
+{
+	if (mode == PHY_PCIE_MODE)
+		return CLK_100MHZ;
+	else
+		return 0;  /* Other mode No support */
+}
+
+static u32 twh_get_phy_cap(unsigned int id)
+{
+	const unsigned int phy_num = 1;
+
+	if (id < phy_num)
+		return PHY_PCIE_CAP;
+	else
+		return 0;
+}
+
+static int twh_phy_cr_cfg(struct phy_ctx *iphy, enum intel_phy_mode mode)
+{
+#define PCIE_PHY_VR_CNT		5000
+	int i;
+	u32 val;
+	void __iomem *base;
+
+	if (mode != PHY_PCIE_MODE)
+		return 0;
+
+	base = iphy->pcie_base;
+	WARN_ON(!base);
+
+	for (i = 0; i < PCIE_PHY_VR_CNT; i++) {
+		if ((combo_phy_r32(base, PCIE_PHY_MPLLA_CTRL) == 0xC0000000) &&
+		    (combo_phy_r32(base, PCIE_PHY_MPLLB_CTRL) == 0xC0000000))
+			break;
+		usleep_range(10, 20);
+	}
+
+	if (i >= PCIE_PHY_VR_CNT) {
+		dev_err(iphy->dev, "%s PHY%d MPLL locked failed\n",
+			__func__, iphy->id);
+		return -ETIMEDOUT;
+	}
+
+	dev_dbg(iphy->dev, "%s PHY%d MPLL locked succeed\n",
+		__func__, iphy->id);
+
+	/* PHY CR setting */
+	base = iphy->cr_base;
+	WARN_ON(!base);
+
+	for (i = 0; i < PCIE_PHY_VR_CNT; i++) {
+		combo_phy_w32_mask(base, BIT(2), BIT(3) | BIT(4), (0x0a << 2));
+		val = combo_phy_r32(base, (0x0a << 2));
+		if (((val & 0x18) == 0x18) &&
+		    !!(combo_phy_r32(base, (0x3059 << 2)) & BIT(0)))
+			break;
+		usleep_range(10, 20);
+	}
+
+	if (i >= PCIE_PHY_VR_CNT) {
+		dev_err(iphy->dev, "SUP_DIG_SUP_OVRD_IN 0x%08x\n",
+			combo_phy_r32(base, (0x0a << 2)));
+		dev_err(iphy->dev,
+			"RAWLANEN_DIG_AON_INIT_PWRUP_DOWN PWR_DONE %d\n",
+			!!((combo_phy_r32(base, (0x3059 << 2))) & BIT(0)));
+	}
+
+	for (i = 0; i < PCIE_PHY_VR_CNT; i++) {
+		if (!!(combo_phy_r32(base, (0x3032 << 2)) & BIT(1)))
+			break;
+		usleep_range(10, 20);
+	}
+
+	if (i >= PCIE_PHY_VR_CNT)
+		dev_err(iphy->dev, "PCIe PHY[%u:%u] calibration failed\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy));
+	else
+		dev_dbg(iphy->dev, "PCIe PHY[%u:%u] calibrtion succeed\n",
+			COMBO_PHY_ID(iphy), PHY_ID(iphy));
+	return 0;
+}
+
+static void twh_combo_phy_mode_set(struct intel_combo_phy *priv)
+{
+	const int cb_mode_reg_off = 0x480;
+	const int cb_mode_bit_off = 0;
+	const int cb_mode_bit_mask = 0x7;
+
+	regmap_update_bits(priv->syscfg, cb_mode_reg_off,
+			   cb_mode_bit_mask,
+			   priv->cb_phy_mode << cb_mode_bit_off);
+}
+
+/* Falconmx platform data */
+static unsigned long falconmx_get_clk_rate(enum intel_phy_mode mode)
+{
+	if (mode == PHY_PCIE_MODE) {
+		return CLK_100MHZ;
+	} else if (mode == PHY_XPCS_MODE) {
+		/* 156.25Mhz */
+		return CLK_156MHZ;
+	}
+
+	return 0;  /* Other mode No support */
+}
+
+static u32 falconmx_get_phy_cap(unsigned int id)
+{
+	const unsigned int phy_num = 1;
+
+	if (id < phy_num)
+		return PHY_PCIE_CAP | PHY_XPCS_CAP;
+	else
+		return 0;
+}
+
+static void falconmx_combo_phy_mode_set(struct intel_combo_phy *priv)
+{
+	const int reg_off = 0x120;
+	const int bit_off = 2;
+	const int bit_mask = 0x1C;
+	int i;
+	struct phy_ctx *iphy;
+
+	regmap_update_bits(priv->syscfg, reg_off, bit_mask,
+			   priv->cb_phy_mode << bit_off);
+
+	for (i = 0; i < PHY_MAX_NUM; i++) {
+		iphy = &priv->phy[i];
+		if (iphy->enable && iphy->phy_mode == PHY_XPCS_MODE)
+			regmap_update_bits(priv->syscfg, reg_off, 2, 2);
+		else if (iphy->enable && iphy->phy_mode == PHY_PCIE_MODE)
+			regmap_update_bits(priv->syscfg, reg_off,
+					   BIT(PCIE_RCLK(i)), 0);
+	}
+}
+
+/* Lighting Mountain platform data */
+static unsigned long lgm_get_clk_rate(enum intel_phy_mode mode)
+{
+	switch (mode) {
+	case PHY_PCIE_MODE:
+	case PHY_SATA_MODE:
+		return CLK_100MHZ;
+	case PHY_XPCS_MODE:
+		return CLK_78MHZ; /* 78.125Mhz */
+	case PHY_MAX_MODE:
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static u32 lgm_get_phy_cap(unsigned int id)
+{
+	const unsigned int phy_num = 4;
+	const unsigned int mtf_phy_num = 2;
+
+	if (id < mtf_phy_num)
+		return PHY_PCIE_CAP | PHY_XPCS_CAP | PHY_SATA_CAP;
+	else if (id < phy_num)
+		return PHY_PCIE_CAP;
+	else
+		return 0;
+}
+
+static const struct intel_cbphy_soc_data twh_phy_data = {
+	.name = "TwinHill",
+	.get_clk_rate = twh_get_clk_rate,
+	.get_phy_cap = twh_get_phy_cap,
+	.phy_cr_cfg = twh_phy_cr_cfg,
+	.combo_phy_mode_set = twh_combo_phy_mode_set,
+};
+
+static const struct intel_cbphy_soc_data falconmx_phy_data = {
+	.name = "Falcon MX",
+	.get_clk_rate = falconmx_get_clk_rate,
+	.get_phy_cap = falconmx_get_phy_cap,
+	.combo_phy_mode_set = falconmx_combo_phy_mode_set,
+};
+
+static const struct intel_cbphy_soc_data lgm_phy_data = {
+	.name = "Lighting Mountain",
+	.get_clk_rate = lgm_get_clk_rate,
+	.get_phy_cap = lgm_get_phy_cap,
+};
+
+static const struct of_device_id of_intel_combo_phy_match[] = {
+	{ .compatible = "intel,combophy-twh", .data = &twh_phy_data },
+	{ .compatible = "intel,combophy-falconmx", .data = &falconmx_phy_data },
+	{ .compatible = "intel,combophy-lgm", .data = &lgm_phy_data },
+	{}
+};
+MODULE_DEVICE_TABLE(of, of_intel_combo_phy_match);
+
+static struct platform_driver intel_combo_phy_driver = {
+	.probe = intel_combo_phy_probe,
+	.driver = {
+		.name = "intel-combo-phy",
+		.of_match_table = of_match_ptr(of_intel_combo_phy_match),
+	}
+};
+
+builtin_platform_driver(intel_combo_phy_driver);
diff --git a/drivers/phy/intel/phy-intel-slim.c b/drivers/phy/intel/phy-intel-slim.c
new file mode 100644
index 000000000000..f04f783466a3
--- /dev/null
+++ b/drivers/phy/intel/phy-intel-slim.c
@@ -0,0 +1,390 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Intel Slim PCIe PHY driver for legacy SoCs
+ *
+ * Copyright (C) 2018 Intel Corporation.
+ */
+
+#include <linux/clk.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of_address.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/phy/phy.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+
+/* PCIe 2.0 PDI PHY register definition */
+#define PCIE_PHY_CFG0			0xc004
+#define PCIE_PHY_CFG1			0xc008
+#define PCIE_PHY_CFG2			0xc00c
+#define PCIE_PHY_CFG3			0xc010
+#define PCIE_PHY_CFG4			0xc014
+#define PCIE_PHY_PIPE_PD		14
+#define PCIE_PHY_PIPE_PD_O		15
+
+/* xRX500 LCPLL SSC */
+#define PCIE_LCPLL_CFG0			0x0094
+#define PLL_RESET			BIT(0)
+#define LCPLL_CFG0_LOCKED		BIT(1)
+#define PCIE_LCPLL_CFG1			0x0098
+#define PLL_SSC				BIT(24)
+#define PLL_PLK_OV			BIT(20)
+#define PCIE_LCPLL_SSC_CTRL		0x009C
+#define PCIE_LCPLL_SSC_SCALE		0x00A0
+#define PCIE_LCPLL_COEF_0		0x00A4
+#define PCIE_LCPLL_COEF_1		0x00A8
+#define PCIE_LCPLL_COEF_2		0x00AC
+#define PCIE_LCPLL_COEF_3		0x00B0
+#define PCIE_LCPLL_COEF_4		0x00B4
+#define PCIE_LCPLL_COEF_5		0x00B8
+#define PCIE_LCPLL_COEF_6		0x00BC
+#define PCIE_LCPLL_COEF_7		0x00C0
+
+/* CHIPTOP REG */
+#define PCIE_IFMUX_CFG			0x120
+#define PCIE_RCLK_OFF(x)		((x) + 22)
+#define PCIE_RCLK(x)			BIT(PCIE_RCLK_OFF(x))
+
+static atomic_t ssc_count;
+
+struct intel_slim_phy {
+	int id;
+	void __iomem *phy_base;
+	struct platform_device *pdev;
+	struct device	*dev;
+	struct regmap	*ssccfg;
+	struct regmap	*phycfg;
+	struct phy *phy;
+	struct reset_control *rst;
+	int ssc_en;
+	int ssc_status;
+};
+
+enum {
+	SSC_DISABLED = 0,
+	SSC_ENABLED = 1,
+};
+
+static inline u32 phy_r32(void __iomem *base, unsigned int reg)
+{
+	return readl(base + reg);
+}
+
+static inline void phy_w32(void __iomem *base, u32 val, unsigned int reg)
+{
+	writel(val, base + reg);
+}
+
+static inline void phy_w32_off_mask(void __iomem *base, u32 off,
+				    u32 mask, u32 set, unsigned int reg)
+{
+	u32 val;
+
+	val = phy_r32(base, reg) & (~(mask << off));
+	val |= (set & mask) << off;
+	phy_w32(base, val, reg);
+}
+
+static void reg_dbg_dump(struct intel_slim_phy *sphy)
+{
+	struct device *dev = sphy->dev;
+	u32 val;
+	int i;
+
+	regmap_read(sphy->ssccfg, PCIE_LCPLL_CFG0, &val);
+	dev_dbg(dev, "LCPLL CFG0: 0x%8x\n", val);
+	regmap_read(sphy->ssccfg, PCIE_LCPLL_CFG1, &val);
+	dev_dbg(dev, "LCPLL CFG1: 0x%8x\n", val);
+	regmap_read(sphy->ssccfg, PCIE_LCPLL_SSC_CTRL, &val);
+	dev_dbg(dev, "SSC CTRL: 0x%8x\n", val);
+	regmap_read(sphy->ssccfg, PCIE_LCPLL_SSC_SCALE, &val);
+	dev_dbg(dev, "SSC SCALE: 0x%8x\n", val);
+
+	for (i = 0; i < 8; i++) {
+		regmap_read(sphy->ssccfg, PCIE_LCPLL_COEF_0 + i * 4, &val);
+		dev_dbg(dev, "LCPLL COEF[%d]: 0x%8x\n", i, val);
+	}
+
+	regmap_read(sphy->phycfg, PCIE_IFMUX_CFG, &val);
+	dev_dbg(dev, "PCIE PHY IFMUX[22-24]: 0x%8x\n", val);
+
+	dev_dbg(dev, "====================================================\n");
+}
+
+static void pcie_phy_power_down(struct intel_slim_phy *sphy)
+{
+	phy_w32_off_mask(sphy->phy_base,
+			 PCIE_PHY_PIPE_PD_O, 1, 1, PCIE_PHY_CFG4);
+	mdelay(1);
+}
+
+static void pcie_phy_power_up(struct intel_slim_phy *sphy)
+{
+	phy_w32_off_mask(sphy->phy_base,
+			 PCIE_PHY_PIPE_PD_O, 1, 0, PCIE_PHY_CFG4);
+	mdelay(1);
+}
+
+static void phy_ssc_enable(struct intel_slim_phy *sphy)
+{
+	int ret;
+	u32 val;
+
+	if (sphy->ssc_status == SSC_ENABLED || !sphy->ssc_en) {
+		dev_info(sphy->dev,
+			 "ssc no enable action: ssc enable: %u, status: %d\n",
+			 sphy->ssc_en, sphy->ssc_status);
+		return;
+	}
+
+	if (atomic_inc_return(&ssc_count) > 1) {
+		sphy->ssc_status = SSC_ENABLED;
+		dev_info(sphy->dev, "SSC has been enabled, count: %d!\n",
+			 atomic_read(&ssc_count));
+		return;
+	}
+
+	/* Enable SSC and LCPLL */
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_CFG1, 0x10003004);
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_CFG1, 0x10103004);
+
+	/* Need to bit 0 from 0 to 1 */
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_CFG0, 0x00000190);
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_CFG0, 0x00000191);
+
+	ret = regmap_read_poll_timeout(sphy->ssccfg, PCIE_LCPLL_CFG0, val,
+				       !!(val & LCPLL_CFG0_LOCKED), 100,
+				       100 * USEC_PER_MSEC);
+	if (ret)
+		dev_err(sphy->dev, "%s LCPLL not locked yet\n", __func__);
+
+	/* Fixed Coefficient parameters */
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_COEF_0, 0x0000FF60);
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_COEF_1, 0x0000FF60);
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_COEF_2, 0x0000FF60);
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_COEF_3, 0x0000FF60);
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_COEF_4, 0x000000A0);
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_COEF_5, 0x000000A0);
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_COEF_6, 0x000000A0);
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_COEF_7, 0x000000A0);
+	/* Program DIV and len parameters */
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_SSC_CTRL, 0x0000FF1C);
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_SSC_CTRL, 0x0000FF1F);
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_SSC_CTRL, 0x0000FF1C);
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_SSC_CTRL, 0x0000FF1D);
+	mdelay(1);
+
+	sphy->ssc_status = SSC_ENABLED;
+	dev_info(sphy->dev, "PCIe LCPLL SSC Mode Enabled\n");
+}
+
+static void phy_ssc_disable(struct intel_slim_phy *sphy)
+{
+	int ret;
+	u32 val;
+
+	if (sphy->ssc_status == SSC_DISABLED || !sphy->ssc_en) {
+		dev_info(sphy->dev,
+			 "ssc no disable action: ssc enable: %u, status: %d\n",
+			 sphy->ssc_en, sphy->ssc_status);
+		return;
+	}
+
+	if (atomic_dec_return(&ssc_count) > 0) {
+		sphy->ssc_status = SSC_DISABLED;
+		dev_info(sphy->dev, "SSC in use, count: %d!\n",
+			 atomic_read(&ssc_count));
+		return;
+	}
+
+	/* Disable SSC CTRL */
+	regmap_write(sphy->ssccfg, PCIE_LCPLL_SSC_CTRL, 0x0);
+	mdelay(1);
+
+	/* Disalbe SSC and LCPLL */
+	regmap_update_bits(sphy->ssccfg, PCIE_LCPLL_CFG1,
+			   PLL_SSC | PLL_PLK_OV, PLL_SSC);
+
+	/* reset PLL */
+	regmap_update_bits(sphy->ssccfg, PCIE_LCPLL_CFG0, PLL_RESET, 0);
+	regmap_update_bits(sphy->ssccfg, PCIE_LCPLL_CFG0, PLL_RESET, 1);
+
+	ret = regmap_read_poll_timeout(sphy->ssccfg, PCIE_LCPLL_CFG0, val,
+				       !!(val & LCPLL_CFG0_LOCKED), 100,
+				       100 * USEC_PER_MSEC);
+	if (ret)
+		dev_err(sphy->dev, "%s LCPLL not locked yet\n", __func__);
+
+	sphy->ssc_status = SSC_DISABLED;
+}
+
+static void phy_reset_deassert(struct intel_slim_phy *sphy)
+{
+	reset_control_deassert(sphy->rst);
+}
+
+static void phy_reset_assert(struct intel_slim_phy *sphy)
+{
+	reset_control_assert(sphy->rst);
+}
+
+static void intel_slim_phy_reset(struct intel_slim_phy *sphy)
+{
+	phy_reset_assert(sphy);
+	phy_reset_deassert(sphy);
+	udelay(1);
+}
+
+static void phy_ref_clk_enable(struct intel_slim_phy *sphy)
+{
+	/* 0 is enable, 1 is disable */
+	regmap_update_bits(sphy->phycfg, PCIE_IFMUX_CFG,
+			   PCIE_RCLK(sphy->id), 0);
+}
+
+static void phy_ref_clk_disable(struct intel_slim_phy *sphy)
+{
+	/* 0 is enable, 1 is disable */
+	regmap_update_bits(sphy->phycfg, PCIE_IFMUX_CFG,
+			   PCIE_RCLK(sphy->id), PCIE_RCLK(sphy->id));
+}
+
+static int intel_slim_phy_init(struct phy *phy)
+{
+	struct intel_slim_phy *sphy;
+
+	sphy = phy_get_drvdata(phy);
+
+	pcie_phy_power_down(sphy);
+	phy_ssc_enable(sphy);
+	pcie_phy_power_up(sphy);
+
+	/* Reset PHY */
+	intel_slim_phy_reset(sphy);
+
+	phy_ref_clk_enable(sphy);
+	reg_dbg_dump(sphy);
+
+	return 0;
+}
+
+static int intel_slim_phy_exit(struct phy *phy)
+{
+	struct intel_slim_phy *sphy;
+
+	sphy = phy_get_drvdata(phy);
+
+	/* PHY down will halt the whole system, ignore PHY */
+	phy_ssc_disable(sphy);
+
+	/* phy clk disable */
+	phy_ref_clk_disable(sphy);
+	reg_dbg_dump(sphy);
+
+	return 0;
+}
+
+static const struct phy_ops intel_slim_phy_ops = {
+	.init = intel_slim_phy_init,
+	.exit = intel_slim_phy_exit,
+};
+
+static int intel_pcie_slim_phy_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct intel_slim_phy *priv;
+	struct resource *res;
+	struct phy_provider *phy_provider;
+	int id;
+	u32 prop;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	id = of_alias_get_id(np, "pciephy");
+	if (id < 0) {
+		dev_err(dev, "PCIe phy id error!\n");
+		return -ENODEV;
+	}
+
+	priv->id = id;
+	priv->pdev = pdev;
+	priv->dev = dev;
+	platform_set_drvdata(pdev, priv);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phy");
+	if (!res) {
+		dev_err(dev, "Failed to get iomem resource!\n");
+		return -EINVAL;
+	}
+
+	priv->phy_base = devm_ioremap_resource(dev, res);
+	if (!priv->phy_base) {
+		dev_err(dev, "Failed to remap phy iomem!\n");
+		return -ENOMEM;
+	}
+
+	priv->ssccfg = syscon_regmap_lookup_by_phandle(np, "intel,ssc-syscon");
+	if (IS_ERR(priv->ssccfg)) {
+		dev_err(dev, "No CGU syscon phandle!\n");
+		return -EINVAL;
+	}
+
+	if (!device_property_read_u32(dev, "intel,ssc_enable", &prop))
+		priv->ssc_en = !!prop;
+	priv->ssc_status = SSC_DISABLED;
+
+	priv->phycfg = syscon_regmap_lookup_by_phandle(np, "intel,phy-syscon");
+	if (IS_ERR(priv->phycfg)) {
+		dev_err(dev, "No CHIPTOP syscon phandle!\n");
+		return -EINVAL;
+	}
+
+	priv->rst = devm_reset_control_get_exclusive(dev, "phy");
+	if (IS_ERR(priv->rst)) {
+		dev_err(dev, "Failed to get reset!\n");
+		return -EINVAL;
+	}
+
+	priv->phy = devm_phy_create(dev, np, &intel_slim_phy_ops);
+	if (IS_ERR(priv->phy)) {
+		dev_err(dev, "Failed to create intel slim-phy!\n");
+		goto __phy_err;
+	}
+
+	phy_set_drvdata(priv->phy, priv);
+	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+	if (IS_ERR(phy_provider))
+		dev_err(dev, "Failed to register phy provider!\n");
+
+	intel_slim_phy_reset(priv);
+	dev_info(dev, "PCIe slim phy[%d] init success!\n", id);
+
+	return 0;
+
+__phy_err:
+	regmap_exit(priv->ssccfg);
+	return -EINVAL;
+}
+
+static const struct of_device_id of_intel_pcie_slim_phy_match[] = {
+	{ .compatible = "intel,grx500-pciephy"},
+	{}
+};
+
+static struct platform_driver intel_pcie_slim_phy_driver = {
+	.probe = intel_pcie_slim_phy_probe,
+	.driver = {
+		.name = "intel-pcie-slim-phy",
+		.of_match_table = of_match_ptr(of_intel_pcie_slim_phy_match),
+	}
+};
+
+builtin_platform_driver(intel_pcie_slim_phy_driver);
+
diff --git a/drivers/phy/intel/phy-intel-wan-xpcs.c b/drivers/phy/intel/phy-intel-wan-xpcs.c
new file mode 100644
index 000000000000..91fafe1e0f49
--- /dev/null
+++ b/drivers/phy/intel/phy-intel-wan-xpcs.c
@@ -0,0 +1,218 @@
+/*
+ * Intel WAN XPCS PHY driver
+ *
+ * Copyright (C) 2018 Intel, Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/phy/phy.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+
+/* chiptop aon/pon config; this is platform specific */
+#define CHIP_TOP_IFMUX_CFG	0x120
+#define WAN_MUX_AON	0x1
+#define WAN_MUX_MASK	0x1
+
+enum clk_control {
+	FREQ_CLK,
+	GATE_CLK,
+	HWEN_CLK,
+	MAX_CLK,
+};
+
+static const char *clk_name[MAX_CLK] = {
+	"freq", "xpcs", "hwclken"
+};
+
+struct intel_wan_xpcs_phy {
+	struct phy *phy;
+	struct platform_device *pdev;
+	struct device *dev;
+	struct clk *clk[MAX_CLK];
+	struct regmap *syscfg;
+	struct reset_control *resets;
+};
+
+static int intel_wan_xpcs_phy_init(struct phy *phy)
+{
+	struct intel_wan_xpcs_phy *priv = phy_get_drvdata(phy);
+
+	dev_dbg(priv->dev, "Initializing intel wan xpcs phy\n");
+
+	/* set WAN_MUX to AON mode */
+	regmap_update_bits(priv->syscfg, CHIP_TOP_IFMUX_CFG, WAN_MUX_MASK,
+			   WAN_MUX_AON);
+	return 0;
+}
+
+static int intel_wan_xpcs_phy_power_on(struct phy *phy)
+{
+	int ret;
+	struct intel_wan_xpcs_phy *priv = phy_get_drvdata(phy);
+	struct device *dev = priv->dev;
+
+	dev_dbg(priv->dev, "Power on intel wan xpcs phy\n");
+
+	ret = clk_prepare_enable(priv->clk[GATE_CLK]);
+	if (ret) {
+		dev_err(dev, "Failed to enable PHY gate clock\n");
+		return ret;
+	}
+	ret = clk_prepare_enable(priv->clk[HWEN_CLK]);
+	if (ret) {
+		dev_err(dev, "Failed to enable PHY gate hwen clock\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(priv->clk[FREQ_CLK]);
+	if (ret) {
+		dev_err(dev, "Failed to enable PHY clock\n");
+		return ret;
+	}
+
+	ret = reset_control_deassert(priv->resets);
+	if (ret) {
+		dev_err(dev, "Failed to deassert phy reset\n");
+		return ret;
+	}
+
+	udelay(2);
+
+	return 0;
+}
+
+static int intel_wan_xpcs_phy_power_off(struct phy *phy)
+{
+	int ret;
+	struct intel_wan_xpcs_phy *priv = phy_get_drvdata(phy);
+	struct device *dev = priv->dev;
+
+	dev_dbg(priv->dev, "Power off intel xpcs phy\n");
+
+	ret = reset_control_assert(priv->resets);
+	if (ret) {
+		dev_err(dev, "Failed to assert xpcs reset\n");
+		return ret;
+	}
+
+	clk_disable_unprepare(priv->clk[FREQ_CLK]);
+	clk_disable_unprepare(priv->clk[GATE_CLK]);
+	clk_disable_unprepare(priv->clk[HWEN_CLK]);
+
+	return 0;
+}
+
+static int intel_wan_xpcs_phy_dt_parse(struct intel_wan_xpcs_phy *priv)
+{
+	struct device *dev = priv->dev;
+	struct device_node *np = dev->of_node;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(priv->clk); i++) {
+		priv->clk[i] = devm_clk_get(dev, clk_name[i]);
+		if (IS_ERR(priv->clk[i])) {
+			if (i == FREQ_CLK) {
+				dev_err(dev, "Failed to retrieve clk %s\n",
+					clk_name[i]);
+				return PTR_ERR(priv->clk[i]);
+			}
+
+			/* others are optional */
+			priv->clk[i] = NULL;
+		}
+	}
+
+	priv->resets = devm_reset_control_get(dev, NULL);
+	if (IS_ERR(priv->resets)) {
+		dev_err(dev, "Failed to retrieve rst controller\n");
+		return PTR_ERR(priv->resets);
+	}
+
+	/* get chiptop regmap */
+	priv->syscfg =
+		syscon_regmap_lookup_by_phandle(np,
+						"intel,wanxpcsphy-syscon");
+	if (IS_ERR(priv->syscfg)) {
+		dev_err(dev, "No phandle specified for xpcs-phy syscon\n");
+		return PTR_ERR(priv->syscfg);
+	}
+
+	return 0;
+}
+
+static const struct phy_ops ops = {
+	.init		= intel_wan_xpcs_phy_init,
+	.power_on	= intel_wan_xpcs_phy_power_on,
+	.power_off	= intel_wan_xpcs_phy_power_off,
+	.owner		= THIS_MODULE,
+};
+
+static int intel_wan_xpcs_phy_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct intel_wan_xpcs_phy *priv;
+	struct phy_provider *phy_provider;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->dev = dev;
+	priv->pdev = pdev;
+	platform_set_drvdata(pdev, priv);
+
+	ret = intel_wan_xpcs_phy_dt_parse(priv);
+	if (ret)
+		return ret;
+
+	priv->phy = devm_phy_create(dev, dev->of_node, &ops);
+	if (IS_ERR(priv->phy)) {
+		dev_err(dev, "Failed to create PHY\n");
+		return PTR_ERR(priv->phy);
+	}
+
+	phy_set_drvdata(priv->phy, priv);
+
+	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+	if (IS_ERR(phy_provider)) {
+		dev_err(dev, "Failed to register phy provider!\n");
+		return PTR_ERR(phy_provider);
+	}
+
+	return 0;
+}
+
+static const struct of_device_id of_intel_wan_xpcs_phy_match[] = {
+	{ .compatible = "intel,wanxpcsphy-falconmx" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, of_intel_wan_xpcs_phy_match);
+
+static struct platform_driver intel_wan_xpcs_phy_driver = {
+	.probe = intel_wan_xpcs_phy_probe,
+	.driver = {
+		.name = "intel-wan-xpcs-phy",
+		.of_match_table = of_match_ptr(of_intel_wan_xpcs_phy_match),
+	}
+};
+
+builtin_platform_driver(intel_wan_xpcs_phy_driver);
+
+MODULE_AUTHOR("Peter Harliman Liem <peter.harliman.liem@intel.com>");
+MODULE_DESCRIPTION("Intel WAN XPCS PHY driver");
+MODULE_LICENSE("GPL v2");
