From 1bc75641844725fbd2ea64e9bd97c5b577f2a655 Mon Sep 17 00:00:00 2001
From: Rekha Eswaran <rekha.eswaran@intel.com>
Date: Wed, 24 Apr 2019 12:08:22 +0800
Subject: [PATCH] PMCPESYS-56 - address review comments

---
 drivers/net/ethernet/lantiq/datapath/datapath.h    |   5 -
 .../net/ethernet/lantiq/datapath/datapath_api.c    |  21 +--
 .../net/ethernet/lantiq/datapath/datapath_misc.c   |  10 +-
 .../lantiq/datapath/gswip30/datapath_coc.c         | 184 ++++++++++-----------
 .../lantiq/datapath/gswip30/datapath_misc.h        |   3 +
 5 files changed, 100 insertions(+), 123 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/datapath/datapath.h b/drivers/net/ethernet/lantiq/datapath/datapath.h
index e5f61fe1f7ee..918c2f6ed5d7 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath.h
+++ b/drivers/net/ethernet/lantiq/datapath/datapath.h
@@ -708,11 +708,6 @@ int dp_coc_cpufreq_exit(void);
 int dp_coc_cpufreq_init(void);
 int dp_cpufreq_notify_init(int inst);
 int dp_cpufreq_notify_exit(void);
-int update_coc_up_sub_module(int new_state,
-			     int old_state, uint32_t flag);
-void proc_coc_read(struct seq_file *s);
-ssize_t proc_coc_write(struct file *file, const char *buf, size_t count,
-		       loff_t *ppos);
 #endif
 int qos_dump_start(void);
 int qos_dump(struct seq_file *s, int pos);
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_api.c b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
index b2350d201bed..11eeb7a94da9 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_api.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
@@ -1358,25 +1358,6 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 	return res;
 }
 
-#ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
-int update_coc_up_sub_module(int new_state,
-			     int old_state, uint32_t flag)
-{
-	int i;
-	dp_coc_confirm_stat fn;
-	int inst = 0;
-
-	for (i = 0; i < dp_port_prop[inst].info.cap.max_num_dp_ports; i++) {
-		fn = dp_port_info[inst][i].cb.dp_coc_confirm_stat_fn;
-
-		if (fn)
-			fn(new_state, old_state, flag);
-	}
-
-	return 0;
-}
-#endif
-
 /* return DP_SUCCESS -- found
  * return DP_FAILURE -- not found
  */
@@ -2912,7 +2893,7 @@ int dp_basic_proc(void)
 		dp_loop_eth_dev_exit();
 #endif
 #ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
-	dp_cpufreq_notify_exit();
+		dp_cpufreq_notify_exit();
 #endif
 		unregister_notifier(0);
 	}
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_misc.c b/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
index 9bddd5fde1f1..6749b0c1fd21 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
@@ -43,7 +43,6 @@
 
 #ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
 #include <linux/cpufreq.h>
-static int dp_coc_inst;
 static int dp_coc_cpufreq_transition_notifier(struct notifier_block *nb,
 					      unsigned long event, void *data);
 static int dp_coc_cpufreq_policy_notifier(struct notifier_block *nb,
@@ -1381,6 +1380,7 @@ int32_t dp_sync_subifid_priv(struct net_device *dev, char *subif_name,
 static int dp_coc_cpufreq_policy_notifier(struct notifier_block *nb,
 					  unsigned long event, void *data)
 {
+	int inst = 0;
 	struct cpufreq_policy *policy = data;
 	DP_DEBUG(DP_DBG_FLAG_COC,"%s; cpu=%d\n",
 		 event ? "CPUFREQ_NOTIFY" : "CPUFREQ_ADJUST",
@@ -1391,7 +1391,7 @@ static int dp_coc_cpufreq_policy_notifier(struct notifier_block *nb,
 		return NOTIFY_DONE;
 	}
 	return
-	dp_port_prop[dp_coc_inst].info.
+	dp_port_prop[inst].info.
 		dp_handle_cpufreq_event(POLICY_NOTIFY, policy);
 }
 
@@ -1399,12 +1399,13 @@ static int dp_coc_cpufreq_policy_notifier(struct notifier_block *nb,
 static int dp_coc_cpufreq_transition_notifier(struct notifier_block *nb,
 					      unsigned long event, void *data)
 {
+	int inst = 0;
 	struct cpufreq_freqs *freq = data;
 	if (event == CPUFREQ_PRECHANGE) {
-		return dp_port_prop[dp_coc_inst].info.
+		return dp_port_prop[inst].info.
 				dp_handle_cpufreq_event(PRE_CHANGE, freq);
 	} else if (event == CPUFREQ_POSTCHANGE) {
-		return dp_port_prop[dp_coc_inst].info.
+		return dp_port_prop[inst].info.
 				dp_handle_cpufreq_event(POST_CHANGE, freq);
 	}
 	return NOTIFY_OK;
@@ -1420,7 +1421,6 @@ static struct notifier_block dp_coc_cpufreq_policy_notifier_block = {
 
 int dp_cpufreq_notify_init(int inst)
 {
-	dp_coc_inst = inst;
 	if (cpufreq_register_notifier
 	    (&dp_coc_cpufreq_transition_notifier_block,
 	    CPUFREQ_TRANSITION_NOTIFIER)) {
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_coc.c b/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_coc.c
index 5a3722c20d1c..837ad1ab32fb 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_coc.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_coc.c
@@ -40,11 +40,11 @@ int dp_coc_ps_new = -1;
 struct work_struct coc_work_q;
 static GSW_RMON_Port_cnt_t rmon_last[PMAC_MAX_NUM];
 static u64 last_rmon_rx;
-int dp_coc_ps_max = 0;/*system maximum*/
-int dp_coc_ps_min = 0;/*system minimum*/
+int dp_coc_ps_max;/*system maximum*/
+int dp_coc_ps_min;/*system minimum*/
 
 int intr = -1;
-int inst = 0;
+int inst;
 /*meter */
 #define PCE_OVERHD 20
 static u32 meter_id;
@@ -76,7 +76,7 @@ int dp_set_rmon_threshold(uint32_t *threshold)
 	if (!threshold)
 		return -1;
 	memcpy((void *)&rmon_threshold,	(void *)threshold,
-			sizeof(rmon_threshold));
+	       sizeof(rmon_threshold));
 	return	0;
 }
 EXPORT_SYMBOL(dp_set_rmon_threshold);
@@ -109,7 +109,7 @@ static char *get_coc_stat_string(int stat)
 		return "Undef";
 }
 
-void proc_coc_read(struct seq_file *s)
+void proc_coc_read_30(struct seq_file *s)
 {
 	GSW_register_t reg;
 	GSW_QoS_meterCfg_t meter_cfg;
@@ -164,11 +164,10 @@ void proc_coc_read(struct seq_file *s)
 	seq_printf(s, "    PCE_PISR(0x%x)=%u(0x%x)-interrupt %s\n",
 		   reg.nRegAddr, reg.nData, reg.nData,
 		   (reg.nData & 0x100) ? "on" : "off");
-
 }
 
-ssize_t proc_coc_write(struct file *file, const char *buf, size_t count,
-		       loff_t *ppos)
+ssize_t proc_coc_write_30(struct file *file, const char *buf, size_t count,
+			  loff_t *ppos)
 {
 	int len, num;
 	char str[64];
@@ -262,13 +261,15 @@ ssize_t proc_coc_write(struct file *file, const char *buf, size_t count,
 	return count;
  help:
 	PR_INFO("Datapath COC Proc Usage:\n");
-	PR_INFO("  echo timer polling_interval_in_seconds > /sys/kernel/debug/dp/coc\n");
-	PR_INFO("  echo <thresholdx> its_threshold_value > /sys/kernel/debug/dp/coc\n");
+	PR_INFO
+	("echo timer polling_interval_in_seconds > /sys/kernel/debug/dp/coc\n");
+	PR_INFO
+	("echo <thresholdx> its_threshold_value > /sys/kernel/debug/dp/coc\n");
 	PR_INFO("       Note:Valid x of ranage: 1 2 3\n");
 	PR_INFO
 	    ("            For downscale to D<x> if rmon<threshold<x>'s cfg\n");
 	PR_INFO("            threshold1's >= threshold'2 > threshold'3\n");
-	PR_INFO("  echo <ratex> <meter_rate_in_knps> /sys/kernel/debug/dp/coc\n");
+	PR_INFO("echo <ratex> <meter_rate_in_knps> /sys/kernel/debug/dp/coc\n");
 	PR_INFO("       Note:Valid x of range: 1 2 3\n");
 	PR_INFO
 	  ("            For upscale to D0 from D<x> if rmon>=rate<x>'s cfg\n");
@@ -353,15 +354,14 @@ int apply_meter_rate(u32 rate, unsigned int new_state)
 	} else if (rate == -1) {
 		meter_cfg.bEnable = 1;
 		/*set PAE metering */
-		if (new_state == LTQ_CPUFREQ_PS_D1) {
+		if (new_state == LTQ_CPUFREQ_PS_D1)
 			meter_cfg.nRate = meter_nrate[1];
-		} else if (new_state == LTQ_CPUFREQ_PS_D2) {
+		else if (new_state == LTQ_CPUFREQ_PS_D2)
 			meter_cfg.nRate = meter_nrate[2];
-		} else if (new_state == LTQ_CPUFREQ_PS_D3) {
+		else if (new_state == LTQ_CPUFREQ_PS_D3)
 			meter_cfg.nRate = meter_nrate[3];
-		} else {
+		else
 			meter_cfg.nRate = new_state;
-		}
 	} else {
 		return -1;
 	}
@@ -506,9 +506,9 @@ static int dp_coc_policy_notify(struct cpufreq_policy *policy)
 		dp_coc_ps_max = policy->max;
 		dp_coc_ps_min = policy->min;
 	} else if (intr == 1) {
-		DP_DEBUG(DP_DBG_FLAG_COC, "dp new freq=%d\n", dp_coc_ps_new);
-		DP_DEBUG(DP_DBG_FLAG_COC, "no down scaling limit to freq=%d\n",
-			 dp_coc_ps_max);
+		DP_DEBUG(DP_DBG_FLAG_COC,
+			 "no down scaling, limit to freq=%d dp_freq_new=%d\n",
+			 dp_coc_ps_max, dp_coc_ps_new);
 		dp_coc_ps_new = dp_coc_ps_max;
 		intr = 0;
 		/*No down scaling allowed, limit the frequency to max */
@@ -520,87 +520,82 @@ static int dp_coc_policy_notify(struct cpufreq_policy *policy)
 
 static void dp_rmon_polling(unsigned long data)
 {
-        GSW_RMON_Port_cnt_t curr;
-        int i;
-        u64 rx = 0;
+	GSW_RMON_Port_cnt_t curr;
+	int i;
+	u64 rx = 0;
 	struct core_ops *gsw_handle;
 
 	/*read gswip-r rmon counter */
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
-        for (i = 0; i < PMAC_MAX_NUM; i++) {
-                memset(&curr, 0, sizeof(curr));
+	for (i = 0; i < PMAC_MAX_NUM; i++) {
+		memset(&curr, 0, sizeof(curr));
 		gsw_core_api((dp_gsw_cb)gsw_handle
-			     ->gsw_rmon_ops.RMON_Port_Get,
-			     gsw_handle, &curr);
-
-                coc_lock();
-                /*wrapround handling */
-                if (curr.nRxGoodPkts >= rmon_last[i].nRxGoodPkts)
-                        rx += curr.nRxGoodPkts - rmon_last[i].nRxGoodPkts;
-                else
-                        rx +=
-                            (u64)0xFFFFFFFF + (u64)curr.nRxGoodPkts -
-                            rmon_last[i].nRxGoodPkts;
-
-                if (curr.nRxDroppedPkts >= rmon_last[i].nRxDroppedPkts)
-                        rx +=
-                            curr.nRxDroppedPkts - rmon_last[i].nRxDroppedPkts;
-                else
-                        rx +=
-                            (u64)0xFFFFFFFF + (u64)curr.nRxDroppedPkts -
-                            rmon_last[i].nRxDroppedPkts;
-
-                memcpy(&rmon_last[i], &curr, sizeof(curr));
-                coc_unlock();
-        }
-        last_rmon_rx = rx;
-        if (dp_coc_ps_curr != -1) {
-                if (rx < rmon_threshold[3]) {
-				schedule_work(&coc_work_q); 
-                                coc_lock();
-                                rmon_timer_en = 0;
-                                coc_unlock();
-				DP_DEBUG(DP_DBG_FLAG_COC,
-                                         "Request to D3:rx (%u) < th_d3 %d\n",
-                                         (unsigned int)rx,
-                                         rmon_threshold[3]);
-                } else if (rx < rmon_threshold[2]) {
-				schedule_work(&coc_work_q); 
-				DP_DEBUG(DP_DBG_FLAG_COC,
-                                        "req to D2: rx (%u) < th_d2 %d\n",
-                                         (unsigned int)rx,
-                                         rmon_threshold[2]);
-                } else if (rx < rmon_threshold[1]) {
-				schedule_work(&coc_work_q); 
-                                DP_DEBUG(DP_DBG_FLAG_COC,
-                                         "req to D1 since rx (%u) < th_d1 %d\n",
-                                         (unsigned int)rx,
-                                         rmon_threshold[1]);
-                } 
-        } else
-                DP_DEBUG(DP_DBG_FLAG_COC,
-                         "DP COC not get its initial power state yet\n");
+				->gsw_rmon_ops.RMON_Port_Get,
+				gsw_handle, &curr);
 
+		coc_lock();
+		/*wrapround handling */
+		if (curr.nRxGoodPkts >= rmon_last[i].nRxGoodPkts)
+			rx += curr.nRxGoodPkts - rmon_last[i].nRxGoodPkts;
+		else
+			rx += (u64)0xFFFFFFFF + (u64)curr.nRxGoodPkts -
+				rmon_last[i].nRxGoodPkts;
+
+		if (curr.nRxDroppedPkts >= rmon_last[i].nRxDroppedPkts)
+			rx += curr.nRxDroppedPkts - rmon_last[i].nRxDroppedPkts;
+		else
+			rx += (u64)0xFFFFFFFF + (u64)curr.nRxDroppedPkts -
+				rmon_last[i].nRxDroppedPkts;
+
+		memcpy(&rmon_last[i], &curr, sizeof(curr));
+		coc_unlock();
+	}
+	last_rmon_rx = rx;
+	if (dp_coc_ps_curr != -1) {
+		if (rx < rmon_threshold[3]) {
+			schedule_work(&coc_work_q);
+			coc_lock();
+			rmon_timer_en = 0;
+			coc_unlock();
+			DP_DEBUG(DP_DBG_FLAG_COC,
+				 "Request to D3:rx (%u) < th_d3 %d\n",
+				 (unsigned int)rx, rmon_threshold[3]);
+		} else if (rx < rmon_threshold[2]) {
+			schedule_work(&coc_work_q);
+			DP_DEBUG(DP_DBG_FLAG_COC,
+				 "req to D2: rx (%u) < th_d2 %d\n",
+				 (unsigned int)rx, rmon_threshold[2]);
+		} else if (rx < rmon_threshold[1]) {
+			schedule_work(&coc_work_q);
+			DP_DEBUG(DP_DBG_FLAG_COC,
+				 "req to D1 since rx (%u) < th_d1 %d\n",
+				 (unsigned int)rx, rmon_threshold[1]);
+		}
+	} else {
+		DP_DEBUG(DP_DBG_FLAG_COC,
+			 "DP COC not get its initial power state yet\n");
+	}
 	coc_lock();
 	if (rmon_timer_en)
 		mod_timer(&dp_coc_timer,
-                          jiffies + msecs_to_jiffies(polling_period * 1000));
-        else
+			  jiffies + msecs_to_jiffies(polling_period * 1000));
+	else
 		last_rmon_rx = 0;
 
-        coc_unlock();
+	coc_unlock();
 }
+
 void update_rmon_last(void)
 {
-        int i;
+	int i;
 	struct core_ops *gsw_handle;
 
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
 	memset(rmon_last, 0, sizeof(rmon_last));
-	for (i = 0; i < PMAC_MAX_NUM; i++)
-		gsw_core_api((dp_gsw_cb)gsw_handle
-			     ->gsw_rmon_ops.RMON_Port_Get,
+	for (i = 0; i < PMAC_MAX_NUM; i++) {
+		gsw_core_api((dp_gsw_cb)gsw_handle->gsw_rmon_ops.RMON_Port_Get,
 			     gsw_handle, &rmon_last[i]);
+	}
 }
 
 int update_coc_rmon_timer(uint32_t new_state)
@@ -649,13 +644,13 @@ int update_coc_rmon_timer(uint32_t new_state)
 static int dp_coc_prechange(struct cpufreq_freqs *freq)
 {
 	/*check whether can be switched or not
-	 * and accept the request 
+	 * and accept the request
 	 */
-	if (!dp_coc_init_stat || !dp_coc_ena) {
+	if (!dp_coc_init_stat || !dp_coc_ena)
 		return NOTIFY_OK;
-	}
+
 	DP_DEBUG(DP_DBG_FLAG_COC,
-	         "dp_coc_prechange:to switch from %d to %d\n",
+		 "dp_coc_prechange:to switch from %d to %d\n",
 		 freq->old, freq->new);
 
 	return NOTIFY_OK;
@@ -671,7 +666,7 @@ static int dp_coc_postchange(struct cpufreq_freqs *freq)
 	update_coc_rmon_timer(freq->new);
 	coc_unlock();
 	DP_DEBUG(DP_DBG_FLAG_COC,
-	         "dp_coc_postchange:to switch from %d to %d\n",
+		 "dp_coc_postchange:to switch from %d to %d\n",
 		 freq->old, freq->new);
 	return NOTIFY_OK;
 }
@@ -699,6 +694,7 @@ int dp_handle_cpufreq_event_30(int event_id, void *cfg)
 	}
 	return res;
 }
+
 /* Create Work Q to call CPUFREQ policy notifier
  *in order to run out of interrupt context
  */
@@ -710,23 +706,24 @@ static int coc_work_task(struct work_struct *work)
 
 void dp_meter_interrupt_cb(void *param)
 {
-	DP_DEBUG(DP_DBG_FLAG_COC, "triggered meter intr\n");
-	DP_DEBUG(DP_DBG_FLAG_COC, "dp curr freq=%d\n", dp_coc_ps_curr);
+	DP_DEBUG(DP_DBG_FLAG_COC,
+		 "triggered meter intr with dp curr freq=%d\n",
+		 dp_coc_ps_curr);
 	intr = 1;
 	schedule_work(&coc_work_q); /* schedule work queue */
-	return;
 }
 
 int dp_coc_cpufreq_init(void)
 {
 	GSW_Irq_Op_t irq;
 	struct core_ops *gsw_handle;
-	PR_INFO("enter dp_coc_cpufreq_init\n");
 
-	spin_lock_init(&dp_coc_lock);
 	dp_coc_init_stat = 0;
 	dp_coc_ena = 0;
-        gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
+
+	PR_INFO("enter dp_coc_cpufreq_init\n");
+	spin_lock_init(&dp_coc_lock);
+	gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
 	cpufreq_update_policy(0);
 
 	if (!polling_period)
@@ -754,8 +751,9 @@ int dp_coc_cpufreq_init(void)
 
 int dp_coc_cpufreq_exit(void)
 {
+	int ret;
+
 	if (dp_coc_init_stat) {
-		int ret;
 		coc_lock();
 		ret = del_timer(&dp_coc_timer);
 		if (ret)
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_misc.h b/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_misc.h
index 375fa81390ac..1d86070bc87f 100644
--- a/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_misc.h
+++ b/drivers/net/ethernet/lantiq/datapath/gswip30/datapath_misc.h
@@ -87,6 +87,9 @@ ssize_t proc_get_qid_via_index30(struct file *file, const char *buf,
 				 size_t count, loff_t *ppos);
 #ifdef CONFIG_LTQ_DATAPATH_CPUFREQ
 int dp_handle_cpufreq_event_30(int event_id, void *cfg);
+void proc_coc_read_30(struct seq_file *s);
+ssize_t proc_coc_write_30(struct file *file, const char *buf, size_t count,
+			  loff_t *ppos);
 #endif
 
 #endif
