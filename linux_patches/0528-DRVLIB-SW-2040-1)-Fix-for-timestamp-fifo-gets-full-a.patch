From cbb10b8845b8da7819bdf48b624cbb5263866f19 Mon Sep 17 00:00:00 2001
From: Dinesh Sudham <dineshx.sudham@intel.com>
Date: Thu, 21 Mar 2019 13:47:03 +0800
Subject: [PATCH] DRVLIB_SW-2040: 1) Fix for timestamp fifo gets full after 15
 hours 2) External timestamp missing after few hours of testing 3) Xgmac timer
 getting stopped after few hours of testing

---
 .../net/ethernet/lantiq/switch-api/mac/mac_drv.c   |  3 +++
 .../ethernet/lantiq/switch-api/mac/mac_tx_fifo.c   | 15 +------------
 drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h | 26 +++++++++++++++++-----
 .../ethernet/lantiq/switch-api/mac/xgmac_common.h  |  1 +
 .../net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c | 21 ++++++++---------
 5 files changed, 36 insertions(+), 30 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c b/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c
index 595c4ee01ed5..a53eaa8075f6 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c
@@ -142,6 +142,9 @@ static int mac_probe(struct platform_device *pdev)
 	/* Initialize MAC Spin lock */
 	spin_lock_init(&pdata->mac_lock);
 
+	/* Initialize Spin lock for Indirect read/write */
+	spin_lock_init(&pdata->rw_lock);
+
 	/* load the memory ranges */
 	for (i = 0; i < pdev->num_resources; i++) {
 		res[i] = platform_get_resource(pdev, IORESOURCE_MEM, i);
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.c b/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.c
index 024c4cb41b4c..390a8042a436 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.c
@@ -180,23 +180,10 @@ static int fifo_freeid_get(void *pdev, u8 ttse)
 {
 	int i = FIFO_FULL;
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_fifo_cnt = 0;
 
 	for (i = START_FIFO; i < MAX_FIFO_ENTRY; i++) {
 		if (!pdata->ts_fifo[i].is_used) {
-			if (ttse) {
-				mac_fifo_cnt = XGMAC_RGRD_BITS(pdata,
-							       MAC_TSTAMP_STSR,
-							       TTSNS);
-			}
-
-			/* If nothing stored in Xgmac Fifo */
-			if (mac_fifo_cnt == 0) {
-				return pdata->ts_fifo[i].rec_id;
-			} else {
-				mac_printf("Xgmac Fifo already have entry\n");
-				return FIFO_FULL;
-			}
+			return pdata->ts_fifo[i].rec_id;
 		} else {
 			fifo_update_hw_clrsts(pdev, &pdata->ts_fifo[i]);
 		}
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h
index 3695c9c9a202..84b6f8db71c0 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h
@@ -755,11 +755,10 @@ enum  {
 #define MASK_N_BITS(reg, field)		((1 << (reg##_##field##_WIDTH)) - 1)
 
 
-
 #ifdef __KERNEL__
 static inline u32 XGMAC_IO_R32(struct mac_prv_data *pdata, u16 reg)
 {
-	u32 reg_val;
+	u32 reg_val, idx = 0;
 	void __iomem *xgmac_ctrl_reg  =
 		(void __iomem *)(pdata->ss_addr_base + pdata->xgmac_ctrl_reg);
 	void __iomem *xgmac_data0_reg =
@@ -769,10 +768,14 @@ static inline u32 XGMAC_IO_R32(struct mac_prv_data *pdata, u16 reg)
 
 	mac_w32((0x8000 | reg), xgmac_ctrl_reg);
 
-	while (1) {
+	do {
 		if ((mac_r32(xgmac_ctrl_reg) & 0x8000) == 0)
 			break;
-	}
+
+	} while (++idx <= MAX_RETRY);
+
+	if (idx >= MAX_RETRY)
+		pr_err(":::: Xgmac register read failed for Offset %x ::::\n",reg);
 
 	reg_val = ((mac_r32(xgmac_data1_reg) << 16) |
 		   (mac_r32(xgmac_data0_reg)));
@@ -783,6 +786,7 @@ static inline u32 XGMAC_IO_R32(struct mac_prv_data *pdata, u16 reg)
 static inline void XGMAC_IO_W32(struct mac_prv_data *pdata, u16 reg,
 				u32 val)
 {
+	u32 idx = 0;
 	void __iomem *xgmac_ctrl_reg  =
 		(void __iomem *)(pdata->ss_addr_base + pdata->xgmac_ctrl_reg);
 	void __iomem *xgmac_data0_reg =
@@ -794,10 +798,15 @@ static inline void XGMAC_IO_W32(struct mac_prv_data *pdata, u16 reg,
 	mac_w32((val & 0x0000FFFF), xgmac_data0_reg);
 	mac_w32((0xC000 | reg), xgmac_ctrl_reg);
 
-	while (1) {
+	do {
 		if ((mac_r32(xgmac_ctrl_reg) & 0x8000) == 0)
 			break;
-	}
+
+	} while (++idx <= MAX_RETRY);
+
+	if (idx >= MAX_RETRY)
+		pr_err(":::: Xgmac register write failed for Offset %x ::::\n",reg);
+
 }
 #else
 static inline u32 XGMAC_R32(struct mac_prv_data *pdata, u16 reg)
@@ -893,7 +902,9 @@ static inline u32 XGMAC_RGRD(struct mac_prv_data *pdata, u16 reg)
 	reg_val = XGMAC_R32(pdata, reg);
 #endif
 #ifdef __KERNEL__
+	spin_lock_bh(&pdata->rw_lock);
 	reg_val = XGMAC_IO_R32(pdata, reg);
+	spin_unlock_bh(&pdata->rw_lock);
 #endif
 
 	return reg_val;
@@ -908,7 +919,9 @@ static inline void XGMAC_RGWR(struct mac_prv_data *pdata, u16 reg, u32 val)
 	XGMAC_W32(pdata, reg, val);
 #endif
 #ifdef __KERNEL__
+	spin_lock_bh(&pdata->rw_lock);
 	XGMAC_IO_W32(pdata, reg, val);
+	spin_unlock_bh(&pdata->rw_lock);
 #endif
 }
 
@@ -992,6 +1005,7 @@ int xgmac_ptp_txtstamp_mode(void *pdev,
 			    u32 snaptypesel,
 			    u32 tsmstrena,
 			    u32 tsevntena);
+
 int xgmac_set_eee_mode(void *pdev, u32 val);
 int xgmac_set_eee_pls(void *pdev, u32 val);
 int xgmac_set_eee_timer(void *pdev, u32 twt, u32 lst);
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h
index 67c6a0ebce57..e933b41c0900 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h
@@ -413,6 +413,7 @@ struct mac_prv_data {
 	spinlock_t ptp_lock;
 	struct ptp_clock *ptp_clock;
 	spinlock_t mac_lock;
+	spinlock_t rw_lock;
 	struct mii_bus *mii;
 	struct phy_device *phydev;
 	struct tasklet_struct mac_tasklet;
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c
index 9a9b47242284..9d93a56368c6 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c
@@ -68,19 +68,20 @@ void xgmac_config_timer_reg(void *pdev)
 	struct mac_ops *hw_if = &pdata->ops;
 	u64 temp = 0;
 
-	/* program Sub Second Increment Reg */
-	hw_if->config_subsec_inc(pdev, pdata->ptp_clk);
+	if (!pdata->systime_initialized) {
 
-	/* Calculate the def addend:
-	 * addend = 2^32 / (PTP ref clock / CLOCK_UPDATE_FREQ)
-	 *        = (2^32 * CLOCK_UPDATE_FREQ) / PTP ref clock
-	 */
-	temp = (u64)((CLOCK_UPDATE_FREQ * 1000000ULL) << 32);
-	pdata->def_addend = div_u64(temp, pdata->ptp_clk);
+		/* program Sub Second Increment Reg */
+		hw_if->config_subsec_inc(pdev, pdata->ptp_clk);
 
-	hw_if->config_addend(pdev, pdata->def_addend);
+		/* Calculate the def addend:
+		 * addend = 2^32 / (PTP ref clock / CLOCK_UPDATE_FREQ)
+		 *        = (2^32 * CLOCK_UPDATE_FREQ) / PTP ref clock
+		 */
+		temp = (u64)((CLOCK_UPDATE_FREQ * 1000000ULL) << 32);
+		pdata->def_addend = div_u64(temp, pdata->ptp_clk);
+
+		hw_if->config_addend(pdev, pdata->def_addend);
 
-	if (!pdata->systime_initialized) {
 		/* initialize system time */
 		getnstimeofday(&now);
 		hw_if->init_systime(pdev, now.tv_sec, now.tv_nsec);
