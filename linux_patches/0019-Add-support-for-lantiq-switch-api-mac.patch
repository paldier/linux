From 6f724cf94f7e4a8e40789227d2043c3f9f872b5f Mon Sep 17 00:00:00 2001
From: Hua Ma <hua.ma@linux.intel.com>
Date: Thu, 21 Jun 2018 17:37:50 +0800
Subject: [PATCH] Add support for lantiq switch api mac

---
 .../net/ethernet/lantiq/switch-api/mac/Makefile    |   20 +
 .../net/ethernet/lantiq/switch-api/mac/gswss_api.c |  695 ++++++
 .../net/ethernet/lantiq/switch-api/mac/gswss_api.h |  273 +++
 .../ethernet/lantiq/switch-api/mac/gswss_mac_api.c | 1832 ++++++++++++++++
 .../ethernet/lantiq/switch-api/mac/gswss_mac_api.h |  280 +++
 .../net/ethernet/lantiq/switch-api/mac/lmac_api.c  | 1400 ++++++++++++
 .../net/ethernet/lantiq/switch-api/mac/lmac_api.h  |  358 ++++
 .../net/ethernet/lantiq/switch-api/mac/mac_cfg.c   | 1212 +++++++++++
 .../net/ethernet/lantiq/switch-api/mac/mac_cfg.h   |   65 +
 .../net/ethernet/lantiq/switch-api/mac/mac_drv.c   |  210 ++
 drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h | 1078 ++++++++++
 .../net/ethernet/lantiq/switch-api/mac/xgmac_cli.c | 1018 +++++++++
 .../net/ethernet/lantiq/switch-api/mac/xgmac_cli.h |  108 +
 .../ethernet/lantiq/switch-api/mac/xgmac_common.h  |  744 +++++++
 .../ethernet/lantiq/switch-api/mac/xgmac_debug.c   | 2258 ++++++++++++++++++++
 .../ethernet/lantiq/switch-api/mac/xgmac_mac_api.c | 1685 +++++++++++++++
 .../ethernet/lantiq/switch-api/mac/xgmac_main.c    | 1028 +++++++++
 .../ethernet/lantiq/switch-api/mac/xgmac_mdio.c    |  676 ++++++
 .../ethernet/lantiq/switch-api/mac/xgmac_mdio.h    |  258 +++
 .../ethernet/lantiq/switch-api/mac/xgmac_mtl_api.c |  584 +++++
 .../net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c |  665 ++++++
 .../net/ethernet/lantiq/switch-api/mac/xgmac_ptp.h |   72 +
 include/net/switch_api/mac_ops.h                   |  384 ++++
 23 files changed, 16903 insertions(+)

diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/Makefile b/drivers/net/ethernet/lantiq/switch-api/mac/Makefile
new file mode 100644
index 000000000000..8a6a5f728e7d
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/Makefile
@@ -0,0 +1,20 @@
+#
+# Makefile for MAC
+#
+
+EXTRA_CFLAGS += -I$(src)
+obj-$(CONFIG_LTQ_ETHSW_API) += mac_driver.o
+
+mac_driver-objs += mac_drv.o 
+mac_driver-objs += xgmac_main.o 
+mac_driver-objs += xgmac_debug.o 
+mac_driver-objs += xgmac_mtl_api.o 
+mac_driver-objs += xgmac_ptp.o 
+mac_driver-objs += xgmac_mac_api.o 
+mac_driver-objs += xgmac_cli.o 
+mac_driver-objs += xgmac_mdio.o 
+mac_driver-objs += mac_cfg.o 
+mac_driver-objs += gswss_api.o 
+mac_driver-objs += gswss_mac_api.o 
+mac_driver-objs += lmac_api.o
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.c b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.c
new file mode 100644
index 000000000000..dbab9a34ca2c
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.c
@@ -0,0 +1,695 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#include <gswss_api.h>
+
+int gswss_cfg0_1588(void *pdev, u32 ref_time, u32 dig_time, u32 bin_time,
+		    u32 pps_sel)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 cfg0;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+
+	cfg0 = GSWSS_RGRD(pdata, CFG0_1588);
+
+	if (ref_time == 0)
+		mac_printf("\tREF_TIME: PON_PCS is the master\n");
+	else if (ref_time == 1)
+		mac_printf("\tREF_TIME: PCIE0 is the master\n");
+	else if (ref_time == 2)
+		mac_printf("\tREF_TIME: PCIE1 is the master\n");
+	else if (ref_time == 3)
+		mac_printf("\tREF_TIME: XGMAC2 is the master\n");
+	else if (ref_time == 4)
+		mac_printf("\tREF_TIME: XGMAC3 is the master\n");
+	else if (ref_time == 5)
+		mac_printf("\tREF_TIME: XGMAC4 is the master\n");
+	else {
+		mac_printf("\tREF_TIME: Wrong Value");
+		goto end;
+	}
+
+	if (dig_time == 0)
+		mac_printf("\tDIG_TIME: PON_PCS is the master\n");
+	else if (dig_time == 1)
+		mac_printf("\tDIG_TIME: PCIE0 is the master\n");
+	else if (dig_time == 2)
+		mac_printf("\tDIG_TIME: PCIE1 is the master\n");
+	else if (dig_time == 3)
+		mac_printf("\tDIG_TIME: XGMAC2 is the master\n");
+	else if (dig_time == 4)
+		mac_printf("\tDIG_TIME: XGMAC3 is the master\n");
+	else if (dig_time == 5)
+		mac_printf("\tDIG_TIME: XGMAC4 is the master\n");
+	else {
+		mac_printf("\tDIG_TIME: Wrong Value");
+		goto end;
+	}
+
+	if (bin_time == 0)
+		mac_printf("\tBIN_TIME: PON_PCS is the master\n");
+	else if (bin_time == 1)
+		mac_printf("\tBIN_TIME: PCIE0 is the master\n");
+	else if (bin_time == 2)
+		mac_printf("\tBIN_TIME: PCIE1 is the master\n");
+	else if (bin_time == 3)
+		mac_printf("\tBIN_TIME: XGMAC2 is the master\n");
+	else if (bin_time == 4)
+		mac_printf("\tBIN_TIME: XGMAC3 is the master\n");
+	else if (bin_time == 5)
+		mac_printf("\tBIN_TIME: XGMAC4 is the master\n");
+	else {
+		mac_printf("\tBIN_TIME: Wrong Value");
+		goto end;
+	}
+
+	if (pps_sel == 0)
+		mac_printf("\tPPS_SEL: PON_PCS is the master\n");
+	else if (pps_sel == 1)
+		mac_printf("\tPPS_SEL: PCIE0 is the master\n");
+	else if (pps_sel == 2)
+		mac_printf("\tPPS_SEL: PCIE1 is the master\n");
+	else if (pps_sel == 3)
+		mac_printf("\tPPS_SEL: XGMAC2 is the master\n");
+	else if (pps_sel == 4)
+		mac_printf("\tPPS_SEL: XGMAC3 is the master\n");
+	else if (pps_sel == 5)
+		mac_printf("\tPPS_SEL: XGMAC4 is the master\n");
+	else if (pps_sel == 6)
+		mac_printf("\tPPS_SEL: PON PPS100US is the master\n");
+	else if (pps_sel == 7)
+		mac_printf("\tPPS_SEL: Software trigger\n");
+	else {
+		mac_printf("\tPPS_SEL: Wrong Value");
+		goto end;
+	}
+
+	MAC_SET_VAL(cfg0, CFG0_1588, REFTIME, ref_time);
+	MAC_SET_VAL(cfg0, CFG0_1588, DIGTIME, dig_time);
+	MAC_SET_VAL(cfg0, CFG0_1588, BINTIME, bin_time);
+	MAC_SET_VAL(cfg0, CFG0_1588, PPSSEL, pps_sel);
+
+	GSWSS_RGWR(pdata, CFG0_1588, cfg0);
+
+end:
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+
+	return 0;
+}
+
+int gswss_get_cfg0_1588(void *pdev, u32 *ref_time, u32 *dig_time,
+			u32 *bin_time, u32 *pps_sel)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 cfg0;
+
+#ifdef __KERNEL__
+
+
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+
+	cfg0 = GSWSS_RGRD(pdata, CFG0_1588);
+
+	*ref_time = MAC_GET_VAL(cfg0, CFG0_1588, REFTIME);
+	*dig_time = MAC_GET_VAL(cfg0, CFG0_1588, DIGTIME);
+	*bin_time = MAC_GET_VAL(cfg0, CFG0_1588, BINTIME);
+	*pps_sel = MAC_GET_VAL(cfg0, CFG0_1588, PPSSEL);
+
+	if (*ref_time == 0)
+		mac_printf("\tREF_TIME: PON_PCS is the master\n");
+	else if (*ref_time == 1)
+		mac_printf("\tREF_TIME: PCIE0 is the master\n");
+	else if (*ref_time == 2)
+		mac_printf("\tREF_TIME: PCIE1 is the master\n");
+	else if (*ref_time == 3)
+		mac_printf("\tREF_TIME: XGMAC2 is the master\n");
+	else if (*ref_time == 4)
+		mac_printf("\tREF_TIME: XGMAC3 is the master\n");
+	else if (*ref_time == 5)
+		mac_printf("\tREF_TIME: XGMAC4 is the master\n");
+
+	if (*dig_time == 0)
+		mac_printf("\tDIG_TIME: PON_PCS is the master\n");
+	else if (*dig_time == 1)
+		mac_printf("\tDIG_TIME: PCIE0 is the master\n");
+	else if (*dig_time == 2)
+		mac_printf("\tDIG_TIME: PCIE1 is the master\n");
+	else if (*dig_time == 3)
+		mac_printf("\tDIG_TIME: XGMAC2 is the master\n");
+	else if (*dig_time == 4)
+		mac_printf("\tDIG_TIME: XGMAC3 is the master\n");
+	else if (*dig_time == 5)
+		mac_printf("\tDIG_TIME: XGMAC4 is the master\n");
+
+	if (*bin_time == 0)
+		mac_printf("\tBIN_TIME: PON_PCS is the master\n");
+	else if (*bin_time == 1)
+		mac_printf("\tBIN_TIME: PCIE0 is the master\n");
+	else if (*bin_time == 2)
+		mac_printf("\tBIN_TIME: PCIE1 is the master\n");
+	else if (*bin_time == 3)
+		mac_printf("\tBIN_TIME: XGMAC2 is the master\n");
+	else if (*bin_time == 4)
+		mac_printf("\tBIN_TIME: XGMAC3 is the master\n");
+	else if (*bin_time == 5)
+		mac_printf("\tBIN_TIME: XGMAC4 is the master\n");
+
+	if (*pps_sel == 0)
+		mac_printf("\tPPS_SEL: PON_PCS is the master\n");
+	else if (*pps_sel == 1)
+		mac_printf("\tPPS_SEL: PCIE0 is the master\n");
+	else if (*pps_sel == 2)
+		mac_printf("\tPPS_SEL: PCIE1 is the master\n");
+	else if (*pps_sel == 3)
+		mac_printf("\tPPS_SEL: XGMAC2 is the master\n");
+	else if (*pps_sel == 4)
+		mac_printf("\tPPS_SEL: XGMAC3 is the master\n");
+	else if (*pps_sel == 5)
+		mac_printf("\tPPS_SEL: XGMAC4 is the master\n");
+	else if (*pps_sel == 6)
+		mac_printf("\tPPS_SEL: PON PPS100US is the master\n");
+	else if (*pps_sel == 7)
+		mac_printf("\tPPS_SEL: Software trigger\n");
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+
+	return 0;
+}
+
+int gswss_macsec_reset(void *pdev, u32 reset)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 macsec_en;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+
+	macsec_en = GSWSS_RGRD(pdata, MACSEC_EN);
+
+	MAC_SET_VAL(macsec_en, MACSEC_EN, RES, reset);
+
+	mac_printf("GSWSS: MACSEC reset : %s\n",
+		   reset ? "ENABLED" : "DISABLED");
+
+	GSWSS_RGWR(pdata, MACSEC_EN, macsec_en);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+
+	return 0;
+}
+
+int gswss_get_macsec_reset(void *pdev)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 macsec_en, reset;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+	macsec_en = GSWSS_RGRD(pdata, MACSEC_EN);
+
+	reset = MAC_GET_VAL(macsec_en, MACSEC_EN, RES);
+
+	mac_printf("GSWSS: MACSEC reset : %s\n",
+		   reset ? "ENABLED" : "DISABLED");
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+
+	return 0;
+}
+
+int gswss_switch_ss_reset(void *pdev)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 core_reset;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+
+	core_reset = GSWSS_RGRD(pdata, GSWIP_CFG);
+
+	mac_printf("Switch Subsys Resetting\n");
+
+	MAC_SET_VAL(core_reset, GSWIP_CFG, SS_HWRES, 1);
+
+	GSWSS_RGWR(pdata, GSWIP_CFG, core_reset);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+
+	return 0;
+}
+
+int gswss_get_switch_ss_reset(void *pdev)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 core_reset, reset;
+
+#ifdef __KERNEL__
+
+
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+	core_reset = GSWSS_RGRD(pdata, GSWIP_CFG);
+	reset = MAC_GET_VAL(core_reset, GSWIP_CFG, SS_HWRES);
+
+	mac_printf("Switch Subsys Reset %s\n",
+		   reset ? "ENABLED" : "DISABLED");
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+
+	return 0;
+}
+
+int gswss_set_clkmode(void *pdev, u32 clk_mode)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 clk_mode_cfg;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+
+	clk_mode_cfg = GSWSS_RGRD(pdata, GSWIP_CFG);
+
+	mac_printf("GSWSS: Clock Mode Changing to :");
+
+	if (clk_mode == 0)
+		mac_printf("%s\n", "NCO1 - 666 Mhz");
+	else if (clk_mode == 1)
+		mac_printf("%s\n", "NCO2 - 450 Mhz");
+	else if (clk_mode == 2)
+		mac_printf("%s\n", "Auto Mode (666/450) Mhz");
+	else if (clk_mode == 3)
+		mac_printf("%s\n", "Auto Mode (666/450) Mhz");
+	else {
+		mac_printf("%s\n", "Wrong Value");
+		goto end;
+	}
+
+	MAC_SET_VAL(clk_mode_cfg, GSWIP_CFG, CLK_MD, clk_mode);
+
+	GSWSS_RGWR(pdata, GSWIP_CFG, clk_mode_cfg);
+
+end:
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+
+	return 0;
+}
+
+u32 gswss_get_clkmode(void *pdev)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 clk_mode_cfg;
+	u32 clk_mode;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+
+	clk_mode_cfg = GSWSS_RGRD(pdata, GSWIP_CFG);
+	clk_mode = MAC_GET_VAL(clk_mode_cfg, GSWIP_CFG, CLK_MD);
+
+	mac_printf("GSWSS: Clock Mode Got :");
+
+	if (clk_mode == 0)
+		mac_printf("%s\n", "NCO1 - 666 Mhz");
+	else if (clk_mode == 1)
+		mac_printf("%s\n", "NCO2 - 450 Mhz");
+	else if (clk_mode == 2)
+		mac_printf("%s\n", "Auto Mode (666/450) Mhz");
+	else if (clk_mode == 3)
+		mac_printf("%s\n", "Auto Mode (666/450) Mhz");
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+
+	return clk_mode;
+}
+
+int gswss_set_corese(void *pdev, u32 val)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 core_en;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+	core_en = GSWSS_RGRD(pdata, GSWIP_CFG);
+
+	if (val == FREEZE)
+		pdata->core_en_cnt++;
+	else {
+		if (pdata->core_en_cnt)
+			pdata->core_en_cnt--;
+	}
+
+	/* Unfreeze only when Count is 0 & val is UNFREEZE
+	 * Freeze when val is FREEZE
+	 */
+	if ((val == UNFREEZE && pdata->core_en_cnt == 0) ||
+	    (val == FREEZE)) {
+		MAC_SET_VAL(core_en, GSWIP_CFG, CORE_SE, val);
+		GSWSS_RGWR(pdata, GSWIP_CFG, core_en);
+	}
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+	return 0;
+}
+
+u32 gswss_get_corese(void *pdev)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 core_en, enable;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+	core_en = GSWSS_RGRD(pdata, GSWIP_CFG);
+
+	enable = MAC_GET_VAL(core_en, GSWIP_CFG, CORE_SE);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+	return enable;
+}
+
+int gswss_set_macsec_to_mac(void *pdev, u32 mac_idx, u32 enable)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 macsec_en;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+	macsec_en = GSWSS_RGRD(pdata, MACSEC_EN);
+
+	mac_idx += 2;
+
+	if (enable) {
+		mac_printf("GSWSS: MACSEC enabled to MAC %d data traffic\n",
+			   mac_idx);
+		MAC_SET_VAL(macsec_en, MACSEC_EN, SEL, mac_idx);
+	} else {
+		mac_printf("GSWSS: MACSEC to MAC mapping : DISABLED\n");
+		MAC_SET_VAL(macsec_en, MACSEC_EN, SEL, 0);
+	}
+
+	GSWSS_RGWR(pdata, MACSEC_EN, macsec_en);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+
+	return 0;
+}
+
+int gswss_get_macsec_to_mac(void *pdev)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 macsec_en, mac_idx;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+	macsec_en = GSWSS_RGRD(pdata, MACSEC_EN);
+
+	mac_idx = MAC_GET_VAL(macsec_en, MACSEC_EN, SEL);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+	return mac_idx;
+}
+
+
+int gswss_dbg_macsec_to_mac(void *pdev)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 macsec_en, mac_idx;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+
+	macsec_en = GSWSS_RGRD(pdata, MACSEC_EN);
+
+	mac_idx = MAC_GET_VAL(macsec_en, MACSEC_EN, SEL);
+
+	if (mac_idx == 0)
+		mac_printf("GSWSS: MACSEC Disabled\n");
+	else if (mac_idx == 2)
+		mac_printf("GSWSS: MACSEC enabled to MAC %d data traffic\n",
+			   mac_idx);
+	else if (mac_idx == 3)
+		mac_printf("GSWSS: MACSEC enabled to MAC %d data traffic\n",
+			   mac_idx);
+	else if (mac_idx == 4)
+		mac_printf("GSWSS: MACSEC enabled to MAC %d data traffic\n",
+			   mac_idx);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+
+	return mac_idx;
+}
+
+/* Calling from Interrupt Context, so no lock required. */
+int gswss_set_interrupt(void *pdev, u32 mod, u32 idx, u32 enable)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 mac_int_en0, mac_int_en1;
+	int ret = 0;
+
+	switch (mod) {
+	case XGMAC:
+		//mac_printf("XGMAC %d: Interrupt %s\n", idx,
+		//	   enable ? "ENABLED" : "DISABLED");
+
+		mac_int_en0 = GSWSS_RGRD(pdata, GSWIPSS_IER0);
+		idx += GSWIPSS_IER0_XGMAC2_POS;
+		SET_N_BITS(mac_int_en0, idx, GSWIPSS_IER0_XGMAC2_WIDTH, enable);
+		GSWSS_RGWR(pdata, GSWIPSS_IER0, mac_int_en0);
+		break;
+
+	case LINK:
+		mac_printf("LINK %d: Interrupt %s\n", idx,
+			   enable ? "ENABLED" : "DISABLED");
+
+		mac_int_en1 = GSWSS_RGRD(pdata, GSWIPSS_IER1);
+		idx += GSWIPSS_IER1_LINK2_POS;
+		SET_N_BITS(mac_int_en1, idx, GSWIPSS_IER1_LINK2_WIDTH, enable);
+		GSWSS_RGWR(pdata, GSWIPSS_IER1, mac_int_en1);
+		break;
+
+	default:
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+
+int gswss_get_int_en_sts(void *pdev)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 reg_val, reg_val1;
+	int ret = 0, i = 0;
+	u32 mac_int_isr0, mac_int_isr1;
+	u32 max_mac = gsw_get_mac_subifcnt(0);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+
+	mac_int_isr0 = GSWSS_RGRD(pdata, GSWIPSS_ISR0);
+	mac_int_isr1 = GSWSS_RGRD(pdata, GSWIPSS_ISR1);
+	reg_val = GSWSS_RGRD(pdata, GSWIPSS_IER0);
+	reg_val1 = GSWSS_RGRD(pdata, GSWIPSS_IER1);
+
+	mac_printf("GSWIPSS_IER0 %08x\n", reg_val);
+	mac_printf("GSWIPSS_IER1 %08x\n", reg_val1);
+	mac_printf("GSWIPSS_ISR0 %08x\n", mac_int_isr0);
+	mac_printf("GSWIPSS_ISR1 %08x\n", mac_int_isr1);
+
+	for (i = 0; i < max_mac; i++) {
+		mac_printf("\tXGMAC %d INT EN:  %s\n",
+			   i,
+			   GET_N_BITS(reg_val, GSWIPSS_IER0_XGMAC2_POS + i, 1) ?
+			   "ENABLED" :
+			   "DISABLED");
+		mac_printf("\tXGMAC %d INT STS: %s\n",
+			   i,
+			   GET_N_BITS(mac_int_isr0, GSWIPSS_ISR0_XGMAC2_POS + i, 1) ?
+			   "ENABLED" :
+			   "DISABLED");
+
+		mac_printf("\tLINK %d INT EN:  %s\n",
+			   i, GET_N_BITS(reg_val1, GSWIPSS_IER1_LINK2_POS + i, 1) ?
+			   "ENABLED" :
+			   "DISABLED");
+		mac_printf("\tLINK %d INT STS: %s\n",
+			   i, GET_N_BITS(mac_int_isr1, GSWIPSS_ISR1_LINK2_POS + i, 1) ?
+			   "ENABLED" :
+			   "DISABLED");
+	}
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+
+	return ret;
+}
+
+/* Calling from Interrupt Context, so no lock required. */
+int gswss_get_int_stat(void *pdev, u32 mod)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	int ret = 0;
+
+	switch (mod) {
+	case XGMAC:
+		ret = GSWSS_RGRD(pdata, GSWIPSS_ISR0);
+		break;
+
+	case LINK:
+		ret = GSWSS_RGRD(pdata, GSWIPSS_ISR1);
+		break;
+
+	default:
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+
+int gswss_set_nco(void *pdev, u32 val, u32 nco_idx)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 nco_lsb, nco_msb;
+	u32 lsb_off, msb_off;
+	int ret = 0;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+
+	if (nco_idx) {
+		lsb_off = (NCO1_LSB + ((nco_idx - 1) * 0x8));
+		msb_off = lsb_off + 4;
+	} else {
+		lsb_off = NCO_LSB;
+		msb_off = lsb_off + 4;
+	}
+
+	nco_lsb = GSWSS_RGRD(pdata, lsb_off);
+	nco_msb = GSWSS_RGRD(pdata, msb_off);
+
+	nco_lsb = (val & 0xFFFF);
+	nco_msb = ((val & 0xFFFF0000) >> 16);
+
+	mac_printf("GSWSS: NCO_LSB Configured to %x\n", nco_lsb);
+	mac_printf("GSWSS: NCO_MSB Configured to %x\n", nco_msb);
+
+	GSWSS_RGWR(pdata, lsb_off, nco_lsb);
+	GSWSS_RGWR(pdata, msb_off, nco_msb);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+
+	return ret;
+}
+
+u32 gswss_get_nco(void *pdev, u32 nco_idx)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 nco_lsb, nco_msb, nco;
+	u32 lsb_off, msb_off;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+
+	if (nco_idx) {
+		lsb_off = (NCO1_LSB + ((nco_idx - 1) * 0x8));
+		msb_off = lsb_off + 4;
+	} else {
+		lsb_off = NCO_LSB;
+		msb_off = lsb_off + 4;
+	}
+
+	nco_lsb = GSWSS_RGRD(pdata, lsb_off);
+	nco_msb = GSWSS_RGRD(pdata, msb_off);
+
+	mac_printf("GSWSS: NCO_LSB Got is %x\n", nco_lsb);
+	mac_printf("GSWSS: NCO_MSB Got is %x\n", nco_msb);
+
+	nco = ((nco_msb << 16) | nco_lsb);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+
+	return nco;
+}
+
+void gswss_init_fn_ptrs(struct adap_ops *adap_ops)
+{
+	adap_ops->ss_hwreset = gswss_switch_ss_reset;
+
+	adap_ops->ss_set_cfg0_1588 = gswss_cfg0_1588;
+	adap_ops->ss_get_cfg0_1588 = gswss_get_cfg0_1588;
+
+	adap_ops->ss_set_clkmode = gswss_set_clkmode;
+	adap_ops->ss_get_clkmode = gswss_get_clkmode;
+
+	adap_ops->ss_core_en = gswss_set_corese;
+	adap_ops->ss_get_core_en = gswss_get_corese;
+
+	adap_ops->ss_set_macsec_mac = gswss_set_macsec_to_mac;
+	adap_ops->ss_get_macsec_mac = gswss_get_macsec_to_mac;
+
+	adap_ops->ss_reset_macsec = gswss_macsec_reset;
+
+	adap_ops->ss_set_nco = gswss_set_nco;
+	adap_ops->ss_get_nco = gswss_get_nco;
+
+	adap_ops->ss_set_inten = gswss_set_interrupt;
+	adap_ops->ss_get_intstat = gswss_get_int_stat;
+	adap_ops->ss_cli = gswss_main;
+	adap_ops->ss_rg_rd = gswss_rd_reg;
+	adap_ops->ss_rg_wr = gswss_wr_reg;
+}
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.h b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.h
new file mode 100644
index 000000000000..fc25d8554929
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.h
@@ -0,0 +1,273 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#ifndef _GSWSS_API_H
+#define _GSWSS_API_H
+
+#include <xgmac_common.h>
+#ifdef __KERNEL__
+#include <net/switch_api/adap_ops.h>
+#else
+#include <adap_ops.h>
+#endif
+
+#if defined(PC_UTILITY) && PC_UTILITY
+#define GSWIP_SS_TOP_BASE		0x40000
+#else
+#define GSWIP_SS_TOP_BASE		0xb8440000
+#endif
+#define GSWIP_CFG			0x0000
+#define MACSEC_EN			0x0008
+#define GSWIPSS_IER0			0x0010
+#define GSWIPSS_ISR0			0x0014
+#define GSWIPSS_IER1			0x0018
+#define GSWIPSS_ISR1			0x001C
+#define NCO_LSB				0x0040
+#define NCO_MSB				0x0044
+#define CFG0_1588			0x0050
+#define CFG1_1588			0x0054
+#define NCO1_LSB			0x0060
+#define NCO1_MSB			0x0064
+#define NCO2_LSB			0x0068
+#define NCO2_MSB			0x006C
+#define NCO3_LSB			0x0070
+#define NCO3_MSB			0x0074
+#define NCO4_LSB			0x0078
+#define NCO4_MSB			0x007C
+
+#define GSWIP_CFG_CORE_SE_POS		15
+#define GSWIP_CFG_CORE_SE_WIDTH		1
+#define GSWIP_CFG_CLK_MD_POS		2
+#define GSWIP_CFG_CLK_MD_WIDTH		2
+#define GSWIP_CFG_SS_HWRES_POS		1
+#define GSWIP_CFG_SS_HWRES_WIDTH	1
+
+#define MACSEC_EN_SEL_POS		0
+#define MACSEC_EN_SEL_WIDTH		4
+#define MACSEC_EN_RES_POS		15
+#define MACSEC_EN_RES_WIDTH		1
+
+#define GSWIPSS_IER0_XGMAC2_POS		2
+#define GSWIPSS_IER0_XGMAC2_WIDTH	1
+#define GSWIPSS_IER0_XGMAC3_POS		3
+#define GSWIPSS_IER0_XGMAC3_WIDTH	1
+#define GSWIPSS_IER0_XGMAC4_POS		4
+#define GSWIPSS_IER0_XGMAC4_WIDTH	1
+#define GSWIPSS_IER0_XGMAC5_POS		5
+#define GSWIPSS_IER0_XGMAC5_WIDTH	1
+#define GSWIPSS_IER0_XGMAC6_POS		6
+#define GSWIPSS_IER0_XGMAC6_WIDTH	1
+#define GSWIPSS_IER0_XGMAC7_POS		7
+#define GSWIPSS_IER0_XGMAC7_WIDTH	1
+#define GSWIPSS_IER0_XGMAC8_POS		8
+#define GSWIPSS_IER0_XGMAC8_WIDTH	1
+#define GSWIPSS_IER0_XGMAC9_POS		9
+#define GSWIPSS_IER0_XGMAC9_WIDTH	1
+#define GSWIPSS_IER0_XGMAC10_POS	10
+#define GSWIPSS_IER0_XGMAC10_WIDTH	1
+#define GSWIPSS_IER0_XGMAC11_POS	11
+#define GSWIPSS_IER0_XGMAC11_WIDTH	1
+
+
+#define GSWIPSS_ISR0_XGMAC2_POS		2
+#define GSWIPSS_ISR0_XGMAC2_WIDTH	1
+#define GSWIPSS_ISR0_XGMAC3_POS		3
+#define GSWIPSS_ISR0_XGMAC3_WIDTH	1
+#define GSWIPSS_ISR0_XGMAC4_POS		4
+#define GSWIPSS_ISR0_XGMAC4_WIDTH	1
+#define GSWIPSS_ISR0_XGMAC5_POS		5
+#define GSWIPSS_ISR0_XGMAC5_WIDTH	1
+#define GSWIPSS_ISR0_XGMAC6_POS		6
+#define GSWIPSS_ISR0_XGMAC6_WIDTH	1
+#define GSWIPSS_ISR0_XGMAC7_POS		7
+#define GSWIPSS_ISR0_XGMAC7_WIDTH	1
+#define GSWIPSS_ISR0_XGMAC8_POS		8
+#define GSWIPSS_ISR0_XGMAC8_WIDTH	1
+#define GSWIPSS_ISR0_XGMAC9_POS		9
+#define GSWIPSS_ISR0_XGMAC9_WIDTH	1
+#define GSWIPSS_ISR0_XGMAC10_POS	10
+#define GSWIPSS_ISR0_XGMAC10_WIDTH	1
+#define GSWIPSS_ISR0_XGMAC11_POS	11
+#define GSWIPSS_ISR0_XGMAC11_WIDTH	1
+
+
+
+#define GSWIPSS_IER1_LINK2_POS		2
+#define GSWIPSS_IER1_LINK2_WIDTH	1
+#define GSWIPSS_IER1_LINK3_POS		3
+#define GSWIPSS_IER1_LINK3_WIDTH	1
+#define GSWIPSS_IER1_LINK4_POS		4
+#define GSWIPSS_IER1_LINK4_WIDTH	1
+#define GSWIPSS_IER1_LINK5_POS		5
+#define GSWIPSS_IER1_LINK5_WIDTH	1
+#define GSWIPSS_IER1_LINK6_POS		6
+#define GSWIPSS_IER1_LINK6_WIDTH	1
+#define GSWIPSS_IER1_LINK7_POS		7
+#define GSWIPSS_IER1_LINK7_WIDTH	1
+#define GSWIPSS_IER1_LINK8_POS		8
+#define GSWIPSS_IER1_LINK8_WIDTH	1
+#define GSWIPSS_IER1_LINK9_POS		9
+#define GSWIPSS_IER1_LINK9_WIDTH	1
+#define GSWIPSS_IER1_LINK10_POS		10
+#define GSWIPSS_IER1_LINK10_WIDTH	1
+#define GSWIPSS_IER1_LINK11_POS		11
+#define GSWIPSS_IER1_LINK11_WIDTH	1
+
+
+#define GSWIPSS_ISR1_LINK2_POS		2
+#define GSWIPSS_ISR1_LINK2_WIDTH	1
+#define GSWIPSS_ISR1_LINK3_POS		3
+#define GSWIPSS_ISR1_LINK3_WIDTH	1
+#define GSWIPSS_ISR1_LINK4_POS		4
+#define GSWIPSS_ISR1_LINK4_WIDTH	1
+#define GSWIPSS_ISR1_LINK5_POS		5
+#define GSWIPSS_ISR1_LINK5_WIDTH	1
+#define GSWIPSS_ISR1_LINK6_POS		6
+#define GSWIPSS_ISR1_LINK6_WIDTH	1
+#define GSWIPSS_ISR1_LINK7_POS		7
+#define GSWIPSS_ISR1_LINK7_WIDTH	1
+#define GSWIPSS_ISR1_LINK8_POS		8
+#define GSWIPSS_ISR1_LINK8_WIDTH	1
+#define GSWIPSS_ISR1_LINK9_POS		9
+#define GSWIPSS_ISR1_LINK9_WIDTH	1
+#define GSWIPSS_ISR1_LINK10_POS		10
+#define GSWIPSS_ISR1_LINK10_WIDTH	1
+#define GSWIPSS_ISR1_LINK11_POS		11
+#define GSWIPSS_ISR1_LINK11_WIDTH	1
+
+
+#define CFG0_1588_REFTIME_POS		0
+#define CFG0_1588_REFTIME_WIDTH		3
+#define CFG0_1588_DIGTIME_POS		4
+#define CFG0_1588_DIGTIME_WIDTH		3
+#define CFG0_1588_BINTIME_POS		8
+#define CFG0_1588_BINTIME_WIDTH		3
+#define CFG0_1588_PPSSEL_POS		12
+#define CFG0_1588_PPSSEL_WIDTH		3
+
+#define CFG1_1588_SWTRIG_POS		7
+#define CFG1_1588_SWTRIG_WIDTH		1
+#define CFG1_1588_TRIG0SEL_POS		8
+#define CFG1_1588_TRIG0SEL_WIDTH	4
+#define CFG1_1588_TRIG1SEL_POS		12
+#define CFG1_1588_TRIG1SEL_WIDTH	4
+
+
+#define FREEZE				0
+#define UNFREEZE			1
+
+enum {
+	XGMAC = 0,
+	LMAC,
+	ADAP,
+	MACSEC,
+	SWSS,
+	LINK
+};
+
+enum {
+	XGMAC2 = 0,
+	XGMAC3,
+	XGMAC4,
+};
+
+struct adap_prv_data;
+
+struct adap_prv_data {
+	u32 flags;
+	u32 ss_addr_base;
+#ifdef __KERNEL__
+	spinlock_t adap_lock;
+#endif
+	u32 core_en_cnt;
+	struct adap_ops ops;
+};
+
+static inline struct adap_prv_data *GET_ADAP_PDATA(void *pdev)
+{
+	struct adap_prv_data *pdata;
+
+	struct adap_ops *adap_ops = (struct adap_ops *)pdev;
+	pdata = container_of(adap_ops, struct adap_prv_data, ops);
+
+	return pdata;
+}
+
+static inline u32 GSWSS_RGRD(struct adap_prv_data *pdata, u32 reg)
+{
+	u32 reg_val;
+#if defined(PC_UTILITY) || defined(CHIPTEST)
+	u32 reg_addr = pdata->ss_addr_base + reg;
+#else
+	volatile void *reg_addr = (volatile void *)pdata->ss_addr_base + reg;
+#endif
+
+#if defined(CHIPTEST) && CHIPTEST
+	reg_val = REG32(reg_addr);
+#endif
+#if defined(PC_UTILITY) && PC_UTILITY
+	pcuart_reg_rd(reg_addr, &reg_val);
+#endif
+#ifdef __KERNEL__
+	reg_val = ltq_r32(reg_addr);
+#endif
+	return reg_val;
+}
+
+static inline void GSWSS_RGWR(struct adap_prv_data *pdata, u32 reg, u32 val)
+{
+#if defined(PC_UTILITY) || defined(CHIPTEST)
+	u32 reg_addr = pdata->ss_addr_base + reg;
+#else
+	volatile void *reg_addr = (volatile void *)pdata->ss_addr_base + reg;
+#endif
+
+#if defined(CHIPTEST) && CHIPTEST
+	REG32(reg_addr) = val;
+#endif
+#if defined(PC_UTILITY) && PC_UTILITY
+	pcuart_reg_wr(reg_addr, val);
+#endif
+#ifdef __KERNEL__
+	ltq_w32(val, reg_addr);
+#endif
+}
+
+extern struct adap_prv_data adap_priv_data;
+
+int gswss_mac_reset(void *pdev, u32 mod, u32 idx, u32 reset);
+int gswss_set_interrupt(void *pdev, u32 mod, u32 idx, u32 enable);
+int gswss_macsec_reset(void *pdev, u32 reset);
+int gswss_set_nco(void *pdev, u32 val, u32 nco_idx);
+int gswss_set_corese(void *pdev, u32 enable);
+int gswss_switch_ss_reset(void *pdev);
+int gswss_set_clkmode(void *pdev, u32 clk_mode);
+int gswss_cfg0_1588(void *pdev, u32 ref_time, u32 dig_time, u32 bin_time,
+		    u32 pps_sel);
+int gswss_set_macsec_to_mac(void *pdev, u32 mac_idx, u32 enable);
+
+int gswss_get_int_stat(void *pdev, u32 mod);
+
+int gswss_get_int_en_sts(void *pdev);
+void gswss_test_all_reg(void *pdev);
+void gswss_check_reg(void *pdev, u32 reg, char *name, int idx,
+		     u16 set_val, u16 clr_val);
+u32 gswss_get_nco(void *pdev, u32 nco_idx);
+int gswss_get_cfg0_1588(void *pdev, u32 *ref_time, u32 *dig_time,
+			u32 *bin_time, u32 *pps_sel);
+u32 gswss_get_clkmode(void *pdev);
+int gswss_get_macsec_to_mac(void *pdev);
+int gswss_dbg_macsec_to_mac(void *pdev);
+u32 gswss_get_corese(void *pdev);
+int gswss_get_switch_ss_reset(void *pdev);
+int gswss_get_macsec_reset(void *pdev);
+
+void gswss_init_fn_ptrs(struct adap_ops *adap_ops);
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.c b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.c
new file mode 100644
index 000000000000..7622366737a9
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.c
@@ -0,0 +1,1832 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#include <gswss_mac_api.h>
+
+struct adap_prv_data adap_priv_data = {
+	.flags = 0,
+	.ss_addr_base = GSWIP_SS_TOP_BASE,
+};
+
+struct _gswss_cfg {
+	char cmdname[256];
+	u8 args;
+	char help[1024];
+};
+
+struct _gswss_cfg gswss_mac_cfg[] = {
+	{
+		"reset",
+		3,
+		"<0/1/2: MacIdx> "
+		"<0/1/2/3/4 XGMAC/LMAC/ADAP> <1/0: Reset/No reset>"
+	},
+	{
+		"macen",
+		2,
+		"<0/1/2: MacIdx> "
+		"<1/0: Enable/Disable>"
+	},
+	{
+		"macif",
+		4,
+		"<0/1/2: MacIdx> <0/1/2: 1G/FE/2.5G> "
+		"<0/1/2/3 MII/GMII/XGMAC_GMII/XGMAC_XGMII>"
+	},
+	{
+		"macop",
+		4,
+		"<0/1/2: MacIdx> <0/1 RX/TX> "
+		"<0/1/2 FCS/SPTAG/TIME> <0/1/2/3 Mode0/Mode1/Mode2/Mode3>"
+	},
+	{
+		"mtu",
+		2,
+		"<0/1/2: MacIdx> "
+		"<mtu size>"
+	},
+	{
+		"txtstamp_fifo",
+		8,
+		"<0/1/2: MacIdx> "
+		"<ttse ostc ost_avail cic sec nsec rec_id>"
+	},
+	{
+		"w",
+		2,
+		"<reg_off> <reg_val>"
+	},
+	{
+		"r",
+		1,
+		"<reg_off>"
+	},
+};
+
+struct _gswss_cfg gswss_adap_cfg[] = {
+	{
+		"int_en",
+		3,
+		"<0/1/2 MacIdx> "
+		"<0/1/2/3 XGMAC/LMAC/ADAP/MACSEC> <1/0: Enable/Disable>"
+	},
+	{
+		"macsec",
+		2,
+		"<0/1/2 MacIdx> "
+		"<1/0: Enable/Disable>"
+	},
+	{
+		"cfg_1588",
+		4,
+		"<ref_time "
+		"dig_time bin_time pps_sel>"
+	},
+	{
+		"clk_md",
+		1,
+		"<0/1/2/3 666/450/Auto/Auto Mhz >"
+	},
+	{
+		"nco",
+		2,
+		"<val idx>"
+	},
+	{
+		"macsec_rst",
+		1,
+		"<1/0: Reset/No-Reset>"
+	},
+	{
+		"ss_rst",
+		0,
+		"<Reset Switch Core>"
+	},
+	{
+		"corese",
+		1,
+		"<1/0: enable/disable>"
+	},
+};
+
+void gswss_help(void)
+{
+	int i = 0;
+	int num_of_elem = (sizeof(gswss_mac_cfg) / sizeof(struct _gswss_cfg));
+
+	mac_printf("\n----GSWSS MAC Commands----\n\n");
+
+	for (i = 0; i < num_of_elem; i++) {
+		if (gswss_mac_cfg[i].help) {
+
+#if defined(CHIPTEST) && CHIPTEST
+			mac_printf("gsw gswss %15s \t %s\n",
+				   gswss_mac_cfg[i].cmdname,
+				   gswss_mac_cfg[i].help);
+#else
+			mac_printf("switch_cli gswss %15s \t %s\n",
+				   gswss_mac_cfg[i].cmdname,
+				   gswss_mac_cfg[i].help);
+#endif
+
+		}
+	}
+
+	mac_printf("\n");
+
+	for (i = 0; i < num_of_elem; i++) {
+
+		if (gswss_mac_cfg[i].cmdname) {
+
+#if defined(CHIPTEST) && CHIPTEST
+
+			if (!strcmp(gswss_mac_cfg[i].cmdname, "txtstamp_fifo")) {
+				mac_printf("gsw gswss get %11s \t "
+					   "<0/1/2: MacIdx> <rec_id>\n",
+					   gswss_mac_cfg[i].cmdname);
+				continue;
+			}
+
+			if (!strcmp(gswss_mac_cfg[i].cmdname, "w") ||
+			    (!strcmp(gswss_mac_cfg[i].cmdname, "r")))
+				continue;
+
+			mac_printf("gsw gswss get %11s \t <0/1/2: MacIdx> \n",
+				   gswss_mac_cfg[i].cmdname);
+#else
+
+			if (!strcmp(gswss_mac_cfg[i].cmdname, "txtstamp_fifo")) {
+				mac_printf("switch_cli gswss get %11s \t "
+					   "<0/1/2: MacIdx> <rec_id>\n",
+					   gswss_mac_cfg[i].cmdname);
+				continue;
+			}
+
+			if (!strcmp(gswss_mac_cfg[i].cmdname, "w") ||
+			    (!strcmp(gswss_mac_cfg[i].cmdname, "r")))
+				continue;
+
+			mac_printf("switch_cli gswss get %11s \t "
+				   "<0/1/2: MacIdx> \n",
+				   gswss_mac_cfg[i].cmdname);
+#endif
+
+		}
+	}
+
+	num_of_elem = (sizeof(gswss_adap_cfg) / sizeof(struct _gswss_cfg));
+
+	mac_printf("\n----GSWSS Adaption Commands----\n\n");
+
+	for (i = 0; i < num_of_elem; i++) {
+		if (gswss_adap_cfg[i].help) {
+
+#if defined(CHIPTEST) && CHIPTEST
+			mac_printf("gsw gswss %15s \t %s\n",
+				   gswss_adap_cfg[i].cmdname,
+				   gswss_adap_cfg[i].help);
+#else
+			mac_printf("switch_cli gswss %15s \t %s\n",
+				   gswss_adap_cfg[i].cmdname,
+				   gswss_adap_cfg[i].help);
+#endif
+		}
+	}
+
+	mac_printf("\n");
+
+	for (i = 0; i < num_of_elem; i++) {
+		if (gswss_adap_cfg[i].cmdname) {
+
+#if defined(CHIPTEST) && CHIPTEST
+			mac_printf("gsw gswss get %11s \t \n",
+				   gswss_adap_cfg[i].cmdname);
+#else
+			mac_printf("switch_cli gswss get %11s \t \n",
+				   gswss_adap_cfg[i].cmdname);
+#endif
+		}
+	}
+
+	return;
+}
+
+int gswss_mac_check_args(int argc, char *argv)
+{
+	int i = 0;
+	int num_of_elem = (sizeof(gswss_mac_cfg) / sizeof(struct _gswss_cfg));
+
+	for (i = 0; i < num_of_elem; i++) {
+		if (!strcmp(argv, gswss_mac_cfg[i].cmdname)) {
+
+			if (argc != (gswss_mac_cfg[i].args + 3)) {
+				mac_printf("\n--WRONG Command--\n");
+				mac_printf("switch_cli gswss %s %s\n",
+					   gswss_mac_cfg[i].cmdname,
+					   gswss_mac_cfg[i].help);
+				mac_printf("switch_cli gswss get %s "
+					   "<0/1/2: MacIdx> \n",
+					   gswss_mac_cfg[i].cmdname);
+				return -1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+struct mac_ops *gswss_get_mac_ops(char *cmd, char *argv, u32 *start_arg)
+{
+	u32 idx, i = 0;
+	int num_of_elem = (sizeof(gswss_mac_cfg) / sizeof(struct _gswss_cfg));
+	struct mac_ops *ops = NULL;
+	u32 max_mac = 0;
+
+	for (i = 0; i < num_of_elem; i++) {
+		if (!strcmp(cmd, gswss_mac_cfg[i].cmdname)) {
+			break;
+		}
+	}
+
+	max_mac = gsw_get_mac_subifcnt(0);
+
+	idx = mac_nstrtoul(argv,
+			   mac_nstrlen(argv),
+			   start_arg);
+
+	if ((idx < 0) || (idx > max_mac)) {
+		gswss_help();
+		return NULL;
+	}
+
+	ops = gsw_get_mac_ops(0, idx);
+	return ops;
+}
+
+int gswss_adap_check_args(int argc, char *argv)
+{
+	int i = 0;
+	int num_of_elem = (sizeof(gswss_adap_cfg) / sizeof(struct _gswss_cfg));
+
+	for (i = 0; i < num_of_elem; i++) {
+		if (!strcmp(argv, gswss_adap_cfg[i].cmdname)) {
+
+			if (argc != (gswss_adap_cfg[i].args + 3)) {
+				mac_printf("\n--WRONG Command--\n");
+				mac_printf("switch_cli %s\n",
+					   gswss_adap_cfg[i].help);
+				mac_printf("switch_cli gswss get %s\n",
+					   gswss_adap_cfg[i].cmdname);
+				return -1;
+			}
+
+
+		}
+	}
+
+	return 0;
+}
+
+void gswss_wr_reg(void *pdev, u32 reg_off, u32 reg_val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	mac_printf("\tREG offset: 0x%04x\n\tData: %08X\n", reg_off,
+		   reg_val);
+
+	GSWSS_MAC_RGWR(pdata, reg_off, reg_val);
+}
+
+u32 gswss_rd_reg(void *pdev, u32 reg_off)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	pdata->reg_val = GSWSS_MAC_RGRD(pdata, reg_off);
+
+	mac_printf("\tREG offset: 0x%04x\n\tData: %08X\n", reg_off,
+		   pdata->reg_val);
+
+	return pdata->reg_val;
+}
+
+int gswss_main(u32 argc, u8 *argv[])
+{
+	u32 start_arg = 0;
+	u32 idx;
+	u32 mod, val;
+	u32 mac_idx;
+	u32 speed;
+	u32 dir, oper;
+	u32 mtu;
+	u32 sec, nsec, rec_id;
+	u32 ttse, ostc, ost_avail, cic;
+
+	u32 enable;
+	u32 ref_time, dig_time, bin_time, pps_sel;
+	struct mac_ops *ops = NULL;
+	struct adap_ops *adap_ops = gsw_get_adap_ops(0);
+	u32 reg_off, reg_val;
+
+
+	start_arg++;
+	start_arg++;
+
+
+	if (argc <= 2) {
+		gswss_help();
+		goto end;
+	}
+
+	if (!strcmp(argv[start_arg], "-help")) {
+		gswss_help();
+		goto end;
+	}
+
+	if (!strcmp(argv[start_arg], "w")) {
+		start_arg++;
+
+		ops = gsw_get_mac_ops(0, 0);
+
+		reg_off = mac_nstrtoul(argv[start_arg],
+				       mac_nstrlen(argv[start_arg]),
+				       &start_arg);
+		reg_val = mac_nstrtoul(argv[start_arg],
+				       mac_nstrlen(argv[start_arg]),
+				       &start_arg);
+		gswss_wr_reg(ops, reg_off, reg_val);
+
+		goto end;
+	}
+
+	if (!strcmp(argv[start_arg], "r")) {
+		start_arg++;
+
+		ops = gsw_get_mac_ops(0, 0);
+
+		reg_off = mac_nstrtoul(argv[start_arg],
+				       mac_nstrlen(argv[start_arg]),
+				       &start_arg);
+
+		gswss_rd_reg(ops, reg_off);
+
+		goto end;
+	}
+
+	if (!strcmp(argv[start_arg], "get")) {
+		start_arg++;
+
+		if (!strcmp(argv[start_arg], "reset")) {
+			start_arg++;
+
+			ops = gswss_get_mac_ops(argv[start_arg - 1],
+						argv[start_arg],
+						&start_arg);
+
+			if (!ops)
+				return -1;
+
+			gswss_get_mac_reset(ops);
+		} else if (!strcmp(argv[start_arg], "macen")) {
+			start_arg++;
+			ops = gswss_get_mac_ops(argv[start_arg - 1],
+						argv[start_arg],
+						&start_arg);
+
+			if (!ops)
+				return -1;
+
+			gswss_get_mac_en(ops);
+		} else if (!strcmp(argv[start_arg], "int_en")) {
+			start_arg++;
+			gswss_get_int_en_sts(adap_ops);
+		} else if (!strcmp(argv[start_arg], "macif")) {
+			start_arg++;
+			ops = gswss_get_mac_ops(argv[start_arg - 1],
+						argv[start_arg],
+						&start_arg);
+
+			if (!ops)
+				return -1;
+
+			gswss_get_macif(ops);
+		} else if (!strcmp(argv[start_arg], "macop")) {
+			start_arg++;
+			ops = gswss_get_mac_ops(argv[start_arg - 1],
+						argv[start_arg],
+						&start_arg);
+
+			if (!ops)
+				return -1;
+
+			gswss_get_macop(ops);
+		} else if (!strcmp(argv[start_arg], "mtu")) {
+			start_arg++;
+			ops = gswss_get_mac_ops(argv[start_arg - 1],
+						argv[start_arg],
+						&start_arg);
+
+			if (!ops)
+				return -1;
+
+			gswss_get_mtu(ops);
+		} else if (!strcmp(argv[start_arg], "txtstamp_fifo")) {
+			start_arg++;
+
+#ifdef __KERNEL__
+
+			if (argc != 6) {
+				mac_printf("switch_cli gswss get txtstamp_fifo"
+					   "<0/1/2: MacIdx> rec_id\n");
+				return -1;
+			}
+
+#endif
+			ops = gswss_get_mac_ops(argv[start_arg - 1],
+						argv[start_arg],
+						&start_arg);
+
+			if (!ops)
+				return -1;
+
+			rec_id = mac_nstrtoul(argv[start_arg],
+					      mac_nstrlen(argv[start_arg]),
+					      &start_arg);
+
+			gswss_get_txtstamp_fifo(ops, rec_id);
+		} else if (!strcmp(argv[start_arg], "phymode")) {
+			start_arg++;
+			ops = gswss_get_mac_ops(argv[start_arg - 1],
+						argv[start_arg],
+						&start_arg);
+
+			if (!ops)
+				return -1;
+
+			gswss_get_phy2mode(ops);
+		} else if (!strcmp(argv[start_arg], "macsec")) {
+			gswss_dbg_macsec_to_mac(adap_ops);
+		} else if (!strcmp(argv[start_arg], "cfg_1588")) {
+			gswss_get_cfg0_1588(adap_ops,
+					    &ref_time,
+					    &dig_time,
+					    &bin_time,
+					    &pps_sel);
+		} else if (!strcmp(argv[start_arg], "clk_md")) {
+			gswss_get_clkmode(adap_ops);
+		} else if (!strcmp(argv[start_arg], "nco")) {
+			gswss_get_nco(adap_ops, 0);
+		} else if (!strcmp(argv[start_arg], "macsec_rst")) {
+			gswss_get_macsec_reset(adap_ops);
+		} else if (!strcmp(argv[start_arg], "ss_rst")) {
+			gswss_get_switch_ss_reset(adap_ops);
+		} else if (!strcmp(argv[start_arg], "corese")) {
+			enable = gswss_get_corese(adap_ops);
+			mac_printf("Switch Core: %s\n", enable ? "ENABLED" :
+				   "DISABLED");
+		} else {
+			gswss_help();
+		}
+	} else {
+		if (gswss_mac_check_args(argc, argv[start_arg]) < 0)
+			return -1;
+
+		if (gswss_adap_check_args(argc, argv[start_arg]) < 0)
+			return -1;
+
+		if (!strcmp(argv[start_arg], "reset")) {
+			start_arg++;
+			ops = gswss_get_mac_ops(argv[start_arg - 1],
+						argv[start_arg],
+						&start_arg);
+
+			if (!ops)
+				return -1;
+
+			mod = mac_nstrtoul(argv[start_arg],
+					   mac_nstrlen(argv[start_arg]),
+					   &start_arg);
+			val = mac_nstrtoul(argv[start_arg],
+					   mac_nstrlen(argv[start_arg]),
+					   &start_arg);
+
+			if (mod == XGMAC)
+				gswss_xgmac_reset(ops, val);
+			else if (mod == LMAC)
+				gswss_lmac_reset(ops, val);
+			else if (mod == ADAP)
+				gswss_adap_reset(ops, val);
+		} else if (!strcmp(argv[start_arg], "macsec_rst")) {
+			start_arg++;
+			val = mac_nstrtoul(argv[start_arg],
+					   mac_nstrlen(argv[start_arg]),
+					   &start_arg);
+			gswss_macsec_reset(adap_ops, val);
+		} else if (!strcmp(argv[start_arg], "ss_rst")) {
+			start_arg++;
+			gswss_switch_ss_reset(adap_ops);
+		} else if (!strcmp(argv[start_arg], "macen")) {
+			start_arg++;
+			ops = gswss_get_mac_ops(argv[start_arg - 1],
+						argv[start_arg],
+						&start_arg);
+
+			if (!ops)
+				return -1;
+
+			val = mac_nstrtoul(argv[start_arg],
+					   mac_nstrlen(argv[start_arg]),
+					   &start_arg);
+			gswss_mac_enable(ops, val);
+		} else if (!strcmp(argv[start_arg], "int_en")) {
+			start_arg++;
+
+			mod = mac_nstrtoul(argv[start_arg],
+					   mac_nstrlen(argv[start_arg]),
+					   &start_arg);
+			idx = mac_nstrtoul(argv[start_arg],
+					   mac_nstrlen(argv[start_arg]),
+					   &start_arg);
+			val = mac_nstrtoul(argv[start_arg],
+					   mac_nstrlen(argv[start_arg]),
+					   &start_arg);
+			gswss_set_interrupt(adap_ops, mod, idx, val);
+
+		} else if (!strcmp(argv[start_arg], "macif")) {
+			start_arg++;
+			ops = gswss_get_mac_ops(argv[start_arg - 1],
+						argv[start_arg],
+						&start_arg);
+
+			if (!ops)
+				return -1;
+
+			speed = mac_nstrtoul(argv[start_arg],
+					     mac_nstrlen(argv[start_arg]),
+					     &start_arg);
+			val = mac_nstrtoul(argv[start_arg],
+					   mac_nstrlen(argv[start_arg]),
+					   &start_arg);
+
+			if (speed == 0)
+				gswss_set_1g_intf(ops, val);
+			else if (speed == 1)
+				gswss_set_fe_intf(ops, val);
+			else if (speed == 2)
+				gswss_set_2G5_intf(ops, val);
+		} else if (!strcmp(argv[start_arg], "macop")) {
+			start_arg++;
+			ops = gswss_get_mac_ops(argv[start_arg - 1],
+						argv[start_arg],
+						&start_arg);
+
+			if (!ops)
+				return -1;
+
+			dir = mac_nstrtoul(argv[start_arg],
+					   mac_nstrlen(argv[start_arg]),
+					   &start_arg);
+			oper = mac_nstrtoul(argv[start_arg],
+					    mac_nstrlen(argv[start_arg]),
+					    &start_arg);
+			val = mac_nstrtoul(argv[start_arg],
+					   mac_nstrlen(argv[start_arg]),
+					   &start_arg);
+
+			if (dir == RX) {
+				if (oper == 0)
+					gswss_set_mac_rxfcs_op(ops, val);
+				else if (oper == 1)
+					gswss_set_mac_rxsptag_op(ops, val);
+				else if (oper == 2)
+					gswss_set_mac_rxtime_op(ops, val);
+			} else if (dir == TX) {
+				if (oper == 0) {
+					if (val == 0 || val == 1)
+						gswss_set_mac_txfcs_ins_op(ops, val);
+					else if (val == 2 || val == 3)
+						gswss_set_mac_txfcs_rm_op(ops, val - 2);
+				} else if (oper == 1) {
+					gswss_set_mac_txsptag_op(ops, val);
+				}
+			}
+		} else if (!strcmp(argv[start_arg], "mtu")) {
+			start_arg++;
+			ops = gswss_get_mac_ops(argv[start_arg - 1],
+						argv[start_arg],
+						&start_arg);
+
+			if (!ops)
+				return -1;
+
+			mtu = mac_nstrtoul(argv[start_arg],
+					   mac_nstrlen(argv[start_arg]),
+					   &start_arg);
+			gswss_set_mtu(ops, mtu);
+		} else if (!strcmp(argv[start_arg], "txtstamp_fifo")) {
+			start_arg++;
+			ops = gswss_get_mac_ops(argv[start_arg - 1],
+						argv[start_arg],
+						&start_arg);
+
+			if (!ops)
+				return -1;
+
+			ttse = mac_nstrtoul(argv[start_arg],
+					    mac_nstrlen(argv[start_arg]),
+					    &start_arg);
+			ostc = mac_nstrtoul(argv[start_arg],
+					    mac_nstrlen(argv[start_arg]),
+					    &start_arg);
+			ost_avail = mac_nstrtoul(argv[start_arg],
+						 mac_nstrlen(argv[start_arg]),
+						 &start_arg);
+			cic = mac_nstrtoul(argv[start_arg],
+					   mac_nstrlen(argv[start_arg]),
+					   &start_arg);
+			sec = mac_nstrtoul(argv[start_arg],
+					   mac_nstrlen(argv[start_arg]),
+					   &start_arg);
+			nsec = mac_nstrtoul(argv[start_arg],
+					    mac_nstrlen(argv[start_arg]),
+					    &start_arg);
+			rec_id = mac_nstrtoul(argv[start_arg],
+					      mac_nstrlen(argv[start_arg]),
+					      &start_arg);
+			gswss_set_txtstamp_fifo(ops, ttse, ostc, ost_avail, cic,
+						sec, nsec, rec_id);
+		} else if (!strcmp(argv[start_arg], "nco")) {
+			start_arg++;
+
+			val = mac_nstrtoul(argv[start_arg],
+					   mac_nstrlen(argv[start_arg]),
+					   &start_arg);
+			idx = mac_nstrtoul(argv[start_arg],
+					   mac_nstrlen(argv[start_arg]),
+					   &start_arg);
+
+			gswss_set_nco(adap_ops, val, idx);
+		} else if (!strcmp(argv[start_arg], "macsec")) {
+			start_arg++;
+
+			mac_idx = mac_nstrtoul(argv[start_arg],
+					       mac_nstrlen(argv[start_arg]),
+					       &start_arg);
+			enable = mac_nstrtoul(argv[start_arg],
+					      mac_nstrlen(argv[start_arg]),
+					      &start_arg);
+
+			gswss_set_macsec_to_mac(adap_ops,
+						mac_idx, enable);
+		} else if (!strcmp(argv[start_arg], "corese")) {
+			start_arg++;
+
+			enable = mac_nstrtoul(argv[start_arg],
+					      mac_nstrlen(argv[start_arg]),
+					      &start_arg);
+
+			gswss_set_corese(adap_ops, enable);
+		} else if (!strcmp(argv[start_arg], "cfg_1588")) {
+			start_arg++;
+
+			ref_time = mac_nstrtoul(argv[start_arg],
+						mac_nstrlen(argv[start_arg]),
+						&start_arg);
+			dig_time = mac_nstrtoul(argv[start_arg],
+						mac_nstrlen(argv[start_arg]),
+						&start_arg);
+			bin_time = mac_nstrtoul(argv[start_arg],
+						mac_nstrlen(argv[start_arg]),
+						&start_arg);
+			pps_sel = mac_nstrtoul(argv[start_arg],
+					       mac_nstrlen(argv[start_arg]),
+					       &start_arg);
+
+			gswss_cfg0_1588(adap_ops,
+					ref_time, dig_time, bin_time, pps_sel);
+		} else if (!strcmp(argv[start_arg], "clk_md")) {
+			start_arg++;
+
+			val = mac_nstrtoul(argv[start_arg],
+					   mac_nstrlen(argv[start_arg]),
+					   &start_arg);
+
+			gswss_set_clkmode(adap_ops, val);
+		} else {
+			gswss_help();
+		}
+	}
+
+end:
+	return 0;
+}
+
+int gswss_xgmac_reset(void *pdev, u32 reset)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_if_cfg;
+
+	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
+
+	MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, XGMAC_RES, reset);
+
+	mac_printf("GSWSS: Resetting XGMAC %d Module\n", pdata->mac_idx);
+
+	GSWSS_MAC_RGWR(pdata, MAC_IF_CFG(pdata->mac_idx), mac_if_cfg);
+
+	return 0;
+}
+
+int gswss_lmac_reset(void *pdev, u32 reset)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_if_cfg;
+
+	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
+
+	MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, LMAC_RES, reset);
+
+	mac_printf("GSWSS: Resetting LMAC %d Module\n", pdata->mac_idx);
+
+	GSWSS_MAC_RGWR(pdata, MAC_IF_CFG(pdata->mac_idx), mac_if_cfg);
+
+	return 0;
+}
+
+int gswss_adap_reset(void *pdev, u32 reset)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_if_cfg;
+
+	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
+
+	MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, ADAP_RES, reset);
+
+	mac_printf("GSWSS: Resetting ADAP %d Module\n", pdata->mac_idx);
+
+	GSWSS_MAC_RGWR(pdata, MAC_IF_CFG(pdata->mac_idx), mac_if_cfg);
+
+	return 0;
+}
+
+int gswss_mac_enable(void *pdev, u32 enable)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_if_cfg;
+
+	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
+
+	MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, MAC_EN, enable);
+
+	mac_printf("GSWSS: MAC %d: %s\n", pdata->mac_idx,
+		   enable ? "ENABLED" : "DISABLED");
+
+	GSWSS_MAC_RGWR(pdata, MAC_IF_CFG(pdata->mac_idx), mac_if_cfg);
+
+	return 0;
+}
+
+int gswss_get_mac_reset(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_if_cfg, reset;
+	int ret = 0, i = 0;
+
+	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
+	reset = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, XGMAC_RES);
+	mac_printf("\tXGMAC %d Reset Bit: %s\n", (i + 2),
+		   reset ? "ENABLED" : "DISABLED");
+	reset = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, LMAC_RES);
+	mac_printf("\tXGMAC %d Reset Bit: %s\n", (i + 2),
+		   reset ? "ENABLED" : "DISABLED");
+	reset = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, ADAP_RES);
+	mac_printf("\tXGMAC %d Reset Bit: %s\n", (i + 2),
+		   reset ? "ENABLED" : "DISABLED");
+
+	return ret;
+}
+
+int gswss_get_mac_en(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_if_cfg, enable;
+	int ret = 0, i = 0;
+
+	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
+	enable = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, MAC_EN);
+	mac_printf("GSWSS: MAC %d: %s\n", i, enable ? "ENABLED" : "DISABLED");
+
+	return ret;
+}
+
+int gswss_set_1g_intf(void *pdev, u32 macif)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_if_cfg;
+	int ret = 0;
+
+	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
+
+	if (macif == LMAC_GMII) {
+		mac_printf("GSWSS: MACIF Set to CFG1G with LMAC_GMII\n");
+		MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, CFG1G, 0);
+	} else if (macif == XGMAC_GMII) {
+		mac_printf("GSWSS: MACIF Set to CFG1G with XGMAC_GMII\n");
+		MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, CFG1G, 1);
+	} else {
+		mac_printf("GSWSS: MACIF Set to 1G Wrong Value\n");
+	}
+
+	GSWSS_MAC_RGWR(pdata, MAC_IF_CFG(pdata->mac_idx), mac_if_cfg);
+
+	return ret;
+}
+
+u32 gswss_get_1g_intf(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_if_cfg, macif;
+
+	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
+
+	macif = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, CFG1G);
+
+	if (macif == 0) {
+		mac_printf("GSWSS: MACIF got for CFG1G is LMAC_GMII\n");
+		macif = LMAC_GMII;
+	} else if (macif == 1) {
+		mac_printf("GSWSS: MACIF got for CFG1G is XGMAC_GMII\n");
+		macif = XGMAC_GMII;
+	} else {
+		mac_printf("GSWSS: MACIF got for CFG1G is Wrong Value\n");
+	}
+
+	return macif;
+}
+
+int gswss_set_fe_intf(void *pdev, u32 macif)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_if_cfg;
+	int ret = 0;
+
+	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
+
+	if (macif == LMAC_MII) {
+		mac_printf("GSWSS: MACIF Set to CFGFE with LMAC_MII\n");
+		MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, CFGFE, 0);
+	} else if (macif == XGMAC_GMII) {
+		mac_printf("GSWSS: MACIF Set to CFGFE with XGMAC_GMII\n");
+		MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, CFGFE, 1);
+	} else {
+		mac_printf("GSWSS: MACIF Set to CFGFE Wrong Value\n");
+	}
+
+	GSWSS_MAC_RGWR(pdata, MAC_IF_CFG(pdata->mac_idx), mac_if_cfg);
+
+	return ret;
+}
+
+u32 gswss_get_fe_intf(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_if_cfg, macif;
+
+	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
+
+	macif = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, CFGFE);
+
+	if (macif == 0) {
+		mac_printf("GSWSS: MACIF got for CFGFE is LMAC_MII\n");
+		macif = LMAC_MII;
+	} else if (macif == 1) {
+		mac_printf("GSWSS: MACIF got for CFGFE is XGMAC_GMII\n");
+		macif = XGMAC_GMII;
+	} else {
+		mac_printf("GSWSS: MACIF got for CFGFE is Wrong Value\n");
+	}
+
+	return macif;
+}
+
+int gswss_set_2G5_intf(void *pdev, u32 macif)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_if_cfg;
+	int ret = 0;
+
+	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
+
+	if (macif == XGMAC_GMII) {
+		mac_printf("GSWSS: MACIF Set to 2.5G with XGMAC_GMII\n");
+		MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, CFG2G5, 0);
+	} else if (macif == XGMAC_XGMII) {
+		mac_printf("GSWSS: MACIF Set to 2.5G with XGMAC_XGMII\n");
+		MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, CFG2G5, 1);
+	} else {
+		mac_printf("GSWSS: MACIF Set to 2.5G Wrong Value\n");
+	}
+
+	GSWSS_MAC_RGWR(pdata, MAC_IF_CFG(pdata->mac_idx), mac_if_cfg);
+
+	return ret;
+}
+
+u32 gswss_get_2G5_intf(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_if_cfg, macif;
+
+	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
+
+	macif = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, CFG2G5);
+
+	if (macif == 0) {
+		mac_printf("GSWSS: MACIF Got for 2.5G with XGMAC_GMII\n");
+		macif = XGMAC_GMII;
+	} else if (macif == 1) {
+		mac_printf("GSWSS: MACIF Got for 2.5G with XGMAC_XGMII\n");
+		macif = XGMAC_XGMII;
+	} else {
+		mac_printf("GSWSS: MACIF Got for 2.5G Wrong Value\n");
+	}
+
+	return macif;
+}
+
+void gswss_get_macif(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_if_cfg, val;
+
+	mac_if_cfg = GSWSS_MAC_RGRD(pdata, MAC_IF_CFG(pdata->mac_idx));
+	mac_printf("GSWSS: MAC%d IF_CFG %d\n", (pdata->mac_idx + 2),
+		   mac_if_cfg);
+	val = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, CFG1G);
+	mac_printf("\t1G:            %s\n",
+		   val ?
+		   "XGMAC GMII interface mode is used" :
+		   "Legacy GMAC GMII interface mode is used");
+	val = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, CFGFE);
+	mac_printf("\tFast Ethernet: %s\n",
+		   val ?
+		   "XGMAC GMII interface mode is used" :
+		   "Legacy GMAC MII interface mode is used");
+	val = MAC_GET_VAL(mac_if_cfg, MAC_IF_CFG, CFG2G5);
+	mac_printf("\t2.5G:          %s\n",
+		   val ?
+		   "XGMAC XGMII interface mode is used" :
+		   "XGMAC GMII interface mode is used");
+}
+
+int gswss_set_mac_txfcs_ins_op(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_op_cfg;
+
+	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, TXFCS_INS) != val) {
+		mac_printf("GSWSS: TX FCS INS operation changing to MODE%d\n",
+			   val);
+		MAC_SET_VAL(mac_op_cfg, MAC_OP_CFG, TXFCS_INS, val);
+		GSWSS_MAC_RGWR(pdata, MAC_OP_CFG(pdata->mac_idx), mac_op_cfg);
+	}
+
+	return 0;
+}
+
+int gswss_set_mac_txfcs_rm_op(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_op_cfg;
+
+	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, TXFCS_RM) != val) {
+		mac_printf("GSWSS: TX FCS RM operation changing to MODE%d\n",
+			   val);
+		MAC_SET_VAL(mac_op_cfg, MAC_OP_CFG, TXFCS_RM, val);
+		GSWSS_MAC_RGWR(pdata, MAC_OP_CFG(pdata->mac_idx), mac_op_cfg);
+	}
+
+	return 0;
+}
+
+int gswss_set_mac_rxfcs_op(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_op_cfg;
+
+	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, RXFCS) != val) {
+		mac_printf("GSWSS: RX FCS operation changing to MODE%d\n",
+			   val);
+		MAC_SET_VAL(mac_op_cfg, MAC_OP_CFG, RXFCS, val);
+		GSWSS_MAC_RGWR(pdata, MAC_OP_CFG(pdata->mac_idx), mac_op_cfg);
+	}
+
+	return 0;
+}
+
+int gswss_set_mac_rxsptag_op(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_op_cfg;
+
+	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, RXSPTAG) != val) {
+		mac_printf("GSWSS: RX SPTAG operation changing to MODE%d\n",
+			   val);
+		MAC_SET_VAL(mac_op_cfg, MAC_OP_CFG, RXSPTAG, val);
+		GSWSS_MAC_RGWR(pdata, MAC_OP_CFG(pdata->mac_idx), mac_op_cfg);
+	}
+
+	return 0;
+}
+
+int gswss_set_mac_txsptag_op(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_op_cfg;
+
+	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, TXSPTAG) != val) {
+		mac_printf("GSWSS: TX SPTAG operation changing to MODE%d\n",
+			   val);
+		MAC_SET_VAL(mac_op_cfg, MAC_OP_CFG, TXSPTAG, val);
+		GSWSS_MAC_RGWR(pdata, MAC_OP_CFG(pdata->mac_idx), mac_op_cfg);
+	}
+
+	return 0;
+}
+
+int gswss_set_mac_rxtime_op(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_op_cfg;
+
+	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, RXTIME) != val) {
+		mac_printf("GSWSS: RX TIME operation changing to MODE%d\n",
+			   val);
+		MAC_SET_VAL(mac_op_cfg, MAC_OP_CFG, RXTIME, val);
+		GSWSS_MAC_RGWR(pdata, MAC_OP_CFG(pdata->mac_idx), mac_op_cfg);
+	}
+
+	return 0;
+}
+
+void gswss_get_macop(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int i = 0;
+	u32 mac_op_cfg, val;
+
+	mac_op_cfg = GSWSS_MAC_RGRD(pdata, MAC_OP_CFG(pdata->mac_idx));
+	mac_printf("GSWSS: MAC%d OP_CFG %d\n", (i + 2), mac_op_cfg);
+	val = MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, TXFCS_INS);
+	mac_printf("TX direction FCS\n");
+
+	if (val == MODE0)
+		mac_printf("\tPacket does not have FCS and FCS "
+			   "is not inserted\n");
+	else if (val == MODE1)
+		mac_printf("\tPacket does not have FCS and FCS "
+			   "is inserted\n");
+	else if (val == MODE2)
+		mac_printf("\tPacket has FCS and FCS is not inserted\n");
+	else if (val == MODE3)
+		mac_printf("\tReserved\n");
+
+	val = MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, RXFCS);
+	mac_printf("RX direction FCS\n");
+
+	if (val == MODE0)
+		mac_printf("\tPacket does not have FCS and FCS "
+			   "is not removed\n");
+	else if (val == MODE1)
+		mac_printf("\tReserved\n");
+	else if (val == MODE2)
+		mac_printf("\tPacket has FCS and FCS is not removed\n");
+	else if (val == MODE3)
+		mac_printf("\tPacket has FCS and FCS is removed\n");
+
+	val = MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, TXSPTAG);
+	mac_printf("TX Special Tag\n");
+
+	if (val == MODE0)
+		mac_printf("\tPacket does not have Special Tag and "
+			   "Special Tag is not removed\n");
+	else if (val == MODE1)
+		mac_printf("\tPacket has Special Tag and "
+			   "Special Tag is replaced\n");
+	else if (val == MODE2)
+		mac_printf("\tPacket has Special Tag and "
+			   "Special Tag is not removed\n");
+	else if (val == MODE3)
+		mac_printf("\tPacket has Special Tag and "
+			   "Special Tag is removed\n");
+
+	val = MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, RXSPTAG);
+	mac_printf("RX Special Tag\n");
+
+	if (val == MODE0)
+		mac_printf("\tPacket does not have Special Tag and "
+			   "Special Tag is not inserted\n");
+	else if (val == MODE1)
+		mac_printf("\tPacket does not have Special Tag and "
+			   "Special Tag is inserted\n");
+	else if (val == MODE2)
+		mac_printf("\tPacket has Special Tag and "
+			   "Special Tag is not inserted\n");
+	else if (val == MODE3)
+		mac_printf("\tReserved\n");
+
+	val = MAC_GET_VAL(mac_op_cfg, MAC_OP_CFG, RXTIME);
+	mac_printf("RX Direction Timestamp\n");
+
+	if (val == MODE0)
+		mac_printf("\tPacket does not have time stamp and "
+			   "time stamp is not inserted.\n");
+	else if (val == MODE1)
+		mac_printf("\tPacket doe not have time stamp and "
+			   "time stamp is inserted\n");
+	else if (val == MODE2)
+		mac_printf("\tPacket has time stamp and "
+			   "time stamp is not inserted\n");
+	else if (val == MODE3)
+		mac_printf("\tReserved\n");
+}
+
+int gswss_set_mtu(void *pdev, u32 mtu)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int ret = 0;
+
+	if (GSWSS_MAC_RGRD(pdata, MAC_MTU_CFG(pdata->mac_idx)) != mtu) {
+		mac_printf("GSWSS: MTU set to %d\n", mtu);
+		GSWSS_MAC_RGWR(pdata, MAC_MTU_CFG(pdata->mac_idx), mtu);
+	}
+
+	return ret;
+}
+
+int gswss_get_mtu(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mtu = GSWSS_MAC_RGRD(pdata, MAC_MTU_CFG(pdata->mac_idx));
+
+	mac_printf("GSWSS: MAC%d MTU %d\n", (pdata->mac_idx + 2), mtu);
+
+	return mtu;
+}
+
+int gswss_set_txtstamp_fifo(void *pdev,
+			    u8 ttse, u8 ostc, u8 ost_avail, u8 cic, u32 sec,
+			    u32 nsec, u32 record_id)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int ret = 0;
+	u16 val = 0;
+	u32 mac_txtstamp;
+
+	val = ((ttse << 4) | (ostc << 3) | (ost_avail << 2) | cic);
+	GSWSS_MAC_RGWR(pdata, MAC_TXTS_CIC(pdata->mac_idx), val);
+
+	mac_txtstamp = MAC_TXTS_0(pdata->mac_idx);
+	val = GET_N_BITS(nsec, 0, 16);
+	GSWSS_MAC_RGWR(pdata, mac_txtstamp, val);
+
+	mac_txtstamp = MAC_TXTS_1(pdata->mac_idx);
+	val = GET_N_BITS(nsec, 16, 16);
+	GSWSS_MAC_RGWR(pdata, mac_txtstamp, val);
+
+	mac_txtstamp = MAC_TXTS_2(pdata->mac_idx);
+	val = GET_N_BITS(sec, 0, 16);
+	GSWSS_MAC_RGWR(pdata, mac_txtstamp, val);
+
+	mac_txtstamp = MAC_TXTS_3(pdata->mac_idx);
+	val = GET_N_BITS(sec, 16, 16);
+	GSWSS_MAC_RGWR(pdata, mac_txtstamp, val);
+
+	sec = ((GSWSS_MAC_RGRD(pdata, MAC_TXTS_1(pdata->mac_idx)) << 16) |
+	       GSWSS_MAC_RGRD(pdata, MAC_TXTS_0(pdata->mac_idx)));
+	nsec = ((GSWSS_MAC_RGRD(pdata, MAC_TXTS_3(pdata->mac_idx)) << 16) |
+		GSWSS_MAC_RGRD(pdata, MAC_TXTS_2(pdata->mac_idx)));
+
+	mac_printf("\nMAC%d: TxTstamp Fifo Record ID %d written\n",
+		   (pdata->mac_idx + 2), record_id);
+
+	/* Write the entries into the 64 array record_id */
+	gswss_set_txtstamp_access(pdev, 1, record_id);
+
+	return ret;
+}
+
+void gswss_get_txtstamp_fifo(void *pdev, u32 record_id)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_txtstamp, tstamp_cic;
+	u32 sec, nsec;
+
+	gswss_set_txtstamp_access(pdev, 0, record_id);
+
+	mac_printf("\nMAC%d: TxTstamp Fifo Record ID %d:\n",
+		   (pdata->mac_idx + 2),
+		   record_id);
+
+	mac_txtstamp = GSWSS_MAC_RGRD(pdata, MAC_TXTS_CIC(pdata->mac_idx));
+
+	mac_printf("\tTTSE: \t%s\n",
+		   GET_N_BITS(mac_txtstamp, 4, 1) ? "ENABLED" : "DISABLED");
+	mac_printf("\tOSTC: \t%s\n",
+		   GET_N_BITS(mac_txtstamp, 3, 1) ? "ENABLED" : "DISABLED");
+	mac_printf("\tOSTPA: \t%s\n",
+		   GET_N_BITS(mac_txtstamp, 2, 1) ? "ENABLED" : "DISABLED");
+	tstamp_cic = GET_N_BITS(mac_txtstamp, 0, 2);
+
+	if (tstamp_cic == 0)
+		mac_printf("\tCIC: \t"
+			   "DISABLED\n");
+
+	if (tstamp_cic == 1)
+		mac_printf("\tCIC: \tTime stamp IP Checksum update\n");
+
+	if (tstamp_cic == 2)
+		mac_printf("\tCIC: \tTime stamp IP and "
+			   "Payload Checksum update\n");
+
+	if (tstamp_cic == 3)
+		mac_printf("\tCIC: \tTime stamp IP, Payload checksum and "
+			   "Pseudo header update\n");
+
+	sec = ((GSWSS_MAC_RGRD(pdata, MAC_TXTS_1(pdata->mac_idx)) << 16) |
+	       GSWSS_MAC_RGRD(pdata, MAC_TXTS_0(pdata->mac_idx)));
+	nsec = ((GSWSS_MAC_RGRD(pdata, MAC_TXTS_3(pdata->mac_idx)) << 16) |
+		GSWSS_MAC_RGRD(pdata, MAC_TXTS_2(pdata->mac_idx)));
+
+	mac_printf("\tSEC: \t%d\n", sec);
+	mac_printf("\tNSEC:\t%d\n", nsec);
+}
+
+
+int gswss_set_txtstamp_access(void *pdev, u32 op_mode, u32 addr)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int ret = 0;
+	u16 tstamp_acc = 0;
+	u32 busy_bit;
+
+	MAC_SET_VAL(tstamp_acc, MAC_TXTS_ACC, BAS, 1);
+	MAC_SET_VAL(tstamp_acc, MAC_TXTS_ACC, OPMOD, op_mode);
+	MAC_SET_VAL(tstamp_acc, MAC_TXTS_ACC, ADDR, addr);
+
+	GSWSS_MAC_RGWR(pdata, MAC_TXTS_ACC(pdata->mac_idx), tstamp_acc);
+
+	while (1) {
+		tstamp_acc = GSWSS_MAC_RGRD(pdata,
+					    MAC_TXTS_ACC(pdata->mac_idx));
+		busy_bit = MAC_GET_VAL(tstamp_acc, MAC_TXTS_ACC, BAS);
+
+		if (busy_bit == 0)
+			break;
+	}
+
+	return ret;
+}
+
+
+int gswss_set_duplex_mode(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u16 phy_mode = 0;
+
+	phy_mode = GSWSS_MAC_RGRD(pdata, PHY_MODE(pdata->mac_idx));
+
+	if (MAC_GET_VAL(phy_mode, PHY_MODE, FDUP) != val) {
+		if (val == MAC_AUTO_DPLX)
+			mac_printf("\tGSWSS: Duplex mode set: Auto Mode\n");
+		else if (val == MAC_FULL_DPLX)
+			mac_printf("\tGSWSS: Duplex mode set: Full Duplex\n");
+		else if (val == MAC_RES_DPLX)
+			mac_printf("\tGSWSS: Duplex mode set: Reserved\n");
+		else if (val == MAC_HALF_DPLX)
+			mac_printf("\tGSWSS: Duplex mode set: Half Duplex\n");
+
+		MAC_SET_VAL(phy_mode, PHY_MODE, FDUP, val);
+		GSWSS_MAC_RGWR(pdata, PHY_MODE(pdata->mac_idx), phy_mode);
+	}
+
+	return 0;
+}
+
+int gswss_get_duplex_mode(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u16 phy_mode = 0;
+	u32 val;
+
+	phy_mode = GSWSS_MAC_RGRD(pdata, PHY_MODE(pdata->mac_idx));
+	val = MAC_GET_VAL(phy_mode, PHY_MODE, FDUP);
+
+	if (val == MAC_AUTO_DPLX)
+		mac_printf("\tGSWSS: Duplex mode got: Auto Mode\n");
+	else if (val == MAC_FULL_DPLX)
+		mac_printf("\tGSWSS: Duplex mode got: Full Duplex\n");
+	else if (val == MAC_RES_DPLX)
+		mac_printf("\tGSWSS: Duplex mode got: Reserved\n");
+	else if (val == MAC_HALF_DPLX)
+		mac_printf("\tGSWSS: Duplex mode got: Half Duplex\n");
+
+	return val;
+}
+
+int gswss_set_speed(void *pdev, u8 speed)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u16 phy_mode = 0;
+	u8 speed_msb = 0, speed_lsb = 0;
+
+	phy_mode = GSWSS_MAC_RGRD(pdata, PHY_MODE(pdata->mac_idx));
+
+	speed_msb = GET_N_BITS(speed, 2, 1);
+	speed_lsb = GET_N_BITS(speed, 0, 2);
+
+	if (speed == SPEED_10M)
+		mac_printf("\tGSWSS: SPEED    10 Mbps\n");
+	else if (speed == SPEED_100M)
+		mac_printf("\tGSWSS: SPEED    100 Mbps\n");
+	else if (speed == SPEED_1G)
+		mac_printf("\tGSWSS: SPEED    1 Gbps\n");
+	else if (speed == SPEED_10G)
+		mac_printf("\tGSWSS: SPEED    10 Gbps\n");
+	else if (speed == SPEED_2G5)
+		mac_printf("\tGSWSS: SPEED    2.5 Gbps\n");
+	else if (speed == SPEED_5G)
+		mac_printf("\tGSWSS: SPEED    5 Gbps\n");
+	else if (speed == SPEED_FLEX)
+		mac_printf("\tGSWSS: SPEED    RESERVED\n");
+	else if (speed == SPEED_AUTO)
+		mac_printf("\tGSWSS: SPEED    Auto Mode\n");
+
+	MAC_SET_VAL(phy_mode, PHY_MODE, SPEEDMSB, speed_msb);
+	MAC_SET_VAL(phy_mode, PHY_MODE, SPEEDLSB, speed_lsb);
+
+	GSWSS_MAC_RGWR(pdata, PHY_MODE(pdata->mac_idx), phy_mode);
+
+	return 0;
+}
+
+u8 gswss_get_speed(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u16 phy_mode = 0;
+	u8 speed_msb, speed_lsb, speed;
+
+	phy_mode = GSWSS_MAC_RGRD(pdata, PHY_MODE(pdata->mac_idx));
+
+	speed_msb = MAC_GET_VAL(phy_mode, PHY_MODE, SPEEDMSB);
+	speed_lsb = MAC_GET_VAL(phy_mode, PHY_MODE, SPEEDLSB);
+
+	speed = ((speed_msb << 2) | speed_lsb);
+
+	if (speed == SPEED_10M)
+		mac_printf("\tGSWSS: SPEED Got   10 Mbps\n");
+	else if (speed == SPEED_100M)
+		mac_printf("\tGSWSS: SPEED Got   100 Mbps\n");
+	else if (speed == SPEED_1G)
+		mac_printf("\tGSWSS: SPEED Got   1 Gbps\n");
+	else if (speed == SPEED_10G)
+		mac_printf("\tGSWSS: SPEED Got   10 Gbps\n");
+	else if (speed == SPEED_2G5)
+		mac_printf("\tGSWSS: SPEED Got   2.5 Gbps\n");
+	else if (speed == SPEED_5G)
+		mac_printf("\tGSWSS: SPEED Got   5 Gbps\n");
+	else if (speed == SPEED_FLEX)
+		mac_printf("\tGSWSS: SPEED Got   RESERVED\n");
+	else if (speed == SPEED_AUTO)
+		mac_printf("\tGSWSS: SPEED Got   Auto Mode\n");
+
+	return speed;
+}
+
+int gswss_set_linkstatus(void *pdev, u8 linkst)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u16 phy_mode = 0;
+
+	phy_mode = GSWSS_MAC_RGRD(pdata, PHY_MODE(pdata->mac_idx));
+
+	if (MAC_GET_VAL(phy_mode, PHY_MODE, LINKST) != linkst) {
+		if (linkst == 0)
+			mac_printf("\tGSWSS: LINK STS: Auto Mode\n");
+		else if (linkst == 1)
+			mac_printf("\tGSWSS: LINK STS: Forced UP\n");
+		else if (linkst == 2)
+			mac_printf("\tGSWSS: LINK STS: Forced DOWN\n");
+		else if (linkst == 3)
+			mac_printf("\tGSWSS: LINK STS: Reserved\n");
+
+		MAC_SET_VAL(phy_mode, PHY_MODE, LINKST, linkst);
+		GSWSS_MAC_RGWR(pdata, PHY_MODE(pdata->mac_idx), phy_mode);
+	}
+
+	return 0;
+}
+
+int gswss_get_linkstatus(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u16 phy_mode = 0;
+	int linkst;
+
+	phy_mode = GSWSS_MAC_RGRD(pdata, PHY_MODE(pdata->mac_idx));
+
+	linkst = MAC_GET_VAL(phy_mode, PHY_MODE, LINKST);
+
+	if (linkst == 0)
+		mac_printf("\tGSWSS: LINK STS Got: Auto Mode\n");
+	else if (linkst == 1)
+		mac_printf("\tGSWSS: LINK STS Got: Forced UP\n");
+	else if (linkst == 2)
+		mac_printf("\tGSWSS: LINK STS Got: Forced DOWN\n");
+	else if (linkst == 3)
+		mac_printf("\tGSWSS: LINK STS Got: Reserved\n");
+
+	return linkst;
+}
+
+int gswss_set_flowctrl_tx(void *pdev, u8 flow_ctrl_tx)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int ret = 0;
+	u16 phy_mode = 0;
+
+	phy_mode = GSWSS_MAC_RGRD(pdata, PHY_MODE(pdata->mac_idx));
+
+	if (MAC_GET_VAL(phy_mode, PHY_MODE, FCONTX) != flow_ctrl_tx) {
+		if (flow_ctrl_tx == 0)
+			mac_printf("\tGSWSS: Flow Ctrl Mode TX: Auto Mode\n");
+		else if (flow_ctrl_tx == 1)
+			mac_printf("\tGSWSS: Flow Ctrl Mode TX: ENABLED\n");
+		else if (flow_ctrl_tx == 2)
+			mac_printf("\tGSWSS: Flow Ctrl Mode TX: Reserved\n");
+		else if (flow_ctrl_tx == 3)
+			mac_printf("\tGSWSS: Flow Ctrl Mode TX: DISABLED\n");
+
+		MAC_SET_VAL(phy_mode, PHY_MODE, FCONTX, flow_ctrl_tx);
+		GSWSS_MAC_RGWR(pdata, PHY_MODE(pdata->mac_idx), phy_mode);
+	}
+
+	return ret;
+}
+
+u32 gswss_get_flowctrl_tx(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u16 phy_mode = 0;
+	u32 flow_ctrl_tx;
+
+	phy_mode = GSWSS_MAC_RGRD(pdata, PHY_MODE(pdata->mac_idx));
+
+	flow_ctrl_tx = MAC_GET_VAL(phy_mode, PHY_MODE, FCONTX);
+
+	if (flow_ctrl_tx == 0)
+		mac_printf("\tGSWSS: Flow Ctrl Mode TX: Auto Mode\n");
+	else if (flow_ctrl_tx == 1)
+		mac_printf("\tGSWSS: Flow Ctrl Mode TX: ENABLED\n");
+	else if (flow_ctrl_tx == 2)
+		mac_printf("\tGSWSS: Flow Ctrl Mode TX: Reserved\n");
+	else if (flow_ctrl_tx == 3)
+		mac_printf("\tGSWSS: Flow Ctrl Mode TX: DISABLED\n");
+
+	return flow_ctrl_tx;
+}
+
+int gswss_set_flowctrl_rx(void *pdev, u8 flow_ctrl_rx)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int ret = 0;
+	u16 phy_mode = 0;
+
+	phy_mode = GSWSS_MAC_RGRD(pdata, PHY_MODE(pdata->mac_idx));
+
+	if (MAC_GET_VAL(phy_mode, PHY_MODE, FCONRX) != flow_ctrl_rx) {
+		if (flow_ctrl_rx == 0)
+			mac_printf("\tGSWSS: Flow Ctrl Mode RX: Auto Mode\n");
+		else if (flow_ctrl_rx == 1)
+			mac_printf("\tGSWSS: Flow Ctrl Mode RX: ENABLED\n");
+		else if (flow_ctrl_rx == 2)
+			mac_printf("\tGSWSS: Flow Ctrl Mode RX: Reserved\n");
+		else if (flow_ctrl_rx == 3)
+			mac_printf("\tGSWSS: Flow Ctrl Mode RX: DISABLED\n");
+
+		MAC_SET_VAL(phy_mode, PHY_MODE, FCONRX, flow_ctrl_rx);
+		GSWSS_MAC_RGWR(pdata, PHY_MODE(pdata->mac_idx), phy_mode);
+	}
+
+	return ret;
+}
+
+u32 gswss_get_flowctrl_rx(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u16 phy_mode = 0;
+	u32 flow_ctrl_rx;
+
+	phy_mode = GSWSS_MAC_RGRD(pdata, PHY_MODE(pdata->mac_idx));
+
+	flow_ctrl_rx = MAC_GET_VAL(phy_mode, PHY_MODE, FCONRX);
+
+	if (flow_ctrl_rx == 0)
+		mac_printf("\tGSWSS: Flow Ctrl Mode RX: Auto Mode\n");
+	else if (flow_ctrl_rx == 1)
+		mac_printf("\tGSWSS: Flow Ctrl Mode RX:  ENABLED\n");
+	else if (flow_ctrl_rx == 2)
+		mac_printf("\tGSWSS: Flow Ctrl Mode RX:  Reserved\n");
+	else if (flow_ctrl_rx == 3)
+		mac_printf("\tGSWSS: Flow Ctrl Mode RX:  DISABLED\n");
+
+	return flow_ctrl_rx;
+}
+
+void gswss_get_phy2mode(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int i = 0;
+	u32 phy_mode;
+	u8 speed_msb, speed_lsb, speed;
+	u8 linkst, fdup, flow_ctrl_tx, flow_ctrl_rx;
+
+	phy_mode = GSWSS_MAC_RGRD(pdata, PHY_MODE(pdata->mac_idx));
+	mac_printf("phy_mode%d %d\n", (i + 2), phy_mode);
+	speed_msb = GET_N_BITS(phy_mode, 15, 1);
+	speed_lsb = GET_N_BITS(phy_mode, 11, 2);
+	speed = (speed_msb << 2) | speed_lsb;
+
+	if (speed == 0)
+		mac_printf("\tGSWSS: SPEED    10 Mbps\n");
+	else if (speed == 1)
+		mac_printf("\tGSWSS: SPEED    100 Mbps\n");
+	else if (speed == 2)
+		mac_printf("\tGSWSS: SPEED    1 Gbps\n");
+	else if (speed == 3)
+		mac_printf("\tGSWSS: SPEED    10 Gbps\n");
+	else if (speed == 4)
+		mac_printf("\tGSWSS: SPEED    2.5 Gbps\n");
+	else if (speed == 5)
+		mac_printf("\tGSWSS: SPEED    5 Gbps\n");
+	else if (speed == 6)
+		mac_printf("\tGSWSS: SPEED    RESERVED\n");
+	else if (speed == 7)
+		mac_printf("\tGSWSS: SPEED    Auto Mode\n");
+
+	linkst = GET_N_BITS(phy_mode, 13, 2);
+
+	if (linkst == 0)
+		mac_printf("\tGSWSS: LINK STS: Auto Mode\n");
+	else if (linkst == 1)
+		mac_printf("\tGSWSS: LINK STS: Forced up\n");
+	else if (linkst == 2)
+		mac_printf("\tGSWSS: LINK STS: Forced down\n");
+	else if (linkst == 3)
+		mac_printf("\tGSWSS: LINK STS: Reserved\n");
+
+	fdup = GET_N_BITS(phy_mode, 9, 2);
+
+	if (fdup == 0)
+		mac_printf("\tGSWSS: Duplex mode set: Auto Mode\n");
+	else if (fdup == 1)
+		mac_printf("\tGSWSS: Duplex mode set: Full Duplex Mode\n");
+	else if (fdup == 2)
+		mac_printf("\tGSWSS: Duplex mode set: Reserved\n");
+	else if (fdup == 3)
+		mac_printf("\tGSWSS: Duplex mode set: Half Duplex Mode\n");
+
+	flow_ctrl_tx = GET_N_BITS(phy_mode, 7, 2);
+
+	if (flow_ctrl_tx == 0)
+		mac_printf("\tGSWSS: Flow Ctrl Mode TX: Auto Mode\n");
+	else if (flow_ctrl_tx == 1)
+		mac_printf("\tGSWSS: Flow Ctrl Mode TX: ENABLED\n");
+	else if (flow_ctrl_tx == 2)
+		mac_printf("\tGSWSS: Flow Ctrl Mode TX: Reserved\n");
+	else if (flow_ctrl_tx == 3)
+		mac_printf("\tGSWSS: Flow Ctrl Mode TX: DISABLED\n");
+
+	flow_ctrl_rx = GET_N_BITS(phy_mode, 7, 2);
+
+	if (flow_ctrl_rx == 0)
+		mac_printf("\tGSWSS: Flow Ctrl Mode RX: Auto Mode\n");
+	else if (flow_ctrl_rx == 1)
+		mac_printf("\tGSWSS: Flow Ctrl Mode RX: ENABLED\n");
+	else if (flow_ctrl_rx == 2)
+		mac_printf("\tGSWSS: Flow Ctrl Mode RX: Reserved\n");
+	else if (flow_ctrl_rx == 3)
+		mac_printf("\tGSWSS: Flow Ctrl Mode RX: DISABLED\n");
+}
+
+int gswss_set_xgmac_tx_disable(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 xgmac_ctrl = 0;
+
+	xgmac_ctrl = GSWSS_MAC_RGRD(pdata, XGMAC_CTRL(pdata->mac_idx));
+
+	if (MAC_GET_VAL(xgmac_ctrl, XGMAC_CTRL, DISTX) != val) {
+		mac_printf("\tGSWSS: XGMAC %d TX %s\n", pdata->mac_idx,
+			   val ? "DISABLED" : "NOT DISABLED");
+		MAC_SET_VAL(xgmac_ctrl, XGMAC_CTRL, DISTX, val);
+		GSWSS_MAC_RGWR(pdata, XGMAC_CTRL(pdata->mac_idx), xgmac_ctrl);
+	}
+
+	return 0;
+}
+
+int gswss_set_xgmac_rx_disable(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 xgmac_ctrl = 0;
+
+	xgmac_ctrl = GSWSS_MAC_RGRD(pdata, XGMAC_CTRL(pdata->mac_idx));
+
+	if (MAC_GET_VAL(xgmac_ctrl, XGMAC_CTRL, DISRX) != val) {
+		mac_printf("\tGSWSS: XGMAC %d RX %s\n", pdata->mac_idx,
+			   val ? "DISABLED" : "NOT DISABLED");
+		MAC_SET_VAL(xgmac_ctrl, XGMAC_CTRL, DISRX, val);
+		GSWSS_MAC_RGWR(pdata, XGMAC_CTRL(pdata->mac_idx), xgmac_ctrl);
+	}
+
+	return 0;
+}
+
+int gswss_set_xgmac_crc_ctrl(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 xgmac_ctrl = 0;
+
+	xgmac_ctrl = GSWSS_MAC_RGRD(pdata, XGMAC_CTRL(pdata->mac_idx));
+
+	if (MAC_GET_VAL(xgmac_ctrl, XGMAC_CTRL, CPC) != val) {
+		if (val == 0)
+			mac_printf("GSWSS: CRC and PAD insertion are "
+				   "enabled.\n");
+		else if (val == 1)
+			mac_printf("GSWSS: CRC insert enable,PAD insert "
+				   "disable\n");
+		else if (val == 2)
+			mac_printf("GSWSS: CRC,PAD not inserted not "
+				   "replaced.\n");
+
+		MAC_SET_VAL(xgmac_ctrl, XGMAC_CTRL, CPC, val);
+		GSWSS_MAC_RGWR(pdata, XGMAC_CTRL(pdata->mac_idx), xgmac_ctrl);
+	}
+
+	return 0;
+}
+
+int gswss_set_eee_cap(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 aneg_eee = 0;
+
+	aneg_eee = GSWSS_MAC_RGRD(pdata, ANEG_EEE(pdata->mac_idx));
+	MAC_SET_VAL(aneg_eee, ANEG_EEE, EEE_CAPABLE, val);
+	GSWSS_MAC_RGWR(pdata, ANEG_EEE(pdata->mac_idx), aneg_eee);
+
+	return 0;
+}
+
+int gswss_get_xgmac_crc_ctrl(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 xgmac_ctrl = 0, val = 0;
+
+	xgmac_ctrl = GSWSS_MAC_RGRD(pdata, XGMAC_CTRL(pdata->mac_idx));
+
+	val = MAC_GET_VAL(xgmac_ctrl, XGMAC_CTRL, CPC);
+
+	if (val == 0)
+		mac_printf("GSWSS: CRC and PAD insertion are enabled.\n");
+	else if (val == 1)
+		mac_printf("GSWSS: CRC insert enable,PAD insert disable\n");
+	else if (val == 2)
+		mac_printf("GSWSS: CRC,PAD not inserted not replaced.\n");
+
+	return val;
+}
+
+void gswss_get_xgmac_ctrl(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 xgmac_ctrl = 0, distx, disrx, crc_ctrl;
+	u32 mac_idx = 0;
+
+	xgmac_ctrl = GSWSS_MAC_RGRD(pdata, XGMAC_CTRL(pdata->mac_idx));
+	mac_printf("GSWSS: XGMAC CTRL %d %x\n", mac_idx, xgmac_ctrl);
+	distx = MAC_GET_VAL(xgmac_ctrl, XGMAC_CTRL, DISTX);
+	disrx = MAC_GET_VAL(xgmac_ctrl, XGMAC_CTRL, DISRX);
+	crc_ctrl = MAC_GET_VAL(xgmac_ctrl, XGMAC_CTRL, CPC);
+
+	mac_printf("\tGSWSS: XGMAC %d TX %s\n", mac_idx,
+		   distx ? "DISABLED" : "NOT DISABLED");
+	mac_printf("\tGSWSS: XGMAC %d RX %s\n", mac_idx,
+		   disrx ? "DISABLED" : "NOT DISABLED");
+
+	if (crc_ctrl == 0)
+		mac_printf("\tGSWSS: CRC and PAD insertion are enabled.\n");
+	else if (crc_ctrl == 1)
+		mac_printf("\tGSWSS: CRC insert enable,PAD insert disable\n");
+	else if (crc_ctrl == 2)
+		mac_printf("\tGSWSS: CRC,PAD not inserted not replaced.\n");
+}
+
+void gswss_test_all_reg(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	gswss_check_reg(pdev, GSWIPSS_IER0, "GSWIPSS_IER0", 0, 0x8C8C, 0);
+	gswss_check_reg(pdev, GSWIPSS_ISR0, "GSWIPSS_ISR0", 0, 0x8C8C, 0);
+	gswss_check_reg(pdev, GSWIPSS_IER1, "GSWIPSS_IER1", 0, 0x8C, 0);
+	gswss_check_reg(pdev, GSWIPSS_ISR1, "GSWIPSS_ISR1", 0, 0x8C, 0);
+	gswss_check_reg(pdev, CFG0_1588, "CFG0_1588", 0, 0x7777, 0);
+	gswss_check_reg(pdev, CFG1_1588, "CFG1_1588", 0, 0xFF80, 0);
+
+	gswss_check_reg(pdev, MAC_IF_CFG(pdata->mac_idx),
+			"MAC_IF_CFG", pdata->mac_idx, 0x7, 0);
+	gswss_check_reg(pdev, MAC_OP_CFG(pdata->mac_idx),
+			"MAC_OP_CFG", pdata->mac_idx, 0x1FF, 0);
+	gswss_check_reg(pdev, MAC_MTU_CFG(pdata->mac_idx),
+			"MAC_MTU_CFG", pdata->mac_idx, 0xFFFF, 0);
+	gswss_check_reg(pdev, MAC_GINT_CFG(pdata->mac_idx),
+			"MAC_GINT_CFG", pdata->mac_idx, 0xFFFF, 0);
+	gswss_check_reg(pdev, MAC_GINT_HD0_CFG(pdata->mac_idx),
+			"MAC_GINT_HD0_CFG", pdata->mac_idx, 0xFFFF, 0);
+	gswss_check_reg(pdev, MAC_GINT_HD1_CFG(pdata->mac_idx),
+			"MAC_GINT_HD1_CFG", pdata->mac_idx, 0xFFFF, 0);
+	gswss_check_reg(pdev, MAC_GINT_HD2_CFG(pdata->mac_idx),
+			"MAC_GINT_HD2_CFG", pdata->mac_idx, 0xFFFF, 0);
+	gswss_check_reg(pdev, MAC_GINT_HD3_CFG(pdata->mac_idx),
+			"MAC_GINT_HD3_CFG", pdata->mac_idx, 0xFFFF, 0);
+	gswss_check_reg(pdev, MAC_GINT_HD4_CFG(pdata->mac_idx),
+			"MAC_GINT_HD4_CFG", pdata->mac_idx, 0xFFFF, 0);
+	gswss_check_reg(pdev, MAC_GINT_HD5_CFG(pdata->mac_idx),
+			"MAC_GINT_HD5_CFG", pdata->mac_idx, 0xFFFF, 0);
+	gswss_check_reg(pdev, MAC_GINT_HD6_CFG(pdata->mac_idx),
+			"MAC_GINT_HD6_CFG", pdata->mac_idx, 0xFFFF, 0);
+	gswss_check_reg(pdev, MAC_TXTS_0(pdata->mac_idx),
+			"MAC_TXTS_0", pdata->mac_idx, 0xFFFF, 0);
+	gswss_check_reg(pdev, MAC_TXTS_1(pdata->mac_idx),
+			"MAC_TXTS_1", pdata->mac_idx, 0xFFFF, 0);
+	gswss_check_reg(pdev, MAC_TXTS_2(pdata->mac_idx),
+			"MAC_TXTS_2", pdata->mac_idx, 0xFFFF, 0);
+	gswss_check_reg(pdev, MAC_TXTS_3(pdata->mac_idx),
+			"MAC_TXTS_3", pdata->mac_idx, 0xFFFF, 0);
+	gswss_check_reg(pdev, MAC_TXTS_CIC(pdata->mac_idx),
+			"MAC_TXTS_CIC", pdata->mac_idx, 0x1F, 0);
+	gswss_check_reg(pdev, MAC_TXTS_ACC(pdata->mac_idx),
+			"MAC_TXTS_ACC", pdata->mac_idx, 0x403F, 0);
+	gswss_check_reg(pdev, PHY_MODE(pdata->mac_idx),
+			"PHY_MODE", pdata->mac_idx, 0xFFE0, 0);
+	gswss_check_reg(pdev, ANEG_EEE(pdata->mac_idx),
+			"ANEG_EEE", pdata->mac_idx, 0xF, 0);
+	gswss_check_reg(pdev, XGMAC_CTRL(pdata->mac_idx),
+			"XGMAC_CTRL", pdata->mac_idx, 0xF, 0);
+}
+
+void gswss_check_reg(void *pdev, u32 reg, char *name, int idx,
+		     u16 set_val, u16 clr_val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 val;
+
+	GSWSS_MAC_RGWR(pdata, reg, set_val);
+	val = GSWSS_MAC_RGRD(pdata, reg);
+
+	if (val != set_val)
+		mac_printf("Setting reg %s: %d with %x FAILED\n",
+			   name, idx, set_val);
+
+	GSWSS_MAC_RGWR(pdata, reg, clr_val);
+
+	if (val != clr_val)
+		mac_printf("Setting reg %s: %d with %x FAILED\n",
+			   name, idx, clr_val);
+}
+
+#if defined(PC_UTILITY) || defined(CHIPTEST)
+struct adap_ops *gsw_get_adap_ops(u32 devid)
+{
+	return &(adap_priv_data.ops);
+}
+#endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.h b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.h
new file mode 100644
index 000000000000..cd204c383f1f
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.h
@@ -0,0 +1,280 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#ifndef _GSWIPSS_MAC_API
+#define _GSWIPSS_MAC_API
+
+#include <xgmac_common.h>
+#include <gswss_api.h>
+
+#define MAC_IF_CFG(idx)			(0x1200 + ((idx) * (0x100)))
+#define MAC_OP_CFG(idx)			(0x1204 + ((idx) * (0x100)))
+#define MAC_MTU_CFG(idx)		(0x1208 + ((idx) * (0x100)))
+#define MAC_GINT_CFG(idx)		(0x120C + ((idx) * (0x100)))
+#define MAC_GINT_HD0_CFG(idx)		(0x1220 + ((idx) * (0x100)))
+#define MAC_GINT_HD1_CFG(idx)		(0x1224 + ((idx) * (0x100)))
+#define MAC_GINT_HD2_CFG(idx)		(0x1228 + ((idx) * (0x100)))
+#define MAC_GINT_HD3_CFG(idx)		(0x122C + ((idx) * (0x100)))
+#define MAC_GINT_HD4_CFG(idx)		(0x1230 + ((idx) * (0x100)))
+#define MAC_GINT_HD5_CFG(idx)		(0x1234 + ((idx) * (0x100)))
+#define MAC_GINT_HD6_CFG(idx)		(0x1238 + ((idx) * (0x100)))
+#define LMAC_CNT_LSB(idx)		(0x1240 + ((idx) * (0x100)))
+#define LMAC_CNT_MSB(idx)		(0x1244 + ((idx) * (0x100)))
+#define LMAC_CNT_ACC(idx)		(0x1248 + ((idx) * (0x100)))
+#define MAC_TXTS_0(idx)			(0x1250 + ((idx) * (0x100)))
+#define MAC_TXTS_1(idx)			(0x1254 + ((idx) * (0x100)))
+#define MAC_TXTS_2(idx)			(0x1258 + ((idx) * (0x100)))
+#define MAC_TXTS_3(idx)			(0x125C + ((idx) * (0x100)))
+#define MAC_TXTS_CIC(idx)		(0x1260 + ((idx) * (0x100)))
+#define MAC_TXTS_ACC(idx)		(0x1264 + ((idx) * (0x100)))
+#define PHY_MODE(idx)			(0x1270 + ((idx) * (0x100)))
+#define PHY_STAT(idx)			(0x1274 + ((idx) * (0x100)))
+#define ANEG_EEE(idx)			(0x1278 + ((idx) * (0x100)))
+#define XGMAC_CTRL(idx)			(0x1280 + ((idx) * (0x100)))
+
+#define MAC_IF_CFG_ADAP_RES_POS		15
+#define MAC_IF_CFG_ADAP_RES_WIDTH	1
+#define MAC_IF_CFG_LMAC_RES_POS		14
+#define MAC_IF_CFG_LMAC_RES_WIDTH	1
+#define MAC_IF_CFG_XGMAC_RES_POS	13
+#define MAC_IF_CFG_XGMAC_RES_WIDTH	1
+#define MAC_IF_CFG_MAC_EN_POS		12
+#define MAC_IF_CFG_MAC_EN_WIDTH		1
+#define MAC_IF_CFG_PTP_DIS_POS		11
+#define MAC_IF_CFG_PTP_DIS_WIDTH	1
+#define MAC_IF_CFG_CFG1G_POS		1
+#define MAC_IF_CFG_CFG1G_WIDTH		1
+#define MAC_IF_CFG_CFGFE_POS		2
+#define MAC_IF_CFG_CFGFE_WIDTH		1
+#define MAC_IF_CFG_CFG2G5_POS		0
+#define MAC_IF_CFG_CFG2G5_WIDTH		1
+
+#define MAC_OP_CFG_RXSPTAG_POS		0
+#define MAC_OP_CFG_RXSPTAG_WIDTH	2
+#define MAC_OP_CFG_RXTIME_POS		2
+#define MAC_OP_CFG_RXTIME_WIDTH		2
+#define MAC_OP_CFG_RXFCS_POS		4
+#define MAC_OP_CFG_RXFCS_WIDTH		2
+#define MAC_OP_CFG_TXSPTAG_POS		6
+#define MAC_OP_CFG_TXSPTAG_WIDTH	2
+#define MAC_OP_CFG_TXFCS_RM_POS		8
+#define MAC_OP_CFG_TXFCS_RM_WIDTH	1
+#define MAC_OP_CFG_TXFCS_INS_POS	9
+#define MAC_OP_CFG_TXFCS_INS_WIDTH	1
+#define MAC_OP_CFG_NUM_STREAM_POS	10
+#define MAC_OP_CFG_NUM_STREAM_WIDTH	1
+
+#define MAC_MTU_CFG_POS			0
+#define MAC_MTU_CFG_WIDTH		14
+
+#define MAC_TXTS_CIC_CIC_POS		0
+#define MAC_TXTS_CIC_CIC_WIDTH		2
+#define MAC_TXTS_CIC_OSTAVAIL_POS	2
+#define MAC_TXTS_CIC_OSTAVAIL_WIDTH	1
+#define MAC_TXTS_CIC_OSTC_POS		3
+#define MAC_TXTS_CIC_OSTC_WIDTH		1
+#define MAC_TXTS_CIC_TTSE_POS		4
+#define MAC_TXTS_CIC_TTSE_WIDTH		1
+
+#define MAC_TXTS_ACC_ADDR_POS		0
+#define MAC_TXTS_ACC_ADDR_WIDTH		6
+#define MAC_TXTS_ACC_OPMOD_POS		14
+#define MAC_TXTS_ACC_OPMOD_WIDTH	1
+#define MAC_TXTS_ACC_BAS_POS		15
+#define MAC_TXTS_ACC_BAS_WIDTH		1
+
+#define PHY_MODE_FCONRX_POS		5
+#define PHY_MODE_FCONRX_WIDTH		2
+#define PHY_MODE_FCONTX_POS		7
+#define PHY_MODE_FCONTX_WIDTH		2
+#define PHY_MODE_FDUP_POS		9
+#define PHY_MODE_FDUP_WIDTH		2
+#define PHY_MODE_SPEEDLSB_POS		11
+#define PHY_MODE_SPEEDLSB_WIDTH		2
+#define PHY_MODE_LINKST_POS		13
+#define PHY_MODE_LINKST_WIDTH		2
+#define PHY_MODE_SPEEDMSB_POS		15
+#define PHY_MODE_SPEEDMSB_WIDTH		1
+
+#define PHY_STAT_TXPAUEN_POS		0
+#define PHY_STAT_TXPAUEN_WIDTH		1
+#define PHY_STAT_RXPAUEN_POS		1
+#define PHY_STAT_RXPAUEN_WIDTH		1
+#define PHY_STAT_FDUP_POS		2
+#define PHY_STAT_FDUP_WIDTH		1
+#define PHY_STAT_SPEEDLSB_POS		3
+#define PHY_STAT_SPEEDLSB_WIDTH		2
+#define PHY_STAT_LSTAT_POS		5
+#define PHY_STAT_LSTAT_WIDTH		1
+#define PHY_STAT_EEECAP_POS		7
+#define PHY_STAT_EEECAP_WIDTH		1
+#define PHY_STAT_CLKSTOPCAP_POS		8
+#define PHY_STAT_CLKSTOPCAP_WIDTH	1
+#define PHY_STAT_SPEEDMSB_POS		11
+#define PHY_STAT_SPEEDMSB_WIDTH		1
+
+#define XGMAC_CTRL_CPC_POS		0
+#define XGMAC_CTRL_CPC_WIDTH		2
+#define XGMAC_CTRL_DISRX_POS		2
+#define XGMAC_CTRL_DISRX_WIDTH		1
+#define XGMAC_CTRL_DISTX_POS		3
+#define XGMAC_CTRL_DISTX_WIDTH		1
+
+#define ANEG_EEE_EEE_CAPABLE_POS	0
+#define ANEG_EEE_EEE_CAPABLE_WIDTH	2
+
+static inline u32 GSWSS_MAC_RGRD(struct mac_prv_data *pdata, u32 reg)
+{
+	u32 reg_val;
+#if defined(PC_UTILITY) || defined(CHIPTEST)
+	u32 reg_addr = pdata->ss_addr_base + reg;
+#else
+	volatile void *reg_addr = (volatile void *)pdata->ss_addr_base + reg;
+#endif
+
+#if defined(CHIPTEST) && CHIPTEST
+	reg_val = REG32(reg_addr);
+#endif
+#if defined(PC_UTILITY) && PC_UTILITY
+	pcuart_reg_rd(reg_addr, &reg_val);
+#endif
+#ifdef __KERNEL__
+	reg_val = ltq_r32(reg_addr);
+#endif
+	return reg_val;
+}
+
+static inline void GSWSS_MAC_RGWR(struct mac_prv_data *pdata, u32 reg,
+				  u32 val)
+{
+#if defined(PC_UTILITY) || defined(CHIPTEST)
+	u32 reg_addr = pdata->ss_addr_base + reg;
+#else
+	volatile void *reg_addr = (volatile void *)pdata->ss_addr_base + reg;
+#endif
+
+#if defined(CHIPTEST) && CHIPTEST
+	REG32(reg_addr) = val;
+#endif
+#if defined(PC_UTILITY) && PC_UTILITY
+	pcuart_reg_wr(reg_addr, val);
+#endif
+#ifdef __KERNEL__
+	ltq_w32(val, reg_addr);
+#endif
+}
+
+enum {
+	LMAC2 = 0,
+	LMAC3,
+	LMAC4
+};
+
+enum {
+	ADAP2 = 0,
+	ADAP3,
+	ADAP4
+};
+
+enum {
+	MAC2 = 0,
+	MAC3,
+	MAC4
+};
+
+enum {
+	LINK2 = 0,
+	LINK3,
+	LINK4
+};
+
+enum {
+	LMAC_MII = 0,
+	LMAC_GMII,
+	XGMAC_GMII,
+	XGMAC_XGMII,
+};
+
+enum {
+	CFG_1G = 0,
+	CFG_FE,
+	CFG_2G5
+};
+
+enum {
+	FCS = 0,
+	SPTAG,
+	TIME
+};
+
+enum {
+	RX = 0,
+	TX,
+};
+
+enum {
+	MODE0 = 0,
+	MODE1,
+	MODE2,
+	MODE3
+};
+
+enum {
+	EEE_CAP_AUTO = 0,
+	EEE_CAP_ON,
+	EEE_CAP_RES,
+	EEE_CAP_OFF
+};
+
+int gswss_mac_enable(void *pdev, u32 enable);
+int gswss_set_1g_intf(void *pdev, u32 macif);
+int gswss_set_fe_intf(void *pdev, u32 macif);
+int gswss_set_2G5_intf(void *pdev, u32 macif);
+int gswss_set_mac_txfcs_ins_op(void *pdev, u32 val);
+int gswss_set_mac_txfcs_rm_op(void *pdev, u32 val);
+int gswss_set_mac_rxfcs_op(void *pdev, u32 val);
+int gswss_set_mac_txsptag_op(void *pdev, u32 val);
+int gswss_set_mac_rxsptag_op(void *pdev, u32 val);
+int gswss_set_mac_rxtime_op(void *pdev, u32 val);
+int gswss_set_mtu(void *pdev, u32 mtu);
+int gswss_set_txtstamp_access(void *pdev, u32 op_mode, u32 addr);
+int gswss_set_duplex_mode(void *pdev, u32 val);
+int gswss_set_speed(void *pdev, u8 speed);
+int gswss_set_linkstatus(void *pdev, u8 linkst);
+int gswss_set_flowctrl_tx(void *pdev, u8 flow_ctrl_tx);
+int gswss_set_flowctrl_rx(void *pdev, u8 flow_ctrl_rx);
+int gswss_xgmac_reset(void *pdev, u32 reset);
+int gswss_lmac_reset(void *pdev, u32 reset);
+int gswss_adap_reset(void *pdev, u32 reset);
+int gswss_set_xgmac_tx_disable(void *pdev, u32 val);
+int gswss_set_xgmac_rx_disable(void *pdev, u32 val);
+int gswss_set_xgmac_crc_ctrl(void *pdev, u32 val);
+
+int gswss_get_mtu(void *pdev);
+u32 gswss_get_flowctrl_tx(void *pdev);
+u32 gswss_get_flowctrl_rx(void *pdev);
+u8 gswss_get_speed(void *pdev);
+u32 gswss_get_2G5_intf(void *pdev);
+u32 gswss_get_1g_intf(void *pdev);
+u32 gswss_get_fe_intf(void *pdev);
+int gswss_get_duplex_mode(void *pdev);
+int gswss_get_linkstatus(void *pdev);
+void gswss_get_xgmac_ctrl(void *pdev);
+void gswss_get_phy2mode(void *pdev);
+void gswss_get_macop(void *pdev);
+void gswss_get_macif(void *pdev);
+int gswss_get_mac_en(void *pdev);
+int gswss_get_mac_reset(void *pdev);
+int gswss_set_txtstamp_fifo(void *pdev,
+			    u8 ttse, u8 ostc, u8 ost_avail, u8 cic, u32 sec,
+			    u32 nsec, u32 record_id);
+void gswss_get_txtstamp_fifo(void *pdev, u32 record_id);
+int gswss_set_eee_cap(void *pdev, u32 val);
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.c b/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.c
new file mode 100644
index 000000000000..40a7cd4bc2c8
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.c
@@ -0,0 +1,1400 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#include <lmac_api.h>
+
+static u32 read_lmac_cnt(void *pdev);
+static u32 write_lmac_cnt(void *pdev, u32 val);
+
+struct _lmac_cfg {
+	char cmdname[256];
+	u8 args;
+	char help[1024];
+};
+
+struct _lmac_cfg lmac_cfg[] = {
+	{
+		"rmon",
+		0,
+		"lmac <0/1/2: Mac Idx> get rmon"
+	},
+	{
+		"all",
+		0,
+		"lmac <0/1/2: Mac Idx> get all"
+	},
+	{
+		"w",
+		2,
+		"lmac <0/1/2: Mac Idx> w <reg_off> <reg_val>"
+	},
+	{
+		"r",
+		1,
+		"lmac <0/1/2: Mac Idx> r <reg_off>"
+	},
+};
+
+void lmac_help(void)
+{
+	int i = 0;
+	int num_of_elem = (sizeof(lmac_cfg) / sizeof(struct _lmac_cfg));
+
+	mac_printf("\n----Legacy MAC Commands----\n\n");
+
+	for (i = 0; i < num_of_elem; i++) {
+		if (lmac_cfg[i].help) {
+
+#if defined(CHIPTEST) && CHIPTEST
+			mac_printf("gsw %s\n",
+				   lmac_cfg[i].help);
+#else
+			mac_printf("switch_cli %s\n",
+				   lmac_cfg[i].help);
+#endif
+		}
+	}
+}
+
+int lmac_check_args(int argc, char *argv)
+{
+	int i = 0;
+	int num_of_elem = (sizeof(lmac_cfg) / sizeof(struct _lmac_cfg));
+
+	for (i = 0; i < num_of_elem; i++) {
+		if (!strcmp(argv, lmac_cfg[i].cmdname)) {
+
+			if (argc != (lmac_cfg[i].args + 4)) {
+				mac_printf("\n--WRONG Command--\n");
+				mac_printf("switch_cli %s\n",
+					   lmac_cfg[i].help);
+				return -1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+void lmac_wr_reg(void *pdev, u32 reg_off, u32 reg_val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	mac_printf("\tREG offset: 0x%04x\n\tData: %08X\n", reg_off,
+		   reg_val);
+
+	LMAC_RGWR(pdata, reg_off, reg_val);
+}
+
+u32 lmac_rd_reg(void *pdev, u32 reg_off)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	pdata->reg_val = LMAC_RGRD(pdata, reg_off);
+
+	mac_printf("\tREG offset: 0x%04x\n\tData: %08X\n", reg_off,
+		   pdata->reg_val);
+
+	return pdata->reg_val;
+}
+
+int lmac_main(u32 argc, u8 *argv[])
+{
+	int idx = 0;
+	u32 start_arg = 0;
+	u32 mode_en, lpi_waitg, lpi_waitm;
+	struct mac_ops *ops;
+	u32 reg_off, reg_val;
+
+
+	start_arg++;
+	start_arg++;
+
+
+	if (argc <= 2) {
+		lmac_help();
+		goto end;
+	}
+
+	if (!strcmp(argv[start_arg], "-help")) {
+		lmac_help();
+
+		goto end;
+	}
+
+	idx = mac_nstrtoul(argv[start_arg],
+			   mac_nstrlen(argv[start_arg]),
+			   &start_arg);
+
+	if (idx > 2 || idx < 0) {
+		mac_printf("Give valid lmac index 0/1/2/\n");
+		return -1;
+	}
+
+	ops = gsw_get_mac_ops(0, idx);
+
+	if (!strcmp(argv[start_arg], "r")) {
+		if (0 != lmac_check_args(argc, (char *)argv[start_arg])) {
+			return -1;
+		}
+
+		start_arg++;
+#if defined(PC_UTILITY) || defined(__KERNEL__)
+
+		if ((strstr(argv[start_arg], "0x")) ||
+		    (strstr(argv[start_arg], "0X")))
+			mac_printf("matches with 0x\n");
+		else
+			mac_printf("Please give the address with "
+				   "0x firmat\n");
+
+#endif
+		reg_off = mac_nstrtoul(argv[start_arg],
+				       mac_nstrlen(argv[start_arg]),
+				       &start_arg);
+		lmac_rd_reg(ops, reg_off);
+
+		goto end;
+	}
+
+	if (!strcmp(argv[start_arg], "w")) {
+		if (0 != lmac_check_args(argc, (char *)argv[start_arg])) {
+			return -1;
+		}
+
+		start_arg++;
+
+#if defined(PC_UTILITY) || defined(__KERNEL__)
+
+		if ((strstr(argv[start_arg], "0x")) ||
+		    (strstr(argv[start_arg], "0X")))
+			mac_printf("matches with 0x\n");
+		else
+			mac_printf("Please give the address with "
+				   "0x format\n");
+
+#endif
+		reg_off = mac_nstrtoul(argv[start_arg],
+				       mac_nstrlen(argv[start_arg]),
+				       &start_arg);
+		reg_val = mac_nstrtoul(argv[start_arg],
+				       mac_nstrlen(argv[start_arg]),
+				       &start_arg);
+		lmac_wr_reg(ops, reg_off, reg_val);
+
+		goto end;
+	}
+
+	if (!strcmp(argv[start_arg], "get")) {
+		start_arg++;
+
+		if (!strcmp(argv[start_arg], "rmon")) {
+			lmac_get_rmon();
+			goto end;
+		} else if (!strcmp(argv[start_arg], "all")) {
+
+			lmac_get_intf_mode(ops);
+			lmac_get_duplex_mode(ops);
+			lmac_get_txfcs(ops);
+			lmac_get_flowcon_mode(ops);
+			lmac_get_ipg(ops);
+			lmac_get_preamble(ops);
+			lmac_get_defermode(ops);
+			lmac_get_jps(ops);
+			lmac_get_loopback(ops);
+			lmac_get_txer(ops);
+			lmac_get_lpimonitor_mode(ops);
+			lmac_get_lpi(ops, &mode_en,
+				     &lpi_waitg, &lpi_waitm);
+			lmac_get_mac_pstat(ops);
+			lmac_get_mac_pisr(ops);
+
+			lmac_get_pauseframe_samode(gsw_get_mac_ops(0, 0));
+		} else {
+			lmac_help();
+		}
+	} else {
+		lmac_help();
+	}
+
+end:
+	return 0;
+}
+
+int lmac_set_intf_mode(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl0 = LMAC_RGRD(pdata, MAC_CTRL0(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_ctrl0, MAC_CTRL0, GMII) != val) {
+		if (val == 0)
+			mac_printf("LMAC %d Intf: AUTO\n",
+				   pdata->mac_idx);
+		else if (val == 1)
+			mac_printf("LMAC %d Intf: MII(10/100/200 Mbps)\n",
+				   pdata->mac_idx);
+		else if (val == 2)
+			mac_printf("LMAC %d Intf: GMII (1000 Mbps)\n",
+				   pdata->mac_idx);
+		else if (val == 3)
+			mac_printf("LMAC %d Intf: GMII_2G (2000 Mbps)\n",
+				   pdata->mac_idx);
+
+		MAC_SET_VAL(mac_ctrl0, MAC_CTRL0, GMII, val);
+
+		LMAC_RGWR(pdata, MAC_CTRL0(pdata->mac_idx), mac_ctrl0);
+	}
+
+	return 0;
+}
+
+int lmac_get_intf_mode(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl0 = LMAC_RGRD(pdata, MAC_CTRL0(pdata->mac_idx));
+	u32 val = 0;
+
+	mac_printf("LMAC %d INTF MODE %08x\n", pdata->mac_idx, mac_ctrl0);
+	val = MAC_GET_VAL(mac_ctrl0, MAC_CTRL0, GMII);
+
+	if (val == 0)
+		mac_printf("\tIntf mode set to : AUTO\n");
+	else if (val == 1)
+		mac_printf("\tIntf mode set to : MII (10/100/200 Mbps)\n");
+	else if (val == 2)
+		mac_printf("\tIntf mode set to : GMII (1000 Mbps)\n");
+	else if (val == 3)
+		mac_printf("\tIntf mode set to : GMII_2G (2000 Mbps)\n");
+
+	return 0;
+}
+
+int lmac_set_duplex_mode(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl0 = LMAC_RGRD(pdata, MAC_CTRL0(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_ctrl0, MAC_CTRL0, FDUP) != val) {
+		if (val == 0)
+			mac_printf("LMAC %d FDUP set to: AUTO\n",
+				   pdata->mac_idx);
+		else if (val == 1)
+			mac_printf("LMAC %d FDUP set to: Full Duplex Mode\n",
+				   pdata->mac_idx);
+		else if (val == 2)
+			mac_printf("LMAC %d FDUP set to: Reserved\n",
+				   pdata->mac_idx);
+		else if (val == 3)
+			mac_printf("LMAC %d FDUP set to: Half Duplex Mode\n",
+				   pdata->mac_idx);
+
+		MAC_SET_VAL(mac_ctrl0, MAC_CTRL0, FDUP, val);
+
+		LMAC_RGWR(pdata, MAC_CTRL0(pdata->mac_idx), mac_ctrl0);
+	}
+
+	return 0;
+}
+
+int lmac_get_duplex_mode(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl0 = LMAC_RGRD(pdata, MAC_CTRL0(pdata->mac_idx));
+	u32 val;
+
+	mac_printf("LMAC %d DUPLEX MODE %08x\n", pdata->mac_idx, mac_ctrl0);
+
+	val = MAC_GET_VAL(mac_ctrl0, MAC_CTRL0, FDUP);
+
+	if (val == 0)
+		mac_printf("\tFDUP mode set to : AUTO\n");
+	else if (val == 1)
+		mac_printf("\tFDUP mode set to : Full Duplex Mode\n");
+	else if (val == 2)
+		mac_printf("\tFDUP mode set to : Reserved\n");
+	else if (val == 3)
+		mac_printf("\tFDUP mode set to : Half Duplex Mode\n");
+
+	return val;
+}
+
+int lmac_set_flowcon_mode(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl0 = LMAC_RGRD(pdata, MAC_CTRL0(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_ctrl0, MAC_CTRL0, FCON) != val) {
+		if (val == 0)
+			mac_printf("LMAC %d FCON mode set to : AUTO\n",
+				   pdata->mac_idx);
+		else if (val == 1)
+			mac_printf("LMAC %d FCON mode set to : RX only\n",
+				   pdata->mac_idx);
+		else if (val == 2)
+			mac_printf("LMAC %d FCON mode set to : TX only\n",
+				   pdata->mac_idx);
+		else if (val == 3)
+			mac_printf("LMAC %d FCON mode set to : RXTX \n",
+				   pdata->mac_idx);
+		else if (val == 4)
+			mac_printf("LMAC %d FCON mode set to : DISABLED\n",
+				   pdata->mac_idx);
+
+		MAC_SET_VAL(mac_ctrl0, MAC_CTRL0, FCON, val);
+
+		LMAC_RGWR(pdata, MAC_CTRL0(pdata->mac_idx), mac_ctrl0);
+	}
+
+	return 0;
+}
+
+u32 lmac_get_flowcon_mode(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl0 = LMAC_RGRD(pdata, MAC_CTRL0(pdata->mac_idx));
+	u32 val;
+
+	mac_printf("LMAC %d FLOWCONTROL MODE %08x\n",
+		   pdata->mac_idx, mac_ctrl0);
+
+	val = MAC_GET_VAL(mac_ctrl0, MAC_CTRL0, FCON);
+
+	if (val == 0)
+		mac_printf("\tFCON mode set to : AUTO\n");
+	else if (val == 1)
+		mac_printf("\tFCON mode set to : Receive only\n");
+	else if (val == 2)
+		mac_printf("\tFCON mode set to : transmit only\n");
+	else if (val == 3)
+		mac_printf("\tFCON mode set to : RXTX\n");
+	else if (val == 4)
+		mac_printf("\tFCON mode set to : DISABLED\n");
+
+	return val;
+}
+
+int lmac_set_txfcs(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl0 = LMAC_RGRD(pdata, MAC_CTRL0(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_ctrl0, MAC_CTRL0, FCS) != val) {
+		mac_printf("LMAC %d FCS generation : %s\n", pdata->mac_idx,
+			   val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(mac_ctrl0, MAC_CTRL0, FCS, val);
+
+		LMAC_RGWR(pdata, MAC_CTRL0(pdata->mac_idx), mac_ctrl0);
+	}
+
+	return 0;
+}
+
+int lmac_get_txfcs(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl0 = LMAC_RGRD(pdata, MAC_CTRL0(pdata->mac_idx));
+	u32 val;
+
+	mac_printf("LMAC %d FCS %08x\n", pdata->mac_idx, mac_ctrl0);
+
+	val = MAC_GET_VAL(mac_ctrl0, MAC_CTRL0, FCS);
+	mac_printf("\tFCS generation : %s\n", val ? "ENABLED" : "DISABLED");
+
+	return val;
+}
+
+int lmac_set_int(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 lmac_ier = LMAC_RGRD(pdata, LMAC_IER);
+
+	pdata->mac_idx += LMAC_IER_MAC2_POS;
+	SET_N_BITS(lmac_ier, pdata->mac_idx, LMAC_IER_MAC2_WIDTH, val);
+
+	//mac_printf("LMAC %d Interrupt : %s\n", pdata->mac_idx,
+	//	   val ? "ENABLED" : "DISABLED");
+	LMAC_RGWR(pdata, LMAC_IER, lmac_ier);
+
+	return 0;
+}
+
+int lmac_set_event_int(void *pdev, u32 evnt, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 lmac_pier = LMAC_RGRD(pdata, MAC_PIER(pdata->mac_idx));
+
+	switch (evnt) {
+	case LMAC_PHYERR_EVNT:
+		MAC_SET_VAL(lmac_pier, MAC_PIER, PHYERR, val);
+		break;
+
+	case LMAC_ALIGN_EVNT:
+		MAC_SET_VAL(lmac_pier, MAC_PIER, ALIGN, val);
+		break;
+
+	case LMAC_SPEED_EVNT:
+		MAC_SET_VAL(lmac_pier, MAC_PIER, SPEED, val);
+		break;
+
+	case LMAC_FDUP_EVNT:
+		MAC_SET_VAL(lmac_pier, MAC_PIER, FDUP, val);
+		break;
+
+	case LMAC_RXPAUEN_EVNT:
+		MAC_SET_VAL(lmac_pier, MAC_PIER, RXPAUEN, val);
+		break;
+
+	case LMAC_TXPAUEN_EVNT:
+		MAC_SET_VAL(lmac_pier, MAC_PIER, TXPAUEN, val);
+		break;
+
+	case LMAC_LPIOFF_EVNT:
+		MAC_SET_VAL(lmac_pier, MAC_PIER, LPIOFF, val);
+		break;
+
+	case LMAC_LPION_EVNT:
+		MAC_SET_VAL(lmac_pier, MAC_PIER, LPION, val);
+		break;
+
+	case LMAC_JAM_EVNT:
+		MAC_SET_VAL(lmac_pier, MAC_PIER, JAM, val);
+		break;
+
+	case LMAC_FCSERR_EVNT:
+		MAC_SET_VAL(lmac_pier, MAC_PIER, FCSERR, val);
+		break;
+
+	case LMAC_TXPAU_EVNT:
+		MAC_SET_VAL(lmac_pier, MAC_PIER, TXPAUSE, val);
+		break;
+
+	case LMAC_RXPAU_EVNT:
+		MAC_SET_VAL(lmac_pier, MAC_PIER, RXPAUSE, val);
+		break;
+
+	case LMAC_ALL_EVNT:
+		if (val)
+			lmac_pier = 0xFFFFFFFF;
+		else
+			lmac_pier = 0;
+
+		break;
+
+	default:
+		return -1;
+	}
+
+	mac_printf("LMAC %d PIER Interrupt Value: %d\n", pdata->mac_idx,
+		   lmac_pier);
+	LMAC_RGWR(pdata, MAC_PIER(pdata->mac_idx), lmac_pier);
+
+	return 0;
+}
+
+int lmac_get_int(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 lmac_isr = LMAC_RGRD(pdata, LMAC_ISR);
+	u32 val = 0, mac_idx = 0;
+
+	mac_idx = pdata->mac_idx + LMAC_ISR_MAC2_POS;
+	val = GET_N_BITS(lmac_isr, mac_idx, LMAC_ISR_MAC2_WIDTH);
+
+#if 0
+	mac_printf("LMAC %d Interrupt Stats : %s\n", pdata->mac_idx,
+		   val ? "ENABLED" : "DISABLED");
+#endif
+	return val;
+}
+
+/* Clear all the LMAC interrupts, Write 1 to Clear */
+int lmac_clear_int(void *pdev, u32 event)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_isr = 0;
+
+	/* Clear all the interrupts which are set */
+	mac_isr = LMAC_RGRD(pdata, MAC_PISR(pdata->mac_idx));
+
+	if ((event & LMAC_PHYERR_EVNT) &&
+	    (MAC_GET_VAL(mac_isr, MAC_PISR, PHYERR))) {
+		mac_printf("LMAC %d Clearing PHYERR Interrupt Status\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_isr, MAC_PISR, PHYERR, 1);
+	}
+
+	if ((event & LMAC_ALIGN_EVNT) &&
+	    (MAC_GET_VAL(mac_isr, MAC_PISR, ALIGN))) {
+		mac_printf("LMAC %d Clearing ALIGN Interrupt Status\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_isr, MAC_PISR, ALIGN, 1);
+	}
+
+	if ((event & LMAC_SPEED_EVNT) &&
+	    (MAC_GET_VAL(mac_isr, MAC_PISR, SPEED))) {
+		mac_printf("LMAC %d Clearing SPEED Interrupt Status\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_isr, MAC_PISR, SPEED, 1);
+	}
+
+	if ((event & LMAC_FDUP_EVNT) &&
+	    (MAC_GET_VAL(mac_isr, MAC_PISR, FDUP))) {
+		mac_printf("LMAC %d Clearing FDUP Interrupt Status\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_isr, MAC_PISR, FDUP, 1);
+	}
+
+	if ((event & LMAC_RXPAUEN_EVNT) &&
+	    (MAC_GET_VAL(mac_isr, MAC_PISR, RXPAUEN))) {
+		mac_printf("LMAC %d Clearing RXPAUEN Interrupt Status\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_isr, MAC_PISR, RXPAUEN, 1);
+	}
+
+	if ((event & LMAC_TXPAUEN_EVNT) &&
+	    (MAC_GET_VAL(mac_isr, MAC_PISR, TXPAUEN))) {
+		mac_printf("LMAC %d Clearing TXPAUEN Interrupt Status\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_isr, MAC_PISR, TXPAUEN, 1);
+	}
+
+	if ((event & LMAC_LPIOFF_EVNT) &&
+	    (MAC_GET_VAL(mac_isr, MAC_PISR, LPIOFF))) {
+		mac_printf("LMAC %d Clearing LPIOFF Interrupt Status\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_isr, MAC_PISR, LPIOFF, 1);
+	}
+
+	if ((event & LMAC_LPION_EVNT) &&
+	    (MAC_GET_VAL(mac_isr, MAC_PISR, LPION))) {
+		mac_printf("LMAC %d Clearing LPION Interrupt Status\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_isr, MAC_PISR, LPION, 1);
+	}
+
+	if ((event & LMAC_JAM_EVNT) &&
+	    (MAC_GET_VAL(mac_isr, MAC_PISR, JAM))) {
+		mac_printf("LMAC %d Clearing JAM Interrupt Status\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_isr, MAC_PISR, JAM, 1);
+	}
+
+	if ((event & LMAC_FCSERR_EVNT) &&
+	    (MAC_GET_VAL(mac_isr, MAC_PISR, FCSERR))) {
+		mac_printf("LMAC %d Clearing FCSERR Interrupt Status\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_isr, MAC_PISR, FCSERR, 1);
+	}
+
+	if ((event & LMAC_TXPAU_EVNT) &&
+	    (MAC_GET_VAL(mac_isr, MAC_PISR, TXPAUSE))) {
+		mac_printf("LMAC %d Clearing TXPAUSE Interrupt Status\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_isr, MAC_PISR, TXPAUSE, 1);
+	}
+
+	if ((event & LMAC_RXPAU_EVNT) &&
+	    (MAC_GET_VAL(mac_isr, MAC_PISR, RXPAUSE))) {
+		mac_printf("LMAC %d Clearing RXPAUSE Interrupt Status\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_isr, MAC_PISR, RXPAUSE, 1);
+	}
+
+	LMAC_RGWR(pdata, MAC_PISR(pdata->mac_idx), mac_isr);
+
+	return 0;
+}
+
+int lmac_set_ipg(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl1 = LMAC_RGRD(pdata, MAC_CTRL1(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_ctrl1, MAC_CTRL1, IPG) != val) {
+		mac_printf("LMAC %d IPG set to : %d bytes\n",
+			   pdata->mac_idx, val);
+		MAC_SET_VAL(mac_ctrl1, MAC_CTRL1, IPG, val);
+
+		LMAC_RGWR(pdata, MAC_CTRL1(pdata->mac_idx), mac_ctrl1);
+	}
+
+	return 0;
+}
+
+int lmac_get_ipg(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl1 = LMAC_RGRD(pdata, MAC_CTRL1(pdata->mac_idx));
+	u32 val;
+
+	mac_printf("LMAC %d IPG %08x\n", pdata->mac_idx, mac_ctrl1);
+
+	val = MAC_GET_VAL(mac_ctrl1, MAC_CTRL1, IPG);
+	mac_printf("\tIPG set to %d : bytes\n", val);
+
+	return val;
+}
+
+int lmac_set_preamble(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl1 = LMAC_RGRD(pdata, MAC_CTRL1(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_ctrl1, MAC_CTRL1, SHORTPRE) != val) {
+		mac_printf("LMAC %d Preamble is : %s\n", pdata->mac_idx,
+			   val ? "0 byte" : "7 byte");
+		MAC_SET_VAL(mac_ctrl1, MAC_CTRL1, SHORTPRE, val);
+
+		LMAC_RGWR(pdata, MAC_CTRL1(pdata->mac_idx), mac_ctrl1);
+	}
+
+	return 0;
+}
+
+int lmac_get_preamble(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl1 = LMAC_RGRD(pdata, MAC_CTRL1(pdata->mac_idx));
+	u32 val;
+
+	mac_printf("LMAC %d PREAMBLE %08x\n", pdata->mac_idx, mac_ctrl1);
+
+	val = MAC_GET_VAL(mac_ctrl1, MAC_CTRL1, SHORTPRE);
+	mac_printf("\tPreamble is : %s\n", val ? "0 byte" : "7 byte");
+
+	return val;
+}
+
+int lmac_set_defermode(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl1 = LMAC_RGRD(pdata, MAC_CTRL1(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_ctrl1, MAC_CTRL1, DEFERMODE) != val) {
+		mac_printf("LMAC %d CRS backpressure : %s\n", pdata->mac_idx,
+			   val ?
+			   "Enabled in Full Duplex mode" :
+			   "Enabled in Half Duplex mode");
+		MAC_SET_VAL(mac_ctrl1, MAC_CTRL1, DEFERMODE, val);
+
+		LMAC_RGWR(pdata, MAC_CTRL1(pdata->mac_idx), mac_ctrl1);
+	}
+
+	return 0;
+}
+
+int lmac_get_defermode(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl1 = LMAC_RGRD(pdata, MAC_CTRL1(pdata->mac_idx));
+	u32 val;
+
+	mac_printf("LMAC %d DEFERMODE %08x\n", pdata->mac_idx, mac_ctrl1);
+
+	val = MAC_GET_VAL(mac_ctrl1, MAC_CTRL1, DEFERMODE);
+	mac_printf("\tCRS backpressure : %s\n",
+		   val ?
+		   "Enabled in Full Duplex mode" :
+		   "Enabled in Half Duplex mode");
+
+	return val;
+}
+
+int lmac_set_lpi(void *pdev, u32 mode_en, u32 lpi_waitg, u32 lpi_waitm)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl4 = LMAC_RGRD(pdata, MAC_CTRL4(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_ctrl4, MAC_CTRL4, LPIEN) != mode_en) {
+		mac_printf("LMAC %d LPI Mode : %s\n", pdata->mac_idx,
+			   mode_en ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(mac_ctrl4, MAC_CTRL4, LPIEN, mode_en);
+	}
+
+	if (MAC_GET_VAL(mac_ctrl4, MAC_CTRL4, WAIT) != lpi_waitm) {
+		mac_printf("LMAC %d LPI Wait time for 100M : %d usec\n",
+			   pdata->mac_idx, lpi_waitm);
+		MAC_SET_VAL(mac_ctrl4, MAC_CTRL4, WAIT, lpi_waitm);
+	}
+
+	if (MAC_GET_VAL(mac_ctrl4, MAC_CTRL4, GWAIT) != lpi_waitg) {
+		mac_printf("LMAC %d LPI Wait time for 1G : %d usec\n",
+			   pdata->mac_idx, lpi_waitg);
+		MAC_SET_VAL(mac_ctrl4, MAC_CTRL4, GWAIT, lpi_waitg);
+	}
+
+	LMAC_RGWR(pdata, MAC_CTRL4(pdata->mac_idx), mac_ctrl4);
+
+	return 0;
+}
+
+int lmac_get_lpi(void *pdev, u32 *mode_en, u32 *lpi_waitg, u32 *lpi_waitm)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl4 = LMAC_RGRD(pdata, MAC_CTRL4(pdata->mac_idx));
+
+	mac_printf("LMAC %d LPI %08x\n", pdata->mac_idx, mac_ctrl4);
+
+	*mode_en = MAC_GET_VAL(mac_ctrl4, MAC_CTRL4, LPIEN);
+	mac_printf("\tLPI Mode : %s\n", *mode_en ? "ENABLED" : "DISABLED");
+
+	*lpi_waitm = MAC_GET_VAL(mac_ctrl4, MAC_CTRL4, WAIT);
+	mac_printf("\tLPI Wait time for 100M : %d usec\n", *lpi_waitm);
+
+	*lpi_waitg = MAC_GET_VAL(mac_ctrl4, MAC_CTRL4, GWAIT);
+	mac_printf("\tLPI Wait time for 1G : %d usec\n", *lpi_waitg);
+
+	return 0;
+}
+
+int lmac_set_jps(void *pdev, u32 pjps_bp, u32 pjps_nobp)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl5 = LMAC_RGRD(pdata, MAC_CTRL5(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_ctrl5, MAC_CTRL5, PJPS_BP) != pjps_bp) {
+		mac_printf("LMAC %d Prolong Jam Pattern Size during "
+			   "backpressure : %s\n",
+			   pdata->mac_idx, pjps_bp ?
+			   "64 bit jam pattern" :
+			   "32 bit jam pattern");
+		MAC_SET_VAL(mac_ctrl5, MAC_CTRL5, PJPS_BP, pjps_bp);
+	}
+
+	if (MAC_GET_VAL(mac_ctrl5, MAC_CTRL5, PJPS_NOBP) != pjps_nobp) {
+		mac_printf("LMAC %d Prolong Jam Pattern Size during "
+			   "no-backpressure : %s\n",
+			   pdata->mac_idx, pjps_nobp ?
+			   "64 bit jam pattern" :
+			   "32 bit jam pattern");
+		MAC_SET_VAL(mac_ctrl5, MAC_CTRL5, PJPS_NOBP, pjps_nobp);
+	}
+
+	LMAC_RGWR(pdata, MAC_CTRL5(pdata->mac_idx), mac_ctrl5);
+
+	return 0;
+}
+
+int lmac_get_jps(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_ctrl5 = LMAC_RGRD(pdata, MAC_CTRL5(pdata->mac_idx));
+	u32 pjps_bp, pjps_nobp;
+
+	mac_printf("LMAC %d JPS %08x\n", pdata->mac_idx, mac_ctrl5);
+
+	pjps_bp = MAC_GET_VAL(mac_ctrl5, MAC_CTRL5, PJPS_BP);
+	mac_printf("\tProlong Jam Pattern Size during backpressure : %s\n",
+		   pjps_bp ?
+		   "64 bit jam pattern" :
+		   "32 bit jam pattern");
+
+	pjps_nobp = MAC_GET_VAL(mac_ctrl5, MAC_CTRL5, PJPS_NOBP);
+	mac_printf("\tProlong Jam Pattern Size during no-backpressure : %s\n",
+		   pjps_nobp ?
+		   "64 bit jam pattern" :
+		   "32 bit jam pattern");
+
+	return 0;
+}
+
+int lmac_set_loopback(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_testen = LMAC_RGRD(pdata, MAC_TESTEN(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_testen, MAC_TESTEN, LOOP) != val) {
+		mac_printf("LMAC %d Loopback : %s\n", pdata->mac_idx,
+			   val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(mac_testen, MAC_TESTEN, LOOP, val);
+
+		LMAC_RGWR(pdata, MAC_TESTEN(pdata->mac_idx), mac_testen);
+	}
+
+	return 0;
+}
+
+int lmac_get_loopback(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_testen = LMAC_RGRD(pdata, MAC_TESTEN(pdata->mac_idx));
+	u32 val;
+
+	mac_printf("LMAC %d Loopback: %08x\n", pdata->mac_idx, mac_testen);
+
+	val = MAC_GET_VAL(mac_testen, MAC_TESTEN, LOOP);
+	mac_printf("\tLMAC: Loopback : %s\n", val ? "ENABLED" : "DISABLED");
+
+	return val;
+}
+
+int lmac_set_txer(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 mac_testen = LMAC_RGRD(pdata, MAC_TESTEN(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_testen, MAC_TESTEN, TXER) != val) {
+		mac_printf("LMAC %d Inject transmit error : %s\n",
+			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(mac_testen, MAC_TESTEN, TXER, val);
+
+		LMAC_RGWR(pdata, MAC_TESTEN(pdata->mac_idx), mac_testen);
+	}
+
+	return 0;
+}
+
+int lmac_get_txer(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_testen = LMAC_RGRD(pdata, MAC_TESTEN(pdata->mac_idx));
+	u32 val;
+
+	mac_printf("LMAC %d TXER %08x\n", pdata->mac_idx, mac_testen);
+
+	val = MAC_GET_VAL(mac_testen, MAC_TESTEN, TXER);
+	mac_printf("\tInject transmit error : %s\n",
+		   val ? "ENABLED" : "DISABLED");
+
+	return val;
+}
+
+int lmac_set_lpimonitor_mode(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_testen = LMAC_RGRD(pdata, MAC_TESTEN(pdata->mac_idx));
+
+	if (MAC_GET_VAL(mac_testen, MAC_TESTEN, LPITM) != val) {
+		if (val == 0)
+			mac_printf("LMAC %d LPI to be monitored in "
+				   "time recording : TX\n", pdata->mac_idx);
+		else if (val == 1)
+			mac_printf("LMAC %d LPI to be monitored in "
+				   "time recording : RX\n", pdata->mac_idx);
+		else if (val == 2)
+			mac_printf("LMAC %d LPI to be monitored in "
+				   "time recording : TXRX\n", pdata->mac_idx);
+
+		MAC_SET_VAL(mac_testen, MAC_TESTEN, LPITM, val);
+
+		LMAC_RGWR(pdata, MAC_TESTEN(pdata->mac_idx), mac_testen);
+	}
+
+	return 0;
+}
+
+int lmac_get_lpimonitor_mode(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_testen = LMAC_RGRD(pdata, MAC_TESTEN(pdata->mac_idx));
+	u32 val;
+
+	mac_printf("LMAC %d LPI MONITORING MODE %08x\n",
+		   pdata->mac_idx, mac_testen);
+
+	val = MAC_GET_VAL(mac_testen, MAC_TESTEN, LPITM);
+
+	if (val == 0)
+		mac_printf("\tLPI to be monitored in time recording : TX\n");
+	else if (val == 1)
+		mac_printf("\tLPI to be monitored in time recording : RX\n");
+	else if (val == 2)
+		mac_printf("\tLPI to be monitored in time recording : TXRX\n");
+
+	return val;
+}
+
+int lmac_set_pauseframe_samode(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_pfad = LMAC_RGRD(pdata, MAC_PFADCFG);
+
+	if (MAC_GET_VAL(mac_pfad, MAC_PFADCFG, SAMOD) != val) {
+		mac_printf("LMAC: Pause frame use : %s\n",
+			   val ?
+			   "PORT specific MAC source address" :
+			   "COMMON MAC source address");
+		MAC_SET_VAL(mac_pfad, MAC_PFADCFG, SAMOD, val);
+
+		LMAC_RGWR(pdata, MAC_PFADCFG, mac_pfad);
+	}
+
+	return 0;
+}
+
+int lmac_get_pauseframe_samode(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_pfad = LMAC_RGRD(pdata, MAC_PFADCFG);
+	u32 val;
+
+	mac_printf("LMAC: PAUSE FRAME SAMODE %08x\n", mac_pfad);
+
+	val = MAC_GET_VAL(mac_pfad, MAC_PFADCFG, SAMOD);
+	mac_printf("\tPause frame use : %s\n",
+		   val ?
+		   "PORT specific MAC source address" :
+		   "COMMON MAC source address");
+
+	return val;
+}
+
+int lmac_set_pauseframe_addr(void *pdev, u8 *mac_addr)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u16 mac_addr_0 = 0, mac_addr_1 = 0, mac_addr_2;
+
+	mac_addr_2 = (mac_addr[5] <<  8) | (mac_addr[4] <<  0);
+	mac_addr_1 = (mac_addr[3] << 24) | (mac_addr[2] << 16);
+	mac_addr_0 = (mac_addr[1] <<  8) | (mac_addr[0] <<  0);
+
+	if (LMAC_RGRD(pdata, MAC_PFSA_0) != mac_addr_0) {
+		mac_printf("Setting mac_addr_0 as %08x\n", mac_addr_0);
+		LMAC_RGWR(pdata, MAC_PFSA_0, mac_addr_0);
+	}
+
+	if (LMAC_RGRD(pdata, MAC_PFSA_1) != mac_addr_1) {
+		mac_printf("Setting mac_addr_1 as %08x\n", mac_addr_1);
+		LMAC_RGWR(pdata, MAC_PFSA_1, mac_addr_1);
+	}
+
+	if (LMAC_RGRD(pdata, MAC_PFSA_2) != mac_addr_2) {
+		mac_printf("Setting mac_addr_2 as %08x\n", mac_addr_2);
+		LMAC_RGWR(pdata, MAC_PFSA_2, mac_addr_2);
+	}
+
+	return 0;
+}
+
+int lmac_get_pauseframe_addr(void *pdev, u8 *mac_addr)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u16 mac_addr_0 = 0, mac_addr_1 = 0, mac_addr_2;
+
+	mac_addr_0 = LMAC_RGRD(pdata, MAC_PFSA_0);
+	mac_addr[1] = ((mac_addr_0 & 0xFF00) >> 8);
+	mac_addr[0] = (mac_addr_0 & 0x00FF);
+
+	mac_addr_1 = LMAC_RGRD(pdata, MAC_PFSA_1);
+	mac_addr[3] = ((mac_addr_1 & 0xFF00) >> 8);
+	mac_addr[2] = (mac_addr_1 & 0x00FF);
+
+	mac_addr_2 = LMAC_RGRD(pdata, MAC_PFSA_2);
+	mac_addr[5] = ((mac_addr_2 & 0xFF00) >> 8);
+	mac_addr[4] = (mac_addr_2 & 0x00FF);
+
+	return 0;
+}
+
+int lmac_get_mac_pstat(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_pstat = LMAC_RGRD(pdata, MAC_PSTAT(pdata->mac_idx));
+
+	mac_printf("LMAC %d PORT STAT: %08x\n", pdata->mac_idx, mac_pstat);
+
+	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, RXLPI))
+		mac_printf("\tReceive Low Power Idle Status : "
+			   "LPI Low power idle state\n");
+	else
+		mac_printf("\tReceive Low Power Idle Status : "
+			   "Normal Power state\n");
+
+	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, TXLPI))
+		mac_printf("\tTransmit Low Power Idle Status : "
+			   "LPI Low power idle state\n");
+	else
+		mac_printf("\tTransmit Low Power Idle Status : "
+			   "Normal Power state\n");
+
+	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, CRS))
+		mac_printf("\tCarrier Detected\n");
+	else
+		mac_printf("\tNo Carrier Detected\n");
+
+	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, LSTAT))
+		mac_printf("\tLink is : UP\n");
+	else
+		mac_printf("\tLink is : DOWN\n");
+
+	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, TXPAUEN))
+		mac_printf("\tLink Partner accepts Pause frames\n");
+	else
+		mac_printf("\tLink Partner doesnot accepts Pause frames\n");
+
+	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, RXPAUEN))
+		mac_printf("\tLink Partner sends Pause frames\n");
+	else
+		mac_printf("\tLink Partner doesnot sends Pause frames\n");
+
+	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, TXPAU))
+		mac_printf("\tTransmit Pause status is active\n");
+	else
+		mac_printf("\tNormal transmit operation\n");
+
+	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, RXPAU))
+		mac_printf("\tReceive Pause status is active\n");
+	else
+		mac_printf("\tNormal Receive operation\n");
+
+	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, FDUP))
+		mac_printf("\tFull duplex Mode\n");
+	else
+		mac_printf("\thalf Duplex mode\n");
+
+	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, MBIT))
+		mac_printf("\tAttached PHY runs at a data rate of "
+			   "100 Mbps\n");
+	else
+		mac_printf("\tAttached PHY runs at a data rate of "
+			   "10 Mbps\n");
+
+	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, GBIT))
+		mac_printf("\tAttached PHY runs at a data rate of "
+			   "1000 or 2000 Mbps\n");
+	else
+		mac_printf("\tAttached PHY runs at a data rate of "
+			   "10 or 100 Mbps\n");
+
+	if (MAC_GET_VAL(mac_pstat, MAC_PSTAT, PACT))
+		mac_printf("\tPHY is active and responds to MDIO accesses\n");
+	else
+		mac_printf("\tPHY is inactive or not present\n");
+
+	return 0;
+}
+
+int lmac_get_mac_pisr(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_pisr = LMAC_RGRD(pdata, MAC_PISR(pdata->mac_idx));
+
+	mac_printf("LMAC %d PORT INTERRUPT STATUS: %08x\n",
+		   pdata->mac_idx, mac_pisr);
+
+	if (MAC_GET_VAL(mac_pisr, MAC_PISR, RXPAUSE))
+		mac_printf("\tAtleast 1 pause frame has been Received\n");
+
+	if (MAC_GET_VAL(mac_pisr, MAC_PISR, TXPAUSE))
+		mac_printf("\tAtleast 1 pause frame has been transmitted\n");
+
+	if (MAC_GET_VAL(mac_pisr, MAC_PISR, FCSERR))
+		mac_printf("\tFrame checksum Error Detected\n");
+
+	if (MAC_GET_VAL(mac_pisr, MAC_PISR, LENERR))
+		mac_printf("\tLength mismatch Error Detected\n");
+
+	if (MAC_GET_VAL(mac_pisr, MAC_PISR, TOOLONG))
+		mac_printf("\tToo Long frame Error Detected\n");
+
+	if (MAC_GET_VAL(mac_pisr, MAC_PISR, TOOSHORT))
+		mac_printf("\tToo Short frame Error Detected\n");
+
+	if (MAC_GET_VAL(mac_pisr, MAC_PISR, JAM))
+		mac_printf("\tJam status detected\n");
+
+	if (MAC_GET_VAL(mac_pisr, MAC_PISR, LPION))
+		mac_printf("\tReceive low power idle mode is entered\n");
+
+	if (MAC_GET_VAL(mac_pisr, MAC_PISR, LPIOFF))
+		mac_printf("\tReceive low power idle mode is left\n");
+
+	if (MAC_GET_VAL(mac_pisr, MAC_PISR, TXPAUEN))
+		mac_printf("\tA change of Transmit Pause Enable Status\n");
+
+	if (MAC_GET_VAL(mac_pisr, MAC_PISR, RXPAUEN))
+		mac_printf("\tA change of Receive Pause Enable Status\n");
+
+	if (MAC_GET_VAL(mac_pisr, MAC_PISR, FDUP))
+		mac_printf("\tA change of half- or full-duplex mode\n");
+
+	if (MAC_GET_VAL(mac_pisr, MAC_PISR, SPEED))
+		mac_printf("\tA change of speed mode\n");
+
+	if (MAC_GET_VAL(mac_pisr, MAC_PISR, PACT))
+		mac_printf("\tA change of link activity\n");
+
+	if (MAC_GET_VAL(mac_pisr, MAC_PISR, ALIGN))
+		mac_printf("\tA frame has been received which an "
+			   "alignment error\n");
+
+	if (MAC_GET_VAL(mac_pisr, MAC_PISR, PHYERR))
+		mac_printf("\tA frame has been received which has an "
+			   "active rx_err signal\n");
+
+	return 0;
+}
+
+void lmac_test_all_reg(void *pdev)
+{
+	int i = 0;
+
+	lmac_check_reg(pdev, MAC_TEST, "MAC_TEST", 0, 0xFFFF, 0);
+	lmac_check_reg(pdev, MAC_PFADCFG, "MAC_PFADCFG", 0, 0x1, 0);
+	lmac_check_reg(pdev, MAC_PFSA_0, "MAC_PFSA_0", 0, 0xFFFF, 0);
+	lmac_check_reg(pdev, MAC_PFSA_1, "MAC_PFSA_1", 0, 0xFFFF, 0);
+	lmac_check_reg(pdev, MAC_PFSA_2, "MAC_PFSA_2", 0, 0xFFFF, 0);
+	lmac_check_reg(pdev, MAC_VLAN_ETYPE_0, "MAC_VLAN_ETYPE_0",
+		       0, 0xFFFF, 0);
+	lmac_check_reg(pdev, MAC_VLAN_ETYPE_1, "MAC_VLAN_ETYPE_1",
+		       0, 0xFFFF, 0);
+	lmac_check_reg(pdev, REG_LMAC_CNT_LSB, "REG_LMAC_CNT_LSB",
+		       0, 0xFFFF, 0);
+	lmac_check_reg(pdev, REG_LMAC_CNT_MSB, "REG_LMAC_CNT_MSB",
+		       0, 0xFFFF, 0);
+	lmac_check_reg(pdev, REG_LMAC_CNT_ACC, "REG_LMAC_CNT_ACC",
+		       0, 0x6F1F, 0);
+
+	lmac_check_reg(pdev, MAC_PISR(i), "MAC_PISR", i, 0xFFFF, 0);
+	lmac_check_reg(pdev, MAC_PIER(i), "MAC_PIER", i, 0xFFFF, 0);
+	lmac_check_reg(pdev, MAC_CTRL0(i), "MAC_CTRL0", i, 0xFFF, 0);
+	lmac_check_reg(pdev, MAC_CTRL1(i), "MAC_CTRL1", i, 0x810F, 0);
+	lmac_check_reg(pdev, MAC_CTRL2(i), "MAC_CTRL2", i, 0xF, 0);
+	lmac_check_reg(pdev, MAC_CTRL3(i), "MAC_CTRL3", i, 0xF, 0);
+	lmac_check_reg(pdev, MAC_CTRL4(i), "MAC_CTRL4", i, 0x7FFF, 0);
+	lmac_check_reg(pdev, MAC_CTRL5(i), "MAC_CTRL5", i, 0x3, 0);
+	lmac_check_reg(pdev, MAC_TESTEN(i), "MAC_TESTEN", i, 0x307, 0);
+	lmac_check_reg(pdev, MAC_LPITIMER0(i), "MAC_LPITIMER0",
+		       i, 0xFFFF, 0);
+	lmac_check_reg(pdev, MAC_LPITIMER1(i), "MAC_LPITIMER1",
+		       i, 0xFFFF, 0);
+}
+
+void lmac_check_reg(void *pdev, u32 reg, char *name, int idx, u16 set_val,
+		    u16 clr_val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 val;
+
+	LMAC_RGWR(pdata, reg, set_val);
+	val = LMAC_RGRD(pdata, reg);
+
+	if (val != set_val)
+		mac_printf("Setting reg %s: %d with %x FAILED\n",
+			   name, idx, set_val);
+
+	LMAC_RGWR(pdata, reg, clr_val);
+
+	if (val != clr_val)
+		mac_printf("Setting reg %s: %d with %x FAILED\n",
+			   name, idx, clr_val);
+}
+
+static u32 read_lmac_cnt(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 cnt = 0;
+
+	cnt = (((LMAC_RGRD(pdata, REG_LMAC_CNT_MSB) & 0xFFFF) << 16) |
+	       (LMAC_RGRD(pdata, REG_LMAC_CNT_LSB)));
+
+	return cnt;
+}
+
+static u32 write_lmac_cnt(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 cnt_msb = 0, cnt_lsb;
+
+	cnt_msb = ((val & 0xFFFF0000) >> 16);
+	cnt_lsb = (val & 0xFFFF);
+
+	LMAC_RGWR(pdata, REG_LMAC_CNT_MSB, cnt_msb);
+	LMAC_RGWR(pdata, REG_LMAC_CNT_LSB, cnt_lsb);
+
+	return 0;
+}
+
+void lmac_rmon_rd(void *pdev, struct lmac_rmon_cnt *lmac_cnt)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 lmac_cnt_acc = 0;
+	int i = 0;
+
+	MAC_SET_VAL(lmac_cnt_acc, LMAC_CNT_ACC, OPMOD, LMAC_RMON_RD);
+	MAC_SET_VAL(lmac_cnt_acc, LMAC_CNT_ACC, MAC, pdata->mac_idx + 2);
+
+	for (i = 0; i < 6; i++) {
+		MAC_SET_VAL(lmac_cnt_acc, LMAC_CNT_ACC, BAS, 1);
+		MAC_SET_VAL(lmac_cnt_acc, LMAC_CNT_ACC, ADDR, i);
+
+		LMAC_RGWR(pdata, REG_LMAC_CNT_ACC, lmac_cnt_acc);
+
+		while (1) {
+			if ((LMAC_RGRD(pdata, REG_LMAC_CNT_ACC) & 0x8000) == 0)
+				break;
+		}
+
+		switch (i) {
+		case SGLE_COLN_CNT:
+			lmac_cnt->sing_coln_cnt = read_lmac_cnt(pdev);
+			break;
+
+		case MPLE_COLN_CNT:
+			lmac_cnt->mple_coln_cnt = read_lmac_cnt(pdev);
+			break;
+
+		case LATE_COLN_CNT:
+			lmac_cnt->late_coln_cnt = read_lmac_cnt(pdev);
+			break;
+
+		case EXCS_COLN_CNT:
+			lmac_cnt->excs_coln_cnt = read_lmac_cnt(pdev);
+			break;
+
+		case RXPA_FRAM_CNT:
+			lmac_cnt->rx_pause_cnt  = read_lmac_cnt(pdev);
+			break;
+
+		case TXPA_FRAM_CNT:
+			lmac_cnt->tx_pause_cnt  = read_lmac_cnt(pdev);
+			break;
+
+		default:
+			break;
+		}
+	}
+}
+
+void lmac_rmon_wr(void *pdev, struct lmac_rmon_cnt *lmac_cnt)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 lmac_cnt_acc = 0;
+	int i = 0;
+
+	MAC_SET_VAL(lmac_cnt_acc, LMAC_CNT_ACC, OPMOD, LMAC_RMON_WR);
+	MAC_SET_VAL(lmac_cnt_acc, LMAC_CNT_ACC, MAC, pdata->mac_idx + 2);
+
+	for (i = 0; i < 6; i++) {
+		MAC_SET_VAL(lmac_cnt_acc, LMAC_CNT_ACC, BAS, 1);
+		MAC_SET_VAL(lmac_cnt_acc, LMAC_CNT_ACC, ADDR, i);
+
+		LMAC_RGWR(pdata, REG_LMAC_CNT_ACC, lmac_cnt_acc);
+
+		while (1) {
+			if ((LMAC_RGRD(pdata, REG_LMAC_CNT_ACC) & 0x8000) == 0)
+				break;
+		}
+
+		switch (i) {
+		case SGLE_COLN_CNT:
+			write_lmac_cnt(pdev, lmac_cnt->sing_coln_cnt);
+			break;
+
+		case MPLE_COLN_CNT:
+			write_lmac_cnt(pdev, lmac_cnt->mple_coln_cnt);
+			break;
+
+		case LATE_COLN_CNT:
+			write_lmac_cnt(pdev, lmac_cnt->late_coln_cnt);
+			break;
+
+		case EXCS_COLN_CNT:
+			write_lmac_cnt(pdev, lmac_cnt->excs_coln_cnt);
+			break;
+
+		case RXPA_FRAM_CNT:
+			write_lmac_cnt(pdev, lmac_cnt->rx_pause_cnt);
+			break;
+
+		case TXPA_FRAM_CNT:
+			write_lmac_cnt(pdev, lmac_cnt->tx_pause_cnt);
+			break;
+
+		default:
+			break;
+		}
+	}
+}
+
+void lmac_rmon_clr(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 lmac_cnt_acc = 0;
+
+	MAC_SET_VAL(lmac_cnt_acc, LMAC_CNT_ACC, OPMOD, LMAC_RMON_CLR);
+	MAC_SET_VAL(lmac_cnt_acc, LMAC_CNT_ACC, MAC, pdata->mac_idx + 2);
+
+	MAC_SET_VAL(lmac_cnt_acc, LMAC_CNT_ACC, BAS, 1);
+	MAC_SET_VAL(lmac_cnt_acc, LMAC_CNT_ACC, ADDR, 0); // ignored
+
+	LMAC_RGWR(pdata, REG_LMAC_CNT_ACC, lmac_cnt_acc);
+
+	while (1) {
+		if ((LMAC_RGRD(pdata, REG_LMAC_CNT_ACC) & 0x8000) == 0)
+			break;
+	}
+}
+
+void lmac_rmon_clr_allmac(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 lmac_cnt_acc = 0;
+
+	MAC_SET_VAL(lmac_cnt_acc, LMAC_CNT_ACC, OPMOD, LMAC_RMON_CLRALL);
+	MAC_SET_VAL(lmac_cnt_acc, LMAC_CNT_ACC, MAC, 0); // ignored
+
+	MAC_SET_VAL(lmac_cnt_acc, LMAC_CNT_ACC, BAS, 1);
+	MAC_SET_VAL(lmac_cnt_acc, LMAC_CNT_ACC, ADDR, 0); // ignored
+
+	LMAC_RGWR(pdata, REG_LMAC_CNT_ACC, lmac_cnt_acc);
+
+	while (1) {
+		if ((LMAC_RGRD(pdata, REG_LMAC_CNT_ACC) & 0x8000) == 0)
+			break;
+	}
+}
+
+void lmac_get_rmon(void)
+{
+	struct lmac_rmon_cnt lmac_cnt[3];
+	int i = 0;
+	struct mac_ops *ops;
+	u32 max_mac = gsw_get_mac_subifcnt(0);
+
+	for (i = 0; i < max_mac; i++) {
+		ops = gsw_get_mac_ops(0, i);
+		lmac_rmon_rd(ops, &lmac_cnt[i]);
+	}
+
+	mac_printf("\nTYPE                            %11s %11s %11s\n", "       LMAC 2", "     LMAC 3", "     LMAC 4\n");
+
+	mac_printf("Single Collision Cnt            = ");
+
+	mac_printf("%11u %11u %11u", lmac_cnt[0].sing_coln_cnt,
+		   lmac_cnt[1].sing_coln_cnt, lmac_cnt[2].sing_coln_cnt);
+
+	mac_printf("Multiple Collision Cnt          = ");
+
+	mac_printf("%11u %11u %11u", lmac_cnt[0].mple_coln_cnt,
+		   lmac_cnt[1].mple_coln_cnt, lmac_cnt[2].mple_coln_cnt);
+
+	mac_printf("Late Collision Cnt              = ");
+
+	mac_printf("%11u %11u %11u", lmac_cnt[0].late_coln_cnt,
+		   lmac_cnt[1].late_coln_cnt, lmac_cnt[2].late_coln_cnt);
+
+	mac_printf("Excess Collision Cnt            = ");
+
+	mac_printf("%11u %11u %11u", lmac_cnt[0].excs_coln_cnt,
+		   lmac_cnt[1].excs_coln_cnt, lmac_cnt[2].excs_coln_cnt);
+
+	mac_printf("Rx Pause Cnt                    = ");
+
+	mac_printf("%11u %11u %11u", lmac_cnt[0].rx_pause_cnt,
+		   lmac_cnt[1].rx_pause_cnt, lmac_cnt[2].rx_pause_cnt);
+
+	mac_printf("Tx Pause Cnt                    = ");
+
+	mac_printf("%11u %11u %11u", lmac_cnt[0].tx_pause_cnt,
+		   lmac_cnt[1].tx_pause_cnt, lmac_cnt[2].tx_pause_cnt);
+
+	mac_printf("\n");
+}
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.h b/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.h
new file mode 100644
index 000000000000..1b7351603768
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.h
@@ -0,0 +1,358 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#ifndef _LMAC_
+#define _LMAC_
+
+#include <xgmac_common.h>
+#if defined(PC_UTILITY) && PC_UTILITY
+#define LEGACY_MAC_BASE			0x42000
+#else
+#define LEGACY_MAC_BASE			0xb8420000
+#endif
+#define MAC_TEST			0x300
+#define MAC_PFADCFG			0x304
+#define MAC_PFSA_0			0x308
+#define MAC_PFSA_1			0x30C
+#define MAC_PFSA_2			0x310
+#define MAC_VLAN_ETYPE_0		0x318
+#define MAC_VLAN_ETYPE_1		0x31C
+#define LMAC_IER			0x320
+#define LMAC_ISR			0x324
+#define REG_LMAC_CNT_LSB		0x328
+#define REG_LMAC_CNT_MSB		0x32C
+#define REG_LMAC_CNT_ACC		0x330
+#define MAC_PSTAT(idx)			(0x400 + ((idx) * (0x30)))
+#define MAC_PISR(idx)			(0x404 + ((idx) * (0x30)))
+#define MAC_PIER(idx)			(0x408 + ((idx) * (0x30)))
+#define MAC_CTRL0(idx)			(0x40C + ((idx) * (0x30)))
+#define MAC_CTRL1(idx)			(0x410 + ((idx) * (0x30)))
+#define MAC_CTRL2(idx)			(0x414 + ((idx) * (0x30)))
+#define MAC_CTRL3(idx)			(0x418 + ((idx) * (0x30)))
+#define MAC_CTRL4(idx)			(0x41C + ((idx) * (0x30)))
+#define MAC_CTRL5(idx)			(0x420 + ((idx) * (0x30)))
+#define MAC_TESTEN(idx)			(0x42C + ((idx) * (0x30)))
+#define MAC_LPITIMER0(idx)		(0x424 + ((idx) * (0x30)))
+#define MAC_LPITIMER1(idx)		(0x428 + ((idx) * (0x30)))
+
+#define MAC_CTRL0_GMII_POS      0
+#define MAC_CTRL0_GMII_WIDTH      2
+#define MAC_CTRL0_FDUP_POS      2
+#define MAC_CTRL0_FDUP_WIDTH      2
+#define MAC_CTRL0_FCON_POS      4
+#define MAC_CTRL0_FCON_WIDTH      2
+#define MAC_CTRL0_FCS_POS       7
+#define MAC_CTRL0_FCS_WIDTH       1
+#define MAC_CTRL0_PADEN_POS     8
+#define MAC_CTRL0_PADEN_WIDTH     1
+#define MAC_CTRL0_VPADEN_POS    9
+#define MAC_CTRL0_VPADEN_WIDTH    1
+#define MAC_CTRL0_VPAD2EN_POS   10
+#define MAC_CTRL0_VPAD2EN_WIDTH   1
+#define MAC_CTRL0_APADEN_POS    11
+#define MAC_CTRL0_APADEN_WIDTH    1
+
+#define MAC_CTRL1_IPG_POS		0
+#define MAC_CTRL1_IPG_WIDTH		4
+#define MAC_CTRL1_SHORTPRE_POS		8
+#define MAC_CTRL1_SHORTPRE_WIDTH	1
+#define MAC_CTRL1_DEFERMODE_POS		15
+#define MAC_CTRL1_DEFERMODE_WIDTH	1
+
+#define MAC_CTRL2_LCHKS_POS		0
+#define MAC_CTRL2_LCHKS_WIDTH		2
+#define MAC_CTRL2_LCHKL_POS		2
+#define MAC_CTRL2_LCHKL_WIDTH		1
+#define MAC_CTRL2_MLEN_POS		3
+#define MAC_CTRL2_MLEN_WIDTH		1
+
+#define MAC_CTRL3_RCNT_POS		0
+#define MAC_CTRL3_RCNT_WIDTH		4
+
+#define MAC_CTRL4_WAIT_POS       0
+#define MAC_CTRL4_WAIT_WIDTH       7
+#define MAC_CTRL4_LPIEN_POS      7
+#define MAC_CTRL4_LPIEN_WIDTH      1
+#define MAC_CTRL4_GWAIT_POS      8
+#define MAC_CTRL4_GWAIT_WIDTH      7
+
+#define MAC_CTRL5_PJPS_BP_POS       0
+#define MAC_CTRL5_PJPS_BP_WIDTH       1
+#define MAC_CTRL5_PJPS_NOBP_POS     1
+#define MAC_CTRL5_PJPS_NOBP_WIDTH     1
+
+#define MAC_TESTEN_LOOP_POS       0
+#define MAC_TESTEN_LOOP_WIDTH       1
+#define MAC_TESTEN_TXER_POS       1
+#define MAC_TESTEN_TXER_WIDTH       1
+#define MAC_TESTEN_JTEN_POS       2
+#define MAC_TESTEN_JTEN_WIDTH       1
+#define MAC_TESTEN_LPITM_POS      8
+#define MAC_TESTEN_LPITM_WIDTH      2
+
+#define MAC_LPITMER0_TMLSB_POS     0
+#define MAC_LPITMER0_TMLSB__WIDTH    16
+#define MAC_LPITMER1_TMLSB_POS     0
+#define MAC_LPITMER1_TMLSB__WIDTH    16
+
+#define MAC_PIER_RXPAUSE_POS      0
+#define MAC_PIER_RXPAUSE_WIDTH      1
+#define MAC_PIER_TXPAUSE_POS      1
+#define MAC_PIER_TXPAUSE_WIDTH      1
+#define MAC_PIER_FCSERR_POS       2
+#define MAC_PIER_FCSERR_WIDTH       1
+#define MAC_PIER_LENERR_POS       3
+#define MAC_PIER_LENERR_WIDTH       1
+#define MAC_PIER_TOOLONG_POS      4
+#define MAC_PIER_TOOLONG_WIDTH      1
+#define MAC_PIER_TOOSHORT_POS     5
+#define MAC_PIER_TOOSHORT_WIDTH     1
+#define MAC_PIER_JAM_POS          6
+#define MAC_PIER_JAM_WIDTH          1
+#define MAC_PIER_LPION_POS        7
+#define MAC_PIER_LPION_WIDTH        1
+#define MAC_PIER_LPIOFF_POS       8
+#define MAC_PIER_LPIOFF_WIDTH       1
+#define MAC_PIER_TXPAUEN_POS      9
+#define MAC_PIER_TXPAUEN_WIDTH      1
+#define MAC_PIER_RXPAUEN_POS      10
+#define MAC_PIER_RXPAUEN_WIDTH      1
+#define MAC_PIER_FDUP_POS         11
+#define MAC_PIER_FDUP_WIDTH         1
+#define MAC_PIER_SPEED_POS        12
+#define MAC_PIER_SPEED_WIDTH        1
+#define MAC_PIER_PACT_POS         13
+#define MAC_PIER_PACT_WIDTH         1
+#define MAC_PIER_ALIGN_POS        14
+#define MAC_PIER_ALIGN_WIDTH        1
+#define MAC_PIER_PHYERR_POS       15
+#define MAC_PIER_PHYERR_WIDTH       1
+
+#define MAC_PISR_RXPAUSE_POS      0
+#define MAC_PISR_RXPAUSE_WIDTH      1
+#define MAC_PISR_TXPAUSE_POS      1
+#define MAC_PISR_TXPAUSE_WIDTH      1
+#define MAC_PISR_FCSERR_POS       2
+#define MAC_PISR_FCSERR_WIDTH       1
+#define MAC_PISR_LENERR_POS       3
+#define MAC_PISR_LENERR_WIDTH       1
+#define MAC_PISR_TOOLONG_POS      4
+#define MAC_PISR_TOOLONG_WIDTH      1
+#define MAC_PISR_TOOSHORT_POS     5
+#define MAC_PISR_TOOSHORT_WIDTH     1
+#define MAC_PISR_JAM_POS          6
+#define MAC_PISR_JAM_WIDTH          1
+#define MAC_PISR_LPION_POS        7
+#define MAC_PISR_LPION_WIDTH        1
+#define MAC_PISR_LPIOFF_POS       8
+#define MAC_PISR_LPIOFF_WIDTH       1
+#define MAC_PISR_TXPAUEN_POS      9
+#define MAC_PISR_TXPAUEN_WIDTH      1
+#define MAC_PISR_RXPAUEN_POS      10
+#define MAC_PISR_RXPAUEN_WIDTH      1
+#define MAC_PISR_FDUP_POS         11
+#define MAC_PISR_FDUP_WIDTH         1
+#define MAC_PISR_SPEED_POS        12
+#define MAC_PISR_SPEED_WIDTH        1
+#define MAC_PISR_PACT_POS         13
+#define MAC_PISR_PACT_WIDTH         1
+#define MAC_PISR_ALIGN_POS        14
+#define MAC_PISR_ALIGN_WIDTH        1
+#define MAC_PISR_PHYERR_POS       15
+#define MAC_PISR_PHYERR_WIDTH       1
+
+#define MAC_PSTAT_RXLPI_POS      0
+#define MAC_PSTAT_RXLPI_WIDTH      1
+#define MAC_PSTAT_TXLPI_POS      1
+#define MAC_PSTAT_TXLPI_WIDTH      1
+#define MAC_PSTAT_CRS_POS        2
+#define MAC_PSTAT_CRS_WIDTH        1
+#define MAC_PSTAT_LSTAT_POS      3
+#define MAC_PSTAT_LSTAT_WIDTH      1
+#define MAC_PSTAT_TXPAUEN_POS    4
+#define MAC_PSTAT_TXPAUEN_WIDTH    1
+#define MAC_PSTAT_RXPAUEN_POS    5
+#define MAC_PSTAT_RXPAUEN_WIDTH    1
+#define MAC_PSTAT_TXPAU_POS      6
+#define MAC_PSTAT_TXPAU_WIDTH      1
+#define MAC_PSTAT_RXPAU_POS      7
+#define MAC_PSTAT_RXPAU_WIDTH      1
+#define MAC_PSTAT_FDUP_POS       8
+#define MAC_PSTAT_FDUP_WIDTH       1
+#define MAC_PSTAT_MBIT_POS       9
+#define MAC_PSTAT_MBIT_WIDTH       1
+#define MAC_PSTAT_GBIT_POS       10
+#define MAC_PSTAT_GBIT_WIDTH       1
+#define MAC_PSTAT_PACT_POS       11
+#define MAC_PSTAT_PACT_WIDTH       1
+
+#define MAC_VLAN_ETPE1_STAG_POS  0
+#define MAC_VLAN_ETPE1_STAG_WIDTH  16
+#define MAC_VLAN_ETPE0_CTAG_POS  0
+#define MAC_VLAN_ETPE0_CTAG_WIDTH  16
+
+#define LMAC_IER_MAC2_POS	0
+#define LMAC_IER_MAC2_WIDTH	1
+#define LMAC_IER_MAC3_POS	1
+#define LMAC_IER_MAC3_WIDTH	1
+#define LMAC_IER_MAC4_POS	2
+#define LMAC_IER_MAC4_WIDTH	1
+
+#define LMAC_ISR_MAC2_POS	0
+#define LMAC_ISR_MAC2_WIDTH	1
+#define LMAC_ISR_MAC3_POS	1
+#define LMAC_ISR_MAC3_WIDTH	1
+#define LMAC_ISR_MAC4_POS	2
+#define LMAC_ISR_MAC4_WIDTH	1
+
+#define MAC_PFSA2_PFAD_POS  0
+#define MAC_PFSA2_PFAD_WIDTH  16
+#define MAC_PFSA1_PFAD_POS  0
+#define MAC_PFSA1_PFAD_WIDTH  16
+#define MAC_PFSA0_PFAD_POS  0
+#define MAC_PFSA0_PFAD_WIDTH  16
+
+#define MAC_PFADCFG_SAMOD_POS  0
+#define MAC_PFADCFG_SAMOD_WIDTH  1
+
+#define LMAC_CNT_ACC_BAS_POS     15
+#define LMAC_CNT_ACC_BAS_WIDTH     1
+#define LMAC_CNT_ACC_OPMOD_POS  13
+#define LMAC_CNT_ACC_OPMOD_WIDTH  2
+#define LMAC_CNT_ACC_MAC_POS     8
+#define LMAC_CNT_ACC_MAC_WIDTH     4
+#define LMAC_CNT_ACC_ADDR_POS    0
+#define LMAC_CNT_ACC_ADDR_WIDTH    5
+
+#define SGLE_COLN_CNT			0
+#define MPLE_COLN_CNT			1
+#define LATE_COLN_CNT			2
+#define EXCS_COLN_CNT			3
+#define RXPA_FRAM_CNT			4
+#define TXPA_FRAM_CNT			5
+
+enum {
+	LMAC_RMON_RD = 0,
+	LMAC_RMON_CLR,
+	LMAC_RMON_WR,
+	LMAC_RMON_CLRALL
+};
+
+struct lmac_rmon_cnt {
+	u32 sing_coln_cnt;
+	u32 mple_coln_cnt;
+	u32 late_coln_cnt;
+	u32 excs_coln_cnt;
+	u32 rx_pause_cnt;
+	u32 tx_pause_cnt;
+};
+
+static inline u32 LMAC_RGRD(struct mac_prv_data *pdata, u32 reg)
+{
+	u32 reg_val;
+#if defined(PC_UTILITY) || defined(CHIPTEST)
+	u32 reg_addr = pdata->lmac_addr_base + reg;
+#else
+	volatile void *reg_addr = (volatile void *)pdata->lmac_addr_base + reg;
+#endif
+
+#if defined(CHIPTEST) && CHIPTEST
+	reg_val = REG32(reg_addr);
+#endif
+#if defined(PC_UTILITY) && PC_UTILITY
+	pcuart_reg_rd(reg_addr, &reg_val);
+#endif
+#ifdef __KERNEL__
+	reg_val = ltq_r32(reg_addr);
+#endif
+	return reg_val;
+}
+
+static inline void LMAC_RGWR(struct mac_prv_data *pdata, u32 reg, u32 val)
+{
+#if defined(PC_UTILITY) || defined(CHIPTEST)
+	u32 reg_addr = pdata->lmac_addr_base + reg;
+#else
+	volatile void *reg_addr = (volatile void *)pdata->lmac_addr_base + reg;
+#endif
+
+#if defined(CHIPTEST) && CHIPTEST
+	REG32(reg_addr) = val;
+#endif
+#if defined(PC_UTILITY) && PC_UTILITY
+	pcuart_reg_wr(reg_addr, val);
+#endif
+#ifdef __KERNEL__
+	ltq_w32(val, reg_addr);
+#endif
+}
+
+#define LMAC_RGRD_BITS(reg, field)			\
+	GET_N_BITS(LMAC_RGRD(reg),			\
+		   reg##_##field##_POS,			\
+		   reg##_##field##_WIDTH)
+
+#define LMAC_RGWR_BITS(reg, field, val)			\
+	do {						\
+		u32 reg_val = LMAC_RGRD(reg);		\
+		SET_N_BITS(reg_val,			\
+			   reg##_##field##_POS,		\
+			   reg##_##field##_WIDTH, (val));\
+		LMAC_RGWR(reg, reg_val);		\
+	} while (0)
+
+int lmac_set_intf_mode(void *pdev, u32 val) ;
+int lmac_set_duplex_mode(void *pdev, u32 val);
+int lmac_set_flowcon_mode(void *pdev, u32 val);
+int lmac_set_txfcs(void *pdev, u32 val);
+int lmac_set_ipg(void *pdev, u32 val);
+int lmac_set_preamble(void *pdev, u32 val);
+int lmac_set_defermode(void *pdev, u32 val);
+int lmac_set_lpi(void *pdev, u32 mode_en, u32 lpi_waitg, u32 lpi_waitm);
+int lmac_set_jps(void *pdev, u32 pjps_bp, u32 pjps_nobp);
+int lmac_set_loopback(void *pdev, u32 val);
+int lmac_set_txer(void *pdev, u32 val);
+int lmac_set_lpimonitor_mode(void *pdev, u32 val);
+int lmac_set_pauseframe_samode(void *pdev, u32 val);
+int lmac_set_pauseframe_addr(void *pdev, u8 *mac_addr);
+int lmac_set_int(void *pdev, u32 val);
+int lmac_set_event_int(void *pdev, u32 evnt, u32 val);
+
+int lmac_get_event_int(void *pdev, u32 evnt);
+int lmac_get_intf_mode(void *pdev);
+int lmac_get_duplex_mode(void *pdev);
+u32 lmac_get_flowcon_mode(void *pdev);
+int lmac_get_txfcs(void *pdev);
+int lmac_get_ipg(void *pdev);
+int lmac_get_preamble(void *pdev);
+int lmac_get_defermode(void *pdev);
+int lmac_get_lpi(void *pdev, u32 *mode_en, u32 *lpi_waitg, u32 *lpi_waitm);
+int lmac_get_jps(void *pdev);
+int lmac_get_loopback(void *pdev);
+int lmac_get_txer(void *pdev);
+int lmac_get_lpimonitor_mode(void *pdev);
+int lmac_get_pauseframe_samode(void *pdev);
+int lmac_get_mac_pstat(void *pdev);
+int lmac_get_mac_pisr(void *pdev);
+int lmac_get_pauseframe_addr(void *pdev, u8 *mac_addr);
+int lmac_get_int_stat(void *pdev);
+int lmac_get_int(void *pdev);
+int lmac_clear_int(void *pdev, u32 event);
+
+void lmac_test_all_reg(void *pdev);
+void lmac_check_reg(void *pdev, u32 reg, char *name, int idx,
+		    u16 set_val, u16 clr_val);
+
+void lmac_rmon_rd(void *pdev, struct lmac_rmon_cnt *lmac_cnt);
+void lmac_rmon_wr(void *pdev, struct lmac_rmon_cnt *lmac_cnt);
+void lmac_rmon_clr(void *pdev);
+void lmac_rmon_clr_allmac(void *pdev);
+void lmac_get_rmon(void);
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.c b/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.c
new file mode 100644
index 000000000000..555f76f38f26
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.c
@@ -0,0 +1,1212 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#include <xgmac.h>
+#include <gswss_mac_api.h>
+#include <lmac_api.h>
+#include <xgmac_mdio.h>
+
+int mac_set_flowctrl(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	if (val > 4) {
+		mac_printf("mac_config_flowctrl invalid val %d\n", val);
+		return -1;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	lmac_set_flowcon_mode(pdev, val);
+
+	switch (val) {
+	case 0: /* AUTO */
+		xgmac_enable_tx_flow_ctl(pdev, pdata->pause_time);
+		xgmac_enable_rx_flow_ctl(pdev);
+		gswss_set_flowctrl_rx(pdev, 0);
+		gswss_set_flowctrl_tx(pdev, 0);
+		break;
+
+	case 3: /* RXTX */
+		xgmac_enable_tx_flow_ctl(pdev, pdata->pause_time);
+		xgmac_enable_rx_flow_ctl(pdev);
+		gswss_set_flowctrl_rx(pdev, 1);
+		gswss_set_flowctrl_tx(pdev, 1);
+		break;
+
+	case 1: /* RX */
+		/* Disable TX in XGMAC and GSWSS */
+		xgmac_disable_tx_flow_ctl(pdev);
+		gswss_set_flowctrl_tx(pdev, 3);
+		/* Enable RX in XGMAC and GSWSS */
+		xgmac_enable_rx_flow_ctl(pdev);
+		gswss_set_flowctrl_rx(pdev, 1);
+		break;
+
+	case 2: /* TX */
+		/* Disable RX in XGMAC and GSWSS */
+		xgmac_disable_rx_flow_ctl(pdev);
+		gswss_set_flowctrl_rx(pdev, 3);
+		/* Enable TX in XGMAC and GSWSS */
+		xgmac_enable_tx_flow_ctl(pdev, pdata->pause_time);
+		gswss_set_flowctrl_tx(pdev, 1);
+		break;
+
+	case 4: /* Disabled */
+		xgmac_disable_tx_flow_ctl(pdev);
+		xgmac_disable_rx_flow_ctl(pdev);
+		gswss_set_flowctrl_rx(pdev, 3);
+		gswss_set_flowctrl_tx(pdev, 3);
+		break;
+
+	default:
+		break;
+	}
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return 0;
+}
+
+int mac_get_flowctrl(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 flow_ctrl_tx = 0, flow_ctrl_rx = 0, flow_ctrl = 0;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	flow_ctrl_tx = gswss_get_flowctrl_tx(pdev);
+	flow_ctrl_rx = gswss_get_flowctrl_rx(pdev);
+
+	if (flow_ctrl_tx == 1 && flow_ctrl_rx == 1)
+		flow_ctrl = 3; /* RXTX */
+	else if (flow_ctrl_tx == 1 && flow_ctrl_rx == 0)
+		flow_ctrl = 2; /* TX */
+	else if (flow_ctrl_tx == 0 && flow_ctrl_rx == 1)
+		flow_ctrl = 1; /* RX */
+	else if (flow_ctrl_tx == 3 && flow_ctrl_rx == 3)
+		flow_ctrl = 4; /* Disabled */
+	else if (flow_ctrl_tx == 0 && flow_ctrl_rx == 0)
+		flow_ctrl = 0; /* Auto */
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return flow_ctrl;
+}
+
+int mac_reset(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	gswss_xgmac_reset(pdev, 1);
+	gswss_set_xgmac_rx_disable(pdev, 1);
+	gswss_set_xgmac_tx_disable(pdev, 1);
+
+	gswss_lmac_reset(pdev, 1);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return 0;
+}
+
+int mac_config_loopback(void *pdev, u32 loopback)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	xgmac_set_loopback(pdev, loopback);
+	lmac_set_loopback(pdev, loopback);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return 0;
+}
+
+int mac_config_ipg(void *pdev, u32 ipg)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	xgmac_set_ipg(pdev, ipg);
+	lmac_set_ipg(pdev, ((96 + (32 * ipg)) / 8));
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return 0;
+}
+
+int mac_set_duplex(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	if (val == GSW_DUPLEX_FULL) /* Full Duplex */
+		val = MAC_FULL_DPLX;
+	else if (val == GSW_DUPLEX_HALF) /* Half Duplex */
+		val = MAC_HALF_DPLX;
+	else
+		val = MAC_AUTO_DPLX;
+
+	gswss_set_duplex_mode(pdev, val);
+	lmac_set_duplex_mode(pdev, val);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return 0;
+}
+
+int mac_get_duplex(void *pdev)
+{
+	int val = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	val = gswss_get_duplex_mode(pdev);
+
+	if (val == MAC_FULL_DPLX)
+		val = GSW_DUPLEX_FULL;
+	else if (val == MAC_HALF_DPLX)
+		val = GSW_DUPLEX_HALF;
+	else
+		val = GSW_DUPLEX_AUTO;
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return val;
+}
+
+int mac_set_mii_if(void *pdev, u32 mii_mode)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int ret = 0;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	/* Default values for 2.5G is XGMAC_GMII, 1G is LMAC_GMII, */
+	/* FE is LMAC_MII */
+	if (mii_mode == GSW_PORT_HW_XGMII) {
+		gswss_set_2G5_intf(pdev, XGMAC_XGMII);
+	} else if (mii_mode == GSW_PORT_HW_MII) {
+		gswss_set_fe_intf(pdev, LMAC_MII);
+	} else if (mii_mode == GSW_PORT_HW_GMII) {
+		gswss_set_1g_intf(pdev, XGMAC_GMII);
+		gswss_set_fe_intf(pdev, XGMAC_GMII);
+		gswss_set_2G5_intf(pdev, XGMAC_GMII);
+	} else if (mii_mode == 5) {	/* For Testing LMAC 1G only */
+		gswss_set_1g_intf(pdev, LMAC_GMII);
+	} else {
+		mac_printf("Wrong MII Interface\n");
+		ret = -1;
+		goto err;
+	}
+
+err:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return -1;
+}
+
+int mac_get_mii_if(void *pdev)
+{
+	int mac_speed;
+	u32 intf = GSW_PORT_HW_XGMII;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	mac_speed = gswss_get_speed(pdev);
+
+	if ((mac_speed == SPEED_10M) || (mac_speed == SPEED_100M)) {
+		intf = gswss_get_fe_intf(pdev);
+
+		if (intf == XGMAC_GMII) {
+			intf = GSW_PORT_HW_GMII;
+			mac_printf("Speed %s got intf XGMAC GMII\n",
+				   (mac_speed == SPEED_10M ? "10M" : "100M"));
+		} else {
+			intf = GSW_PORT_HW_MII;
+			mac_printf("Speed %s got intf LMAC MII\n",
+				   (mac_speed == SPEED_10M ? "10M" : "100M"));
+		}
+	} else if (mac_speed == SPEED_1G) {
+		intf = gswss_get_1g_intf(pdev);
+
+		if (intf == XGMAC_GMII)
+			mac_printf("Speed 1G got intf XGMAC GMII\n");
+		else
+			mac_printf("Speed 1G got intf LMAC GMII\n");
+
+		intf = GSW_PORT_HW_GMII;
+	} else if (mac_speed == SPEED_2G5) {
+		intf = gswss_get_2G5_intf(pdev);
+
+		if (intf == XGMAC_GMII) {
+			intf = GSW_PORT_HW_GMII;
+			mac_printf("Speed 2.5G got intf XGMAC GMII\n");
+		} else {
+			intf = GSW_PORT_HW_XGMII;
+			mac_printf("Speed 2.5G got intf XGMAC XGMII\n");
+		}
+	} else if (mac_speed == SPEED_10G) {
+		intf = GSW_PORT_HW_XGMII;
+		mac_printf("Speed 10G got intf XGMAC XGMII\n");
+	} else if (mac_speed == SPEED_AUTO) {
+		intf = GSW_PORT_HW_XGMII;
+		mac_printf("Speed 10G got intf AUTO\n");
+	}
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return intf;
+}
+
+int mac_set_speed(void *pdev, u32 phy_speed)
+{
+	u32 mii_intf;
+	int ret = 0;
+
+	if (phy_speed == GSW_PORT_SPEED_10) {	/* 10 Mbps */
+		mii_intf = gswss_get_fe_intf(pdev);
+
+		if (mii_intf == LMAC_MII)
+			phy_speed = SPEED_LMAC_10M;
+		else if (mii_intf == XGMAC_GMII)
+			phy_speed = SPEED_XGMAC_10M;
+	} else if (phy_speed == GSW_PORT_SPEED_100) {	/* 100 Mbps */
+		mii_intf = gswss_get_fe_intf(pdev);
+
+		if (mii_intf == LMAC_MII)
+			phy_speed = SPEED_LMAC_100M;
+		else if (mii_intf == XGMAC_GMII)
+			phy_speed = SPEED_XGMAC_100M;
+	} else if (phy_speed == GSW_PORT_SPEED_1000) { /* 1 Gbps */
+		mii_intf = gswss_get_1g_intf(pdev);
+
+		if (mii_intf == XGMAC_GMII)
+			phy_speed = SPEED_XGMAC_1G;
+		else if (mii_intf == LMAC_GMII)
+			phy_speed = SPEED_LMAC_1G;
+	} else if (phy_speed == GSW_PORT_SPEED_25000) { /* 2.5Gbps */
+		mii_intf = gswss_get_2G5_intf(pdev);
+
+		if (mii_intf == XGMAC_GMII)
+			phy_speed = SPEED_GMII_25G;
+		else if (mii_intf == XGMAC_XGMII)
+			phy_speed = SPEED_XGMII_25G;
+	} else if (phy_speed == GSW_PORT_SPEED_100000) {  /* 10Gbps */
+		phy_speed = SPEED_XGMAC_10G;
+	} else if (phy_speed == 0) {
+		phy_speed = SPEED_MAC_AUTO;
+	} else {
+		ret = -1;
+		goto err;
+	}
+
+	mac_set_physpeed(pdev, phy_speed);
+
+err:
+	return ret;
+}
+
+int mac_set_physpeed(void *pdev, u32 phy_speed)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	xgmac_set_extcfg(pdev, 1);
+
+	switch (phy_speed) {
+	case SPEED_MAC_AUTO:
+		gswss_set_speed(pdev, SPEED_AUTO);
+		break;
+
+	case SPEED_XGMAC_10G:
+		xgmac_set_xgmii_speed(pdev);
+		gswss_set_speed(pdev, SPEED_10G);
+		break;
+
+	case SPEED_GMII_25G:
+		gswss_set_speed(pdev, SPEED_2G5);
+		gswss_set_2G5_intf(pdev, XGMAC_GMII);
+		xgmac_set_gmii_2500_speed(pdev);
+		break;
+
+	case SPEED_XGMII_25G:
+		gswss_set_speed(pdev, SPEED_2G5);
+		gswss_set_2G5_intf(pdev, XGMAC_XGMII);
+		xgmac_set_xgmii_2500_speed(pdev);
+		break;
+
+	case SPEED_XGMAC_1G:
+		gswss_set_speed(pdev, SPEED_1G);
+		gswss_set_1g_intf(pdev, XGMAC_GMII);
+		xgmac_set_gmii_speed(pdev);
+		xgmac_set_extcfg(pdev, 1);
+		break;
+
+	case SPEED_XGMAC_10M:
+		gswss_set_speed(pdev, SPEED_10M);
+
+	case SPEED_XGMAC_100M:
+		if (phy_speed != SPEED_XGMAC_10M)
+			gswss_set_speed(pdev, SPEED_100M);
+
+		gswss_set_fe_intf(pdev, XGMAC_GMII);
+		gswss_set_1g_intf(pdev, XGMAC_GMII);
+		xgmac_set_gmii_speed(pdev);
+		break;
+
+	case SPEED_LMAC_10M:
+		gswss_set_speed(pdev, SPEED_10M);
+
+	case SPEED_LMAC_100M:
+		if (phy_speed != SPEED_LMAC_10M)
+			gswss_set_speed(pdev, SPEED_100M);
+
+		gswss_set_fe_intf(pdev, LMAC_MII);
+		lmac_set_intf_mode(pdev, 1);
+		break;
+
+	case SPEED_LMAC_1G:
+		gswss_set_speed(pdev, SPEED_1G);
+		gswss_set_1g_intf(pdev, LMAC_GMII);
+		lmac_set_intf_mode(pdev, 2);
+		break;
+
+	default:
+		break;
+	}
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return 0;
+}
+
+int mac_get_speed(void *pdev)
+{
+	int mac_speed;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	mac_speed = gswss_get_speed(pdev);
+
+	if (mac_speed == SPEED_10M)
+		mac_speed = GSW_PORT_SPEED_10;
+	else if (mac_speed == SPEED_100M)
+		mac_speed = GSW_PORT_SPEED_100;
+	else if (mac_speed == SPEED_1G)
+		mac_speed = GSW_PORT_SPEED_1000;
+	else if (mac_speed == SPEED_10G)
+		mac_speed = GSW_PORT_SPEED_100000;
+	else if (mac_speed == SPEED_2G5)
+		mac_speed = GSW_PORT_SPEED_25000;
+	else if (mac_speed == SPEED_AUTO)
+		mac_speed = 0;
+
+	mac_printf("Returning Speed = %d\n", mac_speed);
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return mac_speed;
+}
+
+int mac_set_linksts(void *pdev, u8 linksts)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	if (linksts == GSW_PORT_LINK_UP)
+		gswss_set_linkstatus(pdev, 1);
+	else if (linksts == GSW_PORT_LINK_DOWN)
+		gswss_set_linkstatus(pdev, 2);
+	else
+		gswss_set_linkstatus(pdev, 0); /* Auto */
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return 0;
+}
+
+int mac_get_linksts(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int linksts;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	linksts = gswss_get_linkstatus(pdev);
+
+	if (linksts == 1)
+		linksts = GSW_PORT_LINK_UP;
+	else if (linksts == 2)
+		linksts = GSW_PORT_LINK_DOWN;
+	else
+		linksts = -1;
+
+	mac_printf("Returning linksts = %d\n", linksts);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return linksts;
+}
+
+int mac_set_lpien(void *pdev, u32 enable, u32 lpi_waitg, u32 lpi_waitm)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+
+#ifdef CONFIG_SILVER_WORKAROUND
+#else
+	mac_printf("Configuring LPIEN\n");
+	lmac_set_lpi(pdev, enable, lpi_waitg, lpi_waitm);
+	xgmac_set_eee_mode(pdev, enable);
+	xgmac_set_eee_timer(pdev, pdata->twt, pdata->lst);
+#endif
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return 0;
+}
+
+int mac_get_lpien(void *pdev)
+{
+	int enable;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	enable = xgmac_get_eee_mode(pdev);
+
+	mac_printf("Returning lpien = %d\n", enable);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return enable;
+}
+
+int mac_set_mtu(void *pdev, u32 mtu)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int ret = 0;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	if (mtu > FALCON_MAX_MTU) {
+		ret = -1;
+		goto err;
+	}
+
+	gswss_set_mtu(pdev, mtu);
+
+	if (mtu > XGMAC_MAX_STD_PACKET)
+		xgmac_config_jumbo_pkt(pdev, mtu);
+	else
+		xgmac_config_std_pkt(pdev);
+
+err:
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return ret;
+}
+
+int mac_get_mtu(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int mtu = 0;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	mtu = gswss_get_mtu(pdev);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return mtu;
+}
+
+int mac_set_pfsa(void *pdev, u8 *mac_addr, u32 mode)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	lmac_set_pauseframe_samode(pdev, mode);
+	lmac_set_pauseframe_addr(pdev, mac_addr);
+
+	/* Program MAC Address */
+	xgmac_set_mac_address(pdev, mac_addr);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return 0;
+}
+
+int mac_get_pfsa(void *pdev, u8 *mac_addr, u32 *mode)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	*mode = lmac_get_pauseframe_samode(pdev);
+	lmac_get_pauseframe_addr(pdev, mac_addr);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return 0;
+}
+
+int mac_set_fcs_gen(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	/* CRC Insertion enable, PAD insertion Disable */
+	if (val == 1)
+		gswss_set_xgmac_crc_ctrl(pdev, 1);
+	else
+		/* CRC and PAD Insertion Disable */
+		gswss_set_xgmac_crc_ctrl(pdev, 2);
+
+	lmac_set_txfcs(pdev, val);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return 0;
+}
+
+int mac_get_fcs_gen(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int tx_fcs = 0;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+
+	tx_fcs = lmac_get_txfcs(pdev);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return tx_fcs;
+}
+
+/*TTSE: Enables the IEEE 1588 hw ts for Tx Frame
+ *OSTC: One step ts correction with ref to ts provided in TTSH and TTSL
+ *OST_AVAIl: It indicates ref ts is available in TTSH and TTSL
+ *CIC:
+ *	0: Csum Insertion disabled
+ *	1: Only IP hdr csum calc and insert enabled
+ *	2: IP hdr csum, Payload csum calc and insertion enabled,
+ *		pseudo hdr csum is not calc in HW
+ *	3: IP hdr csum, Payload csum calc and insertion enabled,
+ *		pseudo hdr csum is calc in HW
+ */
+int mac_enable_onestep_ts(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+	gswss_set_mac_rxtime_op(pdev, MODE1);
+	gswss_set_mac_txsptag_op(pdev, MODE3);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return 0;
+}
+
+int mac_disable_onestep_ts(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->mac_lock);
+#endif
+	gswss_set_mac_rxtime_op(pdev, MODE0);
+	gswss_set_mac_txsptag_op(pdev, MODE0);
+	gswss_set_mac_rxsptag_op(pdev, MODE0);
+
+	xgmac_disable_tstamp(pdev);
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->mac_lock);
+#endif
+
+	return 0;
+}
+
+int mac_get_int_sts(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int val = 0;
+	u32 mac_isr = XGMAC_RGRD(pdata, MAC_ISR);
+	u32 mtl_q_isr = XGMAC_RGRD(pdata, MTL_Q_ISR);
+	u32 lmac_pisr = LMAC_RGRD(pdata, MAC_PISR(pdata->mac_idx));
+
+	//mac_printf("MAC ISR %x MTL ISR %x LMAC Pisr %x\n", mac_isr, mtl_q_isr,
+	//	   lmac_pisr);
+
+	/* XGMAC Mac ISR Status */
+	if (mac_isr) {
+		/* Timestamp interrupt */
+		if (MAC_GET_VAL(mac_isr, MAC_ISR, TSIS))
+			val |= (1 << XGMAC_TSTAMP_EVNT);
+
+		/* LPI interrupt (EEE) */
+		if (MAC_GET_VAL(mac_isr, MAC_ISR, LPIIS))
+			val |= (1 << XGMAC_LPI_EVNT);
+
+		/* transmit error status interrupt */
+		if (MAC_GET_VAL(mac_isr, MAC_ISR, TXESIS))
+			val |= (1 << XGMAC_TXERR_STS_EVNT);
+
+		/* Receive error status interrupt */
+		if (MAC_GET_VAL(mac_isr, MAC_ISR, RXESIS))
+			val |= (1 << XGMAC_RXERR_STS_EVNT);
+
+		/* Power Management interrupt */
+		if (MAC_GET_VAL(mac_isr, MAC_ISR, PMTIS))
+			val |= (1 << XGMAC_PMT_EVNT);
+	}
+
+	/* XGMAC MTL ISR Status */
+	if (mtl_q_isr) {
+		/* Tx Q Overflow Interrupt Enable */
+		if (MAC_GET_VAL(mtl_q_isr, MTL_Q_ISR, TXUNFIS))
+			val |= (1 << XGMAC_TXQ_OVFW_EVNT);
+
+		/* Rx Q Overflow Interrupt Enable */
+		if (MAC_GET_VAL(mtl_q_isr, MTL_Q_ISR, ABPSIS))
+			val |= (1 << XGMAC_RXQ_OVFW_EVNT);
+
+		/* Average bits per slot interrupt enable */
+		if (MAC_GET_VAL(mtl_q_isr, MTL_Q_ISR, RXOVFIS))
+			val |= (1 << XGMAC_AVG_BPS_EVNT);
+	}
+
+	/* LMAC ISR Status */
+	if (lmac_pisr) {
+
+		if (MAC_GET_VAL(lmac_pisr, MAC_PISR, PHYERR))
+			val |= (1 << LMAC_PHYERR_EVNT);
+
+		if (MAC_GET_VAL(lmac_pisr, MAC_PISR, ALIGN))
+			val |= (1 << LMAC_ALIGN_EVNT);
+
+		if (MAC_GET_VAL(lmac_pisr, MAC_PISR, SPEED))
+			val |= (1 << LMAC_SPEED_EVNT);
+
+		if (MAC_GET_VAL(lmac_pisr, MAC_PISR, FDUP))
+			val |= (1 << LMAC_FDUP_EVNT);
+
+		if (MAC_GET_VAL(lmac_pisr, MAC_PISR, RXPAUEN))
+			val |= (1 << LMAC_RXPAUEN_EVNT);
+
+		if (MAC_GET_VAL(lmac_pisr, MAC_PISR, TXPAUEN))
+			val |= (1 << LMAC_TXPAUEN_EVNT);
+
+		if (MAC_GET_VAL(lmac_pisr, MAC_PISR, LPIOFF))
+			val |= (1 << LMAC_LPIOFF_EVNT);
+
+		if (MAC_GET_VAL(lmac_pisr, MAC_PISR, LPION))
+			val |= (1 << LMAC_LPION_EVNT);
+
+		if (MAC_GET_VAL(lmac_pisr, MAC_PISR, JAM))
+			val |= (1 << LMAC_JAM_EVNT);
+
+		if (MAC_GET_VAL(lmac_pisr, MAC_PISR, FCSERR))
+			val |= (1 << LMAC_FCSERR_EVNT);
+
+		if (MAC_GET_VAL(lmac_pisr, MAC_PISR, TXPAUSE))
+			val |= (1 << LMAC_TXPAU_EVNT);
+
+		if (MAC_GET_VAL(lmac_pisr, MAC_PISR, RXPAUSE))
+			val |= (1 << LMAC_RXPAU_EVNT);
+	}
+
+	return val;
+}
+
+
+int mac_init(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+#if defined(PC_UTILITY) || defined(CHIPTEST)
+	int i = 0;
+	xgmac_init_pdata(pdata, -1);
+#endif
+	xgmac_cli_init();
+
+	mac_printf("XGMAC INIT for Module %d\n", pdata->mac_idx);
+
+	/* Initialize MAC related features */
+
+	/* Program MAC Address */
+	xgmac_set_mac_address(pdev, pdata->mac_addr);
+
+	/* Program for Jumbo/Std settings */
+	mac_set_mtu(pdev, pdata->mtu);
+
+	/* TODO: Interrupt enable change to Irq register */
+	/* Configure RWK filter frames */
+
+	populate_filter_frames(pdev);
+
+	/* Program Promisc mode and All multicast mode */
+	xgmac_set_promiscuous_mode(pdev, pdata->promisc_mode);
+
+	/* Program All multicast mode */
+	xgmac_set_all_multicast_mode(pdev, pdata->all_mcast_mode);
+
+
+#ifdef __KERNEL__
+	/* Default enable flow control Rx and TX */
+	mac_set_flowctrl(pdev, 3);
+#endif
+	/* Configure MII for 100M, 10M, 1G and 2.5G to XGMAC by default
+         * default value is LMAC
+         */
+	mac_set_mii_if(pdev, GSW_PORT_HW_GMII);
+
+	if (pdata->haps) {
+		/* Set the link status as UP */
+		mac_set_linksts(pdev, GSW_PORT_LINK_UP);
+
+		/* Set the Duplex as Full Duplex */
+		mac_set_duplex(pdev, GSW_DUPLEX_FULL);
+	} else {
+		/* Set the link status as AUTO */
+		mac_set_linksts(pdev, GSW_PORT_LINK_AUTO);
+
+		/* Set the Duplex as AUTO */
+		mac_set_duplex(pdev, GSW_DUPLEX_AUTO);
+	}
+
+	/* Set LPI TX Automate and LPI Auto Timer Enable to
+	 * overcome packet-drop issue
+	 */
+	xgmac_set_mac_lpitx(pdev, 1);
+
+#if defined(UPTIME) && UPTIME
+
+	if (pdata->mac_idx == 0)
+		xgmac_set_hwtstamp_settings(pdev, 1, 1);
+
+#endif
+
+	/* Configure MAC Speed to 10/2.5/1 G */
+	if (pdata->haps)
+		mac_set_physpeed(pdev, pdata->phy_speed);
+	else
+		mac_set_physpeed(pdev, SPEED_MAC_AUTO);
+
+	/* POWER ON MAC Tx/Rx */
+	xgmac_powerup(pdev);
+
+#ifdef __KERNEL__
+	/* Filter pause frames from XGMAC */
+	xgmac_pause_frame_filtering(pdev, 1);
+#endif
+
+	/* EEE Capability Turn OFF as Aquania OnBoard Phy and SFP+ will go down
+	 * with EEE Capability ON/Auto.
+	 */
+	gswss_set_eee_cap(pdev, EEE_CAP_OFF);
+
+	/* Set XGMAC Port to MDIO Clause 22 */
+	mdio_set_clause(pdev, 1, pdata->mac_idx);
+
+#ifdef __KERNEL__
+	xgmac_mdio_register(pdev);
+#endif
+
+
+	return 0;
+}
+
+/* TRCSTS: MTL Tx Queue Read Controller Status
+ *	This field indicates the state of the Tx Queue Read Controller:
+ *	00 Idle state
+ *	01 Read state (transferring data to the MAC transmitter)
+ *	10 Waiting for pending Tx Status from the MAC transmitter
+ *	11 Flushing the Tx queue because of the Packet Abort request from
+ *	the MAC
+ * TXQSTS: MTL Tx Queue Not Empty Status
+ *	if 1, it indicates that the MTL Tx Queue is not empty
+ *	and some data is left for transmission.
+ * PRXQ: Number of Packets in Receive Queue
+ *	This field indicates the current number of packets in the Rx Queue. The
+ *	theoretical maximum value for this field is 256KB/16B = 16K Packets,
+ *	that is, Max_Queue_Size/Min_Packet_Size.
+ * RXQSTS: MTL Rx Queue Fill-Level Status
+ *	This field gives the status of the fill-level of the Rx Queue:
+ *	00 Rx Queue empty
+ *	01 Rx Queue fill-level below flow-control deactivate threshold
+ *	10 Rx Queue fill-level above flow-control activate threshold
+ *	11 Rx Queue full
+ */
+int mac_exit(void *pdev)
+{
+	u32 mtl_tx_debugq, trcsts, txqsts;
+	u32 mtl_rx_debugq, prxq, rxqsts;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	mtl_tx_debugq = XGMAC_RGRD(pdata, MTL_Q_TQDG);
+	trcsts = MAC_GET_VAL(mtl_tx_debugq, MTL_Q_TQDG, TRCSTS);
+	txqsts = MAC_GET_VAL(mtl_tx_debugq, MTL_Q_TQDG, TXQSTS);
+
+	if ((trcsts != 1) && (txqsts == 0)) {
+		mac_printf("XGMAC EXIT for Module %d\n", pdata->mac_idx);
+		/* POWER OFF MAC Tx/Rx */
+		xgmac_powerdown(pdev);
+	} else
+		mac_printf("Can't Exit XGMAC %d now,data is left for txing\n",
+			   pdata->mac_idx);
+
+	mtl_rx_debugq = XGMAC_RGRD(pdata, MTL_Q_RQDG);
+	prxq = MAC_GET_VAL(mtl_tx_debugq, MTL_Q_RQDG, PRXQ);
+	rxqsts = MAC_GET_VAL(mtl_tx_debugq, MTL_Q_RQDG, RXQSTS);
+
+	if ((prxq == 0) && (rxqsts == 0))
+		mac_printf("All Data is transferred to system memory\n");
+	else
+		mac_printf("ERROR: Data is still txing to system memory\n");
+
+#ifdef __KERNEL__
+	xgmac_mdio_unregister(pdev);
+#endif
+
+	return 0;
+}
+
+
+int mac_int_enable(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct adap_ops *adap_ops = gsw_get_adap_ops(0);
+
+	/* Enable LMAC 2/3/4 Interrupt */
+	lmac_set_int(pdev, 1);
+	/* Enable XGMAC 2/3/4 Interrupt */
+	gswss_set_interrupt(adap_ops, XGMAC, pdata->mac_idx, 1);
+
+	return 0;
+}
+
+
+int mac_int_disable(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct adap_ops *adap_ops = gsw_get_adap_ops(0);
+
+	/* Enable LMAC 2/3/4 Interrupt */
+	lmac_set_int(pdev, 0);
+	/* Enable XGMAC 2/3/4 Interrupt */
+	gswss_set_interrupt(adap_ops, XGMAC, pdata->mac_idx, 0);
+
+	return 0;
+}
+
+int mac_irq_event_enable(void *pdev, GSW_Irq_Op_t *irq)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	/* Enable LMAC and XGMAC Interrupt */
+	mac_int_enable(pdev);
+
+	if (irq->blk == LMAC_BLK) {
+		mac_printf("LMAC %d: mac_irq_enable Event %x\n",
+			   pdata->mac_idx, irq->event);
+		/* Enable LMAC Event Interrupt */
+		lmac_set_event_int(pdev, irq->event, 1);
+	} else if (irq->blk == XGMAC_BLK) {
+		mac_printf("XGMAC %d: mac_irq_enable Event %x\n",
+			   pdata->mac_idx, irq->event);
+		/* Enable XGMAC Event Interrupt */
+		xgmac_set_mac_int(pdev, irq->event, 1);
+	} else {
+		mac_printf("Unsupported MAC Block %d\n", irq->blk);
+		return GSW_statusErr;
+	}
+
+	return 0;
+}
+
+int mac_irq_event_disable(void *pdev, GSW_Irq_Op_t *irq)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	if (irq->blk == LMAC_BLK) {
+		mac_printf("LMAC %d: mac_irq_disable Event %x\n",
+			   pdata->mac_idx, irq->event);
+		/* Disable LMAC Event Interrupt */
+		lmac_set_event_int(pdev, irq->event, 0);
+	} else if (irq->blk == XGMAC_BLK) {
+		mac_printf("XGMAC %d: mac_irq_disable Event %x\n",
+			   pdata->mac_idx, irq->event);
+		/* Disable XGMAC Event Interrupt */
+		xgmac_set_mac_int(pdev, irq->event, 0);
+	} else {
+		mac_printf("Unsupported MAC Block %d\n", irq->blk);
+		return GSW_statusErr;
+	}
+
+	return 0;
+}
+
+int mac_irq_register(void *pdev, GSW_Irq_Op_t *irq)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	if (irq->event >= MAX_IRQ_EVNT) {
+		mac_printf("Wrong Irq event\n");
+		return -1;
+	}
+
+	mac_printf("MAC %d: mac_irq_register Event %x\n",
+		   pdata->mac_idx, irq->event);
+
+	pdata->irq_hdl[irq->event].cb = irq->call_back;
+	pdata->irq_hdl[irq->event].param = irq->param;
+
+	return 0;
+}
+
+int mac_irq_unregister(void *pdev, GSW_Irq_Op_t *irq)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	if (irq->event >= MAX_IRQ_EVNT) {
+		mac_printf("Wrong Irq event\n");
+		return -1;
+	}
+
+	mac_printf("MAC %d: mac_irq_unregister Event %x\n",
+		   pdata->mac_idx, irq->event);
+
+	pdata->irq_hdl[irq->event].cb = NULL;
+	pdata->irq_hdl[irq->event].param = NULL;
+
+	return 0;
+}
+
+int mac_irq_clr(void *pdev, u32 event)
+{
+	switch (event) {
+	case XGMAC_PMT_EVNT:
+		xgmac_pmt_int_clr(pdev);
+		break;
+
+	case XGMAC_TSTAMP_EVNT:
+#ifdef __KERNEL__
+		xgmac_ptp_isr_hdlr(pdev);
+#endif
+		break;
+
+	case XGMAC_LPI_EVNT:
+		xgmac_lpi_int_clr(pdev);
+		break;
+
+	/* These 2 interrupts are cleared by a read RXESIS or TXESIS
+	   Which will be done while reading Interrupt Status */
+	case XGMAC_TXERR_STS_EVNT:
+	case XGMAC_RXERR_STS_EVNT:
+		break;
+
+	case XGMAC_TXQ_OVFW_EVNT:
+	case XGMAC_RXQ_OVFW_EVNT:
+	case XGMAC_AVG_BPS_EVNT:
+		xgmac_clear_mtl_int(pdev, event);
+		break;
+
+	case LMAC_PHYERR_EVNT:
+	case LMAC_ALIGN_EVNT:
+	case LMAC_SPEED_EVNT:
+	case LMAC_FDUP_EVNT:
+	case LMAC_RXPAUEN_EVNT:
+	case LMAC_TXPAUEN_EVNT:
+	case LMAC_LPIOFF_EVNT:
+	case LMAC_LPION_EVNT:
+	case LMAC_JAM_EVNT:
+	case LMAC_FCSERR_EVNT:
+	case LMAC_TXPAU_EVNT:
+	case LMAC_RXPAU_EVNT:
+		lmac_clear_int(pdev, event);
+		break;
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+void mac_init_fn_ptrs(struct mac_ops *mac_op)
+{
+	mac_op->set_flow_ctl = mac_set_flowctrl;
+	mac_op->get_flow_ctl = mac_get_flowctrl;
+
+	mac_op->mac_reset = mac_reset;
+
+	mac_op->set_speed = mac_set_speed;
+	mac_op->get_speed = mac_get_speed;
+
+	mac_op->set_duplex = mac_set_duplex;
+	mac_op->get_duplex = mac_get_duplex;
+
+	mac_op->mac_config_ipg = mac_config_ipg;
+	mac_op->mac_config_loopback = mac_config_loopback;
+
+	mac_op->set_lpi = mac_set_lpien;
+	mac_op->get_lpi = mac_get_lpien;
+
+	mac_op->set_mii_if = mac_set_mii_if;
+	mac_op->get_mii_if = mac_get_mii_if;
+
+	mac_op->set_link_sts = mac_set_linksts;
+	mac_op->get_link_sts = mac_get_linksts;
+
+	mac_op->set_mtu = mac_set_mtu;
+	mac_op->get_mtu = mac_get_mtu;
+
+	mac_op->set_pfsa = mac_set_pfsa;
+	mac_op->get_pfsa = mac_get_pfsa;
+
+	mac_op->set_fcsgen = mac_set_fcs_gen;
+	mac_op->get_fcsgen = mac_get_fcs_gen;
+
+	mac_op->get_int_sts = mac_get_int_sts;
+	mac_op->clr_int_sts = mac_irq_clr;
+
+	mac_op->init_systime = xgmac_init_systime;
+	mac_op->config_addend = xgmac_set_tstamp_addend;
+	mac_op->adjust_systime = xgmac_adjust_systime;
+	mac_op->get_systime = xgmac_get_systime;
+	mac_op->get_tx_tstamp = xgmac_get_tx_tstamp;
+	mac_op->config_hw_time_stamping = xgmac_set_hwtstamp_settings;
+	mac_op->config_subsec_inc = xgmac_config_subsec_inc;
+	mac_op->get_txtstamp_cap_cnt = xgmac_get_txtstamp_cnt;
+
+	mac_op->init = mac_init;
+	mac_op->exit = mac_exit;
+	mac_op->xgmac_cli = xgmac_main;
+	mac_op->lmac_cli = lmac_main;
+	mac_op->xgmac_reg_rd = xgmac_rd_reg;
+	mac_op->xgmac_reg_wr = xgmac_wr_reg;
+	mac_op->lmac_reg_rd = lmac_rd_reg;
+	mac_op->lmac_reg_wr = lmac_wr_reg;
+
+
+	mac_op->mac_int_en = mac_int_enable;
+	mac_op->mac_int_dis = mac_int_disable;
+
+	mac_op->IRQ_Disable = mac_irq_event_disable;
+	mac_op->IRQ_Enable = mac_irq_event_enable;
+	mac_op->IRQ_Register = mac_irq_register;
+	mac_op->IRQ_UnRegister = mac_irq_unregister;
+
+}
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.h b/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.h
new file mode 100644
index 000000000000..46d25a0a7f0b
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.h
@@ -0,0 +1,65 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_CFG_
+#define _MAC_CFG_
+
+#include <xgmac_common.h>
+
+/* MAC Interface API's */
+int mac_config_loopback(void *pdev, u32 loopback);
+int mac_config_ipg(void *pdev, u32 ipg);
+
+int mac_set_mii_if(void *pdev, u32 mii_mode);
+int mac_get_mii_if(void *pdev);
+
+int mac_set_speed(void *pdev, u32 phy_speed);
+int mac_set_physpeed(void *pdev, u32 phy_speed);
+int mac_get_speed(void *pdev);
+
+int mac_set_duplex(void *pdev, u32 val);
+int mac_get_duplex(void *pdev);
+
+int mac_set_mtu(void *pdev, u32 mtu);
+int mac_get_mtu(void *pdev);
+
+int mac_set_pfsa(void *pdev, u8 *mac_addr, u32 mode);
+int mac_get_pfsa(void *pdev, u8 *mac_addr, u32 *mode);
+
+int mac_reset(void *pdev);
+
+int mac_init(void *pdev);
+int mac_exit(void *pdev);
+
+
+int mac_set_flowctrl(void *pdev, u32 val);
+int mac_get_flowctrl(void *pdev);
+
+int mac_set_lpien(void *pdev, u32 enable, u32 lpi_waitg, u32 lpi_waitm);
+int mac_get_lpien(void *pdev);
+
+int mac_set_linksts(void *pdev, u8 linksts);
+int mac_get_linksts(void *pdev);
+
+int mac_set_fcs_gen(void *pdev, u32 val);
+int mac_get_fcs_gen(void *pdev);
+
+int mac_enable_onestep_ts(void *pdev);
+int mac_disable_onestep_ts(void *pdev);
+
+int mac_irq_enable(void *pdev, GSW_Irq_Op_t *irq);
+int mac_irq_disable(void *pdev, GSW_Irq_Op_t *irq);
+int mac_irq_register(void *pdev, GSW_Irq_Op_t *irq);
+int mac_irq_unregister(void *pdev, GSW_Irq_Op_t *irq);
+
+int mac_int_enable(void *pdev);
+int mac_int_disable(void *pdev);
+
+#endif
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c b/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c
new file mode 100644
index 000000000000..e2f41ffe74a2
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c
@@ -0,0 +1,210 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#include <lantiq_soc.h>
+#include <net/switch_api/gsw_dev.h>
+#include <net/switch_api/adap_ops.h>
+#include <gswss_api.h>
+#include <xgmac_common.h>
+#include <xgmac.h>
+#include <lmac_api.h>
+
+static void __iomem *base[2];
+
+static irqreturn_t mac_isr(int irq, void *dev_id)
+{
+	u32 devid = 0;
+	struct adap_ops *adap_ops = gsw_get_adap_ops(devid);
+	struct mac_ops *mac_ops;
+	struct mac_prv_data *pdata;
+	int i = 0, mac_int_sts = 0, lmac_int_sts = 0;
+	u32 max_mac = gsw_get_mac_subifcnt(devid);
+	int task_sched = 0;
+
+	/* Handle all the MAC Interrupts */
+	for (i = 0; i < max_mac; i++) {
+
+		task_sched = 0;
+
+		mac_int_sts = gswss_get_int_stat(adap_ops, XGMAC);
+
+		mac_ops = gsw_get_mac_ops(devid, i);
+		pdata = GET_MAC_PDATA(mac_ops);
+
+		/* Check XGMAC i Interrupts */
+		if (mac_int_sts & (1 << (GSWIPSS_IER0_XGMAC2_POS + i))) {
+
+			/* Disable the XGMAC 2/3/4 Interrupt First */
+			gswss_set_interrupt(adap_ops, XGMAC,
+					    pdata->mac_idx, 0);
+
+			task_sched = 1;
+		}
+
+		lmac_int_sts = lmac_get_int(mac_ops);
+
+		/* Check LMAC i Interrupts */
+		if (lmac_int_sts & (1 << (LMAC_ISR_MAC2_POS + i))) {
+
+			/* Disable the LMAC 2/3/4 Interrupt First */
+			lmac_set_int(mac_ops, 0);
+
+			task_sched = 1;
+		}
+
+		/* Schedule tasklet for this MAC */
+		if (task_sched)
+			tasklet_schedule(&pdata->mac_tasklet);
+	}
+
+
+	return IRQ_HANDLED;
+}
+
+static void mac_irq_tasklet(unsigned long data)
+{
+	int evnt = 0, j = 0;
+	void *param;
+	struct mac_prv_data *pdata = (struct mac_prv_data *)data;
+	struct mac_ops *ops = &pdata->ops;
+
+	/* Get all events available for this idx XGMAC and LMAC events */
+	evnt = ops->get_int_sts(ops);
+
+	if (evnt) {
+		/* Check all events for this MAC */
+		for (j = 0; j < MAX_IRQ_EVNT; j++) {
+			if (evnt & (1 << j)) {
+
+				/* Clear the MAC Interrupt status */
+				ops->clr_int_sts(ops, j);
+
+				/* If callback is registered, return callback */
+				if (pdata->irq_hdl[j].cb) {
+					param = pdata->irq_hdl[j].param;
+					/* Call the Upper level callback */
+					pdata->irq_hdl[j].cb(param);
+				}
+			}
+		}
+
+
+		/* Enable Corresponding XGMAC and LMAC Interrupts back */
+		ops->mac_int_en(ops);
+	}
+
+
+	return;
+}
+
+static int mac_irq_init(struct mac_prv_data *pdata)
+{
+	int ret = 0;
+
+	pdata->irq_hdl = kzalloc(sizeof(struct mac_irq_hdl) * (MAX_IRQ_EVNT - 1),
+				 GFP_KERNEL);
+
+	if (!pdata->irq_hdl) {
+		mac_printf("IRQ handler alloc error\n");
+		return -1;
+	}
+
+	if (pdata->mac_idx == 0) {
+
+		ret = request_irq(pdata->irq_num, mac_isr, 0, "gsw_mac", NULL);
+
+		if (ret) {
+			mac_printf("request_irq Error for MAC - %d", ret);
+			return ret;
+		}
+	}
+
+	tasklet_init(&pdata->mac_tasklet,
+		     mac_irq_tasklet,
+		     (unsigned long)pdata);
+
+	return ret;
+}
+
+static int mac_probe(struct platform_device *pdev)
+{
+	int i = 0;
+	struct resource *res[2];
+	struct gswss *gswdev = dev_get_drvdata(pdev->dev.parent);
+	struct adap_prv_data *adap_pdata = GET_ADAP_PDATA(gswdev->adap_ops);
+	struct mac_prv_data *pdata =
+		GET_MAC_PDATA(platform_get_drvdata(pdev));
+
+	gswdev->mac_dev[pdev->id] = pdev;
+
+	/* Initialize MAC Spin lock */
+	spin_lock_init(&pdata->mac_lock);
+
+	/* load the memory ranges */
+	for (i = 0; i < pdev->num_resources; i++) {
+		res[i] = platform_get_resource(pdev, IORESOURCE_MEM, i);
+
+		if (!res[i]) {
+			pr_info("failed to get resources %d\n", i);
+			return -1;
+		}
+
+		if (pdata->mac_idx == 0)
+			base[i] = devm_ioremap_resource(&pdev->dev, res[i]);
+	}
+
+	/* Update Adaption layer pointer and Lmac base address per Mac private
+	 * data.This is needed since all MAC api's have Private data as argument
+	 */
+	pdata->ss_addr_base = (u32)base[0];
+	adap_pdata->ss_addr_base = (u32)base[0];
+	pdata->lmac_addr_base = (u32)base[1];
+
+	pdata->max_mac = gsw_get_mac_subifcnt(0);
+
+	if (device_property_present(&pdev->dev, "board_type")) {
+		pr_info("Board Type: HAPS\n");
+		pdata->haps = 1;
+	} else
+		pdata->haps = 0;
+
+	/* Init function fointers */
+	mac_init_fn_ptrs(&pdata->ops);
+
+	/* Request IRQ for MAC */
+	mac_irq_init(pdata);
+
+	pr_info("XGMAC INIT %d Started\n", pdata->mac_idx);
+	pdata->ops.init(&pdata->ops);
+	pr_info("XGMAC INIT %d completed\n\n", pdata->mac_idx);
+
+	return 0;
+}
+
+static const struct of_device_id gsw_mac_match[] = {
+	{ .compatible = "intel,gsw_mac" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, gsw_mac_match);
+
+static struct platform_driver gsw_mac_driver = {
+	.probe = mac_probe,
+	.driver = {
+		.name = MAC_DEV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = gsw_mac_match,
+	},
+};
+
+module_platform_driver(gsw_mac_driver);
+
+MODULE_AUTHOR("Intel");
+MODULE_DESCRIPTION("Intel GSW_MAC Device driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h
new file mode 100644
index 000000000000..3a666a88e87b
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h
@@ -0,0 +1,1078 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+/* =========================================================================
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ * The Synopsys DWC ETHER XGMAC Software Driver and documentation (hereinafter
+ * "Software") is an unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto.  Permission is hereby granted,
+ * free of charge, to any person obtaining a copy of this software annotated
+ * with this license and the Software, to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================= */
+
+#ifndef __XGMAC_H__
+#define __XGMAC_H__
+
+#include <xgmac_common.h>
+#include <xgmac_cli.h>
+#include <mac_cfg.h>
+
+#define XGMAC_MIN_PACKET        60
+#define XGMAC_STD_PACKET_MTU    1500
+#define XGMAC_MAX_STD_PACKET    1518
+#define XGMAC_JUMBO_PACKET_MTU  9000
+#define XGMAC_MAX_JUMBO_PACKET  9018
+
+/* Default maximum Gaint Packet Size Limit */
+#define XGMAC_MAX_GPSL			9000
+#define XGMAC_MAX_SUPPORTED_MTU		16380
+#define FALCON_MAX_MTU			10000
+#if defined(CHIPTEST) && CHIPTEST
+#define NULL 0
+#endif
+/* Timestamp support - values based on 50MHz PTP clock
+ *   50MHz => 20 nsec
+ *   1 Mhz => 1000 nsec
+ */
+// PTP Clock in Mhz
+#define PTP_CLK				500
+
+// Seconds value to increment in nsec
+#define XGMAC_TSTAMP_SSINC		(1000 / PTP_CLK)
+#define XGMAC_TSTAMP_SNSINC		0
+
+#define NSEC_TO_SEC			1000000000L
+
+#define MHZ_TO_HZ(val)			((val) * 1000000)
+
+#define XGMAC_CTRL_REG(idx)		(0x1298 + ((idx) * 0x100))
+#define XGMAC_DATA1_REG(idx)		(0x1294 + ((idx) * 0x100))
+#define XGMAC_DATA0_REG(idx)		(0x1290 + ((idx) * 0x100))
+
+/* MAC register offsets */
+#define MAC_TX_CFG			0x0000
+#define MAC_RX_CFG			0x0004
+#define MAC_PKT_FR			0x0008
+#define MAC_TX_FCR			0x0070
+#define MAC_TX_FCR1			0x0074
+#define MAC_TX_FCR2			0x0078
+#define MAC_TX_FCR3			0x007C
+#define MAC_TX_FCR4			0x0080
+#define MAC_TX_FCR5			0x0084
+#define MAC_TX_FCR6			0x0088
+#define MAC_TX_FCR7			0x008C
+#define MAC_RX_FCR			0x0090
+#define MAC_ISR				0x00b0
+#define MAC_IER				0x00b4
+#define MAC_RXTX_STS			0x00b8
+#define MAC_PMT_CSR			0x00c0
+#define MAC_RWK_PFR			0x00c4
+#define MAC_LPI_CSR			0x00d0
+#define MAC_LPI_TCR			0x00d4
+#define MAC_VR				0x0110
+#define MAC_HW_F0			0x011c
+#define MAC_HW_F1			0x0120
+#define MAC_HW_F2			0x0124
+#define MAC_EXTCFG			0x0140
+#define MAC_MACA0HR			0x0300
+#define MAC_MACA0LR			0x0304
+#define MAC_MACA1HR			0x0308
+#define MAC_MACA1LR			0x030c
+#define MAC_TSTAMP_CR			0x0d00
+#define MAC_SUBSEC_INCR			0x0d04
+#define MAC_SYS_TIME_SEC		0x0d08
+#define MAC_SYS_TIME_NSEC		0x0d0c
+#define MAC_SYS_TIME_SEC_UPD		0x0d10
+#define MAC_SYS_TIME_NSEC_UPD		0x0d14
+#define MAC_TSTAMP_ADDNDR		0x0d18
+#define MAC_TSTAMP_STSR			0x0d20
+#define MAC_TXTSTAMP_NSECR		0x0d30
+#define MAC_TXTSTAMP_SECR		0x0d34
+#define MAC_TXTSTAMP_STS		0x0d38
+
+/* MTL register offsets */
+#define MTL_OMR				0x1000
+#define MTL_DBG_CTL			0x1008
+#define MTL_DBG_STS			0x100c
+#define MTL_DBG_DAT			0x1010
+#define MTL_ISR				0x1020
+#define MTL_RQDCM0R			0x1030
+#define MTL_TCPR_MAP0			0x1040
+
+#define MTL_Q_TQOMR			0x1100
+#define MTL_Q_TQUR			0x1104
+#define MTL_Q_TQDG			0x1108
+#define MTL_Q_RQOMR			0x1140
+#define MTL_Q_RQMPOCR			0x1144
+#define MTL_Q_RQDG			0x1148
+#define MTL_Q_RQFCR			0x1150
+#define MTL_Q_IER			0x1170
+#define MTL_Q_ISR			0x1174
+
+
+
+#define MAC_LPS_TLPIEN			0x00000001
+#define MAC_LPS_TLPIEX			0x00000002
+#define MAC_LPS_RLPIEN			0x00000004
+#define MAC_LPS_RLPIEX			0x00000008
+
+/* XGMAC_CTRL_REG */
+#define XGMAC_CTRL_REG_ADDR_POS		0
+#define XGMAC_CTRL_REG_ADDR_WIDTH	14
+#define XGMAC_CTRL_REG_OPMODE_POS	14
+#define XGMAC_CTRL_REG_OPMODE_WIDTH	1
+#define XGMAC_CTRL_REG_BAS_POS		15
+#define XGMAC_CTRL_REG_BAS_WIDTH	1
+
+
+
+/* MAC register entry bit positions and sizes */
+#define MAC_HW_F0_ADDMACADRSEL_POS      18
+#define MAC_HW_F0_ADDMACADRSEL_WIDTH    5
+#define MAC_HW_F0_ARPOFFSEL_POS         9
+#define MAC_HW_F0_ARPOFFSEL_WIDTH       1
+#define MAC_HW_F0_EEESEL_POS            13
+#define MAC_HW_F0_EEESEL_WIDTH          1
+#define MAC_HW_F0_GMIISEL_POS           1
+#define MAC_HW_F0_GMIISEL_WIDTH         1
+#define MAC_HW_F0_MGKSEL_POS            7
+#define MAC_HW_F0_MGKSEL_WIDTH          1
+#define MAC_HW_F0_MMCSEL_POS            8
+#define MAC_HW_F0_MMCSEL_WIDTH          1
+#define MAC_HW_F0_RWKSEL_POS            6
+#define MAC_HW_F0_RWKSEL_WIDTH          1
+#define MAC_HW_F0_RXCOESEL_POS          16
+#define MAC_HW_F0_RXCOESEL_WIDTH        1
+#define MAC_HW_F0_SAVLANINS_POS         27
+#define MAC_HW_F0_SAVLANINS_WIDTH       1
+#define MAC_HW_F0_SMASEL_POS            5
+#define MAC_HW_F0_SMASEL_WIDTH          1
+#define MAC_HW_F0_TSSEL_POS             12
+#define MAC_HW_F0_TSSEL_WIDTH           1
+#define MAC_HW_F0_TSSTSSEL_POS          25
+#define MAC_HW_F0_TSSTSSEL_WIDTH        2
+#define MAC_HW_F0_TXCOESEL_POS          14
+#define MAC_HW_F0_TXCOESEL_WIDTH        1
+#define MAC_HW_F0_VLHASH_POS            4
+#define MAC_HW_F0_VLHASH_WIDTH          1
+#define MAC_HW_F0_VXN_POS		29
+#define MAC_HW_F0_VXN_WIDTH		1
+#define MAC_HW_F0_EDIFFC_POS		30
+#define MAC_HW_F0_EDIFFC_WIDTH		1
+#define MAC_HW_F0_EDMA_POS		31
+#define MAC_HW_F0_EDMA_WIDTH		1
+
+#define MAC_HW_F1_ADDR64_POS            14
+#define MAC_HW_F1_ADDR64_WIDTH          2
+#define MAC_HW_F1_ADVTHWORD_POS         13
+#define MAC_HW_F1_ADVTHWORD_WIDTH       1
+#define MAC_HW_F1_DBGMEMA_POS           19
+#define MAC_HW_F1_DBGMEMA_WIDTH         1
+#define MAC_HW_F1_DCBEN_POS             16
+#define MAC_HW_F1_DCBEN_WIDTH           1
+#define MAC_HW_F1_HASHTBLSZ_POS         24
+#define MAC_HW_F1_HASHTBLSZ_WIDTH       3
+#define MAC_HW_F1_L3L4FNUM_POS          27
+#define MAC_HW_F1_L3L4FNUM_WIDTH        4
+#define MAC_HW_F1_NUMTC_POS             21
+#define MAC_HW_F1_NUMTC_WIDTH           3
+#define MAC_HW_F1_RSSEN_POS             20
+#define MAC_HW_F1_RSSEN_WIDTH           1
+#define MAC_HW_F1_RXFIFOSIZE_POS        0
+#define MAC_HW_F1_RXFIFOSIZE_WIDTH      5
+#define MAC_HW_F1_SPHEN_POS             17
+#define MAC_HW_F1_SPHEN_WIDTH           1
+#define MAC_HW_F1_TSOEN_POS             18
+#define MAC_HW_F1_TSOEN_WIDTH           1
+#define MAC_HW_F1_TXFIFOSIZE_POS        6
+#define MAC_HW_F1_TXFIFOSIZE_WIDTH      5
+#define MAC_HW_F1_OSTEN_POS		11
+#define MAC_HW_F1_OSTEN_WIDTH		1
+#define MAC_HW_F1_PTOEN_POS             12
+#define MAC_HW_F1_PTOEN_WIDTH           1
+
+#define MAC_HW_F2_AUXSNAPNUM_POS        28
+#define MAC_HW_F2_AUXSNAPNUM_WIDTH      3
+#define MAC_HW_F2_PPSOUTNUM_POS         24
+#define MAC_HW_F2_PPSOUTNUM_WIDTH       3
+#define MAC_HW_F2_RXCHCNT_POS           12
+#define MAC_HW_F2_RXCHCNT_WIDTH         4
+#define MAC_HW_F2_RXQCNT_POS            0
+#define MAC_HW_F2_RXQCNT_WIDTH          4
+#define MAC_HW_F2_TXCHCNT_POS           18
+#define MAC_HW_F2_TXCHCNT_WIDTH         4
+#define MAC_HW_F2_TXQCNT_POS            6
+#define MAC_HW_F2_TXQCNT_WIDTH          4
+
+#define MAC_EXTCFG_SBDIOEN_POS		8
+#define MAC_EXTCFG_SBDIOEN_WIDTH	1
+
+#define MAC_IER_TSIE_POS                12
+#define MAC_IER_TSIE_WIDTH              1
+#define MAC_IER_TXESIE_POS              13
+#define MAC_IER_TXESIE_WIDTH            1
+#define MAC_IER_RXESIE_POS              14
+#define MAC_IER_RXESIE_WIDTH            1
+#define MAC_IER_LPIIE_POS               5
+#define MAC_IER_LPIIE_WIDTH             1
+#define MAC_IER_PMTIE_POS               4
+#define MAC_IER_PMTIE_WIDTH             1
+
+#define MAC_ISR_LSI_POS                 0
+#define MAC_ISR_LSI_WIDTH               1
+#define MAC_ISR_SMI_POS                 1
+#define MAC_ISR_SMI_WIDTH               1
+#define MAC_ISR_PMTIS_POS               4
+#define MAC_ISR_PMTIS_WIDTH             1
+#define MAC_ISR_LPIIS_POS               5
+#define MAC_ISR_LPIIS_WIDTH             1
+#define MAC_ISR_MMCRXIS_POS             9
+#define MAC_ISR_MMCRXIS_WIDTH           1
+#define MAC_ISR_MMCTXIS_POS             10
+#define MAC_ISR_MMCTXIS_WIDTH           1
+#define MAC_ISR_TSIS_POS                12
+#define MAC_ISR_TSIS_WIDTH              1
+#define MAC_ISR_TXESIS_POS              13
+#define MAC_ISR_TXESIS_WIDTH            1
+#define MAC_ISR_RXESIS_POS              14
+#define MAC_ISR_RXESIS_WIDTH            1
+#define MAC_ISR_GPIIS_POS               15
+#define MAC_ISR_GPIIS_WIDTH             1
+#define MAC_ISR_LS_POS                  24
+#define MAC_ISR_LS_WIDTH                2
+
+#define MAC_LPI_CSR_TLPIEN_POS      	0
+#define MAC_LPI_CSR_TLPIEN_WIDTH    	1
+#define MAC_LPI_CSR_TLPIEX_POS         	1
+#define MAC_LPI_CSR_TLPIEX_WIDTH       	1
+#define MAC_LPI_CSR_RLPIEN_POS          2
+#define MAC_LPI_CSR_RLPIEN_WIDTH       	1
+#define MAC_LPI_CSR_RLPIEX_POS          3
+#define MAC_LPI_CSR_RLPIEX_WIDTH       	1
+#define MAC_LPI_CSR_LPITXEN_POS          16
+#define MAC_LPI_CSR_LPITXEN_WIDTH        1
+#define MAC_LPI_CSR_LPIATE_POS           20
+#define MAC_LPI_CSR_LPIATE_WIDTH         1
+#define MAC_LPI_CSR_LPITXA_POS           19
+#define MAC_LPI_CSR_LPITXA_WIDTH         1
+#define MAC_LPI_CSR_PLS_POS              17
+#define MAC_LPI_CSR_PLS_WIDTH            1
+
+#define MAC_LPI_TCR_LST_POS              16
+#define MAC_LPI_TCR_LST_WIDTH            10
+#define MAC_LPI_TCR_TWT_POS              0
+#define MAC_LPI_TCR_TWT_WIDTH            16
+
+#define MAC_MACA1HR_AE_POS              31
+#define MAC_MACA1HR_AE_WIDTH            1
+
+#define MAC_PKT_FR_PM_POS                  4
+#define MAC_PKT_FR_PM_WIDTH                1
+#define MAC_PKT_FR_PR_POS                  0
+#define MAC_PKT_FR_PR_WIDTH                1
+#define MAC_PKT_FR_VTFE_POS                16
+#define MAC_PKT_FR_VTFE_WIDTH              1
+#define MAC_PKT_FR_RA_POS                  31
+#define MAC_PKT_FR_RA_WIDTH                1
+#define MAC_PKT_FR_PCF_POS                 6
+#define MAC_PKT_FR_PCF_WIDTH               2
+
+#define MAC_PMT_CSR_PWRDWN_POS		0
+#define MAC_PMT_CSR_PWRDWN_WIDTH	1
+#define MAC_PMT_CSR_MGKPKTEN_POS	1
+#define MAC_PMT_CSR_MGKPKTEN_WIDTH	1
+#define MAC_PMT_CSR_RWKPKTEN_POS	2
+#define MAC_PMT_CSR_RWKPKTEN_WIDTH	1
+#define MAC_PMT_CSR_MGKPRCVD_POS	5
+#define MAC_PMT_CSR_MGKPRCVD_WIDTH	1
+#define MAC_PMT_CSR_RWKPRCVD_POS	6
+#define MAC_PMT_CSR_RWKPRCVD_WIDTH	1
+#define MAC_PMT_CSR_RWKPFE_POS		10
+#define MAC_PMT_CSR_RWKPFE_WIDTH	1
+#define MAC_PMT_CSR_RWKPTR_POS		24
+#define MAC_PMT_CSR_RWKPTR_WIDTH	5
+#define MAC_PMT_CSR_GLBLUCAST_POS	9
+#define MAC_PMT_CSR_GLBLUCAST_WIDTH	1
+#define MAC_PMT_CSR_RWKFILTRST_POS	31
+#define MAC_PMT_CSR_RWKFILTRST_WIDTH	1
+
+#define MAC_TX_FCR_PT_POS               16
+#define MAC_TX_FCR_PT_WIDTH             16
+#define MAC_TX_FCR_TFE_POS              1
+#define MAC_TX_FCR_TFE_WIDTH            1
+#define MAC_TX_FCR_FCB_POS              0
+#define MAC_TX_FCR_FCB_WIDTH            1
+#define MAC_TX_FCR1_PT_POS               16
+#define MAC_TX_FCR1_PT_WIDTH             16
+#define MAC_TX_FCR1_TFE_POS              1
+#define MAC_TX_FCR1_TFE_WIDTH            1
+#define MAC_TX_FCR2_PT_POS               16
+#define MAC_TX_FCR2_PT_WIDTH             16
+#define MAC_TX_FCR2_TFE_POS              1
+#define MAC_TX_FCR2_TFE_WIDTH            1
+#define MAC_TX_FCR3_PT_POS               16
+#define MAC_TX_FCR3_PT_WIDTH             16
+#define MAC_TX_FCR3_TFE_POS              1
+#define MAC_TX_FCR3_TFE_WIDTH            1
+#define MAC_TX_FCR4_PT_POS               16
+#define MAC_TX_FCR4_PT_WIDTH             16
+#define MAC_TX_FCR4_TFE_POS              1
+#define MAC_TX_FCR4_TFE_WIDTH            1
+#define MAC_TX_FCR5_PT_POS               16
+#define MAC_TX_FCR5_PT_WIDTH             16
+#define MAC_TX_FCR5_TFE_POS              1
+#define MAC_TX_FCR5_TFE_WIDTH            1
+#define MAC_TX_FCR6_PT_POS               16
+#define MAC_TX_FCR6_PT_WIDTH             16
+#define MAC_TX_FCR6_TFE_POS              1
+#define MAC_TX_FCR6_TFE_WIDTH            1
+#define MAC_TX_FCR7_PT_POS               16
+#define MAC_TX_FCR7_PT_WIDTH             16
+#define MAC_TX_FCR7_TFE_POS              1
+#define MAC_TX_FCR7_TFE_WIDTH            1
+
+
+#define MAC_RX_CFG_ACS_POS                 1
+#define MAC_RX_CFG_ACS_WIDTH               1
+#define MAC_RX_CFG_CST_POS                 2
+#define MAC_RX_CFG_CST_WIDTH               1
+#define MAC_RX_CFG_DCRCC_POS               3
+#define MAC_RX_CFG_DCRCC_WIDTH             1
+#define MAC_RX_CFG_HDSMS_POS               12
+#define MAC_RX_CFG_HDSMS_WIDTH             3
+#define MAC_RX_CFG_IPC_POS                 9
+#define MAC_RX_CFG_IPC_WIDTH               1
+#define MAC_RX_CFG_JE_POS                  8
+#define MAC_RX_CFG_JE_WIDTH                1
+#define MAC_RX_CFG_LM_POS                  10
+#define MAC_RX_CFG_LM_WIDTH                1
+#define MAC_RX_CFG_RE_POS                  0
+#define MAC_RX_CFG_RE_WIDTH                1
+#define MAC_RX_CFG_WD_POS                  7
+#define MAC_RX_CFG_WD_WIDTH		   1
+#define MAC_RX_CFG_GPSLCE_POS              6
+#define MAC_RX_CFG_GPSLCE_WIDTH		   1
+#define MAC_RX_CFG_GPSL_POS                16
+#define MAC_RX_CFG_GPSL_WIDTH		   14
+
+#define MAC_RX_FCR_PFCE_POS               8
+#define MAC_RX_FCR_PFCE_WIDTH             1
+#define MAC_RX_FCR_RFE_POS                0
+#define MAC_RX_FCR_RFE_WIDTH              1
+#define MAC_RX_FCR_UP_POS                 1
+#define MAC_RX_FCR_UP_WIDTH               1
+
+#define MAC_RXTX_STS_RWT_POS		8
+#define MAC_RXTX_STS_RWT_WIDTH		1
+#define MAC_RXTX_STS_TJT_POS		0
+#define MAC_RXTX_STS_TJT_WIDTH		1
+
+#define MAC_SUBSEC_INCR_SNSINC_POS             8
+#define MAC_SUBSEC_INCR_SNSINC_WIDTH           8
+#define MAC_SUBSEC_INCR_SSINC_POS              16
+#define MAC_SUBSEC_INCR_SSINC_WIDTH            8
+
+#define MAC_SYS_TIME_NSEC_UPD_ADDSUB_POS	31
+#define MAC_SYS_TIME_NSEC_UPD_ADDSUB_WIDTH	1
+#define MAC_SYS_TIME_NSEC_UPD_TSSS_POS		0
+#define MAC_SYS_TIME_NSEC_UPD_TSSS_WIDTH	31
+
+#define MAC_TX_CFG_USS_POS                 31
+#define MAC_TX_CFG_USS_WIDTH               1
+#define MAC_TX_CFG_SS_POS                  29
+#define MAC_TX_CFG_SS_WIDTH                2
+#define MAC_TX_CFG_TE_POS                  0
+#define MAC_TX_CFG_TE_WIDTH                1
+#define MAC_TX_CFG_JD_POS                  16
+#define MAC_TX_CFG_JD_WIDTH		   1
+#define MAC_TX_CFG_IPG_POS                 8
+#define MAC_TX_CFG_IPG_WIDTH		   3
+#define MAC_TX_CFG_IFP_POS                 11
+#define MAC_TX_CFG_IFP_WIDTH		   1
+#define MAC_TX_CFG_G9991EN_POS             28
+#define MAC_TX_CFG_G9991EN_WIDTH	   1
+
+#define MAC_TSTAMP_CR_AV8021ASMEN_POS        28
+#define MAC_TSTAMP_CR_AV8021ASMEN_WIDTH      1
+#define MAC_TSTAMP_CR_SNAPTYPSEL_POS         16
+#define MAC_TSTAMP_CR_SNAPTYPSEL_WIDTH       2
+#define MAC_TSTAMP_CR_TSADDREG_POS           5
+#define MAC_TSTAMP_CR_TSADDREG_WIDTH         1
+#define MAC_TSTAMP_CR_TSCFUPDT_POS           1
+#define MAC_TSTAMP_CR_TSCFUPDT_WIDTH         1
+#define MAC_TSTAMP_CR_TSCTRLSSR_POS          9
+#define MAC_TSTAMP_CR_TSCTRLSSR_WIDTH        1
+#define MAC_TSTAMP_CR_TSENA_POS              0
+#define MAC_TSTAMP_CR_TSENA_WIDTH            1
+#define MAC_TSTAMP_CR_TSENALL_POS            8
+#define MAC_TSTAMP_CR_TSENALL_WIDTH          1
+#define MAC_TSTAMP_CR_TSEVNTENA_POS          14
+#define MAC_TSTAMP_CR_TSEVNTENA_WIDTH        1
+#define MAC_TSTAMP_CR_TSINIT_POS             2
+#define MAC_TSTAMP_CR_TSINIT_WIDTH           1
+#define MAC_TSTAMP_CR_TSIPENA_POS            11
+#define MAC_TSTAMP_CR_TSIPENA_WIDTH          1
+#define MAC_TSTAMP_CR_TSIPV4ENA_POS          13
+#define MAC_TSTAMP_CR_TSIPV4ENA_WIDTH        1
+#define MAC_TSTAMP_CR_TSIPV6ENA_POS          12
+#define MAC_TSTAMP_CR_TSIPV6ENA_WIDTH        1
+#define MAC_TSTAMP_CR_TSMSTRENA_POS          15
+#define MAC_TSTAMP_CR_TSMSTRENA_WIDTH        1
+#define MAC_TSTAMP_CR_TSVER2ENA_POS          10
+#define MAC_TSTAMP_CR_TSVER2ENA_WIDTH        1
+#define MAC_TSTAMP_CR_TXTSSTSM_POS           24
+#define MAC_TSTAMP_CR_TXTSSTSM_WIDTH         1
+#define MAC_TSTAMP_CR_TSTRIG_POS             4
+#define MAC_TSTAMP_CR_TSTRIG_WIDTH           1
+#define MAC_TSTAMP_CR_TSUPDT_POS             3
+#define MAC_TSTAMP_CR_TSUPDT_WIDTH           1
+
+#define MAC_TSTAMP_STSR_ATSNS_POS              25
+#define MAC_TSTAMP_STSR_ATSNS_WIDTH            5
+#define MAC_TSTAMP_STSR_ATSSTM_POS             24
+#define MAC_TSTAMP_STSR_ATSSTM_WIDTH           1
+#define MAC_TSTAMP_STSR_ATSSTN_POS             16
+#define MAC_TSTAMP_STSR_ATSSTN_WIDTH           4
+#define MAC_TSTAMP_STSR_TXTSC_POS              15
+#define MAC_TSTAMP_STSR_TXTSC_WIDTH            1
+#define MAC_TSTAMP_STSR_TTSNS_POS              10
+#define MAC_TSTAMP_STSR_TTSNS_WIDTH            5
+#define MAC_TSTAMP_STSR_TSTRGTERR3_POS         9
+#define MAC_TSTAMP_STSR_TSTRGTERR3_WIDTH       1
+#define MAC_TSTAMP_STSR_TSTARGT3_POS           8
+#define MAC_TSTAMP_STSR_TSTARGT3_WIDTH         1
+#define MAC_TSTAMP_STSR_TSTRGTERR2_POS         7
+#define MAC_TSTAMP_STSR_TSTRGTERR2_WIDTH       1
+#define MAC_TSTAMP_STSR_TSTARGT2_POS           6
+#define MAC_TSTAMP_STSR_TSTARGT2_WIDTH         1
+#define MAC_TSTAMP_STSR_TSTRGTERR1_POS         5
+#define MAC_TSTAMP_STSR_TSTRGTERR1_WIDTH       1
+#define MAC_TSTAMP_STSR_TSTARGT1_POS           4
+#define MAC_TSTAMP_STSR_TSTARGT1_WIDTH         1
+#define MAC_TSTAMP_STSR_TSTRGTERR0_POS         3
+#define MAC_TSTAMP_STSR_TSTRGTERR0_WIDTH       1
+#define MAC_TSTAMP_STSR_TSTARGT0_POS           1
+#define MAC_TSTAMP_STSR_TSTARGT0_WIDTH         1
+#define MAC_TSTAMP_STSR_AUXTSTRIG_POS          2
+#define MAC_TSTAMP_STSR_AUXTSTRIG_WIDTH        1
+#define MAC_TSTAMP_STSR_TSSOVF_POS             0
+#define MAC_TSTAMP_STSR_TSSOVF_WIDTH           1
+
+#define MAC_TXTSTAMP_NSECR_TXTSSTSMIS_POS        31
+#define MAC_TXTSTAMP_NSECR_TXTSSTSMIS_WIDTH      1
+
+#define MAC_TXTSTAMP_STS_PKTID_POS        0
+#define MAC_TXTSTAMP_STS_PKTID_WIDTH      10
+
+#define MAC_VR_SNPSVER_POS              0
+#define MAC_VR_SNPSVER_WIDTH            8
+
+/* MMC register offsets */
+#define MMC_CR                          0x0800
+
+#define MMC_TXOCTETCOUNT_GB_LO          0x0814
+#define MMC_TXFRAMECOUNT_GB_LO          0x081c
+#define MMC_TXBROADCASTFRAMES_G_LO      0x0824
+#define MMC_TXMULTICASTFRAMES_G_LO      0x082c
+#define MMC_TXUNICASTFRAMES_GB_LO       0x0864
+#define MMC_TXMULTICASTFRAMES_GB_LO     0x086c
+#define MMC_TXBROADCASTFRAMES_GB_LO     0x0874
+#define MMC_TXUNDERFLOWERROR_LO         0x087c
+#define MMC_TXOCTETCOUNT_G_LO           0x0884
+#define MMC_TXFRAMECOUNT_G_LO           0x088c
+#define MMC_TXPAUSEFRAMES_LO            0x0894
+#define MMC_TXVLANFRAMES_G_LO           0x089c
+
+#define MMC_RXFRAMECOUNT_GB_LO          0x0900
+#define MMC_RXOCTETCOUNT_GB_LO          0x0908
+#define MMC_RXOCTETCOUNT_G_LO           0x0910
+#define MMC_RXBROADCASTFRAMES_G_LO      0x0918
+#define MMC_RXMULTICASTFRAMES_G_LO      0x0920
+#define MMC_RXCRCERROR_LO               0x0928
+#define MMC_RXRUNTERROR                 0x0930
+#define MMC_RXJABBERERROR               0x0934
+#define MMC_RXUNDERSIZE_G               0x0938
+#define MMC_RXOVERSIZE_G                0x093c
+#define MMC_RXUNICASTFRAMES_G_LO        0x0970
+#define MMC_RXLENGTHERROR_LO            0x0978
+#define MMC_RXOUTOFRANGETYPE_LO         0x0980
+#define MMC_RXPAUSEFRAMES_LO            0x0988
+#define MMC_RXFIFOOVERFLOW_LO           0x0990
+#define MMC_RXVLANFRAMES_GB_LO          0x0998
+#define MMC_RXWATCHDOGERROR             0x09a0
+
+/* MMC register entry bit positions and sizes */
+#define MMC_CR_CR_POS                         0
+#define MMC_CR_CR_WIDTH                       1
+#define MMC_CR_CSR_POS                        1
+#define MMC_CR_CSR_WIDTH                      1
+#define MMC_CR_ROR_POS                        2
+#define MMC_CR_ROR_WIDTH                      1
+#define MMC_CR_MCF_POS                        3
+#define MMC_CR_MCF_WIDTH                      1
+#define MMC_CR_MCT_POS                        4
+#define MMC_CR_MCT_WIDTH                      2
+
+/* MTL register entry bit positions and sizes */
+#define MTL_OMR_ETSALG_POS			5
+#define MTL_OMR_ETSALG_WIDTH			2
+#define MTL_OMR_RAA_POS				2
+#define MTL_OMR_RAA_WIDTH			1
+
+/* MTL queue register entry bit positions and sizes */
+#define MTL_Q_RQMPOCR_MISCNTOVF_POS	     31
+#define MTL_Q_RQMPOCR_MISCNTOVF_WIDTH	      1
+#define MTL_Q_RQMPOCR_MISPKTCNT_POS	     16
+#define MTL_Q_RQMPOCR_MISPKTCNT_WIDTH	     11
+#define MTL_Q_RQMPOCR_OVFCNTOVF_POS	     15
+#define MTL_Q_RQMPOCR_OVFCNTOVF_WIDTH	      1
+#define MTL_Q_RQMPOCR_OVFPKTCNT_POS	     0
+#define MTL_Q_RQMPOCR_OVFPKTCNT_WIDTH	     11
+
+#define MTL_Q_TQUR_UFCNTOVF_POS		     15
+#define MTL_Q_TQUR_UFCNTOVF_WIDTH	      1
+#define MTL_Q_TQUR_UFPKTCNT_POS		      0
+#define MTL_Q_TQUR_UFPKTCNT_WIDTH	     11
+
+#define MTL_Q_RQDR_PRXQ_POS                  16
+#define MTL_Q_RQDR_PRXQ_WIDTH                14
+#define MTL_Q_RQDR_RXQSTS_POS         4
+#define MTL_Q_RQDR_RXQSTS_WIDTH       2
+#define MTL_Q_RQFCR_RFA_POS           1
+#define MTL_Q_RQFCR_RFA_WIDTH         6
+#define MTL_Q_RQFCR_RFD_POS           17
+#define MTL_Q_RQFCR_RFD_WIDTH         6
+#define MTL_Q_RQOMR_EHFC_POS          7
+#define MTL_Q_RQOMR_EHFC_WIDTH        1
+#define MTL_Q_RQOMR_RQS_POS           16
+#define MTL_Q_RQOMR_RQS_WIDTH         9
+#define MTL_Q_RQOMR_RSF_POS           5
+#define MTL_Q_RQOMR_RSF_WIDTH         1
+#define MTL_Q_RQOMR_RTC_POS           0
+#define MTL_Q_RQOMR_RTC_WIDTH         2
+#define MTL_Q_RQOMR_FUP_POS           3
+#define MTL_Q_RQOMR_FUP_WIDTH         1
+#define MTL_Q_RQOMR_FEF_POS           4
+#define MTL_Q_RQOMR_FEF_WIDTH         1
+
+#define MTL_Q_RQDG_PRXQ_POS           16
+#define MTL_Q_RQDG_PRXQ_WIDTH         14
+#define MTL_Q_RQDG_RXQSTS_POS         4
+#define MTL_Q_RQDG_RXQSTS_WIDTH       2
+#define MTL_Q_RQDG_RRCSTS_POS         1
+#define MTL_Q_RQDG_RRCSTS_WIDTH       2
+
+#define MTL_Q_TQOMR_FTQ_POS           0
+#define MTL_Q_TQOMR_FTQ_WIDTH         1
+#define MTL_Q_TQOMR_Q2TCMAP_POS       8
+#define MTL_Q_TQOMR_Q2TCMAP_WIDTH     3
+#define MTL_Q_TQOMR_TQS_POS           16
+#define MTL_Q_TQOMR_TQS_WIDTH         10
+#define MTL_Q_TQOMR_TSF_POS           1
+#define MTL_Q_TQOMR_TSF_WIDTH         1
+#define MTL_Q_TQOMR_TTC_POS           4
+#define MTL_Q_TQOMR_TTC_WIDTH         3
+#define MTL_Q_TQOMR_TXQEN_POS         2
+#define MTL_Q_TQOMR_TXQEN_WIDTH       2
+
+#define MTL_Q_TQDG_TXQSTS_POS		4
+#define MTL_Q_TQDG_TXQSTS_WIDTH		1
+#define MTL_Q_TQDG_TRCSTS_POS		1
+#define MTL_Q_TQDG_TRCSTS_WIDTH		2
+
+#define MTL_Q_IER_TXUIE_POS		0
+#define MTL_Q_IER_TXUIE_WIDTH		1
+#define MTL_Q_IER_ABPSIE_POS		1
+#define MTL_Q_IER_ABPSIE_WIDTH		1
+#define MTL_Q_IER_RXOIE_POS		16
+#define MTL_Q_IER_RXOIE_WIDTH		1
+
+#define MTL_Q_ISR_TXUNFIS_POS		0
+#define MTL_Q_ISR_TXUNFIS_WIDTH		1
+#define MTL_Q_ISR_ABPSIS_POS		1
+#define MTL_Q_ISR_ABPSIS_WIDTH		1
+#define MTL_Q_ISR_RXOVFIS_POS		16
+#define MTL_Q_ISR_RXOVFIS_WIDTH		1
+
+/* MTL DEBUG CONTROL */
+#define MTL_DBG_CTL_FDBGEN_POS		0
+#define MTL_DBG_CTL_FDBGEN_WIDTH	1
+#define MTL_DBG_CTL_DBGMOD_POS		1
+#define MTL_DBG_CTL_DBGMOD_WIDTH	1
+#define MTL_DBG_CTL_PKTSTATE_POS	5
+#define MTL_DBG_CTL_PKTSTATE_WIDTH	2
+#define MTL_DBG_CTL_RSTALL_POS		8
+#define MTL_DBG_CTL_RSTALL_WIDTH	1
+#define MTL_DBG_CTL_RSTSEL_POS		9
+#define MTL_DBG_CTL_RSTSEL_WIDTH	1
+#define MTL_DBG_CTL_FIFORDEN_POS	10
+#define MTL_DBG_CTL_FIFORDEN_WIDTH	1
+#define MTL_DBG_CTL_FIFOWREN_POS	11
+#define MTL_DBG_CTL_FIFOWREN_WIDTH	1
+#define MTL_DBG_CTL_FIFOSEL_POS		12
+#define MTL_DBG_CTL_FIFOSEL_WIDTH	2
+#define MTL_DBG_CTL_PKTIE_POS		14
+#define MTL_DBG_CTL_PKTIE_WIDTH		2
+#define MTL_DBG_CTL_BYTEEN_POS		2
+#define MTL_DBG_CTL_BYTEEN_WIDTH	2
+
+/* MTL DEBUG STATUS */
+#define MTL_DBG_STS_FIFOBUSY_POS	0
+#define MTL_DBG_STS_FIFOBUSY_WIDTH	1
+#define MTL_DBG_STS_PKTSTATE_POS	1
+#define MTL_DBG_STS_PKTSTATE_WIDTH	2
+#define MTL_DBG_STS_PKTI_POS		8
+#define MTL_DBG_STS_PKTI_WIDTH		1
+#define MTL_DBG_STS_LOCR_POS		16
+#define MTL_DBG_STS_LOCR_WIDTH		16
+#define MTL_DBG_STS_BYTEEN_POS		3
+#define MTL_DBG_STS_BYTEEN_WIDTH	2
+
+/* MTL DEBUG DATA */
+#define MTL_DBG_DAT_FDBGDATA_POS	0
+#define MTL_DBG_CTL_FDBGDATA_WIDTH	32
+
+#define MTL_TCPR_MAP0_PSTC0_POS		0
+#define MTL_TCPR_MAP0_PSTC0_WIDTH	8
+
+/* RX THRESHOLD operations */
+#define MTL_RX_THRESHOLD_32		0x01
+#define MTL_RX_THRESHOLD_64             0x00
+#define MTL_RX_THRESHOLD_96             0x02
+#define MTL_RX_THRESHOLD_128            0x03
+#define MTL_TX_THRESHOLD_32             0x01
+#define MTL_TX_THRESHOLD_64             0x00
+#define MTL_TX_THRESHOLD_96             0x02
+#define MTL_TX_THRESHOLD_128            0x03
+#define MTL_TX_THRESHOLD_192            0x04
+#define MTL_TX_THRESHOLD_256            0x05
+#define MTL_TX_THRESHOLD_384            0x06
+#define MTL_TX_THRESHOLD_512            0x07
+
+#define MTL_ETSALG_WRR                  0x00
+#define MTL_ETSALG_WFQ                  0x01
+#define MTL_ETSALG_DWRR                 0x02
+#define MTL_RAA_SP                      0x00
+#define MTL_RAA_WSP                     0x01
+
+enum {
+	XGMAC_256 = 0x0,
+	XGMAC_512 = 0x1,
+	XGMAC_1k = 0x3,
+	XGMAC_2k = 0x7,
+	XGMAC_4k = 0xf,
+	XGMAC_8k = 0x1f,
+	XGMAC_16k = 0x3f,
+	XGMAC_32k = 0x7f
+};
+
+enum {
+	TX_PKT_DATA,
+	TX_CTRL_WORD,
+	TX_SOP_DATA,
+	TX_EOP_DATA,
+};
+
+enum {
+	RX_PKT_DATA,
+	RX_NORMAL_STS,
+	RX_LAST_STS,
+	RX_EOP_DATA
+};
+
+struct _vlan_tag {
+	u32 vlan_tag2: 16;
+	u32 vlan_tag1: 16;
+};
+
+struct _pkt_len_ctrl {
+	u32 vxn: 1;
+	u32 svtv: 1;
+	u32 vtv: 1;
+	u32 vtir: 2;
+	u32 saic: 3;
+	u32 ivtir: 2;
+	u32 cic_ost_avail: 2;
+	u32 ostc: 1;
+	u32 ttse: 1;
+	u32 cpc: 2;
+	u32 ost_avail: 1;
+	u32 res: 11;
+	u32 pl: 5;
+};
+
+struct ctrl_word0 {
+	struct _vlan_tag vlan_tag;
+	struct _pkt_len_ctrl pkt_len_ctrl;
+};
+
+struct ctrl_word1 {
+	u32 ttsh;
+	u32 ttsl;
+};
+
+struct ctrl_word {
+	struct ctrl_word0 w0;
+	struct ctrl_word1 w1;
+};
+
+enum  {
+	XGMAC_SPEED_1000 = 0,
+	XGMAC_SPEED_2500,
+	XGMAC_SPEED_10000,
+	XGMAC_SPEEDS,
+};
+
+#define MASK(reg, field)		(1 << reg##_##field##_POS)
+#define MASK_N_BITS(reg, field)		((1 << (reg##_##field##_WIDTH)) - 1)
+
+
+
+#ifdef __KERNEL__
+static inline u32 XGMAC_IO_R32(struct mac_prv_data *pdata, u16 reg)
+{
+	u32 reg_val;
+	volatile void *xgmac_ctrl_reg  =
+		(volatile void *)(pdata->ss_addr_base + pdata->xgmac_ctrl_reg);
+	volatile void *xgmac_data0_reg =
+		(volatile void *)pdata->ss_addr_base + pdata->xgmac_data0_reg;
+	volatile void *xgmac_data1_reg =
+		(volatile void *)pdata->ss_addr_base + pdata->xgmac_data1_reg;
+
+	ltq_w32((0x8000 | reg), xgmac_ctrl_reg);
+
+	while (1) {
+		if ((ltq_r32(xgmac_ctrl_reg) & 0x8000) == 0)
+			break;
+	}
+
+	reg_val = ((ltq_r32(xgmac_data1_reg) << 16) |
+		   (ltq_r32(xgmac_data0_reg)));
+
+	return reg_val;
+}
+
+static inline void XGMAC_IO_W32(struct mac_prv_data *pdata, u16 reg,
+				u32 val)
+{
+	volatile void *xgmac_ctrl_reg  =
+		(volatile void *)(pdata->ss_addr_base + pdata->xgmac_ctrl_reg);
+	volatile void *xgmac_data0_reg =
+		(volatile void *)(pdata->ss_addr_base + pdata->xgmac_data0_reg);
+	volatile void *xgmac_data1_reg =
+		(volatile void *)(pdata->ss_addr_base + pdata->xgmac_data1_reg);
+
+	ltq_w32(((val & 0xFFFF0000) >> 16), xgmac_data1_reg);
+	ltq_w32((val & 0x0000FFFF), xgmac_data0_reg);
+	ltq_w32((0xC000 | reg), xgmac_ctrl_reg);
+
+	while (1) {
+		if ((ltq_r32(xgmac_ctrl_reg) & 0x8000) == 0)
+			break;
+	}
+}
+#else
+static inline u32 XGMAC_R32(struct mac_prv_data *pdata, u16 reg)
+{
+	u32 reg_val;
+	u32 xgmac_ctrl_reg  = pdata->ss_addr_base + pdata->xgmac_ctrl_reg;
+	u32 xgmac_data0_reg = pdata->ss_addr_base + pdata->xgmac_data0_reg;
+	u32 xgmac_data1_reg = pdata->ss_addr_base + pdata->xgmac_data1_reg;
+
+	REG32(xgmac_ctrl_reg) = (0x8000 | reg);
+
+	while (1) {
+		if ((REG32(xgmac_ctrl_reg) & 0x8000) == 0)
+			break;
+	}
+
+	reg_val = ((REG32(xgmac_data1_reg) << 16) | (REG32(xgmac_data0_reg)));
+
+	return reg_val;
+}
+
+static inline void XGMAC_W32(struct mac_prv_data *pdata, u16 reg, u32 val)
+{
+	u32 xgmac_ctrl_reg  = pdata->ss_addr_base + pdata->xgmac_ctrl_reg;
+	u32 xgmac_data0_reg = pdata->ss_addr_base + pdata->xgmac_data0_reg;
+	u32 xgmac_data1_reg = pdata->ss_addr_base + pdata->xgmac_data1_reg;
+
+	REG32(xgmac_data1_reg) = ((val & 0xFFFF0000) >> 16);
+	REG32(xgmac_data0_reg) = (val & 0x0000FFFF);
+	REG32(xgmac_ctrl_reg) = (0xC000 | reg);
+
+	while (1) {
+		if ((REG32(xgmac_ctrl_reg) & 0x8000) == 0)
+			break;
+	}
+}
+
+#if defined(PC_UTILITY) && PC_UTILITY
+static inline u32 XGMAC_URT_R32(struct mac_prv_data *pdata, u16 reg)
+{
+	u32 reg_val;
+	u32 xgmac_ctrl_reg  = pdata->ss_addr_base + pdata->xgmac_ctrl_reg;
+	u32 xgmac_data0_reg = pdata->ss_addr_base + pdata->xgmac_data0_reg;
+	u32 xgmac_data1_reg = pdata->ss_addr_base + pdata->xgmac_data1_reg;
+	u32 data0_val, data1_val;
+
+	pcuart_reg_wr(xgmac_ctrl_reg, (0x8000 | reg));
+
+	while (1) {
+		pcuart_reg_rd(xgmac_ctrl_reg, &reg_val);
+
+		if ((reg_val & 0x8000) == 0)
+			break;
+	}
+
+	pcuart_reg_rd(xgmac_data1_reg, &data1_val);
+	pcuart_reg_rd(xgmac_data0_reg, &data0_val);
+	reg_val = ((data1_val << 16) | data0_val);
+
+	return reg_val;
+}
+
+static inline void XGMAC_URT_W32(struct mac_prv_data *pdata, u16 reg,
+				 u32 val)
+{
+	u32 xgmac_ctrl_reg  = pdata->ss_addr_base + pdata->xgmac_ctrl_reg;
+	u32 xgmac_data0_reg = pdata->ss_addr_base + pdata->xgmac_data0_reg;
+	u32 xgmac_data1_reg = pdata->ss_addr_base + pdata->xgmac_data1_reg;
+	u32 reg_val;
+
+	pcuart_reg_wr(xgmac_data1_reg, ((val & 0xFFFF0000) >> 16));
+	pcuart_reg_wr(xgmac_data0_reg, (val & 0x0000FFFF));
+	pcuart_reg_wr(xgmac_ctrl_reg, (0xC000 | reg));
+
+	while (1) {
+		pcuart_reg_rd(xgmac_ctrl_reg, &reg_val);
+
+		if ((reg_val & 0x8000) == 0)
+			break;
+	}
+}
+
+#endif
+#endif
+
+static inline u32 XGMAC_RGRD(struct mac_prv_data *pdata, u16 reg)
+{
+	u32 reg_val;
+#if defined(PC_UTILITY) && PC_UTILITY
+	reg_val = XGMAC_URT_R32(pdata, reg);
+#endif
+#if defined(CHIPTEST) && CHIPTEST
+	reg_val = XGMAC_R32(pdata, reg);
+#endif
+#ifdef __KERNEL__
+	reg_val = XGMAC_IO_R32(pdata, reg);
+#endif
+
+	return reg_val;
+}
+
+static inline void XGMAC_RGWR(struct mac_prv_data *pdata, u16 reg, u32 val)
+{
+#if defined(PC_UTILITY) && PC_UTILITY
+	XGMAC_URT_W32(pdata, reg, val);
+#endif
+#if defined(CHIPTEST) && CHIPTEST
+	XGMAC_W32(pdata, reg, val);
+#endif
+#ifdef __KERNEL__
+	XGMAC_IO_W32(pdata, reg, val);
+#endif
+}
+
+#define XGMAC_RGRD_BITS(pdata, reg, field)			\
+	GET_N_BITS(XGMAC_RGRD(pdata, reg),			\
+		   reg##_##field##_POS,				\
+		   reg##_##field##_WIDTH)
+
+#define XGMAC_RGWR_BITS(pdata, reg, field, _val)		\
+	do {							\
+		u32 reg_val = XGMAC_RGRD(pdata, reg);		\
+		SET_N_BITS(reg_val,				\
+			   reg##_##field##_POS,			\
+			   reg##_##field##_WIDTH, (_val));	\
+		XGMAC_RGWR(pdata, reg, reg_val);		\
+	} while (0)
+
+/* Function prototypes*/
+
+/* MTL related features*/
+int xgmac_set_mtl_rx_mode(void *pdev, u32 rx_mode);
+int xgmac_set_mtl_rx_thresh(void *pdev, u32 rx_thresh);
+int xgmac_set_mtl_tx_mode(void *pdev, u32 tx_mode);
+int xgmac_set_mtl_tx_thresh(void *pdev, u32 tx_thresh);
+int xgmac_clear_mtl_int(void *pdev, u32 event);
+int xgmac_set_mtl_int(void *pdev, u32 val);
+int xgmac_flush_tx_queues(void *pdev);
+int xgmac_set_flow_control_threshold(void *pdev,
+				     u32 rfa, u32 rfd);
+int xgmac_set_mmc(void *pdev);
+
+int xgmac_clear_rmon(void *pdev, u32 rmon_reset);
+int xgmac_read_mmc_stats(void *pdev, struct xgmac_mmc_stats *stats);
+int xgmac_set_debug_ctl(void *pdev, u32 dbg_en, u32 dbg_mode);
+int xgmac_set_debug_data(void *pdev, u32 dbg_data);
+int xgmac_tx_debug_data(void *pdev, u32 dbg_pktstate);
+int xgmac_rx_debug_data(void *pdev, u32 *dbg_pktstate, u32 *dbg_byteen);
+int xgmac_set_rx_debugctrl_int(void *pdev, u32 dbg_pktie);
+int xgmac_set_fifo_reset(void *pdev, u32 dbg_rst_sel, u32 dbg_rst_all);
+int xgmac_poll_fifo_sts(void *pdev);
+int xgmac_poll_pkt_rx(void *pdev);
+int xgmac_clr_debug_sts(void *pdev);
+int xgmac_forward_fup_fep_pkt(void *pdev, u32 fup, u32 fef);
+int xgmac_disable_tstamp(void *pdev);
+
+/* MAC related features */
+
+int xgmac_set_loopback(void *pdev, u32 val);
+int xgmac_disable_tx_flow_ctl(void *pdev);
+int xgmac_disable_rx_flow_ctl(void *pdev);
+int xgmac_enable_tx_flow_ctl(void *pdev, u32 pause_time);
+int xgmac_enable_rx_flow_ctl(void *pdev);
+int xgmac_initiate_pause_tx(void *pdev);
+int xgmac_clear_mac_int(void *pdev);
+int xgmac_set_mac_int(void *pdev, u32 event, u32 val);
+int xgmac_set_gmii_speed(void *pdev);
+int xgmac_set_gmii_2500_speed(void *pdev);
+int xgmac_set_xgmii_2500_speed(void *pdev);
+int xgmac_set_xgmii_speed(void *pdev);
+int xgmac_set_promiscuous_mode(void *pdev, u32 val);
+int xgmac_set_all_multicast_mode(void *pdev, u32 val);
+int xgmac_set_mac_address(void *pdev, u8 *mac_addr);
+int xgmac_set_checksum_offload(void *pdev, u32 val);
+int xgmac_set_tstamp_addend(void *pdev, u32 tstamp_addend);
+int xgmac_init_systime(void *pdev, u32 sec, u32 nsec);
+int xgmac_adjust_systime(void *pdev, u32 sec, u32 nsec, u32 add_sub,
+			 u32 one_nsec_accuracy);
+u64 xgmac_get_systime(void *pdev);
+u64 xgmac_get_tx_tstamp(void *pdev);
+int xgmac_config_tstamp(void *pdev, u32 mac_tscr);
+int xgmac_get_hwtstamp_settings(void *pdev,
+				struct hwtstamp_config *config);
+int xgmac_set_hwtstamp_settings(void *pdev, u32 tx_type,
+				u32 rx_filter);
+int xgmac_config_jumbo_pkt(void *pdev, u32 mtu);
+int xgmac_config_std_pkt(void *pdev);
+int xgmac_powerup(void *pdev);
+int xgmac_powerdown(void *pdev);
+int xgmac_config_subsec_inc(void *pdev, u32 ptp_clk);
+void xgmac_ptp_txtstamp_mode(void *pdev,
+			     u32 snaptypesel,
+			     u32 tsmstrena,
+			     u32 tsevntena);
+
+int xgmac_set_eee_mode(void *pdev, u32 val);
+int xgmac_set_eee_pls(void *pdev, u32 val);
+int xgmac_set_eee_timer(void *pdev, u32 twt, u32 lst);
+int xgmac_set_crc_strip_type(void *pdev, u32 val);
+int xgmac_set_acs(void *pdev, u32 val);
+int xgmac_set_ipg(void *pdev, u32 ipg);
+int xgmac_set_magic_pmt(void *pdev, u32 val);
+int xgmac_set_rwk_pmt(void *pdev, u32 val);
+int xgmac_set_extcfg(void *pdev, u32 val);
+void xgmac_set_mac_rxtx(void *pdev, u32 wd, u32 jd);
+int xgmac_set_rwk_filter_registers(void *pdev, u32 count,
+				   u32 *val);
+int xgmac_set_pmt_gucast(void *pdev, u32 val);
+int xgmac_set_ptp_offload(void *pdev, u32 type, u32 val);
+int xgmac_set_ptp_offload_msg_gen(void *pdev, u32 mode);
+int xgmac_set_mac_lpitx(void *pdev, u32 val);
+int xgmac_pause_frame_filtering(void *pdev, u32 val);
+int xgmac_set_gint(void *pdev, u32 val);
+int xgmac_set_rxcrc(void *pdev, u32 val);
+
+/* GET API's */
+int xgmac_get_all_hw_features(void *pdev);
+int xgmac_dbg_eee_status(void *pdev);
+int xgmac_get_priv_data(void *pdev);
+int xgmac_get_stats(void *pdev);
+int xgmac_get_tx_cfg(void *pdev);
+int xgmac_get_counters_cfg(void *pdev);
+int xgmac_get_fifo_size(void *pdev);
+int xgmac_get_flow_control_threshold(void *pdev);
+int xgmac_get_mtl_rx_flow_ctl(void *pdev);
+int xgmac_get_mtl_tx(void *pdev);
+int xgmac_get_tx_threshold(void *pdev);
+int xgmac_get_rx_threshold(void *pdev);
+int xgmac_get_mtl_rx(void *pdev);
+int xgmac_get_mtl_q_alg(void *pdev);
+int xgmac_get_crc_settings(void *pdev);
+int xgmac_get_eee_settings(void *pdev);
+int xgmac_get_mac_settings(void *pdev);
+int xgmac_get_mtu_settings(void *pdev);
+int xgmac_get_checksum_offload(void *pdev);
+int xgmac_get_mac_addr(void *pdev);
+int xgmac_get_mac_rx_mode(void *pdev);
+int xgmac_get_rx_vlan_filtering_mode(void *pdev);
+int xgmac_get_mac_speed(void *pdev);
+int xgmac_get_pause_frame_ctl(void *pdev);
+int xgmac_get_mac_loopback_mode(void *pdev);
+int xgmac_get_tstamp_settings(void *pdev);
+u64 xgmac_get_tx_tstamp(void *pdev);
+int xgmac_get_stats_all(void *pdev);
+int xgmac_get_fup_fep_setting(void *pdev);
+int xgmac_get_int_sts(void *pdev);
+int xgmac_dbg_int_sts(void *pdev);
+int xgmac_get_ipg(void *pdev);
+int xgmac_get_txtstamp_cnt(void *pdev);
+int xgmac_get_txtstamp_pktid(void *pdev);
+
+
+#if defined(CHIPTEST) && CHIPTEST
+u32 xgmac_mmc_read(void *pdev, u32 reg_lo);
+#else
+u64 xgmac_mmc_read(void *pdev, u32 reg_lo);
+#endif
+int xgmac_get_mtl_int_sts(void *pdev);
+int xgmac_dbg_pmt(void *pdev);
+int xgmac_get_debug_sts(void *pdev);
+int xgmac_get_debug_data(void *pdev, u32 *dbg_data);
+int xgmac_get_extcfg(void *pdev);
+int xgmac_get_mac_rxtx_sts(void *pdev);
+int xgmac_get_mtl_missed_pkt_cnt(void *pdev);
+int xgmac_get_mtl_underflow_pkt_cnt(void *pdev);
+int xgmac_get_tstamp_status(void *pdev);
+int xgmac_get_ptp_offload_msg_gen(void *pdev);
+int xgmac_get_ptp_offload(void *pdev);
+u32 xgmac_get_eee_mode(void *pdev);
+int xgmac_get_txtstamp_mode(void *pdev);
+int xgmac_print_system_time(void *pdev);
+
+int xgmac_pmt_int_clr(void *pdev);
+int xgmac_lpi_int_clr(void *pdev);
+int xgmac_ptp_isr_hdlr(void *pdev);
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_cli.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_cli.c
new file mode 100644
index 000000000000..8f54bc79b9af
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_cli.c
@@ -0,0 +1,1018 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+/* =========================================================================
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ * The Synopsys DWC ETHER XGMAC Software Driver and documentation (hereinafter
+ * "Software") is an unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto.  Permission is hereby granted,
+ * free of charge, to any person obtaining a copy of this software annotated
+ * with this license and the Software, to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================= */
+
+
+#include <xgmac.h>
+#include <gswss_mac_api.h>
+#include <lmac_api.h>
+#include <xgmac_mdio.h>
+
+void cli_set_mtl_tx(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_mtl_tx_mode(ops, pdata->tx_sf_mode);
+			xgmac_set_mtl_tx_thresh(ops,
+						pdata->tx_threshold);
+		}
+	} else {
+		xgmac_set_mtl_tx_mode(pdev, pdata->tx_sf_mode);
+		xgmac_set_mtl_tx_thresh(pdev, pdata->tx_threshold);
+	}
+}
+
+void cli_set_mtl_rx(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_mtl_rx_mode(ops, pdata->rx_sf_mode);
+			xgmac_set_mtl_rx_thresh(ops,
+						pdata->rx_threshold);
+		}
+	} else {
+		xgmac_set_mtl_rx_mode(pdev, pdata->rx_sf_mode);
+		xgmac_set_mtl_rx_thresh(pdev, pdata->rx_threshold);
+	}
+}
+
+void cli_flow_ctrl_thresh(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_flow_control_threshold(ops,
+							 pdata->rfa,
+							 pdata->rfd);
+		}
+	} else {
+		xgmac_set_flow_control_threshold(pdev, pdata->rfa, pdata->rfd);
+	}
+}
+
+void cli_set_tstamp_addend(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_tstamp_addend(ops,
+						pdata->tstamp_addend);
+		}
+	} else {
+		xgmac_set_tstamp_addend(pdev, pdata->tstamp_addend);
+	}
+}
+
+void cli_set_tstamp_enable(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			mac_enable_onestep_ts(ops);
+		}
+	} else {
+		mac_enable_onestep_ts(pdev);
+	}
+}
+
+void cli_set_tstamp_disable(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			mac_disable_onestep_ts(ops);
+		}
+	} else {
+		mac_disable_onestep_ts(pdev);
+	}
+}
+
+void cli_set_hwtstamp_settings(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_hwtstamp_settings(ops,
+						    pdata->tstamp_config.tx_type,
+						    pdata->tstamp_config.rx_filter);
+		}
+	} else {
+		xgmac_set_hwtstamp_settings(pdev,
+					    pdata->tstamp_config.tx_type,
+					    pdata->tstamp_config.rx_filter);
+	}
+}
+
+void cli_flush_tx_queues(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_flush_tx_queues(ops);
+		}
+	} else {
+		xgmac_flush_tx_queues(pdev);
+	}
+}
+
+void cli_set_debug_ctl(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_debug_ctl(ops,
+					    pdata->dbg_en, pdata->dbg_mode);
+		}
+	} else {
+		xgmac_set_debug_ctl(pdev, pdata->dbg_en, pdata->dbg_mode);
+	}
+}
+
+void cli_set_tx_debug_data(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_tx_debug_data(ops, pdata->dbg_pktstate);
+		}
+	} else {
+		xgmac_tx_debug_data(pdev, pdata->dbg_pktstate);
+	}
+}
+
+void cli_set_rx_debug_data(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_rx_debug_data(ops,
+					    &pdata->dbg_pktstate,
+					    &pdata->dbg_byteen);
+		}
+	} else {
+		xgmac_rx_debug_data(pdev, &pdata->dbg_pktstate,
+				    &pdata->dbg_byteen);
+	}
+}
+
+void cli_set_debug_data(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_rx_debug_data(ops,
+					    &pdata->dbg_pktstate,
+					    &pdata->dbg_byteen);
+		}
+	} else {
+		xgmac_set_debug_data(pdev, pdata->dbg_data);
+	}
+}
+
+void cli_set_rx_debugctrl_int(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_rx_debugctrl_int(ops,
+						   pdata->dbg_pktie);
+		}
+	} else {
+		xgmac_set_rx_debugctrl_int(pdev, pdata->dbg_pktie);
+	}
+}
+
+void cli_set_fifo_reset(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_fifo_reset(ops,
+					     pdata->dbg_rst_sel,
+					     pdata->dbg_rst_all);
+		}
+	} else {
+		xgmac_set_fifo_reset(pdev, pdata->dbg_rst_sel,
+				     pdata->dbg_rst_all);
+	}
+}
+
+void cli_set_fup_fep_pkt(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_forward_fup_fep_pkt(ops,
+						  pdata->fup, pdata->fef);
+		}
+	} else {
+		xgmac_forward_fup_fep_pkt(pdev, pdata->fup, pdata->fef);
+	}
+}
+
+void cli_set_int(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_mac_int(ops, pdata->enable_mac_int, 1);
+			xgmac_set_mtl_int(ops, pdata->enable_mtl_int);
+		}
+	} else {
+		xgmac_set_mac_int(pdev, pdata->enable_mac_int, 1);
+		xgmac_set_mtl_int(pdev, pdata->enable_mtl_int);
+	}
+}
+
+/* MAC REGISTER SETTINGS */
+void cli_set_mac_enable(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+
+			if (pdata->mac_en)
+				xgmac_powerup(ops);
+			else
+				xgmac_powerdown(ops);
+		}
+	} else {
+		if (pdata->mac_en)
+			xgmac_powerup(pdev);
+		else
+			xgmac_powerdown(pdev);
+	}
+}
+
+void cli_set_mac_address(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_mac_address(ops, pdata->mac_addr);
+		}
+	} else {
+		xgmac_set_mac_address(pdev, pdata->mac_addr);
+	}
+}
+
+void cli_set_mac_rx_mode(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_promiscuous_mode(ops,
+						   pdata->promisc_mode);
+			xgmac_set_all_multicast_mode(ops,
+						     pdata->all_mcast_mode);
+		}
+	} else {
+		xgmac_set_promiscuous_mode(pdev, pdata->promisc_mode);
+		xgmac_set_all_multicast_mode(pdev, pdata->all_mcast_mode);
+	}
+}
+
+void cli_set_mtu(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	mac_printf("MTU going to set %d\n", pdata->mtu);
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			mac_set_mtu(ops, pdata->mtu);
+		}
+	} else {
+		mac_set_mtu(pdev, pdata->mtu);
+	}
+}
+
+void cli_set_pause_frame_ctrl(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+
+			if (pdata->pause_frm_enable) {
+				xgmac_enable_tx_flow_ctl(ops,
+							 pdata->pause_time);
+				xgmac_enable_rx_flow_ctl(ops);
+			} else {
+				xgmac_disable_tx_flow_ctl(ops);
+				xgmac_disable_rx_flow_ctl(ops);
+			}
+		}
+	} else {
+		if (pdata->pause_frm_enable) {
+			xgmac_enable_tx_flow_ctl(pdev, pdata->pause_time);
+			xgmac_enable_rx_flow_ctl(pdev);
+		} else {
+			xgmac_disable_tx_flow_ctl(pdev);
+			xgmac_disable_rx_flow_ctl(pdev);
+		}
+	}
+}
+
+void cli_set_pause_frame_filter(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_pause_frame_filtering(ops,
+						    pdata->pause_filter);
+		}
+	} else {
+		xgmac_pause_frame_filtering(pdev, pdata->pause_filter);
+	}
+}
+
+void cli_initiate_pause_tx(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_initiate_pause_tx(ops);
+		}
+	} else {
+		xgmac_initiate_pause_tx(pdev);
+	}
+}
+
+void cli_set_mac_speed(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			mac_set_physpeed(ops, pdata->phy_speed);
+		}
+	} else {
+		mac_set_physpeed(pdev, pdata->phy_speed);
+	}
+}
+
+void cli_set_duplex_mode(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			mac_set_duplex(ops, pdata->duplex_mode);
+		}
+	} else {
+		mac_set_duplex(pdev, pdata->duplex_mode);
+	}
+}
+
+void cli_set_csum_offload(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_checksum_offload(ops,
+						   pdata->rx_checksum_offload);
+		}
+	} else {
+		xgmac_set_checksum_offload(pdev, pdata->rx_checksum_offload);
+	}
+}
+
+void cli_set_loopback(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			mac_config_loopback(ops, pdata->loopback);
+		}
+	} else {
+		mac_config_loopback(pdev, pdata->loopback);
+	}
+}
+
+void cli_set_eee_mode(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_eee_timer(ops,
+					    pdata->twt, pdata->lst);
+			xgmac_set_eee_mode(ops, pdata->eee_enable);
+		}
+	} else {
+		xgmac_set_eee_timer(pdev, pdata->twt, pdata->lst);
+		xgmac_set_eee_mode(pdev, pdata->eee_enable);
+	}
+}
+
+void cli_set_crc_strip_type(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_crc_strip_type(ops,
+						 pdata->crc_strip_type);
+		}
+	} else {
+		xgmac_set_crc_strip_type(pdev, pdata->crc_strip_type);
+	}
+}
+
+void cli_set_crc_strip_acs(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_acs(ops, pdata->padcrc_strip);
+		}
+	} else {
+		xgmac_set_acs(pdev, pdata->padcrc_strip);
+	}
+}
+
+void cli_set_ipg(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			mac_config_ipg(ops, pdata->ipg);
+		}
+	} else {
+		mac_config_ipg(pdev, pdata->ipg);
+	}
+}
+
+void cli_set_pmt_magic(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_magic_pmt(ops, pdata->magic_pkt_en);
+		}
+	} else {
+		xgmac_set_magic_pmt(pdev, pdata->magic_pkt_en);
+	}
+}
+
+void cli_set_pmt_gucast(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_pmt_gucast(ops, pdata->gucast);
+		}
+	} else {
+		xgmac_set_pmt_gucast(pdev, pdata->gucast);
+	}
+}
+
+void cli_set_pmt_rwk(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_rwk_filter_registers(ops,
+						       pdata->rwk_filter_length,
+						       pdata->rwk_filter_values);
+			xgmac_set_rwk_pmt(ops, pdata->rwk_pkt_en);
+		}
+	} else {
+		xgmac_set_rwk_filter_registers(pdev,
+					       pdata->rwk_filter_length,
+					       pdata->rwk_filter_values);
+		xgmac_set_rwk_pmt(pdev, pdata->rwk_pkt_en);
+	}
+}
+
+int cli_get_rmon(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	if (pdata->set_all)
+		xgmac_get_stats_all(pdev);
+	else
+		xgmac_get_stats(pdev);
+
+	return 0;
+}
+
+/* OTHERS */
+void cli_clear_rmon_all(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_clear_rmon(ops, pdata->rmon_reset);
+		}
+	} else {
+		xgmac_clear_rmon(pdev, pdata->rmon_reset);
+	}
+}
+
+void cli_reset(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			mac_reset(ops);
+		}
+	} else {
+		mac_reset(pdev);
+	}
+}
+
+void cli_init(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			mac_init(ops);
+		}
+	} else {
+		mac_init(pdev);
+	}
+}
+
+void cli_set_extcfg(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_extcfg(ops, pdata->extcfg);
+		}
+	} else {
+		xgmac_set_extcfg(pdev, pdata->extcfg);
+	}
+}
+
+void cli_set_macrxtxcfg(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_mac_rxtx(ops, pdata->wd, pdata->jd);
+		}
+	} else {
+		xgmac_set_mac_rxtx(pdev, pdata->wd, pdata->jd);
+	}
+}
+
+void cli_set_linksts(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			mac_set_linksts(ops, pdata->linksts);
+		}
+	} else {
+		mac_set_linksts(pdev, pdata->linksts);
+	}
+}
+
+void cli_set_lpitx(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_mac_lpitx(ops, pdata->lpitxa);
+		}
+	} else {
+		xgmac_set_mac_lpitx(pdev, pdata->lpitxa);
+	}
+}
+
+void cli_set_mdio_cl(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			mdio_set_clause(ops, pdata->mdio_cl,
+					pdata->phy_id);
+		}
+	} else {
+		mdio_set_clause(pdev, pdata->mdio_cl, pdata->phy_id);
+	}
+}
+
+void cli_mdio_rd_cont(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			print_mdio_rd_cnt(ops,
+					  pdata->dev_adr,
+					  pdata->phy_id,
+					  pdata->phy_reg_st,
+					  pdata->phy_reg_end);
+		}
+	} else {
+		print_mdio_rd_cnt(pdev,
+				  pdata->dev_adr,
+				  pdata->phy_id,
+				  pdata->phy_reg_st,
+				  pdata->phy_reg_end);
+	}
+}
+
+void cli_mdio_rd(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_mdio_single_rd(ops,
+					     pdata->dev_adr,
+					     pdata->phy_id,
+					     pdata->phy_reg,
+					     &pdata->phy_data);
+		}
+	} else {
+		xgmac_mdio_single_rd(pdev,
+				     pdata->dev_adr,
+				     pdata->phy_id,
+				     pdata->phy_reg,
+				     &pdata->phy_data);
+	}
+}
+
+void cli_mdio_wr(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_mdio_single_wr(ops,
+					     pdata->dev_adr,
+					     pdata->phy_id,
+					     pdata->phy_reg,
+					     pdata->phy_data);
+		}
+	} else {
+		xgmac_mdio_single_wr(pdev,
+				     pdata->dev_adr,
+				     pdata->phy_id,
+				     pdata->phy_reg,
+				     pdata->phy_data);
+	}
+}
+
+void cli_set_mdio_int(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			mdio_set_interrupt(ops, pdata->mdio_int);
+		}
+	} else {
+		mdio_set_interrupt(pdev, pdata->mdio_int);
+	}
+}
+
+void cli_set_fcsgen(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			mac_set_fcs_gen(ops, pdata->fcsgen);
+		}
+	} else {
+		mac_set_fcs_gen(pdev, pdata->fcsgen);
+	}
+}
+
+void cli_set_txtstamp_mode(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_ptp_txtstamp_mode(ops,
+						pdata->snaptype,
+						pdata->tsmstrena,
+						pdata->tsevntena);
+		}
+	} else {
+		xgmac_ptp_txtstamp_mode(pdev,
+					pdata->snaptype,
+					pdata->tsmstrena,
+					pdata->tsevntena);
+	}
+}
+
+void cli_set_gint(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_gint(ops, pdata->val);
+		}
+	} else {
+		xgmac_set_gint(pdev, pdata->val);
+	}
+}
+
+void cli_set_rxcrc(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			xgmac_set_rxcrc(ops, pdata->val);
+		}
+	} else {
+		xgmac_set_rxcrc(pdev, pdata->val);
+	}
+}
+void cli_test_all_reg(void *pdev)
+{
+	lmac_test_all_reg(pdev);
+	gswss_test_all_reg(&adap_priv_data);
+}
+
+void cli_rx_packet_slavemode(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	pdata->dbg_pktstate = 0;
+	pdata->dbg_data = 0;
+	pdata->dbg_byteen = 0;
+
+	pdata->dbg_en = 1;
+	pdata->dbg_mode = 0,
+	       xgmac_set_debug_ctl(pdev, pdata->dbg_en, pdata->dbg_mode);
+
+	xgmac_set_rx_debugctrl_int(pdev, 1);
+
+	pdata->dbg_rst_all = 1,
+	       xgmac_set_fifo_reset(pdev, 0, pdata->dbg_rst_all);
+
+	// Poll for the packet data
+	xgmac_poll_pkt_rx(pdata);
+
+	pdata->dbg_pktstate = RX_PKT_DATA;
+	xgmac_rx_debug_data(pdev, &pdata->dbg_pktstate, &pdata->dbg_byteen);
+	xgmac_get_debug_data(pdev, &pdata->dbg_data);
+
+	xgmac_clr_debug_sts(pdev);
+
+	mac_printf("Packet State %x\n", pdata->dbg_pktstate);
+	mac_printf("Byteen %x\n", pdata->dbg_byteen);
+	mac_printf("Dbg Data %x\n", pdata->dbg_data);
+}
+
+void cli_rx_packet_dbgmode(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	pdata->dbg_pktstate = 0;
+	pdata->dbg_data = 0;
+	pdata->dbg_byteen = 0;
+
+	pdata->dbg_en = 1;
+	pdata->dbg_mode = 1,
+
+	       xgmac_set_debug_ctl(pdev, pdata->dbg_en, pdata->dbg_mode);
+
+	pdata->dbg_rst_all = 1,
+	       xgmac_set_fifo_reset(pdev, 0, pdata->dbg_rst_all);
+
+	pdata->dbg_pktstate = RX_PKT_DATA;
+	xgmac_rx_debug_data(pdev, &pdata->dbg_pktstate, &pdata->dbg_byteen);
+	xgmac_get_debug_data(pdev, &pdata->dbg_data);
+
+	mac_printf("Packet State %x\n", pdata->dbg_pktstate);
+	mac_printf("Byteen %x\n", pdata->dbg_byteen);
+	mac_printf("Dbg Data %x\n", pdata->dbg_data);
+}
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_cli.h b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_cli.h
new file mode 100644
index 000000000000..7ef75c34d18f
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_cli.h
@@ -0,0 +1,108 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+/* =========================================================================
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ * The Synopsys DWC ETHER XGMAC Software Driver and documentation (hereinafter
+ * "Software") is an unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto.  Permission is hereby granted,
+ * free of charge, to any person obtaining a copy of this software annotated
+ * with this license and the Software, to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================= */
+
+
+#ifndef _XGMAC_CLI_
+#define _XGMAC_CLI_
+
+#include <xgmac_common.h>
+
+/* CLI SET API's */
+
+void cli_set_mtl_tx(void *pdev);
+void cli_set_mtl_rx(void *pdev);
+void cli_flow_ctrl_thresh(void *pdev);
+void cli_set_tstamp_addend(void *pdev);
+void cli_set_tstamp_enable(void *pdev);
+void cli_set_hwtstamp_settings(void *pdev);
+void cli_flush_tx_queues(void *pdev);
+void cli_set_debug_ctl(void *pdev);
+void cli_set_tx_debug_data(void *pdev);
+void cli_set_rx_debug_data(void *pdev);
+void cli_set_debug_data(void *pdev);
+void cli_set_rx_debugctrl_int(void *pdev);
+void cli_set_fifo_reset(void *pdev);
+void cli_set_fup_fep_pkt(void *pdev);
+void cli_set_int(void *pdev);
+void cli_set_mac_enable(void *pdev);
+void cli_set_mac_address(void *pdev);
+void cli_set_mac_rx_mode(void *pdev);
+void cli_set_mtu(void *pdev);
+void cli_set_pause_frame_ctrl(void *pdev);
+void cli_initiate_pause_tx(void *pdev);
+void cli_set_mac_speed(void *pdev);
+void cli_set_csum_offload(void *pdev);
+void cli_set_loopback(void *pdev);
+void cli_set_eee_mode(void *pdev);
+void cli_set_crc_strip_type(void *pdev);
+void cli_set_crc_strip_acs(void *pdev);
+void cli_set_ipg(void *pdev);
+void cli_set_pmt_magic(void *pdev);
+void cli_set_pmt_rwk(void *pdev);
+void cli_clear_rmon_all(void *pdev);
+void cli_set_duplex_mode(void *pdev);
+void cli_reset(void *pdev);
+void cli_init(void *pdev);
+void cli_test_all_reg(void *pdev);
+void cli_rx_packet_dbgmode(void *pdev);
+void cli_set_extcfg(void *pdev);
+void cli_set_macrxtxcfg(void *pdev);
+void cli_set_pmt_gucast(void *pdev);
+void cli_rx_packet_slavemode(void *pdev);
+void cli_set_ptpoff_settings(void *pdev);
+void cli_set_ptpoff_mode(void *pdev);
+void cli_set_linksts(void *pdev);
+void cli_set_lpitx(void *pdev);
+void cli_set_mdio_cl(void *pdev);
+void cli_mdio_rd(void *pdev);
+void cli_mdio_wr(void *pdev);
+void cli_set_mdio_int(void *pdev);
+void cli_set_fcsgen(void *pdev);
+void cli_mdio_rd_cont(void *pdev);
+void cli_set_tstamp_disable(void *pdev);
+void cli_set_txtstamp_mode(void *pdev);
+int cli_get_rmon(void *pdev);
+void cli_set_pause_frame_filter(void *pdev);
+void cli_set_gint(void *pdev);
+void cli_set_rxcrc(void *pdev);
+
+#endif
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h
new file mode 100644
index 000000000000..66edc6f75615
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h
@@ -0,0 +1,744 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+/* =========================================================================
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ * The Synopsys DWC ETHER XGMAC Software Driver and documentation (hereinafter
+ * "Software") is an unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto.  Permission is hereby granted,
+ * free of charge, to any person obtaining a copy of this software annotated
+ * with this license and the Software, to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================= */
+
+#ifndef __XGMAC_COMMON_H__
+#define __XGMAC_COMMON_H__
+
+//#define CHIPTEST	0
+//#define PC_UTILITY 0
+//#define KERNEL_MODE 1
+//#define CONFIG_SILVER_WORKAROUND 1
+
+#if defined(PC_UTILITY) && PC_UTILITY
+#include <stdio.h>
+#include <string.h>
+#endif
+
+#ifdef __KERNEL__
+#include <linux/unistd.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/err.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sysctl.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/irq.h>
+#include <linux/seq_file.h>
+#include <linux/semaphore.h>
+#include <lantiq.h>
+#include <lantiq_soc.h>
+#include <linux/netdevice.h>
+#include <linux/net_tstamp.h>
+#include <linux/clocksource.h>
+#include <linux/ptp_clock_kernel.h>
+#include <linux/net_tstamp.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/if_ether.h>
+#include <linux/spinlock.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <linux/udp.h>
+#include <linux/skbuff.h>
+#include <linux/if.h>
+#include <linux/export.h>
+#include <net/switch_api/gsw_dev.h>
+#else
+#include <stddef.h>
+#include <lantiq_gsw.h>
+#include <mac_ops.h>
+#include <adap_ops.h>
+#include <types.h>
+#endif
+
+
+#if defined(PC_UTILITY) && PC_UTILITY
+extern int pc_uart_dataread(u32 Offset, u32 *value);
+extern int pc_uart_datawrite(u32 Offset, u32 value);
+extern int pc_uart_dataread_32(u32 Offset, u32 *value);
+extern int pc_uart_datawrite_32(u32 Offset, u32 value);
+
+#endif
+
+#define UPTIME 0
+
+#if defined(PC_UTILITY) && PC_UTILITY
+#define NANOSEC_IN_ONESEC 550000
+#else
+#define NANOSEC_IN_ONESEC 550000
+#endif
+
+#define XGMAC_ARRAY_SIZE(x) (sizeof(x) / sizeof(*(x)))
+
+#define GET_N_BITS(reg, pos, n) \
+	(((reg) >> (pos)) & ((0x1 << (n)) - 1))
+
+#define SET_N_BITS(reg, pos, n, val)                            \
+	do {                                                    \
+		(reg) &= ~(((0x1 << (n)) - 1) << (pos));               \
+		(reg) |= (((val) & ((0x1 << (n)) - 1)) << (pos));     \
+	} while (0)
+
+
+#define MAC_GET_VAL(var, reg, field)				\
+	GET_N_BITS((var),					\
+		   reg##_##field##_POS, 			\
+		   reg##_##field##_WIDTH)
+
+#define MAC_SET_VAL(var, reg, field, val)			\
+	SET_N_BITS((var),					\
+		   reg##_##field##_POS, 			\
+		   reg##_##field##_WIDTH, (val))
+
+#if defined(PC_UTILITY) && PC_UTILITY
+
+/* UART inetrface suppot function */
+static inline void pcuart_reg_rd(u32 regaddr, u32 *data)
+{
+	/* Add customer UART routines*/
+	/* pseudo function */
+	pc_uart_dataread(regaddr, data);
+}
+
+static inline void pcuart_reg_wr(u32 regaddr, u32 data)
+{
+	/* Add customer UART routines*/
+	/* pseudo function */
+	pc_uart_datawrite(regaddr, data);
+}
+
+/* UART inetrface suppot function */
+static inline void pcuart_reg_rd_32(u32 regaddr, u32 *data)
+{
+	/* Add customer UART routines*/
+	/* pseudo function */
+	pc_uart_dataread_32(regaddr, data);
+}
+
+static inline void pcuart_reg_wr_32(u32 regaddr, u32 data)
+{
+	/* Add customer UART routines*/
+	/* pseudo function */
+	pc_uart_datawrite_32(regaddr, data);
+}
+
+#endif /* PC_UTILITY */
+
+#if defined(PC_UTILITY) || defined(CHIPTEST)
+#ifdef SWITCH_SERVER
+extern FILE *g_fp;
+FILE *get_fp(void);
+
+#define mac_printf(...)		\
+	do { FILE *fp;			\
+		fp = (FILE *) get_fp();	\
+		fprintf(fp, __VA_ARGS__); \
+	} while (0)
+#else
+#define mac_printf printf
+#endif
+#else
+#define mac_printf printk
+#endif
+
+static inline int mac_nstrlen(char *s)
+{
+	int cnt = 0;
+
+	if (s == (void *)0)
+		return 0;
+
+	while (s[cnt])
+		cnt++;
+
+	return cnt;
+}
+
+static inline unsigned long mac_nstrtoul(const char *s, int len,
+		u32 *next_idx)
+{
+	unsigned long acc;
+	int cnt = 0;
+	char c;
+	int base = 0;
+
+	acc = 0;
+
+	c = s[cnt];
+
+	if (s[cnt] == '0') {
+		cnt++;
+
+		if ((s[cnt] == 'x') || (s[cnt] == 'X')) {
+			base = 16;
+			cnt++;
+		}
+	}
+
+	if (!base)
+		base = 10;
+
+	for (; cnt < len; cnt++) {
+		c = s[cnt];
+
+		if ((c >= '0') && (c <= '9'))
+			c -= '0';
+		else if ((c >= 'a') && (c <= 'f'))
+			c -= 'a' - 10;
+		else if ((c >= 'A') && (c <= 'F'))
+			c -= 'A' - 10;
+		else
+			c = 0;
+
+		acc *= base;
+		acc += c;
+	}
+
+	(*next_idx)++;
+
+	return acc;
+}
+
+enum {
+	MAC_AUTO_DPLX = 0,
+	MAC_FULL_DPLX,
+	MAC_RES_DPLX,
+	MAC_HALF_DPLX,
+};
+
+enum {
+	SPEED_10M = 0,
+	SPEED_100M,
+	SPEED_1G,
+	SPEED_10G,
+	SPEED_2G5,
+	SPEED_5G,
+	SPEED_FLEX,
+	SPEED_AUTO
+};
+
+enum {
+	SPEED_LMAC_10M = 0,
+	SPEED_LMAC_100M,
+	SPEED_LMAC_200M,
+	SPEED_LMAC_1G,
+	SPEED_XGMAC_10M,
+	SPEED_XGMAC_100M,
+	SPEED_XGMAC_1G,
+	SPEED_XGMII_25G,
+	SPEED_XGMAC_5G,
+	SPEED_XGMAC_10G,
+	SPEED_GMII_25G,
+	SPEED_MAC_AUTO,
+};
+
+/* In Linux below struct and enum is defined in net_tstamp.h */
+#if defined(PC_UTILITY) || defined(CHIPTEST)
+struct hwtstamp_config {
+	int flags;
+	int tx_type;
+	int rx_filter;
+};
+
+/* possible values for hwtstamp_config->tx_type */
+enum hwtstamp_tx_types {
+	/* No outgoing packet will need hardware time stamping;
+	 * should a packet arrive which asks for it, no hardware
+	 * time stamping will be done.
+	 */
+	HWTSTAMP_TX_OFF,
+
+	/* Enables hardware time stamping for outgoing packets;
+	 * the sender of the packet decides which are to be
+	 * time stamped by setting %SOF_TIMESTAMPING_TX_SOFTWARE
+	 * before sending the packet.
+	 */
+	HWTSTAMP_TX_ON,
+
+	/* Enables time stamping for outgoing packets just as
+	 * HWTSTAMP_TX_ON does, but also enables time stamp insertion
+	 * directly into Sync packets. In this case, transmitted Sync
+	 * packets will not received a time stamp via the socket error
+	 * queue.
+	 */
+	HWTSTAMP_TX_ONESTEP_SYNC,
+};
+
+/* possible values for hwtstamp_config->rx_filter */
+enum hwtstamp_rx_filters {
+	/* time stamp no incoming packet at all */
+	HWTSTAMP_FILTER_NONE = 0,
+
+	/* time stamp any incoming packet */
+	HWTSTAMP_FILTER_ALL = 1,
+
+	/* return value: time stamp all packets requested plus some others */
+	HWTSTAMP_FILTER_SOME = 2,
+
+	/* PTP v1, UDP, any kind of event packet */
+	HWTSTAMP_FILTER_PTP_V1_L4_EVENT = 3,
+	/* PTP v1, UDP, Sync packet */
+	HWTSTAMP_FILTER_PTP_V1_L4_SYNC = 4,
+	/* PTP v1, UDP, Delay_req packet */
+	HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ = 5,
+	/* PTP v2, UDP, any kind of event packet */
+	HWTSTAMP_FILTER_PTP_V2_L4_EVENT = 6,
+	/* PTP v2, UDP, Sync packet */
+	HWTSTAMP_FILTER_PTP_V2_L4_SYNC = 7,
+	/* PTP v2, UDP, Delay_req packet */
+	HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ = 8,
+
+	/* 802.AS1, Ethernet, any kind of event packet */
+	HWTSTAMP_FILTER_PTP_V2_L2_EVENT = 9,
+	/* 802.AS1, Ethernet, Sync packet */
+	HWTSTAMP_FILTER_PTP_V2_L2_SYNC = 10,
+	/* 802.AS1, Ethernet, Delay_req packet */
+	HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ = 11,
+
+	/* PTP v2/802.AS1, any layer, any kind of event packet */
+	HWTSTAMP_FILTER_PTP_V2_EVENT = 12,
+	/* PTP v2/802.AS1, any layer, Sync packet */
+	HWTSTAMP_FILTER_PTP_V2_SYNC = 13,
+	/* PTP v2/802.AS1, any layer, Delay_req packet */
+	HWTSTAMP_FILTER_PTP_V2_DELAY_REQ = 14,
+};
+
+#endif
+
+enum {
+	PTP_RX_OVER_IPV4_UDP = 0x1,
+	PTP_RX_OVER_IPV6_UDP = 0x2,
+	PTP_RX_OVER_ETH      = 0x4,
+	PTP_RX_OVER_ANY_LYR  = 0x8,
+	PTP_RX_V2			 = 0x10,
+	PTP_RX_MSG_TYPE		 = 0x20,
+	PTP_RX_EVNT		     = 0x40,
+	PTP_RX_SNAP		     = 0x80,
+	PTP_RX_MSTR		     = 0x100,
+	PTP_RX_EN_ALL		 = 0x400,
+};
+
+struct ptp_flags {
+	u32 ptp_rx_en;
+	u32 ptp_tx_en;
+};
+
+#if defined(CHIPTEST) && CHIPTEST
+struct xgmac_mmc_stats {
+	/* Tx Stats */
+	u32 txoctetcount_gb;
+	u32 txframecount_gb;
+	u32 txbroadcastframes_g;
+	u32 txmulticastframes_g;
+	u32 txunicastframes_gb;
+	u32 txmulticastframes_gb;
+	u32 txbroadcastframes_gb;
+	u32 txunderflowerror;
+	u32 txoctetcount_g;
+	u32 txframecount_g;
+	u32 txpauseframes;
+	u32 txvlanframes_g;
+
+	/* Rx Stats */
+	u32 rxframecount_gb;
+	u32 rxoctetcount_gb;
+	u32 rxoctetcount_g;
+	u32 rxbroadcastframes_g;
+	u32 rxmulticastframes_g;
+	u32 rxcrcerror;
+	u32 rxrunterror;
+	u32 rxjabbererror;
+	u32 rxundersize_g;
+	u32 rxoversize_g;
+	u32 rxunicastframes_g;
+	u32 rxlengtherror;
+	u32 rxoutofrangetype;
+	u32 rxpauseframes;
+	u32 rxfifooverflow;
+	u32 rxvlanframes_gb;
+	u32 rxwatchdogerror;
+};
+#else
+struct xgmac_mmc_stats {
+	/* Tx Stats */
+	u64 txoctetcount_gb;
+	u64 txframecount_gb;
+	u64 txbroadcastframes_g;
+	u64 txmulticastframes_g;
+	u64 txunicastframes_gb;
+	u64 txmulticastframes_gb;
+	u64 txbroadcastframes_gb;
+	u64 txunderflowerror;
+	u64 txoctetcount_g;
+	u64 txframecount_g;
+	u64 txpauseframes;
+	u64 txvlanframes_g;
+
+	/* Rx Stats */
+	u64 rxframecount_gb;
+	u64 rxoctetcount_gb;
+	u64 rxoctetcount_g;
+	u64 rxbroadcastframes_g;
+	u64 rxmulticastframes_g;
+	u64 rxcrcerror;
+	u64 rxrunterror;
+	u64 rxjabbererror;
+	u64 rxundersize_g;
+	u64 rxoversize_g;
+	u64 rxunicastframes_g;
+	u64 rxlengtherror;
+	u64 rxoutofrangetype;
+	u64 rxpauseframes;
+	u64 rxfifooverflow;
+	u64 rxvlanframes_gb;
+	u64 rxwatchdogerror;
+};
+
+#endif
+/* This structure contains flags that indicate what hardware features
+ * or configurations are present in the device.
+ */
+struct xgmac_hw_features {
+	/* HW Version */
+	u32 version;
+
+	/* HW Feature Register0 */
+	u32 gmii;              /* 1000 Mbps support */
+	u32 vlhash;            /* VLAN Hash Filter */
+	u32 sma;               /* SMA(MDIO) Interface */
+	u32 rwk;               /* PMT remote wake-up packet */
+	u32 mgk;               /* PMT magic packet */
+	u32 mmc;               /* RMON module */
+	u32 aoe;               /* ARP Offload */
+	u32 ts;                /* IEEE 1588-2008 Advanced Timestamp */
+	u32 eee;               /* Energy Efficient Ethernet */
+	u32 tx_coe;            /* Tx Checksum Offload */
+	u32 rx_coe;            /* Rx Checksum Offload */
+	u32 addn_mac;          /* Additional MAC Addresses */
+	u32 ts_src;            /* Timestamp Source */
+	u32 sa_vlan_ins;       /* Source Address or VLAN Insertion */
+	u32 vxn;				/* VxLAN/NVGRE Support */
+	u32 ediffc;			/* Different Descriptor Cache */
+	u32 edma;				/* Enhanced DMA */
+
+	/* HW Feature Register1 */
+	u32 rx_fifo_size;      /* MTL Receive FIFO Size */
+	u32 tx_fifo_size;      /* MTL Transmit FIFO Size */
+	u32 osten;      		/* One-Step Timestamping Enable */
+	u32 ptoen;      		/* PTP Offload Enable */
+	u32 adv_ts_hi;         /* Advance Timestamping High Word */
+	u32 dma_width;         /* DMA width */
+	u32 dcb;               /* DCB Feature */
+	u32 sph;               /* Split Header Feature */
+	u32 tso;               /* TCP Segmentation Offload */
+	u32 dma_debug;         /* DMA Debug Registers */
+	u32 rss;               /* Receive Side Scaling */
+	u32 tc_cnt;            /* Number of Traffic Classes */
+	u32 hash_table_size;   /* Hash Table Size */
+	u32 l3l4_filter_num;   /* Number of L3-L4 Filters */
+
+	/* HW Feature Register2 */
+	u32 rx_q_cnt;          /* Number of MTL Receive Queues */
+	u32 tx_q_cnt;          /* Number of MTL Transmit Queues */
+	u32 rx_ch_cnt;         /* Number of DMA Receive Channels */
+	u32 tx_ch_cnt;         /* Number of DMA Transmit Channels */
+	u32 pps_out_num;       /* Number of PPS outputs */
+	u32 aux_snap_num;      /* Number of Aux snapshot inputs */
+};
+
+struct mac_irq_hdl {
+	u32 irq_event;
+	void (*cb)(void *);
+	void *param;
+};
+
+
+/* do forward declaration of private data structure */
+struct mac_prv_data;
+
+struct mac_prv_data {
+	/* Lmac addr base */
+	u32 lmac_addr_base;
+
+	/* XGMAC registers for indirect accessing */
+	u32 xgmac_ctrl_reg;
+	u32 xgmac_data0_reg;
+	u32 xgmac_data1_reg;
+
+	/* Adaption layer private data */
+	u32 ss_addr_base;
+	/* Index to point XGMAC 2/3/4 */
+	u32 mac_idx;
+
+	/* TX/RX Queues supported by HW */
+	u32 tx_q_count;
+	u32 rx_q_count;
+
+	/* Tx settings */
+	u32 tx_sf_mode;
+	u32 tx_threshold;
+
+	/* Rx settings */
+	u32 rx_sf_mode;
+	u32 rx_threshold;
+
+	/* Flow control settings */
+	u32 pause_autoneg;
+	u32 tx_pause;
+	u32 rx_pause;
+	u32 pause_time;
+	u32 pause_frm_enable;
+	u32 pause_filter;
+
+	u32 mac_en;
+
+	/* MAC Addr */
+	u8 mac_addr[6];
+
+	/* Rmon related settings */
+	struct xgmac_mmc_stats mmc_stats;
+	u32 rmon_reset;
+
+	/* Timestamp support */
+	struct hwtstamp_config tstamp_config;
+	struct ptp_flags ptp_flgs;
+	u32 def_addend;
+	u32 tstamp_addend;
+	u64 tx_tstamp;
+	u32 sec;
+	u32 nsec;
+	u32 one_nsec_accuracy;
+	u32 two_step;
+	u32 cic;
+	u32 rec_id;
+#ifdef __KERNEL__
+	/* will be pointing to skb which is
+	 * queued for transmission and device
+	 * will take timesstamp for this skb
+	 */
+	struct device *dev;
+	struct sk_buff *ptp_tx_skb;
+	struct work_struct ptp_tx_work;
+	struct ptp_clock_info ptp_clk_info;
+	spinlock_t ptp_lock;
+	struct ptp_clock *ptp_clock;
+	u32 ptp_tx_init;
+	spinlock_t mac_lock;
+	struct mii_bus *mii;
+	struct phy_device *phydev;
+	struct tasklet_struct mac_tasklet;
+#endif
+	u32 snaptype;
+	u32 tsmstrena;
+	u32 tsevntena;
+	u32 ttse;
+	u32 ostc;
+	u32 ostc_avail;
+
+	/* Hardware features of the device */
+	struct xgmac_hw_features hw_feat;
+
+	/* MAC rx mode */
+	u32 promisc_mode;
+	u32 all_mcast_mode;
+
+	u32 rfa;
+	u32 rfd;
+
+	u32 tx_mtl_alg;
+	u32 rx_mtl_alg;
+
+	u32 mtu;
+
+	u32 rx_checksum_offload;
+
+	/* Reg Read/Write */
+	u16 reg_off;
+	u32 reg_val;
+
+	/* Phy status */
+	u32 phy_speed;
+	u32 phymode_speed;
+	u32 phy_link;
+	const char *phy_mode;
+
+	/* Loopback */
+	u32 loopback;
+
+	/* EEE mode */
+	u32 eee_enable;
+	u32 twt;
+	u32 lst;
+	u32 lpitxa;
+
+	/* CRC stripping */
+	u32 crc_strip;
+	u32 crc_strip_type;
+	u32 padcrc_strip;
+
+	/* Debug Mode */
+	u32 dbg_en;
+	u32 dbg_pktie;
+	u32 dbg_rst_sel;
+	u32 dbg_rst_all;
+	u32 dbg_pktstate;
+	u32 dbg_data;
+	u32 dbg_mode;
+	u32 dbg_byteen;
+
+	/* Forward Error paackets */
+	u32 fef;
+	u32 fup;
+
+	/* interrupts */
+	u32 enable_mac_int;
+	u32 enable_mtl_int;
+
+	/* IPG */
+	u32 ipg;
+
+	/* PMT */
+	u32 magic_pkt_en;
+	u32 rwk_pkt_en;
+	u32 rwk_filter_values[8];
+	u32 rwk_filter_length;
+	u32 gucast;
+
+	u32 extcfg;
+
+	u32 set_all;
+	u32 duplex_mode;
+
+	u32 init_val;
+
+	u32 jd;
+	u32 wd;
+
+	u32 linksts;
+
+	u32 fcsgen;
+
+	u32 mdio_cl;
+	u32 dev_adr;
+	u32 phy_id;
+	u32 phy_reg;
+	u32 phy_reg_st;
+	u32 phy_reg_end;
+	u32 phy_data;
+	u32 mdio_int;
+
+	u32 phyadr;
+	u32 bus_id;
+
+	u32 ptp_clk;
+
+	u32 val;
+	/* Maximum number of MAC present */
+	u32 max_mac;
+
+	/* MAC IRQ Number */
+	u32 irq_num;
+
+	/* haps=1, if board is HAPS, else 0 */
+	u32 haps;
+
+	/* MAC IRQ handler */
+	struct mac_irq_hdl *irq_hdl;
+
+	struct mac_ops ops;
+};
+
+extern struct mac_prv_data prv_data[10];
+
+#if defined(PC_UTILITY) || defined(CHIPTEST)
+#define container_of(ptr, type, member) ({                      \
+		const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
+		(type *)( (char *)__mptr - offsetof(type,member) );})
+#endif
+
+static inline struct mac_prv_data *GET_MAC_PDATA(void *pdev)
+{
+	struct mac_prv_data *pdata;
+
+	struct mac_ops *mac_op = (struct mac_ops *)pdev;
+	pdata = container_of(mac_op, struct mac_prv_data, ops);
+
+	return pdata;
+}
+
+#if defined(PC_UTILITY) || defined(CHIPTEST)
+struct adap_ops *gsw_get_adap_ops(u32 devid);
+struct mac_ops *gsw_get_mac_ops(u32 devid, u32 mac_idx);
+u32 gsw_get_mac_subifcnt(u32 devid);
+#endif
+
+int xgmac_main(u32 argc, u8 *argv[]);
+int gswss_main(u32 argc, u8 *argv[]);
+int lmac_main(u32 argc, u8 *argv[]);
+void lmac_wr_reg(void *pdev, u32 reg_off, u32 reg_val);
+u32 lmac_rd_reg(void *pdev, u32 reg_off);
+void xgmac_wr_reg(void *pdev, u16 reg_off, u32 reg_val);
+u32 xgmac_rd_reg(void *pdev, u16 reg_off);
+void gswss_wr_reg(void *pdev, u32 reg_off, u32 reg_val);
+u32 gswss_rd_reg(void *pdev, u32 reg_off);
+void mac_init_fn_ptrs(struct mac_ops *mac_op);
+int xgmac_init(void *pdev);
+int xgmac_exit(void *pdev);
+void xgmac_init_pdata(struct mac_prv_data *pdata, int idx);
+int xgmac_get_all_hw_settings(void *pdev);
+void xgmac_cli_init(void);
+int populate_filter_frames(void *pdev);
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_debug.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_debug.c
new file mode 100644
index 000000000000..a74bc63b7fcf
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_debug.c
@@ -0,0 +1,2258 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+/* =========================================================================
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ * The Synopsys DWC ETHER XGMAC Software Driver and documentation (hereinafter
+ * "Software") is an unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto.  Permission is hereby granted,
+ * free of charge, to any person obtaining a copy of this software annotated
+ * with this license and the Software, to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================= */
+
+
+#include <xgmac.h>
+#include <gswss_mac_api.h>
+
+int xgmac_get_tx_cfg(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 txq_en;
+
+	mac_printf("XGMAC %d: MTL_Q CFG\n", pdata->mac_idx);
+
+	txq_en = XGMAC_RGRD_BITS(pdata, MTL_Q_TQOMR, TXQEN);
+	mac_printf("\tMTL TX Q is %s by default\n",
+		   txq_en ? "ENABLED" : "DISABLED");
+
+	return 0;
+}
+
+int xgmac_get_counters_cfg(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 ror = 0;
+
+	ror = XGMAC_RGRD_BITS(pdata, MMC_CR, ROR);
+
+	mac_printf("XGMAC %d: RMON_CFG\n", pdata->mac_idx);
+
+	if (ror)
+		mac_printf("\tMMC mode: Counters reset to zero after read\n");
+	else
+		mac_printf("\tCounters will not get to Zero after a read\n");
+
+	return 0;
+}
+
+int xgmac_get_fifo_size(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 rx_fifo_size, tx_fifo_size;
+
+	mac_printf("XGMAC %d: FIFO SIZE\n", pdata->mac_idx);
+
+	rx_fifo_size = XGMAC_RGRD_BITS(pdata, MTL_Q_RQOMR, RQS);
+	tx_fifo_size = XGMAC_RGRD_BITS(pdata, MTL_Q_TQOMR, TQS);
+
+	rx_fifo_size = ((rx_fifo_size + 1) * 256);
+	tx_fifo_size = ((tx_fifo_size + 1) * 256);
+
+	mac_printf("\tRX Q, RQS %d byte fifo per queue\n",  rx_fifo_size);
+	mac_printf("\tTX Q, TQS %d byte fifo per queue\n",  tx_fifo_size);
+	return 0;
+}
+
+int xgmac_get_flow_control_threshold(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 fifo_size, rx_fc, rfa, rfd;
+
+	mac_printf("XGMAC %d: MTL FLOW Control Thresh\n", pdata->mac_idx);
+
+	fifo_size = XGMAC_RGRD_BITS(pdata, MTL_Q_RQOMR, RQS);
+	fifo_size = ((fifo_size + 1) * 256);
+	rx_fc = XGMAC_RGRD_BITS(pdata, MTL_Q_RQOMR, EHFC);
+	rfa = XGMAC_RGRD_BITS(pdata, MTL_Q_RQFCR, RFA);
+	rfd = XGMAC_RGRD_BITS(pdata, MTL_Q_RQFCR, RFD);
+
+	mac_printf("\tRX Q, RQS %d byte fifo per queue\n", fifo_size);
+	mac_printf("\tRx Q, Flow control activte Thresh value %d\n", rfa);
+	mac_printf("\tRx Q, Flow Control deactivate Thresh value %d\n", rfd);
+
+	if ((fifo_size >= 4096) && (rx_fc == 1))
+		mac_printf("\tFLow Control will get triggered according"
+			   "to Thresh values\n");
+
+	if (fifo_size < 4096)
+		mac_printf("\tRQS is less than 4KB, Flow control"
+			   "will not get triggered\n");
+
+	if (rx_fc == 0)
+		mac_printf("\tFlow control is disabled\n");
+
+	return 0;
+}
+
+int xgmac_get_mtl_rx_flow_ctl(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 rx_fc;
+
+	mac_printf("XGMAC %d: MTL RX Flow Control\n", pdata->mac_idx);
+
+	rx_fc = XGMAC_RGRD_BITS(pdata, MTL_Q_RQOMR, EHFC);
+	mac_printf("\tRX Flow control operation is %s\n",
+		   rx_fc ? "ENABLED" : "DISABLED");
+	return 0;
+}
+
+int xgmac_get_mtl_tx(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 tx_mode;
+
+	mac_printf("XGMAC %d: MTL TX mode\n", pdata->mac_idx);
+
+	tx_mode = XGMAC_RGRD_BITS(pdata, MTL_Q_TQOMR, TSF);
+
+	if (tx_mode == 1)
+		mac_printf("\tXGMAC %d TX Q Mode: Store and Forward mode\n",
+			   pdata->mac_idx);
+	else if (tx_mode == 0)
+		mac_printf("\tXGMAC %d TX Q Mode: Thresh mode\n",
+			   pdata->mac_idx);
+	else
+		mac_printf("\tXGMAC %d TX Q Mode: unknown mode\n",
+			   pdata->mac_idx);
+
+	xgmac_get_tx_threshold(pdev);
+	return 0;
+}
+
+int xgmac_get_mtl_rx(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 rx_mode;
+
+	mac_printf("XGMAC %d: MTL RX mode\n", pdata->mac_idx);
+
+	rx_mode = XGMAC_RGRD_BITS(pdata, MTL_Q_RQOMR, RSF);
+
+	if (rx_mode == 1)
+		mac_printf("\tXGMAC %d RX Q Mode: Store and Forward mode\n",
+			   pdata->mac_idx);
+	else if (rx_mode == 0)
+		mac_printf("\tXGMAC %d RX Q Mode: Thresh mode\n",
+			   pdata->mac_idx);
+	else
+		mac_printf("\tXGMAC %d RX Q Mode: unknown mode\n",
+			   pdata->mac_idx);
+
+	xgmac_get_rx_threshold(pdev);
+	return 0;
+}
+
+int xgmac_get_tx_threshold(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 tx_thresh;
+
+	mac_printf("XGMAC %d: MTL TX Thresh\n", pdata->mac_idx);
+
+	tx_thresh = XGMAC_RGRD_BITS(pdata, MTL_Q_TQOMR, TTC);
+
+	if (tx_thresh == MTL_TX_THRESHOLD_32)
+		mac_printf("\tXGMAC %d TX Q operates in Thresh 32 bytes\n",
+			   pdata->mac_idx);
+	else if (tx_thresh == MTL_TX_THRESHOLD_64)
+		mac_printf("\tXGMAC %d TX Q operates in Thresh 64 bytes\n",
+			   pdata->mac_idx);
+	else if (tx_thresh == MTL_TX_THRESHOLD_96)
+		mac_printf("\tXGMAC %d TX Q operates in Thresh 96 bytes\n",
+			   pdata->mac_idx);
+	else if (tx_thresh == MTL_TX_THRESHOLD_128)
+		mac_printf("\tXGMAC %d TX Q operates in Thresh 128 bytes\n",
+			   pdata->mac_idx);
+	else if (tx_thresh == MTL_TX_THRESHOLD_192)
+		mac_printf("\tXGMAC %d TX Q operates in Thresh 192 bytes\n",
+			   pdata->mac_idx);
+	else if (tx_thresh == MTL_TX_THRESHOLD_256)
+		mac_printf("\tXGMAC %d TX Q operates in Thresh 256 bytes\n",
+			   pdata->mac_idx);
+	else if (tx_thresh == MTL_TX_THRESHOLD_384)
+		mac_printf("\tXGMAC %d TX Q operates in Thresh 384 bytes\n",
+			   pdata->mac_idx);
+	else if (tx_thresh == MTL_TX_THRESHOLD_512)
+		mac_printf("\tXGMAC %d TX Q operates in Thresh 512 bytes\n",
+			   pdata->mac_idx);
+
+	return 0;
+}
+
+int xgmac_get_rx_threshold(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 rx_thresh;
+
+	mac_printf("XGMAC %d: MTL RX Thresh\n", pdata->mac_idx);
+
+	rx_thresh = XGMAC_RGRD_BITS(pdata, MTL_Q_RQOMR, RTC);
+
+	if (rx_thresh == MTL_RX_THRESHOLD_32)
+		mac_printf("\tXGMAC %d RX Q operates in Thresh 32 bytes\n",
+			   pdata->mac_idx);
+	else if (rx_thresh == MTL_RX_THRESHOLD_64)
+		mac_printf("\tXGMAC %d RX Q operates in Thresh 64 bytes\n",
+			   pdata->mac_idx);
+	else if (rx_thresh == MTL_RX_THRESHOLD_96)
+		mac_printf("\tXGMAC %d RX Q operates in Thresh 96 bytes\n",
+			   pdata->mac_idx);
+	else if (rx_thresh == MTL_RX_THRESHOLD_128)
+		mac_printf("\tXGMAC %d RX Q operates in Thresh 128 bytes\n",
+			   pdata->mac_idx);
+
+	return 0;
+}
+
+int xgmac_get_mtl_q_alg(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 tx_mtl_alg, rx_mtl_alg;
+
+	tx_mtl_alg = XGMAC_RGRD_BITS(pdata, MTL_OMR, ETSALG);
+
+	mac_printf("XGMAC %d: MTL_Q ALG\n", pdata->mac_idx);
+
+	if (tx_mtl_alg == MTL_ETSALG_WRR)
+		mac_printf("\tTX is set to WRR Algorithm\n");
+	else if (tx_mtl_alg == MTL_ETSALG_WFQ)
+		mac_printf("\tTX is set to WFQ Algorithm\n");
+	else if (tx_mtl_alg == MTL_ETSALG_DWRR)
+		mac_printf("\tTX is set to DWRR Algorithm\n");
+
+	rx_mtl_alg = XGMAC_RGRD_BITS(pdata, MTL_OMR, RAA);
+
+	if (rx_mtl_alg == MTL_RAA_SP)
+		mac_printf("\tRX is set to Strict Priority Algorithm\n");
+	else if (rx_mtl_alg == MTL_RAA_WSP)
+		mac_printf("\tRX is set to WSP Algorithm\n");
+
+	return 0;
+}
+
+int xgmac_get_crc_settings(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 cst, acs, dcrcc;
+
+	mac_printf("XGMAC %d: CRC Stripping\n", pdata->mac_idx);
+	cst = XGMAC_RGRD_BITS(pdata, MAC_RX_CFG, CST);
+	mac_printf("\tCRC stripping for Type packets: %s\n",
+		   cst ? "ENABLED" : "DISABLED");
+	acs = XGMAC_RGRD_BITS(pdata, MAC_RX_CFG, ACS);
+	mac_printf("\tAutomatic Pad or CRC Stripping: %s\n",
+		   acs ? "ENABLED" : "DISABLED");
+	dcrcc = XGMAC_RGRD_BITS(pdata, MAC_RX_CFG, DCRCC);
+	mac_printf("\tMAC RX do not check the CRC field in the rx pkt: %s\n",
+		   dcrcc ? "ENABLED" : "DISABLED");
+	return 0;
+}
+
+int xgmac_dbg_eee_status(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 varmac_lps;
+
+	varmac_lps = XGMAC_RGRD(pdata, MAC_LPI_CSR);
+
+	mac_printf("XGMAC %d: EEE Status\n", pdata->mac_idx);
+
+	mac_printf("\tMAC_LPI_Control_Status = %x\n", varmac_lps);
+
+	if (varmac_lps & MAC_LPS_TLPIEN)
+		mac_printf("\tMAC Transmitter has entered the LPI state\n");
+
+	if (varmac_lps & MAC_LPS_TLPIEX)
+		mac_printf("\tMAC Transmitter has exited the LPI state\n");
+
+	if (varmac_lps & MAC_LPS_RLPIEN)
+		mac_printf("\tMAC Receiver has entered the LPI state\n");
+
+	if (varmac_lps & MAC_LPS_RLPIEX)
+		mac_printf("\tMAC Receiver has exited the LPI state\n");
+
+	return 0;
+}
+
+int xgmac_get_eee_settings(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 twt, lst, pls, lpitxa, lpitxen;
+
+	twt = XGMAC_RGRD_BITS(pdata, MAC_LPI_TCR, TWT);
+	lst = XGMAC_RGRD_BITS(pdata, MAC_LPI_TCR, LST);
+	pls = XGMAC_RGRD_BITS(pdata, MAC_LPI_CSR, PLS);
+	lpitxa = XGMAC_RGRD_BITS(pdata, MAC_LPI_CSR, LPITXA);
+	lpitxen = XGMAC_RGRD_BITS(pdata, MAC_LPI_CSR, LPITXEN);
+
+	mac_printf("XGMAC %d: EEE Settings\n", pdata->mac_idx);
+
+	mac_printf("\tLPI LS TIMER: %d\n", lst);
+	mac_printf("\tLPI TW TIMER: %d\n", twt);
+	mac_printf("\tPhy link Status: %s\n",
+		   pls ? "ENABLED" : "DISABLED");
+	mac_printf("\tLPI Transmit Automate: %s\n",
+		   lpitxa ? "ENABLED" : "DISABLED");
+	mac_printf("\tLPI Transmit Enable: %s\n",
+		   lpitxen ? "ENABLED" : "DISABLED");
+
+	xgmac_dbg_eee_status(pdev);
+	return 0;
+}
+
+int xgmac_get_mac_settings(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 te, re, ra;
+
+	mac_printf("XGMAC %d: MAC Settings\n", pdata->mac_idx);
+
+	te = XGMAC_RGRD_BITS(pdata, MAC_TX_CFG, TE);
+	mac_printf("\tMAC TX: %s\n", te ? "ENABLED" : "DISABLED");
+	re = XGMAC_RGRD_BITS(pdata, MAC_RX_CFG, RE);
+	mac_printf("\tMAC RX: %s\n", re ? "ENABLED" : "DISABLED");
+	ra = XGMAC_RGRD_BITS(pdata, MAC_PKT_FR, RA);
+	mac_printf("\tMAC Filter RX ALL: %s\n", ra ? "ENABLED" : "DISABLED");
+	return 0;
+}
+
+int xgmac_get_mac_rxtx_sts(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 rwt, tjt, wd, jd;
+
+	mac_printf("XGMAC %d: MAC RXTX Status\n", pdata->mac_idx);
+
+	jd = XGMAC_RGRD_BITS(pdata, MAC_TX_CFG, JD);
+	wd = XGMAC_RGRD_BITS(pdata, MAC_RX_CFG, WD);
+
+	mac_printf("\tWATCHDOG Disable       : %s\n",
+		   wd ? "ENABLED" : "DISABLED");
+	mac_printf("\tJABBER TIMEOUT Disable : %s\n",
+		   jd ? "ENABLED" : "DISABLED");
+
+	rwt = XGMAC_RGRD_BITS(pdata, MAC_RXTX_STS, RWT);
+
+	if (wd)
+		mac_printf("\tMAC : %s\n",
+			   rwt ?
+			   "Received packet > 16383 bytes with WD=1" :
+			   "No packet recived with RWT");
+	else
+		mac_printf("\tMAC : %s\n",
+			   rwt ?
+			   "Received packet > 2048 bytes with WD=0" :
+			   "No packet recived with RWT");
+
+	tjt = XGMAC_RGRD_BITS(pdata, MAC_RXTX_STS, TJT);
+
+	if (jd)
+		mac_printf("\tMAC : %s\n",
+			   tjt ?
+			   "Transmitted packet > 16383 bytes with JD=1" :
+			   "No packet transmitted with TJT");
+	else
+		mac_printf("\tMAC : %s\n",
+			   tjt ?
+			   "Transmitted packet > 2048 bytes with JD=0" :
+			   "No packet transmitted with TJT");
+
+	return 0;
+}
+
+int xgmac_get_mtu_settings(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_rcr, je, wd, gpslce, jd, gpsl;
+
+	mac_rcr = XGMAC_RGRD(pdata, MAC_RX_CFG);
+
+	je = MAC_GET_VAL(mac_rcr, MAC_RX_CFG, JE);
+	wd = MAC_GET_VAL(mac_rcr, MAC_RX_CFG, WD);
+	gpslce = MAC_GET_VAL(mac_rcr, MAC_RX_CFG, GPSLCE);
+	gpsl = MAC_GET_VAL(mac_rcr, MAC_RX_CFG, GPSL);
+	jd = XGMAC_RGRD_BITS(pdata, MAC_TX_CFG, JD);
+
+	mac_printf("XGMAC %d: MTU Settings\n", pdata->mac_idx);
+
+	mac_printf("\tMTU CONFIGURED %d\n", pdata->mtu);
+
+	if (je)
+		mac_printf("\tJumbo Enabled: 1, MAC allows jumbo packets of "
+			   "9,018 bytes (9,022 bytes for VLAN tagged packets)"
+			   "without reporting a giant packet error\n");
+
+	if (wd)
+		mac_printf("\tWatchdog Disable: 1,MAC disables the "
+			   "watchdog timer on the receiver. The MAC can "
+			   "receive packets of up to 16,383 bytes.\n");
+	else
+		mac_printf("\tWatchdog Disable: 0, MAC does not allow more "
+			   "than 2,048 bytes (10,240 if JE is 1) of the pkt "
+			   "being received.The MAC cuts off any bytes "
+			   "received after 2,048 bytes\n");
+
+	if (gpslce) {
+		mac_printf("\tGPSLCE: 1, MAC considers the value in "
+			   "GPSL field to declare a received packet "
+			   "as Giant packet\n");
+		mac_printf("\tGPSL: %04x\n", gpsl);
+	} else {
+		mac_printf("\tGPSLCE: 0, MAC considers a RX packet as Giant  "
+			   "packet when its size is greater than 1,518 bytes"
+			   "(1522 bytes for tagged packet)\n");
+	}
+
+	if (jd)
+		mac_printf("\tJabber Disable: 1, XGMAC disables the "
+			   "jabber timer on the tx. Tx of up to 16,383-byte  "
+			   "frames is supported.\n");
+	else
+		mac_printf("\tJabber Disable: 0, XGMAC cuts off the TX "
+			   "if the application sends more than 2,048 bytes "
+			   "of data (10,240 bytes if JE is 1 during TX\n");
+
+	return 0;
+}
+
+int xgmac_get_checksum_offload(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 co = 0;
+
+	co = XGMAC_RGRD_BITS(pdata, MAC_RX_CFG, IPC);
+	mac_printf("XGMAC %d: Checksum Offload Settings\n", pdata->mac_idx);
+	mac_printf("\tChecksum Offload : %s\n", co ? "ENABLED" : "DISABLED");
+	return 0;
+}
+
+int xgmac_get_mac_addr(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_addr_hi, mac_addr_lo;
+	u8 mac_addr[6];
+
+	mac_addr_hi = XGMAC_RGRD(pdata, MAC_MACA0HR);
+	mac_addr_lo = XGMAC_RGRD(pdata, MAC_MACA0LR);
+
+	mac_printf("XGMAC %d: MAC ADDR\n", pdata->mac_idx);
+
+	mac_printf("\tmac_addr_hi = %08x\n", mac_addr_hi);
+	mac_printf("\tmac_addr_lo = %08x\n", mac_addr_lo);
+
+	mac_addr[5] = ((mac_addr_hi & 0x0000FF00) >> 8);
+	mac_addr[4] = (mac_addr_hi & 0x000000FF);
+	mac_addr[3] = ((mac_addr_lo & 0xFF000000) >> 24);
+	mac_addr[2] = ((mac_addr_lo & 0x00FF0000) >> 16);
+	mac_addr[1] = ((mac_addr_lo & 0x0000FF00) >> 8);
+	mac_addr[0] = (mac_addr_lo & 0x000000FF);
+
+	mac_printf("\tSet mac address %02x:%02x:%02x:%02x:%02x:%02x\n",
+		   mac_addr[0],
+		   mac_addr[1],
+		   mac_addr[2],
+		   mac_addr[3],
+		   mac_addr[4],
+		   mac_addr[5]);
+	return 0;
+}
+
+int xgmac_get_mac_rx_mode(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mode = 0;
+
+	mac_printf("XGMAC %d: MAC RX MODE\n", pdata->mac_idx);
+
+	mode = XGMAC_RGRD_BITS(pdata, MAC_PKT_FR, PR);
+	mac_printf("\tPromiscous Mode    : %s\n",
+		   mode ? "ENABLED" : "DISABLED");
+	mode = XGMAC_RGRD_BITS(pdata, MAC_PKT_FR, PM);
+	mac_printf("\tPass All Multicast : %s\n",
+		   mode ? "ENABLED" : "DISABLED");
+	return 0;
+}
+
+int xgmac_get_rx_vlan_filtering_mode(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 vtfe = 0;
+
+	vtfe = XGMAC_RGRD_BITS(pdata, MAC_PKT_FR, VTFE);
+
+	mac_printf("XGMAC %d: RX VLAN Filtering\n", pdata->mac_idx);
+	mac_printf("\tRX VLAN Filtering is %s\n",
+		   vtfe ? "ENABLED" : "DISABLED");
+	return 0;
+}
+
+int xgmac_get_mac_speed(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 speed;
+
+	speed  = XGMAC_RGRD_BITS(pdata, MAC_TX_CFG, SS);
+	mac_printf("XGMAC %d: MAC Speed\n", pdata->mac_idx);
+
+	if (speed == 0)
+		mac_printf("\tXGMAC configured for XGMII 10G speed\n");
+	else if (speed == 2)
+		mac_printf("\tXGMAC configured for GMII 2.5G speed\n");
+	else if (speed == 3)
+		mac_printf("\tXGMAC configured for GMII 1G speed\n");
+
+	return 0;
+}
+
+int xgmac_get_pause_frame_ctl(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 pfce = 0, rfe = 0, tfe = 0, pt = 0;
+
+	pfce = XGMAC_RGRD_BITS(pdata, MAC_RX_FCR, PFCE);
+	rfe = XGMAC_RGRD_BITS(pdata, MAC_RX_FCR, RFE);
+	tfe = XGMAC_RGRD_BITS(pdata, MAC_TX_FCR, TFE);
+	pt = XGMAC_RGRD_BITS(pdata, MAC_TX_FCR, PT);
+
+	mac_printf("XGMAC %d: Pause Frame Settings\n", pdata->mac_idx);
+
+	mac_printf("\tPriority based Flow control: %s\n",
+		   pfce ? "ENABLED" : "DISABLED");
+
+	if (pfce)
+		mac_printf("\tEnables TX of priority based flow Ctrl Pkts\n");
+	else
+		mac_printf("\tEnables TX and RX of 802.3x Pause Ctrl Pkts\n");
+
+	mac_printf("\tReceive Flow control:        %s\n",
+		   rfe ? "ENABLED" : "DISABLED");
+
+	if (rfe)
+		mac_printf("\tMAC decodes the Rx Pause packets and "
+			   "disables the TX for a specified Pause time\n");
+	else
+		mac_printf("\tMAC doesnot decode the Pause packet\n");
+
+	mac_printf("\tTransmit Flow control:       %s\n",
+		   tfe ? "ENABLED" : "DISABLED");
+
+	if (tfe)
+		mac_printf("\tMAC enables Flow control operation "
+			   "based on Pause frame\n");
+	else
+		mac_printf("\tMAC does not transmit and Pause packets by "
+			   "itself\n");
+
+	mac_printf("\tPause Time:                  %d\n", pt);
+	return 0;
+}
+
+int xgmac_get_mac_loopback_mode(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 lm;
+
+	lm = XGMAC_RGRD_BITS(pdata, MAC_RX_CFG, LM);
+
+	mac_printf("XGMAC %d: MAC Loopback\n", pdata->mac_idx);
+	mac_printf("\tMAC Loopback mode: %s\n", lm ? "ENABLED" : "DISABLED");
+	return 0;
+}
+
+int xgmac_get_tstamp_settings(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_tscr, val;
+
+	mac_tscr = XGMAC_RGRD(pdata, MAC_TSTAMP_CR);
+
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, TSENA);
+
+	mac_printf("XGMAC %d: Timestamp Settings\n", pdata->mac_idx);
+	mac_printf("\tTimestamp is added for TX and RX packets: %s\n",
+		   val ? "ENABLED" : "DISABLED");
+
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, TSCFUPDT);
+	mac_printf("\tTimestamp Update type: %s\n", val ? "FINE" : "COARSE");
+	mac_printf("\tAddend present only in FINE update, "
+		   "Timestamp Addend value %d\n",
+		   XGMAC_RGRD(pdata, MAC_TSTAMP_ADDNDR));
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, TSENALL);
+	mac_printf("\tTimestamp for All Packets Received: %s\n",
+		   val ? "ENABLED" : "DISABLED");
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, TSCTRLSSR);
+	mac_printf("\tTimestamp Digital or Binary Rollover Control %s\n",
+		   val ?
+		   "TIME STAMP DIGITAL (1ns accuracy)" :
+		   "BINARY ROLLOVER");
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, TSTRIG);
+	mac_printf("\tTSTRIG: Timestamp Interrupt trigger: %s\n",
+		   val ? "ENABLED" : "DISABLED");
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, TSVER2ENA);
+	mac_printf("\tTSVER2ENA: PTP Pkt Processing for Ver 2 Format: %s\n",
+		   val ? "ENABLED" : "DISABLED");
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, TSIPENA);
+	mac_printf("\tTSIPENA: MAC receiver processes the PTP packets "
+		   "encapsulated directly in the Ethernet packets: %s\n",
+		   val ? "ENABLED" : "DISABLED");
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, TSIPV6ENA);
+	mac_printf("\tTSIPV6ENA: MAC receiver processes the PTP packets "
+		   "encapsulated in IPv6-UDP packets: %s\n",
+		   val ? "ENABLED" : "DISABLED");
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, TSIPV4ENA);
+	mac_printf("\tTSIPV4ENA: MAC receiver processes the PTP packets "
+		   "encapsulated in IPv4-UDP packets: %s\n",
+		   val ? "ENABLED" : "DISABLED");
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, TSEVNTENA);
+	mac_printf("\tTSEVNTENA: Timestamp snapshot is taken only for "
+		   "event msg (SYNC, Delay_Req, Pdelay_Req, or "
+		   "Pdelay_Resp): %s\n",
+		   val ? "ENABLED" : "DISABLED");
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, SNAPTYPSEL);
+	mac_printf("\tSNAPTYPSEL: These bits, along with TSMSTRENA "
+		   "TSEVNTENA, decide the set of PTP packet types for which "
+		   "snapshot needs to be taken. %s\n",
+		   val ? "ENABLED" : "DISABLED");
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, TSMSTRENA);
+	mac_printf("\tTSMSTRENA: Snapshot is taken only for the "
+		   "messages that are relevant to the master node: %s\n",
+		   val ? "ENABLED" : "DISABLED");
+	return 0;
+}
+
+int xgmac_get_tstamp_status(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_tscr, val;
+	u64 time;
+
+	mac_tscr = XGMAC_RGRD(pdata, MAC_TSTAMP_STSR);
+
+	mac_printf("XGMAC %d: Timestamp Status\n", pdata->mac_idx);
+
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_STSR, ATSNS);
+	mac_printf("\tNumber of Auxiliary Timestamp Snapshots:          %d\n",
+		   val);
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_STSR, ATSSTM);
+	mac_printf("\tAuxiliary Timestamp Snapshot Trigger Missed:      %d\n",
+		   val);
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_STSR, ATSSTN);
+	mac_printf("\tAuxiliary Timestamp Snapshot Trigger Identifier   %d\n",
+		   val);
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_STSR, TXTSC);
+	mac_printf("\tTX Timestamp Captured:                            %d\n",
+		   val);
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_STSR, TSTRGTERR3);
+	mac_printf("\tTimestamp Target Time Error:                      %d\n",
+		   val);
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_STSR, TSTARGT3);
+	mac_printf("\tTimestamp Target Time Reached for Time PPS3:      %d\n",
+		   val);
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_STSR, TSTRGTERR2);
+	mac_printf("\tTimestamp Target Time Error:                      %d\n",
+		   val);
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_STSR, TSTARGT2);
+	mac_printf("\tTimestamp Target Time Reached for Time PPS2:      %d\n",
+		   val);
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_STSR, TSTRGTERR1);
+	mac_printf("\tTimestamp Target Time Error:                      %d\n",
+		   val);
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_STSR, TSTARGT1);
+	mac_printf("\tTimestamp Target Time Reached for Time PPS1:      %d\n",
+		   val);
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_STSR, TSTRGTERR0);
+	mac_printf("\tTimestamp Target Time Error:                      %d\n",
+		   val);
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_STSR, TSTARGT0);
+	mac_printf("\tTimestamp Target Time Reached:                    %d\n",
+		   val);
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_STSR, AUXTSTRIG);
+	mac_printf("\tAuxiliary Timestamp Trigger Snapshot:             %d\n",
+		   val);
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_STSR, TSSOVF);
+	mac_printf("\tTimestamp Seconds Overflow                        %d\n",
+		   val);
+
+	mac_printf("\n\n");
+
+	time = xgmac_get_systime(pdev);
+	mac_printf("\t64 bit system time in nsec                      %lld\n",
+		   time);
+
+	val = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_STSR, TTSNS);
+	mac_printf("\tTstamp captured count in xgmac Fifo:              %d\n",
+		   val);
+
+	time = xgmac_get_tx_tstamp(pdev);
+	mac_printf("\tTimestamp captured in nsec:                     %lld\n",
+		   time);
+
+	return 0;
+}
+
+int xgmac_print_system_time(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u64 nsec;
+	u32 reg_sec, nanosec, sec;
+	u32 min, hr, days;
+
+	reg_sec = XGMAC_RGRD(pdata, MAC_SYS_TIME_SEC);
+	nanosec = XGMAC_RGRD(pdata, MAC_SYS_TIME_NSEC);
+	nsec = NSEC_TO_SEC * reg_sec;
+	nsec += nanosec;
+
+	if (reg_sec)
+		sec = (reg_sec * (nanosec / NANOSEC_IN_ONESEC));
+	else
+		sec = (nanosec / NANOSEC_IN_ONESEC);
+
+	if (sec >= 60) {
+		min = sec / 60;
+		sec = sec - (min * 60);
+	} else {
+		min = 0;
+	}
+
+	if (min >= 60) {
+		hr = min / 60;
+		min = min - (hr * 60);
+	} else {
+		hr = 0;
+	}
+
+	if (hr >= 24) {
+		days = hr / 24;
+		hr = hr - (days * 24);
+	} else {
+		days = 0;
+	}
+
+	mac_printf("Uptime(d:h:m:s):     %02d:%02d:%02d:%02d\n",
+		   days, hr, min, sec);
+
+	mac_printf("Sec                  %d\n", reg_sec);
+	mac_printf("NanoSec              %d\n", nanosec);
+	mac_printf("Total in nsec        %lld\n", nsec);
+	return 0;
+}
+
+int xgmac_get_txtstamp_mode(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_tscr = 0, mac_txtstamp;
+	u32 snaptypesel, tsmstrena, tsevntena, tsena;
+
+	mac_txtstamp = GSWSS_MAC_RGRD(pdata, MAC_TXTS_CIC(pdata->mac_idx));
+	mac_printf("TTSE:         %s\n",
+		   GET_N_BITS(mac_txtstamp, 4, 1) ? "ENABLED" : "DISABLED");
+	mac_printf("OSTC:         %s\n",
+		   GET_N_BITS(mac_txtstamp, 3, 1) ? "ENABLED" : "DISABLED");
+	mac_printf("OSTC_AVAIL:   %s\n",
+		   GET_N_BITS(mac_txtstamp, 2, 1) ? "ENABLED" : "DISABLED");
+
+	mac_tscr = XGMAC_RGRD(pdata, MAC_TSTAMP_CR);
+
+	snaptypesel = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, SNAPTYPSEL);
+	tsevntena = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, TSEVNTENA);
+	tsmstrena = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, TSMSTRENA);
+	tsena = MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, TSENA);
+
+	mac_printf("snaptypesel   %d\n", snaptypesel);
+	mac_printf("tsevntena     %d\n", tsevntena);
+	mac_printf("tsmstrena     %d\n", tsmstrena);
+	mac_printf("tsena         %d\n", tsena);
+	return 0;
+}
+
+int xgmac_get_debug_sts(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 dbg_sts, dbg_ctl, fifo_sel, pktstate, byteen;
+
+	dbg_ctl = XGMAC_RGRD(pdata, MTL_DBG_CTL);
+	dbg_sts = XGMAC_RGRD(pdata, MTL_DBG_STS);
+
+	fifo_sel = MAC_GET_VAL(dbg_sts, MTL_DBG_CTL, FIFOSEL);
+
+	mac_printf("XGMAC %d: Debug Status\n", pdata->mac_idx);
+
+	if (MAC_GET_VAL(dbg_sts, MTL_DBG_STS, FIFOBUSY)) {
+		mac_printf("\tA FIFO operation is in progress in the MAC, "
+			   "All other fields in this register is Invalid\n");
+		return 0;
+	}
+
+	pktstate = MAC_GET_VAL(dbg_sts, MTL_DBG_CTL, PKTSTATE);
+
+	if (fifo_sel == 0) {
+		mac_printf("\tTX FIFO Selected\n");
+
+		if (pktstate == 0)
+			mac_printf("\tType of Data Read: PACKET_DATA\n");
+		else if (pktstate == 1)
+			mac_printf("\tType of Data Read: CONTROL_WORD\n");
+		else if (pktstate == 2)
+			mac_printf("\tType of Data Read: SOP_DATA\n");
+		else if (pktstate == 3)
+			mac_printf("\tType of Data Read: EOP_DATA\n");
+
+		mac_printf("\tSpace Available in Tx Fifo %d\n",
+			   MAC_GET_VAL(dbg_sts, MTL_DBG_STS, LOCR));
+	} else if (fifo_sel == 3) {
+		mac_printf("\tRX FIFO Selected\n");
+
+		if (pktstate == 0)
+			mac_printf("\tType of Data Read: PACKET_DATA\n");
+		else if (pktstate == 1)
+			mac_printf("\tType of Data Read: NORMAL_STS\n");
+		else if (pktstate == 2)
+			mac_printf("\tType of Data Read: LAST_STS\n");
+		else if (pktstate == 3)
+			mac_printf("\tType of Data Read: EOP\n");
+
+		mac_printf("\tSpace Available in Rx Fifo %d\n",
+			   MAC_GET_VAL(dbg_sts, MTL_DBG_STS, LOCR));
+	}
+
+	byteen = MAC_GET_VAL(dbg_ctl, MTL_DBG_CTL, BYTEEN);
+
+	if (MAC_GET_VAL(dbg_sts, MTL_DBG_STS, PKTI))
+		mac_printf("\tFull packet is available in RxFIFO\n");
+
+	return 0;
+}
+
+int xgmac_get_debug_data(void *pdev, u32 *dbg_data)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 fifo_sel, dbg_ctrl;
+
+	dbg_ctrl = XGMAC_RGRD(pdata, MTL_DBG_CTL);
+	*dbg_data = XGMAC_RGRD(pdata, MTL_DBG_DAT);
+	fifo_sel = MAC_GET_VAL(dbg_ctrl, MTL_DBG_CTL, FIFOSEL);
+
+	mac_printf("XGMAC %d: Debug Data\n", pdata->mac_idx);
+
+	if (fifo_sel == 0)
+		mac_printf("\tData pointer in the Tx FIFO %08x\n", *dbg_data);
+	else if (fifo_sel == 3)
+		mac_printf("\tData pointer in the Rx FIFO %08x\n", *dbg_data);
+
+	return 0;
+}
+
+int xgmac_get_fifo_space_left(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 locr, dbg_ctl, fifo_sel, fdbgen, dbgmod;
+
+	locr = XGMAC_RGRD_BITS(pdata, MTL_DBG_STS, LOCR);
+
+	dbg_ctl = XGMAC_RGRD(pdata, MTL_DBG_CTL);
+
+	fifo_sel = MAC_GET_VAL(dbg_ctl, MTL_DBG_CTL, FIFOSEL);
+	fdbgen = MAC_GET_VAL(dbg_ctl, MTL_DBG_CTL, FDBGEN);
+	dbgmod = MAC_GET_VAL(dbg_ctl, MTL_DBG_CTL, DBGMOD);
+
+	mac_printf("XGMAC %d: Fifo Space Left\n", pdata->mac_idx);
+
+	if (fdbgen && !dbgmod) {
+		if (fifo_sel == 0)
+			mac_printf("\tSlave Mode: Space Available in the "
+				   "TX FIFO %d\n", locr);
+
+		if (fifo_sel == 3)
+			mac_printf("\tSlave Mode: Space Available in the "
+				   "RX FIFO %d\n", locr);
+	}
+
+	if (fdbgen && dbgmod) {
+		if (fifo_sel == 0)
+			mac_printf("\tData to be written to the Tx FIFO %d\n",
+				   locr);
+
+		if (fifo_sel == 3)
+			mac_printf("\tData to be written to the Rx FIFO %d\n",
+				   locr);
+	}
+
+	return 0;
+}
+
+int xgmac_dbg_int_sts(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_isr = 0, val;
+
+	mac_printf("XGMAC %d: MAC Interrupt Status\n", pdata->mac_idx);
+	mac_isr = XGMAC_RGRD(pdata, MAC_ISR);
+	val = XGMAC_RGRD(pdata, MAC_IER);
+	mac_printf("\tMAC_IER interrupts  %s %08x\n",
+		   val ? "ENABLED" : "DISABLED", val);
+
+	/* Enable Timestamp interrupt */
+	if (val & MASK(MAC_IER, TSIE))
+		mac_printf("\t\tTimestamp Interrupt Enabled\n");
+
+	/* Enable LPI interrupt (EEE) */
+	if (val & MASK(MAC_IER, LPIIE))
+		mac_printf("\t\tLPI interrupt (EEE) Enabled\n");
+
+	/* Enable transmit error status interrupt */
+	if (val & MASK(MAC_IER, TXESIE))
+		mac_printf("\t\tTransmit error status interrupt Enabled\n");
+
+	/* Enable Receive error status interrupt */
+	if (val & MASK(MAC_IER, RXESIE))
+		mac_printf("\t\tReceive error status interrupt Enabled\n");
+
+	/* Enable power management interrupt */
+	if (val & MASK(MAC_IER, PMTIE))
+		mac_printf("\tPower Management interrupt Enabled\n");
+
+	if (!mac_isr) {
+		mac_printf("\tNo MAC interrupt status available %d\n",
+			   mac_isr);
+	} else {
+		mac_printf("XGMAC %d: MAC Interrupt Status %08x\n",
+			   pdata->mac_idx, mac_isr);
+		val = MAC_GET_VAL(mac_isr, MAC_ISR, LSI);
+
+		if (val)
+			mac_printf("\tMAC_INT_STS: Link Status bits change "
+				   "their value\n");
+
+		val = MAC_GET_VAL(mac_isr, MAC_ISR, SMI);
+
+		if (val)
+			mac_printf("\tMAC_INT_STS: Any of the bits in the "
+				   "MDIO Interrupt Status Register is set\n");
+
+		val = MAC_GET_VAL(mac_isr, MAC_ISR, PMTIS);
+
+		if (val)
+			mac_printf("\tMAC_INT_STS: A Magic packet or "
+				   "Wake-on-LAN packet is received in the "
+				   "power-down mode\n");
+
+		val = MAC_GET_VAL(mac_isr, MAC_ISR, LPIIS);
+
+		if (val)
+			mac_printf("\tMAC_INT_STS: It is set for any LPI "
+				   "state entry or exit in the MAC Tx/Rx\n");
+
+		val = MAC_GET_VAL(mac_isr, MAC_ISR, MMCRXIS);
+
+		if (val)
+			mac_printf("\tMAC_INT_STS: Interrupt is generated "
+				   "in the MMC Receive Interrupt Register\n");
+
+		val = MAC_GET_VAL(mac_isr, MAC_ISR, MMCTXIS);
+
+		if (val)
+			mac_printf("\tMAC_INT_STS: Interrupt is generated in "
+				   "the MMC Transmit Interrupt Register\n");
+
+		val = MAC_GET_VAL(mac_isr, MAC_ISR, TSIS);
+
+		if (val)
+			mac_printf("\tMAC_INT_STS: Timestamp Interrupt Status"
+				   "is set\n");
+
+		val = MAC_GET_VAL(mac_isr, MAC_ISR, TXESIS);
+
+		if (val)
+			mac_printf("\tMAC_INT_STS: Transmit Error, "
+				   "Jabber Timeout (TJT) event occurs during "
+				   "transmission\n");
+
+		val = MAC_GET_VAL(mac_isr, MAC_ISR, RXESIS);
+
+		if (val)
+			mac_printf("\tMAC_INT_STS: Receive Error, Watchdog "
+				   "Timeout (WDT) event occurs during Rx.\n");
+
+		val = MAC_GET_VAL(mac_isr, MAC_ISR, GPIIS);
+
+		if (val)
+			mac_printf("\tMAC_INT_STS: GPIO Interrupt status "
+				   "is set\n");
+
+		val = MAC_GET_VAL(mac_isr, MAC_ISR, LS);
+
+		if (val == 0)
+			mac_printf("\tMAC_INT_STS: Current Link Status: %s\n",
+				   "LINK OK");
+
+		if (val == 2)
+			mac_printf("\tMAC_INT_STS: Current Link Status: %s\n",
+				   "Local Link Fault");
+
+		if (val == 3)
+			mac_printf("\tMAC_INT_STS: Current Link Status: %s\n",
+				   "Remote Link Fault");
+
+		xgmac_clear_mac_int(pdev);
+
+		return val;
+	}
+
+	val = xgmac_get_mtl_int_sts(pdev);
+	return val;
+}
+
+
+int xgmac_get_mtl_underflow_pkt_cnt(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mtl_q;
+	u32 val;
+
+	mtl_q = XGMAC_RGRD(pdata, MTL_Q_TQUR);
+	mac_printf("XGMAC %d: MTL Underflow Pkt Counter %08x\n",
+		   pdata->mac_idx, mtl_q);
+
+	val = MAC_GET_VAL(mtl_q, MTL_Q_TQUR, UFCNTOVF);
+
+	if (val)
+		mac_printf("\t\tOverflow bit of Underflow pkt counter %d\n",
+			   val);
+
+	val = MAC_GET_VAL(mtl_q, MTL_Q_TQUR, UFPKTCNT);
+
+	if (val)
+		mac_printf("\t\tUnerflow packet counter %d\n", val);
+
+	return 0;
+}
+
+int xgmac_get_mtl_missed_pkt_cnt(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mtl_q;
+	u32 val;
+
+	mtl_q = XGMAC_RGRD(pdata, MTL_Q_RQMPOCR);
+	mac_printf("XGMAC %d: MTL Missed Overflow Pkt Counter %08x\n",
+		   pdata->mac_idx, mtl_q);
+
+	val = MAC_GET_VAL(mtl_q, MTL_Q_RQMPOCR, MISCNTOVF);
+
+	if (val)
+		mac_printf("\t\tRx Queue Missed Packet Counter crossed the "
+			   "maximum limit %d\n", val);
+
+	val = MAC_GET_VAL(mtl_q, MTL_Q_RQMPOCR, MISPKTCNT);
+
+	if (val)
+		mac_printf("\t\tNumber of packets missed by XGMAC %d\n", val);
+
+	val = MAC_GET_VAL(mtl_q, MTL_Q_RQMPOCR, OVFCNTOVF);
+
+	if (val)
+		mac_printf("\t\tRx Queue Overflow Packet Counter field "
+			   "crossed the maximum limit %d\n", val);
+
+	val = MAC_GET_VAL(mtl_q, MTL_Q_RQMPOCR, OVFPKTCNT);
+
+	if (val)
+		mac_printf("\tNo: of packets discarded by the XGMAC %d\n",
+			   val);
+
+	return 0;
+}
+
+int xgmac_get_mtl_int_sts(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mtl_q_isr;
+	u32 val;
+
+	mtl_q_isr = XGMAC_RGRD(pdata, MTL_Q_ISR);
+	val = XGMAC_RGRD(pdata, MTL_Q_IER);
+
+	mac_printf("XGMAC %d: MTL Interrupt Status\n", pdata->mac_idx);
+
+	mac_printf("\tMTL_Q_IER interrupts %s %08x\n",
+		   val ? "ENABLED" : "DISABLED", val);
+
+	/* Tx Q Overflow Interrupt Enable */
+	if (val & MASK(MTL_Q_IER, TXUIE))
+		mac_printf("\t\tTx Q Overflow Interrupt Enabled\n");
+
+	/* Average bits per slot interrupt enable */
+	if (val & MASK(MTL_Q_IER, ABPSIE))
+		mac_printf("\t\tAverage bits per slot interrupt Enabled\n");
+
+	/* Rx Q Overflow Interrupt Enable */
+	if (val & MASK(MTL_Q_IER, RXOIE))
+		mac_printf("\t\tRx Q Overflow Interrupt Enabled\n");
+
+	if (!mtl_q_isr) {
+		mac_printf("\tNo MTL interrupt status available\n");
+	} else {
+		/* Tx Q Overflow Interrupt Enable */
+		val = MAC_GET_VAL(mtl_q_isr, MTL_Q_ISR, TXUNFIS);
+
+		if (val)
+			mac_printf("\tTransmit Queue had an Underflow "
+				   "during packet transmission\n");
+
+		// TODO: Check whether this bit is reserved since traffic class is 1
+		/* Average bits per slot interrupt enable */
+		val = MAC_GET_VAL(mtl_q_isr, MTL_Q_ISR, ABPSIS);
+
+		if (val)
+			mac_printf("\tMAC has updated the ABS value for "
+				   "Traffic Class 0\n");
+
+		/* Rx Q Overflow Interrupt Enable */
+		val = MAC_GET_VAL(mtl_q_isr, MTL_Q_ISR, RXOVFIS);
+
+		if (val)
+			mac_printf("\tReceive Queue had an Overflow during "
+				   "packet reception\n");
+	}
+
+	return 0;
+}
+
+int xgmac_get_fup_fep_setting(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 fup, fef;
+
+	mac_printf("XGMAC %d: FUP/FEP Settings\n", pdata->mac_idx);
+
+	fup = XGMAC_RGRD_BITS(pdata, MTL_Q_RQOMR, FUP);
+	mac_printf("\tForward Undersized Good Packets for RxQ: %s\n",
+		   fup ? "ENABLE" : "DISABLE");
+	fef = XGMAC_RGRD_BITS(pdata, MTL_Q_RQOMR, FEF);
+	mac_printf("\tForward Error Packets for RxQ:           %s\n",
+		   fef ? "ENABLE" : "DISABLE");
+	return 0;
+}
+
+int xgmac_get_ipg(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 ipg, ifp, speed;
+
+	ipg = XGMAC_RGRD_BITS(pdata, MAC_TX_CFG, IPG);
+	ifp = XGMAC_RGRD_BITS(pdata, MAC_TX_CFG, IFP);
+	speed = XGMAC_RGRD_BITS(pdata, MAC_TX_CFG, SS);
+
+	mac_printf("XGMAC %d: IPG Settings\n", pdata->mac_idx);
+
+	if (((speed == 3) || (speed == 2)) && (ifp == 0)) {
+		mac_printf("\tGMMI mode Minimum IPG between packets during "
+			   "TX is %d bits\n", (96 - (ipg * 8)));
+		return 0;
+	}
+
+	if ((speed == 0) && (ifp == 0))
+		mac_printf("\tMinimum IPG between packets during TX is %d "
+			   "bits, XGMII mode No reduction possible\n", 96);
+
+	if (ifp)
+		mac_printf("\tMinimum IPG between packets during "
+			   "TX is %d bits\n", (96 - (ipg * 32)));
+
+	return 0;
+}
+
+int xgmac_get_extcfg(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_extcfg, val;
+
+	mac_extcfg = XGMAC_RGRD(pdata, MAC_EXTCFG);
+
+	val = MAC_GET_VAL(mac_extcfg, MAC_EXTCFG, SBDIOEN);
+	mac_printf("XGMAC %d: MAC Extended CFG SGDIOEN: %s\n",
+		   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+	return 0;
+}
+
+int xgmac_dbg_pmt(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_pmtcsr, val, i = 0;
+	u32 value[8];
+
+	mac_pmtcsr = XGMAC_RGRD(pdata, MAC_PMT_CSR);
+
+	mac_printf("XGMAC %d: PMT Settings\n", pdata->mac_idx);
+
+	val = MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, MGKPKTEN);
+	mac_printf("Magic_Packet_Enable:          %s\n",
+		   val ? "ENABLED" : "DISABLED");
+
+	val = MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, RWKPKTEN);
+	mac_printf("Remote_Wakeup_Packet_Enable: %s\n",
+		   val ? "ENABLED" : "DISABLED");
+
+	val = MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, PWRDWN);
+	mac_printf("Power_Down:           %s\n",
+		   val ? "ENABLED" : "DISABLED");
+
+	val = MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, MGKPRCVD);
+	mac_printf("Magic_Packet :                %s\n",
+		   val ? "Received" : "Not Received");
+
+	val = MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, RWKPRCVD);
+	mac_printf("Remote_Wakeup_Packet :       %s\n",
+		   val ? "Received" : "Not Received");
+
+	val = MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, RWKPTR);
+	mac_printf("Remote_Wakeup_FIFO_Pointer : %d\n", val);
+
+	val = MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, GLBLUCAST);
+	mac_printf("Global_unicast:               %d\n", val);
+
+	for (i = 0; i < 8; i++) {
+		value[i] = XGMAC_RGRD(pdata, MAC_RWK_PFR);
+		mac_printf("Remote_Wakeup_Packet_REG[%d]:       %08x\n",
+			   i, value[i]);
+	}
+
+	return 0;
+}
+
+#if defined(CHIPTEST) && CHIPTEST
+int xgmac_get_stats_all(void *pdev)
+{
+	int i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	for (i = 0; i < pdata->max_mac; i++) {
+		mac_printf("XGMAC %d: Reading rmon\n", i);
+		xgmac_read_mmc_stats(&prv_data[i], &prv_data[i].mmc_stats);
+	}
+
+	mac_printf("\nTYPE                      %s\t%s\t%s\n", "      XGMAC 2", "    XGMAC 3", "    XGMAC 4\n");
+
+	mac_printf("Rx_Packets                = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11d\t", prv_data[i].mmc_stats.rxframecount_gb);
+
+	mac_printf("\n");
+
+	mac_printf("Rx_Bytes                  = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11d\t", prv_data[i].mmc_stats.rxoctetcount_gb);
+
+	mac_printf("\n");
+
+	mac_printf("Rx_Byte_errors            = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11d\t",
+			   (prv_data[i].mmc_stats.rxoctetcount_gb -
+			    prv_data[i].mmc_stats.rxoctetcount_g));
+
+	mac_printf("\n");
+
+	mac_printf("Rx_Pauseframe             = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11d\t", prv_data[i].mmc_stats.rxpauseframes);
+
+	mac_printf("\n");
+
+	mac_printf("Rx_Crc_Errors             = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11d\t", prv_data[i].mmc_stats.rxcrcerror);
+
+	mac_printf("\n");
+
+	mac_printf("Rx_Fifo_Errors            = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11d\t", prv_data[i].mmc_stats.rxfifooverflow);
+
+	mac_printf("\n");
+	mac_printf("\n");
+
+	mac_printf("Tx_Packets                = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11d\t", prv_data[i].mmc_stats.txframecount_gb);
+
+	mac_printf("\n");
+
+	mac_printf("Tx_Bytes                  = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11d\t", prv_data[i].mmc_stats.txoctetcount_gb);
+
+	mac_printf("\n");
+
+	mac_printf("Tx_Packet_Errors          = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11d\t",
+			   (prv_data[i].mmc_stats.txframecount_gb -
+			    prv_data[i].mmc_stats.txframecount_g));
+
+	mac_printf("\n");
+
+	mac_printf("Tx_Byte_Errors            = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11d\t",
+			   (prv_data[i].mmc_stats.txoctetcount_gb -
+			    prv_data[i].mmc_stats.txoctetcount_g));
+
+	mac_printf("\n");
+
+	mac_printf("Tx_Pauseframe             = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11d\t", prv_data[i].mmc_stats.txpauseframes);
+
+	mac_printf("\n");
+
+	mac_printf("Tx_underflow_error        = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11d\t", prv_data[i].mmc_stats.txunderflowerror);
+
+	mac_printf("\n");
+	return 0;
+}
+
+int xgmac_get_stats(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int i = 0;
+	struct xgmac_mmc_stats *pstats = &pdata->mmc_stats;
+
+	mac_printf("XGMAC %d: Reading rmon\n", pdata->mac_idx);
+
+	xgmac_read_mmc_stats(pdev, pstats);
+
+	mac_printf("\nTYPE                            XGMAC %d\n\n",
+		   pdata->mac_idx);
+	mac_printf("Rx_Packets                = ");
+
+	mac_printf("%11d\t", pdata->mmc_stats.rxframecount_gb);
+
+	mac_printf("\n");
+
+	mac_printf("Rx_Bytes                  = ");
+
+	mac_printf("%11d\t", pdata->mmc_stats.rxoctetcount_gb);
+
+	mac_printf("\n");
+
+	mac_printf("Rx_Byte_errors            = ");
+
+	mac_printf("%11d\t",
+		   (pdata->mmc_stats.rxoctetcount_gb -
+		    pdata->mmc_stats.rxoctetcount_g));
+
+	mac_printf("\n");
+
+	mac_printf("Rx_Pauseframe             = ");
+
+	mac_printf("%11d\t", pdata->mmc_stats.rxpauseframes);
+
+	mac_printf("\n");
+
+	mac_printf("Rx_Crc_Errors             = ");
+
+	mac_printf("%11d\t", pdata->mmc_stats.rxcrcerror);
+
+	mac_printf("\n");
+
+	mac_printf("Rx_Fifo_Errors            = ");
+
+	mac_printf("%11d\t", pdata->mmc_stats.rxfifooverflow);
+
+	mac_printf("\n");
+	mac_printf("\n");
+
+	mac_printf("Tx_Packets                = ");
+
+	mac_printf("%11d\t", pdata->mmc_stats.txframecount_gb);
+
+	mac_printf("\n");
+
+	mac_printf("Tx_Bytes                  = ");
+
+	mac_printf("%11d\t", pdata->mmc_stats.txoctetcount_gb);
+
+	mac_printf("\n");
+
+	mac_printf("Tx_Packet_Errors          = ");
+
+	mac_printf("%11d\t",
+		   (pdata->mmc_stats.txframecount_gb -
+		    pdata->mmc_stats.txframecount_g));
+
+	mac_printf("\n");
+
+	mac_printf("Tx_Byte_Errors            = ");
+
+	mac_printf("%11d\t",
+		   (pdata->mmc_stats.txoctetcount_gb -
+		    pdata->mmc_stats.txoctetcount_g));
+
+	mac_printf("\n");
+
+	mac_printf("Tx_Pauseframe             = ");
+
+	mac_printf("%11d\t", pdata->mmc_stats.txpauseframes);
+
+	mac_printf("\n");
+
+	mac_printf("Tx_underflow_error        = ");
+
+	mac_printf("%11d\t", pdata->mmc_stats.txunderflowerror);
+
+	mac_printf("\n");
+	return 0;
+}
+#endif
+
+#if defined(PC_UTILITY) && PC_UTILITY
+int xgmac_get_stats_all(void *pdev)
+{
+	u32 i = 0;
+	struct mac_ops *ops;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	for (i = 0; i < pdata->max_mac; i++) {
+		ops = gsw_get_mac_ops(0, i);
+		mac_printf("XGMAC %d: Reading rmon\n", i);
+		xgmac_read_mmc_stats(ops, &prv_data[i].mmc_stats);
+	}
+
+	mac_printf("\nTYPE                        ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%9s %d", "XGMAC", i);
+
+	mac_printf("\n");
+
+	mac_printf("Rx_Packets                = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11llu", prv_data[i].mmc_stats.rxframecount_gb);
+
+	mac_printf("\n");
+
+	mac_printf("Rx_Bytes                  = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11llu", prv_data[i].mmc_stats.rxoctetcount_gb);
+
+	mac_printf("\n");
+
+	mac_printf("Rx_Byte_errors            = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11llu",
+			   (prv_data[i].mmc_stats.rxoctetcount_gb -
+			    prv_data[i].mmc_stats.rxoctetcount_g));
+
+	mac_printf("\n");
+
+	mac_printf("Rx_Pauseframe             = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11llu", prv_data[i].mmc_stats.rxpauseframes);
+
+	mac_printf("\n");
+
+	mac_printf("Rx_Crc_Errors             = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11llu", prv_data[i].mmc_stats.rxcrcerror);
+
+	mac_printf("\n");
+
+	mac_printf("Rx_Fifo_Errors            = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11llu", prv_data[i].mmc_stats.rxfifooverflow);
+
+	mac_printf("\n");
+	mac_printf("\n");
+
+	mac_printf("Tx_Packets                = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11llu", prv_data[i].mmc_stats.txframecount_gb);
+
+	mac_printf("\n");
+
+	mac_printf("Tx_Bytes                  = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11llu", prv_data[i].mmc_stats.txoctetcount_gb);
+
+	mac_printf("\n");
+
+	mac_printf("Tx_Packet_Errors          = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11llu",
+			   (prv_data[i].mmc_stats.txframecount_gb -
+			    prv_data[i].mmc_stats.txframecount_g));
+
+	mac_printf("\n");
+
+	mac_printf("Tx_Byte_Errors            = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11llu",
+			   (prv_data[i].mmc_stats.txoctetcount_gb -
+			    prv_data[i].mmc_stats.txoctetcount_g));
+
+	mac_printf("\n");
+
+	mac_printf("Tx_Pauseframe             = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11llu", prv_data[i].mmc_stats.txpauseframes);
+
+	mac_printf("\n");
+
+	mac_printf("Tx_underflow_error        = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		mac_printf("%11llu", prv_data[i].mmc_stats.txunderflowerror);
+
+	return 0;
+}
+
+int xgmac_get_stats(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct xgmac_mmc_stats *pstats = &pdata->mmc_stats;
+
+	mac_printf("XGMAC %d: Reading rmon\n", pdata->mac_idx);
+
+	xgmac_read_mmc_stats(pdev, pstats);
+
+	mac_printf("\nTYPE                            XGMAC %d\n\n",
+		   pdata->mac_idx);
+	mac_printf("Rx_Packets                = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.rxframecount_gb);
+	mac_printf("\n");
+
+	mac_printf("Rx_Bytes                  = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.rxoctetcount_gb);
+	mac_printf("\n");
+
+	mac_printf("Rx_Byte_errors            = ");
+
+	mac_printf("%11llu\n",
+		   (pdata->mmc_stats.rxoctetcount_gb -
+		    pdata->mmc_stats.rxoctetcount_g));
+	mac_printf("\n");
+
+	mac_printf("Rx_Pauseframe             = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.rxpauseframes);
+	mac_printf("\n");
+
+	mac_printf("Rx_Crc_Errors             = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.rxcrcerror);
+	mac_printf("\n");
+
+	mac_printf("Rx_Fifo_Errors            = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.rxfifooverflow);
+	mac_printf("\n");
+
+	mac_printf("\n");
+
+	mac_printf("Tx_Packets                = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.txframecount_gb);
+	mac_printf("\n");
+
+	mac_printf("Tx_Bytes                  = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.txoctetcount_gb);
+	mac_printf("\n");
+
+	mac_printf("Tx_Packet_Errors          = ");
+
+	mac_printf("%11llu\n",
+		   (pdata->mmc_stats.txframecount_gb -
+		    pdata->mmc_stats.txframecount_g));
+	mac_printf("\n");
+
+	mac_printf("Tx_Byte_Errors            = ");
+
+	mac_printf("%11llu\n",
+		   (pdata->mmc_stats.txoctetcount_gb -
+		    pdata->mmc_stats.txoctetcount_g));
+	mac_printf("\n");
+
+	mac_printf("Tx_Pauseframe             = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.txpauseframes);
+	mac_printf("\n");
+
+	mac_printf("Tx_underflow_error        = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.txunderflowerror);
+	mac_printf("\n");
+
+	return 0;
+}
+#endif
+
+#ifdef __KERNEL__
+int xgmac_get_stats_all(void *pdev)
+{
+	u32 i = 0;
+	struct mac_ops *ops;
+	static char buf[256] = {'\0'};
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	memset((char *)buf, '\0', 256);
+
+	for (i = 0; i < pdata->max_mac; i++) {
+		ops = gsw_get_mac_ops(0, i);
+		mac_printf("XGMAC %d: Reading rmon\n", i);
+		xgmac_read_mmc_stats(ops, &prv_data[i].mmc_stats);
+	}
+
+	mac_printf("\nTYPE                        ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		sprintf(buf + strlen(buf), "%9s %d\t", "XGMAC", i);
+
+	mac_printf(buf);
+
+	memset((char *)buf, '\0', 256);
+
+	mac_printf("Rx_Packets                = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		sprintf(buf + strlen(buf), "%11llu\t",
+			prv_data[i].mmc_stats.rxframecount_gb);
+
+	mac_printf(buf);
+
+	memset((char *)buf, '\0', 256);
+
+	mac_printf("Rx_Bytes                  = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		sprintf(buf + strlen(buf), "%11llu\t",
+			prv_data[i].mmc_stats.rxoctetcount_gb);
+
+	mac_printf(buf);
+
+	memset((char *)buf, '\0', 256);
+
+	mac_printf("Rx_Byte_errors            = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		sprintf(buf + strlen(buf), "%11llu\t",
+			(prv_data[i].mmc_stats.rxoctetcount_gb -
+			 prv_data[i].mmc_stats.rxoctetcount_g));
+
+	mac_printf(buf);
+
+	memset((char *)buf, '\0', 256);
+
+	mac_printf("Rx_Pauseframe             = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		sprintf(buf + strlen(buf), "%11llu\t",
+			prv_data[i].mmc_stats.rxpauseframes);
+
+	mac_printf(buf);
+
+	memset((char *)buf, '\0', 256);
+
+	mac_printf("Rx_Crc_Errors             = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		sprintf(buf + strlen(buf), "%11llu\t",
+			prv_data[i].mmc_stats.rxcrcerror);
+
+	mac_printf(buf);
+
+	memset((char *)buf, '\0', 256);
+
+	mac_printf("Rx_Fifo_Errors            = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		sprintf(buf + strlen(buf), "%11llu\t",
+			prv_data[i].mmc_stats.rxfifooverflow);
+
+	mac_printf(buf);
+
+	memset((char *)buf, '\0', 256);
+
+	mac_printf("\n");
+
+	mac_printf("Tx_Packets                = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		sprintf(buf + strlen(buf), "%11llu\t",
+			prv_data[i].mmc_stats.txframecount_gb);
+
+	mac_printf(buf);
+
+	memset((char *)buf, '\0', 256);
+
+	mac_printf("Tx_Bytes                  = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		sprintf(buf + strlen(buf), "%11llu\t",
+			prv_data[i].mmc_stats.txoctetcount_gb);
+
+	mac_printf(buf);
+
+	memset((char *)buf, '\0', 256);
+
+	mac_printf("Tx_Packet_Errors          = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		sprintf(buf + strlen(buf), "%11llu\t",
+			(prv_data[i].mmc_stats.txframecount_gb -
+			 prv_data[i].mmc_stats.txframecount_g));
+
+	mac_printf(buf);
+
+	memset((char *)buf, '\0', 256);
+
+	mac_printf("Tx_Byte_Errors            = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		sprintf(buf + strlen(buf), "%11llu\t",
+			(prv_data[i].mmc_stats.txoctetcount_gb -
+			 prv_data[i].mmc_stats.txoctetcount_g));
+
+	mac_printf(buf);
+
+	memset((char *)buf, '\0', 256);
+
+	mac_printf("Tx_Pauseframe             = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		sprintf(buf + strlen(buf), "%11llu\t",
+			prv_data[i].mmc_stats.txpauseframes);
+
+	mac_printf(buf);
+
+	memset((char *)buf, '\0', 256);
+
+	mac_printf("Tx_underflow_error        = ");
+
+	for (i = 0; i < pdata->max_mac; i++)
+		sprintf(buf + strlen(buf), "%11llu\t",
+			prv_data[i].mmc_stats.txunderflowerror);
+
+	mac_printf(buf);
+
+	return 0;
+}
+
+int xgmac_get_stats(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct xgmac_mmc_stats *pstats = &pdata->mmc_stats;
+
+	mac_printf("XGMAC %d: Reading rmon\n", pdata->mac_idx);
+
+	xgmac_read_mmc_stats(pdev, pstats);
+
+	mac_printf("\nTYPE                            XGMAC %d\n\n",
+		   pdata->mac_idx);
+	mac_printf("Rx_Packets                = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.rxframecount_gb);
+
+	mac_printf("Rx_Bytes                  = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.rxoctetcount_gb);
+
+	mac_printf("Rx_Byte_errors            = ");
+
+	mac_printf("%11llu\n",
+		   (pdata->mmc_stats.rxoctetcount_gb -
+		    pdata->mmc_stats.rxoctetcount_g));
+
+	mac_printf("Rx_Pauseframe             = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.rxpauseframes);
+
+	mac_printf("Rx_Crc_Errors             = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.rxcrcerror);
+
+	mac_printf("Rx_Fifo_Errors            = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.rxfifooverflow);
+
+	mac_printf("\n");
+
+	mac_printf("Tx_Packets                = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.txframecount_gb);
+
+	mac_printf("Tx_Bytes                  = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.txoctetcount_gb);
+
+	mac_printf("Tx_Packet_Errors          = ");
+
+	mac_printf("%11llu\n",
+		   (pdata->mmc_stats.txframecount_gb -
+		    pdata->mmc_stats.txframecount_g));
+
+	mac_printf("Tx_Byte_Errors            = ");
+
+	mac_printf("%11llu\n",
+		   (pdata->mmc_stats.txoctetcount_gb -
+		    pdata->mmc_stats.txoctetcount_g));
+
+	mac_printf("Tx_Pauseframe             = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.txpauseframes);
+
+	mac_printf("Tx_underflow_error        = ");
+
+	mac_printf("%11llu\n", pdata->mmc_stats.txunderflowerror);
+
+	return 0;
+}
+#endif
+
+
+int xgmac_get_priv_data(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	mac_printf("XGMAC MODULE          = %d\n\n", pdata->mac_idx);
+	mac_printf("xgmac_ctrl_reg        = %08x\n", pdata->xgmac_ctrl_reg);
+	mac_printf("xgmac_data0_reg       = %08x\n", pdata->xgmac_data0_reg);
+	mac_printf("xgmac_data1_reg       = %08x\n", pdata->xgmac_data1_reg);
+	mac_printf("tx_q_count            = %d\n", pdata->tx_q_count);
+	mac_printf("rx_q_count            = %d\n", pdata->rx_q_count);
+	mac_printf("tx_sf_mode            = %d\n", pdata->tx_sf_mode);
+	mac_printf("tx_threshold          = %d\n", pdata->tx_threshold);
+	mac_printf("rx_sf_mode            = %d\n", pdata->rx_sf_mode);
+	mac_printf("rx_threshold          = %d\n", pdata->rx_threshold);
+	mac_printf("tx_pause              = %d\n", pdata->tx_pause);
+	mac_printf("rx_pause              = %d\n", pdata->rx_pause);
+	mac_printf("mac_addr              = %02x:%02x:%02x:%02x:%02x:%02x\n",
+		   pdata->mac_addr[0],
+		   pdata->mac_addr[1],
+		   pdata->mac_addr[2],
+		   pdata->mac_addr[3],
+		   pdata->mac_addr[4],
+		   pdata->mac_addr[5]);
+	mac_printf("tstamp_addend         = %d\n", pdata->tstamp_addend);
+#if defined(CHIPTEST) && CHIPTEST
+	mac_printf("tx_tstamp             = %d\n", pdata->tx_tstamp);
+#else
+	mac_printf("tx_tstamp             = %llu\n", pdata->tx_tstamp);
+#endif
+	mac_printf("promisc_mode          = %d\n", pdata->promisc_mode);
+	mac_printf("all_mcast_mode        = %d\n", pdata->all_mcast_mode);
+	mac_printf("rfa                   = %d\n", pdata->rfa);
+	mac_printf("rfd                   = %d\n", pdata->rfd);
+	mac_printf("tx_mtl_alg            = %d\n", pdata->tx_mtl_alg);
+	mac_printf("rx_mtl_alg            = %d\n", pdata->rx_mtl_alg);
+	mac_printf("mtu                   = %d\n", pdata->mtu);
+	mac_printf("pause_time            = %d\n", pdata->pause_time);
+	mac_printf("rx_checksum_offload   = %d\n",
+		   pdata->rx_checksum_offload);
+	mac_printf("pause_frm_enable      = %d\n", pdata->pause_frm_enable);
+	mac_printf("rmon_reset            = %d\n", pdata->rmon_reset);
+	mac_printf("reg_off               = %d\n", pdata->reg_off);
+	mac_printf("reg_val               = %d\n", pdata->reg_val);
+	mac_printf("sec                   = %d\n", pdata->sec);
+	mac_printf("nsec                  = %d\n", pdata->nsec);
+	mac_printf("phy_speed             = %d\n", pdata->phy_speed);
+	mac_printf("phy_link 			    = %d\n", pdata->phy_link);
+	mac_printf("loopback              = %d\n", pdata->loopback);
+	mac_printf("twt                   = %d\n", pdata->twt);
+	mac_printf("lst                   = %d\n", pdata->lst);
+	mac_printf("lpitxa                = %d\n", pdata->lpitxa);
+	mac_printf("crc_strip             = %d\n", pdata->crc_strip);
+	mac_printf("crc_strip_type        = %d\n", pdata->crc_strip_type);
+	mac_printf("padcrc_strip          = %d\n", pdata->padcrc_strip);
+	mac_printf("dbg_en                = %d\n", pdata->dbg_en);
+	mac_printf("dbg_pktie             = %d\n", pdata->dbg_pktie);
+	mac_printf("dbg_rst_sel           = %d\n", pdata->dbg_rst_sel);
+	mac_printf("dbg_rst_all           = %d\n", pdata->dbg_rst_all);
+	mac_printf("fef                   = %d\n", pdata->fef);
+	mac_printf("fup                   = %d\n", pdata->fup);
+	return 0;
+}
+
+int xgmac_get_all_hw_features(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_hfr0, mac_hfr1, mac_hfr2;
+	/* Hardware features of the device */
+	struct xgmac_hw_features *hw_feat = &pdata->hw_feat;
+
+	mac_hfr0 = XGMAC_RGRD(pdata, MAC_HW_F0);
+	mac_hfr1 = XGMAC_RGRD(pdata, MAC_HW_F1);
+	mac_hfr2 = XGMAC_RGRD(pdata, MAC_HW_F2);
+
+	memset(hw_feat, 0, sizeof(*hw_feat));
+
+	hw_feat->version = XGMAC_RGRD(pdata, MAC_VR);
+
+	/* Hardware feature register 0 */
+	mac_printf("========== Hardware feature register 0 ==============\n");
+	hw_feat->gmii        = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, GMIISEL);
+
+	if (hw_feat->gmii)
+		mac_printf("\t 1Gbps Supported\n");
+
+	hw_feat->vlhash      = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, VLHASH);
+
+	if (hw_feat->vlhash)
+		mac_printf("\t Enable Address Filter VLAN Hash Table "
+			   "option is selected.\n");
+
+	hw_feat->sma         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, SMASEL);
+
+	if (hw_feat->sma)
+		mac_printf("\t Enable Station Management Block "
+			   "(MDIO Interface) option is selected.\n");
+
+	hw_feat->rwk         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, RWKSEL);
+
+	if (hw_feat->rwk)
+		mac_printf("\t Enable Remote Wake-Up Packet Detection "
+			   "option is selected\n");
+
+	hw_feat->mgk         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, MGKSEL);
+
+	if (hw_feat->mgk)
+		mac_printf("\t Enable Magic Packet Detection option "
+			   "is selected.\n");
+
+	hw_feat->mmc         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, MMCSEL);
+
+	if (hw_feat->mmc)
+		mac_printf("\t Enable XGMAC Management Counter (MMC) option "
+			   "is selected.\n");
+
+	hw_feat->aoe         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, ARPOFFSEL);
+
+	if (hw_feat->aoe)
+		mac_printf("\t Enable IPv4 ARP Offload option "
+			   "is selected\n");
+
+	hw_feat->ts          = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, TSSEL);
+
+	if (hw_feat->ts)
+		mac_printf("\t Enable IEEE 1588 Timestamp Support option "
+			   "is selected.\n");
+
+	hw_feat->eee         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, EEESEL);
+
+	if (hw_feat->eee)
+		mac_printf("\t Enable Energy Efficient Ethernet (EEE) option "
+			   "is selected.\n");
+
+	hw_feat->tx_coe      = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, TXCOESEL);
+
+	if (hw_feat->tx_coe)
+		mac_printf("\t Enable Transmit TCP/IP Checksum Offload option"
+			   "is selected.\n");
+
+	hw_feat->rx_coe      = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, RXCOESEL);
+
+	if (hw_feat->rx_coe)
+		mac_printf("\t Enable Receive TCP/IP Checksum Check option"
+			   "is selected.\n");
+
+	hw_feat->addn_mac   = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, ADDMACADRSEL);
+
+	if (hw_feat->addn_mac)
+		mac_printf("\t Number of additional MAC addresses "
+			   "selected = %d\n", hw_feat->addn_mac);
+
+	hw_feat->ts_src      = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, TSSTSSEL);
+
+	if (hw_feat->ts_src) {
+		if (hw_feat->ts_src == 1)
+			mac_printf("\t Time Stamp time source: INTERNAL\n");
+		else if (hw_feat->ts_src == 2)
+			mac_printf("\t Time Stamp time source: EXTERNAL\n");
+		else if (hw_feat->ts_src == 3)
+			mac_printf("\t Time Stamp time source: "
+				   "INTERNAL & EXTERNAL\n");
+	} else {
+		mac_printf("\t Time Stamp time source: RESERVED\n");
+	}
+
+	hw_feat->sa_vlan_ins = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, SAVLANINS);
+
+	if (hw_feat->sa_vlan_ins)
+		mac_printf("\t Enable SA and VLAN Insertion on "
+			   "Tx option is selected.\n");
+
+	hw_feat->vxn = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, VXN);
+
+	if (hw_feat->vxn)
+		mac_printf("\t Support for VxLAN/NVGRE is selected\n");
+
+	hw_feat->ediffc = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, EDIFFC);
+
+	if (hw_feat->ediffc)
+		mac_printf("\t EDMA mode Separate Memory is selected "
+			   "for the Descriptor Cache.\n");
+
+	hw_feat->edma = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, EDMA);
+
+	if (hw_feat->edma)
+		mac_printf("\t Enhanced DMA option is selected.\n");
+
+	mac_printf("========== Hardware feature register 1 ==============\n");
+
+	/* Hardware feature register 1 */
+	hw_feat->rx_fifo_size  =
+		MAC_GET_VAL(mac_hfr1, MAC_HW_F1, RXFIFOSIZE);
+
+	if (hw_feat->rx_fifo_size)
+		mac_printf("\t Rx Fifo Size %d:%d bytes\n",
+			   hw_feat->rx_fifo_size,
+			   (1 << (hw_feat->rx_fifo_size + 7)));
+
+	hw_feat->tx_fifo_size  =
+		MAC_GET_VAL(mac_hfr1, MAC_HW_F1, TXFIFOSIZE);
+
+	if (hw_feat->tx_fifo_size)
+		mac_printf("\t Tx Fifo Size %d:%d bytes\n",
+			   hw_feat->tx_fifo_size,
+			   (1 << (hw_feat->tx_fifo_size + 7)));
+
+	hw_feat->osten  = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, OSTEN);
+
+	if (hw_feat->osten)
+		mac_printf("\t One Step Timestamping Enabled\n");
+
+	hw_feat->ptoen  = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, PTOEN);
+
+	if (hw_feat->ptoen)
+		mac_printf("\t Enable PTP Timestamp Offload Feature is "
+			   "selected\n");
+
+	hw_feat->adv_ts_hi     = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, ADVTHWORD);
+
+	if (hw_feat->adv_ts_hi)
+		mac_printf("\t Add IEEE 1588 Higher Word Register option is "
+			   "selected.\n");
+
+	hw_feat->dma_width     = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, ADDR64);
+
+	if (hw_feat->dma_width == 0)
+		mac_printf("\t Dma Width: 32\n");
+	else if (hw_feat->dma_width == 1)
+		mac_printf("\t Dma Width: 40\n");
+	else if (hw_feat->dma_width == 2)
+		mac_printf("\t Dma Width: 48\n");
+	else if (hw_feat->dma_width == 3)
+		mac_printf("\t Dma Width: RESERVED\n");
+
+	hw_feat->dcb           = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, DCBEN);
+
+	if (hw_feat->dcb)
+		mac_printf("\t Enable Data Center Bridging option is "
+			   "selected.\n");
+
+	hw_feat->sph           = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, SPHEN);
+
+	if (hw_feat->sph)
+		mac_printf("\t Enable Split Header Structure option is "
+			   "selected.\n");
+
+	hw_feat->tso           = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, TSOEN);
+
+	if (hw_feat->tso)
+		mac_printf("\t Enable TCP Segmentation Offloading for "
+			   "TCP/IP Packets option is selected.\n");
+
+	hw_feat->dma_debug     = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, DBGMEMA);
+
+	if (hw_feat->dma_debug)
+		mac_printf("\t Enable Debug Memory Access option is "
+			   "selected.\n");
+
+	hw_feat->rss           = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, RSSEN);
+
+	if (hw_feat->rss)
+		mac_printf("\t RSS Feature Enabled\n");
+
+	hw_feat->tc_cnt        = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, NUMTC);
+	mac_printf("\t Number of traffic classes selected: %d\n",
+		   (hw_feat->tc_cnt + 1));
+
+	hw_feat->hash_table_size =
+		MAC_GET_VAL(mac_hfr1, MAC_HW_F1, HASHTBLSZ);
+
+	if (hw_feat->hash_table_size)
+		mac_printf("\t Hash table size: %d\n",
+			   (64 << (hw_feat->hash_table_size - 1)));
+	else
+		mac_printf("\t Hash table size: No hash table selected\n");
+
+	hw_feat->l3l4_filter_num =
+		MAC_GET_VAL(mac_hfr1, MAC_HW_F1, L3L4FNUM);
+
+	if (hw_feat->l3l4_filter_num)
+		mac_printf("\t Total number of L3 or L4 filters %d\n",
+			   hw_feat->l3l4_filter_num);
+
+	mac_printf("========== Hardware feature register 2 ==============\n");
+
+	/* Hardware feature register 2 */
+	hw_feat->rx_q_cnt     = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, RXQCNT);
+	mac_printf("\t Number of MTL RX Q: %d\n", (hw_feat->rx_q_cnt + 1));
+
+	hw_feat->tx_q_cnt     = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, TXQCNT);
+	mac_printf("\t Number of MTL TX Q: %d\n", (hw_feat->tx_q_cnt + 1));
+
+	hw_feat->rx_ch_cnt    = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, RXCHCNT);
+
+	if (hw_feat->rx_ch_cnt)
+		mac_printf("\t Number of DMA Receive channels: %d\n",
+			   (hw_feat->rx_ch_cnt + 1));
+
+	hw_feat->tx_ch_cnt    = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, TXCHCNT);
+
+	if (hw_feat->tx_ch_cnt)
+		mac_printf("\t Number of DMA transmit channels: %d\n",
+			   (hw_feat->tx_ch_cnt + 1));
+
+	hw_feat->pps_out_num  = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, PPSOUTNUM);
+
+	if (hw_feat->pps_out_num)
+		mac_printf("\t Number of PPS outputs %d\n",
+			   hw_feat->pps_out_num);
+
+	hw_feat->aux_snap_num = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, AUXSNAPNUM);
+
+	if (hw_feat->aux_snap_num) {
+		if (hw_feat->aux_snap_num > 4)
+			mac_printf("\t Number of Auxiliary Snapshot Inputs: "
+				   "RESERVED\n");
+		else
+			mac_printf("\t Number of Auxiliary Snapshot Inputs: "
+				   "%d\n", hw_feat->aux_snap_num);
+	} else {
+		mac_printf("\t No Auxiliary input\n");
+	}
+
+	hw_feat->tc_cnt++;
+	hw_feat->rx_q_cnt++;
+	hw_feat->tx_q_cnt++;
+	return 0;
+}
+
+int xgmac_get_all_hw_settings(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	mac_printf("\n\n\t\t\tGET ALL SETTINGS for XGMAC %d\n",
+		   pdata->mac_idx);
+	mac_printf("\n");
+	xgmac_get_tx_cfg(pdev);
+	xgmac_get_counters_cfg(pdev);
+	xgmac_get_fifo_size(pdev);
+	xgmac_get_flow_control_threshold(pdev);
+	xgmac_get_mtl_rx_flow_ctl(pdev);
+	xgmac_get_mtl_tx(pdev);
+	xgmac_get_mtl_rx(pdev);
+	xgmac_get_mtl_q_alg(pdev);
+
+	xgmac_get_crc_settings(pdev);
+
+	xgmac_get_eee_settings(pdev);
+	xgmac_dbg_eee_status(pdev);
+
+	xgmac_get_mac_settings(pdev);
+	xgmac_get_mtu_settings(pdev);
+	xgmac_get_checksum_offload(pdev);
+	xgmac_get_mac_addr(pdev);
+	xgmac_get_mac_rx_mode(pdev);
+	xgmac_get_rx_vlan_filtering_mode(pdev);
+	xgmac_get_mac_speed(pdev);
+	xgmac_get_pause_frame_ctl(pdev);
+	xgmac_get_mac_loopback_mode(pdev);
+	xgmac_get_tstamp_settings(pdev);
+	xgmac_get_debug_sts(pdev);
+	xgmac_dbg_int_sts(pdev);
+	xgmac_get_fup_fep_setting(pdev);
+	xgmac_get_ipg(pdev);
+	xgmac_dbg_pmt(pdev);
+	xgmac_get_mac_rxtx_sts(pdev);
+	xgmac_get_mtl_missed_pkt_cnt(pdev);
+
+	return 0;
+}
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mac_api.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mac_api.c
new file mode 100644
index 000000000000..ef76207ba225
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mac_api.c
@@ -0,0 +1,1685 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+/* =========================================================================
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ * The Synopsys DWC ETHER XGMAC Software Driver and documentation (hereinafter
+ * "Software") is an unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto.  Permission is hereby granted,
+ * free of charge, to any person obtaining a copy of this software annotated
+ * with this license and the Software, to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================= */
+
+
+#include <xgmac.h>
+#ifdef __KERNEL__
+#include <xgmac_ptp.h>
+#include <net/switch_api/gsw_irq.h>
+#else
+#include <gsw_irq.h>
+#endif
+
+/* LM: Loopback Mode
+ * When this bit is set, the MAC operates in the loopback mode at GMII or
+ * XGMII. The (X)GMII Rx clock input (clk_rx_312pt5_i) is required for the
+ * loopback to work properly. This is because the Tx clock is not internally
+ * looped back.
+ */
+int xgmac_set_loopback(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val;
+
+	reg_val = XGMAC_RGRD(pdata, MAC_RX_CFG);
+
+	if (MAC_GET_VAL(reg_val, MAC_RX_CFG, LM) != val) {
+		mac_printf("XGMAC %d: LOOPBACK mode: %s\n",
+			   pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(reg_val, MAC_RX_CFG, LM, val);
+		XGMAC_RGWR(pdata, MAC_RX_CFG, reg_val);
+	}
+
+	return 0;
+}
+
+/* TFE: Transmit Flow Control Enable
+ * When this bit is set, the MAC enables the flow control operation based on
+ * Tx Pause packets.
+ * When this bit is reset, the flow control operation in the
+ * MAC is disabled, and the MAC does not transmit any Pause packets by
+ * itself
+ * RFE: Receive Flow Control Enable
+ * When this bit is set and the MAC is operating in full-duplex mode, the MAC
+ * decodes the received Pause packet and disables its transmitter for a
+ * specified (Pause) time. When this bit is reset, the decode function of the
+ * Pause packet is disabled.
+ * PFCE: Priority Based Flow Control Enable
+ * When 1, it enables generation and reception of priority-based flow control
+ * (PFC) packets.
+ * When 0, it enables generation and reception of 802.3x Pause control packets.
+ * This bit is reserved when the Enable Data Center Bridging option is not
+ * selected.
+ */
+int xgmac_disable_tx_flow_ctl(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val;
+
+	reg_val = XGMAC_RGRD(pdata, MAC_TX_FCR);
+
+	if (MAC_GET_VAL(reg_val, MAC_TX_FCR, TFE) != 0) {
+		mac_printf("XGMAC %d: Disable TX Flow Control\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(reg_val, MAC_TX_FCR, TFE, 0);
+		XGMAC_RGWR(pdata, MAC_TX_FCR, reg_val);
+	}
+
+	return 0;
+}
+
+int xgmac_disable_rx_flow_ctl(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val;
+
+	reg_val = XGMAC_RGRD(pdata, MAC_RX_FCR);
+
+	if (MAC_GET_VAL(reg_val, MAC_RX_FCR, RFE) != 0) {
+		mac_printf("XGMAC %d: Disable RX Flow Control\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(reg_val, MAC_RX_FCR, RFE, 0);
+		XGMAC_RGWR(pdata, MAC_RX_FCR, reg_val);
+	}
+
+	return 0;
+}
+
+int xgmac_enable_tx_flow_ctl(void *pdev, u32 pause_time)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val;
+
+	reg_val = XGMAC_RGRD(pdata, MAC_TX_FCR);
+
+	if (MAC_GET_VAL(reg_val, MAC_TX_FCR, TFE) != 1) {
+		mac_printf("XGMAC %d: Enable TX Flow Control\n",
+			   pdata->mac_idx);
+		/* Enable transmit flow control */
+		MAC_SET_VAL(reg_val, MAC_TX_FCR, TFE, 1);
+		/* Set pause time */
+		MAC_SET_VAL(reg_val, MAC_TX_FCR, PT, pause_time);
+
+		XGMAC_RGWR(pdata, MAC_TX_FCR, reg_val);
+	}
+
+	return 0;
+}
+
+int xgmac_enable_rx_flow_ctl(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val;
+
+	reg_val = XGMAC_RGRD(pdata, MAC_RX_FCR);
+
+	if (MAC_GET_VAL(reg_val, MAC_RX_FCR, RFE) != 1) {
+		mac_printf("XGMAC %d: Enable RX Flow Control\n",
+			   pdata->mac_idx);
+		/* Enable Receive flow control */
+		MAC_SET_VAL(reg_val, MAC_RX_FCR, RFE, 1);
+		// TODO: Need to check whether this is needed
+		MAC_SET_VAL(reg_val, MAC_RX_FCR, PFCE, 0);
+
+		XGMAC_RGWR(pdata, MAC_RX_FCR, reg_val);
+	}
+
+	return 0;
+}
+
+/* FCB: Flow Control Busy
+ * This bit initiates a Pause packet if the TFE bit is set. To initiate a Pause
+ * packet, the application must set this bit to 1'b1. During Control packet
+ * transfer, this bit continues to be set to indicate that a packet
+ * transmission is in progress. When Pause packet transmission is complete,
+ * the MAC resets this bit to 1'b0. You should not write to this register
+ * until this bit is cleared
+ */
+int xgmac_initiate_pause_tx(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val;
+
+	reg_val = XGMAC_RGRD(pdata, MAC_TX_FCR);
+
+	if (MAC_GET_VAL(reg_val, MAC_TX_FCR, TFE) == 0) {
+		mac_printf("XGMAC %d: Pause pkt will be txd only if TFE bit is set\n",
+			   pdata->mac_idx);
+		return 0;
+	}
+
+	MAC_SET_VAL(reg_val, MAC_TX_FCR, FCB, 1);
+
+	/* Initiate Pause TX */
+	XGMAC_RGWR(pdata, MAC_TX_FCR, reg_val);
+
+	while (1) {
+		reg_val = XGMAC_RGRD(pdata, MAC_TX_FCR);
+
+		if (MAC_GET_VAL(reg_val, MAC_TX_FCR, FCB) == 0) {
+			mac_printf("XGMAC %d: Pause Pkt Txd complete\n",
+				   pdata->mac_idx);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+/* Clear all the MAC interrupts */
+int xgmac_clear_mac_int(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_isr;
+
+	/* Clear all the interrupts which are set */
+	mac_isr = XGMAC_RGRD(pdata, MAC_ISR);
+	mac_printf("XGMAC %d Clearing MAC ISR registers with %08x\n",
+		   pdata->mac_idx, mac_isr);
+	XGMAC_RGWR(pdata, MAC_ISR, mac_isr);
+	return 0;
+}
+
+int xgmac_set_mac_int(void *pdev, u32 event, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 mac_ier = XGMAC_RGRD(pdata, MAC_IER);
+	u32 mtl_q_ier = XGMAC_RGRD(pdata, MTL_Q_IER);
+
+	switch (event) {
+	/* Enable Timestamp interrupt */
+	case XGMAC_TSTAMP_EVNT:
+		MAC_SET_VAL(mac_ier, MAC_IER, TSIE, val);
+		break;
+
+	/* Enable LPI interrupt (EEE) */
+	case XGMAC_LPI_EVNT:
+		MAC_SET_VAL(mac_ier, MAC_IER, LPIIE, val);
+		break;
+
+	/* Enable transmit error status interrupt */
+	case XGMAC_TXERR_STS_EVNT:
+		MAC_SET_VAL(mac_ier, MAC_IER, TXESIE, val);
+		break;
+
+	/* Enable Receive error status interrupt */
+	case XGMAC_RXERR_STS_EVNT:
+		MAC_SET_VAL(mac_ier, MAC_IER, RXESIE, val);
+		break;
+
+	/* Enable power management interrupt */
+	case XGMAC_PMT_EVNT:
+		MAC_SET_VAL(mac_ier, MAC_IER, PMTIE, val);
+		break;
+
+	/* Tx Q Overflow Interrupt Enable */
+	case XGMAC_TXQ_OVFW_EVNT:
+		MAC_SET_VAL(mtl_q_ier, MTL_Q_IER, TXUIE, val);
+		break;
+
+	/* Rx Q Overflow Interrupt Enable */
+	case XGMAC_RXQ_OVFW_EVNT:
+		MAC_SET_VAL(mtl_q_ier, MTL_Q_IER, ABPSIE, val);
+		break;
+
+	/* Average bits per slot interrupt enable */
+	case XGMAC_AVG_BPS_EVNT:
+		MAC_SET_VAL(mtl_q_ier, MTL_Q_IER, RXOIE, val);
+		break;
+
+	/* Interrupt Enable All */
+	case XGMAC_ALL_EVNT:
+		mac_ier = 0xFFFFFFFF;
+		mtl_q_ier = 0xFFFFFFFF;
+		break;
+
+	default:
+		mac_printf("Unsupported Mac Event\n");
+		return GSW_statusErr;
+	}
+
+	XGMAC_RGWR(pdata, MAC_IER, mac_ier);
+	XGMAC_RGWR(pdata, MTL_Q_IER, mtl_q_ier);
+
+	return 0;
+}
+
+/* USS = 1
+ * SS = 0 10G (USXGMII mode)
+ * SS = 1 5G
+ * SS = 2 2.5G using XGMII
+ * SS = 3 Reserved
+ * USS = 0
+ * SS = 0 10G using XGMII
+ * SS = 2 2.5G using GMII
+ * SS = 3 1G using GMII
+ */
+int xgmac_set_gmii_speed(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_tcr = XGMAC_RGRD(pdata, MAC_TX_CFG);
+
+	xgmac_powerdown(pdev);
+
+	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, USS) != 0)
+		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, USS, 0);
+
+	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, SS) != 0x3) {
+		mac_printf("XGMAC %d: Setting SPEED to GMII 1G\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, SS, 0x3);
+	}
+
+	XGMAC_RGWR(pdata, MAC_TX_CFG, mac_tcr);
+
+	xgmac_powerup(pdev);
+
+	return 0;
+}
+
+int xgmac_set_gmii_2500_speed(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_tcr = XGMAC_RGRD(pdata, MAC_TX_CFG);
+
+	xgmac_powerdown(pdev);
+
+	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, USS) != 0)
+		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, USS, 0);
+
+	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, SS) != 0x2) {
+		mac_printf("XGMAC %d: Setting SPEED to GMII 2.5G\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, SS, 0x2);
+	}
+
+	XGMAC_RGWR(pdata, MAC_TX_CFG, mac_tcr);
+
+	xgmac_powerup(pdev);
+
+	return 0;
+}
+
+int xgmac_set_xgmii_2500_speed(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_tcr = XGMAC_RGRD(pdata, MAC_TX_CFG);
+
+	xgmac_powerdown(pdev);
+
+	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, USS) != 1)
+		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, USS, 1);
+
+	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, SS) != 0x2) {
+		mac_printf("XGMAC %d: Setting SPEED to XGMII 2.5G\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, SS, 0x2);
+	}
+
+	XGMAC_RGWR(pdata, MAC_TX_CFG, mac_tcr);
+
+	xgmac_powerup(pdev);
+
+	return 0;
+}
+
+int xgmac_set_xgmii_speed(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_tcr = XGMAC_RGRD(pdata, MAC_TX_CFG);
+
+	xgmac_powerdown(pdev);
+
+	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, USS) != 0)
+		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, USS, 0);
+
+	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, SS) != 0) {
+		mac_printf("XGMAC %d: Setting SPEED to XGMII 10G\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, SS, 0);
+	}
+
+	XGMAC_RGWR(pdata, MAC_TX_CFG, mac_tcr);
+
+	xgmac_powerup(pdev);
+
+	return 0;
+}
+
+int xgmac_pause_frame_filtering(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_pfr = XGMAC_RGRD(pdata, MAC_PKT_FR);
+
+	if (MAC_GET_VAL(mac_pfr, MAC_PKT_FR, PCF) != val) {
+		mac_printf("XGMAC %d: Pause filtering %s\n",
+			   pdata->mac_idx, val ? "Enabled" : "Disabled");
+		/* Pause filtering */
+		MAC_SET_VAL(mac_pfr, MAC_PKT_FR, PCF, val);
+	}
+
+	if (MAC_GET_VAL(mac_pfr, MAC_PKT_FR, RA) == 1) {
+		mac_printf("XGMAC %d: MAC Filter Receive All: DISABLED\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_pfr, MAC_PKT_FR, RA, 0);
+	}
+
+	XGMAC_RGWR(pdata, MAC_PKT_FR, mac_pfr);
+
+	return 0;
+}
+
+/* MAC_PKT_FR:
+ * The MAC Packet Filter register contains the filter controls for receiving
+ * packets. Some of the controls from
+ * this register go to the address check block of the MAC which performs the
+ * first level of address filtering. The
+ * second level of filtering is performed on the incoming packet based on other
+ * controls such as Pass Bad Packets and Pass Control Packets.
+ * PR:Promiscuous Mode
+ * When this bit is set, the Address Filtering module passes all incoming
+ * packets irrespective of the destination or source address.
+ * The SA or DA Filter Fails status bits of the Rx Status Word are always
+ * cleared when PR is set.
+ */
+int xgmac_set_promiscuous_mode(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val = XGMAC_RGRD(pdata, MAC_PKT_FR);
+
+	if (MAC_GET_VAL(reg_val, MAC_PKT_FR, PR) != val) {
+		mac_printf("XGMAC %d: %s promiscuous mode\n",
+			   pdata->mac_idx,  val ? "Entering" : "Leaving");
+		MAC_SET_VAL(reg_val, MAC_PKT_FR, PR, val);
+
+		XGMAC_RGWR(pdata, MAC_PKT_FR, reg_val);
+	}
+
+	return 0;
+}
+
+/* PM:Pass All Multicast
+ * When this bit is set, it indicates that all received packets with a
+ * multicast destination address (first bit in the destination address
+ * field is '1') are passed. When this bit is reset, filtering of
+ * multicast packet depends on HMC bit.
+ */
+int xgmac_set_all_multicast_mode(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val = XGMAC_RGRD(pdata, MAC_PKT_FR);
+
+	if (MAC_GET_VAL(reg_val, MAC_PKT_FR, PM) != val) {
+		MAC_SET_VAL(reg_val, MAC_PKT_FR, PM, val);
+		mac_printf("XGMAC %d: %s allmulti mode\n",
+			   pdata->mac_idx,  val ? "Entering" : "Leaving");
+		XGMAC_RGWR(pdata, MAC_PKT_FR, reg_val);
+	}
+
+	return 0;
+}
+
+/* The MAC Address0 High register
+ * This field contains the upper 16 bits [47:32] of the first 6-byte MAC
+ * address. The MAC uses this field for filtering the received packets
+ * and inserting the MAC address in the Transmit Flow Control (Pause)
+ * Packets.
+ * The MAC Address0 Low register
+ * This field contains the lower 32 bits of the first 6-byte MAC address.
+ * The MAC uses this field for filtering the received packets and inserting
+ * the MAC address in the Transmit Flow Control (Pause) Packets.
+ */
+int xgmac_set_mac_address(void *pdev, u8 *mac_addr)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_addr_hi = 0, mac_addr_lo = 0;
+
+	mac_addr_hi = (mac_addr[5] <<  8) | (mac_addr[4] <<  0);
+	mac_addr_lo = (mac_addr[3] << 24) | (mac_addr[2] << 16) |
+		      (mac_addr[1] <<  8) | (mac_addr[0] <<  0);
+
+	/* Since 16 bits only need to check, not checking the previous value */
+	XGMAC_RGWR(pdata, MAC_MACA0HR, mac_addr_hi);
+
+	if (XGMAC_RGRD(pdata, MAC_MACA0LR) != mac_addr_lo) {
+		mac_printf("XGMAC %d: Setting mac_addr as %08x%04x\n",
+			   pdata->mac_idx,  mac_addr_lo,
+			   (mac_addr_hi & 0x0000FFFF));
+		XGMAC_RGWR(pdata, MAC_MACA0LR, mac_addr_lo);
+	}
+
+	return 0;
+}
+
+/* Rx Checksum Offload Engine
+ * Both IPv4 and IPv6 packet in the received Ethernet packets are detected
+ * and processed for data integrity. The MAC receiver identifies IPv4 or
+ * IPv6 packets by checking for value 0x0800 or 0x86DD,
+ * respectively, in the Type field of the received Ethernet packet.
+ * The Rx Checksum Offload Engine calculates the IPv4 header checksums
+ * and checks that they match the received
+ * IPv4 header checksums. The result of this operation (pass or fail) is
+ * given to the RFC module for insertion into the receive status word.
+ * IPC:
+ * if 1, this bit enables the IPv4 header checksum checking and IPv4
+ * or IPv6 TCP, UDP, or ICMP payload checksum checking.
+ * if 0, the COE function in the receiver is disabled.
+ */
+
+int xgmac_set_checksum_offload(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val = XGMAC_RGRD(pdata, MAC_RX_CFG);
+
+	if (MAC_GET_VAL(reg_val, MAC_RX_CFG, IPC) != val) {
+		mac_printf("XGMAC %d: Setting rx_checksum_offload as %s\n",
+			   pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(reg_val, MAC_RX_CFG, IPC, val);
+		XGMAC_RGWR(pdata, MAC_RX_CFG, reg_val);
+	}
+
+	return 0;
+}
+
+/* JE:
+ * if 1, the MAC allows jumbo packets of 9,018 bytes (9,022
+ * bytes for VLAN tagged packets) without reporting a giant packet error in
+ * the Rx packet status.
+ * WD:Watchdog Disable
+ * if 1, the MAC disables the watchdog timer on the receiver.
+ * The MAC can receive packets of up to 16,383 bytes.
+ * if 0, the MAC does not allow more than 2,048 bytes
+ * (10,240 if JE is set high) of the packet being received.
+ * The MAC cuts off any bytes received after 2,048 bytes.
+ * GPSLCE:
+ * if 1, the MAC considers the value in GPSL field in MAC_Rx_Configuration
+ * register to declare a received packet as Giant packet.
+ * This field must be programmed to more than 1,518 bytes.
+ * Otherwise, the MAC considers 1,518 bytes as giant packet limit.
+ * if 0, the MAC considers a received packet as Giant packet when its size
+ * is greater than 1,518 bytes (1522 bytes for tagged packet)
+ * JD: Jabber Disable
+ * if 1, the XGMAC disables the jabber timer on the transmitter.
+ * Transmission of up to 16,383-byte frames is supported.
+ * if 0, the XGMAC cuts off the transmitter if the application sends
+ * more than 2,048 bytes of data
+ * (10,240 bytes if JE (in MAC_Rx_Configuration register is set high)
+ * during transmission.
+ * GPSL: Giant Packet Size Limit
+ * If the received packet size is greater than the value programmed in this
+ * field in units of bytes, the MAC declares the received packet as Giant
+ * packet. The value programmed in this field must be greater than or equal
+ * to 1,518 bytes. Any other programmed value is considered as 1,518bytes.
+ * For VLAN tagged packets, the MAC adds 4 bytes to the programmed value.
+ * The value in this field is applicable when the GPSLCE bit is set in
+ * MAC_Rx_Configuration register.
+ */
+int xgmac_config_jumbo_pkt(void *pdev, u32 mtu)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 mac_rcr, mac_tcr;
+
+	mac_rcr = XGMAC_RGRD(pdata, MAC_RX_CFG);
+	mac_tcr = XGMAC_RGRD(pdata, MAC_TX_CFG);
+
+	if (mtu < XGMAC_MAX_GPSL) { /* upto 9018 configuration */
+		MAC_SET_VAL(mac_rcr, MAC_RX_CFG, JE, 1);
+		MAC_SET_VAL(mac_rcr, MAC_RX_CFG, WD, 0);
+		MAC_SET_VAL(mac_rcr, MAC_RX_CFG, GPSLCE, 0);
+		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, JD, 0);
+	} else { /* upto 16K configuration */
+		MAC_SET_VAL(mac_rcr, MAC_RX_CFG, JE, 0);
+		MAC_SET_VAL(mac_rcr, MAC_RX_CFG, WD, 1);
+		MAC_SET_VAL(mac_rcr, MAC_RX_CFG, GPSLCE, 1);
+		MAC_SET_VAL(mac_rcr, MAC_RX_CFG, GPSL, XGMAC_MAX_SUPPORTED_MTU);
+		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, JD, 1);
+	}
+
+	XGMAC_RGWR(pdata, MAC_RX_CFG, mac_rcr);
+	XGMAC_RGWR(pdata, MAC_TX_CFG, mac_tcr);
+
+	return 0;
+}
+
+int xgmac_config_std_pkt(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 mac_rcr, mac_tcr;
+
+	mac_rcr = XGMAC_RGRD(pdata, MAC_RX_CFG);
+	mac_tcr = XGMAC_RGRD(pdata, MAC_TX_CFG);
+
+	MAC_SET_VAL(mac_rcr, MAC_RX_CFG, JE, 0);
+	MAC_SET_VAL(mac_rcr, MAC_RX_CFG, WD, 0);
+	MAC_SET_VAL(mac_rcr, MAC_RX_CFG, GPSLCE, 0);
+	MAC_SET_VAL(mac_tcr, MAC_TX_CFG, JD, 0);
+
+	XGMAC_RGWR(pdata, MAC_RX_CFG, mac_rcr);
+	XGMAC_RGWR(pdata, MAC_TX_CFG, mac_tcr);
+
+	return 0;
+}
+
+int xgmac_set_rxcrc(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_rcr;
+
+	mac_rcr = XGMAC_RGRD(pdata, MAC_RX_CFG);
+	MAC_SET_VAL(mac_rcr, MAC_RX_CFG, DCRCC, val);
+
+	mac_printf("XGMAC %d: Rx CRC check: %s\n", pdata->mac_idx,
+		   val ? "DISABLED" : "ENABLED");
+
+	XGMAC_RGWR(pdata, MAC_RX_CFG, mac_rcr);
+
+	return 0;
+}
+/* RE:
+ * When this bit is set, the Rx state machine of the MAC is enabled for
+ * receiving packets from the GMII or XGMII interface
+ * ACS:
+ * If 1, the MAC strips the Pad or FCS field on the incoming
+ * packets only if the value of the length field is less than 1,536 bytes. All
+ * received packets with length field greater than or equal to 1,536 bytes are
+ * passed to the application without stripping the Pad or FCS field.
+ * if 0, the MAC passes all incoming packets to the
+ * application, without any modification.
+ * CST:
+ * if 1, the last four bytes (FCS) of all packets of Ether type
+ * (field greater than 1,536) are stripped and dropped before forwarding the
+ * packet to the application.
+ * DCRCC:
+ * if 1, the MAC receiver does not check the CRC field in the received packets.
+ * if 0, the MAC receiver always checks the CRC field in the received packets.
+ */
+
+int xgmac_powerup(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_tcr = XGMAC_RGRD(pdata, MAC_TX_CFG);
+	u32 mac_rcr = XGMAC_RGRD(pdata, MAC_RX_CFG);
+	u32 mac_pfr = XGMAC_RGRD(pdata, MAC_PKT_FR);
+
+	/* Enable MAC Tx */
+	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, TE) != 1) {
+		mac_printf("XGMAC %d: MAC TX: ENABLED\n", pdata->mac_idx);
+		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, TE, 1);
+		XGMAC_RGWR(pdata, MAC_TX_CFG, mac_tcr);
+	}
+
+	/* Enable MAC Rx */
+	if (MAC_GET_VAL(mac_rcr, MAC_RX_CFG, RE) != 1) {
+		mac_printf("XGMAC %d: MAC RX: ENABLED\n", pdata->mac_idx);
+		MAC_SET_VAL(mac_rcr, MAC_RX_CFG, RE, 1);
+		XGMAC_RGWR(pdata, MAC_RX_CFG, mac_rcr);
+	}
+
+	/* Enable MAC Filter Rx All */
+	if (MAC_GET_VAL(mac_pfr, MAC_PKT_FR, RA) != 1) {
+		mac_printf("XGMAC %d: MAC Filter Receive All: ENABLED\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_pfr, MAC_PKT_FR, RA, 1);
+		XGMAC_RGWR(pdata, MAC_PKT_FR, mac_pfr);
+	}
+
+	return 0;
+}
+
+int xgmac_powerdown(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_tcr = XGMAC_RGRD(pdata, MAC_TX_CFG);
+	u32 mac_rcr = XGMAC_RGRD(pdata, MAC_RX_CFG);
+	u32 mac_pfr = XGMAC_RGRD(pdata, MAC_PKT_FR);
+
+	/* Disable MAC Tx */
+	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, TE) != 0) {
+		mac_printf("XGMAC %d: MAC TX: DISABLED\n", pdata->mac_idx);
+		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, TE, 0);
+		XGMAC_RGWR(pdata, MAC_TX_CFG, mac_tcr);
+	}
+
+	/* Disable MAC Rx */
+	if (MAC_GET_VAL(mac_rcr, MAC_RX_CFG, RE) != 0) {
+		mac_printf("XGMAC %d: MAC RX: DISABLED\n", pdata->mac_idx);
+		MAC_SET_VAL(mac_rcr, MAC_RX_CFG, RE, 0);
+		XGMAC_RGWR(pdata, MAC_RX_CFG, mac_rcr);
+	}
+
+	/* Disable MAC Filter Rx All */
+	if (MAC_GET_VAL(mac_pfr, MAC_PKT_FR, RA) != 0) {
+		mac_printf("XGMAC %d: MAC Filter Receive All: DISABLED\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(mac_pfr, MAC_PKT_FR, RA, 0);
+		XGMAC_RGWR(pdata, MAC_PKT_FR, mac_pfr);
+	}
+
+	return 0;
+}
+
+/* EEE CONFIGURATIONS */
+
+/* brief This sequence is used to enable EEE mode
+ * LPITXA: LPI Transmit Automate
+ * If the LPITXA and LPITXEN bits are set to 1, the MAC enters the LPI mode
+ * only after all outstanding packets (in the core) and pending packets (in the
+ * application interface) have been transmitted. The MAC comes out of the LPI
+ * mode when the application presents any packet for transmission or the
+ * application issues a Tx FIFO Flush command. In addition, the MAC
+ * automatically clears the LPITXEN bit when it exits the LPI state. If Tx FIFO
+ * Flush is set in the FTQ bit of MTL_TxQ0_Operation_Mode register, when
+ * the MAC is in the LPI mode, it exits the LPI mode.
+ * When this bit is 0, the LPITXEN bit directly controls behavior of the MAC
+ * when it is entering or coming out of the LPI mode.
+ * LPITXEN: LPI Transmit Enable
+ * When this bit is set, it instructs the MAC Transmitter to enter the LPI state
+ * When this bit is reset, it instructs the MAC to exit the LPI state and resume
+ * normal transmission.
+ * This bit is cleared when the LPITXA bit is set and the MAC exits the LPI
+ * state because of the arrival of a new packet for transmission
+ *
+ */
+int xgmac_set_eee_mode(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_lpiscr = XGMAC_RGRD(pdata, MAC_LPI_CSR);
+
+	if (MAC_GET_VAL(mac_lpiscr, MAC_LPI_CSR, LPITXEN) != val) {
+		mac_printf("XGMAC %d: LPI Transmit Enable: %s\n",
+			   pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(mac_lpiscr, MAC_LPI_CSR, LPITXA, val);
+		MAC_SET_VAL(mac_lpiscr, MAC_LPI_CSR, LPITXEN, val);
+	}
+
+	XGMAC_RGWR(pdata, MAC_LPI_CSR, mac_lpiscr);
+
+	return 0;
+}
+
+u32 xgmac_get_eee_mode(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 lpitxen;
+
+	lpitxen = XGMAC_RGRD_BITS(pdata, MAC_LPI_CSR, LPITXEN);
+
+	mac_printf("\tLPI Transmit Enable: %s\n",
+		   lpitxen ? "ENABLED" : "DISABLED");
+
+	return lpitxen;
+}
+
+/* brief This sequence is used to set PLS bit
+ * PLS: Phy link Status
+ * This bit indicates the link status of the PHY. The MAC Transmitter asserts
+ * the LPI pattern only when the link status is up (OKAY) at least for the time
+ * indicated by the LPI LS TIMER.
+ * When this bit is set, the link is considered to be okay (UP) and when this
+ * bit is reset, the link is considered to be down.
+ */
+
+int xgmac_set_eee_pls(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val = XGMAC_RGRD(pdata, MAC_LPI_CSR);
+
+	/* Disable MAC Tx */
+	if (MAC_GET_VAL(reg_val, MAC_LPI_CSR, PLS) != val) {
+		mac_printf("XGMAC %d: Phy link Status: %s\n",
+			   pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(reg_val, MAC_LPI_CSR, PLS, val);
+		XGMAC_RGWR(pdata, MAC_LPI_CSR, reg_val);
+	}
+
+	return 0;
+}
+
+/* brief This sequence is used to set EEE timer values
+ * LPI LS TIMER:
+ * This field specifies the minimum time (in milliseconds) for which the
+ * link status from the PHY should be up (OKAY) before the LPI pattern
+ * can be transmitted to the PHY. The MAC does not transmit the LPI pattern
+ * even when the LPITXEN bit is set unless the LPI LS Timer reaches the
+ * programmed terminal count. The default value of the LPI LS Timer is
+ * 1000 (1 sec) as defined in the IEEE standard.
+ * LPI TW TIMER
+ * This field specifies the minimum time (in microseconds) for which
+ * the MAC waits after it stops transmitting the LPI pattern to the
+ * PHY and before it resumes the normal transmission. The TLPIEX status
+ * bit is set after the expiry of this timer.
+ */
+
+int xgmac_set_eee_timer(void *pdev, u32 twt, u32 lst)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val;
+
+	reg_val = XGMAC_RGRD(pdata, MAC_LPI_TCR);
+
+	/* Waits till  the TWT(usec), before starting normal transmission */
+	MAC_SET_VAL(reg_val, MAC_LPI_TCR, TWT, twt);
+	/* Waits till  the LST(msec), before starting to send LPI pattern */
+	MAC_SET_VAL(reg_val, MAC_LPI_TCR, LST, lst);
+
+	XGMAC_RGWR(pdata, MAC_LPI_TCR, reg_val);
+
+	return 0;
+}
+
+/* CRC STRIPPING */
+
+/* CST: CRC stripping for Type packets
+ * When this bit is set, the last four bytes (FCS) of all packets of Ether type
+ * (field greater than 1,536) are stripped and dropped before forwarding the
+ * packet to the application.
+ */
+int xgmac_set_crc_strip_type(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val;
+
+	reg_val = XGMAC_RGRD(pdata, MAC_RX_CFG);
+
+	if (MAC_GET_VAL(reg_val, MAC_RX_CFG, CST) != val) {
+		mac_printf("XGMAC %d: CRC stripping for Type packets: %s\n",
+			   pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(reg_val, MAC_RX_CFG, CST, val);
+		XGMAC_RGWR(pdata, MAC_RX_CFG, reg_val);
+	}
+
+	return 0;
+}
+
+/* ACS: Automatic Pad or CRC Stripping
+ * When this bit is set, the MAC strips the Pad or FCS field on the incoming
+ * packets only if the value of the length field is less than 1,536 bytes. All
+ * received packets with length field greater than or equal to 1,536 bytes are
+ * passed to the application without stripping the Pad or FCS field.
+ * When this bit is reset, the MAC passes all incoming packets to the
+ * application, without any modification.
+ */
+int xgmac_set_acs(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val;
+
+	reg_val = XGMAC_RGRD(pdata, MAC_RX_CFG);
+
+	if (MAC_GET_VAL(reg_val, MAC_RX_CFG, ACS) != val) {
+		mac_printf("XGMAC %d: Automatic Pad or CRC Stripping: %s\n",
+			   pdata->mac_idx,  val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(reg_val, MAC_RX_CFG, ACS, val);
+		XGMAC_RGWR(pdata, MAC_RX_CFG, reg_val);
+	}
+
+	return 0;
+}
+
+/* In GMII mode (1G or 2.5G) and when IFP is cleared, the
+ * minimum IPG between transmitted frames is reduced.
+ * In all modes (10G/2.5G/1G), when IFP is set, the minimum IPG is
+ * increased in steps of 32 bits as follows. In 10G (XGMII) mode, when IFP
+ * is set, it overrides the functions of DDIC and ISM bits.
+ */
+int xgmac_set_ipg(void *pdev, u32 ipg)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val;
+
+	reg_val = XGMAC_RGRD(pdata, MAC_TX_CFG);
+
+	if (MAC_GET_VAL(reg_val, MAC_TX_CFG, IPG) != ipg) {
+		mac_printf("XGMAC %d: IPG set to %d bytes\n",
+			   pdata->mac_idx, ((96 + (ipg * 32)) / 8));
+		MAC_SET_VAL(reg_val, MAC_TX_CFG, IPG, ipg);
+		XGMAC_RGWR(pdata, MAC_TX_CFG, reg_val);
+	}
+
+	return 0;
+}
+
+/* PWRDWN: Power Down
+ * if 1, the MAC receiver drops all received packets until
+ * it receives the expected magic packet or remote wake-up packet.
+ * This bit is then self-cleared and the power-down mode is disabled.
+ * The software can clear this bit before the expected magic packet or
+ * remote wake-up packet is received. The packets received by the
+ * MAC after this bit is cleared are forwarded to the application. This bit
+ * must only be set when the Magic Packet Enable, Global Unicast, or
+ * Remote Wake-Up Packet Enable bit is set high.
+ * MGKPKTEN: Magic Packet Enable
+ * if 1, a power management event is generated when
+ * the MAC receives a magic packet.
+ */
+int xgmac_set_magic_pmt(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 mac_pmtcsr;
+
+	mac_pmtcsr = XGMAC_RGRD(pdata, MAC_PMT_CSR);
+
+	if (MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, MGKPKTEN) != val) {
+		mac_printf("XGMAC %d: Magic Packet: %s\n",
+			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(mac_pmtcsr, MAC_PMT_CSR, MGKPKTEN, val);
+	}
+
+	if (MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, PWRDWN) != val) {
+		mac_printf("XGMAC %d: Power Down Mode: %s\n",
+			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(mac_pmtcsr, MAC_PMT_CSR, PWRDWN, val);
+	}
+
+	XGMAC_RGWR(pdata, MAC_PMT_CSR, mac_pmtcsr);
+	return 0;
+}
+
+/* Reading MGKPRCVD or RWKPRCVD will clear the XGMAC PMT Interrupt Status */
+int xgmac_pmt_int_clr(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_pmtcsr;
+	int ret = -1;
+
+	mac_pmtcsr = XGMAC_RGRD(pdata, MAC_PMT_CSR);
+
+	if (MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, MGKPRCVD)) {
+		mac_printf("XGMAC %d: Clearing Magic packet "
+			   "Interrupt\n", pdata->mac_idx);
+		ret = 0;
+	}
+
+	if (MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, RWKPRCVD)) {
+		mac_printf("XGMAC %d: Clearing Remote wakeup packet "
+			   "Interrupt\n", pdata->mac_idx);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+/* Reading TLPIEN or RLPIEN will clear the XGMAC LPI Interrupt Status */
+int xgmac_lpi_int_clr(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 varmac_lps;
+	int ret = -1;
+
+	varmac_lps = XGMAC_RGRD(pdata, MAC_LPI_CSR);
+
+	if (MAC_GET_VAL(varmac_lps, MAC_LPI_CSR, TLPIEN)) {
+		//mac_printf("XGMAC %d: Clearing LPI TX Interrupt Status\n",
+		//	   pdata->mac_idx);
+		ret = 0;
+	}
+
+	if (MAC_GET_VAL(varmac_lps, MAC_LPI_CSR, RLPIEN)) {
+		//mac_printf("XGMAC %d: Clearing LPI RX Interrupt Status\n",
+		//	   pdata->mac_idx);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+
+/* RWKPKTEN: Remote Wake-Up Packet Enable
+ * if 1, a power management event is generated when
+ * the MAC receives a remote wake-up packet.
+ */
+
+int xgmac_set_rwk_pmt(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 mac_pmtcsr;
+
+	mac_pmtcsr = XGMAC_RGRD(pdata, MAC_PMT_CSR);
+
+	if (MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, RWKPKTEN) != val) {
+		mac_printf("XGMAC %d: Remote Wakeup Packet: %s\n",
+			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(mac_pmtcsr, MAC_PMT_CSR, RWKPKTEN, val);
+	}
+
+	if (MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, PWRDWN) != val) {
+		mac_printf("XGMAC %d: Power Down Mode: %s\n",
+			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(mac_pmtcsr, MAC_PMT_CSR, PWRDWN, val);
+	}
+
+	XGMAC_RGWR(pdata, MAC_PMT_CSR, mac_pmtcsr);
+	return 0;
+}
+
+/* RWKFILTRST:
+ * Remote Wake-Up Packet Filter Register Pointer Reset
+ * When this bit is set, the remote wake-up packet filter register pointer
+ * (RWKPTR) is reset to 0. It is automatically cleared after 1 clock cycle.
+ */
+int xgmac_set_rwk_filter_registers(void *pdev, u32 count, u32 *val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 i;
+
+	for (i = 0; i < count; i++)
+		XGMAC_RGWR(pdata, MAC_RWK_PFR, val[i]);
+
+	return 0;
+}
+
+int xgmac_set_pmt_gucast(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_pmtcsr;
+
+	mac_pmtcsr = XGMAC_RGRD(pdata, MAC_PMT_CSR);
+
+	if (MAC_GET_VAL(mac_pmtcsr, MAC_PMT_CSR, GLBLUCAST) != val) {
+		mac_printf("XGMAC %d: PMT Global Unicast: %s\n",
+			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(mac_pmtcsr, MAC_PMT_CSR, GLBLUCAST, val);
+	}
+
+	XGMAC_RGWR(pdata, MAC_PMT_CSR, mac_pmtcsr);
+
+	return 0;
+}
+
+int xgmac_set_extcfg(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_extcfg;
+
+	mac_extcfg = XGMAC_RGRD(pdata, MAC_EXTCFG);
+
+	if (MAC_GET_VAL(mac_extcfg, MAC_EXTCFG, SBDIOEN) != val) {
+		mac_printf("XGMAC %d: MAC Extended CFG SBDIOEN: %s\n",
+			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+
+		MAC_SET_VAL(mac_extcfg, MAC_EXTCFG, SBDIOEN, val);
+
+		XGMAC_RGWR(pdata, MAC_EXTCFG, mac_extcfg);
+	}
+
+	return 0;
+}
+
+void xgmac_set_mac_rxtx(void *pdev, u32 wd, u32 jd)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val;
+
+	reg_val = XGMAC_RGRD(pdata, MAC_RX_CFG);
+
+	if (MAC_GET_VAL(reg_val, MAC_RX_CFG, WD) != wd) {
+		mac_printf("XGMAC %d: WD: %s\n",
+			   pdata->mac_idx, wd ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(reg_val, MAC_RX_CFG, WD, wd);
+		XGMAC_RGWR(pdata, MAC_RX_CFG, reg_val);
+	}
+
+	reg_val = XGMAC_RGRD(pdata, MAC_TX_CFG);
+
+	if (MAC_GET_VAL(reg_val, MAC_TX_CFG, JD) != jd) {
+		mac_printf("XGMAC %d: JD: %s\n",
+			   pdata->mac_idx, jd ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(reg_val, MAC_TX_CFG, JD, jd);
+		XGMAC_RGWR(pdata, MAC_TX_CFG, reg_val);
+	}
+}
+
+/* LPIATE: LPI Auto Timer Enable
+ * This bit controls the automatic entry of the MAC Transmitter into
+ * and exit out of the LPI state. When LPIATE, LPITXA and LPITXEN bits
+ * are set, the MAC Transmitter will enter LPI state only when the
+ * complete MAC TX data path is IDLE for a period indicated by the
+ * MAC_LPI_Auto_Entry_Timer register. After entering LPI state,
+ * if the data path becomes non-IDLE (due to a new packet being accepted
+ * for transmission), the Transmitter will exit LPI state
+ * but will not clear LPITXEN bit. This enables the re-entry into LPI state
+ * when it is IDLE again.
+ * When LPIATE is 0, the LPI Auto timer is disabled and MAC Transmitter will
+ * enter LPI state based on the settings of LPITXA and LPITXEN bit
+ * descriptions.
+ * LPITXA: LPI Tx Automate
+ * This bit controls the behavior of the MAC when it is entering or coming out
+ * of the LPI mode on the Transmit side. This bit is not functional in the
+ * XGMAC-CORE configurations in which the Tx clock gating is done during
+ * the LPI mode.
+ * If the LPITXA and LPITXEN bits are set to 1, the MAC enters the LPI mode
+ * only after all outstanding packets (in the core) and pending packets (in the
+ * application interface) have been transmitted. The MAC comes out of the LPI
+ * mode when the application presents any packet for transmission or the
+ * application issues a Tx FIFO Flush command. In addition, the MAC
+ * automatically clears the LPITXEN bit when it exits the LPI state. If Tx FIFO
+ * Flush is set in the FTQ bit of MTL_TxQ0_Operation_Mode register, when
+ * the MAC is in the LPI mode, it exits the LPI mode.
+ * When this bit is 0, the LPITXEN bit directly controls behavior of the MAC
+ * when it is entering or coming out of the LPI mode.
+ */
+int xgmac_set_mac_lpitx(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 lpiate;
+
+	lpiate = XGMAC_RGRD(pdata, MAC_LPI_CSR);
+
+	if (MAC_GET_VAL(lpiate, MAC_LPI_CSR, LPIATE) != val) {
+		mac_printf("XGMAC %d: LPIATE: %s\n",
+			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(lpiate, MAC_LPI_CSR, LPIATE, val);
+	}
+
+	if (MAC_GET_VAL(lpiate, MAC_LPI_CSR, LPITXA) != val) {
+		mac_printf("XGMAC %d: LPITXA: %s\n",
+			   pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(lpiate, MAC_LPI_CSR, LPITXA, val);
+	}
+
+	XGMAC_RGWR(pdata, MAC_LPI_CSR, lpiate);
+
+	return 0;
+}
+
+/* This sequence is used to adjust the ptp operating frequency.
+ * TSADDREG:
+ * The Timestamp Addend register is present only when the IEEE 1588 Timestamp
+ * feature is selected without external timestamp input. This register value
+ * is used only when the system time is configured for Fine
+ * Update mode (TSCFUPDT bit in the MAC_Timestamp_Control register).
+ * The content of this register is added to a 32-bit accumulator in every
+ * clock cycle and the system time is updated whenever the accumulator
+ * overflows.
+ * This field indicates the 32-bit time value to be added to the
+ * Accumulator register to achieve time synchronization.
+ */
+int xgmac_set_tstamp_addend(void *pdev, u32 tstamp_addend)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	/* Set the addend register value and tell the device */
+	XGMAC_RGWR(pdata, MAC_TSTAMP_ADDNDR, tstamp_addend);
+	XGMAC_RGWR_BITS(pdata, MAC_TSTAMP_CR, TSADDREG, 1);
+
+	/* Wait for addend update to complete */
+	while (1) {
+		if (XGMAC_RGRD_BITS(pdata, MAC_TSTAMP_CR, TSADDREG) == 0)
+			break;
+	}
+
+	return 0;
+}
+
+/* This sequence is used to initialize the system time
+ * TSINIT:
+ * if 1, the system time is initialized (overwritten) with the
+ * value specified in the MAC Register 80
+ * This bit should be zero before it is updated.
+ * This bit is reset when the initialization is complete.
+ */
+
+int xgmac_init_systime(void *pdev, u32 sec, u32 nsec)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	/* Set the time values and tell the device */
+	XGMAC_RGWR(pdata, MAC_SYS_TIME_SEC_UPD, sec);
+	XGMAC_RGWR(pdata, MAC_SYS_TIME_NSEC_UPD, nsec);
+	XGMAC_RGWR_BITS(pdata, MAC_TSTAMP_CR, TSINIT, 1);
+
+	/* Wait for time update to complete */
+	while (1) {
+		if (XGMAC_RGRD_BITS(pdata, MAC_TSTAMP_CR, TSINIT) == 0)
+			break;
+	}
+
+	return 0;
+}
+
+/* This sequence is used to adjust/update the system time
+ * ADDSUB:Add or Subtract Time
+ * When this bit is set, the time value is subtracted with the contents of the
+ * update register. When this bit is reset, the time value is added with the
+ * contents of the update register.
+ * TSUPDT:Update Timestamp
+ * When this bit is set, the system time is updated (added or subtracted)
+ * with the value specified in MAC_System_Time_Seconds_Update and
+ * MAC_System_Time_Nanoseconds_Update.
+ * This bit should be zero before updating it. This bit is reset when the
+ * update is complete in hardware. The Timestamp Higher Word register
+ * (if enabled during core configuration) is not updated.
+ * TSCTRLSSR :Timestamp Digital or Binary Rollover Control
+ * When this bit is set, the Timestamp Low register rolls over after
+ * 0x3B9A_C9FF value (that is, 1 nanosecond accuracy) and increments
+ * the timestamp (High) seconds. When this bit is reset, the rollover value
+ * of sub-second register is 0x7FFF_FFFF. The sub-second increment
+ * must be programmed correctly depending on the PTP reference clock
+ * frequency and the value of this bit.
+ */
+int xgmac_adjust_systime(void *pdev, u32 sec, u32 nsec, u32 add_sub,
+			 u32 one_nsec_accuracy)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	if (add_sub) {
+		/* If the new sec value needs to be subtracted with
+		 * the system time, then MAC_SYS_TIME_SEC_UPD reg should be
+		 * programmed with (2^32 - <new_sec_value>)
+		 */
+		sec = (0x100000000ull - sec);
+
+		/* If the new nsec value need to be subtracted with
+		 * the system time, then MAC_STNSUR.TSSS field should be
+		 * programmed with,
+		 * (10^9 - <new_nsec_value>) if MAC_TX_CFG.TSCTRLSSR is set or
+		 * (2^31 - <new_nsec_value> if MAC_TX_CFG.TSCTRLSSR is reset)
+		 */
+		if (one_nsec_accuracy)
+			nsec = (0x3B9ACA00 - nsec);
+		else
+			nsec = (0x80000000 - nsec);
+	}
+
+	/* Set the time values and tell the device */
+	XGMAC_RGWR(pdata, MAC_SYS_TIME_SEC_UPD, sec);
+	XGMAC_RGWR(pdata, MAC_SYS_TIME_NSEC_UPD, nsec);
+	XGMAC_RGWR_BITS(pdata, MAC_SYS_TIME_NSEC_UPD, ADDSUB, add_sub);
+	XGMAC_RGWR_BITS(pdata, MAC_TSTAMP_CR, TSUPDT, 1);
+
+	/* Wait for time update to complete */
+	while (1) {
+		if (XGMAC_RGRD_BITS(pdata, MAC_TSTAMP_CR, TSUPDT) == 0)
+			break;
+	}
+
+	return 0;
+}
+
+/* This sequence is used get 64-bit system time in nano sec */
+u64 xgmac_get_systime(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u64 nsec;
+
+	nsec = XGMAC_RGRD(pdata, MAC_SYS_TIME_SEC);
+	nsec *= NSEC_TO_SEC;
+	nsec += XGMAC_RGRD(pdata, MAC_SYS_TIME_NSEC);
+
+	return nsec;
+}
+
+/* This sequence is used to check whether a timestamp has been
+ * captured for the corresponding transmit packet. Returns val if
+ * timestamp is taken else returns 0
+ */
+u64 xgmac_get_tx_tstamp(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 tx_snr;
+	u64 nsec;
+
+	tx_snr = XGMAC_RGRD(pdata, MAC_TXTSTAMP_NSECR);
+
+	/* check whether tstamp of the prev pkt is overwritten with the
+	 * tstamp of the cur pkt
+	 */
+	if (MAC_GET_VAL(tx_snr, MAC_TXTSTAMP_NSECR, TXTSSTSMIS)) {
+		/* timesatmp of the current pkt is ignored */
+		return 0;
+	}
+
+	nsec = XGMAC_RGRD(pdata, MAC_TXTSTAMP_SECR);
+	nsec *= NSEC_TO_SEC;
+	nsec += tx_snr;
+
+	return nsec;
+}
+
+/* This sequence is used to get the number of tx timestamp snapshots captured.
+ */
+int xgmac_get_txtstamp_cnt(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 tx_sts;
+	u32 ttsns;
+
+	tx_sts = XGMAC_RGRD(pdata, MAC_TSTAMP_STSR);
+
+	ttsns = MAC_GET_VAL(tx_sts, MAC_TSTAMP_STSR, TTSNS);
+	mac_printf("\tTx Timestamp Fifo: %d\n", ttsns);
+
+	/* Max Fifo Value*/
+	if (ttsns == 16)
+		mac_printf("XGMAC %d: Tx Timestamp Fifo is Full\n",
+			   pdata->mac_idx);
+
+	return ttsns;
+}
+
+/* This sequence is used to get PktID of Transmitted Packet.
+ */
+int xgmac_get_txtstamp_pktid(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 tx_sts;
+	int pktid;
+
+	tx_sts = XGMAC_RGRD(pdata, MAC_TXTSTAMP_STS);
+
+	pktid = MAC_GET_VAL(tx_sts, MAC_TXTSTAMP_STS, PKTID);
+	mac_printf("\tTx Timestamp PacketID: %d\n", pktid);
+
+	return pktid;
+}
+
+
+/* TSCTRLSSR:Timestamp Digital or Binary Rollover Control
+ * if 1, the Timestamp Low register rolls over after 0x3B9A_C9FF value
+ * (that is, 1 nanosecond accuracy) and increments
+ * the timestamp (High) seconds.
+ * if 0, the rollover value of sub-second register is 0x7FFF_FFFF.
+ * The sub-second increment must be programmed correctly
+ * depending on the PTP reference clock frequency and the value of this bit.
+ * TSCFUPDT:Fine or Coarse Timestamp Update
+ * if 1, the Fine method is used to update system timestamp.
+ * if 0, Coarse method is used to update the system timestamp
+ * TXTSSTSM:Transmit Timestamp Status Mode
+ * if 1, the MAC overwrites the earlier transmit timestamp status even
+ * if it is not read by the software.
+ * The MAC indicates this by setting the TXTSSTSMIS bit of the
+ * MAC_TxTimestamp_Status_Nanoseconds register.
+ * if 0, the MAC ignores the timestamp status of current packet if the
+ * timestamp status of previous packet is not read by the software.
+ * The MAC indicates this by setting the TXTSSTSMIS bit of the
+ * MAC_TxTimestamp_Status_Nanoseconds register
+ * SSINC:
+ * The value programmed in this field is accumulated with the
+ * contents of the sub-second register.
+ * For example, when the PTP clock is 50 MHz (period is 20 ns),
+ * you should program 20 (0x14)
+ * when the System TimeNanoseconds register has an accuracy of 1 ns
+ * [Bit 9 (TSCTRLSSR) is set in MAC_Timestamp_Control].
+ * When TSCTRLSSR is clear, the Nanoseconds register has a resolution
+ * of ~0.465 ns. In this case, you
+ * should program a value of 43 (0x2B) which is derived by 20 ns/0.465.
+ * SNSINC:
+ * This field contains the sub-nanosecond increment value, represented
+ * in nanoseconds multiplied by 28.
+ * This value is accumulated with the sub-nanoseconds field of the
+ * sub-second register.
+ * For example, when TSCTRLSSR field in the
+ * MAC_Timestamp_Control register is set.
+ * and if the required increment is 5.3ns, then SSINC should be 0x05
+ * and SNSINC should be 0x4C.
+ */
+int xgmac_config_tstamp(void *pdev, u32 mac_tscr)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	/* Exit if timestamping is not enabled */
+	if (!MAC_GET_VAL(mac_tscr, MAC_TSTAMP_CR, TSENA))
+		return 0;
+
+	/* Set one nano-second accuracy */
+	if (pdata->one_nsec_accuracy)
+		MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSCTRLSSR, 1);
+	else
+		MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSCTRLSSR, 0);
+
+	/* Set fine timestamp update */
+	MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSCFUPDT, 1);
+
+	/* Overwrite earlier timestamps */
+	MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TXTSSTSM, 1);
+
+	XGMAC_RGWR(pdata, MAC_TSTAMP_CR, mac_tscr);
+
+#ifdef __KERNEL__
+#else
+	/* Initialize time registers */
+	xgmac_config_subsec_inc(pdev, pdata->ptp_clk);
+
+	xgmac_set_tstamp_addend(pdev, pdata->def_addend);
+	xgmac_init_systime(pdev, pdata->sec, pdata->nsec);
+#endif
+
+	return 0;
+}
+
+int xgmac_config_subsec_inc(void *pdev, u32 ptp_clk)
+{
+#if defined(PC_UTILITY) && PC_UTILITY
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u64 val;
+
+	if (XGMAC_RGRD_BITS(pdata, MAC_TSTAMP_CR, TSCFUPDT) == 1)
+		val = ((1 * NSEC_TO_SEC) / MHZ_TO_HZ(50));
+	else
+		val = ((1 * NSEC_TO_SEC) / ptp_clk);
+
+	/* 0.465ns accurecy */
+	if (XGMAC_RGRD_BITS(pdata, MAC_TSTAMP_CR, TSCTRLSSR) == 0)
+		val = (val * 1000) / 465;
+
+	XGMAC_RGWR_BITS(pdata, MAC_SUBSEC_INCR, SSINC, val);
+#else
+	// TODO: for linux u64 division need to change
+#endif
+	return 0;
+}
+
+int xgmac_disable_tstamp(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_tscr = 0;
+
+	memset(&pdata->ptp_flgs, 0, sizeof(pdata->ptp_flgs));
+
+	/* Basically set all bits in MAC_TSTAMP_CR to 0, beloc code is
+	 * actually not needed
+	 */
+	MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSENA, 0);
+	MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSENALL, 0);
+
+	XGMAC_RGWR(pdata, MAC_TSTAMP_CR, mac_tscr);
+
+	return 0;
+}
+
+int xgmac_get_hwtstamp_settings(void *pdev,
+				struct hwtstamp_config *config)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	memcpy(config, &pdata->tstamp_config, sizeof(pdata->tstamp_config));
+	return 0;
+}
+
+/* TSENALL:
+ * Enable Timestamp for All Packets
+ * When this bit is set, the timestamp snapshot is enabled for all packets
+ * received by the MAC.
+ * TSENA:
+ * When this bit is set, the timestamp is added for Transmit and
+ * Receive packets.
+ * On the Receive side, the MAC processes the 1588 packets only
+ * if this bit is set.
+ * TSVER2ENA:
+ * When this bit is set, the IEEE 1588 version 2 format is used to
+ * process the PTP packets
+ * TSIPV4ENA:
+ * When this bit is set, the MAC receiver processes the PTP packets
+ * encapsulated in IPv4-UDP packets.
+ * TSIPV6ENA:
+ * When this bit is set, the MAC receiver processes the PTP packets
+ * encapsulated in IPv6-UDP packets.
+ * SNAPTYPSEL:
+ * These bits, along with Bits 15 and 14, decide the set of PTP packet
+ * types for which snapshot needs to be taken.
+ * TSENA:
+ * When this bit is set, the timestamp is added for Transmit and
+ * Receive packets.
+ * On the Receive side, the MAC processes the 1588 packets only
+ * if this bit is set.
+ * TSEVNTENA:
+ * if 1, the timestamp snapshot is taken only for event messages
+ * (SYNC, Delay_Req, Pdelay_Req, or Pdelay_Resp).
+ * if 0, the snapshot is taken for all messages except
+ * Announce, Management, and Signaling.
+ * TSMSTRENA:
+ * if 1, the snapshot is taken only for the messages that are
+ * relevant to the master node.
+ * if 0, the snapshot is taken for the messages relevant
+ * to the slave node.
+ * AV8021ASMEN:
+ * if 1, the MAC processes only untagged PTP over Ethernet packets
+ * for providing PTP status
+ * and capturing timestamp snapshots, that is, IEEE 802.1AS mode of operation.
+ * TSIPENA:
+ * if 1, the MAC receiver processes the PTP packets encapsulated directly
+ * in the Ethernet packets.
+ * if 0, the MAC ignores the PTP over Ethernet packets.
+ */
+
+int xgmac_set_hwtstamp_settings(void *pdev,
+				u32 tx_type,
+				u32 rx_filter)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_tscr = 0;
+
+	memset(&pdata->ptp_flgs, 0, sizeof(pdata->ptp_flgs));
+
+	switch (tx_type) {
+	case HWTSTAMP_TX_OFF:
+		break;
+
+	case HWTSTAMP_TX_ON:
+		pdata->ptp_flgs.ptp_tx_en = 1;
+		MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSENA, 1);
+		break;
+
+	default:
+		return 0;
+	}
+
+	/* This is based on Table 7-146, Receive side timestamp Capture
+	 * scenarios
+	 */
+
+	switch (rx_filter) {
+	case HWTSTAMP_FILTER_NONE:
+		break;
+
+	case HWTSTAMP_FILTER_ALL:
+		mac_printf("HW tstamp config: Filter All\n");
+		pdata->ptp_flgs.ptp_rx_en |= PTP_RX_EN_ALL;
+		break;
+
+	/* PTP v1, UDP, any kind of event packet */
+	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+		pdata->ptp_flgs.ptp_rx_en |= PTP_RX_V2;
+
+	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
+		mac_printf("PTP v1, UDP, any kind of event packet\n");
+		pdata->ptp_flgs.ptp_rx_en |=
+			(PTP_RX_OVER_IPV4_UDP |
+			 PTP_RX_OVER_IPV6_UDP | PTP_RX_SNAP);
+		break;
+
+	/* PTP v1, UDP, Sync packet */
+	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+		pdata->ptp_flgs.ptp_rx_en |= PTP_RX_V2;
+
+	case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
+		mac_printf("PTP v1, UDP, Sync packet\n");
+		pdata->ptp_flgs.ptp_rx_en |=
+			(PTP_RX_OVER_IPV4_UDP |
+			 PTP_RX_OVER_IPV6_UDP | PTP_RX_EVNT);
+		break;
+
+	/* PTP v1, UDP, Delay_req packet */
+	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+		pdata->ptp_flgs.ptp_rx_en |= PTP_RX_V2;
+
+	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
+		mac_printf("PTP v1, UDP, Delay_req packet\n");
+		pdata->ptp_flgs.ptp_rx_en |=
+			(PTP_RX_OVER_IPV4_UDP |
+			 PTP_RX_OVER_IPV6_UDP | PTP_RX_EVNT | PTP_RX_MSTR);
+		break;
+
+	/* 802.AS1, Ethernet, any kind of event packet */
+	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+		mac_printf("802.AS1, Ethernet, any kind of event packet\n");
+		pdata->ptp_flgs.ptp_rx_en |=
+			(PTP_RX_V2 | PTP_RX_OVER_ETH | PTP_RX_SNAP);
+
+		break;
+
+	/* 802.AS1, Ethernet, Sync packet */
+	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+		mac_printf("802.AS1, Ethernet, Sync packet\n");
+		pdata->ptp_flgs.ptp_rx_en |=
+			(PTP_RX_V2 | PTP_RX_OVER_ETH | PTP_RX_EVNT);
+		break;
+
+	/* 802.AS1, Ethernet, Delay_req packet */
+	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+		mac_printf("802.AS1, Ethernet, Delay_req packet\n");
+		pdata->ptp_flgs.ptp_rx_en |=
+			(PTP_RX_V2 | PTP_RX_OVER_ETH |
+			 PTP_RX_EVNT | PTP_RX_MSTR);
+		break;
+
+	/* PTP v2/802.AS1, any layer, any kind of event packet */
+	case HWTSTAMP_FILTER_PTP_V2_EVENT:
+		mac_printf("PTP v2/802.AS1,any layer,any kind of event pkt\n");
+		pdata->ptp_flgs.ptp_rx_en |=
+			(PTP_RX_V2 | PTP_RX_OVER_ANY_LYR | PTP_RX_SNAP);
+		break;
+
+	/* PTP v2/802.AS1, any layer, Sync packet */
+	case HWTSTAMP_FILTER_PTP_V2_SYNC:
+		mac_printf("PTP v2/802.AS1, any layer, Sync packet\n");
+		pdata->ptp_flgs.ptp_rx_en |=
+			(PTP_RX_V2 | PTP_RX_OVER_ANY_LYR | PTP_RX_EVNT);
+		break;
+
+	/* PTP v2/802.AS1, any layer, Delay_req packet */
+	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+		mac_printf("PTP v2/802.AS1, any layer, Delay_req packet\n");
+		pdata->ptp_flgs.ptp_rx_en |=
+			(PTP_RX_V2 | PTP_RX_OVER_ANY_LYR |
+			 PTP_RX_EVNT | PTP_RX_MSTR);
+		break;
+
+	default:
+		return 0;
+	}
+
+	if (pdata->ptp_flgs.ptp_rx_en != 0) {
+		MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSENA, 1);
+
+		if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_V2)
+			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSVER2ENA, 1);
+
+		if (pdata->ptp_flgs.ptp_rx_en &
+		    (PTP_RX_OVER_ANY_LYR | PTP_RX_OVER_IPV4_UDP))
+			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSIPV4ENA, 1);
+
+		if (pdata->ptp_flgs.ptp_rx_en &
+		    (PTP_RX_OVER_ANY_LYR | PTP_RX_OVER_IPV6_UDP))
+			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSIPV6ENA, 1);
+
+		if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_OVER_ETH)
+			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, AV8021ASMEN, 1);
+
+		if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_OVER_ANY_LYR)
+			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSIPENA, 1);
+
+		if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_EVNT)
+			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSEVNTENA, 1);
+
+		if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_SNAP)
+			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, SNAPTYPSEL, 1);
+
+		if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_MSTR)
+			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSMSTRENA, 1);
+
+		if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_EN_ALL)
+			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSENALL, 1);
+	}
+
+	xgmac_config_tstamp(pdev, mac_tscr);
+
+#ifdef __KERNEL__
+	xgmac_config_timer_reg(pdev);
+#endif
+
+	return 0;
+}
+
+void xgmac_ptp_txtstamp_mode(void *pdev,
+			     u32 snaptypesel,
+			     u32 tsmstrena,
+			     u32 tsevntena)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_tscr = 0;
+
+	memset(&pdata->ptp_flgs, 0, sizeof(pdata->ptp_flgs));
+
+	MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSVER2ENA, 1);
+	MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSIPENA, 1);
+	MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSIPV4ENA, 1);
+	MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSIPV6ENA, 1);
+	MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, SNAPTYPSEL, snaptypesel);
+	MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSEVNTENA, tsevntena);
+	MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSMSTRENA, tsmstrena);
+	MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSENA, 1);
+
+	xgmac_config_tstamp(pdev, mac_tscr);
+}
+int xgmac_set_gint(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_tcr = XGMAC_RGRD(pdata, MAC_TX_CFG);
+
+	/* Enable/Disable MAC G9991EN */
+	if (MAC_GET_VAL(mac_tcr, MAC_TX_CFG, G9991EN) != val) {
+		mac_printf("XGMAC %d: G9991EN: %s\n", pdata->mac_idx,
+			   val ? "ENABLED" : "DISABLED");
+		MAC_SET_VAL(mac_tcr, MAC_TX_CFG, G9991EN, val);
+		XGMAC_RGWR(pdata, MAC_TX_CFG, mac_tcr);
+	}
+
+	return 0;
+}
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_main.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_main.c
new file mode 100644
index 000000000000..f7ebb2932ad6
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_main.c
@@ -0,0 +1,1028 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+/* =========================================================================
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ * The Synopsys DWC ETHER XGMAC Software Driver and documentation (hereinafter
+ * "Software") is an unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto.  Permission is hereby granted,
+ * free of charge, to any person obtaining a copy of this software annotated
+ * with this license and the Software, to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================= */
+
+
+#include <xgmac.h>
+#include <gswss_mac_api.h>
+#include <xgmac_mdio.h>
+#include <mac_cfg.h>
+#include <lmac_api.h>
+
+static void xgmac_menu(void);
+static void set_data(u8 *argv[], int i, u32 *start_arg, u32 idx);
+static void set_pdata(u8 *arg, u32 idx, u32 *data, u32 *start_arg);
+static void set_all_pdata(u8 *arg, u32 *data, u32 *start_arg);
+
+struct _xgmac_cfg {
+	char name[256];
+	void (*set_func)(void *);
+	int (*get_func)(void *);
+	u32 args;
+	u32 *data1;
+	u32 *data2;
+	u32 *data3;
+	u32 *data4;
+	char help[1024];
+};
+
+struct mac_prv_data prv_data[10];
+struct mac_prv_data pdata;
+
+struct _xgmac_cfg xgmac_cfg_table[] = {
+	/* Name  WritePtr ReadPtr  Args,Data1,Data2,Data3,Data4	Help	*/
+	{
+		"init            ",
+		cli_init,
+		0,
+		0, &pdata.init_val, 0, 0, 0,
+		"<Initialize the module based on the Index Set>"
+	},
+	{
+		"reset           ",
+		cli_reset,
+		0,
+		0, 0, 0, 0, 0,
+		"<XGMAC Reset 1/0 Reset/No reset>"
+	},
+	{
+		"regtest         ",
+		cli_test_all_reg,
+		0,
+		0, 0, 0, 0, 0,
+		"<Test all registers>"
+	},
+	/* MTL REGISTER SETTINGS */
+	{
+		"mtl_tx          ",
+		cli_set_mtl_tx,
+		xgmac_get_mtl_tx,
+		0, &pdata.tx_sf_mode, &pdata.tx_threshold, 0, 0,
+		"<args 2: 1/0: store_forward/threshold arg 2 0:64, 1:res, 2:96, 3:128, 4:192, 5:256, 6:384, 7:512>"
+	},
+	{
+		"mtl_rx          ",
+		cli_set_mtl_rx,
+		xgmac_get_mtl_rx,
+		0, &pdata.rx_sf_mode, &pdata.rx_threshold, 0, 0,
+		"<args 2: 1/0: store_forward/threshold args 2: 0:64, 1:res, 2:96, 3:128>"
+	},
+	{
+		"flow_ctrl_thresh",
+		cli_flow_ctrl_thresh,
+		xgmac_get_mtl_rx_flow_ctl,
+		0, &pdata.rfa, &pdata.rfd, 0, 0,
+		"<args 2: Thresh to act Flow Ctrl, Thresh to de-act Flow Ctrl>"
+	},
+	{
+		"ts_addend       ",
+		cli_set_tstamp_addend,
+		0,
+		0, &pdata.tstamp_addend, 0, 0, 0,
+		"<args 1: Timestamd addend val>"
+	},
+	{
+		"systime         ",
+		0,
+		xgmac_print_system_time,
+		0, 0, 0, 0, 0,
+		"Print System time"
+	},
+	{
+		"ts_enable       ",
+		cli_set_tstamp_enable,
+		0,
+		0, 0, 0, 0, 0,
+		"Tx Timestamp Enable"
+	},
+	{
+		"ts_disable      ",
+		cli_set_tstamp_disable,
+		0,
+		0, 0, 0, 0, 0,
+		"Disable TX and RX timestamp"
+	},
+	{
+		"ptp_tx_mode     ",
+		cli_set_txtstamp_mode,
+		xgmac_get_txtstamp_mode,
+		0, &pdata.snaptype, &pdata.tsmstrena, &pdata.tsevntena, 0,
+		"<1/0: SnaptypeSel, 1/0: tsmstrena, 1/0: tseventena>"
+	},
+	{
+		"hwtstamp        ",
+		cli_set_hwtstamp_settings,
+		xgmac_get_tstamp_settings,
+		0, &pdata.tstamp_config.tx_type, &pdata.tstamp_config.rx_filter, 0, 0,
+		"<args 2: 1/0 TX timestamp ON/OFF, FILTER_TYPE: 0-14/ None/ALL/Some/V1L4EVENT/V1L4SYNC/V1L4DELAY_REQ/V2L4EVENT/V2L4SYNC/V2L4DELAYREQ/V2L2EVENT/V2L2SYNC/V2L2DELAYREQ/V2EVENT/V2SYNC/V2DELAYREQ>"
+	},
+	{
+		"flush_tx_q      ",
+		cli_flush_tx_queues,
+		0,
+		0, 0, 0, 0, 0,
+		"flush MTL transmit Q>"
+	},
+	{
+		"debug_en        ",
+		cli_set_debug_ctl,
+		xgmac_get_debug_sts,
+		0, &pdata.dbg_en, &pdata.dbg_mode, 0, 0,
+		"<args 2: 1/0 DBG_EN 1/0 DBGMODE/SLAVE MODE>"
+	},
+	{
+		"debug_tx        ",
+		cli_set_tx_debug_data,
+		0,
+		0, &pdata.dbg_pktstate, 0, 0, 0,
+		"<Pktstate 0/1/2/3 PKT_DATA/Ctrl_Word/SOP/EOP"
+	},
+	{
+		"debug_rx        ",
+		cli_set_rx_debug_data,
+		0,
+		0, 0, 0, 0, 0,
+		"<Pktstate 0/1/2/3 PKT_DATA/Normal Sts/Last Sts/EOP>"
+	},
+	{
+		"debug_data      ",
+		cli_set_debug_data,
+		0,
+		0, &pdata.dbg_data, 0, 0, 0,
+		"<args 1: debug_data pointer>"
+	},
+	{
+		"debug_int_en    ",
+		cli_set_rx_debugctrl_int,
+		0,
+		0, &pdata.dbg_pktie, 0, 0, 0,
+		"<args 1: 1/0 PKT INT EN>"
+	},
+	{
+		"debug_reset     ",
+		cli_set_fifo_reset,
+		0,
+		0, &pdata.dbg_rst_sel, &pdata.dbg_rst_all, 0, 0,
+		"<args 2: 1/0 RESET SEL FIFO, 1/0 RESET ALL FIFO>"
+	},
+	{
+		"dbg_rx          ",
+		cli_rx_packet_dbgmode,
+		0,
+		0, 0, 0, 0, 0,
+		"<Rx Packet in DBGMODE>"
+	},
+	{
+		"dbg_rx_slave    ",
+		cli_rx_packet_slavemode,
+		0,
+		0, 0, 0, 0, 0,
+		"<Rx Packet in SLAVEMODE>"
+	},
+	{
+		"error_pkt_fwd   ",
+		cli_set_fup_fep_pkt,
+		xgmac_get_fup_fep_setting,
+		0, &pdata.fup, &pdata.fef, 0, 0,
+		"<args 2: <1/0 enable/disable FUP, 1/0 enable/disable FEF>"
+	},
+	{
+		"int_en          ",
+		cli_set_int,
+		xgmac_dbg_int_sts,
+		0, &pdata.enable_mtl_int, &pdata.enable_mac_int, 0, 0,
+		"<MTL and MAC Interrupt Enable and get status>"
+	},
+	/* MAC REGISTER SETTINGS */
+	{
+		"mac_enable      ",
+		cli_set_mac_enable,
+		xgmac_get_mac_settings,
+		0, &pdata.mac_en, 0, 0, 0,
+		"<args 1: 1/0: MAC enable/disable>"
+	},
+	{
+		"mac_addr        ",
+		cli_set_mac_address,
+		xgmac_get_mac_addr,
+		0, (u32 *) &pdata.mac_addr, 0, 0, 0,
+		"<args 1: mac_addr>"
+	},
+	{
+		"mac_rx_mode     ",
+		cli_set_mac_rx_mode,
+		xgmac_get_mac_rx_mode,
+		0, &pdata.promisc_mode, &pdata.all_mcast_mode, 0, 0,
+		"<args 2: <1/0 enable/disable promisc, 1/0 accept/deny allmcast>"
+	},
+	{
+		"mtu             ",
+		cli_set_mtu,
+		mac_get_mtu,
+		0, &pdata.mtu, 0, 0, 0,
+		"<args 1: MTU value>"
+	},
+	{
+		"pause_time      ",
+		0,
+		0,
+		0, &pdata.pause_time, 0, 0, 0,
+		"<args 1: pause_time>"
+	},
+	{
+		"pause_frame_ctrl",
+		cli_set_pause_frame_ctrl,
+		xgmac_get_pause_frame_ctl,
+		0, &pdata.pause_frm_enable, &pdata.pause_time, 0, 0,
+		"<args 1: 1/0: enable pause frame/disable pause frame>"
+	},
+	{
+		"pause_filter    ",
+		cli_set_pause_frame_filter,
+		0,
+		0, &pdata.pause_filter, 0, 0, 0,
+		"<args 1: 1/0: enable pause frame filter/disable pause frame filter>"
+	},
+	{
+		"pause_tx        ",
+		cli_initiate_pause_tx,
+		0,
+		0, 0, 0, 0, 0,
+		"<Initiate PAUSE packet transmit>"
+	},
+	{
+		"speed           ",
+		cli_set_mac_speed,
+		mac_get_speed,
+		0, &pdata.phy_speed, 0, 0, 0,
+		"<args 1: 0/1/2/3:LMAC 10/100/200/1G  4/5/6/7/8/9:XGMAC 10/100/1G/2G5/5G/10G 10: 2G5-GMII>"
+	},
+	{
+		"duplex          ",
+		cli_set_duplex_mode,
+		0,
+		0, &pdata.duplex_mode, 0, 0, 0,
+		"<args 1: 0/1/2:Full/Half/Auto>"
+	},
+	{
+		"rx_csum_offload ",
+		cli_set_csum_offload,
+		xgmac_get_checksum_offload,
+		0, &pdata.rx_checksum_offload, 0, 0, 0,
+		"<args 1: 1/0: enable/disable rx checksum offload>"
+	},
+	{
+		"loopback        ",
+		cli_set_loopback,
+		xgmac_get_mac_loopback_mode,
+		0, &pdata.loopback, 0, 0, 0,
+		"<args 1: 1/0: loopback enable/disable>"
+	},
+	{
+		"eee             ",
+		cli_set_eee_mode,
+		xgmac_get_eee_settings,
+		0, &pdata.eee_enable, 0, 0, 0,
+		"<args 1: 1/0: enable/disable eee mode>"
+	},
+	{
+		"crc_strip_type  ",
+		cli_set_crc_strip_type,
+		xgmac_get_crc_settings,
+		0, &pdata.crc_strip_type, 0, 0, 0,
+		"<args 1: 1/0: enable/disable crc strip>"
+	},
+	{
+		"crc_strip_acs   ",
+		cli_set_crc_strip_acs,
+		xgmac_get_crc_settings,
+		0, &pdata.padcrc_strip, 0, 0, 0,
+		"<args 1: 1/0: enable/disable crc strip>"
+	},
+	{
+		"ipg             ",
+		cli_set_ipg,
+		xgmac_get_ipg,
+		0, &pdata.ipg, 0, 0, 0,
+		"<args 1 IPG val 0 - 4, default val 0>"
+	},
+	{
+		"magic_pmt       ",
+		cli_set_pmt_magic,
+		xgmac_dbg_pmt,
+		0, &pdata.magic_pkt_en, 0, 0, 0,
+		"<args 1: 1/0 MAGIC packet enable/disable for PMT>"
+	},
+	{
+		"rwk_pmt         ",
+		cli_set_pmt_rwk,
+		xgmac_dbg_pmt,
+		0, &pdata.rwk_pkt_en, 0, 0, 0,
+		"<args 1: 1/0 Remote Wake Up packet enable/disable for PMT>"
+	},
+	{
+		"gucast_pmt      ",
+		cli_set_pmt_gucast,
+		xgmac_dbg_pmt,
+		0, &pdata.gucast, 0, 0, 0,
+		"<args 1: 1/0 PMT Global Unicast ENABLE/DISABLE>"
+	},
+	{
+		"extcfg          ",
+		cli_set_extcfg,
+		xgmac_get_extcfg,
+		0, &pdata.extcfg, 0, 0, 0,
+		"<args 1: 1/0 ExtCfg SBDIOEN>"
+	},
+	{
+		"rxtx            ",
+		cli_set_macrxtxcfg,
+		xgmac_get_mac_rxtx_sts,
+		0, &pdata.jd, &pdata.wd, 0, 0,
+		"<args 2: 1/0 Jabber Disable 1/0 Watchdog Disable>"
+	},
+	{
+		"miss_ovf_pkt_cnt",
+		0,
+		xgmac_get_mtl_missed_pkt_cnt,
+		0, 0, 0, 0, 0,
+		"<Missed Overflow packet count>"
+	},
+	{
+		"uflow_pkt_cnt   ",
+		0,
+		xgmac_get_mtl_underflow_pkt_cnt,
+		0, 0, 0, 0, 0,
+		"<Underflow packet count>"
+	},
+	{
+		"tstamp_sts      ",
+		0,
+		xgmac_get_tstamp_status,
+		0, 0, 0, 0, 0,
+		"<Get timestamp status>"
+	},
+	{
+		"txtstamp_cnt      ",
+		0,
+		xgmac_get_txtstamp_cnt,
+		0, 0, 0, 0, 0,
+		"<Get txtstamp count>"
+	},
+	{
+		"txtstamp_pktid      ",
+		0,
+		xgmac_get_txtstamp_pktid,
+		0, 0, 0, 0, 0,
+		"<Get txtstamp pktid>"
+	},
+	{
+		"linksts         ",
+		cli_set_linksts,
+		0,
+		0, &pdata.linksts, 0, 0, 0,
+		"<0/1/2 UP/DOWN/AUTO>"
+	},
+	{
+		"lpitx           ",
+		cli_set_lpitx,
+		0,
+		0, &pdata.lpitxa, 0, 0, 0,
+		"<args 1: 1/0: enable/disable>"
+	},
+	{
+		"mdio_cl         ",
+		cli_set_mdio_cl,
+		0,
+		0, &pdata.mdio_cl, &pdata.phy_id, 0, 0,
+		"<args 2: 1/0: CL22/CL45, phy_id>"
+	},
+	{
+		"mdio_rd         ",
+		cli_mdio_rd,
+		0,
+		0, &pdata.dev_adr, &pdata.phy_id, &pdata.phy_reg, 0,
+		"<args 3: dev_adr, phy_id, phy_reg>"
+	},
+	{
+		"mdio_rd_cont    ",
+		cli_mdio_rd_cont,
+		0,
+		0, &pdata.dev_adr, &pdata.phy_id, &pdata.phy_reg_st, &pdata.phy_reg_end,
+		"<args 4: dev_adr, phy_id, phy_reg_st, phy_reg_end>"
+	},
+	{
+		"mdio_wr         ",
+		cli_mdio_wr,
+		0,
+		0, &pdata.dev_adr, &pdata.phy_id, &pdata.phy_reg, &pdata.phy_data,
+		"<args 4: dev_adr, phy_id, phy_reg, phy_data>"
+	},
+	{
+		"mdio_int        ",
+		cli_set_mdio_int,
+		xgmac_mdio_get_int_sts,
+		0, &pdata.mdio_int, 0, 0, 0,
+		"<args 1: <mdio_int>"
+	},
+	{
+		"fcs_gen         ",
+		cli_set_fcsgen,
+		0,
+		0, &pdata.fcsgen, 0, 0, 0,
+		"<args 1: 1/0 fcs gen ENABLE/DISABLE>"
+	},
+	{
+		"gint             ",
+		cli_set_gint,
+		0,
+		0, &pdata.val, 0, 0, 0,
+		"<args 1: 1/0 G.INT ENABLE/DISABLE>"
+	},
+	{
+		"rx_crc             ",
+		cli_set_rxcrc,
+		0,
+		0, &pdata.val, 0, 0, 0,
+		"<args 1: 1/0 Rx Crc check DISABLE/ENABLE>"
+	},
+	/* OTHERS */
+	{
+		"rmon            ",
+		0,
+		cli_get_rmon,
+		0, 0, 0, 0, 0,
+		"<args 1: 1: reset 0: no reset>"
+	},
+	{
+		"clear_rmon      ",
+		cli_clear_rmon_all,
+		0,
+		0, 0, 0, 0, 0,
+		"<clear rmon>"
+	},
+	{
+		"rmon_cfg        ",
+		0,
+		xgmac_get_counters_cfg,
+		0, 0, 0, 0, 0,
+		"<RMON config>"
+	},
+	{
+		"priv_data       ",
+		0,
+		xgmac_get_priv_data,
+		0, 0, 0, 0, 0,
+		"<read private data>"
+	},
+	{
+		"hw_feat         ",
+		0,
+		xgmac_get_all_hw_features,
+		0, 0, 0, 0, 0,
+		"<get all hw features>"
+	},
+	{
+		"all             ",
+		0,
+		xgmac_get_all_hw_settings,
+		0, 0, 0, 0, 0,
+		"<Get all HW settings>"
+	},
+};
+
+u32 wakeup_filter_config[] = {
+	/* for filter 0 CRC is computed on 0 - 7 bytes from offset */
+	0x000000ff,
+	/* for filter 1 CRC is computed on 0 - 7 bytes from offset */
+	0x000000ff,
+	/* for filter 2 CRC is computed on 0 - 7 bytes from offset */
+	0x000000ff,
+	/* for filter 3 CRC is computed on 0 - 7 bytes from offset */
+	0x000000ff,
+	/* filter 0, 1 independently enabled and would apply for
+	 * unicast packet only filter 3, 2 combined as,
+	 * "Filter-3 pattern AND NOT Filter-2 pattern"
+	 */
+	0x01010101,
+	/* filter 3, 2, 1 and 0 offset is 14, 22, 30, 38 bytes
+	 * from start
+	 */
+	0x0e161e26,
+	/* pattern for filter 1 and 0, "0x55", "11", repeated 8 times */
+	0x0B400B40,
+	/* pattern for filter 3 and 2, "0x44", "33", repeated 8 times */
+	0x0B400B40,
+};
+
+int populate_filter_frames(void *pdev)
+{
+	int i;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	for (i = 0; i < 8; i++)
+		pdata->rwk_filter_values[i] = wakeup_filter_config[i];
+
+	pdata->rwk_filter_length = 8;
+
+	return 0;
+}
+
+void removeSpace(char *str)
+{
+	char *p1 = str, *p2 = str;
+
+	do
+		while (*p2 == ' ')
+			p2++;
+
+	while ((*p1++ = *p2++));
+}
+
+void xgmac_menu(void)
+{
+	int i = 0;
+
+	int num_of_elem = (sizeof(xgmac_cfg_table) / sizeof(struct _xgmac_cfg));
+
+	mac_printf("\n MAC SET API's\n\n");
+
+	for (i = 0; i < num_of_elem; i++) {
+		if (xgmac_cfg_table[i].set_func)
+			mac_printf("switch_cli xgmac <0/1/2/* MacIdx> %15s \t %s \n",
+				   xgmac_cfg_table[i].name,
+				   xgmac_cfg_table[i].help);
+	}
+
+	mac_printf("\n MAC GET API's\n\n");
+
+	for (i = 0; i < num_of_elem; i++) {
+		if (xgmac_cfg_table[i].get_func)
+			mac_printf("switch_cli xgmac <0/1/2/ MacIdx> get %s\n",
+				   xgmac_cfg_table[i].name);
+	}
+}
+
+void xgmac_wr_reg(void *pdev, u16 reg_off, u32 reg_val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	mac_printf("\tREG offset: 0x%04x\n\tData: %08X\n", reg_off,
+		   reg_val);
+
+	XGMAC_RGWR(pdata, reg_off, reg_val);
+}
+
+u32 xgmac_rd_reg(void *pdev, u16 reg_off)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	pdata->reg_val = XGMAC_RGRD(pdata, reg_off);
+
+	mac_printf("\tREG offset: 0x%04x\n\tData: %08X\n", reg_off,
+		   pdata->reg_val);
+
+	return pdata->reg_val;
+}
+
+u8 mac_addr[6] = {0x00, 0x00, 0x94, 0x00, 0x00, 0x08};
+
+void xgmac_init_pdata(struct mac_prv_data *pdata, int idx)
+{
+#ifdef __KERNEL__
+	memset(pdata, 0, sizeof(struct mac_prv_data));
+#endif
+
+	if (idx == -1)
+		pdata->mac_idx = (pdata - &prv_data[0]);
+	else
+		pdata->mac_idx = idx;
+
+	pdata->xgmac_ctrl_reg = XGMAC_CTRL_REG(pdata->mac_idx);
+	pdata->xgmac_data1_reg = XGMAC_DATA1_REG(pdata->mac_idx);
+	pdata->xgmac_data0_reg = XGMAC_DATA0_REG(pdata->mac_idx);
+
+	pdata->tx_q_count		= 1;
+	pdata->rx_q_count		= 1;
+	pdata->tx_sf_mode		= 0;
+	pdata->tx_threshold		= MTL_TX_THRESHOLD_64;
+	pdata->rx_sf_mode		= 0;
+	pdata->rx_threshold		= MTL_RX_THRESHOLD_64;
+
+	mac_addr[5] = pdata->mac_idx + 1;
+	memcpy(pdata->mac_addr,	mac_addr, 6);
+
+	pdata->tstamp_addend		= 0;
+	pdata->tx_tstamp		= 0;
+	pdata->phy_speed		= SPEED_XGMAC_10G;
+	pdata->promisc_mode		= 1;
+	pdata->all_mcast_mode		= 1;
+	pdata->rfa			= 2;
+	pdata->rfd			= 4;
+	pdata->tx_mtl_alg		= MTL_ETSALG_WRR;
+	pdata->rx_mtl_alg		= MTL_RAA_SP;
+	pdata->mtu			= FALCON_MAX_MTU;
+	pdata->pause_time		= 0xFFFF;
+	pdata->rx_checksum_offload	= 1;
+	pdata->pause_frm_enable		= 1;
+	pdata->rmon_reset		= 1;
+	pdata->loopback			= 0;
+	pdata->eee_enable		= 1;
+	pdata->lst			= 1000;
+	pdata->twt			= 0;
+	pdata->lpitxa			= 0;
+	pdata->crc_strip		= 0;
+	pdata->crc_strip_type		= 0;
+	pdata->padcrc_strip		= 0;
+	pdata->rmon_reset		= 1;
+	pdata->fup			= 1;
+	pdata->fef			= 1;
+	pdata->mac_en			= 1;
+	pdata->ipg			= 0;
+	pdata->enable_mac_int		= XGMAC_ALL_EVNT;
+	pdata->enable_mtl_int		= MASK(MTL_Q_IER, TXUIE) |
+					  MASK(MTL_Q_IER, ABPSIE) |
+					  MASK(MTL_Q_IER, RXOIE);
+	/* Calc as (2^32 * 50Mhz)/ 500Mhz */
+	pdata->def_addend		= 0x19999999;
+	pdata->sec			= 0;
+	pdata->nsec			= 0;
+	pdata->ptp_clk			= PTP_CLK;
+	pdata->one_nsec_accuracy	= 0;
+	pdata->ss_addr_base		= adap_priv_data.ss_addr_base;
+	pdata->lmac_addr_base		= LEGACY_MAC_BASE;
+#if defined(PC_UTILITY) || defined(CHIPTEST)
+	pdata->max_mac			= MAX_MAC;
+#endif
+}
+
+int xgmac_main(u32 argc, u8 *argv[])
+{
+	u32 i = 0, found = 0;
+	u32 start_arg = 0;
+	int idx = 0;
+	u32 max_mac;
+
+	int num_of_elem =
+		(sizeof(xgmac_cfg_table) / sizeof(struct _xgmac_cfg));
+	struct mac_ops *ops = NULL;
+	struct mac_prv_data *prv_data_k = NULL;
+
+	prv_data[0].set_all = 0;
+	prv_data[1].set_all = 0;
+	prv_data[2].set_all = 0;
+
+	start_arg++;
+	start_arg++;
+
+#if defined(UPTIME) && UPTIME
+
+	if (!strcmp(argv[start_arg], "uptime")) {
+		found = 1;
+		u32 total_sec, nanosec;
+		u32 sec, min, hr, days;
+
+		total_sec = XGMAC_RGRD(&prv_data[0], MAC_SYS_TIME_SEC);
+		nanosec = XGMAC_RGRD(&prv_data[0], MAC_SYS_TIME_NSEC);
+
+		if (sec)
+			sec = (total_sec * (nanosec / NANOSEC_IN_ONESEC));
+		else
+			sec = (nanosec / NANOSEC_IN_ONESEC);
+
+		if (sec >= 60) {
+			min = sec / 60;
+			sec = sec - (min * 60);
+		} else {
+			min = 0;
+		}
+
+		if (min >= 60) {
+			hr = min / 60;
+			min = min - (hr * 60);
+		} else {
+			hr = 0;
+		}
+
+		if (hr >= 24) {
+			days = hr / 24;
+			hr = hr - (days * 24);
+		} else {
+			days = 0;
+		}
+
+		mac_printf("Uptime(d:h:m:s): %02d:%02d:%02d:%02d\n",
+			   days, hr, min, sec);
+
+		goto end;
+	}
+
+#endif
+
+	if (!strcmp(argv[start_arg], "-help")) {
+		found = 1;
+		xgmac_menu();
+
+		goto end;
+	}
+
+	if (found)
+		goto end;
+
+	if (!strcmp(argv[start_arg], "*")) {
+		start_arg++;
+		max_mac = gsw_get_mac_subifcnt(0);
+
+		for (i = 0; i < max_mac; i++) {
+			prv_data[i].set_all = 1;
+			ops = gsw_get_mac_ops(0, i);
+			prv_data_k = GET_MAC_PDATA(ops);
+			prv_data_k->set_all = 1;
+		}
+
+	} else {
+		idx = mac_nstrtoul(argv[start_arg],
+				   mac_nstrlen(argv[start_arg]), &start_arg);
+
+		max_mac = gsw_get_mac_subifcnt(0);
+
+		if ((idx > (max_mac - 1)) || (idx < 0)) {
+			mac_printf("Give valid xgmac index 0/1/2/*\n");
+			return -1;
+		}
+
+		ops = gsw_get_mac_ops(0, idx);
+
+		if (!ops)
+			return -1;
+
+		prv_data_k = GET_MAC_PDATA(ops);
+
+		if (!prv_data_k)
+			return -1;
+
+		prv_data_k->set_all = 0;
+	}
+
+	if (!strcmp(argv[start_arg], "r")) {
+		start_arg++;
+		found = 1;
+#if defined(PC_UTILITY) || defined(__KERNEL__)
+
+		if ((strstr(argv[start_arg], "0x")) ||
+		    (strstr(argv[start_arg], "0X")))
+			mac_printf("matches with 0x\n");
+		else
+			mac_printf("Please give the address with "
+				   "0x firmat\n");
+
+#endif
+
+		if (prv_data_k) {
+			prv_data_k->reg_off = mac_nstrtoul(argv[start_arg],
+							   mac_nstrlen(argv[start_arg]),
+							   &start_arg);
+			xgmac_rd_reg(ops, prv_data_k->reg_off);
+		}
+
+		goto end;
+	}
+
+	if (!strcmp(argv[start_arg], "w")) {
+		start_arg++;
+		found = 1;
+
+#if defined(PC_UTILITY) || defined(__KERNEL__)
+
+		if ((strstr(argv[start_arg], "0x")) ||
+		    (strstr(argv[start_arg], "0X")))
+			mac_printf("matches with 0x\n");
+		else
+			mac_printf("Please give the address with "
+				   "0x format\n");
+
+#endif
+
+		if (prv_data_k) {
+			prv_data_k->reg_off = mac_nstrtoul(argv[start_arg],
+							   mac_nstrlen(argv[start_arg]),
+							   &start_arg);
+			prv_data_k->reg_val = mac_nstrtoul(argv[start_arg],
+							   mac_nstrlen(argv[start_arg]),
+							   &start_arg);
+			xgmac_wr_reg(ops,
+				     prv_data_k->reg_off,
+				     prv_data_k->reg_val);
+		}
+
+		goto end;
+	}
+
+	if (!strcmp(argv[start_arg], "get")) {
+		start_arg++;
+
+		for (i = 0; i < num_of_elem; i++) {
+			removeSpace(xgmac_cfg_table[i].name);
+
+			if (!strcmp(xgmac_cfg_table[i].name,
+				    argv[start_arg])) {
+				if (xgmac_cfg_table[i].get_func)
+					xgmac_cfg_table[i].get_func(ops);
+
+				found = 1;
+				break;
+			}
+		}
+	}
+
+	if (found)
+		goto end;
+
+	for (i = 0; i < num_of_elem; i++) {
+		removeSpace(argv[start_arg]);
+
+		if (!strcmp(xgmac_cfg_table[i].name, argv[start_arg])) {
+			start_arg++;
+
+			if (argc != xgmac_cfg_table[i].args) {
+				mac_printf("[USAGE:]\n");
+				mac_printf("xgmac <idx> %s %s\n",
+					   xgmac_cfg_table[i].name,
+					   xgmac_cfg_table[i].help);
+				return 0;
+			}
+
+
+			set_data(argv, i, &start_arg, idx);
+
+			if (xgmac_cfg_table[i].set_func)
+				xgmac_cfg_table[i].set_func(ops);
+
+			found = 1;
+			break;
+		}
+	}
+
+end:
+
+	if (found == 0)
+		mac_printf("command entered is invalid, use help to "
+			   "display the supported cmds\n");
+
+	return 0;
+}
+
+void set_data(u8 *argv[], int i, u32 *start_arg, u32 idx)
+{
+	if (prv_data[0].set_all == 1) {
+		set_all_pdata(argv[*start_arg],
+			      xgmac_cfg_table[i].data1, start_arg);
+		set_all_pdata(argv[*start_arg],
+			      xgmac_cfg_table[i].data2, start_arg);
+		set_all_pdata(argv[*start_arg],
+			      xgmac_cfg_table[i].data3, start_arg);
+		set_all_pdata(argv[*start_arg],
+			      xgmac_cfg_table[i].data4, start_arg);
+	} else {
+		set_pdata(argv[*start_arg], idx,
+			  xgmac_cfg_table[i].data1, start_arg);
+		set_pdata(argv[*start_arg], idx,
+			  xgmac_cfg_table[i].data2, start_arg);
+		set_pdata(argv[*start_arg], idx,
+			  xgmac_cfg_table[i].data3, start_arg);
+		set_pdata(argv[*start_arg], idx,
+			  xgmac_cfg_table[i].data4, start_arg);
+	}
+}
+
+void set_all_pdata(u8 *arg, u32 *data, u32 *start_arg)
+{
+	int j = 0, offset;
+	u32 val;
+	struct mac_ops *ops;
+	struct mac_prv_data *mac_priv_data;
+	u32 max_mac = gsw_get_mac_subifcnt(0);
+
+	if (data) {
+		offset = (u8 *)(data) - (u8 *)&pdata;
+		val = mac_nstrtoul(arg, mac_nstrlen(arg), start_arg);
+
+		*data = val;
+
+		for (j = 0; j < max_mac; j++) {
+#ifdef __KERNEL__
+			ops  = gsw_get_mac_ops(0, j);
+
+			if (ops) {
+				mac_priv_data = GET_MAC_PDATA(ops);
+				*(u32 *)(((u8 *)mac_priv_data + offset)) =
+					val;
+			}
+
+#else
+			*((u32 *)(((u8 *)&prv_data[j]) + offset)) = val;
+#endif
+		}
+	}
+}
+
+void set_pdata(u8 *arg, u32 idx, u32 *data, u32 *start_arg)
+{
+	int offset;
+	u32 val;
+	struct mac_ops *ops;
+	struct mac_prv_data *mac_priv_data;
+
+	if (data) {
+		offset = (u8 *)(data) - (u8 *)&pdata;
+		val =  mac_nstrtoul(arg, mac_nstrlen(arg), start_arg);
+
+		*data = val;
+
+#ifdef __KERNEL__
+		ops  = gsw_get_mac_ops(0, idx);
+
+		if (ops) {
+			mac_priv_data = GET_MAC_PDATA(ops);
+			*(u32 *)(((u8 *)mac_priv_data + offset)) = val;
+		}
+
+#else
+		*((u32 *)(((u8 *)&prv_data[idx]) + offset)) = val;
+#endif
+	}
+}
+
+void xgmac_cli_init(void)
+{
+	int i = 0;
+	int num_of_elem = (sizeof(xgmac_cfg_table) / sizeof(struct _xgmac_cfg));
+
+	for (i = 0; i < num_of_elem; i++) {
+		removeSpace(xgmac_cfg_table[i].name);
+
+		xgmac_cfg_table[i].args = 4;
+
+		if (xgmac_cfg_table[i].data1)
+			xgmac_cfg_table[i].args += 1;
+
+		if (xgmac_cfg_table[i].data2)
+			xgmac_cfg_table[i].args += 1;
+
+		if (xgmac_cfg_table[i].data3)
+			xgmac_cfg_table[i].args += 1;
+
+		if (xgmac_cfg_table[i].data4)
+			xgmac_cfg_table[i].args += 1;
+	}
+}
+
+
+#if defined(PC_UTILITY) || defined(CHIPTEST)
+struct mac_ops *gsw_get_mac_ops(u32 devid, u32 mac_idx)
+{
+	return &(prv_data[mac_idx].ops);
+}
+
+u32 gsw_get_mac_subifcnt(u32 devid)
+{
+	return MAX_MAC;
+}
+#endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mdio.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mdio.c
new file mode 100644
index 000000000000..f777a64af52b
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mdio.c
@@ -0,0 +1,676 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+/* =========================================================================
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ * The Synopsys DWC ETHER XGMAC Software Driver and documentation (hereinafter
+ * "Software") is an unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto.  Permission is hereby granted,
+ * free of charge, to any person obtaining a copy of this software annotated
+ * with this license and the Software, to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================= */
+
+
+#include <xgmac_mdio.h>
+#include <xgmac.h>
+#ifdef __KERNEL__
+#include <linux/phy.h>
+#include <linux/mdio.h>
+#endif
+
+static void dump_phy_registers(void *pdev);
+
+/* SCAR:
+ * DA
+ *	Device Address for indirect addressing of device for single read/write.
+ * PA
+ *	Port Address used for indirect single read/write access.
+ * RA
+ *	Register Address for single read /write
+ *	When using Clause 22 frames, only the lower 5 bits of the field are used
+ * SCCDR:
+ * SADDR: Skip Address Frame
+ *	The application sets this bit to prevent the SMA from sending address
+ *	frames before read, write, or post-increment read frames.
+ * CMD: Control Command
+ *	SMA commands are written to these bits. The command codes are:
+ *	11 SINGLE_READ
+ *	01 SINGLE_WRITE
+ *	10 POST INCREMENT READ OPERATION
+ *	00 Reserved (Results are undefined)
+ * SDATA: Single Write Data
+ *	For single writes, this field contains data to be written.
+ *	For single reads, this field contains data that has been read.
+ */
+int xgmac_mdio_single_rd(void *pdev,
+			 u32 dev_adr,
+			 u32 phy_id,
+			 u32 phy_reg,
+			 u32 *phy_reg_data)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mdio_sccdr = 0;
+	u32 mdio_scar = 0;
+
+	/* wait for any previous MDIO read/write operation to complete */
+
+	/*Poll*/
+	while (1) {
+		if (XGMAC_RGRD_BITS(pdata, MDIO_SCCDR, BUSY) == 0)
+			break;
+	}
+
+	/* initiate the MDIO read operation by updating desired bits
+	 * PA - phy address/id (0 - 31)
+	 * RA - phy register offset
+	 */
+
+	mdio_scar = XGMAC_RGRD(pdata, MDIO_SCAR);
+
+	MAC_SET_VAL(mdio_scar, MDIO_SCAR, DA, dev_adr);
+	MAC_SET_VAL(mdio_scar, MDIO_SCAR, PA, phy_id);
+	MAC_SET_VAL(mdio_scar, MDIO_SCAR, RA, phy_reg);
+
+	XGMAC_RGWR(pdata, MDIO_SCAR, mdio_scar);
+
+	mdio_sccdr = XGMAC_RGRD(pdata, MDIO_SCCDR);
+
+	MAC_SET_VAL(mdio_sccdr, MDIO_SCCDR, BUSY, 1);
+	MAC_SET_VAL(mdio_sccdr, MDIO_SCCDR, SADDR, 0);
+	MAC_SET_VAL(mdio_sccdr, MDIO_SCCDR, CMD, 3);
+	MAC_SET_VAL(mdio_sccdr, MDIO_SCCDR, SDATA, 0);
+
+	XGMAC_RGWR(pdata, MDIO_SCCDR, mdio_sccdr);
+
+	/*DELAY IMPLEMENTATION USING udelay()*/
+	//udelay(10);
+
+	/* wait for MDIO read operation to complete */
+
+	/*Poll*/
+	while (1) {
+		if (XGMAC_RGRD_BITS(pdata, MDIO_SCCDR, BUSY) == 0)
+			break;
+	}
+
+	/* read the data */
+	mdio_sccdr = XGMAC_RGRD(pdata, MDIO_SCCDR);
+	*phy_reg_data = MAC_GET_VAL(mdio_sccdr, MDIO_SCCDR, SDATA);
+
+	return 0;
+}
+
+void print_mdio_rd_cnt(void *pdev,
+		       u32 dev_adr,
+		       u32 phy_id,
+		       u32 phy_reg_st,
+		       u32 phy_reg_end)
+
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int clause;
+	u32 i, phy_reg_data;
+
+	clause = mdio_get_clause(pdata, pdata->mac_idx);
+	mac_printf("OP    \tCL    \tDEVADR\tPHYID \tPHYREG\tDATA  \n");
+	mac_printf("============================================\n");
+
+	for (i = 0; i <= (phy_reg_end - phy_reg_st); i++) {
+		xgmac_mdio_single_rd(pdev, dev_adr, phy_id, phy_reg_st + i,
+				     &phy_reg_data);
+
+		mac_printf("%s\t", "RD");
+		mac_printf("%4s\t", clause ? "CL22" : "CL45");
+		mac_printf("%6X\t", dev_adr);
+		mac_printf("%5X\t", phy_id);
+		mac_printf("%6X\t", phy_reg_st + i);
+		mac_printf("%4X\t", phy_reg_data);
+		mac_printf("\n");
+	}
+}
+
+void xgmac_print_mdio(void *pdev,
+		      u32 op,
+		      u32 dev_adr,
+		      u32 phy_id,
+		      u32 phy_reg,
+		      u32 phy_reg_data)
+
+{
+	int clause;
+
+	clause = mdio_get_clause(pdev, phy_id);
+	mac_printf("OP    \tCL    \tDEVADR\tPHYID \tPHYREG\tDATA  \n");
+	mac_printf("============================================\n");
+
+	mac_printf("%6s\t", "RD");
+	mac_printf("%6s\t", clause ? "CL22" : "CL45");
+	mac_printf("%6X\t", dev_adr);
+	mac_printf("%6X\t", phy_id);
+	mac_printf("%6X\t", phy_reg);
+	mac_printf("%6X\t", phy_reg_data);
+	mac_printf("\n");
+}
+
+/*brief This sequence is used to write into phy registers
+ */
+int xgmac_mdio_single_wr(void *pdev,
+			 u32 dev_adr,
+			 u32 phy_id,
+			 u32 phy_reg,
+			 u32 phy_reg_data)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mdio_sccdr = 0;
+	u32 mdio_scar = 0;
+
+	/* wait for any previous MDIO read/write operation to complete */
+
+	/*Poll*/
+	while (1) {
+		if (XGMAC_RGRD_BITS(pdata, MDIO_SCCDR, BUSY) == 0)
+			break;
+	}
+
+	mdio_scar = XGMAC_RGRD(pdata, MDIO_SCAR);
+
+	MAC_SET_VAL(mdio_scar, MDIO_SCAR, DA, dev_adr);
+	MAC_SET_VAL(mdio_scar, MDIO_SCAR, PA, phy_id);
+	MAC_SET_VAL(mdio_scar, MDIO_SCAR, RA, phy_reg);
+
+	XGMAC_RGWR(pdata, MDIO_SCAR, mdio_scar);
+
+	mdio_sccdr = XGMAC_RGRD(pdata, MDIO_SCCDR);
+
+	MAC_SET_VAL(mdio_sccdr, MDIO_SCCDR, SDATA, phy_reg_data);
+	MAC_SET_VAL(mdio_sccdr, MDIO_SCCDR, BUSY, 1);
+	MAC_SET_VAL(mdio_sccdr, MDIO_SCCDR, SADDR, 0);
+	MAC_SET_VAL(mdio_sccdr, MDIO_SCCDR, CMD, 1);
+
+	XGMAC_RGWR(pdata, MDIO_SCCDR, mdio_sccdr);
+
+	/*DELAY IMPLEMENTATION USING udelay()*/
+	//udelay(10);
+
+	/* wait for MDIO read operation to complete */
+
+	/*Poll*/
+	while (1) {
+		if (XGMAC_RGRD_BITS(pdata, MDIO_SCCDR, BUSY) == 0)
+			break;
+	}
+
+	return 0;
+}
+
+/*	1 - Clause 22
+ *	0 - Clause 45
+ *	phy_id same as portid, 0/1/2/3
+ */
+int mdio_set_clause(void *pdev, u32 clause, u32 phy_id)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mdio_c22p = 0;
+
+	mdio_c22p = XGMAC_RGRD(pdata, MDIO_C22P);
+
+	SET_N_BITS(mdio_c22p, phy_id, MDIO_CL22P_PORT0_WIDTH, clause);
+
+	mac_printf("MDIO: portID %d set to %s\n", phy_id,
+		   clause ? "Clause 22" : "Clause 45");
+
+	/* Select port 0, 1, 2 and 3 as Clause 22/45 ports */
+	XGMAC_RGWR(pdata, MDIO_C22P, mdio_c22p);
+
+	return 0;
+}
+
+int mdio_get_clause(void *pdev,  u32 phy_id)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mdio_c22p = 0;
+	int clause;
+
+	mdio_c22p = XGMAC_RGRD(pdata, MDIO_C22P);
+
+	clause = GET_N_BITS(mdio_c22p, phy_id, MDIO_CL22P_PORT0_WIDTH);
+
+	return clause;
+}
+
+int mdio_set_interrupt(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mdio_ier = 0;
+
+	if (val & MASK(MDIO_IER, CWCOMPIE))
+		MAC_SET_VAL(mdio_ier, MDIO_IER, CWCOMPIE, val);
+
+	if (val & MASK(MDIO_IER, SNGLCOMPIE))
+		MAC_SET_VAL(mdio_ier, MDIO_IER, SNGLCOMPIE, val);
+
+	if (val & MASK(MDIO_IER, PRT3ALIE))
+		MAC_SET_VAL(mdio_ier, MDIO_IER, PRT3ALIE, val);
+
+	if (val & MASK(MDIO_IER, PRT2ALIE))
+		MAC_SET_VAL(mdio_ier, MDIO_IER, PRT2ALIE, val);
+
+	if (val & MASK(MDIO_IER, PRT1ALIE))
+		MAC_SET_VAL(mdio_ier, MDIO_IER, PRT1ALIE, val);
+
+	if (val & MASK(MDIO_IER, PRT0ALIE))
+		MAC_SET_VAL(mdio_ier, MDIO_IER, PRT0ALIE, val);
+
+	if (val & MASK(MDIO_IER, PRT3LSIE))
+		MAC_SET_VAL(mdio_ier, MDIO_IER, PRT3LSIE, val);
+
+	if (val & MASK(MDIO_IER, PRT2LSIE))
+		MAC_SET_VAL(mdio_ier, MDIO_IER, PRT2LSIE, val);
+
+	if (val & MASK(MDIO_IER, PRT1LSIE))
+		MAC_SET_VAL(mdio_ier, MDIO_IER, PRT1LSIE, val);
+
+	if (val & MASK(MDIO_IER, PRT0LSIE))
+		MAC_SET_VAL(mdio_ier, MDIO_IER, PRT0LSIE, val);
+
+	if (val & MASK(MDIO_IER, PRT3CONIE))
+		MAC_SET_VAL(mdio_ier, MDIO_IER, PRT3CONIE, val);
+
+	if (val & MASK(MDIO_IER, PRT2CONIE))
+		MAC_SET_VAL(mdio_ier, MDIO_IER, PRT2CONIE, val);
+
+	if (val & MASK(MDIO_IER, PRT1CONIE))
+		MAC_SET_VAL(mdio_ier, MDIO_IER, PRT1CONIE, val);
+
+	if (val & MASK(MDIO_IER, PRT0CONIE))
+		MAC_SET_VAL(mdio_ier, MDIO_IER, PRT0CONIE, val);
+
+	XGMAC_RGWR(pdata, MDIO_IER, mdio_ier);
+
+	return 0;
+}
+
+int xgmac_mdio_get_int_sts(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mdio_isr = XGMAC_RGRD(pdata, MDIO_ISR);
+	u32 mdio_ier = XGMAC_RGRD(pdata, MDIO_IER);
+
+	mac_printf("XGMAC %d: MDIO Interrupt Status\n", pdata->mac_idx);
+	mac_printf("\tMDIO_IER interrupts  %s %08x\n",
+		   mdio_ier ? "ENABLED" : "DISABLED", mdio_ier);
+
+	if (mdio_ier & MASK(MDIO_IER, CWCOMPIE))
+		mac_printf("Continuous Write Completion Interrupt Enabled\n");
+
+	if (mdio_ier & MASK(MDIO_IER, SNGLCOMPIE))
+		mac_printf("Single Command Completion Interrupt Enabled\n");
+
+	if (mdio_ier & MASK(MDIO_IER, PRT3ALIE))
+		mac_printf("Dev Present Sts Change Interrupt P3 Enabled\n");
+
+	if (mdio_ier & MASK(MDIO_IER, PRT2ALIE))
+		mac_printf("Dev Present Sts Change Interrupt P2 Enabled\n");
+
+	if (mdio_ier & MASK(MDIO_IER, PRT1ALIE))
+		mac_printf("Dev Present Sts Change Interrupt P1 Enabled\n");
+
+	if (mdio_ier & MASK(MDIO_IER, PRT0ALIE))
+		mac_printf("Dev Present Sts Change Interrupt P0 Enabled\n");
+
+	if (mdio_ier & MASK(MDIO_IER, PRT3LSIE))
+		mac_printf("Link Status Change Interrupt P3 Enabled\n");
+
+	if (mdio_ier & MASK(MDIO_IER, PRT2LSIE))
+		mac_printf("Link Status Change Interrupt P2 Enabled\n");
+
+	if (mdio_ier & MASK(MDIO_IER, PRT1LSIE))
+		mac_printf("Link Status Change Interrupt P1 Enabled\n");
+
+	if (mdio_ier & MASK(MDIO_IER, PRT0LSIE))
+		mac_printf("Link Status Change Interrupt P0 Enabled\n");
+
+	if (mdio_ier & MASK(MDIO_IER, PRT3CONIE))
+		mac_printf("Connect/Disconnect Event Interrupt P3 Enabled\n");
+
+	if (mdio_ier & MASK(MDIO_IER, PRT2CONIE))
+		mac_printf("Connect/Disconnect Event Interrupt P2 Enabled\n");
+
+	if (mdio_ier & MASK(MDIO_IER, PRT1CONIE))
+		mac_printf("Connect/Disconnect Event Interrupt P1 Enabled\n");
+
+	if (mdio_ier & MASK(MDIO_IER, PRT0CONIE))
+		mac_printf("Connect/Disconnect Event Interrupt P0 Enabled\n");
+
+	if (!mdio_isr) {
+		mac_printf("\tNo MDIO interrupt status available %08x\n",
+			   mdio_isr);
+	} else {
+		mac_printf("\tMDIO interrupt status available %08x\n",
+			   mdio_isr);
+
+		if (mdio_isr & MASK(MDIO_ISR, CWCOMPINT))
+			mac_printf("Continuous WR Completion Int Set\n");
+
+		if (mdio_isr & MASK(MDIO_ISR, SNGLCOMPINT))
+			mac_printf("Single Cmd Completion Int Set\n");
+
+		if (mdio_isr & MASK(MDIO_ISR, PRT3ALINT))
+			mac_printf("Dev Present Sts Change Int P3 Set\n");
+
+		if (mdio_isr & MASK(MDIO_ISR, PRT2ALINT))
+			mac_printf("Dev Present Sts Change Int P2 Set\n");
+
+		if (mdio_isr & MASK(MDIO_ISR, PRT1ALINT))
+			mac_printf("Dev Present Sts Change Int P1 Set\n");
+
+		if (mdio_isr & MASK(MDIO_ISR, PRT0ALINT))
+			mac_printf("Dev Present Sts Change Int P0 Set\n");
+
+		if (mdio_isr & MASK(MDIO_ISR, PRT3LSINT))
+			mac_printf("Link Sts Change Int P3 Set\n");
+
+		if (mdio_isr & MASK(MDIO_ISR, PRT2LSINT))
+			mac_printf("Link Sts Change Int P2 Set\n");
+
+		if (mdio_isr & MASK(MDIO_ISR, PRT1LSINT))
+			mac_printf("Link Sts Change Int P1 Set\n");
+
+		if (mdio_isr & MASK(MDIO_ISR, PRT0LSINT))
+			mac_printf("Link Sts Change Int P0 Set\n");
+
+		if (mdio_isr & MASK(MDIO_ISR, PRT3CONINT))
+			mac_printf("Connect/Disconnect Event Int P3 Set\n");
+
+		if (mdio_isr & MASK(MDIO_ISR, PRT2CONINT))
+			mac_printf("Connect/Disconnect Event Int P2 Set\n");
+
+		if (mdio_isr & MASK(MDIO_ISR, PRT1CONINT))
+			mac_printf("Connect/Disconnect Event Int P1 Set\n");
+
+		if (mdio_isr & MASK(MDIO_ISR, PRT0CONINT))
+			mac_printf("Connect/Disconnect Event Int P0 Set\n");
+	}
+
+	return 0;
+}
+#ifdef __KERNEL__
+/* API to read MII PHY register
+* \details This API is expected to write MII registers with the value being
+* passed as the last argument which is done in write_phy_regs API
+* called by this function.
+*
+* \param[in] bus - points to the mii_bus structure
+* \param[in] phyadr - the phy address to write
+* \param[in] phyreg - the phy register offset to write
+* \param[in] phydata - the register value to write with
+*
+* \return 0 on success and -ve number on failure.
+*/
+static int xgmac_mdio_read(struct mii_bus *bus, int phyadr, int phyreg)
+{
+	struct mac_ops *pdev = bus->priv;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int phydata;
+
+	mac_printf("XGMAC %d: MDIO Read phyadr = %d, phyreg = %d\n",
+		   pdata->mac_idx, phyadr, phyreg);
+
+	xgmac_mdio_single_rd(pdev, 0, phyadr, phyreg, &phydata);
+
+	mac_printf("XGMAC %d: MDIO Read phydata = %#x\n",
+		   pdata->mac_idx, phydata);
+
+	return phydata;
+}
+
+/* API to write MII PHY register
+* \details This API is expected to write MII registers with the value being
+* passed as the last argument which is done in write_phy_regs API
+* called by this function.
+*
+* \param[in] bus - points to the mii_bus structure
+* \param[in] phyadr - the phy address to write
+* \param[in] phyreg - the phy register offset to write
+* \param[in] phydata - the register value to write with
+*
+* \return 0 on success and -ve number on failure.
+*/
+
+static int xgmac_mdio_write(struct mii_bus *bus, int phyadr, int phyreg,
+			    u16 phydata)
+{
+	struct mac_ops *pdev = bus->priv;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int ret = 0;
+
+	xgmac_mdio_single_wr(pdev, 0, phyadr, phyreg, phydata);
+
+	mac_printf("XGMAC %d: MDIO Write"
+		   "phyadr %x phyreg %x phydata %x Completed\n",
+		   pdata->mac_idx, phyadr, phyreg, phydata);
+
+	return ret;
+}
+
+
+/* API to reset PHY
+ */
+static int xgmac_mdio_reset(struct mii_bus *bus)
+{
+	struct mac_ops *pdev = bus->priv;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int phydata;
+
+	mac_printf("XGMAC %d: MDIO Reset phyadr : %d\n", pdata->mac_idx,
+		   pdata->phyadr);
+
+	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_BMCR,
+			     &phydata);
+
+	if (phydata < 0)
+		return 0;
+
+	/* issue soft reset to PHY */
+	phydata |= BMCR_RESET;
+	xgmac_mdio_single_wr(pdev, 0, pdata->phyadr, MII_BMCR, phydata);
+
+	/* wait until software reset completes */
+	do {
+		xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_BMCR,
+				     &phydata);
+	} while ((phydata >= 0) && (phydata & BMCR_RESET));
+
+	mac_printf("XGMAC %d: MDIO Reset Completed\n",
+		   pdata->mac_idx);
+
+	return 0;
+}
+
+/* API to register mdio.
+ */
+int xgmac_mdio_register(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mii_bus *new_bus = NULL;
+	int phyadr = 0;
+	unsigned short phy_detected = 0;
+	int ret = 0;
+	int phy_reg_read_status, mii_status;
+
+	mac_printf("XGMAC %d: mdio register\n", pdata->mac_idx);
+
+	/* find the phy ID or phy address which is connected to our MAC */
+	for (phyadr = 0; phyadr < 32; phyadr++) {
+
+		phy_reg_read_status =
+			xgmac_mdio_single_rd(&pdata->ops, 0, phyadr, MII_BMSR,
+					     &mii_status);
+
+		if (phy_reg_read_status == 0) {
+			if (mii_status != 0x0000 && mii_status != 0xffff) {
+				pr_err("Phy detected at"\
+				       " ID/ADDR %d\n", phyadr);
+				phy_detected = 1;
+				break;
+			}
+		} else if (phy_reg_read_status < 0) {
+			pr_err("Error reading the phy register"\
+			       " MII_BMSR for phy ID/ADDR %d\n", phyadr);
+		}
+	}
+
+	if (!phy_detected) {
+		mac_printf("XGMAC %d: No phy could be detected\n",
+			   pdata->mac_idx);
+		return -ENOLINK;
+	}
+
+	pdata->phyadr = phyadr;
+	pdata->bus_id = 0x1;
+
+	dump_phy_registers(pdev);
+
+	new_bus = mdiobus_alloc();
+
+	if (new_bus == NULL) {
+		mac_printf("XGMAC %d: Unable to allocate mdio bus\n",
+			   pdata->mac_idx);
+		return -ENOMEM;
+	}
+
+	new_bus->name = "xgmac_phy";
+	new_bus->read = xgmac_mdio_read;
+	new_bus->write = xgmac_mdio_write;
+	new_bus->reset = xgmac_mdio_reset;
+	snprintf(new_bus->id, MII_BUS_ID_SIZE, "%s-%x", new_bus->name,
+		 pdata->bus_id);
+	new_bus->priv = pdev;
+	new_bus->phy_mask = 0;
+	new_bus->parent = pdata->dev;
+	ret = mdiobus_register(new_bus);
+
+	if (ret != 0) {
+		pr_err("%s: Cannot register as MDIO bus\n",
+		       new_bus->name);
+		mdiobus_free(new_bus);
+		return ret;
+	}
+
+	pdata->mii = new_bus;
+
+	mac_printf("XGMAC %d: MDIO register Successfull\n", pdata->mac_idx);
+
+	return ret;
+}
+
+/* API to unregister mdio.
+ */
+void xgmac_mdio_unregister(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	mac_printf("XGMAC %d: mdio unregister\n", pdata->mac_idx);
+
+	if (pdata->phydev) {
+		phy_stop(pdata->phydev);
+		phy_disconnect(pdata->phydev);
+		pdata->phydev = NULL;
+	}
+
+	mdiobus_unregister(pdata->mii);
+	pdata->mii->priv = NULL;
+	mdiobus_free(pdata->mii);
+	pdata->mii = NULL;
+
+	mac_printf("XGMAC %d: mdio_unregister Successfull\n", pdata->mac_idx);
+}
+
+static void dump_phy_registers(void *pdev)
+{
+	u32 phydata = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	mac_printf(
+		"\n************* PHY Reg dump *************************\n");
+	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_BMCR, &phydata);
+	mac_printf(
+		"Phy Control Reg(Basic Mode Control Reg) (%#x) = %#x\n",
+		MII_BMCR, phydata);
+
+	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_BMSR, &phydata);
+	mac_printf("Phy Status Reg(Basic Mode Status Reg) (%#x) = %#x\n",
+		   MII_BMSR, phydata);
+
+	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_PHYSID1, &phydata);
+	mac_printf("Phy Id (PHYS ID 1) (%#x)= %#x\n", MII_PHYSID1,
+		   phydata);
+
+	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_PHYSID2,
+			     &phydata);
+	mac_printf("Phy Id (PHYS ID 2) (%#x)= %#x\n", MII_PHYSID2,
+		   phydata);
+
+	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_ADVERTISE,
+			     &phydata);
+	mac_printf("Auto-nego Adv (Advertisement Control Reg)"\
+		   " (%#x) = %#x\n", MII_ADVERTISE, phydata);
+
+	/* read Phy Control Reg */
+	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_LPA,
+			     &phydata);
+	mac_printf("Auto-nego Lap (Link Partner Ability Reg)"\
+		   " (%#x)= %#x\n", MII_LPA, phydata);
+
+	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_EXPANSION,
+			     &phydata);
+	mac_printf("Auto-nego Exp (Extension Reg)"\
+		   "(%#x) = %#x\n", MII_EXPANSION, phydata);
+
+	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_ESTATUS,
+			     &phydata);
+	mac_printf("Extended Status Reg (%#x) = %#x\n", MII_ESTATUS,
+		   phydata);
+
+	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_CTRL1000,
+			     &phydata);
+	mac_printf("1000 Ctl Reg (1000BASE-T Control Reg)"\
+		   "(%#x) = %#x\n", MII_CTRL1000, phydata);
+
+	xgmac_mdio_single_rd(pdev, 0, pdata->phyadr, MII_STAT1000, &phydata);
+	mac_printf("1000 Sts Reg (1000BASE-T Status)(%#x) = %#x\n",
+		   MII_STAT1000, phydata);
+
+	mac_printf(
+		"\n****************************************************\n");
+}
+#endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mdio.h b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mdio.h
new file mode 100644
index 000000000000..3b82a22ce986
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mdio.h
@@ -0,0 +1,258 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+/* =========================================================================
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ * The Synopsys DWC ETHER XGMAC Software Driver and documentation (hereinafter
+ * "Software") is an unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto.  Permission is hereby granted,
+ * free of charge, to any person obtaining a copy of this software annotated
+ * with this license and the Software, to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================= */
+
+#ifndef __XGMAC_MDIO_H__
+#define __XGMAC_MDIO_H__
+
+#include <xgmac_common.h>
+
+#define MDIO_C_45	0
+#define MDIO_C_22	1
+
+#define MDIO_SCAR		0x200
+#define MDIO_SCCDR		0x204
+#define MDIO_CWAR		0x208
+#define MDIO_CWDR		0x20C
+#define MDIO_CSPE		0x210
+#define MDIO_ISR		0x214
+#define MDIO_IER		0x218
+#define MDIO_PSR		0x21C
+#define MDIO_C22P		0x220
+#define MDIO_DIUR(port)	(0x230 + ((port) * 0x10))
+#define MDIO_LSR(port)	(0x234 + ((port) * 0x10))
+#define MDIO_ASR(port)	(0x238 + ((port) * 0x10))
+
+#define MDIO_SCAR_DA_POS	21
+#define MDIO_SCAR_DA_WIDTH	 5
+#define MDIO_SCAR_PA_POS	16
+#define MDIO_SCAR_PA_WIDTH	 5
+#define MDIO_SCAR_RA_POS	 0
+// Clause 22 (only lower 5 bits are used)
+#define MDIO_SCAR_RA_WIDTH	16
+
+#define MDIO_SCCDR_BUSY_POS	22
+#define MDIO_SCCDR_BUSY_WIDTH	1
+#define MDIO_SCCDR_CR_POS		19
+#define MDIO_SCCDR_CR_WIDTH		3
+#define MDIO_SCCDR_SADDR_POS	18
+#define MDIO_SCCDR_SADDR_WIDTH	1
+#define MDIO_SCCDR_CMD_POS	16
+#define MDIO_SCCDR_CMD_WIDTH	2
+#define MDIO_SCCDR_SDATA_POS	0
+#define MDIO_SCCDR_SDATA_WIDTH	16
+
+#define MDIO_CWAR_CWB_POS		22
+#define MDIO_CWAR_CWB_WIDTH		1
+#define MDIO_CWAR_CPRT_POS		21
+#define MDIO_CWAR_CPRT_WIDTH		1
+#define MDIO_CWAR_CADDR_POS		16
+#define MDIO_CWAR_CADDR_WIDTH		5
+#define MDIO_CWAR_CREGADDR_POS		0
+#define MDIO_CWAR_CREGADDR_WIDTH	16
+
+#define MDIO_CWDR_CDATA_POS		0
+#define MDIO_CWDR_CDATA_WIDTH		16
+
+#define MDIO_CSPE_PORT3_POS		3
+#define MDIO_CSPE_PORT3_WIDTH		1
+#define MDIO_CSPE_PORT2_POS		2
+#define MDIO_CSPE_PORT2_WIDTH		1
+#define MDIO_CSPE_PORT1_POS		1
+#define MDIO_CSPE_PORT1_WIDTH		1
+#define MDIO_CSPE_PORT0_POS		0
+#define MDIO_CSPE_PORT0_WIDTH		1
+
+#define MDIO_ISR_CWCOMPINT_POS		13
+#define MDIO_ISR_CWCOMPINT_WIDTH	1
+#define MDIO_ISR_SNGLCOMPINT_POS	12
+#define MDIO_ISR_SNGLCOMPINT_WIDTH	1
+#define MDIO_ISR_PRT3ALINT_POS		11
+#define MDIO_ISR_PRT3ALINT_WIDTH	1
+#define MDIO_ISR_PRT2ALINT_POS		10
+#define MDIO_ISR_PRT2ALINT_WIDTH	1
+#define MDIO_ISR_PRT1ALINT_POS		9
+#define MDIO_ISR_PRT1ALINT_WIDTH	1
+#define MDIO_ISR_PRT0ALINT_POS		8
+#define MDIO_ISR_PRT0ALINT_WIDTH	1
+#define MDIO_ISR_PRT3LSINT_POS		7
+#define MDIO_ISR_PRT3LSINT_WIDTH	1
+#define MDIO_ISR_PRT2LSINT_POS		6
+#define MDIO_ISR_PRT2LSINT_WIDTH	1
+#define MDIO_ISR_PRT1LSINT_POS		5
+#define MDIO_ISR_PRT1LSINT_WIDTH	1
+#define MDIO_ISR_PRT0LSINT_POS		4
+#define MDIO_ISR_PRT0LSINT_WIDTH	1
+#define MDIO_ISR_PRT3CONINT_POS		3
+#define MDIO_ISR_PRT3CONINT_WIDTH	1
+#define MDIO_ISR_PRT2CONINT_POS		2
+#define MDIO_ISR_PRT2CONINT_WIDTH	1
+#define MDIO_ISR_PRT1CONINT_POS		1
+#define MDIO_ISR_PRT1CONINT_WIDTH	1
+#define MDIO_ISR_PRT0CONINT_POS		0
+#define MDIO_ISR_PRT0CONINT_WIDTH	1
+
+#define MDIO_IER_CWCOMPIE_POS		13
+#define MDIO_IER_CWCOMPIE_WIDTH		1
+#define MDIO_IER_SNGLCOMPIE_POS		12
+#define MDIO_IER_SNGLCOMPIE_WIDTH	1
+#define MDIO_IER_PRT3ALIE_POS		11
+#define MDIO_IER_PRT3ALIE_WIDTH		1
+#define MDIO_IER_PRT2ALIE_POS		10
+#define MDIO_IER_PRT2ALIE_WIDTH		1
+#define MDIO_IER_PRT1ALIE_POS		9
+#define MDIO_IER_PRT1ALIE_WIDTH		1
+#define MDIO_IER_PRT0ALIE_POS		8
+#define MDIO_IER_PRT0ALIE_WIDTH		1
+#define MDIO_IER_PRT3LSIE_POS		7
+#define MDIO_IER_PRT3LSIE_WIDTH		1
+#define MDIO_IER_PRT2LSIE_POS		6
+#define MDIO_IER_PRT2LSIE_WIDTH		1
+#define MDIO_IER_PRT1LSIE_POS		5
+#define MDIO_IER_PRT1LSIE_WIDTH		1
+#define MDIO_IER_PRT0LSIE_POS		4
+#define MDIO_IER_PRT0LSIE_WIDTH		1
+#define MDIO_IER_PRT3CONIE_POS		3
+#define MDIO_IER_PRT3CONIE_WIDTH	1
+#define MDIO_IER_PRT2CONIE_POS		2
+#define MDIO_IER_PRT2CONIE_WIDTH	1
+#define MDIO_IER_PRT1CONIE_POS		1
+#define MDIO_IER_PRT1CONIE_WIDTH	1
+#define MDIO_IER_PRT0CONIE_POS		0
+#define MDIO_IER_PRT0CONIE_WIDTH	1
+
+#define MDIO_PSR_PORT3CON_POS		3
+#define MDIO_PSR_PORT3CON_WIDTH		1
+#define MDIO_PSR_PORT2CON_POS		2
+#define MDIO_PSR_PORT2CON_WIDTH		1
+#define MDIO_PSR_PORT1CON_POS		1
+#define MDIO_PSR_PORT1CON_WIDTH		1
+#define MDIO_PSR_PORT0CON_POS		0
+#define MDIO_PSR_PORT0CON_WIDTH		1
+
+#define MDIO_CL22P_PORT3_POS		3
+#define MDIO_CL22P_PORT3_WIDTH		1
+#define MDIO_CL22P_PORT2_POS		2
+#define MDIO_CL22P_PORT2_WIDTH		1
+#define MDIO_CL22P_PORT1_POS		1
+#define MDIO_CL22P_PORT1_WIDTH		1
+#define MDIO_CL22P_PORT0_POS		0
+#define MDIO_CL22P_PORT0_WIDTH		1
+
+#define MDIO_DIUR_PVSD2_POS		31
+#define MDIO_DIUR_PVSD2_WIDTH		1
+#define MDIO_DIUR_PVSD1_POS		30
+#define MDIO_DIUR_PVSD1_WIDTH		1
+#define MDIO_DIUR_PTC_POS		6
+#define MDIO_DIUR_PTC_WIDTH		1
+#define MDIO_DIUR_PDTEXS_POS		5
+#define MDIO_DIUR_PDTEXS_WIDTH		1
+#define MDIO_DIUR_PPHYXS_POS		4
+#define MDIO_DIUR_PPHYXS_WIDTH		1
+#define MDIO_DIUR_PPCS_POS		3
+#define MDIO_DIUR_PPCS_WIDTH		1
+#define MDIO_DIUR_PWIS_POS		2
+#define MDIO_DIUR_PWIS_WIDTH		1
+#define MDIO_DIUR_PPMDPMA_POS		1
+#define MDIO_DIUR_PPMDPMA_WIDTH		1
+
+#define MDIO_LSR_PVSD2_POS		31
+#define MDIO_LSR_PVSD2_WIDTH		1
+#define MDIO_LSR_PVSD1_POS		30
+#define MDIO_LSR_PVSD1_WIDTH		1
+#define MDIO_LSR_PTC_POS		6
+#define MDIO_LSR_PTC_WIDTH		1
+#define MDIO_LSR_PDTEXS_POS		5
+#define MDIO_LSR_PDTEXS_WIDTH		1
+#define MDIO_LSR_PPHYXS_POS		4
+#define MDIO_LSR_PPHYXS_WIDTH		1
+#define MDIO_LSR_PPCS_POS		3
+#define MDIO_LSR_PPCS_WIDTH		1
+#define MDIO_LSR_PWIS_POS		2
+#define MDIO_LSR_PWIS_WIDTH		1
+#define MDIO_LSR_PPMDPMA_POS		1
+#define MDIO_LSR_PPMDPMA_WIDTH		1
+
+#define MDIO_ASR_PVSD2_POS		31
+#define MDIO_ASR_PVSD2_WIDTH		1
+#define MDIO_ASR_PVSD1_POS		30
+#define MDIO_ASR_PVSD1_WIDTH		1
+#define MDIO_ASR_PTC_POS		6
+#define MDIO_ASR_PTC_WIDTH		1
+#define MDIO_ASR_PDTEXS_POS		5
+#define MDIO_ASR_PDTEXS_WIDTH		1
+#define MDIO_ASR_PPHYXS_POS		4
+#define MDIO_ASR_PPHYXS_WIDTH		1
+#define MDIO_ASR_PPCS_POS		3
+#define MDIO_ASR_PPCS_WIDTH		1
+#define MDIO_ASR_PWIS_POS		2
+#define MDIO_ASR_PWIS_WIDTH		1
+#define MDIO_ASR_PPMDPMA_POS		1
+#define MDIO_ASR_PPMDPMA_WIDTH		1
+
+int xgmac_mdio_single_wr(void *pdev,
+			 u32 dev_adr,
+			 u32 phy_id,
+			 u32 phy_reg,
+			 u32 phy_reg_data);
+int xgmac_mdio_single_rd(void *pdev, u32 dev_adr, u32 phy_id,
+			 u32 phy_reg, u32 *phy_reg_data);
+int mdio_set_clause(void *pdev, u32 clause, u32 phy_id);
+int mdio_get_clause(void *pdev,  u32 phy_id);
+int mdio_set_interrupt(void *pdev, u32 val);
+int xgmac_mdio_get_int_sts(void *pdev);
+void print_mdio_rd_cnt(void *pdev,
+		       u32 dev_adr,
+		       u32 phy_id,
+		       u32 phy_reg_st,
+		       u32 phy_reg_end);
+void xgmac_print_mdio(void *pdev,
+		      u32 op,
+		      u32 dev_adr,
+		      u32 phy_id,
+		      u32 phy_reg,
+		      u32 phy_reg_data);
+
+#ifdef __KERNEL__
+int xgmac_mdio_register(void *pdev);
+void xgmac_mdio_unregister(void *pdev);
+#endif
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mtl_api.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mtl_api.c
new file mode 100644
index 000000000000..4de14cd268ee
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mtl_api.c
@@ -0,0 +1,584 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+/* =========================================================================
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ * The Synopsys DWC ETHER XGMAC Software Driver and documentation (hereinafter
+ * "Software") is an unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto.  Permission is hereby granted,
+ * free of charge, to any person obtaining a copy of this software annotated
+ * with this license and the Software, to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================= */
+
+
+#include <xgmac.h>
+
+/*  RSF: Receive Q store and forward
+ *  if 1, XGMAC reads packet from Rx Q after the complete packet has been
+ *  written
+ *  if 0, Rx Queue operates in threshold mode,
+ *  The received packet is transferred to the application when the
+ *  packet size within the MTL Rx queue is larger than the threshold
+ */
+int xgmac_set_mtl_rx_mode(void *pdev, u32 rx_mode)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val = XGMAC_RGRD(pdata, MTL_Q_RQOMR);
+
+	if (MAC_GET_VAL(reg_val, MTL_Q_RQOMR, RSF) != rx_mode) {
+		mac_printf("XGMAC %d: Setting MTL RX mode to: %s\n",
+			   pdata->mac_idx,
+			   rx_mode ? "Store and Forward" : "Threshold");
+		MAC_SET_VAL(reg_val, MTL_Q_RQOMR, RSF, rx_mode);
+		XGMAC_RGWR(pdata, MTL_Q_RQOMR, reg_val);
+	}
+
+	return 0;
+}
+
+int xgmac_set_mtl_rx_thresh(void *pdev, u32 rx_thresh)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val = XGMAC_RGRD(pdata, MTL_Q_RQOMR);
+
+	if (MAC_GET_VAL(reg_val, MTL_Q_RQOMR, RTC) != rx_thresh) {
+		mac_printf("XGMAC %d: Setting MTL RX threshold to: %d\n",
+			   pdata->mac_idx,  rx_thresh);
+		MAC_SET_VAL(reg_val, MTL_Q_RQOMR, RTC, rx_thresh);
+		XGMAC_RGWR(pdata, MTL_Q_RQOMR, reg_val);
+	}
+
+	return 0;
+}
+
+/*  TSF: Transmit Q Store and Forward
+ *  if 1, the transmission starts when a full packet resides in the MTL Tx queue
+ *  When this bit is set, the TX threshold value specified in the register are
+ *  ignored.
+ *  if 0, Tx Queue operates in threshold mode,
+ *  This bit should be changed only when the transmission is stopped.
+ */
+int xgmac_set_mtl_tx_mode(void *pdev, u32 tx_mode)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val = XGMAC_RGRD(pdata, MTL_Q_TQOMR);
+
+	if (MAC_GET_VAL(reg_val, MTL_Q_TQOMR, TSF) != tx_mode) {
+		mac_printf("XGMAC %d: Setting MTL TX mode to: %s\n",
+			   pdata->mac_idx,
+			   tx_mode ? "Store and Forward" : "Threshold");
+		MAC_SET_VAL(reg_val, MTL_Q_TQOMR, TSF, tx_mode);
+		XGMAC_RGWR(pdata, MTL_Q_TQOMR, reg_val);
+	}
+
+	return 0;
+}
+
+int xgmac_set_mtl_tx_thresh(void *pdev, u32 tx_thresh)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val = XGMAC_RGRD(pdata, MTL_Q_TQOMR);
+
+	if (MAC_GET_VAL(reg_val, MTL_Q_TQOMR, TTC) != tx_thresh) {
+		mac_printf("XGMAC %d: Setting MTL TX threshold to: %d\n",
+			   pdata->mac_idx,  tx_thresh);
+		MAC_SET_VAL(reg_val, MTL_Q_TQOMR, TTC, tx_thresh);
+		XGMAC_RGWR(pdata, MTL_Q_TQOMR, reg_val);
+	}
+
+	return 0;
+}
+
+/* Clear all the MTL Q interrupts */
+int xgmac_clear_mtl_int(void *pdev, u32 event)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mtl_q_isr = XGMAC_RGRD(pdata, MTL_Q_ISR);
+
+	if ((event & XGMAC_TXQ_OVFW_EVNT) &&
+	    (MAC_GET_VAL(mtl_q_isr, MTL_Q_ISR, TXUNFIS))) {
+		mac_printf("XGMAC: %d Clearing MTL Q TXUNFIS"
+			   "Interrupt Status\n", pdata->mac_idx);
+		MAC_SET_VAL(mtl_q_isr, MTL_Q_ISR, TXUNFIS, 1);
+	}
+
+	if ((event & XGMAC_RXQ_OVFW_EVNT) &&
+	    (MAC_GET_VAL(mtl_q_isr, MTL_Q_ISR, ABPSIS))) {
+		mac_printf("XGMAC: %d Clearing MTL Q ABPSIS"
+			   "Interrupt Status\n", pdata->mac_idx);
+		MAC_SET_VAL(mtl_q_isr, MTL_Q_ISR, ABPSIS, 1);
+	}
+
+	if ((event & XGMAC_AVG_BPS_EVNT) &&
+	    (MAC_GET_VAL(mtl_q_isr, MTL_Q_ISR, RXOVFIS))) {
+		mac_printf("XGMAC: %d Clearing MTL Q RXOVFIS"
+			   "Interrupt Status\n", pdata->mac_idx);
+		MAC_SET_VAL(mtl_q_isr, MTL_Q_ISR, RXOVFIS, 1);
+	}
+
+	XGMAC_RGWR(pdata, MTL_Q_ISR, mtl_q_isr);
+
+	return 0;
+}
+
+/* Enable and disable all the MTL Q interrupts */
+int xgmac_set_mtl_int(void *pdev, u32 val)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mtl_q_isr;
+
+	mtl_q_isr = XGMAC_RGRD(pdata, MTL_Q_IER);
+
+	/* Tx Q Overflow Interrupt Enable */
+	if (val & MASK(MTL_Q_IER, TXUIE))
+		MAC_SET_VAL(mtl_q_isr, MTL_Q_IER, TXUIE, val);
+
+	/* Average bits per slot interrupt enable */
+	if (val & MASK(MTL_Q_IER, ABPSIE))
+		MAC_SET_VAL(mtl_q_isr, MTL_Q_IER, ABPSIE, val);
+
+	/* Rx Q Overflow Interrupt Enable */
+	if (val & MASK(MTL_Q_IER, RXOIE))
+		MAC_SET_VAL(mtl_q_isr, MTL_Q_IER, RXOIE, val);
+
+	XGMAC_RGWR(pdata, MTL_Q_IER, mtl_q_isr);
+	return 0;
+}
+
+/* SNPVER: Synopsys-defined Version
+ * FTQ:
+ *	if 1, the Tx Queue Controller logic is reset to its default values.
+ *	Therefore,  all the data in the Tx queue is lost or flushed.
+ *	This bit is internally reset when the flushing operation is complete.
+ *	You should not write to this register until this bit is reset.
+ *	The data which is already accepted by the MAC transmitter is not
+ *	flushed. It is scheduled for transmission and results in underflow
+ *	and runt packet transmission.
+ *	Note: The flush operation is complete only when the Tx queue is empty.
+ *	To complete this flush operation, the PHY Tx clock must be active.
+ */
+
+int xgmac_flush_tx_queues(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	mac_printf("XGMAC %d: Flushing TX Q\n", pdata->mac_idx);
+
+	XGMAC_RGWR_BITS(pdata, MTL_Q_TQOMR, FTQ, 1);
+
+	while (1) {
+		if (XGMAC_RGRD_BITS(pdata, MTL_Q_TQOMR, FTQ) == 0)
+			break;
+	}
+
+	return 0;
+}
+
+/*RQS: Receive Queue Size
+ *RFA:
+ *	Threshold for activating Flow Control
+ *	These bits control the threshold (fill-level of RxQ0) at which the flow
+ *	control is activated
+ *	The flow control is triggered when EHFC=1 and RQS >= 4KB
+ *RFD:
+ *	Threshold for deactivating Flow Control
+ *	These bits control the threshold (fill-level of RxQ0) at which the flow
+ *	control is de-asserted once it is activated.
+ */
+int xgmac_set_flow_control_threshold(void *pdev, u32 rfa, u32 rfd)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val = XGMAC_RGRD(pdata, MTL_Q_RQFCR);
+
+	/* Activate flow control when less than 4k left in fifo */
+	if (MAC_GET_VAL(reg_val, MTL_Q_RQFCR, RFA) != rfa) {
+		mac_printf("XGMAC %d: Set Thresh for activate Flow Ctrl %d\n",
+			   pdata->mac_idx, rfa);
+		MAC_SET_VAL(reg_val, MTL_Q_RQFCR, RFA, rfa);
+	}
+
+	/* De-activate flow control when more than 6k left in fifo */
+	if (MAC_GET_VAL(reg_val, MTL_Q_RQFCR, RFD) != rfd) {
+		mac_printf("XGMAC %d: Set Thresh for deact Flow Ctrl as %d\n",
+			   pdata->mac_idx, rfd);
+		MAC_SET_VAL(reg_val, MTL_Q_RQFCR, RFD, rfd);
+	}
+
+	XGMAC_RGWR(pdata, MTL_Q_RQFCR, reg_val);
+
+	return 0;
+}
+
+/* MMC_Control
+ * The MMC Control register establishes the operating mode of the management
+ * counters
+ * ROR:
+ * When this bit is set, the MMC counters are reset to zero after a read. The
+ * counters are cleared when the least significant byte lane (bits[7:0]) is read
+ * When the MMC module is enabled for the 64-bit counter mode, the lower and
+ * upper counters are cleared only when the least significant byte lane
+ * (bits[7:0]) of the corresponding counter is read.
+ * CR:
+ * Counters Reset
+ * When this bit is set, all counters are reset.
+ * This bit is cleared automatically after 1 clock cycle.
+ */
+int xgmac_set_mmc(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val = XGMAC_RGRD(pdata, MMC_CR);
+
+	/* Set counters to reset on read */
+	if (MAC_GET_VAL(reg_val, MMC_CR, ROR) != 0) {
+		mac_printf("XGMAC %d: reset on read %s\n",
+			   pdata->mac_idx, "DISABLED");
+		MAC_SET_VAL(reg_val, MMC_CR, ROR, 0);
+		XGMAC_RGWR(pdata, MMC_CR, reg_val);
+	}
+
+	return 0;
+}
+
+int xgmac_clear_rmon(void *pdev, u32 rmon_reset)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	/* Reset the counters */
+	if (rmon_reset) {
+		mac_printf("XGMAC %d: Resetting the counters\n",
+			   pdata->mac_idx);
+		XGMAC_RGWR_BITS(pdata, MMC_CR, CR, 1);
+		memset(&prv_data[pdata->mac_idx].mmc_stats, 0,
+		       sizeof(struct xgmac_mmc_stats));
+
+		while (1) {
+			if (XGMAC_RGRD_BITS(pdata, MMC_CR, CR) == 0)
+				break;
+		}
+	}
+
+	return 0;
+}
+
+/* GB - Good Bad frames
+ * G  - Good frames
+ */
+#if defined(CHIPTEST) && CHIPTEST
+u32 xgmac_mmc_read(void *pdev, u32 reg_lo)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u32 val_lo = 0, val_hi = 0;
+	u32 val = 0;
+
+	val_lo = XGMAC_RGRD(pdata, reg_lo);
+	val_hi = XGMAC_RGRD(pdata, reg_lo + 4);
+
+	val = ((u64)val_hi << 32) | val_lo;
+
+	return val;
+}
+#else
+u64 xgmac_mmc_read(void *pdev, u32 reg_lo)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 val_lo, val_hi;
+	u64 val;
+
+	val_lo = XGMAC_RGRD(pdata, reg_lo);
+	val_hi = XGMAC_RGRD(pdata, reg_lo + 4);
+
+	val = ((u64)val_hi << 32) | val_lo;
+
+	return val;
+}
+#endif
+
+int xgmac_read_mmc_stats(void *pdev, struct xgmac_mmc_stats *stats)
+{
+	stats->txoctetcount_gb =
+		xgmac_mmc_read(pdev, MMC_TXOCTETCOUNT_GB_LO);
+
+	stats->txframecount_gb =
+		xgmac_mmc_read(pdev, MMC_TXFRAMECOUNT_GB_LO);
+
+	stats->txunderflowerror =
+		xgmac_mmc_read(pdev, MMC_TXUNDERFLOWERROR_LO);
+
+	stats->txoctetcount_g =
+		xgmac_mmc_read(pdev, MMC_TXOCTETCOUNT_G_LO);
+
+	stats->txframecount_g =
+		xgmac_mmc_read(pdev, MMC_TXFRAMECOUNT_G_LO);
+
+	stats->txpauseframes =
+		xgmac_mmc_read(pdev, MMC_TXPAUSEFRAMES_LO);
+
+	stats->rxframecount_gb =
+		xgmac_mmc_read(pdev, MMC_RXFRAMECOUNT_GB_LO);
+
+	stats->rxoctetcount_gb =
+		xgmac_mmc_read(pdev, MMC_RXOCTETCOUNT_GB_LO);
+
+	stats->rxoctetcount_g =
+		xgmac_mmc_read(pdev, MMC_RXOCTETCOUNT_G_LO);
+
+	stats->rxcrcerror =
+		xgmac_mmc_read(pdev, MMC_RXCRCERROR_LO);
+
+	stats->rxpauseframes =
+		xgmac_mmc_read(pdev, MMC_RXPAUSEFRAMES_LO);
+
+	stats->rxfifooverflow =
+		xgmac_mmc_read(pdev, MMC_RXFIFOOVERFLOW_LO);
+
+	return 0;
+}
+
+/* DBGMOD: Debug Mode Access to FIFO
+ *	if 1, it indicates that the current access to the FIFO is
+ *	debug access. Data transfers from Tx FIFO to MAC Transmitter and
+ *	from MAC Receiver to Rx FIFO is disabled. In this mode, the
+ *following access types are allowed:
+ *	Direct Read and Write access to all locations of Tx FIFO,
+ *	Descriptor Cache and Rx FIFO memories.
+ *FDBGEN: FIFO Debug Access Enable
+ * if 1, it indicates that the debug/slave mode access to the FIFO is enabled.
+ * if 0, it indicates that the FIFO can be accessed only through a master
+ * interface (ATI, ARI, DMA).
+ *PKTSTATE: Write Control Type
+ *	This field is used to decide the tag bits along with the data being
+ *	written into the FIFO.
+ *	When the TxFIFO is written in Slave mode or Debug mode, this field
+ *	marks the type of data written as follows:
+ *	00 Packet Data
+ *	01 Control Word
+ *	10 SOP Data
+ *	11 EOP Data
+ *	When the Rx FIFO is being written in slave mode, this field marks the
+ *	type of data written as follows:
+ *	00 Packet Data
+ *	01 Normal Status
+ *	10 Last Status
+ *	11 EOP
+ *FIFOSEL: FIFO Selected for Access
+ *	This field indicates the FIFO selected for debug access:
+ *	00 Tx FIFO
+ *	01 Descriptor cache (only when DBGMOD=1)
+ *	10 TSO FIFO (only when DBGMOD = 1)
+ *	11 Rx FIFO
+ *BYTEEN: Write Data Byte Enable
+ *	This field indicates the number of data bytes valid in the data register
+ *	during Write operation. This is valid only when PKTSTATE is 2'b11
+ *	(EOP) and Tx FIFO or Rx FIFO is selected.
+ *	00 Byte 0 valid
+ *	01 Byte 0 and Byte 1 are valid
+ *	10 Byte 0, Byte 1, and Byte 2 are valid
+ *	11 All four bytes are valid
+ *FIFOWREN: FIFO Write Enable
+ *		if 1, it enables the Write operation on selected FIFO.
+ *FIFORDEN: FIFO Read Enable
+ *		if 1, it enables the Read operation on selected FIFO.
+ *PKTIE:  Receive Packet Available Interrupt Status Enable
+ *		if 1, an interrupt is generated when EOP of received
+ *		packet is written by the MAC to the Rx FIFO.
+ *RSTSEL: Reset Pointers of Selected FIFO
+ *		if 1, the pointers of the currently-selected FIFO are
+ *		reset.
+ *RSTALL: Reset All Pointers
+ *		if 1, the pointers of all FIFOs are reset.
+ */
+
+int xgmac_set_debug_ctl(void *pdev, u32 dbg_en, u32 dbg_mode)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 dbg_ctl = XGMAC_RGRD(pdata, MTL_DBG_CTL);
+
+	u32 enable = dbg_en ? 1 : 0;
+	u32 mode = dbg_mode ? 1 : 0;
+
+	if (enable) {
+		if (mode) {	/* Debug Mode */
+			MAC_SET_VAL(dbg_ctl, MTL_DBG_CTL, FDBGEN, enable);
+			MAC_SET_VAL(dbg_ctl, MTL_DBG_CTL, DBGMOD, enable);
+		} else {	/* Slave Mode */
+			MAC_SET_VAL(dbg_ctl, MTL_DBG_CTL, FDBGEN, enable);
+			MAC_SET_VAL(dbg_ctl, MTL_DBG_CTL, DBGMOD, 0);
+		}
+	} else {
+		MAC_SET_VAL(dbg_ctl, MTL_DBG_CTL, FDBGEN, 0);
+		MAC_SET_VAL(dbg_ctl, MTL_DBG_CTL, DBGMOD, 0);
+	}
+
+	XGMAC_RGWR(pdata, MTL_DBG_CTL, dbg_ctl);
+	return 0;
+}
+
+int xgmac_set_debug_data(void *pdev, u32 dbg_data)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	XGMAC_RGWR(pdata, MTL_DBG_DAT, dbg_data);
+	return 0;
+}
+
+int xgmac_tx_debug_data(void *pdev, u32 dbg_pktstate)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 dbg_ctl = XGMAC_RGRD(pdata, MTL_DBG_CTL);
+
+	MAC_SET_VAL(dbg_ctl, MTL_DBG_CTL, PKTSTATE, dbg_pktstate);
+
+	/* Set Fifo Sel to TX FIFO */
+	MAC_SET_VAL(dbg_ctl, MTL_DBG_CTL, FIFOSEL, 0);
+	/* Enables write on TX FIFO */
+	MAC_SET_VAL(dbg_ctl, MTL_DBG_CTL, FIFOWREN, 1);
+
+	if (dbg_pktstate == TX_EOP_DATA)
+		MAC_SET_VAL(dbg_ctl, MTL_DBG_CTL, BYTEEN, 3);
+
+	XGMAC_RGWR(pdata, MTL_DBG_CTL, dbg_ctl);
+
+	return 0;
+}
+
+int xgmac_rx_debug_data(void *pdev, u32 *dbg_pktstate, u32 *dbg_byteen)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 dbg_ctl = XGMAC_RGRD(pdata, MTL_DBG_CTL);
+
+	/* Set Fifo Sel to RX FIFO */
+	MAC_SET_VAL(dbg_ctl, MTL_DBG_CTL, FIFOSEL, 3);
+	/* Enables write on RX FIFO */
+	MAC_SET_VAL(dbg_ctl, MTL_DBG_CTL, FIFORDEN, 1);
+
+	XGMAC_RGWR(pdata, MTL_DBG_CTL, dbg_ctl);
+
+	while (XGMAC_RGRD_BITS(pdata, MTL_DBG_STS, FIFOBUSY) == 1);
+
+	dbg_ctl = XGMAC_RGRD(pdata, MTL_DBG_CTL);
+
+	*dbg_pktstate = MAC_GET_VAL(dbg_ctl, MTL_DBG_CTL, PKTSTATE);
+
+	if (*dbg_pktstate == RX_EOP_DATA)
+		*dbg_byteen = XGMAC_RGRD_BITS(pdata, MTL_DBG_STS, BYTEEN);
+
+	return 0;
+}
+
+int xgmac_set_rx_debugctrl_int(void *pdev, u32 dbg_pktie)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	XGMAC_RGWR_BITS(pdata, MTL_DBG_CTL, PKTIE, dbg_pktie);
+	return 0;
+}
+
+int xgmac_set_fifo_reset(void *pdev, u32 dbg_rst_sel, u32 dbg_rst_all)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 dbg_ctl = XGMAC_RGRD(pdata, MTL_DBG_CTL);
+
+	MAC_SET_VAL(dbg_ctl, MTL_DBG_CTL, RSTSEL, dbg_rst_sel);
+	MAC_SET_VAL(dbg_ctl, MTL_DBG_CTL, RSTALL, dbg_rst_all);
+
+	XGMAC_RGWR(pdata, MTL_DBG_CTL, dbg_ctl);
+	return 0;
+}
+
+int xgmac_poll_fifo_sts(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	while (1) {
+		if (XGMAC_RGRD_BITS(pdata, MTL_DBG_STS, FIFOBUSY) == 0)
+			break;
+	}
+
+	return 0;
+}
+
+int xgmac_poll_pkt_rx(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	while (1) {
+		if (XGMAC_RGRD_BITS(pdata, MTL_DBG_STS, PKTI) == 1)
+			break;
+	}
+
+	return 0;
+}
+
+int xgmac_clr_debug_sts(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	/* Clear the debug interrupt status */
+	XGMAC_RGWR_BITS(pdata, MTL_DBG_STS, PKTI, 1);
+
+	return 0;
+}
+
+/* FEF: Forward Error Packets
+ *	if 0, the Rx queue drops packets with error status (CRC
+ *	error, GMII_ER, watchdog timeout, or overflow).
+ *	if 1, all packets except the runt error packets are
+ *	forwarded to the application or DMA.
+ * FUP: Forward Undersized Good Packets
+ *	if 1, the Rx queue forwards the undersized good packets
+ *	(with no error and length less than 64 bytes), including pad-bytes and
+ *	CRC. if 0, the Rx queue drops all packets of less than 64 bytes.
+ */
+
+int xgmac_forward_fup_fep_pkt(void *pdev, u32 fup, u32 fef)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 reg_val = XGMAC_RGRD(pdata, MTL_Q_RQOMR);
+
+	if (MAC_GET_VAL(reg_val, MTL_Q_RQOMR, FUP) != fup) {
+		mac_printf("XGMAC %d: Set Forward Undersized Good Packets\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(reg_val, MTL_Q_RQOMR, FUP, fup);
+	}
+
+	if (MAC_GET_VAL(reg_val, MTL_Q_RQOMR, FEF) != fef) {
+		mac_printf("XGMAC %d: Set Forward Error Packets\n",
+			   pdata->mac_idx);
+		MAC_SET_VAL(reg_val, MTL_Q_RQOMR, FEF, fef);
+	}
+
+	XGMAC_RGWR(pdata, MTL_Q_RQOMR, reg_val);
+
+	return 0;
+}
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c
new file mode 100644
index 000000000000..85b167cb39a9
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c
@@ -0,0 +1,665 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+/* =========================================================================
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ * The Synopsys DWC ETHER XGMAC Software Driver and documentation (hereinafter
+ * "Software") is an unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto.  Permission is hereby granted,
+ * free of charge, to any person obtaining a copy of this software annotated
+ * with this license and the Software, to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================= */
+
+
+#include <xgmac.h>
+#include <xgmac_ptp.h>
+
+static int xgmac_adj_freq(struct ptp_clock_info *ptp, s32 ppb);
+static int xgmac_adj_time(struct ptp_clock_info *ptp, s64 delta);
+static int xgmac_get_time(struct ptp_clock_info *ptp,
+			  struct timespec64 *ts);
+static int xgmac_set_time(struct ptp_clock_info *ptp,
+			  const struct timespec64 *ts);
+static void *parse_ptp_packet(struct sk_buff *skb, u16 *eth_type);
+static int xgmac_check_tx_tstamp(void *pdev, struct sk_buff *skb);
+static void xgmac_get_rx_tstamp(void *pdev, struct sk_buff *skb);
+static int xgmac_ptp_register(void *pdev);
+
+// TODO: Get the ptp clock in Hz from device tree
+void xgmac_config_timer_reg(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	struct timespec now;
+	struct mac_ops *hw_if = &pdata->ops;
+	u64 temp;
+
+	/* program Sub Second Increment Reg */
+	hw_if->config_subsec_inc(pdata, pdata->ptp_clk);
+
+	/* Calculate the def addend:
+	 * addend = 2^32 / (PTP ref clock / 50Mhz)
+	 *        = (2^32 * 50Mhz) / PTP ref clock
+	 */
+	temp = ((u64)(MHZ_TO_HZ(50)) << 32);
+	pdata->def_addend = div_u64(temp, pdata->ptp_clk);
+
+	hw_if->config_addend(pdev, pdata->def_addend);
+
+	/* initialize system time */
+	getnstimeofday(&now);
+	hw_if->init_systime(pdev, now.tv_sec, now.tv_nsec);
+}
+
+/* API to adjust the frequency of hardware clock.
+ * delta - desired period change.
+ */
+static int xgmac_adj_freq(struct ptp_clock_info *ptp, s32 ppb)
+{
+	struct mac_prv_data *pdata =
+		container_of(ptp, struct mac_prv_data, ptp_clk_info);
+	struct mac_ops *hw_if = &pdata->ops;
+
+	u64 adj;
+	u32 diff, addend;
+	int neg_adj = 0;
+
+	pr_info("Calling adjust_freq: %d\n", ppb);
+
+	if (ppb < 0) {
+		neg_adj = 1;
+		ppb = -ppb;
+	}
+
+	addend = pdata->def_addend;
+	adj = addend;
+	adj *= ppb;
+	/* div_u64 will divided the "adj" by "NSEC_TO_SEC"
+	 * and return the quotient.
+	 */
+	diff = div_u64(adj, NSEC_TO_SEC);
+	addend = neg_adj ? (addend - diff) : (addend + diff);
+
+	spin_lock_bh(&pdata->ptp_lock);
+
+	hw_if->config_addend(pdata, addend);
+
+	spin_unlock_bh(&pdata->ptp_lock);
+
+	return 0;
+}
+
+/* This function is used to shift/adjust the time of the
+ * hardware clock.
+ * delta - desired change in nanoseconds.
+ */
+static int xgmac_adj_time(struct ptp_clock_info *ptp, s64 delta)
+{
+	struct mac_prv_data *pdata =
+		container_of(ptp, struct mac_prv_data, ptp_clk_info);
+	struct mac_ops *hw_if = &pdata->ops;
+
+	u32 sec, nsec;
+	u32 quotient, reminder;
+	int neg_adj = 0;
+
+	pr_info("Calling adjust_time: %lld\n", delta);
+
+	if (delta < 0) {
+		neg_adj = 1;
+		delta = -delta;
+	}
+
+	quotient = div_u64_rem(delta, NSEC_TO_SEC, &reminder);
+	sec = quotient;
+	nsec = reminder;
+
+	spin_lock_bh(&pdata->ptp_lock);
+
+	hw_if->adjust_systime(pdata, sec, nsec, neg_adj,
+			      pdata->one_nsec_accuracy);
+
+	spin_unlock_bh(&pdata->ptp_lock);
+
+	return 0;
+}
+
+/* This function is used to read the current time from the
+ * hardware clock.
+ */
+static int xgmac_get_time(struct ptp_clock_info *ptp,
+			  struct timespec64 *ts)
+{
+	struct mac_prv_data *pdata =
+		container_of(ptp, struct mac_prv_data, ptp_clk_info);
+	struct mac_ops *hw_if = &pdata->ops;
+	u64 ns;
+	u32 reminder;
+
+
+	spin_lock_bh(&pdata->ptp_lock);
+
+	ns = hw_if->get_systime(pdata);
+
+	spin_unlock_bh(&pdata->ptp_lock);
+
+	ts->tv_sec = div_u64_rem(ns, NSEC_TO_SEC, &reminder);
+	ts->tv_nsec = reminder;
+
+	pr_info("get_time: ts->tv_sec  = %ld,ts->tv_nsec = %ld\n",
+		(long int)ts->tv_sec, (long int)ts->tv_nsec);
+
+	return 0;
+}
+
+/* This function is used to set the current time on the
+ * hardware clock.
+ */
+static int xgmac_set_time(struct ptp_clock_info *ptp,
+			  const struct timespec64 *ts)
+{
+	struct mac_prv_data *pdata =
+		container_of(ptp, struct mac_prv_data, ptp_clk_info);
+	struct mac_ops *hw_if = &pdata->ops;
+
+
+	pr_info("set_time: ts->tv_sec  = %lld, ts->tv_nsec = %lld\n",
+		(u64)ts->tv_sec, (u64)ts->tv_nsec);
+
+	spin_lock_bh(&pdata->ptp_lock);
+
+	hw_if->init_systime(pdata, ts->tv_sec, ts->tv_nsec);
+
+	spin_unlock_bh(&pdata->ptp_lock);
+
+	return 0;
+}
+
+/*  Parse PTP packet to find out whether flag is 1 step or 2 step.
+ *  The PTP header can be found in an IPv4, IPv6 or in an IEEE802.3
+ *  ethernet frame. The function returns the position of the PTP packet
+ *  or NULL, if no PTP found.
+ */
+static void *parse_ptp_packet(struct sk_buff *skb, u16 *eth_type)
+{
+	struct iphdr *iph;
+	struct udphdr *udph;
+	struct ipv6hdr *ipv6h;
+	void *pos = skb->data + ETH_ALEN + ETH_ALEN;
+	u8 *ptp_loc = NULL;
+	u8 msg_type;
+
+	*eth_type = *((u16 *)pos);
+
+	/* Check if any VLAN tag is there */
+	while (1) {
+		if (*eth_type == ETH_P_8021Q) {
+			pos += 4;
+			*eth_type = *((u16 *)pos);
+		} else {
+			break;
+		}
+	}
+
+	/* set pos after ethertype */
+	pos += 2;
+
+	switch (*eth_type) {
+	/* Transport of PTP over Ethernet */
+	case ETH_P_1588:
+		ptp_loc = pos;
+
+		msg_type = *((u8 *)(ptp_loc + PTP_OFFS_MSG_TYPE)) & 0xf;
+
+		if ((msg_type == PTP_MSGTYPE_SYNC) ||
+		    (msg_type == PTP_MSGTYPE_DELREQ) ||
+		    (msg_type == PTP_MSGTYPE_PDELREQ) ||
+		    (msg_type == PTP_MSGTYPE_PDELRESP)) {
+			pr_info("Transport of PTP over Ethernet header\n");
+			ptp_loc = pos;
+		} else {
+			pr_info("Error: Transport of PTP over Ethernet header\n");
+			ptp_loc = NULL;
+		}
+
+		break;
+
+	/* Transport of PTP over IPv4 */
+	case ETH_P_IP:
+		iph = (struct iphdr *)pos;
+
+		if (ntohs(iph->protocol) != IPPROTO_UDP)
+			ptp_loc = NULL;
+
+		pos += iph->ihl * 4;
+		udph = (struct udphdr *)pos;
+
+		/* check the destination port address
+		 * ( 319 (0x013F) = PTP event port )
+		 */
+		if (ntohs(udph->dest) != 319) {
+			pr_info(" Transport of PTP over IPv4 Error\n");
+			ptp_loc = NULL;
+		} else {
+			pr_info("Transport of PTP over IPv4 header\n");
+			ptp_loc = pos + sizeof(struct udphdr);
+		}
+
+		break;
+
+	/* Transport of PTP over IPv6 */
+	case ETH_P_IPV6:
+		ipv6h = (struct ipv6hdr *)pos;
+
+		if (ntohs(ipv6h->nexthdr) != IPPROTO_UDP)
+			ptp_loc = NULL;
+
+		pos += sizeof(struct ipv6hdr);
+		udph = (struct udphdr *)pos;
+
+		/* check the destination port address
+		 * ( 319 (0x013F) = PTP event port )
+		 */
+		if (ntohs(udph->dest) != 319) {
+			pr_info(" Transport of PTP over IPv6 Error\n");
+			ptp_loc = NULL;
+		} else {
+			pr_info("Transport of PTP over IPv6 header\n");
+			ptp_loc = pos + sizeof(struct udphdr);
+		}
+
+		break;
+
+	default:
+		ptp_loc = NULL;
+		break;
+	}
+
+	if (!ptp_loc)
+		pr_info("PTP header is not found in the packet, Please check\n");
+
+	return ptp_loc;
+}
+
+/* =========================== TX TIMESTAMP =========================== */
+
+/*  This API will be called by Datapath library when transmitting a packet to HW
+ *  ptpd sends down 1-Step/2-Step sync packet on the event socket (i.e, one
+ *  for which SO_TIMESTAMPING socket option is set).
+ *  Network stack sets the SKBTX_HW_TSTAMP in skb since socket is
+ *  marked for SO_TIMESTAMPING.
+ */
+/*  TODO: From Pmac Header OneStep bit indicates oneStep or TwoStep
+ *  If 2 step use record id to enable TTSE/OSTC/OSTC_AVAIL
+ *  to store the transmit timestamp
+ */
+int xgmac_tx_hwts(void *pdev, struct sk_buff *skb)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	int ret = 0;
+
+	/* check for hw tstamping */
+	if (pdata->hw_feat.ts_src && pdata->ptp_flgs.ptp_tx_en) {
+		if ((skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&
+		    !(pdata->ptp_tx_skb)) {
+			/* Check 1-step or 2-step tstamp */
+			if (xgmac_check_tx_tstamp(pdata, skb) < 0)
+				return ret;
+
+			/* declare that device is doing timestamping */
+			skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+			pdata->ptp_tx_skb = skb_get(skb);
+			pr_info("Got PTP pkt to transmit\n");
+		}
+	}
+
+	return ret;
+}
+
+/*  This API will determine whether the TX packet need to do 1 Step or 2 Step
+ *  For one-step clock, the value of TWO_STEP shall be FALSE.
+ *  For two-step clock, the value of TWO_STEP shall be TRUE.
+ */
+static int xgmac_check_tx_tstamp(void *pdev, struct sk_buff *skb)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	u16 flags;
+	u16 ethtype;
+	u8 *ptp_loc;
+
+	/* Extract the packet Sync or Delay Resp Flags Field
+	 *  Parsing here will not cause performance drop since only
+	 *  SKBTX_HW_TSTAMP flagged packet will be parsed
+	 */
+
+	ptp_loc = parse_ptp_packet(skb, &ethtype);
+
+	if (!ptp_loc)
+		return -1;
+
+	flags =  *((u16 *)(ptp_loc + PTP_OFFS_FLAGS)) & 0xFFFF;
+
+	/* Check the TWO_STEP bit in the flag, Bit 1 in Flags is the 2 step flag
+	 */
+	if ((flags >> 8) & 0x02) {
+		/* 2 Step timestamp flag enabled */
+		pdata->two_step = 1;
+
+		if (pdata->ptp_tx_init == 0) {
+			INIT_WORK(&pdata->ptp_tx_work,
+				  (work_func_t)xgmac_ptp_tx_work);
+			pdata->ptp_tx_init = 1;
+		}
+	} else {
+		/* 1 Step timestamp flag enabled */
+		pdata->two_step = 0;
+
+		if (pdata->ptp_tx_init) {
+			cancel_work_sync(&pdata->ptp_tx_work);
+			pdata->ptp_tx_init = 0;
+		}
+	}
+
+	return 0;
+}
+
+/*  This API will get executed by workqueue only for 2 step timestamp
+ *  Get the TX'ted Timestamp and pass it to upper app
+ *  and free the skb
+ */
+int xgmac_ptp_tx_work(struct work_struct *work)
+{
+	struct mac_prv_data *pdata =
+		container_of(work, struct mac_prv_data, ptp_tx_work);
+	u64 tstamp;
+	struct skb_shared_hwtstamps shhwtstamp;
+
+	if (!pdata->ptp_tx_skb) {
+		pr_info("No PTP packet transferred out from device\n");
+		return -1;
+	}
+
+	/* check tx tstamp status, if have, read the timestamp and sent to
+	 * stack, otherwise reschedule later
+	 */
+	tstamp = pdata->ops.get_tx_tstamp(pdata);
+
+	if (!tstamp) {
+		pr_info("Tx tstamp is not captured or ignored for this pkt\n");
+		goto schedule_later;
+	}
+
+	memset(&shhwtstamp, 0, sizeof(struct skb_shared_hwtstamps));
+	shhwtstamp.hwtstamp = ns_to_ktime(tstamp);
+
+	/* pass tstamp from HW to network stack fr 2 step */
+	skb_tstamp_tx(pdata->ptp_tx_skb, &shhwtstamp);
+
+	pr_info("Tx timestamp to stack\n");
+
+	/* skb_tstamp_tx() clones the original skb and
+	 * adds the timestamps, therefore the original skb
+	 * has to be freed now and return.
+	 */
+
+	if (tstamp) {
+		dev_kfree_skb_any(pdata->ptp_tx_skb);
+		pdata->ptp_tx_skb = NULL;
+		return 0;
+	}
+
+schedule_later:
+
+	/* If One step timestamp no need to schedule work */
+	if (pdata->two_step == 1) {
+		/* reschedule to check later */
+		schedule_work(&pdata->ptp_tx_work);
+	}
+
+	return 1;
+}
+
+/* =========================== RX TIMESTAMP =========================== */
+/* This API will be called by Datapath library before calling netif_rx()
+ */
+int xgmac_rx_hwts(void *pdev, struct sk_buff *skb)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	/* No Rx packet will have timestamp added to it */
+	if (pdata->ptp_flgs.ptp_rx_en == 0)
+		return -1;
+
+	/* All packets have timestamp appended to it, retrieve all
+	 * timestamp and send to App
+	 */
+	if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_EN_ALL)
+		xgmac_get_rx_tstamp(pdev, skb);
+
+	/* No other Rx filter currently supported in driver */
+	return 0;
+}
+
+/* Update the received timestamp in skbhwtstamp
+ * which will be used by PTP app
+ */
+static void xgmac_get_rx_tstamp(void *pdev, struct sk_buff *skb)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	__le64 regval;
+	u32 ts_hdr_len = 8;
+	struct skb_shared_hwtstamps *shhwtstamp = NULL;
+	u64 ns;
+
+	/* TODO: Below code to get hdr len is wrong, Need to find the
+	 * correct register
+	 */
+	/* External clk_src only have 8 bytes as tstamp header
+	 * Internal clk_src have 10 bytes as tstamp header
+	 * (8 bytes tstamp + 2 bytes Year)
+	 * Get the register setting for clk src
+	 */
+	if (pdata->hw_feat.ts_src == 2)
+		ts_hdr_len = 8;
+	else if (pdata->hw_feat.ts_src == 1 || pdata->hw_feat.ts_src == 3)
+		ts_hdr_len = 10;
+
+	/* copy the bits out of the skb, and then trim the skb length */
+	skb_copy_bits(skb, skb->len - ts_hdr_len, &regval, ts_hdr_len);
+	__pskb_trim(skb, skb->len - ts_hdr_len);
+
+	/* The timestamp is recorded in little endian format, and is stored at
+	 * the end of the packet.
+	 *
+	 * DWORD: N              N + 1      N + 2
+	 * Field: End of Packet  SYSTIMH    SYSTIML
+	 */
+	ns = le64_to_cpu(regval);
+
+	shhwtstamp = skb_hwtstamps(skb);
+	memset(shhwtstamp, 0, sizeof(struct skb_shared_hwtstamps));
+	shhwtstamp->hwtstamp = ns_to_ktime(ns);
+}
+
+/* Configuring the HW Timestamping feature
+ * This api will be called from the IOCTL SIOCSHWTSTAMP
+ */
+int xgmac_config_hwts(void *pdev, struct ifreq *ifr)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	struct hwtstamp_config config;
+	int err;
+	struct mac_ops *hw_if = &pdata->ops;
+
+	if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
+		return -EFAULT;
+
+	err = hw_if->config_hw_time_stamping(pdev,
+					     config.rx_filter, config.tx_type);
+
+	if (err)
+		return err;
+
+	/* save these settings for future reference */
+	memcpy(&pdata->tstamp_config, &config, sizeof(pdata->tstamp_config));
+
+	return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?
+	       -EFAULT : 0;
+}
+
+int xgmac_ptp_isr_hdlr(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 txtsc;
+	struct mac_ops *hw_if = &pdata->ops;
+	u64 tstamp;
+	int ret = -1;
+
+	/* Clear/Acknowledge interrupt by reading TXTSC */
+	txtsc = XGMAC_RGRD_BITS(pdata, MAC_TSTAMP_STSR, TXTSC);
+
+	if (txtsc) {
+		/* If One step timestamp no need to schedule work */
+		if (pdata->two_step == 1) {
+			schedule_work(&pdata->ptp_tx_work);
+		} else {
+			/* Read the TxTimestamp Seconds register
+			 * to clear the TXTSC bit
+			 */
+			tstamp = hw_if->get_tx_tstamp(pdata);
+		}
+
+		ret = 0;
+	}
+
+	return ret;
+}
+
+/* This API performs the required steps for enabling PTP support.
+ * This api will be called by MAC driver when initializing MAC
+ */
+int xgmac_ptp_init(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	int ret = 0;
+
+	if (!pdata->hw_feat.ts_src || !pdata->hw_feat.osten) {
+		ret = -1;
+		pdata->ptp_clock = NULL;
+		pr_info("No PTP suppor in HW Aborting PTP clk drv register\n");
+		return ret;
+	}
+
+	/* Initialize the spin lock first since we can't control when a user
+	 * will call the entry functions once we have initialized the clock
+	 * device
+	 */
+
+	spin_lock_init(&pdata->ptp_lock);
+
+	/* Initialize the work queue, this is needed for 2 step timestamp
+	 * process
+	 */
+	INIT_WORK(&pdata->ptp_tx_work, (work_func_t)xgmac_ptp_tx_work);
+
+	pdata->ptp_tx_init = 1;
+
+	pdata->one_nsec_accuracy = 1;
+
+	ret = xgmac_ptp_register(pdev);
+
+	if (ret == -1)
+		pr_info("Already have a PTP clock device\n");
+
+	return ret;
+}
+
+static int xgmac_ptp_register(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	struct ptp_clock_info *info = &pdata->ptp_clk_info;
+	int ret = 0;
+
+	/* do nothing if we already have a clock device */
+	if (pdata->ptp_clock)
+		return -1;
+
+	snprintf(info->name, sizeof(info->name),
+		 "%s", "xgmac_clk");
+
+	info->owner = THIS_MODULE;
+	info->adjfreq = xgmac_adj_freq;
+	info->adjtime = xgmac_adj_time;
+	info->gettime64 = xgmac_get_time;
+	info->settime64 = xgmac_set_time;
+#ifdef CONFIG_PTP_1588_CLOCK
+	pdata->ptp_clock = ptp_clock_register(info, pdata->dev);
+#endif
+
+	if (IS_ERR(pdata->ptp_clock)) {
+		pdata->ptp_clock = NULL;
+		pr_err("ptp_clock_register() failed\n");
+		return -1;
+	}
+
+	pr_info("Added PTP HW clock successfully\n");
+
+	/* Disable all timestamping to start */
+	pdata->tstamp_config.tx_type = HWTSTAMP_TX_OFF;
+	pdata->tstamp_config.rx_filter = HWTSTAMP_FILTER_NONE;
+
+	return ret;
+}
+
+void xgmac_ptp_remove(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	if (pdata->ptp_tx_init) {
+		cancel_work_sync(&pdata->ptp_tx_work);
+		pdata->ptp_tx_init = 0;
+	}
+
+	if (pdata->ptp_clock) {
+#ifdef CONFIG_PTP_1588_CLOCK
+		ptp_clock_unregister(pdata->ptp_clock);
+		pr_info("Removed PTP HW clock successfully\n");
+#endif
+	}
+}
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.h b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.h
new file mode 100644
index 000000000000..054294c83aa2
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.h
@@ -0,0 +1,72 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+/* =========================================================================
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ * The Synopsys DWC ETHER XGMAC Software Driver and documentation (hereinafter
+ * "Software") is an unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto.  Permission is hereby granted,
+ * free of charge, to any person obtaining a copy of this software annotated
+ * with this license and the Software, to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================= */
+
+#ifndef __XGMAC_PTP_H__
+#define __XGMAC_PTP_H__
+
+/* PTP V2 message type */
+enum {
+	PTP_MSGTYPE_SYNC			= 0x0,
+	PTP_MSGTYPE_DELREQ			= 0x1,
+	PTP_MSGTYPE_PDELREQ			= 0x2,
+	PTP_MSGTYPE_PDELRESP			= 0x3,
+	PTP_MSGTYPE_FLWUP			= 0x8,
+	PTP_MSGTYPE_DELRESP			= 0x9,
+	PTP_MSGTYPE_PDELRES_FLWUP		= 0xA,
+	PTP_MSGTYPE_ANNOUNCE			= 0xB,
+	PTP_MSGTYPE_SGNLNG			= 0xC,
+	PTP_MSGTYPE_MNGMNT			= 0xD,
+};
+
+/* Byte offset of data in the PTP V2 headers */
+#define PTP_OFFS_MSG_TYPE		0
+#define PTP_OFFS_FLAGS			6
+
+int xgmac_tx_hwts(void *pdev, struct sk_buff *skb);
+int xgmac_rx_hwts(void *pdev, struct sk_buff *skb);
+int xgmac_config_hwts(void *pdev, struct ifreq *ifr);
+int xgmac_ptp_init(void *pdev);
+void xgmac_ptp_remove(void *pdev);
+void xgmac_config_timer_reg(void *pdev);
+int xgmac_ptp_tx_work(struct work_struct *work);
+
+
+#endif
diff --git a/include/net/switch_api/mac_ops.h b/include/net/switch_api/mac_ops.h
new file mode 100644
index 000000000000..57c8af04cf3a
--- /dev/null
+++ b/include/net/switch_api/mac_ops.h
@@ -0,0 +1,384 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_OPS_H_
+#define _MAC_OPS_H_
+
+#include "gsw_irq.h"
+#include "gsw_types.h"
+
+struct mac_ops {
+	/* This function Sets the Flow Ctrl operation in Both XGMAC and LMAC.
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	mode	0 - Auto Mode based on GPHY/XPCS link.
+	 *				1 - Flow Ctrl enabled only in RX
+	 *				2 - Flow Ctrl enabled only in TX
+	 *				3 - Flow Ctrl enabled both in RX & TX
+	 *				4 - Flow Ctrl disabled both in RX & TX
+	 * return	OUT  0:Flow Ctrl operation Set Successfully
+	 * return	OUT  !0:Flow Ctrl operation Set Error
+	 */
+	int(*set_flow_ctl)(void *, u32);
+	/* This function Gets the Flow Ctrl operation in Both XGMAC and LMAC.
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT:	mode	0 - Auto Mode based on GPHY/XPCS link.
+	 *				1 - Flow Ctrl enabled only in RX
+	 *				2 - Flow Ctrl enabled only in TX
+	 *				3 - Flow Ctrl enabled both in RX & TX
+	 *				4 - Flow Ctrl disabled both in RX & TX
+	 * return	OUT  -1:	Flow Ctrl operation Get Error
+	 */
+	int(*get_flow_ctl)(void *);
+	/* This function Resets the MAC module.
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT  0:	Reset of MAC module Done Successfully
+	 * return	OUT  -1:	Reset of MAC module Error
+	 */
+	int(*mac_reset)(void *);
+	/* This function Configures MAC Loopback.
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	val	1 - Loopback Enable, 0 - Loopback Dis
+	 * return	OUT  -1:	Loopback Set Error
+	 */
+	int(*mac_config_loopback)(void *, u32);
+	/* This function Configures MAC IPG.
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	IPG val	Value is from 0 - 7,
+	 *			where 0 denotes the default 96 bits
+	 * 			000: 96 bit
+	 *			001: 128 bit
+	 *			010: 160 bit
+	 *			011: 192 bit
+	 *			100: 224 bit
+	 *			101  111: Reserved
+	 * return	OUT  -1:	IPG Set Error
+	 */
+	int(*mac_config_ipg)(void *, u32);
+	/* This function Configures the Speed
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	speed(Mbps)
+	 *			10  	- 10Mbps
+	 *			100 	- 100Mbps
+	 *			1000  	- 1Gbps
+	 *			25000  	- 2.5Gbps
+	 *			100000  - 10Gbps
+	 * return	OUT  -1:	Speed Set Error
+	 */
+
+	int(*set_speed)(void *, u32);
+	/* This function Gets the Speed
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT:	speed(Mbps)
+	 *			10  	- 10Mbps
+	 *			100 	- 100Mbps
+	 *			1000  	- 1Gbps
+	 *			25000  	- 2.5Gbps
+	 *			100000  - 10Gbps
+	 * return	OUT  -1:	Speed Get Error
+	 */
+	int(*get_speed)(void *);
+	/* This function Configures the Duplex
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	duplex
+	 *			0  	- Full Duplex
+	 *			1 	- Half Duplex
+	 *			2 	- Auto
+	 * return	OUT  -1:	Duplex Set Error
+	 */
+	int(*set_duplex)(void *, u32);
+	/* This function Gets the Duplex value
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT:	duplex
+	 *			0  	- Full Duplex
+	 *			1 	- Half Duplex
+	 *			2 	- Auto
+	 * return	OUT  -1:	Duplex Get Error
+	 */
+	int(*get_duplex)(void *);
+	/* This function Configures the LPI
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	LPI EN
+	 * 			0  	- Disable
+	 *			1 	- Enable
+	 * param[in/out]IN:	LPI Wait time for 100M in usec
+	 * param[in/out]IN:	LPI Wait time for 1G in usec
+	 * return	OUT	-1:	LPI Set Error
+	 */
+	int(*set_lpi)(void *, u32, u32, u32);
+	/* This function Gets the LPI Enable/Disable
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT:	LPI EN
+	 *			0  	- Disable
+	 *			1 	- Enable
+	 * return	OUT  -1:	LPI Get Error
+	 */
+	int(*get_lpi)(void *);
+	/* This function Configures the MII Interface
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	MII Mode
+	 *			0  	- MII
+	 *			2 	- GMII
+	 *			4 	- XGMII
+	 *			5 	- LMAC GMII
+	 * return	OUT  -1:	MII Interface Set Error
+	 */
+	int(*set_mii_if)(void *, u32);
+	/* This function Gets the MII Interface
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT:	MII Mode
+	 *			0  	- MII
+	 *			2 	- GMII
+	 *			4 	- XGMII
+	 *			5 	- LMAC GMII
+	 * return	OUT  -1:	MII Interface Get Error
+	 */
+	int(*get_mii_if)(void *);
+	/* This function Sets the Link Status
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	Link
+	 *			0  	- LINK Force UP
+	 *			1  	- LINK Force DOWN
+	 *			Any - AUTO Mode
+	 * return	OUT  -1:	Link Status Set Error
+	 */
+	int(*set_link_sts)(void *, u8);
+	/* This function Gets the Link Status
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT:	Link
+	 *			0  	- LINK Force UP
+	 *			1  	- LINK Force DOWN
+	 *			Any - AUTO Mode
+	 * return	OUT  -1:	Link Status Get Error
+	 */
+	int(*get_link_sts)(void *);
+	/* This function Sets the MTU Configuration
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	MTU
+	 *			Max MTU that can be set is 10000 for Falcon-Mx
+	 * return	OUT	-1: 	MTU set exceed the Max limit
+	 */
+	int(*set_mtu)(void *, u32);
+	/* This function Gets the MTU Configuration
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT:	MTU
+	 * 			MTU configured
+	 * return	OUT  -1:	MTU Get Error
+	 */
+	int(*get_mtu)(void *);
+	/* This function Sets the Pause frame Source Address
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	*mac_addrMAC source address to Set
+	 * param[in/out]IN:	mode
+	 *			1 - PORT specific MAC source address
+	 *			0 - COMMON MAC source address
+	 * return	OUT	-1: 	Pause frame Source Address Set Error
+	 */
+	int(*set_pfsa)(void *, u8 *, u32);
+	/* This function Gets the Pause frame Source Address
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT:	*mac_addr	MAC source address which is set
+	 * return	OUT:	*mode		Mode configured
+	 *			1 - PORT specific MAC source address
+	 *			0 - COMMON MAC source address
+	 * return	OUT	-1:	Pause frame Source Address Get Error
+	 */
+	int(*get_pfsa)(void *, u8 *, u32 *);
+	/* This function Sets the FCS generation Configuration
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	val	FCS generation Configuration
+	 *			0 - CRC and PAD insertion are enabled.
+	 *			1 - CRC insert enable and PAD insert disable
+	 *			2 - CRC and PAD are not insert and not replaced.
+	 * return	OUT	-1:	FCS generation Set Error
+	 */
+	int(*set_fcsgen)(void *, u32);
+	/* This function Gets the FCS generation Configuration
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT:	val	FCS generation Configuration
+	 *			0 - CRC and PAD insertion are enabled.
+	 *			1 - CRC insert enable and PAD insert disable
+	 *			2 - CRC and PAD are not insert and not replaced.
+	 * return	OUT	-1:	FCS generation Get Error
+	 */
+	int(*get_fcsgen)(void *);
+	/* This function Clears MAC Interrupt Status
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	event	Difffernt events to clear
+	 * return	OUT	: 	Cleared return status
+	 */
+	int(*clr_int_sts)(void *, u32);
+	/* This function Gets MAC Interrupt Status
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT	: 	Interrupts Pending
+	 */
+	int(*get_int_sts)(void *);
+	/* This function Initializes System time Configuration
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	sec	Initial seconds value to be configured
+	 *				in register
+	 * param[in/out]IN:	nsec	Initial nano-seconds value to be
+	 *				configured in register
+	 * return	OUT	-1: 	System time Configuration Set Error
+	 */
+	int(*init_systime)(void *, u32, u32);
+	/* This function Configures addend value
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	addend
+	 * The Timestamp Addend register is present only when the IEEE 1588
+	 * Timestamp feature is selected without
+	 * external timestamp input. This register value is used only when the
+	 * system time is configured for Fine
+	 * Update mode (TSCFUPDT bit in the MAC_Timestamp_Ctrl register).
+	 * The content of this register is
+	 * added to a 32-bit accumulator in every clock cycle and the
+	 * system time is updated whenever the accumulator overflows.
+	 * This field indicates the 32-bit time value to be added to the
+	 * Accumulator register to achieve time synchronization.
+	 * return	OUT	-1: 	Addend Configuration Set Error
+	 */
+	int(*config_addend)(void *, u32);
+	/* This function Adjust System Time for PTP
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	sec	New seconds value to be configured
+	 * param[in/out]IN:	nsec	New nano seconds value to be configured
+	 * param[in/out]IN:	addsub	Add or Subtract Time
+	 * When this bit is set, the time value is subtracted with the
+	 * contents of the update register. When this bit is reset,
+	 * the time value is added with the contents of the update register.
+	 * param[in/out]IN:	one_nsec_accuracy
+	 *	If the new nsec value need to be subtracted with
+	 *	the system time, then MAC_STNSUR.TSSS field should be
+	 *	programmed with,
+	 *	(10^9 - <new_nsec_value>) if MAC_TX_CFG.TSCTRLSSR is set or
+	 *	(2^31 - <new_nsec_value> if MAC_TX_CFG.TSCTRLSSR is reset)
+	 * return	OUT	-1: 		Adjust System Time for PTP Error
+	 */
+	int(*adjust_systime)(void *, u32, u32, u32, u32);
+	/* This sequence is used get 64-bit system time in nano sec
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT	u64: 	64-bit system time in nano sec
+	 */
+	u64(*get_systime)(void *);
+	/* This sequence is used get Transmitted 64-bit system time in nano sec
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT	u64: 	Tx 64-bit system time in nano sec
+	 */
+	u64(*get_tx_tstamp)(void *);
+	/* This sequence is used get Tx Transmitted capture count
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT	u32: 	Tx Timestamp capture count
+	 */
+	int(*get_txtstamp_cap_cnt)(void *);
+	/* This sequence is used Configure HW TimeStamping TX/RX filter Cfg
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	tx_type: 1/0 - ON/OFF
+	 * param[in/out]IN:	rx_filter:	This is based on Table 7-146,
+	 *			Receive side timestamp Capture scenarios
+	 * return	OUT	-1:	Configure HW TimeStamping Set Error
+	 */
+	int(*config_hw_time_stamping)(void *, u32, u32);
+	/* This sequence is used ConfigureSub Second Increment
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	ptp_clk: PTP Clock Value in Hz
+	 *	The value programmed in this field is accumulated with the
+	 *	contents of the sub-second register.
+	 *	For example, when the PTP clock is 50 MHz (period is 20 ns),
+	 *	you should program 20 (0x14)
+	 *	when the System TimeNanoseconds register has an accuracy
+	 *	of 1 ns [Bit 9 (TSCTRLSSR) is set in MAC_Timestamp_Ctrl].
+	 *	When TSCTRLSSR is clear, the Nanoseconds register has a
+	 *	resolution of ~0.465 ns. In this case, you
+	 *	should program a value of 43 (0x2B)
+	 *	which is derived by 20 ns/0.465.
+	 * return	OUT	-1: 	Configure Sub Second Inccrement Error
+	 */
+	int(*config_subsec_inc)(void *, u32);
+	/* This sequence is used Initialize MAC
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT	-1: 	Initialize MAC Error
+	 */
+	int(*init)(void *);
+	/* This sequence is used Exit MAC
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT	-1: 		Exit MAC Error
+	 */
+	int(*exit)(void *);
+	/* This sequence is used for Xgmac Cli implementation
+	 * param[in/out]IN:	argc - Number of args.
+	 * param[in/out]IN:	argv - Argument value.
+	 * return	OUT	-1: 		Exit MAC Error
+	 */
+	int(*xgmac_cli)(u32, u8 **);
+	/* This sequence is used for Lmac Cli implementation
+	 * param[in/out]IN:	argc - Number of args.
+	 * param[in/out]IN:	argv - Argument value.
+	 * return	OUT	-1: 		Exit MAC Error
+	 */
+	int(*lmac_cli)(u32, u8 **);
+	/* This sequence is used for Reading XGMAC register
+	 * param[in/out]IN:	ops -	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	u16 -   Register Offset.
+	 * return	OUT	u32 -	Register Value
+	 */
+	u32(*xgmac_reg_rd)(void *, u16);
+	/* This sequence is used for Writing XGMAC register
+	 * param[in/out]IN:	ops -	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	u16 -   Register Offset.
+	 * param[in/out]IN:	u32 -   Register Value.
+	 */
+	void(*xgmac_reg_wr)(void *, u16, u32);
+	/* This sequence is used for Reading LMAC register
+	 * param[in/out]IN:	ops -	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	u16 -   Register Offset.
+	 * return	OUT	u32 -	Register Value
+	 */
+	u32(*lmac_reg_rd)(void *, u32);
+	/* This sequence is used for Writing LMAC register
+	 * param[in/out]IN:	ops -	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	u16 -   Register Offset.
+	 * param[in/out]IN:	u32 -   Register Value.
+	 */
+	void(*lmac_reg_wr)(void *, u32, u32);
+	/* This sequence is used for Registering IRQ Callback for a event
+	 * param[in/out]IN:	ops -	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	GSW_Irq_Op_t -   IRQ event info.
+	 * return	OUT	int -	Success/Fail
+	 */
+	int (*IRQ_Register)(void *, GSW_Irq_Op_t *);
+	/* This sequence is used for UnRegistering IRQ Callback for a event
+	 * param[in/out]IN:	ops -	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	GSW_Irq_Op_t -   IRQ event info.
+	 * return	OUT	int -	Success/Fail
+	 */
+	int (*IRQ_UnRegister)(void *, GSW_Irq_Op_t *);
+	/* This sequence is used for Enabling IRQ for a event
+	 * param[in/out]IN:	ops -	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	GSW_Irq_Op_t -   IRQ event info.
+	 * return	OUT	int -	Success/Fail
+	 */
+	int (*IRQ_Enable)(void *, GSW_Irq_Op_t *);
+	/* This sequence is used for Disabling IRQ for a event
+	 * param[in/out]IN:	ops -	MAC ops Struct registered for MAC 0/1/2.
+	 * param[in/out]IN:	GSW_Irq_Op_t -   IRQ event info.
+	 * return	OUT	int -	Success/Fail
+	 */
+	int (*IRQ_Disable)(void *, GSW_Irq_Op_t *);
+	/* This sequence is used for Enabling MAC Interrupt
+	 * param[in/out]IN:	ops -	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT	int -	Success/Fail
+	 */
+	int (*mac_int_en)(void *);
+	/* This sequence is used for Disabling MAC Interrupt
+	 * param[in/out]IN:	ops -	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT	int -	Success/Fail
+	 */
+	int (*mac_int_dis)(void *);
+};
+
+#endif
