From 0ce9e19e0e951d2891a30e46f23075f67d29b1c8 Mon Sep 17 00:00:00 2001
From: thampan <joby.thampan@intel.com>
Date: Fri, 29 Jun 2018 14:15:41 +0800
Subject: [PATCH] DRVLIB_SW-778: PTP Clock, 1-Step and 2-Step Support

---
 drivers/net/ethernet/lantiq/datapath/Kconfig       |   14 +
 drivers/net/ethernet/lantiq/datapath/Makefile      |    4 +
 drivers/net/ethernet/lantiq/datapath/datapath.h    |   19 +-
 .../net/ethernet/lantiq/datapath/datapath_api.c    |   40 +
 .../ethernet/lantiq/datapath/datapath_instance.c   |   17 +-
 .../net/ethernet/lantiq/datapath/datapath_ioctl.c  |   81 +
 .../net/ethernet/lantiq/datapath/datapath_ioctl.h  |    9 +
 .../net/ethernet/lantiq/datapath/datapath_soc.c    |    5 +
 .../lantiq/datapath/gswip31/datapath_misc.c        |    4 +
 drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c   |   17 +
 .../ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c |    2 +-
 .../net/ethernet/lantiq/switch-api/mac/Makefile    |    1 +
 .../net/ethernet/lantiq/switch-api/mac/gswss_api.c |   80 +
 .../net/ethernet/lantiq/switch-api/mac/gswss_api.h |    2 +
 .../ethernet/lantiq/switch-api/mac/gswss_mac_api.c |  152 +-
 .../ethernet/lantiq/switch-api/mac/gswss_mac_api.h |    7 +-
 .../net/ethernet/lantiq/switch-api/mac/lmac_api.c  |   48 +-
 .../net/ethernet/lantiq/switch-api/mac/mac_cfg.c   |   96 +-
 .../net/ethernet/lantiq/switch-api/mac/mac_cfg.h   |    4 +-
 .../net/ethernet/lantiq/switch-api/mac/mac_drv.c   |   15 +-
 .../ethernet/lantiq/switch-api/mac/mac_tx_fifo.c   |  223 ++
 .../ethernet/lantiq/switch-api/mac/mac_tx_fifo.h   |   47 +
 drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h |   25 +-
 .../net/ethernet/lantiq/switch-api/mac/xgmac_cli.c |   62 +-
 .../net/ethernet/lantiq/switch-api/mac/xgmac_cli.h |    3 +
 .../ethernet/lantiq/switch-api/mac/xgmac_common.h  |   20 +-
 .../ethernet/lantiq/switch-api/mac/xgmac_debug.c   |   92 +-
 .../ethernet/lantiq/switch-api/mac/xgmac_mac_api.c |  152 +-
 .../ethernet/lantiq/switch-api/mac/xgmac_main.c    |  102 +-
 .../net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c |  405 +--
 .../net/ethernet/lantiq/switch-api/mac/xgmac_ptp.h |   12 +-
 include/net/datapath_api.h                         |    1 +
 include/net/datapath_api_gswip31.h                 |    4 +-
 include/net/datapath_inst.h                        |    3 +
 include/net/switch_api/adap_ops.h                  |    0
 include/net/switch_api/gsw_flow_ops.h              | 1416 +++++------
 include/net/switch_api/gsw_ioctlcmd_type.h         |  130 +-
 include/net/switch_api/gsw_tbl_rw.h                |  328 +--
 include/net/switch_api/lantiq_gsw.h                |    2 +-
 include/net/switch_api/lantiq_gsw_api.h            |  182 +-
 include/net/switch_api/lantiq_gsw_flow.h           | 2688 ++++++++++----------
 include/net/switch_api/mac_ops.h                   |   28 +
 tools/testing/selftests/ptp/testptp.c              |    7 +-
 43 files changed, 3717 insertions(+), 2832 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/datapath/Kconfig b/drivers/net/ethernet/lantiq/datapath/Kconfig
old mode 100644
new mode 100755
index 9ed63cc2a1d4..6b07a7dd4e48
--- a/drivers/net/ethernet/lantiq/datapath/Kconfig
+++ b/drivers/net/ethernet/lantiq/datapath/Kconfig
@@ -115,6 +115,20 @@ config LTQ_DATAPATH_SWITCHDEV
 	---help---
 	  Switchdev support for different switch in datapath
 
+config LTQ_DATAPATH_PTP1588
+	bool "PTP1588 Support"
+	default n
+	depends on  LTQ_DATAPATH
+	---help---
+	  PTP1588 support in datapath
+
+config LTQ_DATAPATH_PTP1588_SW_WORKAROUND
+        bool "PTP1588 Software Workaround"
+        default n
+        depends on  LTQ_DATAPATH && LTQ_DATAPATH_PTP1588
+        ---help---
+          PTP1588 Software Workaround
+
 config LTQ_DATAPATH_DDR_SIMULATE_GSWIP31
 	bool "Force FALCON-MX SOC"
 	default n
diff --git a/drivers/net/ethernet/lantiq/datapath/Makefile b/drivers/net/ethernet/lantiq/datapath/Makefile
old mode 100644
new mode 100755
index 0367e49fade9..281c794c5dbb
--- a/drivers/net/ethernet/lantiq/datapath/Makefile
+++ b/drivers/net/ethernet/lantiq/datapath/Makefile
@@ -10,3 +10,7 @@ endif
 ifneq ($(CONFIG_LTQ_DATAPATH_SWITCHDEV),)
 obj-$(CONFIG_LTQ_DATAPATH) += datapath_swdev.o
 endif
+
+ifneq ($(CONFIG_LTQ_DATAPATH_PTP1588),)
+obj-$(CONFIG_LTQ_DATAPATH) += datapath_ioctl.o
+endif
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath.h b/drivers/net/ethernet/lantiq/datapath/datapath.h
index 71e716d82a66..f9014d0426da 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath.h
+++ b/drivers/net/ethernet/lantiq/datapath/datapath.h
@@ -155,6 +155,7 @@ enum dp_xmit_errors {
 	DP_XMIT_ERR_EP_ZERO,
 	DP_XMIT_ERR_GSO_NOHEADROOM,
 	DP_XMIT_ERR_CSM_NO_SUPPORT,
+	DP_XMIT_PTP_ERR,
 };
 
 enum PARSER_FLAGS {
@@ -411,12 +412,15 @@ struct vlan_info {
 	u16 in_vid;
 	int cnt;
 };
-
-#define MAX_TEMPLATE 3
-#define TEMPL_NORMAL 0
-#define TEMPL_CHECKSUM 1
-#define TEMPL_OTHERS   2
-
+enum DP_TEMP_DMA_PMAC {
+	TEMPL_NORMAL = 0,
+	TEMPL_CHECKSUM,
+#if IS_ENABLED(CONFIG_LTQ_DATAPATH_PTP1588)
+	TEMPL_PTP,
+#endif
+	TEMPL_OTHERS,
+	MAX_TEMPLATE
+};
 enum DP_PRIV_F {
 	DP_PRIV_PER_CTP_QUEUE = BIT(0), /*Manage Queue per CTP/subif */
 };
@@ -450,6 +454,9 @@ struct pmac_port_info {
 	u32 tx_ring_offset;  /*PP: next tx_ring_addr=
 			      *   current tx_ring_addr + tx_ring_offset
 			      */
+#if IS_ENABLED(CONFIG_LTQ_DATAPATH_PTP1588)
+	u32 f_ptp:1; /* PTP1588 support enablement */
+#endif
 };
 
 struct pmac_port_info2 {
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_api.c b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
index 70736e705bd5..5721efbfdbfc 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_api.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
@@ -1916,6 +1916,7 @@ static inline int32_t dp_rx_one_skb(struct sk_buff *skb, uint32_t flags)
 	char decryp = 0;
 	u8 inst = 0;
 	struct pmac_port_info *dp_port;
+	struct mac_ops *ops;
 
 	dp_port = &dp_port_info[inst][0];
 	if (!skb) {
@@ -1973,6 +1974,13 @@ static inline int32_t dp_rx_one_skb(struct sk_buff *skb, uint32_t flags)
 		goto RX_DROP;
 	}
 	dp_port = &dp_port_info[inst][port_id];
+#if IS_ENABLED(CONFIG_LTQ_DATAPATH_PTP1588)
+	if (dp_port->f_ptp) {
+		ops = dp_port_prop[inst].mac_ops[port_id];
+		if (ops)
+			ops->do_rx_hwts(ops, skb);
+	}
+#endif
 	rx_fn = dp_port->cb.rx_fn;
 	if (likely(rx_fn && dp_port->status)) {
 		/*Clear some fields as SWAS V3.7 required */
@@ -2165,6 +2173,10 @@ static void set_chksum(struct pmac_tx_hdr *pmac, u32 tcp_type,
 	pmac->tcp_h_offset = tcp_h_offset >> 2;
 }
 
+static void set_ptp_recid(struct pmac_tx_hdr *pmac, int rec_id)
+{
+	pmac->record_id_msb = rec_id;
+}
 int32_t dp_xmit(struct net_device *rx_if, dp_subif_t *rx_subif,
 		struct sk_buff *skb, int32_t len, uint32_t flags)
 {
@@ -2183,6 +2195,10 @@ int32_t dp_xmit(struct net_device *rx_if, dp_subif_t *rx_subif,
 	enum dp_xmit_errors err_ret = 0;
 	int inst = 0;
 	struct cbm_tx_data data;
+#if IS_ENABLED(CONFIG_LTQ_DATAPATH_PTP1588)
+	struct mac_ops *ops;
+	int rec_id = 0;
+#endif
 
 #ifdef CONFIG_LTQ_DATAPATH_EXTRA_DEBUG
 	if (unlikely(!dp_init_ok)) {
@@ -2290,6 +2306,28 @@ int32_t dp_xmit(struct net_device *rx_if, dp_subif_t *rx_subif,
 							dp_info2);
 			DP_CB(inst, set_pmac_subif)(&pmac, rx_subif->subif);
 		}
+#if IS_ENABLED(CONFIG_LTQ_DATAPATH_PTP1588)
+#if IS_ENABLED(CONFIG_LTQ_DATAPATH_PTP1588_SW_WORKAROUND)
+		if(dp_info->f_ptp)
+#else
+		if(dp_info->f_ptp && 
+			(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP))
+#endif
+		{	ops = dp_port_prop[inst].mac_ops[dp_info->port_id];
+			if(ops)
+				rec_id = ops->do_tx_hwts(ops, skb);
+
+			if(rec_id < 0) {
+				err_ret = DP_XMIT_PTP_ERR;
+				goto lbl_err_ret;
+			}
+
+			DP_CB(inst, get_dma_pmac_templ)(TEMPL_PTP, &pmac,
+							desc_0, desc_1,
+							dp_info2);
+			set_ptp_recid(&pmac, rec_id);
+		}
+#endif
 	} else if (dp_info->alloc_flags & DP_F_FAST_DSL) { /*some with pmac*/
 		if (unlikely(flags & DP_TX_CAL_CHKSUM)) { /* w/ pmac*/
 			DP_CB(inst, get_dma_pmac_templ)(TEMPL_CHECKSUM, &pmac,
@@ -2449,6 +2487,8 @@ int32_t dp_xmit(struct net_device *rx_if, dp_subif_t *rx_subif,
 	case DP_XMIT_ERR_CSM_NO_SUPPORT:
 		PR_RATELIMITED("dp_xmit not support checksum\n");
 		break;
+	case DP_XMIT_PTP_ERR:
+		break;
 	default:
 		UP_STATS(dp_info->subif_info[vap].mib.tx_pkt_dropped);
 		PR_INFO_ONCE("Why come to here:%x\n",
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_instance.c b/drivers/net/ethernet/lantiq/datapath/datapath_instance.c
index 3dfe79e41e90..62ee978374a9 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_instance.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_instance.c
@@ -29,7 +29,9 @@
 #include "datapath.h"
 #include "datapath_instance.h"
 #include "datapath_swdev_api.h"
-
+#if IS_ENABLED(CONFIG_LTQ_DATAPATH_PTP1588)
+#include "datapath_ioctl.h"
+#endif
 int dp_cap_num;
 struct dp_hw_cap hw_cap_list[DP_MAX_HW_CAP];
 
@@ -120,6 +122,9 @@ int dp_request_inst(struct dp_inst_info *info, u32 flag)
 	}
 	dp_port_prop[i].ops[0] = info->ops[0];
 	dp_port_prop[i].ops[1] = info->ops[1];
+	dp_port_prop[i].mac_ops[2] = info->mac_ops[2];
+	dp_port_prop[i].mac_ops[3] = info->mac_ops[3];
+	dp_port_prop[i].mac_ops[4] = info->mac_ops[4];
 	dp_port_prop[i].info = hw_cap_list[k].info;
 	dp_port_prop[i].cbm_inst = info->cbm_inst;
 	dp_port_prop[i].qos_inst = info->qos_inst;
@@ -292,8 +297,11 @@ int dp_inst_add_dev(struct net_device *dev, char *subif_name, int inst,
 		}
 #endif
 #if IS_ENABLED(CONFIG_LTQ_DATAPATH_SWITCHDEV)
-		if (!(flag & DP_F_SUBIF_LOGICAL))
-			dp_port_register_switchdev(dp_dev, dev);
+	if (!(flag & DP_F_SUBIF_LOGICAL))
+		dp_port_register_switchdev(dp_dev, dev);
+#endif
+#if IS_ENABLED(CONFIG_LTQ_DATAPATH_PTP1588)
+	dp_register_ptp_ioctl(dp_dev, dev, inst);
 #endif
 	}
 	dp_dev->count++;
@@ -351,6 +359,9 @@ int dp_inst_del_dev(struct net_device *dev, char *subif_name, int inst, int ep,
 #endif				/*do't really free now
 				 *in case network stack is holding the callback
 				 */
+#if IS_ENABLED(CONFIG_LTQ_DATAPATH_PTP1588)
+				dp_deregister_ptp_ioctl(dp_dev,dev,inst);
+#endif
 				hlist_add_head(&dp_dev->hlist,
 					       &dp_dev_list_free[idx]);
 			}
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_ioctl.c b/drivers/net/ethernet/lantiq/datapath/datapath_ioctl.c
new file mode 100644
index 000000000000..6926b2678ccb
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_ioctl.c
@@ -0,0 +1,81 @@
+#include "datapath_ioctl.h"
+
+static int dp_ndo_ptp_ioctl(struct net_device *dev,
+                 struct ifreq *ifr, int cmd);
+
+
+static int dp_ndo_ptp_ioctl(struct net_device *dev,
+                 struct ifreq *ifr, int cmd)
+{
+	int err = DP_SUCCESS;
+	struct mac_ops *ops;
+	int inst = 0;
+	
+	struct pmac_port_info *port = get_port_info_via_dp_name(dev);
+	if(!port)
+		return DP_FAILURE;
+	
+	ops = dp_port_prop[inst].mac_ops[port->port_id];
+	if(!ops)
+		return DP_FAILURE;
+	
+	switch(cmd) {
+		case SIOCSHWTSTAMP: {
+			port->f_ptp = ops->set_hwts(ops, ifr);
+			if (port->f_ptp < 0) {
+				err = DP_FAILURE;
+				break;
+			}
+			DP_DEBUG(DP_DBG_FLAG_DBG,
+				"PTP in SIOCGHWTSTAMP done\n");
+			}
+			break;
+		case SIOCGHWTSTAMP:
+			ops->get_hwts(ops, ifr);
+			DP_DEBUG(DP_DBG_FLAG_DBG,
+				"PTP in SIOCGHWTSTAMP done\n");
+			break;
+		}
+
+	return err;
+}
+
+int dp_register_ptp_ioctl(struct dp_dev *dp_dev,
+			struct net_device *dp_port, int inst)
+{
+	struct dp_cap cap;
+
+	cap.inst = inst;
+	dp_get_cap(&cap,0);
+	if (!cap.hw_ptp)
+		return DP_FAILURE;
+	if (!dp_dev->old_dev_ops)
+		dp_dev->old_dev_ops = dp_port->netdev_ops;
+	if (dp_port->netdev_ops)
+		dp_dev->new_dev_ops = *dp_port->netdev_ops;
+
+	dp_dev->new_dev_ops.ndo_do_ioctl = dp_ndo_ptp_ioctl,
+	dp_port->netdev_ops =
+		(const struct net_device_ops *)&dp_dev->new_dev_ops;
+	DP_DEBUG(DP_DBG_FLAG_INST,
+		"dp_port_register_ptp_ioctl done:%s\n",
+		dp_port->name);
+	return DP_SUCCESS;
+}
+
+int dp_deregister_ptp_ioctl(struct dp_dev *dp_dev,
+                  struct net_device *dev, int inst)
+{
+	struct dp_cap cap;
+
+	cap.inst = inst;
+	dp_get_cap(&cap,0);
+	if (!cap.hw_ptp)
+		return DP_FAILURE;
+
+	if (dp_dev->old_dev_ops)
+		dev->netdev_ops = dp_dev->old_dev_ops;
+
+	return DP_SUCCESS;
+}
+
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_ioctl.h b/drivers/net/ethernet/lantiq/datapath/datapath_ioctl.h
new file mode 100644
index 000000000000..2a291057cd25
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_ioctl.h
@@ -0,0 +1,9 @@
+#include <net/datapath_api.h>
+#include <net/datapath_api_skb.h>
+#include "datapath.h"
+#include "datapath_instance.h"
+
+int dp_register_ptp_ioctl(struct dp_dev *dp_dev,
+                  struct net_device *dp_port, int inst);
+int dp_deregister_ptp_ioctl(struct dp_dev *dp_dev,
+                  struct net_device *dev, int inst);
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_soc.c b/drivers/net/ethernet/lantiq/datapath/datapath_soc.c
index 407558d7d2dd..1bcba5cf9dae 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_soc.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_soc.c
@@ -32,6 +32,11 @@ int request_dp(u32 flag)
 	info.ver = GSWIP31_VER;
 	info.ops[0] = gsw_get_swcore_ops(0);
 	info.ops[1] = gsw_get_swcore_ops(0);
+	info.mac_ops[0] = NULL;
+	info.mac_ops[1] = NULL;
+	info.mac_ops[2] = gsw_get_mac_ops(0, 0);
+	info.mac_ops[3] = gsw_get_mac_ops(0, 1);
+	info.mac_ops[4] = gsw_get_mac_ops(0, 2);
 #else
 	info.type = GSWIP30_TYPE;
 	info.ver = GSWIP30_VER;
diff --git a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
old mode 100644
new mode 100755
index fecd8e92047c..ae6efc12bcab
--- a/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
+++ b/drivers/net/ethernet/lantiq/datapath/gswip31/datapath_misc.c
@@ -98,6 +98,9 @@ static void init_dma_pmac_template(int portid, u32 flags)
 			dp_info->dma0_template[i].field.redir = 1;
 			dp_info->dma0_mask_template[i].field.redir = 0;
 		}
+#if IS_ENABLED(CONFIG_LTQ_DATAPATH_PTP1588)
+		dp_info->pmac_template[TEMPL_PTP].ptp= 1;
+#endif
 	} else if (flags & DP_F_FAST_WLAN) {/*someties with pmac*/
 		/*normal fast_wlan without pmac.*/
 	} else if (flags & DP_F_DIRECTLINK) { /*always with pmac*/
@@ -1368,6 +1371,7 @@ int register_dp_cap_gswip31(int flag)
 	cap.info.cap.rx_hw_chksum = 0;
 	cap.info.cap.hw_tso = 0;
 	cap.info.cap.hw_gso = 0;
+	cap.info.cap.hw_ptp = 1;
 	strncpy(cap.info.cap.qos_eng_name, "ppv4",
 		sizeof(cap.info.cap.qos_eng_name));
 	strncpy(cap.info.cap.pkt_eng_name, "mpe",
diff --git a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
old mode 100644
new mode 100755
index 7d79cebb5626..ebe5b589da3c
--- a/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
+++ b/drivers/net/ethernet/lantiq/ltq_eth_drv_xrx500.c
@@ -201,6 +201,20 @@ static int set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 	return -ENODEV;
 }
 
+static int get_tsinfo(struct net_device *dev, struct ethtool_ts_info *ts_info)
+{
+	struct ltq_switch_priv_t *priv;
+	struct mac_ops *ops;
+
+	priv = netdev_priv(dev);
+
+	ops = gsw_get_mac_ops(0, (priv->dp_port_id - 2));
+	if(ops)
+		ops->mac_get_ts_info(ops, ts_info);
+
+	return;
+}
+
 /* Reset the device */
 static int nway_reset(struct net_device *dev)
 {
@@ -215,6 +229,7 @@ static const struct ethtool_ops ethtool_ops = {
 	.set_settings		= set_settings,
 	.nway_reset		= nway_reset,
 	.get_link		= ethtool_op_get_link,
+	.get_ts_info 		= get_tsinfo,
 };
 
 /* open the network device interface*/
@@ -636,6 +651,8 @@ static int ltq_eth_init(struct net_device *dev)
 		}
 	}
 
+	dev->ethtool_ops = &ethtool_ops;
+
 	priv->dp_subif.subif = 0;
 	priv->dp_subif.port_id = priv->dp_port_id;
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c b/drivers/net/ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c
index af838fd30d20..d5bd355e6634 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c
@@ -323,7 +323,7 @@ static int update_gsw_dev_cell(struct device_node *np,
 		goto failed;
 
 	strncpy(gsw_dev_cells[idx].name, np->name, 
-		ARRAY_SIZE(gsw_dev_cells[idx].name));
+		(ARRAY_SIZE(gsw_dev_cells[idx].name) - 1));
 
 	gsw_dev_cells[idx].of_node = np;
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/Makefile b/drivers/net/ethernet/lantiq/switch-api/mac/Makefile
old mode 100644
new mode 100755
index 8a6a5f728e7d..4ed1832637fd
--- a/drivers/net/ethernet/lantiq/switch-api/mac/Makefile
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/Makefile
@@ -17,4 +17,5 @@ mac_driver-objs += mac_cfg.o
 mac_driver-objs += gswss_api.o 
 mac_driver-objs += gswss_mac_api.o 
 mac_driver-objs += lmac_api.o
+mac_driver-objs += mac_tx_fifo.o
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.c b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.c
index dbab9a34ca2c..d1d3c05a48fa 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.c
@@ -108,6 +108,86 @@ int gswss_cfg0_1588(void *pdev, u32 ref_time, u32 dig_time, u32 bin_time,
 	return 0;
 }
 
+int gswss_cfg1_1588(void *pdev, u32 trig0_sel, u32 trig1_sel, u32 sw_trig)
+{
+	struct adap_prv_data *pdata = GET_ADAP_PDATA(pdev);
+	u32 cfg0;
+
+#ifdef __KERNEL__
+	spin_lock_bh(&pdata->adap_lock);
+#endif
+
+	cfg0 = GSWSS_RGRD(pdata, CFG1_1588);
+
+	if (trig0_sel == 0)
+		mac_printf("\tTRIG0: PON is the master\n");
+	else if (trig0_sel == 1)
+		mac_printf("\tTRIG0: PCIE0 is the master\n");
+	else if (trig0_sel == 2)
+		mac_printf("\tTRIG0: PCIE1 is the master\n");
+	else if (trig0_sel == 3)
+		mac_printf("\tTRIG0: XGMAC2 is the master\n");
+	else if (trig0_sel == 4)
+		mac_printf("\tTRIG0: XGMAC3 is the master\n");
+	else if (trig0_sel == 5)
+		mac_printf("\tTRIG0: XGMAC4 is the master\n");
+	else if (trig0_sel == 6)
+		mac_printf("\tTRIG0: PON100US is the master\n");
+	else if (trig0_sel == 8)
+		mac_printf("\tTRIG0: EXTPPS0 is the master\n");
+	else if (trig0_sel == 9)
+		mac_printf("\tTRIG0: EXTPPS1 is the master\n");
+	else if (trig0_sel == 10)
+		mac_printf("\tTRIG0: Software Trigger\n");
+	else {
+		mac_printf("\tREF_TIME: Wrong Value");
+		goto end;
+	}
+
+	if (trig1_sel == 0)
+		mac_printf("\tTRIG1: PON is the master\n");
+	else if (trig1_sel == 1)
+		mac_printf("\tTRIG1: PCIE0 is the master\n");
+	else if (trig1_sel == 2)
+		mac_printf("\tTRIG1: PCIE1 is the master\n");
+	else if (trig1_sel == 3)
+		mac_printf("\tTRIG1: XGMAC2 is the master\n");
+	else if (trig1_sel == 4)
+		mac_printf("\tTRIG1: XGMAC3 is the master\n");
+	else if (trig1_sel == 5)
+		mac_printf("\tTRIG1: XGMAC4 is the master\n");
+	else if (trig1_sel == 6)
+		mac_printf("\tTRIG1: PON100US is the master\n");
+	else if (trig1_sel == 8)
+		mac_printf("\tTRIG1: EXTPPS0 is the master\n");
+	else if (trig1_sel == 9)
+		mac_printf("\tTRIG1: EXTPPS1 is the master\n");
+	else if (trig1_sel == 10)
+		mac_printf("\tTRIG1: Software Trigger\n");
+	else {
+		mac_printf("\tTRIG1: Wrong Value");
+		goto end;
+	}
+
+	if (sw_trig == 0)
+		mac_printf("\tSW_TRIG: 0\n");
+	else if (trig1_sel == 1)
+		mac_printf("\tSW_TRIG: 1\n");
+
+	MAC_SET_VAL(cfg0, CFG1_1588, TRIG1SEL, trig1_sel);
+	MAC_SET_VAL(cfg0, CFG1_1588, TRIG0SEL, trig0_sel);
+	MAC_SET_VAL(cfg0, CFG1_1588, SWTRIG, sw_trig);
+
+	GSWSS_RGWR(pdata, CFG1_1588, cfg0);
+end:
+#ifdef __KERNEL__
+	spin_unlock_bh(&pdata->adap_lock);
+#endif
+
+	return 0;
+}
+
+
 int gswss_get_cfg0_1588(void *pdev, u32 *ref_time, u32 *dig_time,
 			u32 *bin_time, u32 *pps_sel)
 {
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.h b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.h
index fc25d8554929..9a802d4c8eb6 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_api.h
@@ -250,6 +250,8 @@ int gswss_switch_ss_reset(void *pdev);
 int gswss_set_clkmode(void *pdev, u32 clk_mode);
 int gswss_cfg0_1588(void *pdev, u32 ref_time, u32 dig_time, u32 bin_time,
 		    u32 pps_sel);
+int gswss_cfg1_1588(void *pdev, u32 trig0_sel, u32 trig1_sel, u32 sw_trig);
+
 int gswss_set_macsec_to_mac(void *pdev, u32 mac_idx, u32 enable);
 
 int gswss_get_int_stat(void *pdev, u32 mod);
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.c b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.c
index 7622366737a9..69f1431d9f56 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.c
@@ -89,6 +89,13 @@ struct _gswss_cfg gswss_adap_cfg[] = {
 		"dig_time bin_time pps_sel>"
 	},
 	{
+		"extts",
+		3,
+		"<trig0_sel <0/1/2/3/4/5/6/8/9/10 PON/PCIE0/PCIE1/XGMAC2/XGMAC3/XGMAC4/PON100US/EXTPPS0/EXTPPS1/SW>"
+		"<trig1_sel <0/1/2/3/4/5/6/8/9/10 PON/PCIE0/PCIE1/XGMAC2/XGMAC3/XGMAC4/PON100US/EXTPPS0/EXTPPS1/SW>"
+		"<sw_trig <0/1>"
+	},
+	{
 		"clk_md",
 		1,
 		"<0/1/2/3 666/450/Auto/Auto Mhz >"
@@ -324,20 +331,17 @@ int gswss_main(u32 argc, u8 *argv[])
 	u32 speed;
 	u32 dir, oper;
 	u32 mtu;
-	u32 sec, nsec, rec_id;
-	u32 ttse, ostc, ost_avail, cic;
-
-	u32 enable;
+	u32 enable, rec_id;
 	u32 ref_time, dig_time, bin_time, pps_sel;
 	struct mac_ops *ops = NULL;
 	struct adap_ops *adap_ops = gsw_get_adap_ops(0);
 	u32 reg_off, reg_val;
-
+	struct mac_fifo_entry f_entry;
+	u32 trig1_sel, trig0_sel, sw_trig;
 
 	start_arg++;
 	start_arg++;
 
-
 	if (argc <= 2) {
 		gswss_help();
 		goto end;
@@ -458,7 +462,7 @@ int gswss_main(u32 argc, u8 *argv[])
 					      mac_nstrlen(argv[start_arg]),
 					      &start_arg);
 
-			gswss_get_txtstamp_fifo(ops, rec_id);
+			gswss_get_txtstamp_fifo(ops, rec_id, &f_entry);
 		} else if (!strcmp(argv[start_arg], "phymode")) {
 			start_arg++;
 			ops = gswss_get_mac_ops(argv[start_arg - 1],
@@ -637,29 +641,28 @@ int gswss_main(u32 argc, u8 *argv[])
 			if (!ops)
 				return -1;
 
-			ttse = mac_nstrtoul(argv[start_arg],
-					    mac_nstrlen(argv[start_arg]),
-					    &start_arg);
-			ostc = mac_nstrtoul(argv[start_arg],
-					    mac_nstrlen(argv[start_arg]),
-					    &start_arg);
-			ost_avail = mac_nstrtoul(argv[start_arg],
-						 mac_nstrlen(argv[start_arg]),
-						 &start_arg);
-			cic = mac_nstrtoul(argv[start_arg],
-					   mac_nstrlen(argv[start_arg]),
-					   &start_arg);
-			sec = mac_nstrtoul(argv[start_arg],
-					   mac_nstrlen(argv[start_arg]),
-					   &start_arg);
-			nsec = mac_nstrtoul(argv[start_arg],
-					    mac_nstrlen(argv[start_arg]),
-					    &start_arg);
-			rec_id = mac_nstrtoul(argv[start_arg],
-					      mac_nstrlen(argv[start_arg]),
-					      &start_arg);
-			gswss_set_txtstamp_fifo(ops, ttse, ostc, ost_avail, cic,
-						sec, nsec, rec_id);
+			f_entry.ttse = mac_nstrtoul(argv[start_arg],
+						    mac_nstrlen(argv[start_arg]),
+						    &start_arg);
+			f_entry.ostc = mac_nstrtoul(argv[start_arg],
+						    mac_nstrlen(argv[start_arg]),
+						    &start_arg);
+			f_entry.ostpa = mac_nstrtoul(argv[start_arg],
+						     mac_nstrlen(argv[start_arg]),
+						     &start_arg);
+			f_entry.cic = mac_nstrtoul(argv[start_arg],
+						   mac_nstrlen(argv[start_arg]),
+						   &start_arg);
+			f_entry.ttsl = mac_nstrtoul(argv[start_arg],
+						    mac_nstrlen(argv[start_arg]),
+						    &start_arg);
+			f_entry.ttsh = mac_nstrtoul(argv[start_arg],
+						    mac_nstrlen(argv[start_arg]),
+						    &start_arg);
+			f_entry.rec_id = mac_nstrtoul(argv[start_arg],
+						      mac_nstrlen(argv[start_arg]),
+						      &start_arg);
+			gswss_set_txtstamp_fifo(ops, &f_entry);
 		} else if (!strcmp(argv[start_arg], "nco")) {
 			start_arg++;
 
@@ -717,6 +720,20 @@ int gswss_main(u32 argc, u8 *argv[])
 					   &start_arg);
 
 			gswss_set_clkmode(adap_ops, val);
+		} else if (!strcmp(argv[start_arg], "extts")) {
+			start_arg++;
+
+			trig0_sel = mac_nstrtoul(argv[start_arg],
+						 mac_nstrlen(argv[start_arg]),
+						 &start_arg);
+			trig1_sel = mac_nstrtoul(argv[start_arg],
+						 mac_nstrlen(argv[start_arg]),
+						 &start_arg);
+			sw_trig = mac_nstrtoul(argv[start_arg],
+					       mac_nstrlen(argv[start_arg]),
+					       &start_arg);
+			gswss_cfg1_1588(adap_ops,
+					trig1_sel, trig0_sel, sw_trig);
 		} else {
 			gswss_help();
 		}
@@ -1192,91 +1209,96 @@ int gswss_get_mtu(void *pdev)
 }
 
 int gswss_set_txtstamp_fifo(void *pdev,
-			    u8 ttse, u8 ostc, u8 ost_avail, u8 cic, u32 sec,
-			    u32 nsec, u32 record_id)
+			    struct mac_fifo_entry *f_entry)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	int ret = 0;
 	u16 val = 0;
 	u32 mac_txtstamp;
 
-	val = ((ttse << 4) | (ostc << 3) | (ost_avail << 2) | cic);
+	val = ((f_entry->ttse << 4) | (f_entry->ostc << 3) |
+	       (f_entry->ostpa << 2) | f_entry->cic);
 	GSWSS_MAC_RGWR(pdata, MAC_TXTS_CIC(pdata->mac_idx), val);
 
 	mac_txtstamp = MAC_TXTS_0(pdata->mac_idx);
-	val = GET_N_BITS(nsec, 0, 16);
+	val = GET_N_BITS(f_entry->ttsh, 0, 16);
 	GSWSS_MAC_RGWR(pdata, mac_txtstamp, val);
 
 	mac_txtstamp = MAC_TXTS_1(pdata->mac_idx);
-	val = GET_N_BITS(nsec, 16, 16);
+	val = GET_N_BITS(f_entry->ttsh, 16, 16);
 	GSWSS_MAC_RGWR(pdata, mac_txtstamp, val);
 
 	mac_txtstamp = MAC_TXTS_2(pdata->mac_idx);
-	val = GET_N_BITS(sec, 0, 16);
+	val = GET_N_BITS(f_entry->ttsl, 0, 16);
 	GSWSS_MAC_RGWR(pdata, mac_txtstamp, val);
 
 	mac_txtstamp = MAC_TXTS_3(pdata->mac_idx);
-	val = GET_N_BITS(sec, 16, 16);
+	val = GET_N_BITS(f_entry->ttsl, 16, 16);
 	GSWSS_MAC_RGWR(pdata, mac_txtstamp, val);
 
-	sec = ((GSWSS_MAC_RGRD(pdata, MAC_TXTS_1(pdata->mac_idx)) << 16) |
-	       GSWSS_MAC_RGRD(pdata, MAC_TXTS_0(pdata->mac_idx)));
-	nsec = ((GSWSS_MAC_RGRD(pdata, MAC_TXTS_3(pdata->mac_idx)) << 16) |
-		GSWSS_MAC_RGRD(pdata, MAC_TXTS_2(pdata->mac_idx)));
-
-	mac_printf("\nMAC%d: TxTstamp Fifo Record ID %d written\n",
-		   (pdata->mac_idx + 2), record_id);
+	mac_dbg("MAC%d: TxTstamp Fifo Record ID %d written\n",
+		(pdata->mac_idx + 2), f_entry->rec_id);
 
 	/* Write the entries into the 64 array record_id */
-	gswss_set_txtstamp_access(pdev, 1, record_id);
+	gswss_set_txtstamp_access(pdev, 1, f_entry->rec_id);
 
 	return ret;
 }
 
-void gswss_get_txtstamp_fifo(void *pdev, u32 record_id)
+void gswss_get_txtstamp_fifo(void *pdev,
+			     u32 record_id, struct mac_fifo_entry *f_entry)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_txtstamp, tstamp_cic;
-	u32 sec, nsec;
+	u32 mac_txtstamp;
 
 	gswss_set_txtstamp_access(pdev, 0, record_id);
-
+#if 0
 	mac_printf("\nMAC%d: TxTstamp Fifo Record ID %d:\n",
 		   (pdata->mac_idx + 2),
 		   record_id);
-
+#endif
 	mac_txtstamp = GSWSS_MAC_RGRD(pdata, MAC_TXTS_CIC(pdata->mac_idx));
 
+	f_entry->ttse = GET_N_BITS(mac_txtstamp, 4, 1);
+	f_entry->ostc = GET_N_BITS(mac_txtstamp, 3, 1);
+	f_entry->ostpa = GET_N_BITS(mac_txtstamp, 2, 1);
+	f_entry->cic = GET_N_BITS(mac_txtstamp, 0, 2);
+
+	f_entry->ttsl =
+		((GSWSS_MAC_RGRD(pdata, MAC_TXTS_1(pdata->mac_idx)) << 16) |
+		 GSWSS_MAC_RGRD(pdata, MAC_TXTS_0(pdata->mac_idx)));
+	f_entry->ttsh =
+		((GSWSS_MAC_RGRD(pdata, MAC_TXTS_3(pdata->mac_idx)) << 16) |
+		 GSWSS_MAC_RGRD(pdata, MAC_TXTS_2(pdata->mac_idx)));
+
+	f_entry->rec_id = record_id;
+
+#if 0
 	mac_printf("\tTTSE: \t%s\n",
-		   GET_N_BITS(mac_txtstamp, 4, 1) ? "ENABLED" : "DISABLED");
+		   f_entry->ttse ? "ENABLED" : "DISABLED");
 	mac_printf("\tOSTC: \t%s\n",
-		   GET_N_BITS(mac_txtstamp, 3, 1) ? "ENABLED" : "DISABLED");
+		   f_entry->ostc ? "ENABLED" : "DISABLED");
 	mac_printf("\tOSTPA: \t%s\n",
-		   GET_N_BITS(mac_txtstamp, 2, 1) ? "ENABLED" : "DISABLED");
-	tstamp_cic = GET_N_BITS(mac_txtstamp, 0, 2);
+		   f_entry->ostpa ? "ENABLED" : "DISABLED");
 
-	if (tstamp_cic == 0)
+	if (f_entry->cic == 0)
 		mac_printf("\tCIC: \t"
 			   "DISABLED\n");
 
-	if (tstamp_cic == 1)
+	if (f_entry->cic == 1)
 		mac_printf("\tCIC: \tTime stamp IP Checksum update\n");
 
-	if (tstamp_cic == 2)
+	if (f_entry->cic == 2)
 		mac_printf("\tCIC: \tTime stamp IP and "
 			   "Payload Checksum update\n");
 
-	if (tstamp_cic == 3)
+	if (f_entry->cic == 3)
 		mac_printf("\tCIC: \tTime stamp IP, Payload checksum and "
 			   "Pseudo header update\n");
 
-	sec = ((GSWSS_MAC_RGRD(pdata, MAC_TXTS_1(pdata->mac_idx)) << 16) |
-	       GSWSS_MAC_RGRD(pdata, MAC_TXTS_0(pdata->mac_idx)));
-	nsec = ((GSWSS_MAC_RGRD(pdata, MAC_TXTS_3(pdata->mac_idx)) << 16) |
-		GSWSS_MAC_RGRD(pdata, MAC_TXTS_2(pdata->mac_idx)));
-
-	mac_printf("\tSEC: \t%d\n", sec);
-	mac_printf("\tNSEC:\t%d\n", nsec);
+	mac_printf("\tTTSL: \t%d\n", f_entry->ttsl);
+	mac_printf("\tTTSH: \t%d\n", f_entry->ttsh);
+#endif
 }
 
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.h b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.h
index cd204c383f1f..1d2ffdfaf0a8 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/gswss_mac_api.h
@@ -272,9 +272,10 @@ void gswss_get_macif(void *pdev);
 int gswss_get_mac_en(void *pdev);
 int gswss_get_mac_reset(void *pdev);
 int gswss_set_txtstamp_fifo(void *pdev,
-			    u8 ttse, u8 ostc, u8 ost_avail, u8 cic, u32 sec,
-			    u32 nsec, u32 record_id);
-void gswss_get_txtstamp_fifo(void *pdev, u32 record_id);
+			    struct mac_fifo_entry *f_entry);
+void gswss_get_txtstamp_fifo(void *pdev,
+			     u32 record_id, struct mac_fifo_entry *f_entry);
+
 int gswss_set_eee_cap(void *pdev, u32 val);
 
 #endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.c b/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.c
index 40a7cd4bc2c8..cc3a5190a9b1 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/lmac_api.c
@@ -524,85 +524,85 @@ int lmac_clear_int(void *pdev, u32 event)
 
 	if ((event & LMAC_PHYERR_EVNT) &&
 	    (MAC_GET_VAL(mac_isr, MAC_PISR, PHYERR))) {
-		mac_printf("LMAC %d Clearing PHYERR Interrupt Status\n",
-			   pdata->mac_idx);
+		mac_dbg("LMAC %d Clearing PHYERR Interrupt Status\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_isr, MAC_PISR, PHYERR, 1);
 	}
 
 	if ((event & LMAC_ALIGN_EVNT) &&
 	    (MAC_GET_VAL(mac_isr, MAC_PISR, ALIGN))) {
-		mac_printf("LMAC %d Clearing ALIGN Interrupt Status\n",
-			   pdata->mac_idx);
+		mac_dbg("LMAC %d Clearing ALIGN Interrupt Status\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_isr, MAC_PISR, ALIGN, 1);
 	}
 
 	if ((event & LMAC_SPEED_EVNT) &&
 	    (MAC_GET_VAL(mac_isr, MAC_PISR, SPEED))) {
-		mac_printf("LMAC %d Clearing SPEED Interrupt Status\n",
-			   pdata->mac_idx);
+		mac_dbg("LMAC %d Clearing SPEED Interrupt Status\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_isr, MAC_PISR, SPEED, 1);
 	}
 
 	if ((event & LMAC_FDUP_EVNT) &&
 	    (MAC_GET_VAL(mac_isr, MAC_PISR, FDUP))) {
-		mac_printf("LMAC %d Clearing FDUP Interrupt Status\n",
-			   pdata->mac_idx);
+		mac_dbg("LMAC %d Clearing FDUP Interrupt Status\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_isr, MAC_PISR, FDUP, 1);
 	}
 
 	if ((event & LMAC_RXPAUEN_EVNT) &&
 	    (MAC_GET_VAL(mac_isr, MAC_PISR, RXPAUEN))) {
-		mac_printf("LMAC %d Clearing RXPAUEN Interrupt Status\n",
-			   pdata->mac_idx);
+		mac_dbg("LMAC %d Clearing RXPAUEN Interrupt Status\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_isr, MAC_PISR, RXPAUEN, 1);
 	}
 
 	if ((event & LMAC_TXPAUEN_EVNT) &&
 	    (MAC_GET_VAL(mac_isr, MAC_PISR, TXPAUEN))) {
-		mac_printf("LMAC %d Clearing TXPAUEN Interrupt Status\n",
-			   pdata->mac_idx);
+		mac_dbg("LMAC %d Clearing TXPAUEN Interrupt Status\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_isr, MAC_PISR, TXPAUEN, 1);
 	}
 
 	if ((event & LMAC_LPIOFF_EVNT) &&
 	    (MAC_GET_VAL(mac_isr, MAC_PISR, LPIOFF))) {
-		mac_printf("LMAC %d Clearing LPIOFF Interrupt Status\n",
-			   pdata->mac_idx);
+		mac_dbg("LMAC %d Clearing LPIOFF Interrupt Status\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_isr, MAC_PISR, LPIOFF, 1);
 	}
 
 	if ((event & LMAC_LPION_EVNT) &&
 	    (MAC_GET_VAL(mac_isr, MAC_PISR, LPION))) {
-		mac_printf("LMAC %d Clearing LPION Interrupt Status\n",
-			   pdata->mac_idx);
+		mac_dbg("LMAC %d Clearing LPION Interrupt Status\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_isr, MAC_PISR, LPION, 1);
 	}
 
 	if ((event & LMAC_JAM_EVNT) &&
 	    (MAC_GET_VAL(mac_isr, MAC_PISR, JAM))) {
-		mac_printf("LMAC %d Clearing JAM Interrupt Status\n",
-			   pdata->mac_idx);
+		mac_dbg("LMAC %d Clearing JAM Interrupt Status\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_isr, MAC_PISR, JAM, 1);
 	}
 
 	if ((event & LMAC_FCSERR_EVNT) &&
 	    (MAC_GET_VAL(mac_isr, MAC_PISR, FCSERR))) {
-		mac_printf("LMAC %d Clearing FCSERR Interrupt Status\n",
-			   pdata->mac_idx);
+		mac_dbg("LMAC %d Clearing FCSERR Interrupt Status\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_isr, MAC_PISR, FCSERR, 1);
 	}
 
 	if ((event & LMAC_TXPAU_EVNT) &&
 	    (MAC_GET_VAL(mac_isr, MAC_PISR, TXPAUSE))) {
-		mac_printf("LMAC %d Clearing TXPAUSE Interrupt Status\n",
-			   pdata->mac_idx);
+		mac_dbg("LMAC %d Clearing TXPAUSE Interrupt Status\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_isr, MAC_PISR, TXPAUSE, 1);
 	}
 
 	if ((event & LMAC_RXPAU_EVNT) &&
 	    (MAC_GET_VAL(mac_isr, MAC_PISR, RXPAUSE))) {
-		mac_printf("LMAC %d Clearing RXPAUSE Interrupt Status\n",
-			   pdata->mac_idx);
+		mac_dbg("LMAC %d Clearing RXPAUSE Interrupt Status\n",
+			pdata->mac_idx);
 		MAC_SET_VAL(mac_isr, MAC_PISR, RXPAUSE, 1);
 	}
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.c b/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.c
index 555f76f38f26..1073460144b1 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.c
@@ -11,6 +11,11 @@
 #include <gswss_mac_api.h>
 #include <lmac_api.h>
 #include <xgmac_mdio.h>
+#include <xgmac_ptp.h>
+#ifdef __KERNEL__
+#include <net/switch_api/lantiq_gsw_api.h>
+#include <net/switch_api/gsw_dev.h>
+#endif
 
 int mac_set_flowctrl(void *pdev, u32 val)
 {
@@ -690,27 +695,56 @@ int mac_get_fcs_gen(void *pdev)
 	return tx_fcs;
 }
 
-/*TTSE: Enables the IEEE 1588 hw ts for Tx Frame
- *OSTC: One step ts correction with ref to ts provided in TTSH and TTSL
- *OST_AVAIl: It indicates ref ts is available in TTSH and TTSL
- *CIC:
- *	0: Csum Insertion disabled
- *	1: Only IP hdr csum calc and insert enabled
- *	2: IP hdr csum, Payload csum calc and insertion enabled,
- *		pseudo hdr csum is not calc in HW
- *	3: IP hdr csum, Payload csum calc and insertion enabled,
- *		pseudo hdr csum is calc in HW
+/* Enables the Attachment of timestamp in Rx Direction and
+ * Removal of Special tag in Tx Direction
  */
-int mac_enable_onestep_ts(void *pdev)
+int mac_enable_ts(void *pdev)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-
 #ifdef __KERNEL__
+	struct core_ops *ops = gsw_get_swcore_ops(0);
+	GSW_CPU_PortCfg_t cpu_port_cfg;
+#if IS_ENABLED(CONFIG_LTQ_DATAPATH_PTP1588_SW_WORKAROUND)
+	int pce_rule_id = 0;
+	GSW_PCE_rule_t pce;
+#endif
+
+	if (!ops) {
+		mac_printf("Open SWAPI device FAILED!\n");
+		return -1;
+	}
+
+	memset((void *)&cpu_port_cfg, 0x00, sizeof(cpu_port_cfg));
+
+	/* Enable the Egress Special Tag */
+	ops->gsw_common_ops.CPU_PortCfgGet(ops, &cpu_port_cfg);
+	cpu_port_cfg.nPortId = (pdata->mac_idx + 2);
+	cpu_port_cfg.bSpecialTagIngress = 1;
+	cpu_port_cfg.bSpecialTagEgress = 1;
+	ops->gsw_common_ops.CPU_PortCfgSet(ops, &cpu_port_cfg);
+
+#if IS_ENABLED(CONFIG_LTQ_DATAPATH_PTP1588_SW_WORKAROUND)
+	/* All RX packets in GSWIP currently have PTP=1 */
+	memset(&pce, 0, sizeof(pce));
+	pce.pattern.nIndex = pce_rule_id;
+	pce.pattern.bEnable = 1;
+	pce.action.eTimestampAction = 2;
+	ops->gsw_tflow_ops.TFLOW_PceRuleWrite(ops, &pce);
+#endif
 	spin_lock_bh(&pdata->mac_lock);
 #endif
+
+	//mac_printf("MAC %d: Enable Timestamp operations\n", pdata->mac_idx);
+
+	/* Tell adaption layer to attach Timestamp */
 	gswss_set_mac_rxtime_op(pdev, MODE1);
+
+	/* Tell adaption layer to remove Special Tag in Tx Directon */
 	gswss_set_mac_txsptag_op(pdev, MODE3);
 
+	mac_int_enable(pdev);
+	xgmac_set_mac_int(pdev, XGMAC_TSTAMP_EVNT, 1);
+
 #ifdef __KERNEL__
 	spin_unlock_bh(&pdata->mac_lock);
 #endif
@@ -718,19 +752,40 @@ int mac_enable_onestep_ts(void *pdev)
 	return 0;
 }
 
-int mac_disable_onestep_ts(void *pdev)
+int mac_disable_ts(void *pdev)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 
 #ifdef __KERNEL__
+
+	GSW_CPU_PortCfg_t cpu_port_cfg;
+	struct core_ops *ops = gsw_get_swcore_ops(0);
+
+	if (!ops) {
+		pr_err("%s: Open SWAPI device FAILED!\n", __func__);
+		return -EIO;
+	}
+
+	memset((void *)&cpu_port_cfg, 0x00, sizeof(cpu_port_cfg));
+
+	/* Disable the Egress Special Tag */
+	ops->gsw_common_ops.CPU_PortCfgGet(ops, &cpu_port_cfg);
+	cpu_port_cfg.nPortId = (pdata->mac_idx + 2);
+	cpu_port_cfg.bSpecialTagEgress = 0;
+	ops->gsw_common_ops.CPU_PortCfgSet(ops, &cpu_port_cfg);
+
 	spin_lock_bh(&pdata->mac_lock);
 #endif
+	mac_printf("MAC %d: Disable Timestamp operations\n", pdata->mac_idx);
+
 	gswss_set_mac_rxtime_op(pdev, MODE0);
 	gswss_set_mac_txsptag_op(pdev, MODE0);
 	gswss_set_mac_rxsptag_op(pdev, MODE0);
 
 	xgmac_disable_tstamp(pdev);
 
+	xgmac_set_mac_int(pdev, XGMAC_TSTAMP_EVNT, 0);
+
 #ifdef __KERNEL__
 	spin_unlock_bh(&pdata->mac_lock);
 #endif
@@ -843,6 +898,9 @@ int mac_init(void *pdev)
 
 	mac_printf("XGMAC INIT for Module %d\n", pdata->mac_idx);
 
+	/* Get all hw capability */
+	xgmac_get_hw_capability(pdev);
+	
 	/* Initialize MAC related features */
 
 	/* Program MAC Address */
@@ -911,6 +969,7 @@ int mac_init(void *pdev)
 	/* Filter pause frames from XGMAC */
 	xgmac_pause_frame_filtering(pdev, 1);
 #endif
+	fifo_init(pdev);
 
 	/* EEE Capability Turn OFF as Aquania OnBoard Phy and SFP+ will go down
 	 * with EEE Capability ON/Auto.
@@ -924,6 +983,9 @@ int mac_init(void *pdev)
 	xgmac_mdio_register(pdev);
 #endif
 
+#ifdef CONFIG_PTP_1588_CLOCK
+	xgmac_ptp_init(pdev);
+#endif
 
 	return 0;
 }
@@ -1199,7 +1261,13 @@ void mac_init_fn_ptrs(struct mac_ops *mac_op)
 	mac_op->lmac_reg_rd = lmac_rd_reg;
 	mac_op->lmac_reg_wr = lmac_wr_reg;
 
-
+#ifdef __KERNEL__
+	mac_op->set_hwts = xgmac_set_hwts;
+	mac_op->get_hwts = xgmac_get_hwts;
+	mac_op->do_rx_hwts = xgmac_rx_hwts;
+	mac_op->do_tx_hwts = xgmac_tx_hwts;
+	mac_op->mac_get_ts_info = xgmac_get_ts_info;
+#endif
 	mac_op->mac_int_en = mac_int_enable;
 	mac_op->mac_int_dis = mac_int_disable;
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.h b/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.h
index 46d25a0a7f0b..d70a8167dfaf 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_cfg.h
@@ -50,8 +50,8 @@ int mac_get_linksts(void *pdev);
 int mac_set_fcs_gen(void *pdev, u32 val);
 int mac_get_fcs_gen(void *pdev);
 
-int mac_enable_onestep_ts(void *pdev);
-int mac_disable_onestep_ts(void *pdev);
+int mac_enable_ts(void *pdev);
+int mac_disable_ts(void *pdev);
 
 int mac_irq_enable(void *pdev, GSW_Irq_Op_t *irq);
 int mac_irq_disable(void *pdev, GSW_Irq_Op_t *irq);
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c b/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c
index e2f41ffe74a2..9ddaf5ef06e7 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_drv.c
@@ -14,6 +14,8 @@
 #include <xgmac_common.h>
 #include <xgmac.h>
 #include <lmac_api.h>
+#include <linux/clk.h>
+
 
 static void __iomem *base[2];
 
@@ -140,6 +142,7 @@ static int mac_probe(struct platform_device *pdev)
 	struct adap_prv_data *adap_pdata = GET_ADAP_PDATA(gswdev->adap_ops);
 	struct mac_prv_data *pdata =
 		GET_MAC_PDATA(platform_get_drvdata(pdev));
+	struct device *dev = &pdev->dev;
 
 	gswdev->mac_dev[pdev->id] = pdev;
 
@@ -168,12 +171,22 @@ static int mac_probe(struct platform_device *pdev)
 
 	pdata->max_mac = gsw_get_mac_subifcnt(0);
 
-	if (device_property_present(&pdev->dev, "board_type")) {
+	if (device_property_present(dev, "board_type")) {
 		pr_info("Board Type: HAPS\n");
 		pdata->haps = 1;
 	} else
 		pdata->haps = 0;
 
+	pdata->ker_ptp_clk = devm_clk_get(dev, "ptp_clk");
+
+	if (IS_ERR(pdata->ker_ptp_clk)) {
+		dev_err(dev, "Failed to get MAC %d ptp clock!\n",
+			pdata->mac_idx);
+		return -EINVAL;
+	}
+
+	pdata->ptp_clk = (u32)clk_get_rate(pdata->ker_ptp_clk);
+
 	/* Init function fointers */
 	mac_init_fn_ptrs(&pdata->ops);
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.c b/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.c
new file mode 100644
index 000000000000..065d85aeb260
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.c
@@ -0,0 +1,223 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017, 2018 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#include <xgmac.h>
+#include <gswss_mac_api.h>
+#include <mac_tx_fifo.h>
+
+static int fifo_freeid_get(void *pdev, u8 ttse);
+void fifo_entry_timeout(unsigned long data);
+static void fifo_update_hw_clrsts(void *pdev,
+				  struct mac_fifo_entry *f_entry);
+
+u32 fifo_init(void *pdev)
+{
+	int i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	memset(pdata->ts_fifo, 0, sizeof(pdata->ts_fifo));
+
+	for (i = START_FIFO; i < MAX_FIFO_ENTRY; i++) {
+		pdata->ts_fifo[i].rec_id = i;
+#ifdef __KERNEL__
+		init_timer(&pdata->ts_fifo[i].timer);
+#endif
+	}
+
+	return 0;
+}
+
+int fifo_entry_add(void *pdev, u8 ttse, u8 ostc, u8 ostpa, u8 cic,
+		   u32 ttsl, u32 ttsh)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	int id;
+	struct mac_fifo_entry *f_entry;
+
+	id = fifo_freeid_get(pdev, ttse);
+
+	if (id == FIFO_FULL)
+		return id;
+
+	f_entry = &pdata->ts_fifo[id];
+
+#ifdef __KERNEL__
+
+	if (f_entry->ttse || f_entry->ostc || f_entry->ostpa || f_entry->cic) {
+		/* if previously there was a timer running, and timeout */
+		del_timer_sync(&f_entry->timer);
+	}
+
+#endif
+	f_entry->ttse = ttse;
+	f_entry->ostc = ostc;
+	f_entry->ostpa = ostpa;
+	f_entry->cic = cic;
+	f_entry->ttsl = ttsl;
+	f_entry->ttsh = ttsh;
+	f_entry->timeout = FIFO_TIMEOUT_IN_SEC;
+	f_entry->is_used = 1;
+
+#ifdef __KERNEL__
+	setup_timer(&f_entry->timer, fifo_entry_timeout,
+		    (unsigned long)f_entry);
+	f_entry->timer.expires = jiffies + (f_entry->timeout * HZ) - 1;
+	add_timer(&f_entry->timer);
+	f_entry->jiffies = jiffies;
+#endif
+
+	gswss_set_txtstamp_fifo(pdev, f_entry);
+
+	return f_entry->rec_id;
+}
+
+void fifo_entry_del(void *pdev, u32 rec_id)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_fifo_entry *f_entry = &pdata->ts_fifo[rec_id];
+
+#ifdef __KERNEL__
+	/* Delete timer */
+	del_timer_sync(&f_entry->timer);
+	f_entry->timer.expires = 0;
+#endif
+	f_entry->ttse = 0;
+	f_entry->ostc = 0;
+	f_entry->ostpa = 0;
+	f_entry->cic = 0;
+	f_entry->ttsl = 0;
+	f_entry->ttsh = 0;
+
+	/* Fifo available for the next packet */
+	f_entry->is_used = 0;
+
+	return;
+}
+
+static void fifo_update_hw_clrsts(void *pdev,
+				  struct mac_fifo_entry *f_entry)
+{
+	gswss_get_txtstamp_fifo(pdev, f_entry->rec_id, f_entry);
+
+	/* HW has cleared the entry before timeout
+	 * Delete the timeout and the entry
+	 */
+	if (f_entry->ostc == 0 &&
+	    f_entry->ostpa == 0 &&
+	    f_entry->ttse == 0 &&
+	    f_entry->cic == 0 &&
+	    f_entry->ttsl == 0 &&
+	    f_entry->ttsh == 0) {
+		fifo_entry_del(pdev, f_entry->rec_id);
+	}
+}
+
+void fifo_isr_handler(void *pdev)
+{
+	int i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	mac_printf("Fifo isr handler\n");
+
+	for (i = START_FIFO; i < MAX_FIFO_ENTRY; i++) {
+		if (pdata->ts_fifo[i].is_used)
+			fifo_update_hw_clrsts(pdev, &pdata->ts_fifo[i]);
+	}
+
+	return;
+}
+
+
+u32 timer_in_sec(u32 jiffies)
+{
+#ifdef __KERNEL__
+	return ((jiffies + HZ / 2) / HZ);
+#else
+	return 0;
+#endif
+}
+
+void print_fifo(void *pdev)
+{
+	int i = 0;
+	struct mac_fifo_entry f_entry;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	mac_printf("%12s %12s %12s %12s %12s %12s %12s %12s\n",
+		   "REC_ID", "TTSE", "OSTC", "OSTPA", "CIC", "TTSL", "TTSH", "TIMEOUT");
+
+	for (i = START_FIFO; i < MAX_FIFO_ENTRY; i++) {
+		gswss_get_txtstamp_fifo(pdev, i, &f_entry);
+
+		if (!pdata->ts_fifo[i].is_used)
+			continue;
+
+#ifdef __KERNEL__
+		mac_printf("%12d %12d %12d %12d %12d %12d %12d %12d\n",
+			   f_entry.rec_id, f_entry.ttse, f_entry.ostc,
+			   f_entry.ostpa, f_entry.cic,
+			   f_entry.ttsl, f_entry.ttsh,
+			   (pdata->ts_fifo[i].timer.expires ?
+			    (pdata->ts_fifo[i].timeout -
+			     (timer_in_sec(jiffies) -
+			      timer_in_sec(pdata->ts_fifo[i].jiffies))) : 0));
+#else
+		mac_printf("%12d %12d %12d %12d %12d %12d %12d %12d\n",
+			   f_entry.rec_id, f_entry.ttse, f_entry.ostc,
+			   f_entry.ostpa, f_entry.cic,
+			   f_entry.ttsl, f_entry.ttsh,
+			   pdata->ts_fifo[i].jiffies);
+#endif
+	}
+
+	return;
+}
+
+static int fifo_freeid_get(void *pdev, u8 ttse)
+{
+	int i = FIFO_FULL;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_fifo_cnt = 0;
+
+	for (i = START_FIFO; i < MAX_FIFO_ENTRY; i++) {
+		if (!pdata->ts_fifo[i].is_used) {
+			if (ttse) {
+				mac_fifo_cnt = XGMAC_RGRD_BITS(pdata,
+							       MAC_TSTAMP_STSR,
+							       TTSNS);
+			}
+
+			/* If nothing stored in Xgmac Fifo */
+			if (mac_fifo_cnt == 0)
+				return pdata->ts_fifo[i].rec_id;
+			else {
+				mac_printf("Xgmac Fifo already have entry\n");
+				return FIFO_FULL;
+			}
+		} else {
+			fifo_update_hw_clrsts(pdev, &pdata->ts_fifo[i]);
+		}
+	}
+
+	return FIFO_FULL;
+}
+
+/* Timeout handler, Called when Fifo entry timeout
+ * This happens when packet is dropped by cqem or some other reason packet lost
+ */
+void fifo_entry_timeout(unsigned long data)
+{
+	struct mac_fifo_entry *f_entry  = (struct mac_fifo_entry *)data;
+
+	//mac_printf("RecordID in timeout %d \n", f_entry->rec_id);
+
+	/* Mark this Fifo entry can be used again */
+	f_entry->is_used = 0;
+}
+
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.h b/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.h
new file mode 100644
index 000000000000..6c2f47bd0e4b
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/mac_tx_fifo.h
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *                Copyright (c) 2016, 2017, 2018 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_TXFIFO_H
+#define _MAC_TXFIFO_H
+
+#define FIFO_TIMEOUT_IN_SEC         	100     /*  5 minute */
+#define MAX_FIFO_ENTRY			64
+#define START_FIFO			1
+
+enum {
+	FIFO_FULL = -1,
+	FIFO_ENTRY_AVAIL = -2,
+	FIFO_ENTRY_NOT_AVAIL = -3,
+};
+
+struct mac_fifo_entry {
+	u32 is_used;
+	u32 rec_id;
+	u8 ttse;
+	u8 ostc;
+	u8 ostpa;
+	u8 cic;
+	u32 ttsl;
+	u32 ttsh;
+	u32 timeout;
+	u32 jiffies;
+#ifdef __KERNEL__
+	struct timer_list timer;
+#endif
+};
+
+
+u32 fifo_init(void *pdev);
+int fifo_entry_add(void *pdev, u8 ttse, u8 ostc, u8 ostpa, u8 cic,
+		   u32 ttsl, u32 ttsh);
+void fifo_entry_del(void *pdev, u32 rec_id);
+void fifo_isr_handler(void *pdev);
+void print_fifo(void *pdev);
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h
index 3a666a88e87b..4e4d72c919af 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac.h
@@ -66,11 +66,9 @@
 // PTP Clock in Mhz
 #define PTP_CLK				500
 
-// Seconds value to increment in nsec
-#define XGMAC_TSTAMP_SSINC		(1000 / PTP_CLK)
 #define XGMAC_TSTAMP_SNSINC		0
 
-#define NSEC_TO_SEC			1000000000L
+#define NSEC_TO_SEC			1000000000
 
 #define MHZ_TO_HZ(val)			((val) * 1000000)
 
@@ -118,6 +116,10 @@
 #define MAC_TXTSTAMP_NSECR		0x0d30
 #define MAC_TXTSTAMP_SECR		0x0d34
 #define MAC_TXTSTAMP_STS		0x0d38
+#define MAC_AUX_CTRL			0x0d40
+#define MAC_AUX_NSEC			0x0d48
+#define MAC_AUX_SEC			0x0d4c
+#define MAC_RX_PCH_CRC_CNT		0x0d2c
 
 /* MTL register offsets */
 #define MTL_OMR				0x1000
@@ -139,7 +141,6 @@
 #define MTL_Q_ISR			0x1174
 
 
-
 #define MAC_LPS_TLPIEN			0x00000001
 #define MAC_LPS_TLPIEX			0x00000002
 #define MAC_LPS_RLPIEN			0x00000004
@@ -153,7 +154,16 @@
 #define XGMAC_CTRL_REG_BAS_POS		15
 #define XGMAC_CTRL_REG_BAS_WIDTH	1
 
-
+#define MAC_AUX_CTRL_ATSFC_POS		0
+#define MAC_AUX_CTRL_ATSFC_WIDTH	1
+#define MAC_AUX_CTRL_ATSEN0_POS		4
+#define MAC_AUX_CTRL_ATSEN0_WIDTH	1
+#define MAC_AUX_CTRL_ATSEN1_POS		5
+#define MAC_AUX_CTRL_ATSEN1_WIDTH	1
+#define MAC_AUX_CTRL_ATSEN2_POS		6
+#define MAC_AUX_CTRL_ATSEN2_WIDTH	1
+#define MAC_AUX_CTRL_ATSEN3_POS		7
+#define MAC_AUX_CTRL_ATSEN3_WIDTH	1
 
 /* MAC register entry bit positions and sizes */
 #define MAC_HW_F0_ADDMACADRSEL_POS      18
@@ -455,6 +465,8 @@
 #define MAC_TSTAMP_CR_TSTRIG_WIDTH           1
 #define MAC_TSTAMP_CR_TSUPDT_POS             3
 #define MAC_TSTAMP_CR_TSUPDT_WIDTH           1
+#define MAC_TSTAMP_CR_ESTI_POS               20
+#define MAC_TSTAMP_CR_ESTI_WIDTH             1
 
 #define MAC_TSTAMP_STSR_ATSNS_POS              25
 #define MAC_TSTAMP_STSR_ATSNS_WIDTH            5
@@ -1015,7 +1027,8 @@ int xgmac_set_gint(void *pdev, u32 val);
 int xgmac_set_rxcrc(void *pdev, u32 val);
 
 /* GET API's */
-int xgmac_get_all_hw_features(void *pdev);
+int xgmac_get_hw_capability(void *pdev);
+int xgmac_print_hw_cap(void *pdev);
 int xgmac_dbg_eee_status(void *pdev);
 int xgmac_get_priv_data(void *pdev);
 int xgmac_get_stats(void *pdev);
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_cli.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_cli.c
index 8f54bc79b9af..f91de1a1ba2e 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_cli.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_cli.c
@@ -44,6 +44,7 @@
 #include <gswss_mac_api.h>
 #include <lmac_api.h>
 #include <xgmac_mdio.h>
+#include <mac_tx_fifo.h>
 
 void cli_set_mtl_tx(void *pdev)
 {
@@ -127,10 +128,10 @@ void cli_set_tstamp_enable(void *pdev)
 	if (pdata->set_all) {
 		for (i = 0; i < pdata->max_mac; i++) {
 			ops = gsw_get_mac_ops(0, i);
-			mac_enable_onestep_ts(ops);
+			mac_enable_ts(ops);
 		}
 	} else {
-		mac_enable_onestep_ts(pdev);
+		mac_enable_ts(pdev);
 	}
 }
 
@@ -143,10 +144,10 @@ void cli_set_tstamp_disable(void *pdev)
 	if (pdata->set_all) {
 		for (i = 0; i < pdata->max_mac; i++) {
 			ops = gsw_get_mac_ops(0, i);
-			mac_disable_onestep_ts(ops);
+			mac_disable_ts(ops);
 		}
 	} else {
-		mac_disable_onestep_ts(pdev);
+		mac_disable_ts(pdev);
 	}
 }
 
@@ -318,10 +319,12 @@ void cli_set_int(void *pdev)
 	if (pdata->set_all) {
 		for (i = 0; i < pdata->max_mac; i++) {
 			ops = gsw_get_mac_ops(0, i);
+			mac_int_enable(ops);
 			xgmac_set_mac_int(ops, pdata->enable_mac_int, 1);
 			xgmac_set_mtl_int(ops, pdata->enable_mtl_int);
 		}
 	} else {
+		mac_int_enable(pdev);
 		xgmac_set_mac_int(pdev, pdata->enable_mac_int, 1);
 		xgmac_set_mtl_int(pdev, pdata->enable_mtl_int);
 	}
@@ -954,6 +957,57 @@ void cli_set_rxcrc(void *pdev)
 		xgmac_set_rxcrc(pdev, pdata->val);
 	}
 }
+
+int cli_get_fifo(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			print_fifo(ops);
+		}
+	} else {
+		print_fifo(pdev);
+	}
+
+	return 0;
+}
+
+void cli_add_fifo(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			fifo_entry_add(ops, 1, 1, 1, 0, 0, 0);
+		}
+	} else {
+		fifo_entry_add(pdev, 1, 1, 1, 0, 0, 0);
+	}
+}
+
+void cli_del_fifo(void *pdev)
+{
+	u32 i = 0;
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	struct mac_ops *ops;
+
+	if (pdata->set_all) {
+		for (i = 0; i < pdata->max_mac; i++) {
+			ops = gsw_get_mac_ops(0, i);
+			fifo_entry_del(ops, pdata->rec_id);
+		}
+	} else {
+		fifo_entry_del(pdev, pdata->rec_id);
+	}
+}
+
 void cli_test_all_reg(void *pdev)
 {
 	lmac_test_all_reg(pdev);
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_cli.h b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_cli.h
index 7ef75c34d18f..5e8c8e222fed 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_cli.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_cli.h
@@ -103,6 +103,9 @@ int cli_get_rmon(void *pdev);
 void cli_set_pause_frame_filter(void *pdev);
 void cli_set_gint(void *pdev);
 void cli_set_rxcrc(void *pdev);
+int cli_get_fifo(void *pdev);
+void cli_add_fifo(void *pdev);
+void cli_del_fifo(void *pdev);
 
 #endif
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h
index 66edc6f75615..4eaea46696f7 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_common.h
@@ -102,7 +102,7 @@
 #include <adap_ops.h>
 #include <types.h>
 #endif
-
+#include <mac_tx_fifo.h>
 
 #if defined(PC_UTILITY) && PC_UTILITY
 extern int pc_uart_dataread(u32 Offset, u32 *value);
@@ -186,11 +186,19 @@ FILE *get_fp(void);
 		fp = (FILE *) get_fp();	\
 		fprintf(fp, __VA_ARGS__); \
 	} while (0)
+
+#define mac_dbg(...)		\
+	do { FILE *fp;			\
+		fp = (FILE *) get_fp(); \
+		fprintf(fp, __VA_ARGS__); \
+	} while (0)
 #else
 #define mac_printf printf
+#define mac_dbg printf
 #endif
 #else
 #define mac_printf printk
+#define mac_dbg pr_debug
 #endif
 
 static inline int mac_nstrlen(char *s)
@@ -560,9 +568,10 @@ struct mac_prv_data {
 	u32 sec;
 	u32 nsec;
 	u32 one_nsec_accuracy;
-	u32 two_step;
 	u32 cic;
 	u32 rec_id;
+	struct mac_fifo_entry ts_fifo[MAX_FIFO_ENTRY];
+
 #ifdef __KERNEL__
 	/* will be pointing to skb which is
 	 * queued for transmission and device
@@ -574,18 +583,17 @@ struct mac_prv_data {
 	struct ptp_clock_info ptp_clk_info;
 	spinlock_t ptp_lock;
 	struct ptp_clock *ptp_clock;
-	u32 ptp_tx_init;
 	spinlock_t mac_lock;
 	struct mii_bus *mii;
 	struct phy_device *phydev;
 	struct tasklet_struct mac_tasklet;
+	struct clk *ker_ptp_clk;
 #endif
+	u32 exts0_enabled;
+	u32 exts1_enabled;
 	u32 snaptype;
 	u32 tsmstrena;
 	u32 tsevntena;
-	u32 ttse;
-	u32 ostc;
-	u32 ostc_avail;
 
 	/* Hardware features of the device */
 	struct xgmac_hw_features hw_feat;
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_debug.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_debug.c
index a74bc63b7fcf..e4efee5c515d 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_debug.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_debug.c
@@ -1948,96 +1948,61 @@ int xgmac_get_priv_data(void *pdev)
 	return 0;
 }
 
-int xgmac_get_all_hw_features(void *pdev)
+int xgmac_print_hw_cap(void *pdev)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u32 mac_hfr0, mac_hfr1, mac_hfr2;
 	/* Hardware features of the device */
 	struct xgmac_hw_features *hw_feat = &pdata->hw_feat;
 
-	mac_hfr0 = XGMAC_RGRD(pdata, MAC_HW_F0);
-	mac_hfr1 = XGMAC_RGRD(pdata, MAC_HW_F1);
-	mac_hfr2 = XGMAC_RGRD(pdata, MAC_HW_F2);
-
-	memset(hw_feat, 0, sizeof(*hw_feat));
-
-	hw_feat->version = XGMAC_RGRD(pdata, MAC_VR);
-
-	/* Hardware feature register 0 */
 	mac_printf("========== Hardware feature register 0 ==============\n");
-	hw_feat->gmii        = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, GMIISEL);
 
 	if (hw_feat->gmii)
 		mac_printf("\t 1Gbps Supported\n");
 
-	hw_feat->vlhash      = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, VLHASH);
-
 	if (hw_feat->vlhash)
 		mac_printf("\t Enable Address Filter VLAN Hash Table "
 			   "option is selected.\n");
 
-	hw_feat->sma         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, SMASEL);
-
 	if (hw_feat->sma)
 		mac_printf("\t Enable Station Management Block "
 			   "(MDIO Interface) option is selected.\n");
 
-	hw_feat->rwk         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, RWKSEL);
-
 	if (hw_feat->rwk)
 		mac_printf("\t Enable Remote Wake-Up Packet Detection "
 			   "option is selected\n");
 
-	hw_feat->mgk         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, MGKSEL);
-
 	if (hw_feat->mgk)
 		mac_printf("\t Enable Magic Packet Detection option "
 			   "is selected.\n");
 
-	hw_feat->mmc         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, MMCSEL);
-
 	if (hw_feat->mmc)
 		mac_printf("\t Enable XGMAC Management Counter (MMC) option "
 			   "is selected.\n");
 
-	hw_feat->aoe         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, ARPOFFSEL);
-
 	if (hw_feat->aoe)
 		mac_printf("\t Enable IPv4 ARP Offload option "
 			   "is selected\n");
 
-	hw_feat->ts          = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, TSSEL);
-
 	if (hw_feat->ts)
 		mac_printf("\t Enable IEEE 1588 Timestamp Support option "
 			   "is selected.\n");
 
-	hw_feat->eee         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, EEESEL);
-
 	if (hw_feat->eee)
 		mac_printf("\t Enable Energy Efficient Ethernet (EEE) option "
 			   "is selected.\n");
 
-	hw_feat->tx_coe      = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, TXCOESEL);
-
 	if (hw_feat->tx_coe)
 		mac_printf("\t Enable Transmit TCP/IP Checksum Offload option"
 			   "is selected.\n");
 
-	hw_feat->rx_coe      = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, RXCOESEL);
-
 	if (hw_feat->rx_coe)
 		mac_printf("\t Enable Receive TCP/IP Checksum Check option"
 			   "is selected.\n");
 
-	hw_feat->addn_mac   = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, ADDMACADRSEL);
-
 	if (hw_feat->addn_mac)
 		mac_printf("\t Number of additional MAC addresses "
 			   "selected = %d\n", hw_feat->addn_mac);
 
-	hw_feat->ts_src      = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, TSSTSSEL);
-
 	if (hw_feat->ts_src) {
 		if (hw_feat->ts_src == 1)
 			mac_printf("\t Time Stamp time source: INTERNAL\n");
@@ -2050,66 +2015,43 @@ int xgmac_get_all_hw_features(void *pdev)
 		mac_printf("\t Time Stamp time source: RESERVED\n");
 	}
 
-	hw_feat->sa_vlan_ins = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, SAVLANINS);
-
 	if (hw_feat->sa_vlan_ins)
 		mac_printf("\t Enable SA and VLAN Insertion on "
 			   "Tx option is selected.\n");
 
-	hw_feat->vxn = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, VXN);
-
 	if (hw_feat->vxn)
 		mac_printf("\t Support for VxLAN/NVGRE is selected\n");
 
-	hw_feat->ediffc = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, EDIFFC);
-
 	if (hw_feat->ediffc)
 		mac_printf("\t EDMA mode Separate Memory is selected "
 			   "for the Descriptor Cache.\n");
 
-	hw_feat->edma = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, EDMA);
-
 	if (hw_feat->edma)
 		mac_printf("\t Enhanced DMA option is selected.\n");
 
 	mac_printf("========== Hardware feature register 1 ==============\n");
 
-	/* Hardware feature register 1 */
-	hw_feat->rx_fifo_size  =
-		MAC_GET_VAL(mac_hfr1, MAC_HW_F1, RXFIFOSIZE);
-
 	if (hw_feat->rx_fifo_size)
 		mac_printf("\t Rx Fifo Size %d:%d bytes\n",
 			   hw_feat->rx_fifo_size,
 			   (1 << (hw_feat->rx_fifo_size + 7)));
 
-	hw_feat->tx_fifo_size  =
-		MAC_GET_VAL(mac_hfr1, MAC_HW_F1, TXFIFOSIZE);
-
 	if (hw_feat->tx_fifo_size)
 		mac_printf("\t Tx Fifo Size %d:%d bytes\n",
 			   hw_feat->tx_fifo_size,
 			   (1 << (hw_feat->tx_fifo_size + 7)));
 
-	hw_feat->osten  = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, OSTEN);
-
 	if (hw_feat->osten)
 		mac_printf("\t One Step Timestamping Enabled\n");
 
-	hw_feat->ptoen  = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, PTOEN);
-
 	if (hw_feat->ptoen)
 		mac_printf("\t Enable PTP Timestamp Offload Feature is "
 			   "selected\n");
 
-	hw_feat->adv_ts_hi     = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, ADVTHWORD);
-
 	if (hw_feat->adv_ts_hi)
 		mac_printf("\t Add IEEE 1588 Higher Word Register option is "
 			   "selected.\n");
 
-	hw_feat->dma_width     = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, ADDR64);
-
 	if (hw_feat->dma_width == 0)
 		mac_printf("\t Dma Width: 32\n");
 	else if (hw_feat->dma_width == 1)
@@ -2119,84 +2061,55 @@ int xgmac_get_all_hw_features(void *pdev)
 	else if (hw_feat->dma_width == 3)
 		mac_printf("\t Dma Width: RESERVED\n");
 
-	hw_feat->dcb           = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, DCBEN);
-
 	if (hw_feat->dcb)
 		mac_printf("\t Enable Data Center Bridging option is "
 			   "selected.\n");
 
-	hw_feat->sph           = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, SPHEN);
-
 	if (hw_feat->sph)
 		mac_printf("\t Enable Split Header Structure option is "
 			   "selected.\n");
 
-	hw_feat->tso           = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, TSOEN);
-
 	if (hw_feat->tso)
 		mac_printf("\t Enable TCP Segmentation Offloading for "
 			   "TCP/IP Packets option is selected.\n");
 
-	hw_feat->dma_debug     = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, DBGMEMA);
-
 	if (hw_feat->dma_debug)
 		mac_printf("\t Enable Debug Memory Access option is "
 			   "selected.\n");
 
-	hw_feat->rss           = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, RSSEN);
-
 	if (hw_feat->rss)
 		mac_printf("\t RSS Feature Enabled\n");
 
-	hw_feat->tc_cnt        = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, NUMTC);
 	mac_printf("\t Number of traffic classes selected: %d\n",
 		   (hw_feat->tc_cnt + 1));
 
-	hw_feat->hash_table_size =
-		MAC_GET_VAL(mac_hfr1, MAC_HW_F1, HASHTBLSZ);
-
 	if (hw_feat->hash_table_size)
 		mac_printf("\t Hash table size: %d\n",
 			   (64 << (hw_feat->hash_table_size - 1)));
 	else
 		mac_printf("\t Hash table size: No hash table selected\n");
 
-	hw_feat->l3l4_filter_num =
-		MAC_GET_VAL(mac_hfr1, MAC_HW_F1, L3L4FNUM);
-
 	if (hw_feat->l3l4_filter_num)
 		mac_printf("\t Total number of L3 or L4 filters %d\n",
 			   hw_feat->l3l4_filter_num);
 
 	mac_printf("========== Hardware feature register 2 ==============\n");
-
-	/* Hardware feature register 2 */
-	hw_feat->rx_q_cnt     = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, RXQCNT);
 	mac_printf("\t Number of MTL RX Q: %d\n", (hw_feat->rx_q_cnt + 1));
 
-	hw_feat->tx_q_cnt     = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, TXQCNT);
 	mac_printf("\t Number of MTL TX Q: %d\n", (hw_feat->tx_q_cnt + 1));
 
-	hw_feat->rx_ch_cnt    = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, RXCHCNT);
-
 	if (hw_feat->rx_ch_cnt)
 		mac_printf("\t Number of DMA Receive channels: %d\n",
 			   (hw_feat->rx_ch_cnt + 1));
 
-	hw_feat->tx_ch_cnt    = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, TXCHCNT);
-
 	if (hw_feat->tx_ch_cnt)
 		mac_printf("\t Number of DMA transmit channels: %d\n",
 			   (hw_feat->tx_ch_cnt + 1));
 
-	hw_feat->pps_out_num  = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, PPSOUTNUM);
-
 	if (hw_feat->pps_out_num)
 		mac_printf("\t Number of PPS outputs %d\n",
 			   hw_feat->pps_out_num);
 
-	hw_feat->aux_snap_num = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, AUXSNAPNUM);
-
 	if (hw_feat->aux_snap_num) {
 		if (hw_feat->aux_snap_num > 4)
 			mac_printf("\t Number of Auxiliary Snapshot Inputs: "
@@ -2208,9 +2121,6 @@ int xgmac_get_all_hw_features(void *pdev)
 		mac_printf("\t No Auxiliary input\n");
 	}
 
-	hw_feat->tc_cnt++;
-	hw_feat->rx_q_cnt++;
-	hw_feat->tx_q_cnt++;
 	return 0;
 }
 
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mac_api.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mac_api.c
index ef76207ba225..c7368b81d817 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mac_api.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_mac_api.c
@@ -41,6 +41,7 @@
 
 
 #include <xgmac.h>
+#include <mac_cfg.h>
 #ifdef __KERNEL__
 #include <xgmac_ptp.h>
 #include <net/switch_api/gsw_irq.h>
@@ -616,6 +617,7 @@ int xgmac_set_rxcrc(void *pdev, u32 val)
 
 	return 0;
 }
+
 /* RE:
  * When this bit is set, the Rx state machine of the MAC is enabled for
  * receiving packets from the GMII or XGMII interface
@@ -1270,6 +1272,7 @@ u64 xgmac_get_tx_tstamp(void *pdev)
 	 * tstamp of the cur pkt
 	 */
 	if (MAC_GET_VAL(tx_snr, MAC_TXTSTAMP_NSECR, TXTSSTSMIS)) {
+		mac_printf("timestamp of the current pkt is ignored\n");
 		/* timesatmp of the current pkt is ignored */
 		return 0;
 	}
@@ -1395,9 +1398,8 @@ int xgmac_config_tstamp(void *pdev, u32 mac_tscr)
 
 int xgmac_config_subsec_inc(void *pdev, u32 ptp_clk)
 {
-#if defined(PC_UTILITY) && PC_UTILITY
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-	u64 val;
+	u32 val;
 
 	if (XGMAC_RGRD_BITS(pdata, MAC_TSTAMP_CR, TSCFUPDT) == 1)
 		val = ((1 * NSEC_TO_SEC) / MHZ_TO_HZ(50));
@@ -1409,9 +1411,7 @@ int xgmac_config_subsec_inc(void *pdev, u32 ptp_clk)
 		val = (val * 1000) / 465;
 
 	XGMAC_RGWR_BITS(pdata, MAC_SUBSEC_INCR, SSINC, val);
-#else
-	// TODO: for linux u64 division need to change
-#endif
+
 	return 0;
 }
 
@@ -1494,15 +1494,18 @@ int xgmac_set_hwtstamp_settings(void *pdev,
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 mac_tscr = 0;
+	struct ptp_flags ptp_flgs;
 
-	memset(&pdata->ptp_flgs, 0, sizeof(pdata->ptp_flgs));
+	mac_printf("Mac Idx %d\n", pdata->mac_idx);
+	mac_printf("tx_type = %d, rx_filter = %d\n", tx_type, rx_filter);
 
 	switch (tx_type) {
 	case HWTSTAMP_TX_OFF:
 		break;
 
 	case HWTSTAMP_TX_ON:
-		pdata->ptp_flgs.ptp_tx_en = 1;
+	case HWTSTAMP_TX_ONESTEP_SYNC:
+		ptp_flgs.ptp_tx_en = 1;
 		MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSENA, 1);
 		break;
 
@@ -1520,38 +1523,38 @@ int xgmac_set_hwtstamp_settings(void *pdev,
 
 	case HWTSTAMP_FILTER_ALL:
 		mac_printf("HW tstamp config: Filter All\n");
-		pdata->ptp_flgs.ptp_rx_en |= PTP_RX_EN_ALL;
+		ptp_flgs.ptp_rx_en |= PTP_RX_EN_ALL;
 		break;
 
 	/* PTP v1, UDP, any kind of event packet */
 	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
-		pdata->ptp_flgs.ptp_rx_en |= PTP_RX_V2;
+		ptp_flgs.ptp_rx_en |= PTP_RX_V2;
 
 	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
 		mac_printf("PTP v1, UDP, any kind of event packet\n");
-		pdata->ptp_flgs.ptp_rx_en |=
+		ptp_flgs.ptp_rx_en |=
 			(PTP_RX_OVER_IPV4_UDP |
 			 PTP_RX_OVER_IPV6_UDP | PTP_RX_SNAP);
 		break;
 
 	/* PTP v1, UDP, Sync packet */
 	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
-		pdata->ptp_flgs.ptp_rx_en |= PTP_RX_V2;
+		ptp_flgs.ptp_rx_en |= PTP_RX_V2;
 
 	case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
 		mac_printf("PTP v1, UDP, Sync packet\n");
-		pdata->ptp_flgs.ptp_rx_en |=
+		ptp_flgs.ptp_rx_en |=
 			(PTP_RX_OVER_IPV4_UDP |
 			 PTP_RX_OVER_IPV6_UDP | PTP_RX_EVNT);
 		break;
 
 	/* PTP v1, UDP, Delay_req packet */
 	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
-		pdata->ptp_flgs.ptp_rx_en |= PTP_RX_V2;
+		ptp_flgs.ptp_rx_en |= PTP_RX_V2;
 
 	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
 		mac_printf("PTP v1, UDP, Delay_req packet\n");
-		pdata->ptp_flgs.ptp_rx_en |=
+		ptp_flgs.ptp_rx_en |=
 			(PTP_RX_OVER_IPV4_UDP |
 			 PTP_RX_OVER_IPV6_UDP | PTP_RX_EVNT | PTP_RX_MSTR);
 		break;
@@ -1559,7 +1562,7 @@ int xgmac_set_hwtstamp_settings(void *pdev,
 	/* 802.AS1, Ethernet, any kind of event packet */
 	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
 		mac_printf("802.AS1, Ethernet, any kind of event packet\n");
-		pdata->ptp_flgs.ptp_rx_en |=
+		ptp_flgs.ptp_rx_en |=
 			(PTP_RX_V2 | PTP_RX_OVER_ETH | PTP_RX_SNAP);
 
 		break;
@@ -1567,14 +1570,14 @@ int xgmac_set_hwtstamp_settings(void *pdev,
 	/* 802.AS1, Ethernet, Sync packet */
 	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
 		mac_printf("802.AS1, Ethernet, Sync packet\n");
-		pdata->ptp_flgs.ptp_rx_en |=
+		ptp_flgs.ptp_rx_en |=
 			(PTP_RX_V2 | PTP_RX_OVER_ETH | PTP_RX_EVNT);
 		break;
 
 	/* 802.AS1, Ethernet, Delay_req packet */
 	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
 		mac_printf("802.AS1, Ethernet, Delay_req packet\n");
-		pdata->ptp_flgs.ptp_rx_en |=
+		ptp_flgs.ptp_rx_en |=
 			(PTP_RX_V2 | PTP_RX_OVER_ETH |
 			 PTP_RX_EVNT | PTP_RX_MSTR);
 		break;
@@ -1582,21 +1585,21 @@ int xgmac_set_hwtstamp_settings(void *pdev,
 	/* PTP v2/802.AS1, any layer, any kind of event packet */
 	case HWTSTAMP_FILTER_PTP_V2_EVENT:
 		mac_printf("PTP v2/802.AS1,any layer,any kind of event pkt\n");
-		pdata->ptp_flgs.ptp_rx_en |=
+		ptp_flgs.ptp_rx_en |=
 			(PTP_RX_V2 | PTP_RX_OVER_ANY_LYR | PTP_RX_SNAP);
 		break;
 
 	/* PTP v2/802.AS1, any layer, Sync packet */
 	case HWTSTAMP_FILTER_PTP_V2_SYNC:
 		mac_printf("PTP v2/802.AS1, any layer, Sync packet\n");
-		pdata->ptp_flgs.ptp_rx_en |=
+		ptp_flgs.ptp_rx_en |=
 			(PTP_RX_V2 | PTP_RX_OVER_ANY_LYR | PTP_RX_EVNT);
 		break;
 
 	/* PTP v2/802.AS1, any layer, Delay_req packet */
 	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
 		mac_printf("PTP v2/802.AS1, any layer, Delay_req packet\n");
-		pdata->ptp_flgs.ptp_rx_en |=
+		ptp_flgs.ptp_rx_en |=
 			(PTP_RX_V2 | PTP_RX_OVER_ANY_LYR |
 			 PTP_RX_EVNT | PTP_RX_MSTR);
 		break;
@@ -1605,39 +1608,58 @@ int xgmac_set_hwtstamp_settings(void *pdev,
 		return 0;
 	}
 
-	if (pdata->ptp_flgs.ptp_rx_en != 0) {
+	if (ptp_flgs.ptp_rx_en != 0) {
+
+		/* In FalconMx all packets have timestamp */
+		ptp_flgs.ptp_rx_en |= PTP_RX_EN_ALL;
+
 		MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSENA, 1);
 
-		if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_V2)
+		if (ptp_flgs.ptp_rx_en & PTP_RX_V2)
 			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSVER2ENA, 1);
 
-		if (pdata->ptp_flgs.ptp_rx_en &
+		if (ptp_flgs.ptp_rx_en &
 		    (PTP_RX_OVER_ANY_LYR | PTP_RX_OVER_IPV4_UDP))
 			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSIPV4ENA, 1);
 
-		if (pdata->ptp_flgs.ptp_rx_en &
+		if (ptp_flgs.ptp_rx_en &
 		    (PTP_RX_OVER_ANY_LYR | PTP_RX_OVER_IPV6_UDP))
 			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSIPV6ENA, 1);
 
-		if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_OVER_ETH)
+		if (ptp_flgs.ptp_rx_en & PTP_RX_OVER_ETH)
 			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, AV8021ASMEN, 1);
 
-		if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_OVER_ANY_LYR)
+		if (ptp_flgs.ptp_rx_en & PTP_RX_OVER_ANY_LYR)
 			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSIPENA, 1);
 
-		if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_EVNT)
+		if (ptp_flgs.ptp_rx_en & PTP_RX_EVNT)
 			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSEVNTENA, 1);
 
-		if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_SNAP)
+		if (ptp_flgs.ptp_rx_en & PTP_RX_SNAP)
 			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, SNAPTYPSEL, 1);
 
-		if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_MSTR)
+		if (ptp_flgs.ptp_rx_en & PTP_RX_MSTR)
 			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSMSTRENA, 1);
 
-		if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_EN_ALL)
+		if (ptp_flgs.ptp_rx_en & PTP_RX_EN_ALL)
 			MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSENALL, 1);
 	}
 
+	if ((pdata->ptp_flgs.ptp_rx_en == ptp_flgs.ptp_rx_en) &&
+	    (pdata->ptp_flgs.ptp_tx_en == ptp_flgs.ptp_tx_en)) {
+		return 0;
+	} else {
+		pdata->ptp_flgs.ptp_rx_en = ptp_flgs.ptp_rx_en;
+		pdata->ptp_flgs.ptp_tx_en = ptp_flgs.ptp_tx_en;
+	}
+
+	if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_EN_ALL &&
+	    pdata->ptp_flgs.ptp_tx_en) {
+		mac_enable_ts(pdev);
+	} else {
+		mac_disable_ts(pdev);
+	}
+
 	xgmac_config_tstamp(pdev, mac_tscr);
 
 #ifdef __KERNEL__
@@ -1652,11 +1674,8 @@ void xgmac_ptp_txtstamp_mode(void *pdev,
 			     u32 tsmstrena,
 			     u32 tsevntena)
 {
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	u32 mac_tscr = 0;
 
-	memset(&pdata->ptp_flgs, 0, sizeof(pdata->ptp_flgs));
-
 	MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSVER2ENA, 1);
 	MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSIPENA, 1);
 	MAC_SET_VAL(mac_tscr, MAC_TSTAMP_CR, TSIPV4ENA, 1);
@@ -1668,6 +1687,7 @@ void xgmac_ptp_txtstamp_mode(void *pdev,
 
 	xgmac_config_tstamp(pdev, mac_tscr);
 }
+
 int xgmac_set_gint(void *pdev, u32 val)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
@@ -1683,3 +1703,69 @@ int xgmac_set_gint(void *pdev, u32 val)
 
 	return 0;
 }
+
+int xgmac_get_hw_capability(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+	u32 mac_hfr0, mac_hfr1, mac_hfr2;
+	/* Hardware features of the device */
+	struct xgmac_hw_features *hw_feat = &pdata->hw_feat;
+
+	mac_hfr0 = XGMAC_RGRD(pdata, MAC_HW_F0);
+	mac_hfr1 = XGMAC_RGRD(pdata, MAC_HW_F1);
+	mac_hfr2 = XGMAC_RGRD(pdata, MAC_HW_F2);
+
+	memset(hw_feat, 0, sizeof(*hw_feat));
+
+	hw_feat->version = XGMAC_RGRD(pdata, MAC_VR);
+
+	/* Hardware feature register 0 */
+	hw_feat->gmii        = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, GMIISEL);
+	hw_feat->vlhash      = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, VLHASH);
+	hw_feat->sma         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, SMASEL);
+	hw_feat->rwk         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, RWKSEL);
+	hw_feat->mgk         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, MGKSEL);
+	hw_feat->mmc         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, MMCSEL);
+	hw_feat->aoe         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, ARPOFFSEL);
+	hw_feat->ts          = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, TSSEL);
+	hw_feat->eee         = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, EEESEL);
+	hw_feat->tx_coe      = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, TXCOESEL);
+	hw_feat->rx_coe      = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, RXCOESEL);
+	hw_feat->addn_mac   = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, ADDMACADRSEL);
+	hw_feat->ts_src      = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, TSSTSSEL);
+	hw_feat->sa_vlan_ins = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, SAVLANINS);
+	hw_feat->vxn = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, VXN);
+	hw_feat->ediffc = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, EDIFFC);
+	hw_feat->edma = MAC_GET_VAL(mac_hfr0, MAC_HW_F0, EDMA);
+	/* Hardware feature register 1 */
+	hw_feat->rx_fifo_size  =
+		MAC_GET_VAL(mac_hfr1, MAC_HW_F1, RXFIFOSIZE);
+	hw_feat->tx_fifo_size  =
+		MAC_GET_VAL(mac_hfr1, MAC_HW_F1, TXFIFOSIZE);
+	hw_feat->osten  = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, OSTEN);
+	hw_feat->ptoen  = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, PTOEN);
+	hw_feat->adv_ts_hi     = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, ADVTHWORD);
+	hw_feat->dma_width     = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, ADDR64);
+	hw_feat->dcb           = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, DCBEN);
+	hw_feat->sph           = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, SPHEN);
+	hw_feat->tso           = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, TSOEN);
+	hw_feat->dma_debug     = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, DBGMEMA);
+	hw_feat->rss           = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, RSSEN);
+	hw_feat->tc_cnt        = MAC_GET_VAL(mac_hfr1, MAC_HW_F1, NUMTC);
+	hw_feat->hash_table_size =
+		MAC_GET_VAL(mac_hfr1, MAC_HW_F1, HASHTBLSZ);
+	hw_feat->l3l4_filter_num =
+		MAC_GET_VAL(mac_hfr1, MAC_HW_F1, L3L4FNUM);
+	/* Hardware feature register 2 */
+	hw_feat->rx_q_cnt     = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, RXQCNT);
+	hw_feat->tx_q_cnt     = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, TXQCNT);
+	hw_feat->rx_ch_cnt    = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, RXCHCNT);
+	hw_feat->tx_ch_cnt    = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, TXCHCNT);
+	hw_feat->pps_out_num  = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, PPSOUTNUM);
+	hw_feat->aux_snap_num = MAC_GET_VAL(mac_hfr2, MAC_HW_F2, AUXSNAPNUM);
+	hw_feat->tc_cnt++;
+	hw_feat->rx_q_cnt++;
+	hw_feat->tx_q_cnt++;
+
+	return 0;
+}
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_main.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_main.c
old mode 100644
new mode 100755
index f7ebb2932ad6..a726d173260c
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_main.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_main.c
@@ -482,6 +482,27 @@ struct _xgmac_cfg xgmac_cfg_table[] = {
 		0,
 		0, &pdata.val, 0, 0, 0,
 		"<args 1: 1/0 Rx Crc check DISABLE/ENABLE>"
+	},	
+	{
+		"fifo             ",
+		0,
+		cli_get_fifo,
+		0, 0, 0, 0, 0,
+		"<Get Tx Fifo>"
+	},
+	{
+		"fifo_add             ",
+		cli_add_fifo,
+		0,
+		0, 0, 0, 0, 0,
+		"<Add Tx Fifo>"
+	},
+	{
+		"fifo_del             ",
+		cli_del_fifo,
+		0,
+		0, &pdata.rec_id, 0, 0, 0,
+		"<Del Tx Fifo>"
 	},
 	/* OTHERS */
 	{
@@ -515,7 +536,7 @@ struct _xgmac_cfg xgmac_cfg_table[] = {
 	{
 		"hw_feat         ",
 		0,
-		xgmac_get_all_hw_features,
+		xgmac_print_hw_cap,
 		0, 0, 0, 0, 0,
 		"<get all hw features>"
 	},
@@ -699,6 +720,8 @@ int xgmac_main(u32 argc, u8 *argv[])
 	u32 start_arg = 0;
 	int idx = 0;
 	u32 max_mac;
+	u32 nanosec;
+	u32 sec, min, hr, days;
 
 	int num_of_elem =
 		(sizeof(xgmac_cfg_table) / sizeof(struct _xgmac_cfg));
@@ -712,50 +735,6 @@ int xgmac_main(u32 argc, u8 *argv[])
 	start_arg++;
 	start_arg++;
 
-#if defined(UPTIME) && UPTIME
-
-	if (!strcmp(argv[start_arg], "uptime")) {
-		found = 1;
-		u32 total_sec, nanosec;
-		u32 sec, min, hr, days;
-
-		total_sec = XGMAC_RGRD(&prv_data[0], MAC_SYS_TIME_SEC);
-		nanosec = XGMAC_RGRD(&prv_data[0], MAC_SYS_TIME_NSEC);
-
-		if (sec)
-			sec = (total_sec * (nanosec / NANOSEC_IN_ONESEC));
-		else
-			sec = (nanosec / NANOSEC_IN_ONESEC);
-
-		if (sec >= 60) {
-			min = sec / 60;
-			sec = sec - (min * 60);
-		} else {
-			min = 0;
-		}
-
-		if (min >= 60) {
-			hr = min / 60;
-			min = min - (hr * 60);
-		} else {
-			hr = 0;
-		}
-
-		if (hr >= 24) {
-			days = hr / 24;
-			hr = hr - (days * 24);
-		} else {
-			days = 0;
-		}
-
-		mac_printf("Uptime(d:h:m:s): %02d:%02d:%02d:%02d\n",
-			   days, hr, min, sec);
-
-		goto end;
-	}
-
-#endif
-
 	if (!strcmp(argv[start_arg], "-help")) {
 		found = 1;
 		xgmac_menu();
@@ -801,6 +780,39 @@ int xgmac_main(u32 argc, u8 *argv[])
 		prv_data_k->set_all = 0;
 	}
 
+	if (!strcmp(argv[start_arg], "uptime")) {
+		found = 1;
+
+		sec = XGMAC_RGRD(prv_data_k, MAC_SYS_TIME_SEC);
+		nanosec = XGMAC_RGRD(prv_data_k, MAC_SYS_TIME_NSEC);
+
+		if (sec >= 60) {
+			min = sec / 60;
+			sec = sec - (min * 60);
+		} else {
+			min = 0;
+		}
+
+		if (min >= 60) {
+			hr = min / 60;
+			min = min - (hr * 60);
+		} else {
+			hr = 0;
+		}
+
+		if (hr >= 24) {
+			days = hr / 24;
+			hr = hr - (days * 24);
+		} else {
+			days = 0;
+		}
+
+		mac_printf("Uptime(d:h:m:s): %02d:%02d:%02d:%02d\n",
+			   days, hr, min, sec);
+
+		goto end;
+	}
+
 	if (!strcmp(argv[start_arg], "r")) {
 		start_arg++;
 		found = 1;
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c
index 85b167cb39a9..7b20ee9224d4 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.c
@@ -43,34 +43,40 @@
 #include <xgmac.h>
 #include <xgmac_ptp.h>
 
+#define AUX_TRIG_0 1
+#define AUX_TRIG_1 2
+#define N_EXT_TS 2
+
 static int xgmac_adj_freq(struct ptp_clock_info *ptp, s32 ppb);
 static int xgmac_adj_time(struct ptp_clock_info *ptp, s64 delta);
 static int xgmac_get_time(struct ptp_clock_info *ptp,
 			  struct timespec64 *ts);
 static int xgmac_set_time(struct ptp_clock_info *ptp,
 			  const struct timespec64 *ts);
-static void *parse_ptp_packet(struct sk_buff *skb, u16 *eth_type);
-static int xgmac_check_tx_tstamp(void *pdev, struct sk_buff *skb);
-static void xgmac_get_rx_tstamp(void *pdev, struct sk_buff *skb);
+static void *parse_ptp_packet(struct sk_buff *skb,
+			      u16 *eth_type,
+			      u8 *msg_type);
+static void xgmac_get_rx_tstamp(struct mac_prv_data *pdata,
+				struct sk_buff *skb);
 static int xgmac_ptp_register(void *pdev);
+static void xgmac_extts_isr_handler(struct mac_prv_data *pdata);
+
 
-// TODO: Get the ptp clock in Hz from device tree
 void xgmac_config_timer_reg(void *pdev)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-
 	struct timespec now;
 	struct mac_ops *hw_if = &pdata->ops;
-	u64 temp;
+	u64 temp = 0;
 
 	/* program Sub Second Increment Reg */
-	hw_if->config_subsec_inc(pdata, pdata->ptp_clk);
+	hw_if->config_subsec_inc(pdev, pdata->ptp_clk);
 
 	/* Calculate the def addend:
 	 * addend = 2^32 / (PTP ref clock / 50Mhz)
 	 *        = (2^32 * 50Mhz) / PTP ref clock
 	 */
-	temp = ((u64)(MHZ_TO_HZ(50)) << 32);
+	temp = (u64)(50000000ULL << 32);
 	pdata->def_addend = div_u64(temp, pdata->ptp_clk);
 
 	hw_if->config_addend(pdev, pdata->def_addend);
@@ -88,12 +94,11 @@ static int xgmac_adj_freq(struct ptp_clock_info *ptp, s32 ppb)
 	struct mac_prv_data *pdata =
 		container_of(ptp, struct mac_prv_data, ptp_clk_info);
 	struct mac_ops *hw_if = &pdata->ops;
-
 	u64 adj;
 	u32 diff, addend;
 	int neg_adj = 0;
 
-	pr_info("Calling adjust_freq: %d\n", ppb);
+	pr_debug("Calling adjust_freq: %d\n", ppb);
 
 	if (ppb < 0) {
 		neg_adj = 1;
@@ -111,10 +116,12 @@ static int xgmac_adj_freq(struct ptp_clock_info *ptp, s32 ppb)
 
 	spin_lock_bh(&pdata->ptp_lock);
 
-	hw_if->config_addend(pdata, addend);
+	hw_if->config_addend(hw_if, addend);
 
 	spin_unlock_bh(&pdata->ptp_lock);
 
+	pr_debug("Adjust_freq: Done\n");
+
 	return 0;
 }
 
@@ -132,7 +139,7 @@ static int xgmac_adj_time(struct ptp_clock_info *ptp, s64 delta)
 	u32 quotient, reminder;
 	int neg_adj = 0;
 
-	pr_info("Calling adjust_time: %lld\n", delta);
+	pr_debug("Calling adjust_time: %lld\n", delta);
 
 	if (delta < 0) {
 		neg_adj = 1;
@@ -145,11 +152,13 @@ static int xgmac_adj_time(struct ptp_clock_info *ptp, s64 delta)
 
 	spin_lock_bh(&pdata->ptp_lock);
 
-	hw_if->adjust_systime(pdata, sec, nsec, neg_adj,
+	hw_if->adjust_systime(hw_if, sec, nsec, neg_adj,
 			      pdata->one_nsec_accuracy);
 
 	spin_unlock_bh(&pdata->ptp_lock);
 
+	pr_debug("Adjust_time: Done\n");
+
 	return 0;
 }
 
@@ -168,15 +177,15 @@ static int xgmac_get_time(struct ptp_clock_info *ptp,
 
 	spin_lock_bh(&pdata->ptp_lock);
 
-	ns = hw_if->get_systime(pdata);
+	ns = hw_if->get_systime(hw_if);
 
 	spin_unlock_bh(&pdata->ptp_lock);
 
 	ts->tv_sec = div_u64_rem(ns, NSEC_TO_SEC, &reminder);
 	ts->tv_nsec = reminder;
 
-	pr_info("get_time: ts->tv_sec  = %ld,ts->tv_nsec = %ld\n",
-		(long int)ts->tv_sec, (long int)ts->tv_nsec);
+	pr_debug("get_time: ts->tv_sec  = %ld,ts->tv_nsec = %ld\n",
+		 (long int)ts->tv_sec, (long int)ts->tv_nsec);
 
 	return 0;
 }
@@ -192,12 +201,12 @@ static int xgmac_set_time(struct ptp_clock_info *ptp,
 	struct mac_ops *hw_if = &pdata->ops;
 
 
-	pr_info("set_time: ts->tv_sec  = %lld, ts->tv_nsec = %lld\n",
-		(u64)ts->tv_sec, (u64)ts->tv_nsec);
+	pr_debug("set_time: ts->tv_sec  = %lld, ts->tv_nsec = %lld\n",
+		 (u64)ts->tv_sec, (u64)ts->tv_nsec);
 
 	spin_lock_bh(&pdata->ptp_lock);
 
-	hw_if->init_systime(pdata, ts->tv_sec, ts->tv_nsec);
+	hw_if->init_systime(hw_if, ts->tv_sec, ts->tv_nsec);
 
 	spin_unlock_bh(&pdata->ptp_lock);
 
@@ -209,14 +218,15 @@ static int xgmac_set_time(struct ptp_clock_info *ptp,
  *  ethernet frame. The function returns the position of the PTP packet
  *  or NULL, if no PTP found.
  */
-static void *parse_ptp_packet(struct sk_buff *skb, u16 *eth_type)
+static void *parse_ptp_packet(struct sk_buff *skb,
+			      u16 *eth_type,
+			      u8 *msg_type)
 {
 	struct iphdr *iph;
 	struct udphdr *udph;
 	struct ipv6hdr *ipv6h;
 	void *pos = skb->data + ETH_ALEN + ETH_ALEN;
 	u8 *ptp_loc = NULL;
-	u8 msg_type;
 
 	*eth_type = *((u16 *)pos);
 
@@ -237,20 +247,7 @@ static void *parse_ptp_packet(struct sk_buff *skb, u16 *eth_type)
 	/* Transport of PTP over Ethernet */
 	case ETH_P_1588:
 		ptp_loc = pos;
-
-		msg_type = *((u8 *)(ptp_loc + PTP_OFFS_MSG_TYPE)) & 0xf;
-
-		if ((msg_type == PTP_MSGTYPE_SYNC) ||
-		    (msg_type == PTP_MSGTYPE_DELREQ) ||
-		    (msg_type == PTP_MSGTYPE_PDELREQ) ||
-		    (msg_type == PTP_MSGTYPE_PDELRESP)) {
-			pr_info("Transport of PTP over Ethernet header\n");
-			ptp_loc = pos;
-		} else {
-			pr_info("Error: Transport of PTP over Ethernet header\n");
-			ptp_loc = NULL;
-		}
-
+		pr_debug("Transport of PTP over Ethernet header\n");
 		break;
 
 	/* Transport of PTP over IPv4 */
@@ -263,6 +260,9 @@ static void *parse_ptp_packet(struct sk_buff *skb, u16 *eth_type)
 		pos += iph->ihl * 4;
 		udph = (struct udphdr *)pos;
 
+		/* Update the Udp header checksum with 0 */
+		udph->check = 0;
+
 		/* check the destination port address
 		 * ( 319 (0x013F) = PTP event port )
 		 */
@@ -270,7 +270,7 @@ static void *parse_ptp_packet(struct sk_buff *skb, u16 *eth_type)
 			pr_info(" Transport of PTP over IPv4 Error\n");
 			ptp_loc = NULL;
 		} else {
-			pr_info("Transport of PTP over IPv4 header\n");
+			pr_debug("Transport of PTP over IPv4 header\n");
 			ptp_loc = pos + sizeof(struct udphdr);
 		}
 
@@ -293,7 +293,7 @@ static void *parse_ptp_packet(struct sk_buff *skb, u16 *eth_type)
 			pr_info(" Transport of PTP over IPv6 Error\n");
 			ptp_loc = NULL;
 		} else {
-			pr_info("Transport of PTP over IPv6 header\n");
+			pr_debug("Transport of PTP over IPv6 header\n");
 			ptp_loc = pos + sizeof(struct udphdr);
 		}
 
@@ -306,94 +306,97 @@ static void *parse_ptp_packet(struct sk_buff *skb, u16 *eth_type)
 
 	if (!ptp_loc)
 		pr_info("PTP header is not found in the packet, Please check\n");
+	else {
+
+		*msg_type = *((u8 *)(ptp_loc + PTP_OFFS_MSG_TYPE)) & 0xf;
+
+		printk("Txing Message Type %d\n", *msg_type);
+
+		if ((*msg_type == PTP_MSGTYPE_SYNC) ||
+		    (*msg_type == PTP_MSGTYPE_DELREQ) ||
+		    (*msg_type == PTP_MSGTYPE_PDELREQ) ||
+		    (*msg_type == PTP_MSGTYPE_PDELRESP)) {
+			ptp_loc = pos;
+		} else {
+			pr_info("Error: Unkown PTP Message \n");
+			ptp_loc = NULL;
+		}
+	}
 
 	return ptp_loc;
 }
 
+static void tx_hwtstamp(struct mac_prv_data *pdata,
+			struct skb_shared_hwtstamps *shhwtstamp)
+{
+	/* Marking Tx Timestamp complete */
+	if (!shhwtstamp->hwtstamp.tv64)
+		shhwtstamp->hwtstamp = ktime_get_real();
+
+	skb_tstamp_tx(pdata->ptp_tx_skb, shhwtstamp);
+}
+
+
 /* =========================== TX TIMESTAMP =========================== */
 
-/*  This API will be called by Datapath library when transmitting a packet to HW
- *  ptpd sends down 1-Step/2-Step sync packet on the event socket (i.e, one
+/*  ptpd sends down 1-Step/2-Step sync packet on the event socket (i.e, one
  *  for which SO_TIMESTAMPING socket option is set).
  *  Network stack sets the SKBTX_HW_TSTAMP in skb since socket is
  *  marked for SO_TIMESTAMPING.
  */
-/*  TODO: From Pmac Header OneStep bit indicates oneStep or TwoStep
- *  If 2 step use record id to enable TTSE/OSTC/OSTC_AVAIL
- *  to store the transmit timestamp
- */
 int xgmac_tx_hwts(void *pdev, struct sk_buff *skb)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-
-	int ret = 0;
+	int rec_id = 0;
+	u16 ethtype;
+	u8 *ptp_loc = NULL;
+	u8 msg_type = PTP_MSGTYPE_INVALID;
+	struct skb_shared_hwtstamps shhwtstamp = {0};
 
 	/* check for hw tstamping */
-	if (pdata->hw_feat.ts_src && pdata->ptp_flgs.ptp_tx_en) {
-		if ((skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&
-		    !(pdata->ptp_tx_skb)) {
-			/* Check 1-step or 2-step tstamp */
-			if (xgmac_check_tx_tstamp(pdata, skb) < 0)
-				return ret;
-
-			/* declare that device is doing timestamping */
-			skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
-			pdata->ptp_tx_skb = skb_get(skb);
-			pr_info("Got PTP pkt to transmit\n");
-		}
-	}
-
-	return ret;
-}
+	if (pdata->hw_feat.ts_src && pdata->ptp_flgs.ptp_tx_en &&
+	    (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {
 
-/*  This API will determine whether the TX packet need to do 1 Step or 2 Step
- *  For one-step clock, the value of TWO_STEP shall be FALSE.
- *  For two-step clock, the value of TWO_STEP shall be TRUE.
- */
-static int xgmac_check_tx_tstamp(void *pdev, struct sk_buff *skb)
-{
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+		/* declare that device is doing timestamping */
+		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
 
-	u16 flags;
-	u16 ethtype;
-	u8 *ptp_loc;
+		pdata->ptp_tx_skb = skb_get(skb);
 
-	/* Extract the packet Sync or Delay Resp Flags Field
-	 *  Parsing here will not cause performance drop since only
-	 *  SKBTX_HW_TSTAMP flagged packet will be parsed
-	 */
+		/* Currently supporting only Master Mode */
+		if (IS_2STEP(pdata)) {
+			mac_printf("2-Step\n");
 
-	ptp_loc = parse_ptp_packet(skb, &ethtype);
+			/* PTP Sync if we are Master TTSE=1 OSTC=0, OSTPA=0 */
+			rec_id = fifo_entry_add(pdev, 1, 0, 0, 0, 0, 0);
+		}
 
-	if (!ptp_loc)
-		return -1;
+		if (IS_1STEP(pdata)) {
+			mac_printf("1-Step\n");
+			ptp_loc = parse_ptp_packet(skb, &ethtype, &msg_type);
 
-	flags =  *((u16 *)(ptp_loc + PTP_OFFS_FLAGS)) & 0xFFFF;
+			if (!ptp_loc)
+				return -1;
 
-	/* Check the TWO_STEP bit in the flag, Bit 1 in Flags is the 2 step flag
-	 */
-	if ((flags >> 8) & 0x02) {
-		/* 2 Step timestamp flag enabled */
-		pdata->two_step = 1;
-
-		if (pdata->ptp_tx_init == 0) {
-			INIT_WORK(&pdata->ptp_tx_work,
-				  (work_func_t)xgmac_ptp_tx_work);
-			pdata->ptp_tx_init = 1;
+			/* PTP Sync if we are Master TTSE=0 OSTC=1, OSTPA=0 */
+			rec_id = fifo_entry_add(pdev, 0, 1, 0, 0, 0, 0);
+			/* SNAPTYPESEL=0 TSMSTREN=1 TSEVNTEN = 0 */
+			xgmac_ptp_txtstamp_mode(pdev, 0, 1, 1);
 		}
-	} else {
-		/* 1 Step timestamp flag enabled */
-		pdata->two_step = 0;
 
-		if (pdata->ptp_tx_init) {
-			cancel_work_sync(&pdata->ptp_tx_work);
-			pdata->ptp_tx_init = 0;
+		if (rec_id == FIFO_FULL) {
+			mac_printf("Fifo is Full\n");
+			/* if -1, CPU should drop the packet */
+			return -1;
 		}
+
+		if (IS_1STEP(pdata))
+			tx_hwtstamp(pdata, &shhwtstamp);
 	}
 
-	return 0;
+	return rec_id;
 }
 
+
 /*  This API will get executed by workqueue only for 2 step timestamp
  *  Get the TX'ted Timestamp and pass it to upper app
  *  and free the skb
@@ -413,7 +416,7 @@ int xgmac_ptp_tx_work(struct work_struct *work)
 	/* check tx tstamp status, if have, read the timestamp and sent to
 	 * stack, otherwise reschedule later
 	 */
-	tstamp = pdata->ops.get_tx_tstamp(pdata);
+	tstamp = pdata->ops.get_tx_tstamp(&pdata->ops);
 
 	if (!tstamp) {
 		pr_info("Tx tstamp is not captured or ignored for this pkt\n");
@@ -424,28 +427,14 @@ int xgmac_ptp_tx_work(struct work_struct *work)
 	shhwtstamp.hwtstamp = ns_to_ktime(tstamp);
 
 	/* pass tstamp from HW to network stack fr 2 step */
-	skb_tstamp_tx(pdata->ptp_tx_skb, &shhwtstamp);
-
-	pr_info("Tx timestamp to stack\n");
-
-	/* skb_tstamp_tx() clones the original skb and
-	 * adds the timestamps, therefore the original skb
-	 * has to be freed now and return.
-	 */
+	tx_hwtstamp(pdata, &shhwtstamp);
 
-	if (tstamp) {
-		dev_kfree_skb_any(pdata->ptp_tx_skb);
-		pdata->ptp_tx_skb = NULL;
-		return 0;
-	}
+	return 1;
 
 schedule_later:
 
-	/* If One step timestamp no need to schedule work */
-	if (pdata->two_step == 1) {
-		/* reschedule to check later */
-		schedule_work(&pdata->ptp_tx_work);
-	}
+	/* reschedule to check later */
+	schedule_work(&pdata->ptp_tx_work);
 
 	return 1;
 }
@@ -465,7 +454,7 @@ int xgmac_rx_hwts(void *pdev, struct sk_buff *skb)
 	 * timestamp and send to App
 	 */
 	if (pdata->ptp_flgs.ptp_rx_en & PTP_RX_EN_ALL)
-		xgmac_get_rx_tstamp(pdev, skb);
+		xgmac_get_rx_tstamp(pdata, skb);
 
 	/* No other Rx filter currently supported in driver */
 	return 0;
@@ -474,18 +463,15 @@ int xgmac_rx_hwts(void *pdev, struct sk_buff *skb)
 /* Update the received timestamp in skbhwtstamp
  * which will be used by PTP app
  */
-static void xgmac_get_rx_tstamp(void *pdev, struct sk_buff *skb)
+static void xgmac_get_rx_tstamp(struct mac_prv_data *pdata,
+				struct sk_buff *skb)
 {
-	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-
 	__le64 regval;
+	__le64 tmpregval[2];
 	u32 ts_hdr_len = 8;
 	struct skb_shared_hwtstamps *shhwtstamp = NULL;
 	u64 ns;
 
-	/* TODO: Below code to get hdr len is wrong, Need to find the
-	 * correct register
-	 */
 	/* External clk_src only have 8 bytes as tstamp header
 	 * Internal clk_src have 10 bytes as tstamp header
 	 * (8 bytes tstamp + 2 bytes Year)
@@ -497,9 +483,14 @@ static void xgmac_get_rx_tstamp(void *pdev, struct sk_buff *skb)
 		ts_hdr_len = 10;
 
 	/* copy the bits out of the skb, and then trim the skb length */
-	skb_copy_bits(skb, skb->len - ts_hdr_len, &regval, ts_hdr_len);
+	skb_copy_bits(skb, skb->len - ts_hdr_len, tmpregval, ts_hdr_len);
 	__pskb_trim(skb, skb->len - ts_hdr_len);
 
+	/* GSWIP HW attach upper 2 bytes with 0 for timestamp */
+	regval = (0xffffffff00000000 & tmpregval[0]) |
+		 (tmpregval[0] & 0xffff) << 16
+		 | (tmpregval[1] & 0xffff000000000000) >> 48 ;
+
 	/* The timestamp is recorded in little endian format, and is stored at
 	 * the end of the packet.
 	 *
@@ -516,10 +507,9 @@ static void xgmac_get_rx_tstamp(void *pdev, struct sk_buff *skb)
 /* Configuring the HW Timestamping feature
  * This api will be called from the IOCTL SIOCSHWTSTAMP
  */
-int xgmac_config_hwts(void *pdev, struct ifreq *ifr)
+int xgmac_set_hwts(void *pdev, struct ifreq *ifr)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
-
 	struct hwtstamp_config config;
 	int err;
 	struct mac_ops *hw_if = &pdata->ops;
@@ -528,18 +518,30 @@ int xgmac_config_hwts(void *pdev, struct ifreq *ifr)
 		return -EFAULT;
 
 	err = hw_if->config_hw_time_stamping(pdev,
-					     config.rx_filter, config.tx_type);
+					     config.tx_type,
+					     config.rx_filter);
 
 	if (err)
-		return err;
+		return 0;
 
 	/* save these settings for future reference */
 	memcpy(&pdata->tstamp_config, &config, sizeof(pdata->tstamp_config));
 
-	return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?
-	       -EFAULT : 0;
+	return 1;
+}
+
+/* Configuring the HW Timestamping feature
+ * This api will be called from the IOCTL SIOCGHWTSTAMP
+ */
+int xgmac_get_hwts(void *pdev, struct ifreq *ifr)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
+
+	return copy_to_user(ifr->ifr_data, &pdata->tstamp_config,
+			    sizeof(pdata->tstamp_config)) ? -EFAULT : 0;
 }
 
+
 int xgmac_ptp_isr_hdlr(void *pdev)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
@@ -551,16 +553,18 @@ int xgmac_ptp_isr_hdlr(void *pdev)
 	/* Clear/Acknowledge interrupt by reading TXTSC */
 	txtsc = XGMAC_RGRD_BITS(pdata, MAC_TSTAMP_STSR, TXTSC);
 
+	/* Read the TxTimestamp Seconds register
+	 * to clear the TXTSC bit
+	 */
 	if (txtsc) {
-		/* If One step timestamp no need to schedule work */
-		if (pdata->two_step == 1) {
-			schedule_work(&pdata->ptp_tx_work);
-		} else {
-			/* Read the TxTimestamp Seconds register
-			 * to clear the TXTSC bit
-			 */
-			tstamp = hw_if->get_tx_tstamp(pdata);
-		}
+		if (IS_2STEP(pdata))
+			xgmac_ptp_tx_work(&pdata->ptp_tx_work);
+
+		if (IS_1STEP(pdata))
+			tstamp = hw_if->get_tx_tstamp(pdev);
+
+		if (XGMAC_RGRD(pdata, MAC_AUX_CTRL) & 0x30)
+			xgmac_extts_isr_handler(pdata);
 
 		ret = 0;
 	}
@@ -568,6 +572,75 @@ int xgmac_ptp_isr_hdlr(void *pdev)
 	return ret;
 }
 
+static int xgmac_extts_enable(struct ptp_clock_info *ptp,
+			      struct ptp_clock_request *rq, int on)
+{
+	struct mac_prv_data *pdata =
+		container_of(ptp, struct mac_prv_data, ptp_clk_info);
+
+	switch (rq->type) {
+	case PTP_CLK_REQ_EXTTS:
+		switch (rq->extts.index) {
+		case 0:
+			pdata->exts0_enabled = on ? 1 : 0;
+			XGMAC_RGWR_BITS(pdata, MAC_AUX_CTRL, ATSEN0, 1);
+			XGMAC_RGWR_BITS(pdata, MAC_TSTAMP_CR, ESTI, 1);
+			break;
+
+		case 1:
+			pdata->exts1_enabled = on ? 1 : 0;
+			XGMAC_RGWR_BITS(pdata, MAC_AUX_CTRL, ATSEN1, 1);
+			XGMAC_RGWR_BITS(pdata, MAC_TSTAMP_CR, ESTI, 1);
+			break;
+
+		default:
+			return -EINVAL;
+		}
+
+		return 0;
+
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static u64 xgmac_get_auxtimestamp(struct mac_prv_data *pdata)
+{
+	u64 nsec;
+
+	nsec = XGMAC_RGRD(pdata, MAC_AUX_SEC);
+	nsec *= NSEC_TO_SEC;
+	nsec += XGMAC_RGRD(pdata, MAC_AUX_NSEC);
+
+	return nsec;
+}
+
+static void xgmac_extts_isr_handler(struct mac_prv_data *pdata)
+{
+	u8 val = XGMAC_RGRD_BITS(pdata, MAC_TSTAMP_STSR, ATSSTN);
+	struct ptp_clock_event event;
+
+	if (val & AUX_TRIG_0) {
+		if (pdata->exts0_enabled) {
+			event.type = PTP_CLOCK_EXTTS;
+			event.index = 0;
+			event.timestamp = xgmac_get_auxtimestamp(pdata);
+			ptp_clock_event(pdata->ptp_clock, &event);
+		}
+	}
+
+	if (val & AUX_TRIG_1) {
+		if (pdata->exts1_enabled) {
+			event.type = PTP_CLOCK_EXTTS;
+			event.index = 1;
+			event.timestamp = xgmac_get_auxtimestamp(pdata);
+			ptp_clock_event(pdata->ptp_clock, &event);
+		}
+	}
+}
+
 /* This API performs the required steps for enabling PTP support.
  * This api will be called by MAC driver when initializing MAC
  */
@@ -580,10 +653,17 @@ int xgmac_ptp_init(void *pdev)
 	if (!pdata->hw_feat.ts_src || !pdata->hw_feat.osten) {
 		ret = -1;
 		pdata->ptp_clock = NULL;
-		pr_info("No PTP suppor in HW Aborting PTP clk drv register\n");
+		pr_info("No PTP support in HW Aborting PTP clk drv register\n");
 		return ret;
 	}
 
+	/* do nothing if we already have a clock device */
+	if (pdata->ptp_clock)
+		return -1;
+
+	/* Initialize the 64 Entry Tx FIFO */
+	fifo_init(pdev);
+
 	/* Initialize the spin lock first since we can't control when a user
 	 * will call the entry functions once we have initialized the clock
 	 * device
@@ -596,10 +676,6 @@ int xgmac_ptp_init(void *pdev)
 	 */
 	INIT_WORK(&pdata->ptp_tx_work, (work_func_t)xgmac_ptp_tx_work);
 
-	pdata->ptp_tx_init = 1;
-
-	pdata->one_nsec_accuracy = 1;
-
 	ret = xgmac_ptp_register(pdev);
 
 	if (ret == -1)
@@ -608,10 +684,42 @@ int xgmac_ptp_init(void *pdev)
 	return ret;
 }
 
-static int xgmac_ptp_register(void *pdev)
+int xgmac_get_ts_info(void *pdev,
+		      struct ethtool_ts_info *ts_info)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 
+	ts_info->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |
+				   SOF_TIMESTAMPING_RX_SOFTWARE |
+				   SOF_TIMESTAMPING_SOFTWARE |
+				   SOF_TIMESTAMPING_TX_HARDWARE |
+				   SOF_TIMESTAMPING_RX_HARDWARE |
+				   SOF_TIMESTAMPING_RAW_HARDWARE;
+
+	if (pdata->ptp_clock)
+		ts_info->phc_index = ptp_clock_index(pdata->ptp_clock);
+	else
+		ts_info->phc_index = -1;
+
+	ts_info->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);
+	ts_info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |
+			      (1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |
+			      (1 << HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |
+			      (1 << HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |
+			      (1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |
+			      (1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |
+			      (1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |
+			      (1 << HWTSTAMP_FILTER_PTP_V2_EVENT) |
+			      (1 << HWTSTAMP_FILTER_PTP_V2_SYNC) |
+			      (1 << HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |
+			      (1 << HWTSTAMP_FILTER_ALL);
+
+	return 0;
+}
+
+static int xgmac_ptp_register(void *pdev)
+{
+	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 	struct ptp_clock_info *info = &pdata->ptp_clk_info;
 	int ret = 0;
 
@@ -623,10 +731,13 @@ static int xgmac_ptp_register(void *pdev)
 		 "%s", "xgmac_clk");
 
 	info->owner = THIS_MODULE;
+	info->max_adj = pdata->ptp_clk;
+	info->n_ext_ts = N_EXT_TS;
 	info->adjfreq = xgmac_adj_freq;
 	info->adjtime = xgmac_adj_time;
 	info->gettime64 = xgmac_get_time;
 	info->settime64 = xgmac_set_time;
+	info->enable	= xgmac_extts_enable;
 #ifdef CONFIG_PTP_1588_CLOCK
 	pdata->ptp_clock = ptp_clock_register(info, pdata->dev);
 #endif
@@ -650,12 +761,8 @@ void xgmac_ptp_remove(void *pdev)
 {
 	struct mac_prv_data *pdata = GET_MAC_PDATA(pdev);
 
-	if (pdata->ptp_tx_init) {
-		cancel_work_sync(&pdata->ptp_tx_work);
-		pdata->ptp_tx_init = 0;
-	}
-
 	if (pdata->ptp_clock) {
+		cancel_work_sync(&pdata->ptp_tx_work);
 #ifdef CONFIG_PTP_1588_CLOCK
 		ptp_clock_unregister(pdata->ptp_clock);
 		pr_info("Removed PTP HW clock successfully\n");
diff --git a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.h b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.h
index 054294c83aa2..12d20ab58e9c 100644
--- a/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.h
+++ b/drivers/net/ethernet/lantiq/switch-api/mac/xgmac_ptp.h
@@ -54,19 +54,29 @@ enum {
 	PTP_MSGTYPE_ANNOUNCE			= 0xB,
 	PTP_MSGTYPE_SGNLNG			= 0xC,
 	PTP_MSGTYPE_MNGMNT			= 0xD,
+	PTP_MSGTYPE_INVALID			= 0xE,
 };
 
 /* Byte offset of data in the PTP V2 headers */
 #define PTP_OFFS_MSG_TYPE		0
 #define PTP_OFFS_FLAGS			6
 
+
+#define IS_2STEP(pdata)	(pdata->tstamp_config.tx_type == HWTSTAMP_TX_ON)
+#define IS_1STEP(pdata)	(pdata->tstamp_config.tx_type == HWTSTAMP_TX_ONESTEP_SYNC)
+
+#ifdef __KERNEL__
 int xgmac_tx_hwts(void *pdev, struct sk_buff *skb);
 int xgmac_rx_hwts(void *pdev, struct sk_buff *skb);
-int xgmac_config_hwts(void *pdev, struct ifreq *ifr);
+int xgmac_set_hwts(void *pdev, struct ifreq *ifr);
+int xgmac_get_hwts(void *pdev, struct ifreq *ifr);
 int xgmac_ptp_init(void *pdev);
 void xgmac_ptp_remove(void *pdev);
 void xgmac_config_timer_reg(void *pdev);
 int xgmac_ptp_tx_work(struct work_struct *work);
+int xgmac_get_ts_info(void *pdev,
+		      struct ethtool_ts_info *ts_info);
+#endif
 
 
 #endif
diff --git a/include/net/datapath_api.h b/include/net/datapath_api.h
index a2f629fc416a..fd6ba8d678b5 100644
--- a/include/net/datapath_api.h
+++ b/include/net/datapath_api.h
@@ -955,6 +955,7 @@ struct dp_cap {
 			      */
 	u32 hw_tso: 1; /*!< output: HW TSO offload support for TX path */
 	u32 hw_gso: 1; /*!< output: HW GSO offload support for TX path */
+	u32 hw_ptp: 1; /*!< HW PTP support */
 
 	char qos_eng_name[DP_MAX_NAME]; /*!< QOS engine name in string */
 	char pkt_eng_name[DP_MAX_NAME]; /*!< Packet Engine Name String */
diff --git a/include/net/datapath_api_gswip31.h b/include/net/datapath_api_gswip31.h
index efb4b7ba9355..187e43651bff 100644
--- a/include/net/datapath_api_gswip31.h
+++ b/include/net/datapath_api_gswip31.h
@@ -234,7 +234,7 @@ struct pmac_rx_hdr { /*Egress PMAC header*/
 } __packed;
 #endif
 
-#ifdef CONFIG_LITTLE_ENDIAN
+#ifdef CONFIG_CPU_BIG_ENDIAN
 struct pmac_tx_hdr { /*Ingress PMAC header*/
 	/*byte 0 */
 	u8 tcp_chksum:1;
@@ -274,7 +274,7 @@ struct pmac_tx_hdr { /*Ingress PMAC header*/
 	u8 record_id_lsb:4;
 	u8 igp_egp:4;
 } __packed;
-#else /*big endian */
+#else /*little endian */
 struct pmac_tx_hdr { /*Ingress PMAC header*/
 	/*byte 0 */
 	u8 ip_offset:6;
diff --git a/include/net/datapath_inst.h b/include/net/datapath_inst.h
index 4f0082ab706b..5bd0975863d3 100644
--- a/include/net/datapath_inst.h
+++ b/include/net/datapath_inst.h
@@ -23,6 +23,7 @@ struct pmac_port_info2;
 struct gsw_itf;
 
 #define DP_MAX_GSW_HANDLE 2 /*! max GSW instance per SOC */
+#define DP_MAX_MAC_HANDLE 11 /*! max MAC instance per SOC */
 
 /*! enum for DP HW capability type */
 enum DP_HW_CAP_TYPE {
@@ -43,6 +44,7 @@ struct dp_inst_info {
 	enum DP_HW_CAP_TYPE type;  /*! HW type */
 	enum DP_HW_CAP_VER ver;  /*! HE version */
 	struct core_ops *ops[DP_MAX_GSW_HANDLE]; /*! GSWIP ops handler*/
+	struct mac_ops *mac_ops[DP_MAX_MAC_HANDLE]; /*! GSWIP ops handler*/
 	int cbm_inst;  /*! CBM instance for this DP instance*/
 	int qos_inst; /*! QOS instance for this DP instance*/
 };
@@ -140,6 +142,7 @@ struct inst_property {
 	struct inst_info info;
 	/*driver should know which HW to configure, esp for PCIe case */
 	struct core_ops *ops[DP_MAX_GSW_HANDLE];
+	struct mac_ops *mac_ops[DP_MAX_MAC_HANDLE];	
 	int cbm_inst;
 	int qos_inst;
 	void *priv_hal; /*private data per HAL */
diff --git a/include/net/switch_api/adap_ops.h b/include/net/switch_api/adap_ops.h
old mode 100755
new mode 100644
diff --git a/include/net/switch_api/gsw_flow_ops.h b/include/net/switch_api/gsw_flow_ops.h
index cb75ecbe0b20..413f0a1d6a25 100644
--- a/include/net/switch_api/gsw_flow_ops.h
+++ b/include/net/switch_api/gsw_flow_ops.h
@@ -1,708 +1,708 @@
-/******************************************************************************
-                Copyright (c) 2016, 2017 Intel Corporation
-
-For licensing information, see the file 'LICENSE' in the root folder of
-this software module.
-******************************************************************************/
-
-
-#ifndef _GSW_FLOW_OPS_H_
-#define _GSW_FLOW_OPS_H_
-
-#include "gsw_types.h"
-#include "lantiq_gsw_api.h"
-#include "gsw_irq.h"
-
-
-/*RMON operation*/
-struct rmon_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_RMON_PORT_GET ; Index: 0x01 */
-	GSW_return_t (*RMON_Port_Get)(void *, GSW_RMON_Port_cnt_t *);
-	/* Command: GSW_RMON_MODE_SET ; Index: 0x02 */
-	GSW_return_t (*RMON_Mode_Set)(void *, GSW_RMON_mode_t *);
-	/* Command: GSW_RMON_METER_GET ; Index: 0x03 */
-	GSW_return_t (*RMON_Meter_Get)(void *, GSW_RMON_Meter_cnt_t *);
-	/* Command: GSW_RMON_REDIRECT_GET ; Index: 0x04 */
-	GSW_return_t (*RMON_Redirect_Get)(void *, GSW_RMON_Redirect_cnt_t *);
-	/* Command: GSW_RMON_IF_GET ; Index: 0x05 */
-	GSW_return_t (*RMON_If_Get)(void *, GSW_RMON_If_cnt_t *);
-	/* Command: GSW_RMON_ROUTE_GET ; Index: 0x06 */
-	GSW_return_t (*RMON_Route_Get)(void *, GSW_RMON_Route_cnt_t *);
-	/* Command: GSW_RMON_CLEAR ; Index: 0x07 */
-	GSW_return_t (*RMON_Clear)(void *, GSW_RMON_clear_t *);
-	/* Command: GSW_RMON_EXTEND_GET ; Index: 0x08 */
-	GSW_return_t (*RMON_ExtendGet)(void *, GSW_RMON_extendGet_t *);
-	/* Command: GSW_RMON_FLOW_GET ; Index: 0x09 */
-	GSW_return_t (*RMON_TflowGet)(void *, GSW_RMON_flowGet_t *);
-	/* Command: GSW_RMON_TFLOW_CLEAR ; Index: 0x0A */
-	GSW_return_t (*RMON_TflowClear)(void *, GSW_RMON_flowGet_t *);
-	/* Command: GSW_TFLOW_COUNT_MODE_SET ; Index: 0x0B */
-	GSW_return_t (*RMON_TflowCountModeSet)(void *, GSW_TflowCmodeConf_t *);
-	/* Command: GSW_TFLOW_COUNT_MODE_GET ; Index: 0x0C */
-	GSW_return_t (*RMON_TflowCountModeGet)(void *, GSW_TflowCmodeConf_t *);
-};
-
-/*Switch MAc operations*/
-struct swmac_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_MAC_TABLE_CLEAR ; Index: 0x01 */
-	GSW_return_t (*MAC_TableClear)(void *);
-	/* Command: GSW_MAC_TABLE_ENTRY_ADD ; Index: 0x02 */
-	GSW_return_t (*MAC_TableEntryAdd)(void *, GSW_MAC_tableAdd_t *);
-	/* Command: GSW_MAC_TABLE_ENTRY_READ ; Index: 0x03 */
-	GSW_return_t (*MAC_TableEntryRead)(void *, GSW_MAC_tableRead_t *);
-	/* Command: GSW_MAC_TABLE_ENTRY_QUERY ; Index: 0x04 */
-	GSW_return_t (*MAC_TableEntryQuery)(void *, GSW_MAC_tableQuery_t *);
-	/* Command: GSW_MAC_TABLE_ENTRY_REMOVE ; Index: 0x05 */
-	GSW_return_t (*MAC_TableEntryRemove)(void *, GSW_MAC_tableRemove_t *);
-	/* Command: GSW_DEFAUL_MAC_FILTER_SET ; Index: 0x06 */
-	GSW_return_t (*MAC_DefaultFilterSet)(void *, GSW_MACFILTER_default_t *);
-	/* Command: GSW_DEFAUL_MAC_FILTER_GET ; Index: 0x07 */
-	GSW_return_t (*MAC_DefaultFilterGet)(void *, GSW_MACFILTER_default_t *);
-};
-
-/*Extended Vlan operations*/
-struct extvlan_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_EXTENDEDVLAN_ALLOC ; Index: 0x01 */
-	GSW_return_t (*ExtendedVlan_Alloc)(void *, GSW_EXTENDEDVLAN_alloc_t *);
-	/* Command: GSW_EXTENDEDVLAN_SET ; Index: 0x02 */
-	GSW_return_t (*ExtendedVlan_Set)(void *, GSW_EXTENDEDVLAN_config_t *);
-	/* Command: GSW_EXTENDEDVLAN_GET ; Index: 0x03 */
-	GSW_return_t (*ExtendedVlan_Get)(void *, GSW_EXTENDEDVLAN_config_t *);
-	/* Command: GSW_EXTENDEDVLAN_FREE ; Index: 0x04 */
-	GSW_return_t (*ExtendedVlan_Free)(void *, GSW_EXTENDEDVLAN_alloc_t *);
-};
-
-/*Vlan Filter operations*/
-struct vlanfilter_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_VLANFILTER_ALLOC ; Index: 0x01 */
-	GSW_return_t (*VlanFilter_Alloc)(void *, GSW_VLANFILTER_alloc_t *);
-	/* Command: GSW_VLANFILTER_SET ; Index: 0x02 */
-	GSW_return_t (*VlanFilter_Set)(void *, GSW_VLANFILTER_config_t *);
-	/* Command: GSW_VLANFILTER_GET ; Index: 0x03 */
-	GSW_return_t (*VlanFilter_Get)(void *, GSW_VLANFILTER_config_t *);
-	/* Command: GSW_VLANFILTER_FREE ; Index: 0x04 */
-	GSW_return_t (*VlanFilter_Free)(void *, GSW_VLANFILTER_alloc_t *);
-};
-
-/*CTP operations*/
-struct ctp_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_CTP_PORT_ASSIGNMENT_ALLOC ; Index: 0x01 */
-	GSW_return_t (*CTP_PortAssignmentAlloc)(void *, GSW_CTP_portAssignment_t *);
-	/* Command: GSW_CTP_PORT_ASSIGNMENT_FREE ; Index: 0x02 */
-	GSW_return_t (*CTP_PortAssignmentFree)(void *, GSW_CTP_portAssignment_t *);
-	/* Command: GSW_CTP_PORT_ASSIGNMENT_SET ; Index: 0x03 */
-	GSW_return_t (*CTP_PortAssignmentSet)(void *, GSW_CTP_portAssignment_t *);
-	/* Command: GSW_CTP_PORT_ASSIGNMENT_GET ; Index: 0x04 */
-	GSW_return_t (*CTP_PortAssignmentGet)(void *, GSW_CTP_portAssignment_t *);
-	/* Command: GSW_CTP_PORT_CONFIG_SET ; Index: 0x05 */
-	GSW_return_t (*CTP_PortConfigSet)(void *, GSW_CTP_portConfig_t *);
-	/* Command: GSW_CTP_PORT_CONFIG_GET ; Index: 0x06 */
-	GSW_return_t (*CTP_PortConfigGet)(void *, GSW_CTP_portConfig_t *);
-	/* Command: GSW_CTP_PORT_CONFIG_RESET ; Index: 0x07 */
-	GSW_return_t (*CTP_PortConfigReset)(void *, GSW_CTP_portConfig_t *);
-};
-
-/*Bridge Port operations*/
-struct brdgport_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_BRIDGE_PORT_ALLOC ; Index: 0x01 */
-	GSW_return_t (*BridgePort_Alloc)(void *, GSW_BRIDGE_portAlloc_t *);
-	/* Command: GSW_BRIDGE_PORT_CONFIG_SET ; Index: 0x02 */
-	GSW_return_t (*BridgePort_ConfigSet)(void *, GSW_BRIDGE_portConfig_t *);
-	/* Command: GSW_BRIDGE_PORT_CONFIG_GET ; Index: 0x03 */
-	GSW_return_t (*BridgePort_ConfigGet)(void *, GSW_BRIDGE_portConfig_t *);
-	/* Command: GSW_BRIDGE_PORT_FREE ; Index: 0x04 */
-	GSW_return_t (*BridgePort_Free)(void *, GSW_BRIDGE_portAlloc_t *);
-};
-
-/*Bridge Operations*/
-struct brdg_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_BRIDGE_ALLOC ; Index: 0x01 */
-	GSW_return_t (*Bridge_Alloc)(void *, GSW_BRIDGE_alloc_t *);
-	/* Command: GSW_BRIDGE_CONFIG_SET ; Index: 0x02 */
-	GSW_return_t (*Bridge_ConfigSet)(void *, GSW_BRIDGE_config_t *);
-	/* Command: GSW_BRIDGE_CONFIG_GET ; Index: 0x03 */
-	GSW_return_t (*Bridge_ConfigGet)(void *, GSW_BRIDGE_config_t *);
-	/* Command: GSW_BRIDGE_FREE ; Index: 0x04 */
-	GSW_return_t (*Bridge_Free)(void *, GSW_BRIDGE_alloc_t *);
-};
-
-/*TFlow operations*/
-struct tflow_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_PCE_RULE_DELETE ; Index: 0x01 */
-	GSW_return_t (*TFLOW_PceRuleDelete)(void *, GSW_PCE_ruleDelete_t *);
-	/* Command: GSW_PCE_RULE_READ ; Index: 0x02 */
-	GSW_return_t (*TFLOW_PceRuleRead)(void *, GSW_PCE_rule_t *);
-	/* Command: GSW_PCE_RULE_WRITE ; Index: 0x03 */
-	GSW_return_t (*TFLOW_PceRuleWrite)(void *, GSW_PCE_rule_t *);
-};
-
-/*QOS operations*/
-struct qos_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_QOS_METER_CFG_GET ; Index: 0x01 */
-	GSW_return_t (*QoS_MeterCfgGet)(void *, GSW_QoS_meterCfg_t *);
-	/* Command: GSW_QOS_METER_CFG_SET ; Index: 0x02 */
-	GSW_return_t (*QoS_MeterCfgSet)(void *, GSW_QoS_meterCfg_t *);
-	/* Command: GSW_QOS_METER_PORT_ASSIGN ; Index: 0x03 */
-	GSW_return_t (*QoS_MeterPortAssign)(void *, GSW_QoS_meterPort_t *);
-	/* Command: GSW_QOS_METER_PORT_DEASSIGN ; Index: 0x04 */
-	GSW_return_t (*QoS_MeterPortDeassign)(void *, GSW_QoS_meterPort_t *);
-	/* Command: GSW_QOS_METER_PORT_GET ; Index: 0x05 */
-	GSW_return_t (*QoS_MeterPortGet)(void *, GSW_QoS_meterPortGet_t *);
-	/* Command: GSW_QOS_DSCP_CLASS_GET ; Index: 0x06 */
-	GSW_return_t (*QoS_DSCP_ClassGet)(void *, GSW_QoS_DSCP_ClassCfg_t *);
-	/* Command: GSW_QOS_DSCP_CLASS_SET ; Index: 0x07 */
-	GSW_return_t (*QoS_DSCP_ClassSet)(void *, GSW_QoS_DSCP_ClassCfg_t *);
-	/* Command: GSW_QOS_CLASS_DSCP_GET ; Index: 0x08 */
-	GSW_return_t (*QoS_ClassDSCP_Get)(void *, GSW_QoS_ClassDSCP_Cfg_t *);
-	/* Command: GSW_QOS_CLASS_DSCP_SET ; Index: 0x09 */
-	GSW_return_t (*QoS_ClassDSCP_Set)(void *, GSW_QoS_ClassDSCP_Cfg_t *);
-	/* Command: GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_GET ; Index: 0x0A */
-	GSW_return_t (*QoS_DSCP_DropPrecedenceCfgGet)(void *, GSW_QoS_DSCP_DropPrecedenceCfg_t *);
-	/* Command: GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_SET ; Index: 0x0B */
-	GSW_return_t (*QoS_DSCP_DropPrecedenceCfgSet)(void *, GSW_QoS_DSCP_DropPrecedenceCfg_t *);
-	/* Command: GSW_QOS_PORT_REMARKING_CFG_GET ; Index: 0x0C */
-	GSW_return_t (*QoS_PortRemarkingCfgGet)(void *, GSW_QoS_portRemarkingCfg_t *);
-	/* Command: GSW_QOS_PORT_REMARKING_CFG_SET ; Index: 0x0D */
-	GSW_return_t (*QoS_PortRemarkingCfgSet)(void *, GSW_QoS_portRemarkingCfg_t *);
-	/* Command: GSW_QOS_CLASS_PCP_GET ; Index: 0x0E*/
-	GSW_return_t (*QoS_ClassPCP_Get)(void *, GSW_QoS_ClassPCP_Cfg_t *);
-	/* Command: GSW_QOS_CLASS_PCP_SET ; Index: 0x0F */
-	GSW_return_t (*QoS_ClassPCP_Set)(void *, GSW_QoS_ClassPCP_Cfg_t *);
-	/* Command: GSW_QOS_PCP_CLASS_GET ; Index: 0x10 */
-	GSW_return_t (*QoS_PCP_ClassGet)(void *, GSW_QoS_PCP_ClassCfg_t *);
-	/* Command: GSW_QOS_PCP_CLASS_SET ; Index: 0x11 */
-	GSW_return_t (*QoS_PCP_ClassSet)(void *, GSW_QoS_PCP_ClassCfg_t *);
-	/* Command: GSW_QOS_PORT_CFG_GET ; Index: 0x12 */
-	GSW_return_t (*QoS_PortCfgGet)(void *, GSW_QoS_portCfg_t *);
-	/* Command: GSW_QOS_PORT_CFG_SET ; Index: 0x13 */
-	GSW_return_t (*QoS_PortCfgSet)(void *, GSW_QoS_portCfg_t *);
-	/* Command: GSW_QOS_QUEUE_PORT_GET ; Index: 0x14 */
-	GSW_return_t (*QoS_QueuePortGet)(void *, GSW_QoS_queuePort_t *);
-	/* Command: GSW_QOS_QUEUE_PORT_SET ; Index: 0x15 */
-	GSW_return_t (*QoS_QueuePortSet)(void *, GSW_QoS_queuePort_t *);
-	/* Command: GSW_QOS_SCHEDULER_CFG_GET ; Index: 0x16 */
-	GSW_return_t (*QoS_SchedulerCfgGet)(void *, GSW_QoS_schedulerCfg_t *);
-	/* Command: GSW_QOS_SCHEDULER_CFG_SET ; Index: 0x17 */
-	GSW_return_t (*QoS_SchedulerCfgSet)(void *, GSW_QoS_schedulerCfg_t *);
-	/* Command: GSW_QOS_SHAPER_CFG_GET ; Index: 0x18 */
-	GSW_return_t (*QoS_ShaperCfgGet)(void *, GSW_QoS_ShaperCfg_t *);
-	/* Command: GSW_QOS_SHAPER_CFG_SET ; Index: 0x19 */
-	GSW_return_t (*QoS_ShaperCfgSet)(void *, GSW_QoS_ShaperCfg_t *);
-	/* Command: GSW_QOS_SHAPER_QUEUE_ASSIGN ; Index: 0x1A */
-	GSW_return_t (*QoS_ShaperQueueAssign)(void *, GSW_QoS_ShaperQueue_t *);
-	/* Command: GSW_QOS_SHAPER_QUEUE_DEASSIGN ; Index: 0x1B */
-	GSW_return_t (*QoS_ShaperQueueDeassign)(void *, GSW_QoS_ShaperQueue_t *);
-	/* Command: GSW_QOS_SHAPER_QUEUE_GET ; Index: 0x1C */
-	GSW_return_t (*QoS_ShaperQueueGet)(void *, GSW_QoS_ShaperQueueGet_t *);
-	/* Command: GSW_QOS_STORM_CFG_SET ; Index: 0x1D */
-	GSW_return_t (*QoS_StormCfgSet)(void *, GSW_QoS_stormCfg_t *);
-	/* Command: GSW_QOS_STORM_CFG_GET ; Index: 0x1E */
-	GSW_return_t (*QoS_StormCfgGet)(void *, GSW_QoS_stormCfg_t *);
-	/* Command: GSW_QOS_WRED_CFG_GET ; Index: 0x1F */
-	GSW_return_t (*QoS_WredCfgGet)(void *, GSW_QoS_WRED_Cfg_t *);
-	/* Command: GSW_QOS_WRED_CFG_SET ; Index: 0x20 */
-	GSW_return_t (*QoS_WredCfgSet)(void *, GSW_QoS_WRED_Cfg_t *);
-	/* Command: GSW_QOS_WRED_QUEUE_CFG_GET ; Index: 0x21 */
-	GSW_return_t (*QoS_WredQueueCfgGet)(void *, GSW_QoS_WRED_QueueCfg_t *);
-	/* Command: GSW_QOS_WRED_QUEUE_CFG_SET ; Index: 0x22 */
-	GSW_return_t (*QoS_WredQueueCfgSet)(void *, GSW_QoS_WRED_QueueCfg_t *);
-	/* Command: GSW_QOS_WRED_PORT_CFG_GET ; Index: 0x23 */
-	GSW_return_t (*QoS_WredPortCfgGet)(void *, GSW_QoS_WRED_PortCfg_t *);
-	/* Command: GSW_QOS_WRED_PORT_CFG_SET ; Index: 0x24 */
-	GSW_return_t (*QoS_WredPortCfgSet)(void *, GSW_QoS_WRED_PortCfg_t *);
-	/* Command: GSW_QOS_FLOWCTRL_CFG_GET ; Index: 0x25 */
-	GSW_return_t (*QoS_FlowctrlCfgGet)(void *, GSW_QoS_FlowCtrlCfg_t *);
-	/* Command: GSW_QOS_FLOWCTRL_CFG_SET ; Index: 0x26 */
-	GSW_return_t (*QoS_FlowctrlCfgSet)(void *, GSW_QoS_FlowCtrlCfg_t *);
-	/* Command: GSW_QOS_FLOWCTRL_PORT_CFG_GET ; Index: 0x27 */
-	GSW_return_t (*QoS_FlowctrlPortCfgGet)(void *, GSW_QoS_FlowCtrlPortCfg_t *);
-	/* Command: GSW_QOS_FLOWCTRL_PORT_CFG_SET ; Index: 0x28 */
-	GSW_return_t (*QoS_FlowctrlPortCfgSet)(void *, GSW_QoS_FlowCtrlPortCfg_t *);
-	/* Command: GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_GET ; Index: 0x29 */
-	GSW_return_t (*QoS_QueueBufferReserveCfgGet)(void *, GSW_QoS_QueueBufferReserveCfg_t *);
-	/* Command: GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_SET ; Index: 0x2A */
-	GSW_return_t (*QoS_QueueBufferReserveCfgSet)(void *, GSW_QoS_QueueBufferReserveCfg_t *);
-	/* Command: GSW_QOS_METER_ACT ; Index: 0x2B */
-	GSW_return_t (*QoS_Meter_Act)(void *, GSW_QoS_mtrAction_t *);
-	/* Command: GSW_QOS_COLOR_MARKING_TABLE_SET ; Index: 0x2C */
-	GSW_return_t (*QOS_ColorMarkingTableGet)(void *, GSW_QoS_colorMarkingEntry_t *);
-	/* Command: GSW_QOS_COLOR_MARKING_TABLE_GET ; Index: 0x2D */
-	GSW_return_t (*QOS_ColorMarkingTableSet)(void *, GSW_QoS_colorMarkingEntry_t *);
-	/* Command: GSW_QOS_COLOR_REMARKING_TABLE_SET ; Index: 0x2E */
-	GSW_return_t (*QOS_ColorReMarkingTableSet)(void *, GSW_QoS_colorRemarkingEntry_t *);
-	/* Command: GSW_QOS_COLOR_REMARKING_TABLE_GET ; Index: 0x2F */
-	GSW_return_t (*QOS_ColorReMarkingTableGet)(void *, GSW_QoS_colorRemarkingEntry_t *);
-	/* Command: GSW_QOS_METER_ALLOC ; Index: 0x30 */
-	GSW_return_t (*QOS_MeterAlloc)(void *, GSW_QoS_meterCfg_t *param);
-	/* Command: GSW_QOS_METER_FREE ; Index: 0x31 */
-	GSW_return_t (*QOS_MeterFree)(void *, GSW_QoS_meterCfg_t *param);
-	/* Command: GSW_DSCP2PCP_MAP_SET ; Index: 0x32 */
-	GSW_return_t (*QOS_Dscp2PcpTableSet)(void *, GSW_DSCP2PCP_map_t *);
-	/* Command: GSW_DSCP2PCP_MAP_GET ; Index: 0x33 */
-	GSW_return_t (*QOS_Dscp2PcpTableGet)(void *, GSW_DSCP2PCP_map_t *);
-	/* Command: GSW_PMAPPER_SET ; Index: 0x34 */
-	GSW_return_t (*QOS_PmapperTableSet)(void *, GSW_PMAPPER_t *);
-	/* Command: GSW_PMAPPER_GET ; Index: 0x35 */
-	GSW_return_t (*QOS_PmapperTableGet)(void *, GSW_PMAPPER_t *);
-	/* Command: GSW_QOS_SVLAN_CLASS_PCP_PORT_GET ; Index: 0x36 */
-	GSW_return_t (*QoS_SVLAN_ClassPCP_PortGet)(void *, GSW_QoS_SVLAN_ClassPCP_PortCfg_t *);
-	/* Command: GSW_QOS_SVLAN_CLASS_PCP_PORT_SET ; Index: 0x37 */
-	GSW_return_t (*QoS_SVLAN_ClassPCP_PortSet)(void *, GSW_QoS_SVLAN_ClassPCP_PortCfg_t *);
-	/* Command: GSW_QOS_SVLAN_PCP_CLASS_GET ; Index: 0x38 */
-	GSW_return_t (*QoS_SVLAN_PCP_ClassGet)(void *, GSW_QoS_SVLAN_PCP_ClassCfg_t *);
-	/* Command: GSW_QOS_SVLAN_PCP_CLASS_SET ; Index: 0x39 */
-	GSW_return_t (*QoS_SVLAN_PCP_ClassSet)(void *, GSW_QoS_SVLAN_PCP_ClassCfg_t *);
-};
-
-/*STP operations*/
-struct stp_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_STP_BPDU_RULE_GET ; Index: 0x01 */
-	GSW_return_t (*STP_BPDU_RuleGet)(void *, GSW_STP_BPDU_Rule_t *);
-	/* Command: GSW_STP_BPDU_RULE_SET ; Index: 0x02 */
-	GSW_return_t (*STP_BPDU_RuleSet)(void *, GSW_STP_BPDU_Rule_t *);
-	/* Command: GSW_STP_PORT_CFG_GET ; Index: 0x03 */
-	GSW_return_t (*STP_PortCfgGet)(void *, GSW_STP_portCfg_t *);
-	/* Command: GSW_STP_PORT_CFG_SET ; Index: 0x04 */
-	GSW_return_t (*STP_PortCfgSet)(void *, GSW_STP_portCfg_t *);
-};
-
-/*8021x operations*/
-struct eapol_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_8021X_EAPOL_RULE_GET ; Index: 0x01 */
-	GSW_return_t (*EAPOL_RuleGet)(void *, GSW_8021X_EAPOL_Rule_t *);
-	/* Command: GSW_8021X_EAPOL_RULE_SET ; Index: 0x02 */
-	GSW_return_t (*EAPOL_RuleGet_RuleSet)(void *, GSW_8021X_EAPOL_Rule_t *);
-	/* Command: GSW_8021X_PORT_CFG_GET ; Index: 0x03 */
-	GSW_return_t (*EAPOL_RuleGet_PortCfgGet)(void *, GSW_8021X_portCfg_t *);
-	/* Command: GSW_8021X_PORT_CFG_SET ; Index: 0x04 */
-	GSW_return_t (*EAPOL_RuleGet_PortCfgSet)(void *, GSW_8021X_portCfg_t *);
-};
-
-/*multicast operations*/
-struct multicast_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_MULTICAST_ROUTER_PORT_ADD ; Index: 0x01 */
-	GSW_return_t (*Multicast_RouterPortAdd)(void *, GSW_multicastRouter_t *);
-	/* Command: GSW_MULTICAST_ROUTER_PORT_READ ; Index: 0x02 */
-	GSW_return_t (*Multicast_RouterPortRead)(void *, GSW_multicastRouterRead_t *);
-	/* Command: GSW_MULTICAST_ROUTER_PORT_REMOVE ; Index: 0x03 */
-	GSW_return_t (*Multicast_RouterPortRemove)(void *, GSW_multicastRouter_t *);
-	/* Command: GSW_MULTICAST_SNOOP_CFG_GET ; Index: 0x04 */
-	GSW_return_t (*Multicast_SnoopCfgGet)(void *, GSW_multicastSnoopCfg_t *);
-	/* Command: GSW_MULTICAST_SNOOP_CFG_SET ; Index: 0x05 */
-	GSW_return_t (*Multicast_SnoopCfgSet)(void *, GSW_multicastSnoopCfg_t *);
-	/* Command: GSW_MULTICAST_TABLE_ENTRY_ADD ; Index: 0x06 */
-	GSW_return_t (*Multicast_TableEntryAdd)(void *, GSW_multicastTable_t *);
-	/* Command: GSW_MULTICAST_TABLE_ENTRY_READ ; Index: 0x07 */
-	GSW_return_t (*Multicast_TableEntryRead)(void *, GSW_multicastTableRead_t *);
-	/* Command: GSW_MULTICAST_TABLE_ENTRY_REMOVE ; Index: 0x08 */
-	GSW_return_t (*Multicast_TableEntryRemove)(void *, GSW_multicastTable_t *);
-};
-
-/*Trunking operations*/
-struct trunking_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_TRUNKING_CFG_GET ; Index: 0x01 */
-	GSW_return_t (*Trunking_CfgGet)(void *, GSW_trunkingCfg_t *);
-	/* Command: GSW_TRUNKING_CFG_SET ; Index: 0x02 */
-	GSW_return_t (*Trunking_CfgSet)(void *, GSW_trunkingCfg_t *);
-	/* Command: GSW_TRUNKING_PORT_CFG_GET ; Index: 0x03 */
-	GSW_return_t (*Trunking_PortCfgGet)(void *, GSW_trunkingPortCfg_t *);
-	/* Command: GSW_TRUNKING_PORT_CFG_SET ; Index: 0x04 */
-	GSW_return_t (*Trunking_PortCfgSet)(void *, GSW_trunkingPortCfg_t *);
-};
-
-/*WOL operations*/
-struct wol_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_WOL_CFG_GET ; Index: 0x01 */
-	GSW_return_t (*WoL_CfgGet)(void *, GSW_WoL_Cfg_t *);
-	/* Command: GSW_WOL_CFG_SET ; Index: 0x02 */
-	GSW_return_t (*WoL_CfgSet)(void *, GSW_WoL_Cfg_t *);
-	/* Command: GSW_WOL_PORT_CFG_GET ; Index: 0x03 */
-	GSW_return_t (*WoL_PortCfgGet)(void *, GSW_WoL_PortCfg_t *);
-	/* Command: GSW_WOL_PORT_CFG_SET ; Index: 0x04 */
-	GSW_return_t (*WoL_PortCfgSet)(void *, GSW_WoL_PortCfg_t *);
-};
-
-/*Common switch operations*/
-struct common_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_REGISTER_GET ; Index: 0x01 */
-	GSW_return_t (*RegisterGet)(void *, GSW_register_t *);
-	/* Command: GSW_REGISTER_SET ; Index: 0x02 */
-	GSW_return_t (*RegisterSet)(void *, GSW_register_t *);
-	/* Command: GSW_IRQ_GET ; Index: 0x03 */
-	GSW_return_t (*IrqGet)(void *, GSW_irq_t *);
-	/* Command: GSW_IRQ_MASK_GET ; Index: 0x04 */
-	GSW_return_t (*IrqMaskGet)(void *, GSW_irq_t *);
-	/* Command: GSW_IRQ_MASK_SET ; Index: 0x05 */
-	GSW_return_t (*IrqMaskSet)(void *, GSW_irq_t *);
-	/* Command: GSW_IRQ_STATUS_CLEAR ; Index: 0x06 */
-	GSW_return_t (*IrqStatusClear)(void *, GSW_irq_t *);
-	/* Command: GSW_ENABLE ; Index: 0x07 */
-	GSW_return_t (*Enable)(void *);
-	/* Command: GSW_RESET ; Index: 0x08 */
-	GSW_return_t (*Reset)(void *, GSW_reset_t *);
-	/* Command: GSW_DISABLE ; Index: 0x09 */
-	GSW_return_t (*Disable)(void *);
-	/* Command: GSW_VERSION_GET ; Index: 0x0A */
-	GSW_return_t (*VersionGet)(void *, GSW_version_t *);
-	/* Command: GSW_CAP_GET ; Index: 0x0B */
-	GSW_return_t (*CapGet)(void *, GSW_cap_t *);
-	/* Command: GSW_CFG_GET ; Index: 0x0C */
-	GSW_return_t (*CfgGet)(void *, GSW_cfg_t *);
-	/* Command: GSW_CFG_SET ; Index: 0x0D */
-	GSW_return_t (*CfgSet)(void *, GSW_cfg_t *);
-	/* Command: GSW_HW_INIT ; Index: 0x0E */
-	GSW_return_t (*HW_Init)(void *, GSW_HW_Init_t *);
-	/* Command: GSW_PORT_LINK_CFG_GET ; Index: 0x0F */
-	GSW_return_t (*PortLinkCfgGet)(void *, GSW_portLinkCfg_t *);
-	/* Command: GSW_PORT_LINK_CFG_SET ; Index: 0x10 */
-	GSW_return_t (*PortLinkCfgSet)(void *, GSW_portLinkCfg_t *);
-	/* Command: GSW_PORT_PHY_ADDR_GET ; Index: 0x11 */
-	GSW_return_t (*PortPHY_AddrGet)(void *, GSW_portPHY_Addr_t *);
-	/* Command: GSW_PORT_PHY_QUERY ; Index: 0x12 */
-	GSW_return_t (*PortPHY_Query)(void *, GSW_portPHY_Query_t *);
-	/* Command: GSW_PORT_RGMII_CLK_CFG_GET ; Index: 0x13 */
-	GSW_return_t (*PortRGMII_ClkCfgGet)(void *, GSW_portRGMII_ClkCfg_t *);
-	/* Command: GSW_PORT_RGMII_CLK_CFG_SET ; Index: 0x14 */
-	GSW_return_t (*PortRGMII_ClkCfgSet)(void *, GSW_portRGMII_ClkCfg_t *);
-	/* Command: GSW_PORT_REDIRECT_GET ; Index: 0x15 */
-	GSW_return_t (*PortRedirectGet)(void *, GSW_portRedirectCfg_t *);
-	/* Command: GSW_PORT_REDIRECT_SET ; Index: 0x16 */
-	GSW_return_t (*PortRedirectSet)(void *, GSW_portRedirectCfg_t *);
-	/* Command: GSW_CPU_PORT_CFG_GET ; Index: 0x17 */
-	GSW_return_t (*CPU_PortCfgGet)(void *, GSW_CPU_PortCfg_t *);
-	/* Command: GSW_CPU_PORT_CFG_SET ; Index: 0x18 */
-	GSW_return_t (*CPU_PortCfgSet)(void *, GSW_CPU_PortCfg_t *);
-	/* Command: GSW_CPU_PORT_EXTEND_CFG_GET ; Index: 0x19 */
-	GSW_return_t (*CPU_PortExtendCfgGet)(void *, GSW_CPU_PortExtendCfg_t *);
-	/* Command: GSW_CPU_PORT_EXTEND_CFG_SET ; Index: 0x1A */
-	GSW_return_t (*CPU_PortExtendCfgSet)(void *, GSW_CPU_PortExtendCfg_t *);
-	/* Command: GSW_MONITOR_PORT_CFG_GET ; Index: 0x1B */
-	GSW_return_t (*MonitorPortCfgGet)(void *, GSW_monitorPortCfg_t *);
-	/* Command: GSW_MONITOR_PORT_CFG_SET ; Index: 0x1C */
-	GSW_return_t (*MonitorPortCfgSet)(void *, GSW_monitorPortCfg_t *);
-	/* Command: GSW_TIMESTAMP_TIMER_SET ; Index: 0x1D */
-	GSW_return_t (*Timestamp_TimerSet)(void *, GSW_TIMESTAMP_Timer_t *);
-	/* Command: GSW_TIMESTAMP_TIMER_GET ; Index: 0x1E */
-	GSW_return_t (*Timestamp_TimerGet)(void *, GSW_TIMESTAMP_Timer_t *);
-	/* Command: GSW_TIMESTAMP_PORT_READ ; Index: 0x1F */
-	GSW_return_t (*Timestamp_PortRead)(void *, GSW_TIMESTAMP_PortRead_t *);
-	/* Command: GSW_PORT_CFG_GET ; Index: 0x20 */
-	GSW_return_t (*PortCfgGet)(void *, GSW_portCfg_t *);
-	/* Command: GSW_PORT_CFG_SET ; Index: 0x21 */
-	GSW_return_t (*PortCfgSet)(void *, GSW_portCfg_t *);
-	/* Command: GSW_MDIO_CFG_GET ; Index: 0x22 */
-	GSW_return_t (*MDIO_CfgGet)(void *, GSW_MDIO_cfg_t *);
-	/* Command: GSW_MDIO_CFG_SET ; Index: 0x23 */
-	GSW_return_t (*MDIO_CfgSet)(void *, GSW_MDIO_cfg_t *);
-	/* Command: GSW_MDIO_DATA_READ ; Index: 0x24 */
-	GSW_return_t (*MDIO_DataRead)(void *, GSW_MDIO_data_t *);
-	/* Command: GSW_MDIO_DATA_WRITE ; Index: 0x25 */
-	GSW_return_t (*MDIO_DataWrite)(void *, GSW_MDIO_data_t *);
-	/* Command: GSW_MMD_DATA_READ ; Index: 0x26 */
-	GSW_return_t (*MmdDataRead)(void *, GSW_MMD_data_t *);
-	/* Command: GSW_MMD_DATA_WRITE ; Index: 0x27 */
-	GSW_return_t (*MmdDataWrite)(void *, GSW_MMD_data_t *);
-};
-
-struct vlan_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_VLAN_MEMBER_INIT ; Index: 0x01 */
-	GSW_return_t (*VLAN_Member_Init)(void *, GSW_VLAN_memberInit_t *);
-	/* Command: GSW_VLAN_ID_CREATE ; Index: 0x02 */
-	GSW_return_t (*VLAN_IdCreate)(void *, GSW_VLAN_IdCreate_t *);
-	/* Command: GSW_VLAN_ID_DELETE ; Index: 0x03 */
-	GSW_return_t (*VLAN_IdDelete)(void *, GSW_VLAN_IdDelete_t *);
-	/* Command: GSW_VLAN_ID_GET ; Index: 0x04 */
-	GSW_return_t (*VLAN_IdGet)(void *, GSW_VLAN_IdGet_t *);
-	/* Command: GSW_VLAN_PORT_CFG_GET ; Index: 0x05 */
-	GSW_return_t (*VLAN_PortCfgGet)(void *, GSW_VLAN_portCfg_t *);
-	/* Command: GSW_VLAN_PORT_CFG_SET ; Index: 0x06 */
-	GSW_return_t (*VLAN_PortCfgSet)(void *, GSW_VLAN_portCfg_t *);
-	/* Command: GSW_VLAN_PORT_MEMBER_ADD ; Index: 0x07 */
-	GSW_return_t (*VLAN_PortMemberAdd)(void *, GSW_VLAN_portMemberAdd_t *);
-	/* Command: GSW_VLAN_PORT_MEMBER_READ ; Index: 0x08 */
-	GSW_return_t (*VLAN_PortMemberRead)(void *, GSW_VLAN_portMemberRead_t *);
-	/* Command: GSW_VLAN_PORT_MEMBER_REMOVE ; Index: 0x09 */
-	GSW_return_t (*VLAN_PortMemberRemove)(void *, GSW_VLAN_portMemberRemove_t *);
-	/* Command: GSW_VLAN_RESERVED_ADD ; Index: 0x0A */
-	GSW_return_t (*VLAN_ReservedAdd)(void *, GSW_VLAN_reserved_t *);
-	/* Command: GSW_VLAN_RESERVED_REMOVE ; Index: 0x0B */
-	GSW_return_t (*VLAN_ReservedRemove)(void *, GSW_VLAN_reserved_t *);
-	/* Command: GSW_PCE_EG_VLAN_CFG_SET ; Index: 0x0C */
-	GSW_return_t (*VLAN_PCE_EG_CfgSet)(void *, GSW_PCE_EgVLAN_Cfg_t *);
-	/* Command: GSW_PCE_EG_VLAN_CFG_GET ; Index: 0x0D */
-	GSW_return_t (*VLAN_PCE_EG_CfgGet)(void *, GSW_PCE_EgVLAN_Cfg_t *);
-	/* Command: GSW_PCE_EG_VLAN_ENTRY_WRITE ; Index: 0x0E */
-	GSW_return_t (*VLAN_PCE_EG_EntryWrite)(void *, GSW_PCE_EgVLAN_Entry_t *);
-	/* Command: GSW_PCE_EG_VLAN_ENTRY_READ ; Index: 0x0F */
-	GSW_return_t (*VLAN_PCE_EG_EntryRead)(void *, GSW_PCE_EgVLAN_Entry_t *);
-	/* Command: GSW_SVLAN_CFG_GET ; Index: 0x10 */
-	GSW_return_t (*SVLAN_CfgGet)(void *, GSW_SVLAN_cfg_t *);
-	/* Command: GSW_SVLAN_CFG_SET ; Index: 0x11 */
-	GSW_return_t (*SVLAN_CfgSet)(void *, GSW_SVLAN_cfg_t *);
-	/* Command: GSW_SVLAN_PORT_CFG_GET ; Index: 0x12 */
-	GSW_return_t (*SVLAN_PortCfgGet)(void *, GSW_SVLAN_portCfg_t *);
-	/* Command: GSW_SVLAN_PORT_CFG_SET ; Index: 0x13 */
-	GSW_return_t (*SVLAN_PortCfgSet)(void *, GSW_SVLAN_portCfg_t *);
-};
-
-/*PMAC operation*/
-struct pmac_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_PMAC_COUNT_GET ; Index: 0x01 */
-	int (*Pmac_CountGet)(void *, GSW_PMAC_Cnt_t *);
-	/* Command: GSW_PMAC_GLBL_CFG_SET ; Index: 0x02 */
-	int (*Pmac_Gbl_CfgSet)(void *, GSW_PMAC_Glbl_Cfg_t *);
-	/* Command: GSW_PMAC_GLBL_CFG_GET ; Index: 0x03 */
-	int (*Pmac_Gbl_CfgGet)(void *, GSW_PMAC_Glbl_Cfg_t *);
-	/* Command: GSW_PMAC_BM_CFG_SET ; Index: 0x04 */
-	int (*Pmac_Bm_CfgSet)(void *, GSW_PMAC_BM_Cfg_t *);
-	/* Command: GSW_PMAC_BM_CFG_GET ; Index: 0x05 */
-	int (*Pmac_Bm_CfgGet)(void *, GSW_PMAC_BM_Cfg_t *);
-	/* Command: GSW_PMAC_IG_CFG_SET ; Index: 0x06 */
-	int (*Pmac_Ig_CfgSet)(void *, GSW_PMAC_Ig_Cfg_t *);
-	/* Command: GSW_PMAC_IG_CFG_GET ; Index: 0x07 */
-	int (*Pmac_Ig_CfgGet)(void *, GSW_PMAC_Ig_Cfg_t *);
-	/* Command: GSW_PMAC_EG_CFG_SET ; Index: 0x08 */
-	int (*Pmac_Eg_CfgSet)(void *, GSW_PMAC_Eg_Cfg_t *);
-	/* Command: GSW_PMAC_EG_CFG_GET ; Index: 0x09 */
-	int (*Pmac_Eg_CfgGet)(void *, GSW_PMAC_Eg_Cfg_t *);
-};
-
-
-
-/*PAE operation*/
-struct pae_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_ROUTE_ENTRY_ADD ; Index: 0x01 */
-	int (*ROUTE_SessionEntryAdd)(void *, GSW_ROUTE_Entry_t *);
-	/* Command: GSW_ROUTE_ENTRY_DELETE ; Index: 0x02 */
-	int (*ROUTE_SessionEntryDel)(void *, GSW_ROUTE_Entry_t *);
-	/* Command: GSW_ROUTE_ENTRY_READ ; Index: 0x03 */
-	int (*ROUTE_SessionEntryRead)(void *, GSW_ROUTE_Entry_t *);
-	/* Command: GSW_ROUTE_TUNNEL_ENTRY_ADD ; Index: 0x04 */
-	int (*ROUTE_TunnelEntryAdd)(void *, GSW_ROUTE_Tunnel_Entry_t *);
-	/* Command: GSW_ROUTE_TUNNEL_ENTRY_READ ; Index: 0x05 */
-	int (*ROUTE_TunnelEntryRead)(void *, GSW_ROUTE_Tunnel_Entry_t *);
-	/* Command: GSW_ROUTE_TUNNEL_ENTRY_DELETE ; Index: 0x06 */
-	int (*ROUTE_TunnelEntryDel)(void *, GSW_ROUTE_Tunnel_Entry_t *);
-	/* Command: GSW_ROUTE_L2NAT_CFG_WRITE ; Index: 0x07 */
-	int (*ROUTE_L2NATCfgWrite)(void *, GSW_ROUTE_EgPort_L2NAT_Cfg_t *);
-	/* Command: GSW_ROUTE_L2NAT_CFG_READ ; Index: 0x08 */
-	int (*ROUTE_L2NATCfgRead)(void *, GSW_ROUTE_EgPort_L2NAT_Cfg_t *);
-	/* Command: GSW_ROUTE_SESSION_HIT_OP ; Index: 0x09 */
-	int (*ROUTE_SessHitOp)(void *, GSW_ROUTE_Session_Hit_t *);
-	/* Command: GSW_ROUTE_SESSION_DEST_MOD ; Index: 0x0A */
-	int (*ROUTE_SessDestModify)(void *, GSW_ROUTE_Session_Dest_t *);
-};
-
-
-struct debug_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_DEBUG_CTPTABLE_STATUS ; Index: 0x01 */
-	GSW_return_t (*DEBUG_CtpTableStatus)(void *, GSW_debug_t *);
-	/* Command: GSW_DEBUG_BRDGPORTTABLE_STATUS ; Index: 0x02 */
-	GSW_return_t (*DEBUG_BrgPortTableStatus)(void *, GSW_debug_t *);
-	/* Command: GSW_DEBUG_BRDGTABLE_STATUS ; Index: 0x03 */
-	GSW_return_t (*DEBUG_BrgTableStatus)(void *, GSW_debug_t *);
-	/* Command: GSW_DEBUG_EXVLANTABLE_STATUS ; Index: 0x04 */
-	GSW_return_t (*DEBUG_ExvlanTableStatus)(void *, GSW_debug_t *);
-	/* Command: GSW_DEBUG_VLANFILTERTABLE_STATUS ; Index: 0x05 */
-	GSW_return_t (*DEBUG_VlanFilterTableStatus)(void *, GSW_debug_t *);
-	/* Command: GSW_DEBUG_METERTABLE_STATUS ; Index: 0x06 */
-	GSW_return_t (*DEBUG_MeterTableStatus)(void *, GSW_debug_t *);
-	/* Command: GSW_DEBUG_DSCP2PCPTABLE_STATUS ; Index: 0x07 */
-	GSW_return_t (*DEBUG_Dscp2PcpTableStatus)(void *, GSW_debug_t *);
-	/* Command: GSW_DEBUG_PMAPPER_STATUS ; Index: 0x08 */
-	GSW_return_t (*DEBUG_PmapperTableStatus)(void *, GSW_debug_t *);
-	/* Command: GSW_DEBUG_PMAC_EG ; Index: 0x09 */
-	GSW_return_t (*DEBUG_PmacEg)(void *, GSW_debug_t *);
-	/* Command: GSW_DEBUG_PMAC_IG ; Index: 0x0A */
-	GSW_return_t (*DEBUG_PmacIg)(void *, GSW_debug_t *);
-	/* Command: GSW_DEBUG_DEF_QMAP ; Index: 0x0B */
-	GSW_return_t (*DEBUG_Def_PceQmap)(void *, GSW_debug_t *);
-	/* Command: GSW_DEBUG_DEF_BYP_QMAP ; Index: 0x0C */
-	GSW_return_t (*DEBUG_Def_PceBypQmap)(void *, GSW_debug_t *);
-	/* Command: GSW_DEBUG_PMAC_BP ; Index: 0x0D */
-	GSW_return_t (*DEBUG_PmacBp)(void *, GSW_debug_t *);
-	/* Command: GSW_DEBUG_LP_STATISTICS ; Index: 0x0E */
-	GSW_return_t (*DEBUG_GetLpStatistics)(void *, GSW_debug_t *);
-	/* Command: GSW_DEBUG_CTP_STATISTICS ; Index: 0x0F */
-	GSW_return_t (*DEBUG_GetCtpStatistics)(void *, GSW_debug_t *);
-	/* Command: GSW_XGMAC_CFG ; Index: 0x10 */
-	GSW_return_t (*Xgmac)(void *, GSW_MAC_cfg_t *);
-	/* Command: GSW_GSWSS_CFG ; Index: 0x11 */
-	GSW_return_t (*Gswss)(void *, GSW_MAC_cfg_t *);
-	/* Command: GSW_LMAC_CFG ; Index: 0x12 */
-	GSW_return_t (*Lmac)(void *, GSW_MAC_cfg_t *);
-	/* Command: GSW_MACSEC_CFG ; Index: 0x13 */
-	GSW_return_t (*Macsec)(void *, GSW_MAC_cfg_t *);
-	/* Command: GSW_DUMP_MEM ; Index: 0x14 */
-	GSW_return_t (*DumpMem)(void *, GSW_table_t *);
-	/* Command: GSW_DEBUG_PRINT_PCEIRQ_LIST ; Index: 0x15 */
-	GSW_return_t (*DEBUG_PrintPceIrqList)(void *);
-	/* Command: GSW_DEBUG_RMON_PORT_GET ; Index: 0x16 */
-	GSW_return_t (*DEBUG_RMON_Port_Get)(void *, GSW_Debug_RMON_Port_cnt_t *);
-};
-
-struct irq_ops {
-	/* Command: (NULL); Index: 0x00 */
-	GSW_return_t (*null)(void);
-	/* Command: GSW_IRQ_REGISTER ; Index: 0x01 */
-	GSW_return_t (*IRQ_Register)(void *, GSW_Irq_Op_t *);
-	/* Command: GSW_IRQ_UNREGISTER ; Index: 0x02 */
-	GSW_return_t (*IRQ_UnRegister)(void *, GSW_Irq_Op_t *);
-	/* Command: GSW_IRQ_ENABLE ; Index: 0x03 */
-	GSW_return_t (*IRQ_Enable)(void *, GSW_Irq_Op_t *);
-	/* Command: GSW_IRQ_DISABLE ; Index: 0x04 */
-	GSW_return_t (*IRQ_Disable)(void *, GSW_Irq_Op_t *);
-};
-
-
-struct core_ops {
-	/**Switch Opertations**/
-	/*RMON Counters GET opertations for Port/Meter/TFlow/Redirect
-	  RMON Counters Mode SET opertations
-	  RMON Counters CLEAR operations
-	  NOTE: Applicable for GSWIP 3.1 and GSWIP 3.0*/
-
-	struct rmon_ops 			gsw_rmon_ops;
-
-	/*Switch MAC table ADD/READ/QUERY/CLEAR/REMOVE operations
-	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0/GSWIP 2.2
-
-	  Switch Defaul MAC filter SET/GET operations
-	  NOTE: Applicable for GSWIP 3.1 only*/
-
-	struct swmac_ops 			gsw_swmac_ops;
-
-	/*Extended VLAN Block ALLOC/SET/GET/FREE operations
-	  NOTE: Applicable for GSWIP 3.1 only*/
-
-	struct extvlan_ops		gsw_extvlan_ops;
-
-	/*VLAN Filter Block ALLOC/SET/GET/FREE operations
-	  NOTE: Applicable for GSWIP 3.1 only*/
-
-	struct vlanfilter_ops 	gsw_vlanfilter_ops;
-
-	/*CTP Port ALLOC/FREE operations
-	  CTP Port Configuration SET/GET/RESET operations
-	  NOTE: Applicable for GSWIP 3.1 only*/
-
-	struct ctp_ops			gsw_ctp_ops;
-
-	/*Bridge Port ALLOC/FREE operations
-	  Bridge Port Configuration SET/GET operations
-	  NOTE: Applicable for GSWIP 3.1 only*/
-
-	struct brdgport_ops		gsw_brdgport_ops;
-
-	/*Bridge ALLOC/FREE operations
-	  Bridge Configuration SET/GET operations
-	  NOTE: Applicable for GSWIP 3.1 only*/
-
-	struct brdg_ops			gsw_brdg_ops;
-
-	/*TFLOW PCE Rule Read/Write/Delete operations
-	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0/GSWIP 2.2*/
-
-	struct tflow_ops			gsw_tflow_ops;
-
-	/*QOS related operations
-	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0/GSWIP 2.2*/
-
-	struct qos_ops			gsw_qos_ops;
-
-	/*Spanning Tree Protocol opertaions
-	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
-
-	struct stp_ops			gsw_stp_ops;
-
-	/*Extensible Authentication Protocol opertaions
-	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
-
-	struct eapol_ops			gsw_8021x_ops;
-
-	/*Multicast related opertaions
-	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
-
-	struct multicast_ops		gsw_multicast_ops;
-
-	/*Port Trunking opertaions
-	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
-
-	struct trunking_ops		gsw_trunking_ops;
-
-	/*Wake On Lan opertaions
-	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
-
-	struct wol_ops			gsw_wol_ops;
-
-	/*VLAN/SVLAN related opertaions
-	 NOTE: Applicable Only for GSWIP 3.0 and below*/
-
-	struct vlan_ops			gsw_vlan_ops;
-
-	/*PMAC related opertaions
-	 NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
-
-	struct pmac_ops			gsw_pmac_ops;
-
-	/*PAE related opertaions*/
-	struct pae_ops			gsw_pae_ops;
-
-	/*Common Purpose Switch operations like
-	Switch REG read/write
-	Irq mask set/get/status clear
-	Switch enable/disable/reset/init
-	Port monitor set/get
-	Port link get/set
-	Port redirect
-	Time stamp,version get
-	Switch capablity get ..etc
-	 NOTE: Applicable for GSWIP 3.1/GSWIP 3.0/GSWIP 2.2*/
-
-	struct common_ops			gsw_common_ops;
-	/*Debug Purpose for GSWIP 3.1*/
-	struct debug_ops			gsw_debug_ops;
-
-	struct irq_ops			gsw_irq_ops;
-};
-
-
-#endif
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+For licensing information, see the file 'LICENSE' in the root folder of
+this software module.
+******************************************************************************/
+
+
+#ifndef _GSW_FLOW_OPS_H_
+#define _GSW_FLOW_OPS_H_
+
+#include "gsw_types.h"
+#include "lantiq_gsw_api.h"
+#include "gsw_irq.h"
+
+
+/*RMON operation*/
+struct rmon_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_RMON_PORT_GET ; Index: 0x01 */
+	GSW_return_t (*RMON_Port_Get)(void *, GSW_RMON_Port_cnt_t *);
+	/* Command: GSW_RMON_MODE_SET ; Index: 0x02 */
+	GSW_return_t (*RMON_Mode_Set)(void *, GSW_RMON_mode_t *);
+	/* Command: GSW_RMON_METER_GET ; Index: 0x03 */
+	GSW_return_t (*RMON_Meter_Get)(void *, GSW_RMON_Meter_cnt_t *);
+	/* Command: GSW_RMON_REDIRECT_GET ; Index: 0x04 */
+	GSW_return_t (*RMON_Redirect_Get)(void *, GSW_RMON_Redirect_cnt_t *);
+	/* Command: GSW_RMON_IF_GET ; Index: 0x05 */
+	GSW_return_t (*RMON_If_Get)(void *, GSW_RMON_If_cnt_t *);
+	/* Command: GSW_RMON_ROUTE_GET ; Index: 0x06 */
+	GSW_return_t (*RMON_Route_Get)(void *, GSW_RMON_Route_cnt_t *);
+	/* Command: GSW_RMON_CLEAR ; Index: 0x07 */
+	GSW_return_t (*RMON_Clear)(void *, GSW_RMON_clear_t *);
+	/* Command: GSW_RMON_EXTEND_GET ; Index: 0x08 */
+	GSW_return_t (*RMON_ExtendGet)(void *, GSW_RMON_extendGet_t *);
+	/* Command: GSW_RMON_FLOW_GET ; Index: 0x09 */
+	GSW_return_t (*RMON_TflowGet)(void *, GSW_RMON_flowGet_t *);
+	/* Command: GSW_RMON_TFLOW_CLEAR ; Index: 0x0A */
+	GSW_return_t (*RMON_TflowClear)(void *, GSW_RMON_flowGet_t *);
+	/* Command: GSW_TFLOW_COUNT_MODE_SET ; Index: 0x0B */
+	GSW_return_t (*RMON_TflowCountModeSet)(void *, GSW_TflowCmodeConf_t *);
+	/* Command: GSW_TFLOW_COUNT_MODE_GET ; Index: 0x0C */
+	GSW_return_t (*RMON_TflowCountModeGet)(void *, GSW_TflowCmodeConf_t *);
+};
+
+/*Switch MAc operations*/
+struct swmac_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_MAC_TABLE_CLEAR ; Index: 0x01 */
+	GSW_return_t (*MAC_TableClear)(void *);
+	/* Command: GSW_MAC_TABLE_ENTRY_ADD ; Index: 0x02 */
+	GSW_return_t (*MAC_TableEntryAdd)(void *, GSW_MAC_tableAdd_t *);
+	/* Command: GSW_MAC_TABLE_ENTRY_READ ; Index: 0x03 */
+	GSW_return_t (*MAC_TableEntryRead)(void *, GSW_MAC_tableRead_t *);
+	/* Command: GSW_MAC_TABLE_ENTRY_QUERY ; Index: 0x04 */
+	GSW_return_t (*MAC_TableEntryQuery)(void *, GSW_MAC_tableQuery_t *);
+	/* Command: GSW_MAC_TABLE_ENTRY_REMOVE ; Index: 0x05 */
+	GSW_return_t (*MAC_TableEntryRemove)(void *, GSW_MAC_tableRemove_t *);
+	/* Command: GSW_DEFAUL_MAC_FILTER_SET ; Index: 0x06 */
+	GSW_return_t (*MAC_DefaultFilterSet)(void *, GSW_MACFILTER_default_t *);
+	/* Command: GSW_DEFAUL_MAC_FILTER_GET ; Index: 0x07 */
+	GSW_return_t (*MAC_DefaultFilterGet)(void *, GSW_MACFILTER_default_t *);
+};
+
+/*Extended Vlan operations*/
+struct extvlan_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_EXTENDEDVLAN_ALLOC ; Index: 0x01 */
+	GSW_return_t (*ExtendedVlan_Alloc)(void *, GSW_EXTENDEDVLAN_alloc_t *);
+	/* Command: GSW_EXTENDEDVLAN_SET ; Index: 0x02 */
+	GSW_return_t (*ExtendedVlan_Set)(void *, GSW_EXTENDEDVLAN_config_t *);
+	/* Command: GSW_EXTENDEDVLAN_GET ; Index: 0x03 */
+	GSW_return_t (*ExtendedVlan_Get)(void *, GSW_EXTENDEDVLAN_config_t *);
+	/* Command: GSW_EXTENDEDVLAN_FREE ; Index: 0x04 */
+	GSW_return_t (*ExtendedVlan_Free)(void *, GSW_EXTENDEDVLAN_alloc_t *);
+};
+
+/*Vlan Filter operations*/
+struct vlanfilter_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_VLANFILTER_ALLOC ; Index: 0x01 */
+	GSW_return_t (*VlanFilter_Alloc)(void *, GSW_VLANFILTER_alloc_t *);
+	/* Command: GSW_VLANFILTER_SET ; Index: 0x02 */
+	GSW_return_t (*VlanFilter_Set)(void *, GSW_VLANFILTER_config_t *);
+	/* Command: GSW_VLANFILTER_GET ; Index: 0x03 */
+	GSW_return_t (*VlanFilter_Get)(void *, GSW_VLANFILTER_config_t *);
+	/* Command: GSW_VLANFILTER_FREE ; Index: 0x04 */
+	GSW_return_t (*VlanFilter_Free)(void *, GSW_VLANFILTER_alloc_t *);
+};
+
+/*CTP operations*/
+struct ctp_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_CTP_PORT_ASSIGNMENT_ALLOC ; Index: 0x01 */
+	GSW_return_t (*CTP_PortAssignmentAlloc)(void *, GSW_CTP_portAssignment_t *);
+	/* Command: GSW_CTP_PORT_ASSIGNMENT_FREE ; Index: 0x02 */
+	GSW_return_t (*CTP_PortAssignmentFree)(void *, GSW_CTP_portAssignment_t *);
+	/* Command: GSW_CTP_PORT_ASSIGNMENT_SET ; Index: 0x03 */
+	GSW_return_t (*CTP_PortAssignmentSet)(void *, GSW_CTP_portAssignment_t *);
+	/* Command: GSW_CTP_PORT_ASSIGNMENT_GET ; Index: 0x04 */
+	GSW_return_t (*CTP_PortAssignmentGet)(void *, GSW_CTP_portAssignment_t *);
+	/* Command: GSW_CTP_PORT_CONFIG_SET ; Index: 0x05 */
+	GSW_return_t (*CTP_PortConfigSet)(void *, GSW_CTP_portConfig_t *);
+	/* Command: GSW_CTP_PORT_CONFIG_GET ; Index: 0x06 */
+	GSW_return_t (*CTP_PortConfigGet)(void *, GSW_CTP_portConfig_t *);
+	/* Command: GSW_CTP_PORT_CONFIG_RESET ; Index: 0x07 */
+	GSW_return_t (*CTP_PortConfigReset)(void *, GSW_CTP_portConfig_t *);
+};
+
+/*Bridge Port operations*/
+struct brdgport_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_BRIDGE_PORT_ALLOC ; Index: 0x01 */
+	GSW_return_t (*BridgePort_Alloc)(void *, GSW_BRIDGE_portAlloc_t *);
+	/* Command: GSW_BRIDGE_PORT_CONFIG_SET ; Index: 0x02 */
+	GSW_return_t (*BridgePort_ConfigSet)(void *, GSW_BRIDGE_portConfig_t *);
+	/* Command: GSW_BRIDGE_PORT_CONFIG_GET ; Index: 0x03 */
+	GSW_return_t (*BridgePort_ConfigGet)(void *, GSW_BRIDGE_portConfig_t *);
+	/* Command: GSW_BRIDGE_PORT_FREE ; Index: 0x04 */
+	GSW_return_t (*BridgePort_Free)(void *, GSW_BRIDGE_portAlloc_t *);
+};
+
+/*Bridge Operations*/
+struct brdg_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_BRIDGE_ALLOC ; Index: 0x01 */
+	GSW_return_t (*Bridge_Alloc)(void *, GSW_BRIDGE_alloc_t *);
+	/* Command: GSW_BRIDGE_CONFIG_SET ; Index: 0x02 */
+	GSW_return_t (*Bridge_ConfigSet)(void *, GSW_BRIDGE_config_t *);
+	/* Command: GSW_BRIDGE_CONFIG_GET ; Index: 0x03 */
+	GSW_return_t (*Bridge_ConfigGet)(void *, GSW_BRIDGE_config_t *);
+	/* Command: GSW_BRIDGE_FREE ; Index: 0x04 */
+	GSW_return_t (*Bridge_Free)(void *, GSW_BRIDGE_alloc_t *);
+};
+
+/*TFlow operations*/
+struct tflow_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_PCE_RULE_DELETE ; Index: 0x01 */
+	GSW_return_t (*TFLOW_PceRuleDelete)(void *, GSW_PCE_ruleDelete_t *);
+	/* Command: GSW_PCE_RULE_READ ; Index: 0x02 */
+	GSW_return_t (*TFLOW_PceRuleRead)(void *, GSW_PCE_rule_t *);
+	/* Command: GSW_PCE_RULE_WRITE ; Index: 0x03 */
+	GSW_return_t (*TFLOW_PceRuleWrite)(void *, GSW_PCE_rule_t *);
+};
+
+/*QOS operations*/
+struct qos_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_QOS_METER_CFG_GET ; Index: 0x01 */
+	GSW_return_t (*QoS_MeterCfgGet)(void *, GSW_QoS_meterCfg_t *);
+	/* Command: GSW_QOS_METER_CFG_SET ; Index: 0x02 */
+	GSW_return_t (*QoS_MeterCfgSet)(void *, GSW_QoS_meterCfg_t *);
+	/* Command: GSW_QOS_METER_PORT_ASSIGN ; Index: 0x03 */
+	GSW_return_t (*QoS_MeterPortAssign)(void *, GSW_QoS_meterPort_t *);
+	/* Command: GSW_QOS_METER_PORT_DEASSIGN ; Index: 0x04 */
+	GSW_return_t (*QoS_MeterPortDeassign)(void *, GSW_QoS_meterPort_t *);
+	/* Command: GSW_QOS_METER_PORT_GET ; Index: 0x05 */
+	GSW_return_t (*QoS_MeterPortGet)(void *, GSW_QoS_meterPortGet_t *);
+	/* Command: GSW_QOS_DSCP_CLASS_GET ; Index: 0x06 */
+	GSW_return_t (*QoS_DSCP_ClassGet)(void *, GSW_QoS_DSCP_ClassCfg_t *);
+	/* Command: GSW_QOS_DSCP_CLASS_SET ; Index: 0x07 */
+	GSW_return_t (*QoS_DSCP_ClassSet)(void *, GSW_QoS_DSCP_ClassCfg_t *);
+	/* Command: GSW_QOS_CLASS_DSCP_GET ; Index: 0x08 */
+	GSW_return_t (*QoS_ClassDSCP_Get)(void *, GSW_QoS_ClassDSCP_Cfg_t *);
+	/* Command: GSW_QOS_CLASS_DSCP_SET ; Index: 0x09 */
+	GSW_return_t (*QoS_ClassDSCP_Set)(void *, GSW_QoS_ClassDSCP_Cfg_t *);
+	/* Command: GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_GET ; Index: 0x0A */
+	GSW_return_t (*QoS_DSCP_DropPrecedenceCfgGet)(void *, GSW_QoS_DSCP_DropPrecedenceCfg_t *);
+	/* Command: GSW_QOS_DSCP_DROP_PRECEDENCE_CFG_SET ; Index: 0x0B */
+	GSW_return_t (*QoS_DSCP_DropPrecedenceCfgSet)(void *, GSW_QoS_DSCP_DropPrecedenceCfg_t *);
+	/* Command: GSW_QOS_PORT_REMARKING_CFG_GET ; Index: 0x0C */
+	GSW_return_t (*QoS_PortRemarkingCfgGet)(void *, GSW_QoS_portRemarkingCfg_t *);
+	/* Command: GSW_QOS_PORT_REMARKING_CFG_SET ; Index: 0x0D */
+	GSW_return_t (*QoS_PortRemarkingCfgSet)(void *, GSW_QoS_portRemarkingCfg_t *);
+	/* Command: GSW_QOS_CLASS_PCP_GET ; Index: 0x0E*/
+	GSW_return_t (*QoS_ClassPCP_Get)(void *, GSW_QoS_ClassPCP_Cfg_t *);
+	/* Command: GSW_QOS_CLASS_PCP_SET ; Index: 0x0F */
+	GSW_return_t (*QoS_ClassPCP_Set)(void *, GSW_QoS_ClassPCP_Cfg_t *);
+	/* Command: GSW_QOS_PCP_CLASS_GET ; Index: 0x10 */
+	GSW_return_t (*QoS_PCP_ClassGet)(void *, GSW_QoS_PCP_ClassCfg_t *);
+	/* Command: GSW_QOS_PCP_CLASS_SET ; Index: 0x11 */
+	GSW_return_t (*QoS_PCP_ClassSet)(void *, GSW_QoS_PCP_ClassCfg_t *);
+	/* Command: GSW_QOS_PORT_CFG_GET ; Index: 0x12 */
+	GSW_return_t (*QoS_PortCfgGet)(void *, GSW_QoS_portCfg_t *);
+	/* Command: GSW_QOS_PORT_CFG_SET ; Index: 0x13 */
+	GSW_return_t (*QoS_PortCfgSet)(void *, GSW_QoS_portCfg_t *);
+	/* Command: GSW_QOS_QUEUE_PORT_GET ; Index: 0x14 */
+	GSW_return_t (*QoS_QueuePortGet)(void *, GSW_QoS_queuePort_t *);
+	/* Command: GSW_QOS_QUEUE_PORT_SET ; Index: 0x15 */
+	GSW_return_t (*QoS_QueuePortSet)(void *, GSW_QoS_queuePort_t *);
+	/* Command: GSW_QOS_SCHEDULER_CFG_GET ; Index: 0x16 */
+	GSW_return_t (*QoS_SchedulerCfgGet)(void *, GSW_QoS_schedulerCfg_t *);
+	/* Command: GSW_QOS_SCHEDULER_CFG_SET ; Index: 0x17 */
+	GSW_return_t (*QoS_SchedulerCfgSet)(void *, GSW_QoS_schedulerCfg_t *);
+	/* Command: GSW_QOS_SHAPER_CFG_GET ; Index: 0x18 */
+	GSW_return_t (*QoS_ShaperCfgGet)(void *, GSW_QoS_ShaperCfg_t *);
+	/* Command: GSW_QOS_SHAPER_CFG_SET ; Index: 0x19 */
+	GSW_return_t (*QoS_ShaperCfgSet)(void *, GSW_QoS_ShaperCfg_t *);
+	/* Command: GSW_QOS_SHAPER_QUEUE_ASSIGN ; Index: 0x1A */
+	GSW_return_t (*QoS_ShaperQueueAssign)(void *, GSW_QoS_ShaperQueue_t *);
+	/* Command: GSW_QOS_SHAPER_QUEUE_DEASSIGN ; Index: 0x1B */
+	GSW_return_t (*QoS_ShaperQueueDeassign)(void *, GSW_QoS_ShaperQueue_t *);
+	/* Command: GSW_QOS_SHAPER_QUEUE_GET ; Index: 0x1C */
+	GSW_return_t (*QoS_ShaperQueueGet)(void *, GSW_QoS_ShaperQueueGet_t *);
+	/* Command: GSW_QOS_STORM_CFG_SET ; Index: 0x1D */
+	GSW_return_t (*QoS_StormCfgSet)(void *, GSW_QoS_stormCfg_t *);
+	/* Command: GSW_QOS_STORM_CFG_GET ; Index: 0x1E */
+	GSW_return_t (*QoS_StormCfgGet)(void *, GSW_QoS_stormCfg_t *);
+	/* Command: GSW_QOS_WRED_CFG_GET ; Index: 0x1F */
+	GSW_return_t (*QoS_WredCfgGet)(void *, GSW_QoS_WRED_Cfg_t *);
+	/* Command: GSW_QOS_WRED_CFG_SET ; Index: 0x20 */
+	GSW_return_t (*QoS_WredCfgSet)(void *, GSW_QoS_WRED_Cfg_t *);
+	/* Command: GSW_QOS_WRED_QUEUE_CFG_GET ; Index: 0x21 */
+	GSW_return_t (*QoS_WredQueueCfgGet)(void *, GSW_QoS_WRED_QueueCfg_t *);
+	/* Command: GSW_QOS_WRED_QUEUE_CFG_SET ; Index: 0x22 */
+	GSW_return_t (*QoS_WredQueueCfgSet)(void *, GSW_QoS_WRED_QueueCfg_t *);
+	/* Command: GSW_QOS_WRED_PORT_CFG_GET ; Index: 0x23 */
+	GSW_return_t (*QoS_WredPortCfgGet)(void *, GSW_QoS_WRED_PortCfg_t *);
+	/* Command: GSW_QOS_WRED_PORT_CFG_SET ; Index: 0x24 */
+	GSW_return_t (*QoS_WredPortCfgSet)(void *, GSW_QoS_WRED_PortCfg_t *);
+	/* Command: GSW_QOS_FLOWCTRL_CFG_GET ; Index: 0x25 */
+	GSW_return_t (*QoS_FlowctrlCfgGet)(void *, GSW_QoS_FlowCtrlCfg_t *);
+	/* Command: GSW_QOS_FLOWCTRL_CFG_SET ; Index: 0x26 */
+	GSW_return_t (*QoS_FlowctrlCfgSet)(void *, GSW_QoS_FlowCtrlCfg_t *);
+	/* Command: GSW_QOS_FLOWCTRL_PORT_CFG_GET ; Index: 0x27 */
+	GSW_return_t (*QoS_FlowctrlPortCfgGet)(void *, GSW_QoS_FlowCtrlPortCfg_t *);
+	/* Command: GSW_QOS_FLOWCTRL_PORT_CFG_SET ; Index: 0x28 */
+	GSW_return_t (*QoS_FlowctrlPortCfgSet)(void *, GSW_QoS_FlowCtrlPortCfg_t *);
+	/* Command: GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_GET ; Index: 0x29 */
+	GSW_return_t (*QoS_QueueBufferReserveCfgGet)(void *, GSW_QoS_QueueBufferReserveCfg_t *);
+	/* Command: GSW_QOS_QUEUE_BUFFER_RESERVE_CFG_SET ; Index: 0x2A */
+	GSW_return_t (*QoS_QueueBufferReserveCfgSet)(void *, GSW_QoS_QueueBufferReserveCfg_t *);
+	/* Command: GSW_QOS_METER_ACT ; Index: 0x2B */
+	GSW_return_t (*QoS_Meter_Act)(void *, GSW_QoS_mtrAction_t *);
+	/* Command: GSW_QOS_COLOR_MARKING_TABLE_SET ; Index: 0x2C */
+	GSW_return_t (*QOS_ColorMarkingTableGet)(void *, GSW_QoS_colorMarkingEntry_t *);
+	/* Command: GSW_QOS_COLOR_MARKING_TABLE_GET ; Index: 0x2D */
+	GSW_return_t (*QOS_ColorMarkingTableSet)(void *, GSW_QoS_colorMarkingEntry_t *);
+	/* Command: GSW_QOS_COLOR_REMARKING_TABLE_SET ; Index: 0x2E */
+	GSW_return_t (*QOS_ColorReMarkingTableSet)(void *, GSW_QoS_colorRemarkingEntry_t *);
+	/* Command: GSW_QOS_COLOR_REMARKING_TABLE_GET ; Index: 0x2F */
+	GSW_return_t (*QOS_ColorReMarkingTableGet)(void *, GSW_QoS_colorRemarkingEntry_t *);
+	/* Command: GSW_QOS_METER_ALLOC ; Index: 0x30 */
+	GSW_return_t (*QOS_MeterAlloc)(void *, GSW_QoS_meterCfg_t *param);
+	/* Command: GSW_QOS_METER_FREE ; Index: 0x31 */
+	GSW_return_t (*QOS_MeterFree)(void *, GSW_QoS_meterCfg_t *param);
+	/* Command: GSW_DSCP2PCP_MAP_SET ; Index: 0x32 */
+	GSW_return_t (*QOS_Dscp2PcpTableSet)(void *, GSW_DSCP2PCP_map_t *);
+	/* Command: GSW_DSCP2PCP_MAP_GET ; Index: 0x33 */
+	GSW_return_t (*QOS_Dscp2PcpTableGet)(void *, GSW_DSCP2PCP_map_t *);
+	/* Command: GSW_PMAPPER_SET ; Index: 0x34 */
+	GSW_return_t (*QOS_PmapperTableSet)(void *, GSW_PMAPPER_t *);
+	/* Command: GSW_PMAPPER_GET ; Index: 0x35 */
+	GSW_return_t (*QOS_PmapperTableGet)(void *, GSW_PMAPPER_t *);
+	/* Command: GSW_QOS_SVLAN_CLASS_PCP_PORT_GET ; Index: 0x36 */
+	GSW_return_t (*QoS_SVLAN_ClassPCP_PortGet)(void *, GSW_QoS_SVLAN_ClassPCP_PortCfg_t *);
+	/* Command: GSW_QOS_SVLAN_CLASS_PCP_PORT_SET ; Index: 0x37 */
+	GSW_return_t (*QoS_SVLAN_ClassPCP_PortSet)(void *, GSW_QoS_SVLAN_ClassPCP_PortCfg_t *);
+	/* Command: GSW_QOS_SVLAN_PCP_CLASS_GET ; Index: 0x38 */
+	GSW_return_t (*QoS_SVLAN_PCP_ClassGet)(void *, GSW_QoS_SVLAN_PCP_ClassCfg_t *);
+	/* Command: GSW_QOS_SVLAN_PCP_CLASS_SET ; Index: 0x39 */
+	GSW_return_t (*QoS_SVLAN_PCP_ClassSet)(void *, GSW_QoS_SVLAN_PCP_ClassCfg_t *);
+};
+
+/*STP operations*/
+struct stp_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_STP_BPDU_RULE_GET ; Index: 0x01 */
+	GSW_return_t (*STP_BPDU_RuleGet)(void *, GSW_STP_BPDU_Rule_t *);
+	/* Command: GSW_STP_BPDU_RULE_SET ; Index: 0x02 */
+	GSW_return_t (*STP_BPDU_RuleSet)(void *, GSW_STP_BPDU_Rule_t *);
+	/* Command: GSW_STP_PORT_CFG_GET ; Index: 0x03 */
+	GSW_return_t (*STP_PortCfgGet)(void *, GSW_STP_portCfg_t *);
+	/* Command: GSW_STP_PORT_CFG_SET ; Index: 0x04 */
+	GSW_return_t (*STP_PortCfgSet)(void *, GSW_STP_portCfg_t *);
+};
+
+/*8021x operations*/
+struct eapol_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_8021X_EAPOL_RULE_GET ; Index: 0x01 */
+	GSW_return_t (*EAPOL_RuleGet)(void *, GSW_8021X_EAPOL_Rule_t *);
+	/* Command: GSW_8021X_EAPOL_RULE_SET ; Index: 0x02 */
+	GSW_return_t (*EAPOL_RuleGet_RuleSet)(void *, GSW_8021X_EAPOL_Rule_t *);
+	/* Command: GSW_8021X_PORT_CFG_GET ; Index: 0x03 */
+	GSW_return_t (*EAPOL_RuleGet_PortCfgGet)(void *, GSW_8021X_portCfg_t *);
+	/* Command: GSW_8021X_PORT_CFG_SET ; Index: 0x04 */
+	GSW_return_t (*EAPOL_RuleGet_PortCfgSet)(void *, GSW_8021X_portCfg_t *);
+};
+
+/*multicast operations*/
+struct multicast_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_MULTICAST_ROUTER_PORT_ADD ; Index: 0x01 */
+	GSW_return_t (*Multicast_RouterPortAdd)(void *, GSW_multicastRouter_t *);
+	/* Command: GSW_MULTICAST_ROUTER_PORT_READ ; Index: 0x02 */
+	GSW_return_t (*Multicast_RouterPortRead)(void *, GSW_multicastRouterRead_t *);
+	/* Command: GSW_MULTICAST_ROUTER_PORT_REMOVE ; Index: 0x03 */
+	GSW_return_t (*Multicast_RouterPortRemove)(void *, GSW_multicastRouter_t *);
+	/* Command: GSW_MULTICAST_SNOOP_CFG_GET ; Index: 0x04 */
+	GSW_return_t (*Multicast_SnoopCfgGet)(void *, GSW_multicastSnoopCfg_t *);
+	/* Command: GSW_MULTICAST_SNOOP_CFG_SET ; Index: 0x05 */
+	GSW_return_t (*Multicast_SnoopCfgSet)(void *, GSW_multicastSnoopCfg_t *);
+	/* Command: GSW_MULTICAST_TABLE_ENTRY_ADD ; Index: 0x06 */
+	GSW_return_t (*Multicast_TableEntryAdd)(void *, GSW_multicastTable_t *);
+	/* Command: GSW_MULTICAST_TABLE_ENTRY_READ ; Index: 0x07 */
+	GSW_return_t (*Multicast_TableEntryRead)(void *, GSW_multicastTableRead_t *);
+	/* Command: GSW_MULTICAST_TABLE_ENTRY_REMOVE ; Index: 0x08 */
+	GSW_return_t (*Multicast_TableEntryRemove)(void *, GSW_multicastTable_t *);
+};
+
+/*Trunking operations*/
+struct trunking_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_TRUNKING_CFG_GET ; Index: 0x01 */
+	GSW_return_t (*Trunking_CfgGet)(void *, GSW_trunkingCfg_t *);
+	/* Command: GSW_TRUNKING_CFG_SET ; Index: 0x02 */
+	GSW_return_t (*Trunking_CfgSet)(void *, GSW_trunkingCfg_t *);
+	/* Command: GSW_TRUNKING_PORT_CFG_GET ; Index: 0x03 */
+	GSW_return_t (*Trunking_PortCfgGet)(void *, GSW_trunkingPortCfg_t *);
+	/* Command: GSW_TRUNKING_PORT_CFG_SET ; Index: 0x04 */
+	GSW_return_t (*Trunking_PortCfgSet)(void *, GSW_trunkingPortCfg_t *);
+};
+
+/*WOL operations*/
+struct wol_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_WOL_CFG_GET ; Index: 0x01 */
+	GSW_return_t (*WoL_CfgGet)(void *, GSW_WoL_Cfg_t *);
+	/* Command: GSW_WOL_CFG_SET ; Index: 0x02 */
+	GSW_return_t (*WoL_CfgSet)(void *, GSW_WoL_Cfg_t *);
+	/* Command: GSW_WOL_PORT_CFG_GET ; Index: 0x03 */
+	GSW_return_t (*WoL_PortCfgGet)(void *, GSW_WoL_PortCfg_t *);
+	/* Command: GSW_WOL_PORT_CFG_SET ; Index: 0x04 */
+	GSW_return_t (*WoL_PortCfgSet)(void *, GSW_WoL_PortCfg_t *);
+};
+
+/*Common switch operations*/
+struct common_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_REGISTER_GET ; Index: 0x01 */
+	GSW_return_t (*RegisterGet)(void *, GSW_register_t *);
+	/* Command: GSW_REGISTER_SET ; Index: 0x02 */
+	GSW_return_t (*RegisterSet)(void *, GSW_register_t *);
+	/* Command: GSW_IRQ_GET ; Index: 0x03 */
+	GSW_return_t (*IrqGet)(void *, GSW_irq_t *);
+	/* Command: GSW_IRQ_MASK_GET ; Index: 0x04 */
+	GSW_return_t (*IrqMaskGet)(void *, GSW_irq_t *);
+	/* Command: GSW_IRQ_MASK_SET ; Index: 0x05 */
+	GSW_return_t (*IrqMaskSet)(void *, GSW_irq_t *);
+	/* Command: GSW_IRQ_STATUS_CLEAR ; Index: 0x06 */
+	GSW_return_t (*IrqStatusClear)(void *, GSW_irq_t *);
+	/* Command: GSW_ENABLE ; Index: 0x07 */
+	GSW_return_t (*Enable)(void *);
+	/* Command: GSW_RESET ; Index: 0x08 */
+	GSW_return_t (*Reset)(void *, GSW_reset_t *);
+	/* Command: GSW_DISABLE ; Index: 0x09 */
+	GSW_return_t (*Disable)(void *);
+	/* Command: GSW_VERSION_GET ; Index: 0x0A */
+	GSW_return_t (*VersionGet)(void *, GSW_version_t *);
+	/* Command: GSW_CAP_GET ; Index: 0x0B */
+	GSW_return_t (*CapGet)(void *, GSW_cap_t *);
+	/* Command: GSW_CFG_GET ; Index: 0x0C */
+	GSW_return_t (*CfgGet)(void *, GSW_cfg_t *);
+	/* Command: GSW_CFG_SET ; Index: 0x0D */
+	GSW_return_t (*CfgSet)(void *, GSW_cfg_t *);
+	/* Command: GSW_HW_INIT ; Index: 0x0E */
+	GSW_return_t (*HW_Init)(void *, GSW_HW_Init_t *);
+	/* Command: GSW_PORT_LINK_CFG_GET ; Index: 0x0F */
+	GSW_return_t (*PortLinkCfgGet)(void *, GSW_portLinkCfg_t *);
+	/* Command: GSW_PORT_LINK_CFG_SET ; Index: 0x10 */
+	GSW_return_t (*PortLinkCfgSet)(void *, GSW_portLinkCfg_t *);
+	/* Command: GSW_PORT_PHY_ADDR_GET ; Index: 0x11 */
+	GSW_return_t (*PortPHY_AddrGet)(void *, GSW_portPHY_Addr_t *);
+	/* Command: GSW_PORT_PHY_QUERY ; Index: 0x12 */
+	GSW_return_t (*PortPHY_Query)(void *, GSW_portPHY_Query_t *);
+	/* Command: GSW_PORT_RGMII_CLK_CFG_GET ; Index: 0x13 */
+	GSW_return_t (*PortRGMII_ClkCfgGet)(void *, GSW_portRGMII_ClkCfg_t *);
+	/* Command: GSW_PORT_RGMII_CLK_CFG_SET ; Index: 0x14 */
+	GSW_return_t (*PortRGMII_ClkCfgSet)(void *, GSW_portRGMII_ClkCfg_t *);
+	/* Command: GSW_PORT_REDIRECT_GET ; Index: 0x15 */
+	GSW_return_t (*PortRedirectGet)(void *, GSW_portRedirectCfg_t *);
+	/* Command: GSW_PORT_REDIRECT_SET ; Index: 0x16 */
+	GSW_return_t (*PortRedirectSet)(void *, GSW_portRedirectCfg_t *);
+	/* Command: GSW_CPU_PORT_CFG_GET ; Index: 0x17 */
+	GSW_return_t (*CPU_PortCfgGet)(void *, GSW_CPU_PortCfg_t *);
+	/* Command: GSW_CPU_PORT_CFG_SET ; Index: 0x18 */
+	GSW_return_t (*CPU_PortCfgSet)(void *, GSW_CPU_PortCfg_t *);
+	/* Command: GSW_CPU_PORT_EXTEND_CFG_GET ; Index: 0x19 */
+	GSW_return_t (*CPU_PortExtendCfgGet)(void *, GSW_CPU_PortExtendCfg_t *);
+	/* Command: GSW_CPU_PORT_EXTEND_CFG_SET ; Index: 0x1A */
+	GSW_return_t (*CPU_PortExtendCfgSet)(void *, GSW_CPU_PortExtendCfg_t *);
+	/* Command: GSW_MONITOR_PORT_CFG_GET ; Index: 0x1B */
+	GSW_return_t (*MonitorPortCfgGet)(void *, GSW_monitorPortCfg_t *);
+	/* Command: GSW_MONITOR_PORT_CFG_SET ; Index: 0x1C */
+	GSW_return_t (*MonitorPortCfgSet)(void *, GSW_monitorPortCfg_t *);
+	/* Command: GSW_TIMESTAMP_TIMER_SET ; Index: 0x1D */
+	GSW_return_t (*Timestamp_TimerSet)(void *, GSW_TIMESTAMP_Timer_t *);
+	/* Command: GSW_TIMESTAMP_TIMER_GET ; Index: 0x1E */
+	GSW_return_t (*Timestamp_TimerGet)(void *, GSW_TIMESTAMP_Timer_t *);
+	/* Command: GSW_TIMESTAMP_PORT_READ ; Index: 0x1F */
+	GSW_return_t (*Timestamp_PortRead)(void *, GSW_TIMESTAMP_PortRead_t *);
+	/* Command: GSW_PORT_CFG_GET ; Index: 0x20 */
+	GSW_return_t (*PortCfgGet)(void *, GSW_portCfg_t *);
+	/* Command: GSW_PORT_CFG_SET ; Index: 0x21 */
+	GSW_return_t (*PortCfgSet)(void *, GSW_portCfg_t *);
+	/* Command: GSW_MDIO_CFG_GET ; Index: 0x22 */
+	GSW_return_t (*MDIO_CfgGet)(void *, GSW_MDIO_cfg_t *);
+	/* Command: GSW_MDIO_CFG_SET ; Index: 0x23 */
+	GSW_return_t (*MDIO_CfgSet)(void *, GSW_MDIO_cfg_t *);
+	/* Command: GSW_MDIO_DATA_READ ; Index: 0x24 */
+	GSW_return_t (*MDIO_DataRead)(void *, GSW_MDIO_data_t *);
+	/* Command: GSW_MDIO_DATA_WRITE ; Index: 0x25 */
+	GSW_return_t (*MDIO_DataWrite)(void *, GSW_MDIO_data_t *);
+	/* Command: GSW_MMD_DATA_READ ; Index: 0x26 */
+	GSW_return_t (*MmdDataRead)(void *, GSW_MMD_data_t *);
+	/* Command: GSW_MMD_DATA_WRITE ; Index: 0x27 */
+	GSW_return_t (*MmdDataWrite)(void *, GSW_MMD_data_t *);
+};
+
+struct vlan_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_VLAN_MEMBER_INIT ; Index: 0x01 */
+	GSW_return_t (*VLAN_Member_Init)(void *, GSW_VLAN_memberInit_t *);
+	/* Command: GSW_VLAN_ID_CREATE ; Index: 0x02 */
+	GSW_return_t (*VLAN_IdCreate)(void *, GSW_VLAN_IdCreate_t *);
+	/* Command: GSW_VLAN_ID_DELETE ; Index: 0x03 */
+	GSW_return_t (*VLAN_IdDelete)(void *, GSW_VLAN_IdDelete_t *);
+	/* Command: GSW_VLAN_ID_GET ; Index: 0x04 */
+	GSW_return_t (*VLAN_IdGet)(void *, GSW_VLAN_IdGet_t *);
+	/* Command: GSW_VLAN_PORT_CFG_GET ; Index: 0x05 */
+	GSW_return_t (*VLAN_PortCfgGet)(void *, GSW_VLAN_portCfg_t *);
+	/* Command: GSW_VLAN_PORT_CFG_SET ; Index: 0x06 */
+	GSW_return_t (*VLAN_PortCfgSet)(void *, GSW_VLAN_portCfg_t *);
+	/* Command: GSW_VLAN_PORT_MEMBER_ADD ; Index: 0x07 */
+	GSW_return_t (*VLAN_PortMemberAdd)(void *, GSW_VLAN_portMemberAdd_t *);
+	/* Command: GSW_VLAN_PORT_MEMBER_READ ; Index: 0x08 */
+	GSW_return_t (*VLAN_PortMemberRead)(void *, GSW_VLAN_portMemberRead_t *);
+	/* Command: GSW_VLAN_PORT_MEMBER_REMOVE ; Index: 0x09 */
+	GSW_return_t (*VLAN_PortMemberRemove)(void *, GSW_VLAN_portMemberRemove_t *);
+	/* Command: GSW_VLAN_RESERVED_ADD ; Index: 0x0A */
+	GSW_return_t (*VLAN_ReservedAdd)(void *, GSW_VLAN_reserved_t *);
+	/* Command: GSW_VLAN_RESERVED_REMOVE ; Index: 0x0B */
+	GSW_return_t (*VLAN_ReservedRemove)(void *, GSW_VLAN_reserved_t *);
+	/* Command: GSW_PCE_EG_VLAN_CFG_SET ; Index: 0x0C */
+	GSW_return_t (*VLAN_PCE_EG_CfgSet)(void *, GSW_PCE_EgVLAN_Cfg_t *);
+	/* Command: GSW_PCE_EG_VLAN_CFG_GET ; Index: 0x0D */
+	GSW_return_t (*VLAN_PCE_EG_CfgGet)(void *, GSW_PCE_EgVLAN_Cfg_t *);
+	/* Command: GSW_PCE_EG_VLAN_ENTRY_WRITE ; Index: 0x0E */
+	GSW_return_t (*VLAN_PCE_EG_EntryWrite)(void *, GSW_PCE_EgVLAN_Entry_t *);
+	/* Command: GSW_PCE_EG_VLAN_ENTRY_READ ; Index: 0x0F */
+	GSW_return_t (*VLAN_PCE_EG_EntryRead)(void *, GSW_PCE_EgVLAN_Entry_t *);
+	/* Command: GSW_SVLAN_CFG_GET ; Index: 0x10 */
+	GSW_return_t (*SVLAN_CfgGet)(void *, GSW_SVLAN_cfg_t *);
+	/* Command: GSW_SVLAN_CFG_SET ; Index: 0x11 */
+	GSW_return_t (*SVLAN_CfgSet)(void *, GSW_SVLAN_cfg_t *);
+	/* Command: GSW_SVLAN_PORT_CFG_GET ; Index: 0x12 */
+	GSW_return_t (*SVLAN_PortCfgGet)(void *, GSW_SVLAN_portCfg_t *);
+	/* Command: GSW_SVLAN_PORT_CFG_SET ; Index: 0x13 */
+	GSW_return_t (*SVLAN_PortCfgSet)(void *, GSW_SVLAN_portCfg_t *);
+};
+
+/*PMAC operation*/
+struct pmac_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_PMAC_COUNT_GET ; Index: 0x01 */
+	int (*Pmac_CountGet)(void *, GSW_PMAC_Cnt_t *);
+	/* Command: GSW_PMAC_GLBL_CFG_SET ; Index: 0x02 */
+	int (*Pmac_Gbl_CfgSet)(void *, GSW_PMAC_Glbl_Cfg_t *);
+	/* Command: GSW_PMAC_GLBL_CFG_GET ; Index: 0x03 */
+	int (*Pmac_Gbl_CfgGet)(void *, GSW_PMAC_Glbl_Cfg_t *);
+	/* Command: GSW_PMAC_BM_CFG_SET ; Index: 0x04 */
+	int (*Pmac_Bm_CfgSet)(void *, GSW_PMAC_BM_Cfg_t *);
+	/* Command: GSW_PMAC_BM_CFG_GET ; Index: 0x05 */
+	int (*Pmac_Bm_CfgGet)(void *, GSW_PMAC_BM_Cfg_t *);
+	/* Command: GSW_PMAC_IG_CFG_SET ; Index: 0x06 */
+	int (*Pmac_Ig_CfgSet)(void *, GSW_PMAC_Ig_Cfg_t *);
+	/* Command: GSW_PMAC_IG_CFG_GET ; Index: 0x07 */
+	int (*Pmac_Ig_CfgGet)(void *, GSW_PMAC_Ig_Cfg_t *);
+	/* Command: GSW_PMAC_EG_CFG_SET ; Index: 0x08 */
+	int (*Pmac_Eg_CfgSet)(void *, GSW_PMAC_Eg_Cfg_t *);
+	/* Command: GSW_PMAC_EG_CFG_GET ; Index: 0x09 */
+	int (*Pmac_Eg_CfgGet)(void *, GSW_PMAC_Eg_Cfg_t *);
+};
+
+
+
+/*PAE operation*/
+struct pae_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_ROUTE_ENTRY_ADD ; Index: 0x01 */
+	int (*ROUTE_SessionEntryAdd)(void *, GSW_ROUTE_Entry_t *);
+	/* Command: GSW_ROUTE_ENTRY_DELETE ; Index: 0x02 */
+	int (*ROUTE_SessionEntryDel)(void *, GSW_ROUTE_Entry_t *);
+	/* Command: GSW_ROUTE_ENTRY_READ ; Index: 0x03 */
+	int (*ROUTE_SessionEntryRead)(void *, GSW_ROUTE_Entry_t *);
+	/* Command: GSW_ROUTE_TUNNEL_ENTRY_ADD ; Index: 0x04 */
+	int (*ROUTE_TunnelEntryAdd)(void *, GSW_ROUTE_Tunnel_Entry_t *);
+	/* Command: GSW_ROUTE_TUNNEL_ENTRY_READ ; Index: 0x05 */
+	int (*ROUTE_TunnelEntryRead)(void *, GSW_ROUTE_Tunnel_Entry_t *);
+	/* Command: GSW_ROUTE_TUNNEL_ENTRY_DELETE ; Index: 0x06 */
+	int (*ROUTE_TunnelEntryDel)(void *, GSW_ROUTE_Tunnel_Entry_t *);
+	/* Command: GSW_ROUTE_L2NAT_CFG_WRITE ; Index: 0x07 */
+	int (*ROUTE_L2NATCfgWrite)(void *, GSW_ROUTE_EgPort_L2NAT_Cfg_t *);
+	/* Command: GSW_ROUTE_L2NAT_CFG_READ ; Index: 0x08 */
+	int (*ROUTE_L2NATCfgRead)(void *, GSW_ROUTE_EgPort_L2NAT_Cfg_t *);
+	/* Command: GSW_ROUTE_SESSION_HIT_OP ; Index: 0x09 */
+	int (*ROUTE_SessHitOp)(void *, GSW_ROUTE_Session_Hit_t *);
+	/* Command: GSW_ROUTE_SESSION_DEST_MOD ; Index: 0x0A */
+	int (*ROUTE_SessDestModify)(void *, GSW_ROUTE_Session_Dest_t *);
+};
+
+
+struct debug_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_DEBUG_CTPTABLE_STATUS ; Index: 0x01 */
+	GSW_return_t (*DEBUG_CtpTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_BRDGPORTTABLE_STATUS ; Index: 0x02 */
+	GSW_return_t (*DEBUG_BrgPortTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_BRDGTABLE_STATUS ; Index: 0x03 */
+	GSW_return_t (*DEBUG_BrgTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_EXVLANTABLE_STATUS ; Index: 0x04 */
+	GSW_return_t (*DEBUG_ExvlanTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_VLANFILTERTABLE_STATUS ; Index: 0x05 */
+	GSW_return_t (*DEBUG_VlanFilterTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_METERTABLE_STATUS ; Index: 0x06 */
+	GSW_return_t (*DEBUG_MeterTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_DSCP2PCPTABLE_STATUS ; Index: 0x07 */
+	GSW_return_t (*DEBUG_Dscp2PcpTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_PMAPPER_STATUS ; Index: 0x08 */
+	GSW_return_t (*DEBUG_PmapperTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_PMAC_EG ; Index: 0x09 */
+	GSW_return_t (*DEBUG_PmacEg)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_PMAC_IG ; Index: 0x0A */
+	GSW_return_t (*DEBUG_PmacIg)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_DEF_QMAP ; Index: 0x0B */
+	GSW_return_t (*DEBUG_Def_PceQmap)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_DEF_BYP_QMAP ; Index: 0x0C */
+	GSW_return_t (*DEBUG_Def_PceBypQmap)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_PMAC_BP ; Index: 0x0D */
+	GSW_return_t (*DEBUG_PmacBp)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_LP_STATISTICS ; Index: 0x0E */
+	GSW_return_t (*DEBUG_GetLpStatistics)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_CTP_STATISTICS ; Index: 0x0F */
+	GSW_return_t (*DEBUG_GetCtpStatistics)(void *, GSW_debug_t *);
+	/* Command: GSW_XGMAC_CFG ; Index: 0x10 */
+	GSW_return_t (*Xgmac)(void *, GSW_MAC_cfg_t *);
+	/* Command: GSW_GSWSS_CFG ; Index: 0x11 */
+	GSW_return_t (*Gswss)(void *, GSW_MAC_cfg_t *);
+	/* Command: GSW_LMAC_CFG ; Index: 0x12 */
+	GSW_return_t (*Lmac)(void *, GSW_MAC_cfg_t *);
+	/* Command: GSW_MACSEC_CFG ; Index: 0x13 */
+	GSW_return_t (*Macsec)(void *, GSW_MAC_cfg_t *);
+	/* Command: GSW_DUMP_MEM ; Index: 0x14 */
+	GSW_return_t (*DumpMem)(void *, GSW_table_t *);
+	/* Command: GSW_DEBUG_PRINT_PCEIRQ_LIST ; Index: 0x15 */
+	GSW_return_t (*DEBUG_PrintPceIrqList)(void *);
+	/* Command: GSW_DEBUG_RMON_PORT_GET ; Index: 0x16 */
+	GSW_return_t (*DEBUG_RMON_Port_Get)(void *, GSW_Debug_RMON_Port_cnt_t *);
+};
+
+struct irq_ops {
+	/* Command: (NULL); Index: 0x00 */
+	GSW_return_t (*null)(void);
+	/* Command: GSW_IRQ_REGISTER ; Index: 0x01 */
+	GSW_return_t (*IRQ_Register)(void *, GSW_Irq_Op_t *);
+	/* Command: GSW_IRQ_UNREGISTER ; Index: 0x02 */
+	GSW_return_t (*IRQ_UnRegister)(void *, GSW_Irq_Op_t *);
+	/* Command: GSW_IRQ_ENABLE ; Index: 0x03 */
+	GSW_return_t (*IRQ_Enable)(void *, GSW_Irq_Op_t *);
+	/* Command: GSW_IRQ_DISABLE ; Index: 0x04 */
+	GSW_return_t (*IRQ_Disable)(void *, GSW_Irq_Op_t *);
+};
+
+
+struct core_ops {
+	/**Switch Opertations**/
+	/*RMON Counters GET opertations for Port/Meter/TFlow/Redirect
+	  RMON Counters Mode SET opertations
+	  RMON Counters CLEAR operations
+	  NOTE: Applicable for GSWIP 3.1 and GSWIP 3.0*/
+
+	struct rmon_ops 			gsw_rmon_ops;
+
+	/*Switch MAC table ADD/READ/QUERY/CLEAR/REMOVE operations
+	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0/GSWIP 2.2
+
+	  Switch Defaul MAC filter SET/GET operations
+	  NOTE: Applicable for GSWIP 3.1 only*/
+
+	struct swmac_ops 			gsw_swmac_ops;
+
+	/*Extended VLAN Block ALLOC/SET/GET/FREE operations
+	  NOTE: Applicable for GSWIP 3.1 only*/
+
+	struct extvlan_ops		gsw_extvlan_ops;
+
+	/*VLAN Filter Block ALLOC/SET/GET/FREE operations
+	  NOTE: Applicable for GSWIP 3.1 only*/
+
+	struct vlanfilter_ops 	gsw_vlanfilter_ops;
+
+	/*CTP Port ALLOC/FREE operations
+	  CTP Port Configuration SET/GET/RESET operations
+	  NOTE: Applicable for GSWIP 3.1 only*/
+
+	struct ctp_ops			gsw_ctp_ops;
+
+	/*Bridge Port ALLOC/FREE operations
+	  Bridge Port Configuration SET/GET operations
+	  NOTE: Applicable for GSWIP 3.1 only*/
+
+	struct brdgport_ops		gsw_brdgport_ops;
+
+	/*Bridge ALLOC/FREE operations
+	  Bridge Configuration SET/GET operations
+	  NOTE: Applicable for GSWIP 3.1 only*/
+
+	struct brdg_ops			gsw_brdg_ops;
+
+	/*TFLOW PCE Rule Read/Write/Delete operations
+	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0/GSWIP 2.2*/
+
+	struct tflow_ops			gsw_tflow_ops;
+
+	/*QOS related operations
+	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0/GSWIP 2.2*/
+
+	struct qos_ops			gsw_qos_ops;
+
+	/*Spanning Tree Protocol opertaions
+	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
+
+	struct stp_ops			gsw_stp_ops;
+
+	/*Extensible Authentication Protocol opertaions
+	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
+
+	struct eapol_ops			gsw_8021x_ops;
+
+	/*Multicast related opertaions
+	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
+
+	struct multicast_ops		gsw_multicast_ops;
+
+	/*Port Trunking opertaions
+	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
+
+	struct trunking_ops		gsw_trunking_ops;
+
+	/*Wake On Lan opertaions
+	  NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
+
+	struct wol_ops			gsw_wol_ops;
+
+	/*VLAN/SVLAN related opertaions
+	 NOTE: Applicable Only for GSWIP 3.0 and below*/
+
+	struct vlan_ops			gsw_vlan_ops;
+
+	/*PMAC related opertaions
+	 NOTE: Applicable for GSWIP 3.1/GSWIP 3.0*/
+
+	struct pmac_ops			gsw_pmac_ops;
+
+	/*PAE related opertaions*/
+	struct pae_ops			gsw_pae_ops;
+
+	/*Common Purpose Switch operations like
+	Switch REG read/write
+	Irq mask set/get/status clear
+	Switch enable/disable/reset/init
+	Port monitor set/get
+	Port link get/set
+	Port redirect
+	Time stamp,version get
+	Switch capablity get ..etc
+	 NOTE: Applicable for GSWIP 3.1/GSWIP 3.0/GSWIP 2.2*/
+
+	struct common_ops			gsw_common_ops;
+	/*Debug Purpose for GSWIP 3.1*/
+	struct debug_ops			gsw_debug_ops;
+
+	struct irq_ops			gsw_irq_ops;
+};
+
+
+#endif
diff --git a/include/net/switch_api/gsw_ioctlcmd_type.h b/include/net/switch_api/gsw_ioctlcmd_type.h
index a41af3f435c1..233d3870d73a 100644
--- a/include/net/switch_api/gsw_ioctlcmd_type.h
+++ b/include/net/switch_api/gsw_ioctlcmd_type.h
@@ -1,66 +1,66 @@
-/******************************************************************************
-                Copyright (c) 2016, 2017 Intel Corporation
-
-For licensing information, see the file 'LICENSE' in the root folder of
-this software module.
-******************************************************************************/
-
-
-
-
-
-#ifndef _GSW_FLOW_IOCTLCMD_TYPE_H_
-#define _GSW_FLOW_IOCTLCMD_TYPE_H_
-
-/* RMON IOCTL MAGIC Number */
-#define GSW_RMON_MAGIC 				('A')
-/* Switch MAC IOCTL MAGIC Number */
-#define GSW_MAC_MAGIC  				('B')
-/* Extended IOCTL MAGIC Number */
-#define GSW_EXVLAN_MAGIC 			('C')
-/* VLAN filter IOCTL MAGIC Number */
-#define GSW_VLANFILTER_MAGIC  		('D')
-/* CTP IOCTL MAGIC Number */
-#define GSW_CTP_MAGIC 				('E')
-/* Bridge Port IOCTL MAGIC Number */
-#define GSW_BRDGPORT_MAGIC  		('F')
-/* Bridge IOCTL MAGIC Number */
-#define GSW_BRDG_MAGIC 				('G')
-/* Tflow IOCTL MAGIC Number */
-#define GSW_TFLOW_MAGIC  			('H')
-/* QOS IOCTL MAGIC Number */
-#define GSW_QOS_MAGIC 				('I')
-/* STP IOCTL MAGIC Number */
-#define GSW_STP_MAGIC  				('J')
-/* EAPOL IOCTL MAGIC Number */
-#define GSW_EAPOL_MAGIC 			('K')
-/* Multicast IOCTL MAGIC Number */
-#define GSW_MULTICAST_MAGIC  		('L')
-/* Trunking IOCTL MAGIC Number */
-#define GSW_TRUNKING_MAGIC 			('N')
-/* WOL IOCTL MAGIC Number */
-#define GSW_WOL_MAGIC 				('O')
-/* VLAN IOCTL MAGIC Number */
-#define GSW_VLAN_MAGIC 				('P')
-/* PMAC IOCTL MAGIC Number */
-#define GSW_PMAC_MAGIC  			('Q')
-/* Switch Common usage IOCTL MAGIC Number */
-#define GSW_COMMON_MAGIC 			('R')
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+For licensing information, see the file 'LICENSE' in the root folder of
+this software module.
+******************************************************************************/
+
+
+
+
+
+#ifndef _GSW_FLOW_IOCTLCMD_TYPE_H_
+#define _GSW_FLOW_IOCTLCMD_TYPE_H_
+
+/* RMON IOCTL MAGIC Number */
+#define GSW_RMON_MAGIC 				('A')
+/* Switch MAC IOCTL MAGIC Number */
+#define GSW_MAC_MAGIC  				('B')
+/* Extended IOCTL MAGIC Number */
+#define GSW_EXVLAN_MAGIC 			('C')
+/* VLAN filter IOCTL MAGIC Number */
+#define GSW_VLANFILTER_MAGIC  		('D')
+/* CTP IOCTL MAGIC Number */
+#define GSW_CTP_MAGIC 				('E')
+/* Bridge Port IOCTL MAGIC Number */
+#define GSW_BRDGPORT_MAGIC  		('F')
+/* Bridge IOCTL MAGIC Number */
+#define GSW_BRDG_MAGIC 				('G')
+/* Tflow IOCTL MAGIC Number */
+#define GSW_TFLOW_MAGIC  			('H')
+/* QOS IOCTL MAGIC Number */
+#define GSW_QOS_MAGIC 				('I')
+/* STP IOCTL MAGIC Number */
+#define GSW_STP_MAGIC  				('J')
+/* EAPOL IOCTL MAGIC Number */
+#define GSW_EAPOL_MAGIC 			('K')
+/* Multicast IOCTL MAGIC Number */
+#define GSW_MULTICAST_MAGIC  		('L')
+/* Trunking IOCTL MAGIC Number */
+#define GSW_TRUNKING_MAGIC 			('N')
+/* WOL IOCTL MAGIC Number */
+#define GSW_WOL_MAGIC 				('O')
+/* VLAN IOCTL MAGIC Number */
+#define GSW_VLAN_MAGIC 				('P')
+/* PMAC IOCTL MAGIC Number */
+#define GSW_PMAC_MAGIC  			('Q')
+/* Switch Common usage IOCTL MAGIC Number */
+#define GSW_COMMON_MAGIC 			('R')
 /* Routing IOCTL MAGIC Number */
-#define GSW_ROUTE_MAGIC 			('S')
-/* IOCTL MAGIC */
-#define GSW_MAGIC 					('U')
-/* IOCTL MAGIC */
-#define GSW_FLOW_MAGIC 				('W')
-/* IOCTL DEBUG */
-#define GSW_DEBUG_MAGIC				('V')
-/* IRQ */
-#define GSW_IRQ_MAGIC				('T')
-
-#endif
-
-
-
-
-
-
+#define GSW_ROUTE_MAGIC 			('S')
+/* IOCTL MAGIC */
+#define GSW_MAGIC 					('U')
+/* IOCTL MAGIC */
+#define GSW_FLOW_MAGIC 				('W')
+/* IOCTL DEBUG */
+#define GSW_DEBUG_MAGIC				('V')
+/* IRQ */
+#define GSW_IRQ_MAGIC				('T')
+
+#endif
+
+
+
+
+
+
diff --git a/include/net/switch_api/gsw_tbl_rw.h b/include/net/switch_api/gsw_tbl_rw.h
index 3438d1e0223f..6cb7d2e75d43 100644
--- a/include/net/switch_api/gsw_tbl_rw.h
+++ b/include/net/switch_api/gsw_tbl_rw.h
@@ -1,164 +1,164 @@
-/******************************************************************************
- *                Copyright (c) 2016, 2017 Intel Corporation
- *
- *
- * For licensing information, see the file 'LICENSE' in the root folder of
- * this software module.
- *
- ******************************************************************************/
-
-#ifndef _GSW_TBL_RW_H_
-#define _GSW_TBL_RW_H_
-
-#include "gsw_types.h"
-
-/* GSWIP PCE Table Programming structure */
-typedef struct {
-	u16 key[34];
-	u16 mask[4];
-	u16 val[31];
-	u16 table;
-	u16 pcindex;
-	u16 op_mode: 2;
-	u16 extop: 1;
-	u16 kformat: 1;
-	u16 type: 1;
-	u16 valid: 1;
-	u16 group: 4;
-} pctbl_prog_t;
-
-/* GSWIP BM Table ID to access different tables */
-typedef enum {
-	CTP_PORT_RX_RMON 				= 0x00,
-	CTP_PORT_TX_RMON 				= 0x01,
-	BRIDGE_PORT_RX_RMON 				= 0x02,
-	BRIDGE_PORT_TX_RMON				= 0x03,
-	CTP_PORT_PCE_BYPASS_TX_RMON			= 0x04,
-	FLOW_RX_RMON					= 0x05,
-	FLOW_TX_RMON					= 0x06,
-	WFQ_PARAM					= 0x08,
-	PQM_THRESHOLD					= 0x09,
-	PQM_PACKET_PTR					= 0x0A,
-	SSL_NEXT_PTR_MEM				= 0x0B,
-	SSL_HEADER_DES_MEM1				= 0x0C,
-	SSL_HEADER_DES_MEM2				= 0x0D,
-	BUF_MGR_Q_MAP_TABLE				= 0x0E,
-	METER_RMON_COUNTER				= 0x19,
-	ROUTING_RMON_COUNTER				= 0x1B,
-	PMAC_RMON_COUNTER				= 0x1C,
-} BM_Table_ID;
-
-/* GSWIP BM Table Address */
-typedef union {
-	u16 raw;
-#if CONFIG_CPU_BIG_ENDIAN
-	struct {
-		u16 b15: 1, b14: 1, b13: 1, b12: 1, b11: 1, b10: 1, b9: 1, b8: 1,
-		    b7: 1, b6: 1, b5: 1, b4: 1, b3: 1, b2: 1, b1: 1, b0: 1;
-	} bits;
-	struct {
-		u16 portOffset: 10, counterOffset: 6;
-	} rmon;
-	struct {
-		u16 reserved0: 10, nQueueId: 6;
-	} wfq;
-	struct {
-		u16 reserved1: 7, nQueueId: 6, mode: 1, color_or_submode: 2;
-	} pqmThr;
-	struct {
-		u16 reserved2: 5, ptr: 11;
-	} pqmPtr;
-	struct {
-		u16 reserved3: 6, ptr: 10;
-	} ssl;
-	struct {
-		u16 reserved4: 10, nQueueId: 6;
-	} qMapTbl;
-	struct {
-		u16 reserved6: 6, color: 2, reserved5: 1, meterNo: 7;
-	} meterRmon;
-	struct {
-		u16 reserved7: 8, counterType: 4, portNo: 4 ;
-	} routingRmon;
-	struct {
-		u16 reserved8: 5, pmacNo: 3, count: 3, channel_or_port: 5;
-	} pmacRmon;
-#else
-	struct {
-		u16 b0: 1, b1: 1, b2: 1, b3: 1, b4: 1, b5: 1, b6: 1, b7: 1,
-		    b8: 1, b9: 1, b10: 1, b11: 1, b12: 1, b13: 1, b14: 1, b15: 1;
-	} bits;
-	struct {
-		u16 counterOffset: 6, portOffset: 10;
-	} rmon;
-	struct {
-		u16 nQueueId: 6, reserved0: 10;
-	} wfq;
-	struct {
-		u16 color_or_submode: 2, mode: 1, nQueueId: 6, reserved1: 7;
-	} pqmThr;
-	struct {
-		u16 ptr: 11, reserved2: 5;
-	} pqmPtr;
-	struct {
-		u16 ptr: 10, reserved3: 6;
-	} ssl;
-	struct {
-		u16 nQueueId: 6, reserved4: 10;
-	} qMapTbl;
-	struct {
-		u16 meterNo: 7, reserved5: 1, color: 2, reserved6: 6;
-	} meterRmon;
-	struct {
-		u16 portNo: 4, counterType: 4, reserved7: 8;
-	} routingRmon;
-	struct {
-		u16 channel_or_port: 5, count: 3, pmacNo: 3, reserved8: 5;
-	} pmacRmon;
-#endif
-
-} BM_Table_Address ;
-
-/* GSWIP BM Table programming structure */
-typedef struct {
-	BM_Table_ID  tableID;
-	BM_Table_Address adr;
-	u32 value[10];
-	ltq_bool_t b64bitMode;
-	u32 numValues;
-} bmtbl_prog_t;
-
-/* GSWIP PMAC Table programming structure */
-typedef struct {
-	u16 val[8];
-	u16 ptaddr;
-	u16 ptcaddr;
-	u16 op_mode;
-	u16 pmacId;
-	/*	u16 valid:1; */
-} pmtbl_prog_t;
-
-/* GSWIP Table structure to access all tables */
-typedef struct {
-	u8 tbl_entry;
-	/** Start offset mem dump purpose */
-	u32 tbl_addr;
-	u32 tbl_id;
-	u32 bm_numValues;
-	pctbl_prog_t ptdata;
-	bmtbl_prog_t bmtable;
-	pmtbl_prog_t pmactable;
-} GSW_table_t;
-
-int gsw_pce_table_write(void *cdev, pctbl_prog_t *ptdata);
-int gsw_pce_table_read(void *cdev, pctbl_prog_t *ptdata);
-int xwayflow_pmac_table_read(void *cdev, pmtbl_prog_t *ptdata);
-int xwayflow_pmac_table_write(void *cdev, pmtbl_prog_t *ptdata);
-int route_table_read(void *cdev, pctbl_prog_t *rdata);
-int route_table_write(void *cdev, pctbl_prog_t *rdata);
-GSW_return_t gsw_bm_table_read(void *cdev, bmtbl_prog_t *ptdata);
-GSW_return_t gsw_bm_table_write(void *cdev, bmtbl_prog_t *ptdata);
-u32 pmac_addr_off(u32 off, u32 id);
-
-#endif
-
+/******************************************************************************
+ *                Copyright (c) 2016, 2017 Intel Corporation
+ *
+ *
+ * For licensing information, see the file 'LICENSE' in the root folder of
+ * this software module.
+ *
+ ******************************************************************************/
+
+#ifndef _GSW_TBL_RW_H_
+#define _GSW_TBL_RW_H_
+
+#include "gsw_types.h"
+
+/* GSWIP PCE Table Programming structure */
+typedef struct {
+	u16 key[34];
+	u16 mask[4];
+	u16 val[31];
+	u16 table;
+	u16 pcindex;
+	u16 op_mode: 2;
+	u16 extop: 1;
+	u16 kformat: 1;
+	u16 type: 1;
+	u16 valid: 1;
+	u16 group: 4;
+} pctbl_prog_t;
+
+/* GSWIP BM Table ID to access different tables */
+typedef enum {
+	CTP_PORT_RX_RMON 				= 0x00,
+	CTP_PORT_TX_RMON 				= 0x01,
+	BRIDGE_PORT_RX_RMON 				= 0x02,
+	BRIDGE_PORT_TX_RMON				= 0x03,
+	CTP_PORT_PCE_BYPASS_TX_RMON			= 0x04,
+	FLOW_RX_RMON					= 0x05,
+	FLOW_TX_RMON					= 0x06,
+	WFQ_PARAM					= 0x08,
+	PQM_THRESHOLD					= 0x09,
+	PQM_PACKET_PTR					= 0x0A,
+	SSL_NEXT_PTR_MEM				= 0x0B,
+	SSL_HEADER_DES_MEM1				= 0x0C,
+	SSL_HEADER_DES_MEM2				= 0x0D,
+	BUF_MGR_Q_MAP_TABLE				= 0x0E,
+	METER_RMON_COUNTER				= 0x19,
+	ROUTING_RMON_COUNTER				= 0x1B,
+	PMAC_RMON_COUNTER				= 0x1C,
+} BM_Table_ID;
+
+/* GSWIP BM Table Address */
+typedef union {
+	u16 raw;
+#if CONFIG_CPU_BIG_ENDIAN
+	struct {
+		u16 b15: 1, b14: 1, b13: 1, b12: 1, b11: 1, b10: 1, b9: 1, b8: 1,
+		    b7: 1, b6: 1, b5: 1, b4: 1, b3: 1, b2: 1, b1: 1, b0: 1;
+	} bits;
+	struct {
+		u16 portOffset: 10, counterOffset: 6;
+	} rmon;
+	struct {
+		u16 reserved0: 10, nQueueId: 6;
+	} wfq;
+	struct {
+		u16 reserved1: 7, nQueueId: 6, mode: 1, color_or_submode: 2;
+	} pqmThr;
+	struct {
+		u16 reserved2: 5, ptr: 11;
+	} pqmPtr;
+	struct {
+		u16 reserved3: 6, ptr: 10;
+	} ssl;
+	struct {
+		u16 reserved4: 10, nQueueId: 6;
+	} qMapTbl;
+	struct {
+		u16 reserved6: 6, color: 2, reserved5: 1, meterNo: 7;
+	} meterRmon;
+	struct {
+		u16 reserved7: 8, counterType: 4, portNo: 4 ;
+	} routingRmon;
+	struct {
+		u16 reserved8: 5, pmacNo: 3, count: 3, channel_or_port: 5;
+	} pmacRmon;
+#else
+	struct {
+		u16 b0: 1, b1: 1, b2: 1, b3: 1, b4: 1, b5: 1, b6: 1, b7: 1,
+		    b8: 1, b9: 1, b10: 1, b11: 1, b12: 1, b13: 1, b14: 1, b15: 1;
+	} bits;
+	struct {
+		u16 counterOffset: 6, portOffset: 10;
+	} rmon;
+	struct {
+		u16 nQueueId: 6, reserved0: 10;
+	} wfq;
+	struct {
+		u16 color_or_submode: 2, mode: 1, nQueueId: 6, reserved1: 7;
+	} pqmThr;
+	struct {
+		u16 ptr: 11, reserved2: 5;
+	} pqmPtr;
+	struct {
+		u16 ptr: 10, reserved3: 6;
+	} ssl;
+	struct {
+		u16 nQueueId: 6, reserved4: 10;
+	} qMapTbl;
+	struct {
+		u16 meterNo: 7, reserved5: 1, color: 2, reserved6: 6;
+	} meterRmon;
+	struct {
+		u16 portNo: 4, counterType: 4, reserved7: 8;
+	} routingRmon;
+	struct {
+		u16 channel_or_port: 5, count: 3, pmacNo: 3, reserved8: 5;
+	} pmacRmon;
+#endif
+
+} BM_Table_Address ;
+
+/* GSWIP BM Table programming structure */
+typedef struct {
+	BM_Table_ID  tableID;
+	BM_Table_Address adr;
+	u32 value[10];
+	ltq_bool_t b64bitMode;
+	u32 numValues;
+} bmtbl_prog_t;
+
+/* GSWIP PMAC Table programming structure */
+typedef struct {
+	u16 val[8];
+	u16 ptaddr;
+	u16 ptcaddr;
+	u16 op_mode;
+	u16 pmacId;
+	/*	u16 valid:1; */
+} pmtbl_prog_t;
+
+/* GSWIP Table structure to access all tables */
+typedef struct {
+	u8 tbl_entry;
+	/** Start offset mem dump purpose */
+	u32 tbl_addr;
+	u32 tbl_id;
+	u32 bm_numValues;
+	pctbl_prog_t ptdata;
+	bmtbl_prog_t bmtable;
+	pmtbl_prog_t pmactable;
+} GSW_table_t;
+
+int gsw_pce_table_write(void *cdev, pctbl_prog_t *ptdata);
+int gsw_pce_table_read(void *cdev, pctbl_prog_t *ptdata);
+int xwayflow_pmac_table_read(void *cdev, pmtbl_prog_t *ptdata);
+int xwayflow_pmac_table_write(void *cdev, pmtbl_prog_t *ptdata);
+int route_table_read(void *cdev, pctbl_prog_t *rdata);
+int route_table_write(void *cdev, pctbl_prog_t *rdata);
+GSW_return_t gsw_bm_table_read(void *cdev, bmtbl_prog_t *ptdata);
+GSW_return_t gsw_bm_table_write(void *cdev, bmtbl_prog_t *ptdata);
+u32 pmac_addr_off(u32 off, u32 id);
+
+#endif
+
diff --git a/include/net/switch_api/lantiq_gsw.h b/include/net/switch_api/lantiq_gsw.h
old mode 100755
new mode 100644
index 58638d11609d..c3975728b0c0
--- a/include/net/switch_api/lantiq_gsw.h
+++ b/include/net/switch_api/lantiq_gsw.h
@@ -2408,7 +2408,7 @@ typedef struct {
 	/** Number of args */
 	u32 argc;
 	/** Argument values */
-	u8 argv[10][30];
+	u8 argv[15][30];
 } GSW_MAC_cfg_t;
 
 /** \brief MMD Register Access. The 'nData' value is directly written
diff --git a/include/net/switch_api/lantiq_gsw_api.h b/include/net/switch_api/lantiq_gsw_api.h
index a51f510c5d72..bf57399f5400 100644
--- a/include/net/switch_api/lantiq_gsw_api.h
+++ b/include/net/switch_api/lantiq_gsw_api.h
@@ -1,91 +1,91 @@
-/******************************************************************************
-                Copyright (c) 2016, 2017 Intel Corporation
-
-******************************************************************************/
-/*****************************************************************************
-                Copyright (c) 2012, 2014, 2015
-                    Lantiq Deutschland GmbH
-    For licensing information, see the file 'LICENSE' in the root folder of
-    this software module.
-******************************************************************************/
-
-
-#ifndef _LTQ_GSW_KERNEL_API_H_
-#define _LTQ_GSW_KERNEL_API_H_
-
-#include "gsw_ioctlcmd_type.h"
-#include "lantiq_gsw.h"
-#include "lantiq_gsw_flow.h"
-#include "lantiq_gsw_routing.h"
-#include "gsw_irq.h"
-#include "gsw_tbl_rw.h"
-
-
-/* Group definitions for Doxygen */
-/** \defgroup ETHSW_KERNELAPI Ethernet Switch Linux Kernel Interface
-    This chapter describes the entire interface to access and
-    configure the various services of the Ethernet switch module of xRX200/xRX300/xRX500 family within the Linux kernel space. */
-
-/*@{*/
-
-/** Definition of the device handle that is retrieved during
-    the \ref gsw_api_kopen call. This handle is used to access the switch
-    device while calling \ref gsw_api_kioctl. */
-typedef unsigned int GSW_API_HANDLE;
-
-/**
-   Request a device handle for a dedicated Ethernet switch device. The switch
-   device is identified by the given device name (e.g. "/dev/switch/1").
-   The device handle is the return value of this function. This handle is
-   used to access the switch parameter and features while
-   calling \ref gsw_api_kioctl. Please call the function
-   \ref gsw_api_kclose to release a device handle that is not needed anymore.
-
-   \param name Pointer to the device name of the requested Ethernet switch device.
-
-   \remarks The client kernel module should check the function return value.
-   A returned zero indicates that the resource allocation failed.
-
-   \return Return the device handle in case the requested device is available.
-   It returns a zero in case the device does not exist or is blocked
-   by another application.
-*/
-GSW_API_HANDLE gsw_api_kopen(char *name);
-
-/**
-   Calls the switch API driver implementation with the given command and the
-   parameter argument. The called Ethernet switch device is identified by the
-   given device handle. This handle was previously requested by
-   calling gsw_api_kopen function.
-
-   \param handle Ethernet switch device handle, given by \ref gsw_api_kopen.
-   \param command Switch API command to perform.
-   \param arg Command arguments. This argument is basically a reference to
-   the command parameter structure.
-
-   \remarks The commands and arguments are the same as normally used over
-   the Linux ioctl interface from user space.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurred.
-*/
-int gsw_api_kioctl(GSW_API_HANDLE handle, unsigned int command, unsigned int arg);
-
-/**
-   Releases an Ethernet switch device handle which was previously
-   allocated by \ref gsw_api_kopen.
-
-   \param handle Ethernet switch device handle, given by \ref gsw_api_kopen.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurred.
-*/
-int gsw_api_kclose(GSW_API_HANDLE handle);
-
-/*@}*/ /* GSWIP_ROUTE_IOCTL */
-
-extern void gsw_api_disable_switch_ports(void);
-
-#endif /* _LTQ_GSW_KERNEL_API_H_ */
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+
+#ifndef _LTQ_GSW_KERNEL_API_H_
+#define _LTQ_GSW_KERNEL_API_H_
+
+#include "gsw_ioctlcmd_type.h"
+#include "lantiq_gsw.h"
+#include "lantiq_gsw_flow.h"
+#include "lantiq_gsw_routing.h"
+#include "gsw_irq.h"
+#include "gsw_tbl_rw.h"
+
+
+/* Group definitions for Doxygen */
+/** \defgroup ETHSW_KERNELAPI Ethernet Switch Linux Kernel Interface
+    This chapter describes the entire interface to access and
+    configure the various services of the Ethernet switch module of xRX200/xRX300/xRX500 family within the Linux kernel space. */
+
+/*@{*/
+
+/** Definition of the device handle that is retrieved during
+    the \ref gsw_api_kopen call. This handle is used to access the switch
+    device while calling \ref gsw_api_kioctl. */
+typedef unsigned int GSW_API_HANDLE;
+
+/**
+   Request a device handle for a dedicated Ethernet switch device. The switch
+   device is identified by the given device name (e.g. "/dev/switch/1").
+   The device handle is the return value of this function. This handle is
+   used to access the switch parameter and features while
+   calling \ref gsw_api_kioctl. Please call the function
+   \ref gsw_api_kclose to release a device handle that is not needed anymore.
+
+   \param name Pointer to the device name of the requested Ethernet switch device.
+
+   \remarks The client kernel module should check the function return value.
+   A returned zero indicates that the resource allocation failed.
+
+   \return Return the device handle in case the requested device is available.
+   It returns a zero in case the device does not exist or is blocked
+   by another application.
+*/
+GSW_API_HANDLE gsw_api_kopen(char *name);
+
+/**
+   Calls the switch API driver implementation with the given command and the
+   parameter argument. The called Ethernet switch device is identified by the
+   given device handle. This handle was previously requested by
+   calling gsw_api_kopen function.
+
+   \param handle Ethernet switch device handle, given by \ref gsw_api_kopen.
+   \param command Switch API command to perform.
+   \param arg Command arguments. This argument is basically a reference to
+   the command parameter structure.
+
+   \remarks The commands and arguments are the same as normally used over
+   the Linux ioctl interface from user space.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurred.
+*/
+int gsw_api_kioctl(GSW_API_HANDLE handle, unsigned int command, unsigned int arg);
+
+/**
+   Releases an Ethernet switch device handle which was previously
+   allocated by \ref gsw_api_kopen.
+
+   \param handle Ethernet switch device handle, given by \ref gsw_api_kopen.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurred.
+*/
+int gsw_api_kclose(GSW_API_HANDLE handle);
+
+/*@}*/ /* GSWIP_ROUTE_IOCTL */
+
+extern void gsw_api_disable_switch_ports(void);
+
+#endif /* _LTQ_GSW_KERNEL_API_H_ */
diff --git a/include/net/switch_api/lantiq_gsw_flow.h b/include/net/switch_api/lantiq_gsw_flow.h
index eef7c2b3b3f0..0defbed612ee 100644
--- a/include/net/switch_api/lantiq_gsw_flow.h
+++ b/include/net/switch_api/lantiq_gsw_flow.h
@@ -1,1344 +1,1344 @@
-/******************************************************************************
-                Copyright (c) 2016, 2017 Intel Corporation
-
-******************************************************************************/
-/*****************************************************************************
-                Copyright (c) 2012, 2014, 2015
-                    Lantiq Deutschland GmbH
-    For licensing information, see the file 'LICENSE' in the root folder of
-    this software module.
-******************************************************************************/
-
-
-#ifndef _LANTIQ_ETHSW_FLOW_H_
-#define _LANTIQ_ETHSW_FLOW_H_
-
-/* =================================== */
-/* Global typedef forward declarations */
-/* =================================== */
-
-/* ============================= */
-/* Local Macros & Definitions    */
-/* ============================= */
-
-
-/* Group definitions for Doxygen */
-/** \defgroup GSW_FLOW_GROUP GSWIP Packet Classification Engine (PCE) related APIs
-    \brief This chapter describes the GSWIP's PCE and other low level related APIs.
-*/
-/*@{*/
-
-/** \defgroup GSW_IOCTL_DEBUG Debug Features
-   \brief Switch Registers write and read for any low level operations including debug.
-*/
-/** \defgroup GSW_IOCTL_IRQ Interrupt Handling
-    \brief Configure GSWIP support to configure and read out the interrupt mask and sources.
-*/
-/** \defgroup GSW_IOCTL_SYS GSWIP System Functions
-    \brief This chapter summarizes the functions that are provided to handle system aspects of GSWIP.
-*/
-/** \defgroup GSW_IOCTL_CLASS Packet Classification Engine
-    \brief Configures and controls the classification unit of the GSWIP.
-*/
-
-/*@}*/
-
-/* -------------------------------------------------------------------------- */
-/*                 Structure and Enumeration Type Defintions                  */
-/* -------------------------------------------------------------------------- */
-
-/** \addtogroup GSW_IOCTL_DEBUG */
-/*@{*/
-
-/** \brief Register access parameter to directly read or write switch
-    internal registers.
-    Used by \ref GSW_REGISTER_SET and \ref GSW_REGISTER_GET. */
-typedef struct {
-	/** Register Address Offset for read or write access. */
-	u16	nRegAddr;
-	/** Value to write to or read from 'nRegAddr'. */
-	u16	nData;
-} GSW_register_t;
-
-/*@}*/ /* GSW_IOCTL_DEBUG */
-
-/** \addtogroup GSW_IOCTL_IRQ */
-/*@{*/
-
-/** \brief Interrupt Source Selector.
-    Used by \ref GSW_irq_t. */
-typedef enum {
-	/** Wake-on-LAN Interrupt. The configured packet flow will trigger WoL interrupt.
-	    The parameter 'nPortId' specifies the relative MAC port. */
-	GSW_IRQ_WOL	= 0,
-	/** Port Limit Alert Interrupt. This interrupt is asserted when the number
-	    of learned MAC addresses exceeds the configured limit for
-	    the ingress port.
-	    The parameter 'nPortId' specifies the relative MAC port. */
-	GSW_IRQ_LIMIT_ALERT	= 1,
-	/** Port Lock Alert Interrupt.
-	    This interrupt is asserted when a source MAC address is learned on a
-	    locked port and is received on another port.
-	    The parameter 'nPortId' specifies the relative MAC port. */
-	GSW_IRQ_LOCK_ALERT	= 2
-} GSW_irqSrc_t;
-
-/** \brief Interrupt bits. Depending on the hardware device type, not all interrupts might be available.
-    Used by \ref GSW_IRQ_MASK_GET, \ref GSW_IRQ_MASK_SET,
-    \ref GSW_IRQ_GET and \ref GSW_IRQ_STATUS_CLEAR. */
-typedef struct {
-	/** Ethernet Port number (zero-based counting). The valid range is hardware dependent.
-	    An error code is delivered if the selected port is not
-	    available. This port parameter is needed for some interrupts
-	    that are specified by 'nIrqSrc'. For all other interrupts, this
-	    parameter is "don't care". */
-	u32	nPortId;
-	/** Interrupt Source Type. */
-	GSW_irqSrc_t	eIrqSrc;
-} GSW_irq_t;
-
-/*@}*/ /* GSW_IOCTL_IRQ */
-
-/** \addtogroup GSW_IOCTL_CLASS */
-/*@{*/
-
-/** \brief Rule selection for IPv4/IPv6.
-    Used by \ref GSW_PCE_pattern_t. */
-typedef enum {
-	/** Rule Pattern for IP selection disabled. */
-	GSW_PCE_IP_DISABLED	= 0,
-	/** Rule Pattern for IPv4. */
-	GSW_PCE_IP_V4	= 1,
-	/** Rule Pattern for IPv6. */
-	GSW_PCE_IP_V6	= 2
-} GSW_PCE_IP_t;
-
-/** \brief Select Mode of Sub-Interface ID Field.
-    Used by \ref GSW_PCE_pattern_t. */
-typedef enum {
-	/** Sub Interface ID as defined by GSWIP-3.0. */
-	GSW_PCE_SUBIFID_TYPE_SUBIFID = 0,
-	/** Sub Interface ID group as defined by GSWIP-3.1. */
-	GSW_PCE_SUBIFID_TYPE_GROUP = 1,
-	/** Bridge Port ID as defined by GSWIP-3.1. */
-	GSW_PCE_SUBIFID_TYPE_BRIDGEPORT = 2
-} GSW_PCE_SUBIFID_TYPE_t;
-
-/** \brief Packet Classification Engine Pattern Configuration.
-     GSWIP-3.0 has additional patterns such as Inner IP, Inner DSCP, Inner Protocol, Exclude Mode etc.
-    Used by \ref GSW_PCE_rule_t. */
-typedef struct {
-	/** PCE Rule Index (Upto 512 rules supported in GSWIP-3.0, whereas 64 rules supported in GSWIP-2.x) */
-	int	nIndex;
-
-	/** Index is used (enabled) or set to unused (disabled) */
-	ltq_bool_t	bEnable;
-
-	/** Port ID used  for ingress packet classification */
-	ltq_bool_t	bPortIdEnable;
-	/** Port ID value of incoming packets used for classification */
-	u8	nPortId;
-	/** Exclude Port Id Value - When set exclusion of specified nPortId takes effect.  Available for GSWIP-3.0 only */
-	ltq_bool_t	bPortId_Exclude;
-
-	/** Select mode of sub-interface ID field */
-	GSW_PCE_SUBIFID_TYPE_t eSubIfIdType;
-	/** Incoming Sub-Interface ID Enable - used for GSWIP-3.0 only */
-	ltq_bool_t	bSubIfIdEnable;
-	/** Incoming Sub-Interface ID value - used for GSWIP-3.0 only */
-	u16	nSubIfId;
-	/** Exclude of specified Sub-Interface Id value in nSubIfId - used for GSWIP-3.0 only */
-	ltq_bool_t	bSubIfId_Exclude;
-
-	/** DSCP value used (Outer for GSWIP-3.0) */
-	ltq_bool_t	bDSCP_Enable;
-	/** DSCP value (Outer for GSWIP-3.0) */
-	u8		nDSCP;
-	/** Exclude (Outer) DSCP value used for GSWIP-3.0 only */
-	ltq_bool_t	bDSCP_Exclude;
-
-	/** Inner DSCP value used for GSWIP-3.0 only */
-	ltq_bool_t	bInner_DSCP_Enable;
-	/** Inner DSCP value  for GSWIP-3.0 only */
-	u8		nInnerDSCP;
-	/** Exclude of Inner DSCP (nInnerDSCP) value used for GSWIP-3.0 only */
-	ltq_bool_t	bInnerDSCP_Exclude;
-
-	/** CTAG VLAN PCP n DEI value used */
-	ltq_bool_t	bPCP_Enable;
-	/** CTAG VLAN PCP n DEI value */
-	u8		nPCP;
-	/* Exclude CTAG  value used for GSWIP-3.0 only */
-//   ltq_bool_t	bCTAG_Exclude;
-	/** Exclude CTAG PCP & DEI value used for GSWIP-3.0 only */
-	ltq_bool_t	bCTAG_PCP_DEI_Exclude;
-
-	/** STAG VLAN PCP/DEI value used */
-	ltq_bool_t	bSTAG_PCP_DEI_Enable;
-	/** STAG VLAN PCP value */
-	u8		nSTAG_PCP_DEI;
-	/* Exclude STAG  value used for GSWIP-3.0 only */
-//   ltq_bool_t	bSTAG_Exclude;
-	/** Exclude STAG PCP & DEI value used for GSWIP-3.0 only */
-	ltq_bool_t	bSTAG_PCP_DEI_Exclude;
-
-	/** Packet length used for classification */
-	ltq_bool_t	bPktLngEnable;
-	/** Packet length in bytes */
-	u16		nPktLng;
-	/** Packet length Range (from nPktLng to nPktLngRange) */
-	u16		nPktLngRange;
-	/** Exclude of Packet Length or range value used for GSWIP-3.0 only */
-	ltq_bool_t	bPktLng_Exclude;
-
-	/** Destination MAC address used */
-	ltq_bool_t	bMAC_DstEnable;
-	/** Destination MAC address */
-	u8		nMAC_Dst[6];
-	/** Destination MAC address nibble mask.
-	    Please clear the bits of the nibbles that are not marked out and set all other bits.
-	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
-	    and so on. */
-	u16	nMAC_DstMask;
-	/** Exclude Destination MAC Address used for GSWIP-3.0 only */
-	ltq_bool_t	bDstMAC_Exclude;
-
-	/** Source MAC address used */
-	ltq_bool_t	bMAC_SrcEnable;
-	/** Source MAC address */
-	u8	nMAC_Src[6];
-	/** Source MAC address nibble mask.
-	    Please clear the bits of the nibbles that are not marked out and set all other bits.
-	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
-	    and so on. */
-	u16	nMAC_SrcMask;
-	/** Exclude Source MAC Address used for GSWIP-3.0 only */
-	ltq_bool_t	bSrcMAC_Exclude;
-
-	/** MSB Application field used */
-	ltq_bool_t	bAppDataMSB_Enable;
-	/** MSB Application field.
-	    The first 2 bytes of the packet content following the IP header
-	    for TCP/UDP packets (source port field), or the first 2 bytes of packet content
-	    following the Ethertype for non-IP packets. Any part of this
-	    content can be masked-out by a programmable bit
-	    mask 'nAppMaskRangeMSB'. */
-	u16	nAppDataMSB;
-	/** MSB Application mask/range selection.
-	    If set to LTQ_TRUE, the field 'nAppMaskRangeMSB' is used as a
-	    range parameter, otherwise it is used as a nibble mask field. */
-	ltq_bool_t	bAppMaskRangeMSB_Select;
-	/** MSB Application mask/range. When used as a range parameter,
-	    1 bit represents 1 nibble mask of the 'nAppDataMSB' field.
-	    Please clear the bits of the nibbles that are not marked out and set all other bits.
-	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
-	    and so on. */
-	u16	nAppMaskRangeMSB;
-	/** MSB Application Data Exclude - for GSWIP-3.0 only */
-	ltq_bool_t	bAppMSB_Exclude;
-
-	/** LSB Application used */
-	ltq_bool_t	bAppDataLSB_Enable;
-	/** LSB Application field.
-	    The following 2 bytes of the packet behind the 'nAppDataMSB' field.
-	    This is the destination port field for TCP/UDP packets,
-	    or byte 3 and byte 4 of the packet content following the Ethertype
-	    for non-IP packets. Any part of this content can be masked-out
-	    by a programmable bit mask 'nAppMaskRangeLSB'. */
-	u16	nAppDataLSB;
-	/** LSB Application mask/range selection.
-	    If set to LTQ_TRUE, the field 'nAppMaskRangeLSB' is used as
-	    a range parameter, otherwise it is used as a nibble mask field. */
-	ltq_bool_t	bAppMaskRangeLSB_Select;
-	/** LSB Application mask/range. When used as a range parameter,
-	    1 bit represents 1 nibble mask of the 'nAppDataLSB' field.
-	    Please clear the bits of the nibbles that are not marked out and set all other bits.
-	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
-	    and so on. */
-	u16	nAppMaskRangeLSB;
-	/** LSB Application Data Exclude - for GSWIP-3.0 only */
-	ltq_bool_t	bAppLSB_Exclude;
-
-	/** Destination IP Selection (Outer for GSWIP-3.0). */
-	GSW_PCE_IP_t	eDstIP_Select;
-	/** Destination IP (Outer for GSWIP-3.0) */
-	GSW_IP_t	nDstIP;
-	/** Destination IP Nibble Mask.
-	    1 bit represents 1 nibble mask of the 'nDstIP' field.
-	    Please clear the bits of the nibbles that are not marked out and set all other bits.
-	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
-	    and so on. */
-	u32	nDstIP_Mask;
-	/** Exclude Destination IP Value - used for GSWIP-3.0 only */
-	ltq_bool_t	bDstIP_Exclude;
-
-	/** Inner Destination IP Selection - for GSWIP-3.0 only. */
-	GSW_PCE_IP_t	eInnerDstIP_Select;
-	/** Inner Destination IP  - for GSWIP-3.0 only.*/
-	GSW_IP_t	nInnerDstIP;
-	/** Inner Destination IP Nibble Mask - for GSWIP-3.0 only.
-	    1 bit represents 1 nibble mask of the 'nInnerDstIP' field.
-	    Please clear the bits of the nibbles that are not marked out and set all other bits.
-	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
-	    and so on. */
-	u32	nInnerDstIP_Mask;
-	/** Exclude Inner Destination IP Value - used for GSWIP-3.0 only */
-	ltq_bool_t	bInnerDstIP_Exclude;
-
-	/** Source IP Selection (Outer for GSWIP-3.0). */
-	GSW_PCE_IP_t	eSrcIP_Select;
-	/** Source IP  (Outer for GSWIP-3.0) */
-	GSW_IP_t	nSrcIP;
-	/** Source IP Nibble Mask (Outer for GSWIP-3.0).
-	    1 bit represents 1 nibble mask of the 'nSrcIP' field.
-	    Please clear the bits of the nibbles that are not marked out and set all other bits.
-	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
-	    and so on. */
-	u32	nSrcIP_Mask;
-	/** Exclude Source IP Value - used for GSWIP-3.0 only */
-	ltq_bool_t	bSrcIP_Exclude;
-
-	/** Inner Source IP Selection - for GSWIP-3.0 only. */
-	GSW_PCE_IP_t	eInnerSrcIP_Select;
-	/** Inner Source IP  - for GSWIP-3.0 only*/
-	GSW_IP_t	nInnerSrcIP;
-	/** Inner Src IP Nibble Mask - for GSWIP-3.0 only.
-	    1 bit represents 1 nibble mask of the 'nInnerSrcIP' field.
-	    Please clear the bits of the nibbles that are not marked out and set all other bits.
-	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
-	    and so on. */
-	u32	nInnerSrcIP_Mask;
-	/** Exclude Inner Source IP Value - used for GSWIP-3.0 only */
-	ltq_bool_t	bInnerSrcIP_Exclude;
-
-	/** Ethertype used. */
-	ltq_bool_t	bEtherTypeEnable;
-	/** Ethertype */
-	u16	nEtherType;
-	/** Ethertype Mask.
-	    1 bit represents 1 nibble mask of the 'nEtherType' field.
-	    Please clear the bits of the nibbles that are not marked out and set all other bits.
-	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
-	    and so on. */
-	u16	nEtherTypeMask;
-	/** Exclude for Ether Type Value - used for GSWIP-3.0 only. */
-	ltq_bool_t	bEtherType_Exclude;
-
-	/** IP protocol used */
-	ltq_bool_t	bProtocolEnable;
-	/** IP protocol Value */
-	u8	nProtocol;
-	/** IP protocol Mask.
-	    1 bit represents 1 nibble mask of the 'nProtocol' field.
-	    Please clear the bits of the nibbles that are not marked out and set all other bits i.e. a set bit 1 indicates that bit is masked out (not compared).
-	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
-	    and so on. */
-	u8	nProtocolMask;
-	/** Exclude for IP Protocol Value - used for GSWIP-3.0 only. */
-	ltq_bool_t	bProtocol_Exclude;
-
-	/** Inner IP protocol used - for GSWIP-3.0 only. */
-	ltq_bool_t	bInnerProtocolEnable;
-	/** Inner IP protocol Value - for GSWIP-3.0 only. */
-	u8	nInnerProtocol;
-	/** Inner IP protocol Bit Mask - for GSWIP-3.0 only. */
-	u8	nInnerProtocolMask;
-	/** Exclude for Inner IP Protocol Value - used for GSWIP-3.0 only. */
-	ltq_bool_t	bInnerProtocol_Exclude;
-
-	/** PPPoE used. */
-	ltq_bool_t	bSessionIdEnable;
-	/** PPPoE Session Id */
-	u16	nSessionId;
-	/** Exclude for PPPoE Session Value - used for GSWIP-3.0 only. */
-	ltq_bool_t	bSessionId_Exclude;
-
-	/** PPP Protocol used - used for GSWIP-3.0 only */
-	ltq_bool_t	bPPP_ProtocolEnable;
-	/** PPP Protocol Value  - used for GSWIP-3.0 only*/
-	u16	nPPP_Protocol;
-	/** PPP protocol Bit Mask (Positional bit 1 signifies masking of corresponding bit value in nPPP_Protocol) - for GSWIP-3.0 only. */
-	u16	nPPP_ProtocolMask;
-	/** Exclude for PPP Protocol Value - used for GSWIP-3.0 only. */
-	ltq_bool_t	bPPP_Protocol_Exclude;
-
-	/** VLAN ID (CVID) used.
-
-	    \remarks
-	    CVID is inner VLAN as defined in GSWIP-3.1 */
-	ltq_bool_t	bVid;
-	/** VLAN ID (CVID) */
-	u16	nVid;
-	/** VID mask/range selection.
-	    If set to 1, the field 'nVidRange' is used as
-	    a range parameter, otherwise it is used as a mask field.
-
-	    \remarks
-	    This must be range in GSWIP-3.1 */
-	ltq_bool_t	bVidRange_Select;
-	/** VLAN ID Range (CVID). Gets used as mask to nVid in case bVidRange_Select is set to 0 */
-	u16	nVidRange;
-	/** Exclude for VLAN Id (CVLAN) - used for GSWIP-3.0 only. */
-	ltq_bool_t	bVid_Exclude;
-	/** If this field is TRUE, use original VLAN ID as key even it's modified in
-	    any stage before flow table process. Used for GSWIP-3.1 only. */
-	ltq_bool_t bVid_Original;
-
-	/** STAG VLAN ID used.
-
-	    \remarks
-	    SLAN is outer VLAN as defined GSWIP-3.1 */
-	ltq_bool_t	bSLAN_Vid;
-	/** STAG VLAN ID */
-	u16	nSLAN_Vid;
-	/** Exclude for SVLAN Id (SVLAN) - used for GSWIP-3.0 only. */
-	ltq_bool_t	bSLANVid_Exclude;
-	/** VID mask/range selection.
-	    If set to 1, the field 'nVidRange' is used as
-	    a range parameter, otherwise it is used as a mask field.
-
-	    \remarks
-	    This must be range in GSWIP-3.1 */
-	ltq_bool_t	bSVidRange_Select;
-	/** VLAN ID Range for outer VLAN tag. Used for GSWIP-3.1 only. */
-	u16 nOuterVidRange;
-	/** If this field is TRUE, use original VLAN ID as key even it's modified in
-	    any stage before flow table process. Used for GSWIP-3.1 only. */
-	ltq_bool_t bOuterVid_Original;
-
-	/** Payload-1 used - for GSWIP-3.0 PAE only */
-	ltq_bool_t	bPayload1_SrcEnable;
-	/** Payload-1 Value (16-bits) - for GSWIP-3.0 PAE only */
-	u16	nPayload1;
-	/** Payload1 mask/range selection.
-	    If set to LTQ_TRUE, the field 'nPayload1' is used as
-	    a range parameter, otherwise it is used as a bit mask field. */
-	ltq_bool_t	bPayload1MaskRange_Select;
-	/** Payload-1 Bit mask - for GSWIP-3.0 PAE only */
-	u16	nPayload1_Mask;
-	/** Exclude Payload-1 used for GSWIP-3.0 PAE only */
-	ltq_bool_t	bPayload1_Exclude;
-
-	/** Payload-2 used - for GSWIP-3.0 PAE only */
-	ltq_bool_t	bPayload2_SrcEnable;
-	/** Payload-2 Value (16-bits) - for GSWIP-3.0 PAE only */
-	u16	nPayload2;
-	/** Payload2 mask/range selection.
-	    If set to LTQ_TRUE, the field 'nPayload2' is used as
-	    a range parameter, otherwise it is used as a bit mask field. */
-	ltq_bool_t	bPayload2MaskRange_Select;
-	/** Payload-2 Bit mask - for GSWIP-3.0 PAE only */
-	u16	nPayload2_Mask;
-	/** Exclude Payload-2 used for GSWIP-3.0 PAE only */
-	ltq_bool_t	bPayload2_Exclude;
-
-	/** Parser Flag LSW (Bit position 15 to 0) is used - for GSWIP 3.0 only */
-	ltq_bool_t	bParserFlagLSB_Enable;
-	/** Parser Flag LSW Value - each bit indicates specific parsed result */
-	u16	nParserFlagLSB;
-	/** Corresponding LSW Parser Flag Mask - when the bit is set to 1 corresponding flag gets masked out (ignored). */
-	u16	nParserFlagLSB_Mask;
-	/** Exclude for Parser Flag LSW specified in nParserFlagLSB */
-	ltq_bool_t	bParserFlagLSB_Exclude;
-
-	/** Parser Flag MSW (Bit 31 to 16) is used - for GSWIP 3.0 only */
-	ltq_bool_t	bParserFlagMSB_Enable;
-	/** Parser Flag MSW Value - each bit indicates specific parsed result */
-	u16	nParserFlagMSB;
-	/** Corresponding Parser Flag MSW Mask - when the bit is set to 1 corresponding flag gets masked out (ignored). */
-	u16	nParserFlagMSB_Mask;
-	/** Exclude for Parser Flag MSW specified in nParserFlagMSB */
-	ltq_bool_t	bParserFlagMSB_Exclude;
-
-	/** Parser Flag LSW (Bit position 47 to 32) is used - for GSWIP 3.1 only */
-	ltq_bool_t	bParserFlag1LSB_Enable;
-	/** Parser Flag LSW Value - each bit indicates specific parsed result */
-	u16	nParserFlag1LSB;
-	/** Corresponding LSW Parser Flag Mask - when the bit is set to 1 corresponding flag gets masked out (ignored). */
-	u16	nParserFlag1LSB_Mask;
-	/** Exclude for Parser Flag LSW specified in nParserFlagLSB */
-	ltq_bool_t	bParserFlag1LSB_Exclude;
-
-	/** Parser Flag MSW (Bit 63 to 48) is used - for GSWIP 3.1 only */
-	ltq_bool_t	bParserFlag1MSB_Enable;
-	/** Parser Flag MSW Value - each bit indicates specific parsed result */
-	u16	nParserFlag1MSB;
-	/** Corresponding Parser Flag MSW Mask - when the bit is set to 1 corresponding flag gets masked out (ignored). */
-	u16	nParserFlag1MSB_Mask;
-	/** Exclude for Parser Flag MSW specified in nParserFlagMSB */
-	ltq_bool_t	bParserFlag1MSB_Exclude;
-
-	/** nInsertionFlag is used. For GSWIP-3.1 only */
-	ltq_bool_t bInsertionFlag_Enable;
-	/** Inserted packet by CPU to data path. For GSWIP-3.1 only */
-	u16 nInsertionFlag;
-} GSW_PCE_pattern_t;
-
-/** \brief IGMP Snooping Control.
-    Used by \ref GSW_PCE_action_t. */
-typedef enum {
-	/** Disabled. IGMP Snooping is disabled. */
-	GSW_PCE_ACTION_IGMP_SNOOP_DISABLE	= 0,
-	/** Default. Regular Packet. No IGMP Snooping action required. */
-	GSW_PCE_ACTION_IGMP_SNOOP_REGULAR	= 1,
-	/** IGMP Report/Join Message. */
-	GSW_PCE_ACTION_IGMP_SNOOP_REPORT	= 2,
-	/** IGMP Leave Message. */
-	GSW_PCE_ACTION_IGMP_SNOOP_LEAVE	= 3,
-	/**  Router Solicitation/Advertisement message. */
-	GSW_PCE_ACTION_IGMP_SNOOP_AD	= 4,
-	/** IGMP Query Message. */
-	GSW_PCE_ACTION_IGMP_SNOOP_QUERY	= 5,
-	/** IGMP Group Specific Query Message. */
-	GSW_PCE_ACTION_IGMP_SNOOP_QUERY_GROUP	= 6,
-	/** IGMP General Query message without Router Solicitation. */
-	GSW_PCE_ACTION_IGMP_SNOOP_QUERY_NO_ROUTER = 7
-} GSW_PCE_ActionIGMP_Snoop_t;
-
-/** \brief MAC Address Learning control.
-    Used by \ref GSW_PCE_action_t. */
-typedef enum {
-	/** Learning is based on the forwarding decision. If the packet is discarded,
-	    the address is not learned. If the packet is forwarded to any egress port,
-	    the address is learned. */
-	GSW_PCE_ACTION_LEARNING_DISABLE	= 0,
-	/** Reserved */
-	GSW_PCE_ACTION_LEARNING_REGULAR	= 1,
-	/** Force No Learning. The address is not learned; forwarding decision
-	    ignored. */
-	GSW_PCE_ACTION_LEARNING_FORCE_NOT = 2,
-	/** Force Learning. The address is learned, the forwarding decision ignored.
-	    Note: The MAC Learning Control signals delivered to Port-Map filtering
-	    and combined with Final Forwarding Decision. The result is used as a
-	    feedback for MAC Address learning in the Bridging Table. */
-	GSW_PCE_ACTION_LEARNING_FORCE	= 3
-} GSW_PCE_ActionLearning_t;
-
-/** \brief Flow Meter Assignment control.
-    Used by \ref GSW_PCE_action_t. */
-typedef enum {
-	/** Action Disable. */
-	GSW_PCE_ACTION_METER_DISABLE	= 0,
-	/** Action Enable.
-	    The action is enabled but no dedicated metering instance is assigned by the rule. */
-	GSW_PCE_ACTION_METER_REGULAR	= 1,
-	/** Action Enable. Assign one meter instance as given in parameter "nMeterId". */
-	GSW_PCE_ACTION_METER_1	= 2,
-	/** Action Enable. Assign pair of meter instances.
-	    These instances are "nMeterId" and the next following meter instance index. */
-	GSW_PCE_ACTION_METER_1_2	= 3
-} GSW_PCE_ActionMeter_t;
-
-/** \brief Traffic Class Action Selector.
-    Used by \ref GSW_PCE_action_t. */
-typedef enum {
-	/** Disabled. Traffic class action is disabled. */
-	GSW_PCE_ACTION_TRAFFIC_CLASS_DISABLE	= 0,
-	/** Regular Class. Traffic class action is enabled and the CoS
-	    classification traffic class is used. */
-	GSW_PCE_ACTION_TRAFFIC_CLASS_REGULAR	= 1,
-	/** Alternative Class. Traffic class action is enabled and the
-	    class of the 'nTrafficClassAlter' field is used. */
-	GSW_PCE_ACTION_TRAFFIC_CLASS_ALTERNATIVE	= 2,
-} GSW_PCE_ActionTrafficClass_t;
-
-/** \brief Interrupt Control Action Selector.
-    Used by \ref GSW_PCE_action_t. */
-typedef enum {
-	/** Disabled. Interrupt Control Action is disabled for this rule. */
-	GSW_PCE_ACTION_IRQ_DISABLE	= 0,
-	/** Regular Packet. The Interrupt Control Action is enabled, the packet is
-	    treated as a regular packet and no interrupt event is generated. */
-	GSW_PCE_ACTION_IRQ_REGULAR	= 1,
-	/** Interrupt Event. The Interrupt Control Action is enabled and an
-	    interrupt event is generated. */
-	GSW_PCE_ACTION_IRQ_EVENT	= 2
-} GSW_PCE_ActionIrq_t;
-
-/** \brief Cross State Action Selector.
-    Used by \ref GSW_PCE_action_t. */
-typedef enum {
-	/** Disable. The Cross State Action is disabled. */
-	GSW_PCE_ACTION_CROSS_STATE_DISABLE	= 0,
-	/** Regular Packet. The Cross State Action is enabled and the packet is
-	    treated as a non-Cross-State packet (regular packet). Therefore it does
-	    not ignore Port-State filtering rules. */
-	GSW_PCE_ACTION_CROSS_STATE_REGULAR	= 1,
-	/** Cross-State packet. The Cross State Action is enabled and the packet is
-	    treated as a Cross-State packet. It ignores the Port-State
-	    filtering rules. */
-	GSW_PCE_ACTION_CROSS_STATE_CROSS	= 2
-} GSW_PCE_ActionCrossState_t;
-
-/** \brief Critical Frame Action Selector.
-    Used by \ref GSW_PCE_action_t. */
-typedef enum {
-	/** Disable. The Critical Frame Action is disabled. */
-	GSW_PCE_ACTION_CRITICAL_FRAME_DISABLE	= 0,
-	/** Regular Packet. The Critical Frame Action is enabled and the packet is
-	    treated as a non-Critical Frame. */
-	GSW_PCE_ACTION_CRITICAL_FRAME_REGULAR	= 1,
-	/** Critical Packet. The Critical Frame Action is enabled and the packet is
-	    treated as a Critical Frame. */
-	GSW_PCE_ACTION_CRITICAL_FRAME_CRITICAL	= 2
-} GSW_PCE_ActionCriticalFrame_t;
-
-/** \brief Color Frame Action Selector.
-    Used by \ref GSW_PCE_action_t. */
-typedef enum {
-	/** Disable. No color frame action. */
-	GSW_PCE_ACTION_COLOR_FRAME_DISABLE = 0,
-	/** Do not change color. */
-	GSW_PCE_ACTION_COLOR_FRAME_NO_CHANGE = 1,
-	/** Idendity packet as critical which bypass active congestion
-	    management (ACM). */
-	GSW_PCE_ACTION_COLOR_FRAME_CRITICAL = 2,
-	/** Change to green color. */
-	GSW_PCE_ACTION_COLOR_FRAME_GREEN = 3,
-	/** Change to yellow color. */
-	GSW_PCE_ACTION_COLOR_FRAME_YELLOW = 4,
-	/** Change to red color. */
-	GSW_PCE_ACTION_COLOR_FRAME_RED = 5
-} GSW_PCE_ActionColorFrame_t;
-
-/** \brief Timestamp Action Selector.
-    Used by \ref GSW_PCE_action_t. */
-typedef enum {
-	/** Disable. Timestamp Action is disabled for this rule. */
-	GSW_PCE_ACTION_TIMESTAMP_DISABLE	= 0,
-	/** Regular Packet. The Timestamp Action is enabled for this rule.
-	    The packet is treated as a regular packet and no timing information
-	    is stored. */
-	GSW_PCE_ACTION_TIMESTAMP_REGULAR	= 1,
-	/** Receive/Transmit Timing packet. Ingress and Egress Timestamps for
-	    this packet should be stored. */
-	GSW_PCE_ACTION_TIMESTAMP_STORED	= 2
-} GSW_PCE_ActionTimestamp_t;
-
-/** \brief Forwarding Group Action Selector.
-    This flow table action and the 'bFlowID_Action' action
-    can be used exclusively.
-    Used by \ref GSW_PCE_action_t. */
-typedef enum {
-	/** Disable. Forwarding Group Action is disabled. */
-	GSW_PCE_ACTION_PORTMAP_DISABLE	= 0,
-	/** Regular Packet. Forwarding Action enabled. Select Default
-	    Port-Map (result of Default Forwarding Classification). */
-	GSW_PCE_ACTION_PORTMAP_REGULAR	= 1,
-	/** Discard. Discard the packets. */
-	GSW_PCE_ACTION_PORTMAP_DISCARD	= 2,
-	/** Forward to the CPU port. This requires that the CPU port is previously
-	    set by calling \ref GSW_CPU_PORT_CFG_SET. */
-	GSW_PCE_ACTION_PORTMAP_CPU	= 3,
-	/** Forward to a portmap, selected by the parameter 'nForwardPortMap'.
-	    Please note that this feature is not supported by all
-	    hardware platforms. */
-	GSW_PCE_ACTION_PORTMAP_ALTERNATIVE	= 4,
-	/** The packet is treated as Multicast Router
-	    Solicitation/Advertisement or Query packet. */
-	GSW_PCE_ACTION_PORTMAP_MULTICAST_ROUTER	= 5,
-	/** The packet is interpreted as Multicast packet and learned in the
-	    multicast group table. */
-	GSW_PCE_ACTION_PORTMAP_MULTICAST_HW_TABLE = 6,
-	/** The CTAG VLAN portmap classification result is replaced by the
-	    portmap parameter 'nForwardPortMap'. All other classification
-	    results stay unchanged and will be combined together with
-	    the overwritten portmap. */
-	GSW_PCE_ACTION_PORTMAP_ALTERNATIVE_VLAN	= 7,
-	/** Add STAG VLAN portmap 'nForwardPortMap' to the overall portmap
-	    classification result (AND'ed with the portmap). */
-	GSW_PCE_ACTION_PORTMAP_ALTERNATIVE_STAG_VLAN	= 8
-} GSW_PCE_ActionPortmap_t;
-
-/** \brief VLAN Group Action Selector.
-    Used by \ref GSW_PCE_action_t. */
-typedef enum {
-	/** Disabled. The VLAN Action is disabled. */
-	GSW_PCE_ACTION_VLAN_DISABLE	= 0,
-	/** Regular VLAN. VLAN Action enabled. Select Default VLAN ID. */
-	GSW_PCE_ACTION_VLAN_REGULAR	= 1,
-	/** Alternative VLAN. VLAN Action enabled.
-	    Select Alternative VLAN as configured in 'nVLAN_Id'
-	    or 'nSVLAN_Id'. For CTAG VLAN it requires that this VLAN ID
-	    is configured by calling
-	    \ref GSW_VLAN_ID_CREATE in advance.
-	    This additional call is not required for STAG VLAN. */
-	GSW_PCE_ACTION_VLAN_ALTERNATIVE	= 2
-} GSW_PCE_ActionVLAN_t;
-
-/** \brief Cross VLAN Action Selector.
-    Used by \ref GSW_PCE_action_t. */
-typedef enum {
-	/** Disabled. The Cross VLAN Action is disabled. */
-	GSW_PCE_ACTION_CROSS_VLAN_DISABLE	= 0,
-	/** Regular VLAN Packet. Do not ignore VLAN filtering rules. */
-	GSW_PCE_ACTION_CROSS_VLAN_REGULAR	= 1,
-	/** Cross-VLAN packet. Ignore VLAN filtering  rules.*/
-	GSW_PCE_ACTION_CROSS_VLAN_CROSS	= 2
-} GSW_PCE_ActionCrossVLAN_t;
-
-/** \brief Port Filter Action-1/2/3/4/5/6 Selector - used for GSWIP-3.0 only.
-     This can be used only along with PortMember config.
-    Used by \ref GSW_PCE_action_t. */
-typedef enum {
-	/** Port Filter Action is Unused. */
-	GSW_PCE_PORT_FILTER_ACTION_UNUSED = 0,
-	/** Port Filter Action Type-1 is used. */
-	GSW_PCE_PORT_FILTER_ACTION_1	= 1,
-	/** Port Filter Action Type-2 is used. */
-	GSW_PCE_PORT_FILTER_ACTION_2	= 2,
-	/** Port Filter Action Type-3 is used. */
-	GSW_PCE_PORT_FILTER_ACTION_3	= 3,
-	/** Port Filter Action Type-4 is used. */
-	GSW_PCE_PORT_FILTER_ACTION_4	= 4,
-	/** Port Filter Action Type-5 (Unknown Unicast) is used. */
-	GSW_PCE_PORT_FILTER_ACTION_5	= 5,
-	/** Port Filter Action Type-6 (Unknown Multicast) is used. */
-	GSW_PCE_PORT_FILTER_ACTION_6	= 6
-} GSW_PCE_PortFilterAction_t;
-
-/** \brief MPE Processing Path Assignment Selector - used for GSWIP-3.0 only.
-    Used by \ref GSW_PCE_action_t. */
-typedef enum {
-	/** Processing Path is not enabled. */
-	GSW_PCE_PROCESSING_PATH_UNUSED = 0,
-	/** Processing Path-1 is used for MPE-1. */
-	GSW_PCE_PROCESSING_PATH_1 = 1,
-	/** Processing Path-2 is used for MPE-2. */
-	GSW_PCE_PROCESSING_PATH_2 = 2,
-	/** Processing Path-1 and -2 are used for MPE-1 & MPE-2. */
-	GSW_PCE_PROCESSING_PATH_BOTH = 3,
-} GSW_PCE_ProcessingPathAction_t;
-
-/** \brief Packet Classification Engine Action Configuration.
-    GSWIP-3.0 extension actions are explicitly indicated.
-    Used by \ref GSW_PCE_rule_t. */
-typedef struct {
-	/** Action "Traffic Class" Group.
-	    Traffic class action enable */
-	GSW_PCE_ActionTrafficClass_t	eTrafficClassAction;
-	/** Alternative Traffic class - used when eTrafficClassAction is set to 2. */
-	u8	nTrafficClassAlternate;
-
-	/** Action "IGMP Snooping" Group.
-	    IGMP Snooping control and enable. Please note that the 'nPortMapAction'
-	    configuration is ignored in case the IGMP snooping is enabled.
-	    Here, on read operations,
-	    'nPortMapAction = GSW_PCE_ACTION_PORTMAP_DISABLE' is returned. */
-	GSW_PCE_ActionIGMP_Snoop_t	eSnoopingTypeAction;
-
-	/** Action "Learning" Group.
-	    Learning action control and enable */
-	GSW_PCE_ActionLearning_t	eLearningAction;
-
-	/** Action "Interrupt" Group.
-	    Interrupt action generate and enable */
-	GSW_PCE_ActionIrq_t	eIrqAction;
-
-	/** Action "Cross State" Group.
-	    Cross state action control and enable */
-	GSW_PCE_ActionCrossState_t	eCrossStateAction;
-
-	/** Action "Critical Frames" Group.
-	    Critical Frame action control and enable */
-	GSW_PCE_ActionCriticalFrame_t	eCritFrameAction;
-
-	/** Action "Color Frames" Group.
-	    This is replacement of eCritFrameAction in GSWIP-3.1. */
-	GSW_PCE_ActionColorFrame_t eColorFrameAction;
-
-	/** Action "Timestamp" Group. Time stamp action control and enable */
-	GSW_PCE_ActionTimestamp_t	eTimestampAction;
-
-	/** Action "Forwarding" Group.
-	    Port map action enable. This port forwarding configuration is ignored
-	    in case the action "IGMP Snooping" is enabled via the
-	    parameter 'nSnoopingTypeAction'. */
-	GSW_PCE_ActionPortmap_t	ePortMapAction;
-	/** Target portmap for forwarded packets, only used if selected by
-	    'ePortMapAction'. Forwarding is done
-	    if 'ePortMapAction = GSW_PCE_ACTION_PORTMAP_ALTERNATIVE'.
-	    Every bit in the portmap represents one port (port 0 = LSB bit). */
-	u16 nForwardPortMap[16];
-
-	/** Target Sub-Interface Id (GSWIP-3.0 only) for forwarded packets,
-	    only used if selected by 'ePortMapAction'. Forwarding is done
-	    if 'ePortMapAction = GSW_PCE_ACTION_PORTMAP_ALTERNATIVE'. */
-	u16	nForwardSubIfId;
-
-	/** Action "Remarking" Group. Remarking action enable. Reserved in
-	    GSWIP-3.1. */
-	ltq_bool_t	bRemarkAction;
-	/** CTAG VLAN PCP remarking enable. Reserved in GSWIP-3.1.
-	    Remarking enabling means that remarking is possible in case
-	    the port configuration or metering enables remarking on that
-	    packet. Disabling remarking means that it is forced to
-	    not remarking this packet, independent of any port remarking of
-	    metering configuration. */
-	ltq_bool_t	bRemarkPCP;
-	/** STAG VLAN PCP remarking enable. Reserved in GSWIP-3.1.
-	    Remarking enabling means that remarking is possible in case
-	    the port configuration or metering enables remarking on that
-	    packet. Disabling remarking means that it is forced to
-	    not remarking this packet, independent of any port remarking of
-	    metering configuration. */
-	ltq_bool_t	bRemarkSTAG_PCP;
-	/** STAG VLAN DEI remarking enable. Reserved in GSWIP-3.1.
-	    Remarking enabling means that remarking is possible in case
-	    the port configuration or metering enables remarking on that
-	    packet. Disabling remarking means that it is forced to
-	    not remarking this packet, independent of any port remarking of
-	    metering configuration. */
-	ltq_bool_t	bRemarkSTAG_DEI;
-	/** DSCP remarking enable. Reserved in GSWIP-3.1.
-	    Remarking enabling means that remarking is possible in case
-	    the port configuration or metering enables remarking on that
-	    packet. Disabling remarking means that it is forced to
-	    not remarking this packet, independent of any port remarking of
-	    metering configuration. */
-	ltq_bool_t	bRemarkDSCP;
-	/** Class remarking enable. Reserved in GSWIP-3.1.
-	    Remarking enabling means that remarking is possible in case
-	    the port configuration or metering enables remarking on that
-	    packet. Disabling remarking means that it is forced to
-	    not remarking this packet, independent of any port remarking of
-	    metering configuration. */
-	ltq_bool_t	bRemarkClass;
-
-	/** Action "Meter" Group. Meter action control and enable.
-	    If metering action enabled, specified metering instance number
-	    overrules any other metering assignment.
-	    Up to two metering instances can be applied to a single packet. */
-	GSW_PCE_ActionMeter_t	eMeterAction;
-	/** Meter ID */
-	u8	nMeterId;
-
-	/** Action "RMON" Group. RMON action enable. Reserved in GSWIP-3.1. */
-	ltq_bool_t	bRMON_Action;
-	/** Counter ID (The index starts counting from zero). */
-	u8	nRMON_Id;
-
-	/** Action "CTAG VLAN" Group. VLAN action enable */
-	GSW_PCE_ActionVLAN_t	eVLAN_Action;
-	/** Alternative CTAG VLAN Id */
-	u16	nVLAN_Id;
-	/** Enable alternative FID */
-	ltq_bool_t bFidEnable;
-	/** Alternative FID. Valid when bFidEnable is TRUE. */
-	u8	nFId;
-	/** Enable extended VLAN operation for traffic match this flow entry. */
-	ltq_bool_t bExtendedVlanEnable;
-	/** Extended VLAN block allocated for traffic match this flow entry. Valid
-	    when bExtendedVlanEnable is TRUE. Only FIRST VLAN operation in this block
-	    is used for flow process. */
-	u32 nExtendedVlanBlockId;
-	/** Action "STAG VLAN" Group. VLAN action enable */
-	GSW_PCE_ActionVLAN_t	eSVLAN_Action;
-	/** Alternative STAG VLAN Id */
-	u16	nSVLAN_Id;
-	/** Action "Cross VLAN" Group. Cross VLAN action enable */
-	GSW_PCE_ActionCrossVLAN_t	eVLAN_CrossAction;
-	/**  CVLAN Ignore control */
-	ltq_bool_t	bCVLAN_Ignore_Control;
-	/** Port BitMap Mux control */
-	ltq_bool_t	bPortBitMapMuxControl;
-	/** Trunking action enable  */
-	ltq_bool_t	bPortTrunkAction;
-	/**  Port Link Selection control */
-	ltq_bool_t	bPortLinkSelection;
-	/** Action "Flow ID".
-	 The Switch supports enhancing the egress packets by a device specific
-	 special tag header. This header contains detailed switch classification
-	 results. One header file is a 'Flow ID', which can be explicitly set as
-	 flow table action when hitting a table rule.
-	 If selected, the Flow ID is given by the parameter 'nFlowID'. */
-	ltq_bool_t	bFlowID_Action;
-	/** Flow ID */
-	u16	nFlowID;
-
-	/** Routing Extension Id Action Selector - for GSWIP-3.0 only.
-	  When enabled, it expects a valid nRoutExtId value to be supplied. */
-	ltq_bool_t	bRoutExtId_Action;
-	/** Routing Extension Id Value - for GSWIP-3.0 only. (8-bits range) */
-	u8	nRoutExtId;
-	/** Routing Destination Port Mask Comparison - for GSWIP-3.0 only. If not enabled this field is not considered for routing session pattern lookup.*/
-	ltq_bool_t	bRtDstPortMaskCmp_Action;
-	/** Routing Source Port Mask Comparison - for GSWIP-3.0 only. If not enabled, this field is not considered for routing session pattern lookup.*/
-	ltq_bool_t	bRtSrcPortMaskCmp_Action;
-	/** Routing Destination IP Address Mask Comparison - for GSWIP-3.0 only. If not enabled, this field is not considered for routing session pattern lookup.*/
-	ltq_bool_t	bRtDstIpMaskCmp_Action;
-	/** Routing Source IP Address Mask Comparison - for GSWIP-3.0 only. If not enabled, this field is not considered for routing session pattern lookup.*/
-	ltq_bool_t	bRtSrcIpMaskCmp_Action;
-	/** Selector of IP in Tunneled IP header (Outer or Inner) - for GSWIP-3.0 only. */
-	ltq_bool_t	bRtInnerIPasKey_Action;
-	/** Routing Acceleration Enable Action - for GSWIP-3.0 only. This variable decides whether to accelerate the Routing session or not */
-	ltq_bool_t	bRtAccelEna_Action;
-	/** Routing Control Enable Action - for GSWIP-3.0 only. This variable is selector of Routing Accelerate action*/
-	ltq_bool_t	bRtCtrlEna_Action;
-	/** Assignment of flow to MPE Processing Path-1 or -2 or both - for GSWIP-3.0 only. */
-	GSW_PCE_ProcessingPathAction_t eProcessPath_Action;
-	/** Port Filter Action Config for this flow - for GSWIP-3.0 only. */
-	GSW_PCE_PortFilterAction_t	ePortFilterType_Action;
-
-	/** Enable Extraction. For GSWIP-3.1 only.
-	    Packet is identified to be extracted at extraction point defined by
-	    nRecordId. */
-	ltq_bool_t bExtractEnable;
-	/** Enable OAM. For GSWIP-3.1 only.
-	    Packet is identified for OAM process. */
-	ltq_bool_t bOamEnable;
-	/** Record ID is information used by extraction (bExtractEnable is set)
-	    and/or OAM process (bOamEnable is set). For GSWIP-3.1 only. Refer to
-	    GSWIP-3.1 Hardware Architecture Spec (HAS) for more detail. */
-	u32 nRecordId;
-} GSW_PCE_action_t;
-
-/** \brief Parameter to add/read a rule to/from the packet classification engine.
-    Used by \ref GSW_PCE_RULE_WRITE and \ref GSW_PCE_RULE_READ. */
-typedef struct {
-	/** PCE Rule Pattern Part. */
-	GSW_PCE_pattern_t	pattern;
-	/** PCE Rule Action Part. */
-	GSW_PCE_action_t	action;
-} GSW_PCE_rule_t;
-
-/** \brief Parameter to delete a rule from the packet classification engine.
-    Used by \ref GSW_PCE_RULE_DELETE. */
-typedef struct {
-	/** Rule Index in the PCE Table. */
-	u32	nIndex;
-} GSW_PCE_ruleDelete_t;
-
-/*@}*/ /* GSW_IOCTL_CLASS */
-
-/** \addtogroup GSW_IOCTL_SYS */
-/*@{*/
-
-/** \brief Reset selection.
-    Used by \ref GSW_reset_t. */
-typedef enum {
-	/** Switch Macro reset */
-	GSW_RESET_SWITCH	= 0,
-	/** MDIO master interface reset */
-	GSW_RESET_MDIO	= 1,
-} GSW_resetMode_t;
-
-/** \brief Reset selection.
-    Used by \ref GSW_RESET. */
-typedef struct {
-	/** Reset selection. */
-	GSW_resetMode_t	eReset;
-} GSW_reset_t;
-
-/** Number of extended RMON counter. */
-#define GSW_RMON_EXTEND_NUM	24
-
-
-/**
-   \brief Hardware platform extended RMON Counters. GSWIP-2.2/3.0 only.
-   This structure contains additional RMON counters of one Ethernet Switch Port.
-   These counters can be used by the packet classification engine and can be
-   freely assigned to dedicated packet rules and flows.
-    Used by \ref GSW_RMON_EXTEND_GET. */
-typedef struct {
-	/** Ethernet Port number (zero-based counting). The valid range is hardware
-	    dependent. An error code is delivered if the selected port is not
-	    available. */
-	u8		nPortId;
-	/** Traffic flow counters */
-	u32	nTrafficFlowCnt[GSW_RMON_EXTEND_NUM];
-} GSW_RMON_extendGet_t;
-
-/**
-   \brief Hardware platform extended RMON Counters. GSWIP-3.1 only.
-   This structure contains additional RMON counters. These counters can be
-   used by the packet classification engine and can be freely assigned to
-   dedicated packet rules and flows.
-    Used by \ref GSW_RMON_FLOW_GET. */
-typedef struct {
-	/** If TRUE, use \ref GSW_RMON_flowGet_t::nIndex to access the Flow Counter,
-	    otherwise, use \ref GSW_TFLOW_COUNT_MODE_GET to determine mode and use
-	    \ref GSW_RMON_flowGet_t::nPortId and \ref GSW_RMON_flowGet_t::nFlowId
-	    to calculate index of the Flow Counter. */
-	ltq_bool_t bIndex;
-	/** Absolute index of Flow Counter. */
-	u16 nIndex;
-	/** Port ID. This could be Logical Port, CTP or Bridge Port. It depends
-	    on the mode set by \ref GSW_TFLOW_COUNT_MODE_SET. */
-	u16 nPortId;
-	/** \ref GSW_PCE_action_t::nFlowID. The range depends on the mode set
-	    by \ref GSW_TFLOW_COUNT_MODE_SET. */
-	u16 nFlowId;
-
-	/** Rx Packet Counter */
-	u32 nRxPkts;
-	/** Tx Packet Counter (non-PCE-Bypass) */
-	u32 nTxPkts;
-	/** Tx Packet Counter (PCE-Bypass) */
-	u32 nTxPceBypassPkts;
-} GSW_RMON_flowGet_t;
-
-/** \brief Used for getting metering RMON counters.
-    Used by \ref GSW_RMON_METER_GET */
-typedef enum {
-	/* Resereved */
-	GSW_RMON_METER_COLOR_RES = 0,
-	/* Green color */
-	GSW_RMON_METER_COLOR_GREEN = 1,
-	/* Yellow color */
-	GSW_RMON_METER_COLOR_YELLOW = 2,
-	/* Red color */
-	GSW_RMON_METER_COLOR_RED = 3,
-} GSW_RmonMeterColor_t;
-
-/**
-   \brief Hardware platform TFLOW counter mode.
-   Supported modes include, Global (default), Logical, CTP, Bridge port mode.
-   The number of counters that can be assigned varies based these mode type.
-    Used by \ref GSW_TFLOW_COUNT_MODE_SET and GSW_TFLOW_COUNT_MODE_GET. */
-typedef struct {
-	//Counter type. PCE Rx/Tx/Bp-Tx.
-	GSW_TflowCountConfType_t eCountType;
-	//Counter mode. Global/Logical/CTP/BrP.
-	GSW_TflowCmodeType_t eCountMode;
-	//The below params are valid only for CTP/BrP types.
-	//A group of ports matching MS (9-n) bits. n is nCtpLsb or nBrpLsb.
-	u16 nPortMsb;
-	//Number of valid bits in CTP port counter mode.
-	GSW_TflowCtpValBits_t nCtpLsb;
-	//Number of valid bits in bridge port counter mode.
-	GSW_TflowBrpValBits_t nBrpLsb;
-} GSW_TflowCmodeConf_t;
-
-/** \brief This structure describes the second, nano second and fractional
-    nano second counterpart of the switch reference timer. This
-    reference counter can be read by
-    using \ref GSW_TIMESTAMP_TIMER_GET , and it can be modified
-    by using \ref GSW_TIMESTAMP_TIMER_SET . */
-typedef struct {
-	/** Second. Absolute second timer count. */
-	u32	nSec;
-	/** Nano Second. Absolute nanosecond timer count. */
-	u32	nNanoSec;
-	/** Fractional NanoSecond. Absolute fractional nanosecond timer count.
-	    This counter specifis a 2^32 fractional 'nNanoSec'. */
-	u32	nFractionalNanoSec;
-} GSW_TIMESTAMP_Timer_t;
-
-/** \brief This structure describes the port related time stamp.
-    Used by \ref GSW_TIMESTAMP_PORT_READ.
-*/
-typedef struct {
-	/** Ethernet Port number (zero-based counting). The valid range is hardware
-	    dependent. An error code is delivered if the selected port is not
-	    available. */
-	u8		nPortId;
-	/** Second. Absolute second timer count. */
-	u32	nIngressSec;
-	/** Nano Second. Absolute nano second timer count. */
-	u32	nIngressNanoSec;
-	/** Second. Absolute second timer count. */
-	u32	nEgressSec;
-	/** Nano Second. Absolute nano second timer count. */
-	u32	nEgressNanoSec;
-} GSW_TIMESTAMP_PortRead_t;
-
-/*@}*/ /* GSW_IOCTL_SYS */
-
-/* -------------------------------------------------------------------------- */
-/*                        IOCTL Command Definitions                           */
-/* -------------------------------------------------------------------------- */
-
-/** \addtogroup GSW_IOCTL_DEBUG */
-/*@{*/
-
-/**
-   \brief Write to an internal register. The register offset defines which register to access in
-   which table. This routine only accesses the M4599_PDI and
-   the ETHSW_PDI of the switch. All PHY registers are accessed
-   via \ref GSW_MDIO_DATA_WRITE and \ref GSW_MDIO_DATA_READ.
-   Note that the switch API implementation checks whether the given address is
-   inside the valid address range. It returns with an error in case an invalid
-   address is given.
-
-   \param GSW_register_t Pointer to \ref GSW_register_t.
-
-   \remarks The function returns an error code in case an error occurs.
-            The error code is described in \ref GSW_return_t.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurs
-*/
-#define GSW_REGISTER_SET	_IOW(GSW_COMMON_MAGIC, 0x02, GSW_register_t)
-
-/**
-   \brief Read an internal register. The register offset defines which register to access in
-   which table. This routine only accesses the ETHSW_PDI of the switch.
-   All PHY registers are accessed via \ref GSW_MDIO_DATA_WRITE and \ref GSW_MDIO_DATA_READ.
-   Note that the switch API implementation checks whether the given address is
-   inside the valid address range. It returns with an error in case an invalid
-   address is given.
-
-   \param GSW_register_t Pointer to \ref GSW_register_t.
-
-   \remarks The function returns an error code in case an error occurs.
-            The error code is described in \ref GSW_return_t.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurs
-*/
-#define GSW_REGISTER_GET	_IOWR(GSW_COMMON_MAGIC, 0x01, GSW_register_t)
-
-/*@}*/ /* GSW_IOCTL_DEBUG */
-
-/** \addtogroup GSW_IOCTL_IRQ */
-/*@{*/
-/**
-   \brief Get the interrupt enable configuration. This assignment can be set using \ref GSW_IRQ_MASK_SET.
-
-   \param GSW_irq_t Pointer to an \ref GSW_irq_t structure.
-
-   \remarks The function returns an error code in case an error occurs.
-            The error code is described in \ref GSW_return_t.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurs
-
-*/
-#define GSW_IRQ_MASK_GET	_IOWR(GSW_COMMON_MAGIC, 0x04, GSW_irq_t)
-
-/**
-   \brief Set the interrupt enable configuration. This assignment can be read using \ref GSW_IRQ_MASK_GET.
-   Setting interrupts that are not supported by hardware results in an error response.
-
-   \param GSW_irq_t Pointer to
-      an \ref GSW_irq_t structure.
-
-   \remarks The function returns an error code in case an error occurs.
-            The error code is described in \ref GSW_return_t.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurs
-
-*/
-#define GSW_IRQ_MASK_SET	_IOW(GSW_COMMON_MAGIC, 0x05, GSW_irq_t)
-
-/**
-   \brief Read the interrupt status. Interrupt status indications can be cleared using \ref GSW_IRQ_STATUS_CLEAR.
-
-   \param GSW_irq_t Pointer to
-      an \ref GSW_irq_t structure.
-
-   \remarks The function returns an error code in case an error occurs.
-            The error code is described in \ref GSW_return_t.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurs
-
-*/
-#define GSW_IRQ_GET	_IOWR(GSW_COMMON_MAGIC, 0x03, GSW_irq_t)
-
-/**
-   \brief Clear individual interrupt status bits. Interrupt status indications can be read using \ref GSW_IRQ_GET.
-
-   \param GSW_irq_t Pointer to
-      an \ref GSW_irq_t structure.
-
-   \remarks The function returns an error code in case an error occurs.
-            The error code is described in \ref GSW_return_t.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurs
-
-*/
-#define GSW_IRQ_STATUS_CLEAR _IOW(GSW_COMMON_MAGIC, 0x06, GSW_irq_t)
-
-/*@}*/ /* GSW_IOCTL_IRQ */
-
-/** \addtogroup GSW_IOCTL_CLASS */
-/*@{*/
-
-/**
-   \brief This command writes a rule pattern and action to the table of the packet
-   classification engine. The pattern part describes the parameter to identify an
-   incoming packet to which the dedicated actions should be applied.
-   A rule can be read using the command \ref GSW_PCE_RULE_WRITE.
-
-   \param GSW_PCE_rule_t Pointer to \ref GSW_PCE_rule_t.
-
-   \remarks The function returns an error code in case an error occurs.
-            The error code is described in \ref GSW_return_t.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurs
-*/
-#define GSW_PCE_RULE_WRITE	_IOWR(GSW_TFLOW_MAGIC, 0x03, GSW_PCE_rule_t)
-
-/**
-   \brief This command allows the reading out of a rule pattern and action of the
-   packet classification engine.
-   A rule can be written using the command \ref GSW_PCE_RULE_WRITE.
-
-   \param GSW_PCE_rule_t Pointer to \ref GSW_PCE_rule_t.
-
-   \remarks The function returns an error code in case an error occurs.
-            The error code is described in \ref GSW_return_t.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurs
-*/
-#define GSW_PCE_RULE_READ	_IOWR(GSW_TFLOW_MAGIC, 0x02, GSW_PCE_rule_t)
-
-/**
-   \brief This command deletes a complete rule from the packet classification engine.
-   A delete operation is done on the rule of a dedicated index 'nIndex'.
-   A rule can be written over using the command \ref GSW_PCE_RULE_WRITE.
-
-   \param GSW_PCE_ruleDelete_t Pointer to \ref GSW_PCE_ruleDelete_t.
-
-   \remarks The function returns an error code in case an error occurs.
-            The error code is described in \ref GSW_return_t.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurs
-*/
-#define GSW_PCE_RULE_DELETE  _IOWR(GSW_TFLOW_MAGIC, 0x01, GSW_PCE_ruleDelete_t)
-
-
-/*@}*/ /* GSW_IOCTL_CLASS */
-
-/** \addtogroup GSW_IOCTL_SYS */
-/*@{*/
-
-/**
-   \brief Forces a hardware reset of the switch device or switch macro. The device
-   automatically comes back out of reset and contains the initial values.
-   All previous configurations and statistics counters info are lost.
-
-   \param GSW_reset_t Pointer to an \ref GSW_reset_t structure.
-
-   \remarks The function returns an error code in case an error occurs.
-            The error code is described in \ref GSW_return_t.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurs
-
-   \remarks Not supported for all devices
-*/
-#define GSW_RESET	_IOW(GSW_COMMON_MAGIC, 0x08, GSW_reset_t)
-
-/**
-   \brief Read out additional traffic flow (RMON) counters.
-   The zero-based 'nPortId' structure element describes the physical switch
-   port for the requested statistic information.
-   This API is replaced by
-	  \ref GSW_RMON_FLOW_GET for GSWIP-3.1.
-
-   \param GSW_RMON_extendGet_t  Pointer to a pre-allocated
-   \ref GSW_RMON_extendGet_t structure. The structure element 'nPortId' is
-   an input parameter that describes from which port to read the RMON counter.
-   All remaining structure elements are filled with the counter values.
-   The counter assignment needs to be done during the flow definition,
-   for example in \ref GSW_PCE_RULE_WRITE.
-
-   \remarks The function returns an error in case the given 'nPortId' is
-   out of range.
-
-   \remarks The function returns an error code in case an error occurs.
-            The error code is described in \ref GSW_return_t.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurs
-*/
-#define GSW_RMON_EXTEND_GET	_IOWR(GSW_RMON_MAGIC, 0x08, GSW_RMON_extendGet_t)
-
-/** \brief This command sets the packet timestamp reference counter.
-    This reference timer is a switch global timer which is used by the
-    packet timestamp capture when sending and receiving Ethernet port level.
-
-    The command \ref GSW_TIMESTAMP_TIMER_GET allows to read out
-    the current reference timer.
-
-   \param GSW_TIMESTAMP_Timer_t Pointer to an \ref GSW_TIMESTAMP_Timer_t structure.
-
-   \remarks The function returns an error code in case an error occurs.
-            The error code is described in \ref GSW_return_t.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurs
-*/
-#define GSW_TIMESTAMP_TIMER_SET _IOW(GSW_COMMON_MAGIC, 0x1D, GSW_TIMESTAMP_Timer_t)
-
-/** \brief This command reads out the switch global reference timer counter that is
-    used by the packet timestamp capture when sending and receiving Ethernet port level.
-
-    This reference timer is useful when processing the packet related
-    timestamp information for delay calculation.
-
-    The reference timer can be configured by \ref GSW_TIMESTAMP_TIMER_SET.
-
-   \param GSW_TIMESTAMP_Timer_t Pointer to an \ref GSW_TIMESTAMP_Timer_t structure.
-
-   \remarks The function returns an error code in case an error occurs.
-            The error code is described in \ref GSW_return_t.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurs
-*/
-#define GSW_TIMESTAMP_TIMER_GET _IOWR(GSW_COMMON_MAGIC, 0x1E, GSW_TIMESTAMP_Timer_t)
-
-/** \brief This command reads out the port related timestamp values. This timestamp is captured
-    for ingress and egress packets triggered due to a traffic flow table timestamp action.
-    A switch global reference timer is used for the timestamp capture operation.
-    This global timer can be access by using \ref GSW_TIMESTAMP_TIMER_SET
-    and \ref GSW_TIMESTAMP_TIMER_GET.
-
-    A port related packet timestamp is triggered by the flow table
-    action 'eTimestampAction'.
-
-   \param GSW_TIMESTAMP_PortRead_t Pointer to
-      an \ref GSW_TIMESTAMP_PortRead_t structure.
-
-   \remarks The function returns an error code in case an error occurs.
-            The error code is described in \ref GSW_return_t.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurs
-*/
-#define GSW_TIMESTAMP_PORT_READ _IOWR(GSW_COMMON_MAGIC, 0x1F, GSW_TIMESTAMP_PortRead_t)
-
-/**
-   \brief Read out additional traffic flow (RMON) counters. GSWIP-3.1 only.
-
-   \param GSW_RMON_flowGet_t  Pointer to a pre-allocated
-   \ref GSW_RMON_flowGet_t structure.
-
-   \remarks The function returns an error in case the given 'nIndex' is
-   out of range.
-
-   \remarks The function returns an error code in case an error occurs.
-            The error code is described in \ref GSW_return_t.
-
-   \return Return value as follows:
-   - GSW_statusOk: if successful
-   - An error code in case an error occurs
-*/
-#define GSW_RMON_FLOW_GET _IOWR(GSW_RMON_MAGIC, 0x09, GSW_RMON_flowGet_t)
-
-/*@}*/ /* GSW_IOCTL_SYS */
-
-#endif /* _LANTIQ_GSW_FLOW_H_ */
+/******************************************************************************
+                Copyright (c) 2016, 2017 Intel Corporation
+
+******************************************************************************/
+/*****************************************************************************
+                Copyright (c) 2012, 2014, 2015
+                    Lantiq Deutschland GmbH
+    For licensing information, see the file 'LICENSE' in the root folder of
+    this software module.
+******************************************************************************/
+
+
+#ifndef _LANTIQ_ETHSW_FLOW_H_
+#define _LANTIQ_ETHSW_FLOW_H_
+
+/* =================================== */
+/* Global typedef forward declarations */
+/* =================================== */
+
+/* ============================= */
+/* Local Macros & Definitions    */
+/* ============================= */
+
+
+/* Group definitions for Doxygen */
+/** \defgroup GSW_FLOW_GROUP GSWIP Packet Classification Engine (PCE) related APIs
+    \brief This chapter describes the GSWIP's PCE and other low level related APIs.
+*/
+/*@{*/
+
+/** \defgroup GSW_IOCTL_DEBUG Debug Features
+   \brief Switch Registers write and read for any low level operations including debug.
+*/
+/** \defgroup GSW_IOCTL_IRQ Interrupt Handling
+    \brief Configure GSWIP support to configure and read out the interrupt mask and sources.
+*/
+/** \defgroup GSW_IOCTL_SYS GSWIP System Functions
+    \brief This chapter summarizes the functions that are provided to handle system aspects of GSWIP.
+*/
+/** \defgroup GSW_IOCTL_CLASS Packet Classification Engine
+    \brief Configures and controls the classification unit of the GSWIP.
+*/
+
+/*@}*/
+
+/* -------------------------------------------------------------------------- */
+/*                 Structure and Enumeration Type Defintions                  */
+/* -------------------------------------------------------------------------- */
+
+/** \addtogroup GSW_IOCTL_DEBUG */
+/*@{*/
+
+/** \brief Register access parameter to directly read or write switch
+    internal registers.
+    Used by \ref GSW_REGISTER_SET and \ref GSW_REGISTER_GET. */
+typedef struct {
+	/** Register Address Offset for read or write access. */
+	u16	nRegAddr;
+	/** Value to write to or read from 'nRegAddr'. */
+	u16	nData;
+} GSW_register_t;
+
+/*@}*/ /* GSW_IOCTL_DEBUG */
+
+/** \addtogroup GSW_IOCTL_IRQ */
+/*@{*/
+
+/** \brief Interrupt Source Selector.
+    Used by \ref GSW_irq_t. */
+typedef enum {
+	/** Wake-on-LAN Interrupt. The configured packet flow will trigger WoL interrupt.
+	    The parameter 'nPortId' specifies the relative MAC port. */
+	GSW_IRQ_WOL	= 0,
+	/** Port Limit Alert Interrupt. This interrupt is asserted when the number
+	    of learned MAC addresses exceeds the configured limit for
+	    the ingress port.
+	    The parameter 'nPortId' specifies the relative MAC port. */
+	GSW_IRQ_LIMIT_ALERT	= 1,
+	/** Port Lock Alert Interrupt.
+	    This interrupt is asserted when a source MAC address is learned on a
+	    locked port and is received on another port.
+	    The parameter 'nPortId' specifies the relative MAC port. */
+	GSW_IRQ_LOCK_ALERT	= 2
+} GSW_irqSrc_t;
+
+/** \brief Interrupt bits. Depending on the hardware device type, not all interrupts might be available.
+    Used by \ref GSW_IRQ_MASK_GET, \ref GSW_IRQ_MASK_SET,
+    \ref GSW_IRQ_GET and \ref GSW_IRQ_STATUS_CLEAR. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware dependent.
+	    An error code is delivered if the selected port is not
+	    available. This port parameter is needed for some interrupts
+	    that are specified by 'nIrqSrc'. For all other interrupts, this
+	    parameter is "don't care". */
+	u32	nPortId;
+	/** Interrupt Source Type. */
+	GSW_irqSrc_t	eIrqSrc;
+} GSW_irq_t;
+
+/*@}*/ /* GSW_IOCTL_IRQ */
+
+/** \addtogroup GSW_IOCTL_CLASS */
+/*@{*/
+
+/** \brief Rule selection for IPv4/IPv6.
+    Used by \ref GSW_PCE_pattern_t. */
+typedef enum {
+	/** Rule Pattern for IP selection disabled. */
+	GSW_PCE_IP_DISABLED	= 0,
+	/** Rule Pattern for IPv4. */
+	GSW_PCE_IP_V4	= 1,
+	/** Rule Pattern for IPv6. */
+	GSW_PCE_IP_V6	= 2
+} GSW_PCE_IP_t;
+
+/** \brief Select Mode of Sub-Interface ID Field.
+    Used by \ref GSW_PCE_pattern_t. */
+typedef enum {
+	/** Sub Interface ID as defined by GSWIP-3.0. */
+	GSW_PCE_SUBIFID_TYPE_SUBIFID = 0,
+	/** Sub Interface ID group as defined by GSWIP-3.1. */
+	GSW_PCE_SUBIFID_TYPE_GROUP = 1,
+	/** Bridge Port ID as defined by GSWIP-3.1. */
+	GSW_PCE_SUBIFID_TYPE_BRIDGEPORT = 2
+} GSW_PCE_SUBIFID_TYPE_t;
+
+/** \brief Packet Classification Engine Pattern Configuration.
+     GSWIP-3.0 has additional patterns such as Inner IP, Inner DSCP, Inner Protocol, Exclude Mode etc.
+    Used by \ref GSW_PCE_rule_t. */
+typedef struct {
+	/** PCE Rule Index (Upto 512 rules supported in GSWIP-3.0, whereas 64 rules supported in GSWIP-2.x) */
+	int	nIndex;
+
+	/** Index is used (enabled) or set to unused (disabled) */
+	ltq_bool_t	bEnable;
+
+	/** Port ID used  for ingress packet classification */
+	ltq_bool_t	bPortIdEnable;
+	/** Port ID value of incoming packets used for classification */
+	u8	nPortId;
+	/** Exclude Port Id Value - When set exclusion of specified nPortId takes effect.  Available for GSWIP-3.0 only */
+	ltq_bool_t	bPortId_Exclude;
+
+	/** Select mode of sub-interface ID field */
+	GSW_PCE_SUBIFID_TYPE_t eSubIfIdType;
+	/** Incoming Sub-Interface ID Enable - used for GSWIP-3.0 only */
+	ltq_bool_t	bSubIfIdEnable;
+	/** Incoming Sub-Interface ID value - used for GSWIP-3.0 only */
+	u16	nSubIfId;
+	/** Exclude of specified Sub-Interface Id value in nSubIfId - used for GSWIP-3.0 only */
+	ltq_bool_t	bSubIfId_Exclude;
+
+	/** DSCP value used (Outer for GSWIP-3.0) */
+	ltq_bool_t	bDSCP_Enable;
+	/** DSCP value (Outer for GSWIP-3.0) */
+	u8		nDSCP;
+	/** Exclude (Outer) DSCP value used for GSWIP-3.0 only */
+	ltq_bool_t	bDSCP_Exclude;
+
+	/** Inner DSCP value used for GSWIP-3.0 only */
+	ltq_bool_t	bInner_DSCP_Enable;
+	/** Inner DSCP value  for GSWIP-3.0 only */
+	u8		nInnerDSCP;
+	/** Exclude of Inner DSCP (nInnerDSCP) value used for GSWIP-3.0 only */
+	ltq_bool_t	bInnerDSCP_Exclude;
+
+	/** CTAG VLAN PCP n DEI value used */
+	ltq_bool_t	bPCP_Enable;
+	/** CTAG VLAN PCP n DEI value */
+	u8		nPCP;
+	/* Exclude CTAG  value used for GSWIP-3.0 only */
+//   ltq_bool_t	bCTAG_Exclude;
+	/** Exclude CTAG PCP & DEI value used for GSWIP-3.0 only */
+	ltq_bool_t	bCTAG_PCP_DEI_Exclude;
+
+	/** STAG VLAN PCP/DEI value used */
+	ltq_bool_t	bSTAG_PCP_DEI_Enable;
+	/** STAG VLAN PCP value */
+	u8		nSTAG_PCP_DEI;
+	/* Exclude STAG  value used for GSWIP-3.0 only */
+//   ltq_bool_t	bSTAG_Exclude;
+	/** Exclude STAG PCP & DEI value used for GSWIP-3.0 only */
+	ltq_bool_t	bSTAG_PCP_DEI_Exclude;
+
+	/** Packet length used for classification */
+	ltq_bool_t	bPktLngEnable;
+	/** Packet length in bytes */
+	u16		nPktLng;
+	/** Packet length Range (from nPktLng to nPktLngRange) */
+	u16		nPktLngRange;
+	/** Exclude of Packet Length or range value used for GSWIP-3.0 only */
+	ltq_bool_t	bPktLng_Exclude;
+
+	/** Destination MAC address used */
+	ltq_bool_t	bMAC_DstEnable;
+	/** Destination MAC address */
+	u8		nMAC_Dst[6];
+	/** Destination MAC address nibble mask.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u16	nMAC_DstMask;
+	/** Exclude Destination MAC Address used for GSWIP-3.0 only */
+	ltq_bool_t	bDstMAC_Exclude;
+
+	/** Source MAC address used */
+	ltq_bool_t	bMAC_SrcEnable;
+	/** Source MAC address */
+	u8	nMAC_Src[6];
+	/** Source MAC address nibble mask.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u16	nMAC_SrcMask;
+	/** Exclude Source MAC Address used for GSWIP-3.0 only */
+	ltq_bool_t	bSrcMAC_Exclude;
+
+	/** MSB Application field used */
+	ltq_bool_t	bAppDataMSB_Enable;
+	/** MSB Application field.
+	    The first 2 bytes of the packet content following the IP header
+	    for TCP/UDP packets (source port field), or the first 2 bytes of packet content
+	    following the Ethertype for non-IP packets. Any part of this
+	    content can be masked-out by a programmable bit
+	    mask 'nAppMaskRangeMSB'. */
+	u16	nAppDataMSB;
+	/** MSB Application mask/range selection.
+	    If set to LTQ_TRUE, the field 'nAppMaskRangeMSB' is used as a
+	    range parameter, otherwise it is used as a nibble mask field. */
+	ltq_bool_t	bAppMaskRangeMSB_Select;
+	/** MSB Application mask/range. When used as a range parameter,
+	    1 bit represents 1 nibble mask of the 'nAppDataMSB' field.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u16	nAppMaskRangeMSB;
+	/** MSB Application Data Exclude - for GSWIP-3.0 only */
+	ltq_bool_t	bAppMSB_Exclude;
+
+	/** LSB Application used */
+	ltq_bool_t	bAppDataLSB_Enable;
+	/** LSB Application field.
+	    The following 2 bytes of the packet behind the 'nAppDataMSB' field.
+	    This is the destination port field for TCP/UDP packets,
+	    or byte 3 and byte 4 of the packet content following the Ethertype
+	    for non-IP packets. Any part of this content can be masked-out
+	    by a programmable bit mask 'nAppMaskRangeLSB'. */
+	u16	nAppDataLSB;
+	/** LSB Application mask/range selection.
+	    If set to LTQ_TRUE, the field 'nAppMaskRangeLSB' is used as
+	    a range parameter, otherwise it is used as a nibble mask field. */
+	ltq_bool_t	bAppMaskRangeLSB_Select;
+	/** LSB Application mask/range. When used as a range parameter,
+	    1 bit represents 1 nibble mask of the 'nAppDataLSB' field.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u16	nAppMaskRangeLSB;
+	/** LSB Application Data Exclude - for GSWIP-3.0 only */
+	ltq_bool_t	bAppLSB_Exclude;
+
+	/** Destination IP Selection (Outer for GSWIP-3.0). */
+	GSW_PCE_IP_t	eDstIP_Select;
+	/** Destination IP (Outer for GSWIP-3.0) */
+	GSW_IP_t	nDstIP;
+	/** Destination IP Nibble Mask.
+	    1 bit represents 1 nibble mask of the 'nDstIP' field.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u32	nDstIP_Mask;
+	/** Exclude Destination IP Value - used for GSWIP-3.0 only */
+	ltq_bool_t	bDstIP_Exclude;
+
+	/** Inner Destination IP Selection - for GSWIP-3.0 only. */
+	GSW_PCE_IP_t	eInnerDstIP_Select;
+	/** Inner Destination IP  - for GSWIP-3.0 only.*/
+	GSW_IP_t	nInnerDstIP;
+	/** Inner Destination IP Nibble Mask - for GSWIP-3.0 only.
+	    1 bit represents 1 nibble mask of the 'nInnerDstIP' field.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u32	nInnerDstIP_Mask;
+	/** Exclude Inner Destination IP Value - used for GSWIP-3.0 only */
+	ltq_bool_t	bInnerDstIP_Exclude;
+
+	/** Source IP Selection (Outer for GSWIP-3.0). */
+	GSW_PCE_IP_t	eSrcIP_Select;
+	/** Source IP  (Outer for GSWIP-3.0) */
+	GSW_IP_t	nSrcIP;
+	/** Source IP Nibble Mask (Outer for GSWIP-3.0).
+	    1 bit represents 1 nibble mask of the 'nSrcIP' field.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u32	nSrcIP_Mask;
+	/** Exclude Source IP Value - used for GSWIP-3.0 only */
+	ltq_bool_t	bSrcIP_Exclude;
+
+	/** Inner Source IP Selection - for GSWIP-3.0 only. */
+	GSW_PCE_IP_t	eInnerSrcIP_Select;
+	/** Inner Source IP  - for GSWIP-3.0 only*/
+	GSW_IP_t	nInnerSrcIP;
+	/** Inner Src IP Nibble Mask - for GSWIP-3.0 only.
+	    1 bit represents 1 nibble mask of the 'nInnerSrcIP' field.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u32	nInnerSrcIP_Mask;
+	/** Exclude Inner Source IP Value - used for GSWIP-3.0 only */
+	ltq_bool_t	bInnerSrcIP_Exclude;
+
+	/** Ethertype used. */
+	ltq_bool_t	bEtherTypeEnable;
+	/** Ethertype */
+	u16	nEtherType;
+	/** Ethertype Mask.
+	    1 bit represents 1 nibble mask of the 'nEtherType' field.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits.
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u16	nEtherTypeMask;
+	/** Exclude for Ether Type Value - used for GSWIP-3.0 only. */
+	ltq_bool_t	bEtherType_Exclude;
+
+	/** IP protocol used */
+	ltq_bool_t	bProtocolEnable;
+	/** IP protocol Value */
+	u8	nProtocol;
+	/** IP protocol Mask.
+	    1 bit represents 1 nibble mask of the 'nProtocol' field.
+	    Please clear the bits of the nibbles that are not marked out and set all other bits i.e. a set bit 1 indicates that bit is masked out (not compared).
+	    The LSB bit represents the lowest data nibble, the next bit the next nibble,
+	    and so on. */
+	u8	nProtocolMask;
+	/** Exclude for IP Protocol Value - used for GSWIP-3.0 only. */
+	ltq_bool_t	bProtocol_Exclude;
+
+	/** Inner IP protocol used - for GSWIP-3.0 only. */
+	ltq_bool_t	bInnerProtocolEnable;
+	/** Inner IP protocol Value - for GSWIP-3.0 only. */
+	u8	nInnerProtocol;
+	/** Inner IP protocol Bit Mask - for GSWIP-3.0 only. */
+	u8	nInnerProtocolMask;
+	/** Exclude for Inner IP Protocol Value - used for GSWIP-3.0 only. */
+	ltq_bool_t	bInnerProtocol_Exclude;
+
+	/** PPPoE used. */
+	ltq_bool_t	bSessionIdEnable;
+	/** PPPoE Session Id */
+	u16	nSessionId;
+	/** Exclude for PPPoE Session Value - used for GSWIP-3.0 only. */
+	ltq_bool_t	bSessionId_Exclude;
+
+	/** PPP Protocol used - used for GSWIP-3.0 only */
+	ltq_bool_t	bPPP_ProtocolEnable;
+	/** PPP Protocol Value  - used for GSWIP-3.0 only*/
+	u16	nPPP_Protocol;
+	/** PPP protocol Bit Mask (Positional bit 1 signifies masking of corresponding bit value in nPPP_Protocol) - for GSWIP-3.0 only. */
+	u16	nPPP_ProtocolMask;
+	/** Exclude for PPP Protocol Value - used for GSWIP-3.0 only. */
+	ltq_bool_t	bPPP_Protocol_Exclude;
+
+	/** VLAN ID (CVID) used.
+
+	    \remarks
+	    CVID is inner VLAN as defined in GSWIP-3.1 */
+	ltq_bool_t	bVid;
+	/** VLAN ID (CVID) */
+	u16	nVid;
+	/** VID mask/range selection.
+	    If set to 1, the field 'nVidRange' is used as
+	    a range parameter, otherwise it is used as a mask field.
+
+	    \remarks
+	    This must be range in GSWIP-3.1 */
+	ltq_bool_t	bVidRange_Select;
+	/** VLAN ID Range (CVID). Gets used as mask to nVid in case bVidRange_Select is set to 0 */
+	u16	nVidRange;
+	/** Exclude for VLAN Id (CVLAN) - used for GSWIP-3.0 only. */
+	ltq_bool_t	bVid_Exclude;
+	/** If this field is TRUE, use original VLAN ID as key even it's modified in
+	    any stage before flow table process. Used for GSWIP-3.1 only. */
+	ltq_bool_t bVid_Original;
+
+	/** STAG VLAN ID used.
+
+	    \remarks
+	    SLAN is outer VLAN as defined GSWIP-3.1 */
+	ltq_bool_t	bSLAN_Vid;
+	/** STAG VLAN ID */
+	u16	nSLAN_Vid;
+	/** Exclude for SVLAN Id (SVLAN) - used for GSWIP-3.0 only. */
+	ltq_bool_t	bSLANVid_Exclude;
+	/** VID mask/range selection.
+	    If set to 1, the field 'nVidRange' is used as
+	    a range parameter, otherwise it is used as a mask field.
+
+	    \remarks
+	    This must be range in GSWIP-3.1 */
+	ltq_bool_t	bSVidRange_Select;
+	/** VLAN ID Range for outer VLAN tag. Used for GSWIP-3.1 only. */
+	u16 nOuterVidRange;
+	/** If this field is TRUE, use original VLAN ID as key even it's modified in
+	    any stage before flow table process. Used for GSWIP-3.1 only. */
+	ltq_bool_t bOuterVid_Original;
+
+	/** Payload-1 used - for GSWIP-3.0 PAE only */
+	ltq_bool_t	bPayload1_SrcEnable;
+	/** Payload-1 Value (16-bits) - for GSWIP-3.0 PAE only */
+	u16	nPayload1;
+	/** Payload1 mask/range selection.
+	    If set to LTQ_TRUE, the field 'nPayload1' is used as
+	    a range parameter, otherwise it is used as a bit mask field. */
+	ltq_bool_t	bPayload1MaskRange_Select;
+	/** Payload-1 Bit mask - for GSWIP-3.0 PAE only */
+	u16	nPayload1_Mask;
+	/** Exclude Payload-1 used for GSWIP-3.0 PAE only */
+	ltq_bool_t	bPayload1_Exclude;
+
+	/** Payload-2 used - for GSWIP-3.0 PAE only */
+	ltq_bool_t	bPayload2_SrcEnable;
+	/** Payload-2 Value (16-bits) - for GSWIP-3.0 PAE only */
+	u16	nPayload2;
+	/** Payload2 mask/range selection.
+	    If set to LTQ_TRUE, the field 'nPayload2' is used as
+	    a range parameter, otherwise it is used as a bit mask field. */
+	ltq_bool_t	bPayload2MaskRange_Select;
+	/** Payload-2 Bit mask - for GSWIP-3.0 PAE only */
+	u16	nPayload2_Mask;
+	/** Exclude Payload-2 used for GSWIP-3.0 PAE only */
+	ltq_bool_t	bPayload2_Exclude;
+
+	/** Parser Flag LSW (Bit position 15 to 0) is used - for GSWIP 3.0 only */
+	ltq_bool_t	bParserFlagLSB_Enable;
+	/** Parser Flag LSW Value - each bit indicates specific parsed result */
+	u16	nParserFlagLSB;
+	/** Corresponding LSW Parser Flag Mask - when the bit is set to 1 corresponding flag gets masked out (ignored). */
+	u16	nParserFlagLSB_Mask;
+	/** Exclude for Parser Flag LSW specified in nParserFlagLSB */
+	ltq_bool_t	bParserFlagLSB_Exclude;
+
+	/** Parser Flag MSW (Bit 31 to 16) is used - for GSWIP 3.0 only */
+	ltq_bool_t	bParserFlagMSB_Enable;
+	/** Parser Flag MSW Value - each bit indicates specific parsed result */
+	u16	nParserFlagMSB;
+	/** Corresponding Parser Flag MSW Mask - when the bit is set to 1 corresponding flag gets masked out (ignored). */
+	u16	nParserFlagMSB_Mask;
+	/** Exclude for Parser Flag MSW specified in nParserFlagMSB */
+	ltq_bool_t	bParserFlagMSB_Exclude;
+
+	/** Parser Flag LSW (Bit position 47 to 32) is used - for GSWIP 3.1 only */
+	ltq_bool_t	bParserFlag1LSB_Enable;
+	/** Parser Flag LSW Value - each bit indicates specific parsed result */
+	u16	nParserFlag1LSB;
+	/** Corresponding LSW Parser Flag Mask - when the bit is set to 1 corresponding flag gets masked out (ignored). */
+	u16	nParserFlag1LSB_Mask;
+	/** Exclude for Parser Flag LSW specified in nParserFlagLSB */
+	ltq_bool_t	bParserFlag1LSB_Exclude;
+
+	/** Parser Flag MSW (Bit 63 to 48) is used - for GSWIP 3.1 only */
+	ltq_bool_t	bParserFlag1MSB_Enable;
+	/** Parser Flag MSW Value - each bit indicates specific parsed result */
+	u16	nParserFlag1MSB;
+	/** Corresponding Parser Flag MSW Mask - when the bit is set to 1 corresponding flag gets masked out (ignored). */
+	u16	nParserFlag1MSB_Mask;
+	/** Exclude for Parser Flag MSW specified in nParserFlagMSB */
+	ltq_bool_t	bParserFlag1MSB_Exclude;
+
+	/** nInsertionFlag is used. For GSWIP-3.1 only */
+	ltq_bool_t bInsertionFlag_Enable;
+	/** Inserted packet by CPU to data path. For GSWIP-3.1 only */
+	u16 nInsertionFlag;
+} GSW_PCE_pattern_t;
+
+/** \brief IGMP Snooping Control.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disabled. IGMP Snooping is disabled. */
+	GSW_PCE_ACTION_IGMP_SNOOP_DISABLE	= 0,
+	/** Default. Regular Packet. No IGMP Snooping action required. */
+	GSW_PCE_ACTION_IGMP_SNOOP_REGULAR	= 1,
+	/** IGMP Report/Join Message. */
+	GSW_PCE_ACTION_IGMP_SNOOP_REPORT	= 2,
+	/** IGMP Leave Message. */
+	GSW_PCE_ACTION_IGMP_SNOOP_LEAVE	= 3,
+	/**  Router Solicitation/Advertisement message. */
+	GSW_PCE_ACTION_IGMP_SNOOP_AD	= 4,
+	/** IGMP Query Message. */
+	GSW_PCE_ACTION_IGMP_SNOOP_QUERY	= 5,
+	/** IGMP Group Specific Query Message. */
+	GSW_PCE_ACTION_IGMP_SNOOP_QUERY_GROUP	= 6,
+	/** IGMP General Query message without Router Solicitation. */
+	GSW_PCE_ACTION_IGMP_SNOOP_QUERY_NO_ROUTER = 7
+} GSW_PCE_ActionIGMP_Snoop_t;
+
+/** \brief MAC Address Learning control.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Learning is based on the forwarding decision. If the packet is discarded,
+	    the address is not learned. If the packet is forwarded to any egress port,
+	    the address is learned. */
+	GSW_PCE_ACTION_LEARNING_DISABLE	= 0,
+	/** Reserved */
+	GSW_PCE_ACTION_LEARNING_REGULAR	= 1,
+	/** Force No Learning. The address is not learned; forwarding decision
+	    ignored. */
+	GSW_PCE_ACTION_LEARNING_FORCE_NOT = 2,
+	/** Force Learning. The address is learned, the forwarding decision ignored.
+	    Note: The MAC Learning Control signals delivered to Port-Map filtering
+	    and combined with Final Forwarding Decision. The result is used as a
+	    feedback for MAC Address learning in the Bridging Table. */
+	GSW_PCE_ACTION_LEARNING_FORCE	= 3
+} GSW_PCE_ActionLearning_t;
+
+/** \brief Flow Meter Assignment control.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Action Disable. */
+	GSW_PCE_ACTION_METER_DISABLE	= 0,
+	/** Action Enable.
+	    The action is enabled but no dedicated metering instance is assigned by the rule. */
+	GSW_PCE_ACTION_METER_REGULAR	= 1,
+	/** Action Enable. Assign one meter instance as given in parameter "nMeterId". */
+	GSW_PCE_ACTION_METER_1	= 2,
+	/** Action Enable. Assign pair of meter instances.
+	    These instances are "nMeterId" and the next following meter instance index. */
+	GSW_PCE_ACTION_METER_1_2	= 3
+} GSW_PCE_ActionMeter_t;
+
+/** \brief Traffic Class Action Selector.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disabled. Traffic class action is disabled. */
+	GSW_PCE_ACTION_TRAFFIC_CLASS_DISABLE	= 0,
+	/** Regular Class. Traffic class action is enabled and the CoS
+	    classification traffic class is used. */
+	GSW_PCE_ACTION_TRAFFIC_CLASS_REGULAR	= 1,
+	/** Alternative Class. Traffic class action is enabled and the
+	    class of the 'nTrafficClassAlter' field is used. */
+	GSW_PCE_ACTION_TRAFFIC_CLASS_ALTERNATIVE	= 2,
+} GSW_PCE_ActionTrafficClass_t;
+
+/** \brief Interrupt Control Action Selector.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disabled. Interrupt Control Action is disabled for this rule. */
+	GSW_PCE_ACTION_IRQ_DISABLE	= 0,
+	/** Regular Packet. The Interrupt Control Action is enabled, the packet is
+	    treated as a regular packet and no interrupt event is generated. */
+	GSW_PCE_ACTION_IRQ_REGULAR	= 1,
+	/** Interrupt Event. The Interrupt Control Action is enabled and an
+	    interrupt event is generated. */
+	GSW_PCE_ACTION_IRQ_EVENT	= 2
+} GSW_PCE_ActionIrq_t;
+
+/** \brief Cross State Action Selector.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disable. The Cross State Action is disabled. */
+	GSW_PCE_ACTION_CROSS_STATE_DISABLE	= 0,
+	/** Regular Packet. The Cross State Action is enabled and the packet is
+	    treated as a non-Cross-State packet (regular packet). Therefore it does
+	    not ignore Port-State filtering rules. */
+	GSW_PCE_ACTION_CROSS_STATE_REGULAR	= 1,
+	/** Cross-State packet. The Cross State Action is enabled and the packet is
+	    treated as a Cross-State packet. It ignores the Port-State
+	    filtering rules. */
+	GSW_PCE_ACTION_CROSS_STATE_CROSS	= 2
+} GSW_PCE_ActionCrossState_t;
+
+/** \brief Critical Frame Action Selector.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disable. The Critical Frame Action is disabled. */
+	GSW_PCE_ACTION_CRITICAL_FRAME_DISABLE	= 0,
+	/** Regular Packet. The Critical Frame Action is enabled and the packet is
+	    treated as a non-Critical Frame. */
+	GSW_PCE_ACTION_CRITICAL_FRAME_REGULAR	= 1,
+	/** Critical Packet. The Critical Frame Action is enabled and the packet is
+	    treated as a Critical Frame. */
+	GSW_PCE_ACTION_CRITICAL_FRAME_CRITICAL	= 2
+} GSW_PCE_ActionCriticalFrame_t;
+
+/** \brief Color Frame Action Selector.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disable. No color frame action. */
+	GSW_PCE_ACTION_COLOR_FRAME_DISABLE = 0,
+	/** Do not change color. */
+	GSW_PCE_ACTION_COLOR_FRAME_NO_CHANGE = 1,
+	/** Idendity packet as critical which bypass active congestion
+	    management (ACM). */
+	GSW_PCE_ACTION_COLOR_FRAME_CRITICAL = 2,
+	/** Change to green color. */
+	GSW_PCE_ACTION_COLOR_FRAME_GREEN = 3,
+	/** Change to yellow color. */
+	GSW_PCE_ACTION_COLOR_FRAME_YELLOW = 4,
+	/** Change to red color. */
+	GSW_PCE_ACTION_COLOR_FRAME_RED = 5
+} GSW_PCE_ActionColorFrame_t;
+
+/** \brief Timestamp Action Selector.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disable. Timestamp Action is disabled for this rule. */
+	GSW_PCE_ACTION_TIMESTAMP_DISABLE	= 0,
+	/** Regular Packet. The Timestamp Action is enabled for this rule.
+	    The packet is treated as a regular packet and no timing information
+	    is stored. */
+	GSW_PCE_ACTION_TIMESTAMP_REGULAR	= 1,
+	/** Receive/Transmit Timing packet. Ingress and Egress Timestamps for
+	    this packet should be stored. */
+	GSW_PCE_ACTION_TIMESTAMP_STORED	= 2
+} GSW_PCE_ActionTimestamp_t;
+
+/** \brief Forwarding Group Action Selector.
+    This flow table action and the 'bFlowID_Action' action
+    can be used exclusively.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disable. Forwarding Group Action is disabled. */
+	GSW_PCE_ACTION_PORTMAP_DISABLE	= 0,
+	/** Regular Packet. Forwarding Action enabled. Select Default
+	    Port-Map (result of Default Forwarding Classification). */
+	GSW_PCE_ACTION_PORTMAP_REGULAR	= 1,
+	/** Discard. Discard the packets. */
+	GSW_PCE_ACTION_PORTMAP_DISCARD	= 2,
+	/** Forward to the CPU port. This requires that the CPU port is previously
+	    set by calling \ref GSW_CPU_PORT_CFG_SET. */
+	GSW_PCE_ACTION_PORTMAP_CPU	= 3,
+	/** Forward to a portmap, selected by the parameter 'nForwardPortMap'.
+	    Please note that this feature is not supported by all
+	    hardware platforms. */
+	GSW_PCE_ACTION_PORTMAP_ALTERNATIVE	= 4,
+	/** The packet is treated as Multicast Router
+	    Solicitation/Advertisement or Query packet. */
+	GSW_PCE_ACTION_PORTMAP_MULTICAST_ROUTER	= 5,
+	/** The packet is interpreted as Multicast packet and learned in the
+	    multicast group table. */
+	GSW_PCE_ACTION_PORTMAP_MULTICAST_HW_TABLE = 6,
+	/** The CTAG VLAN portmap classification result is replaced by the
+	    portmap parameter 'nForwardPortMap'. All other classification
+	    results stay unchanged and will be combined together with
+	    the overwritten portmap. */
+	GSW_PCE_ACTION_PORTMAP_ALTERNATIVE_VLAN	= 7,
+	/** Add STAG VLAN portmap 'nForwardPortMap' to the overall portmap
+	    classification result (AND'ed with the portmap). */
+	GSW_PCE_ACTION_PORTMAP_ALTERNATIVE_STAG_VLAN	= 8
+} GSW_PCE_ActionPortmap_t;
+
+/** \brief VLAN Group Action Selector.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disabled. The VLAN Action is disabled. */
+	GSW_PCE_ACTION_VLAN_DISABLE	= 0,
+	/** Regular VLAN. VLAN Action enabled. Select Default VLAN ID. */
+	GSW_PCE_ACTION_VLAN_REGULAR	= 1,
+	/** Alternative VLAN. VLAN Action enabled.
+	    Select Alternative VLAN as configured in 'nVLAN_Id'
+	    or 'nSVLAN_Id'. For CTAG VLAN it requires that this VLAN ID
+	    is configured by calling
+	    \ref GSW_VLAN_ID_CREATE in advance.
+	    This additional call is not required for STAG VLAN. */
+	GSW_PCE_ACTION_VLAN_ALTERNATIVE	= 2
+} GSW_PCE_ActionVLAN_t;
+
+/** \brief Cross VLAN Action Selector.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Disabled. The Cross VLAN Action is disabled. */
+	GSW_PCE_ACTION_CROSS_VLAN_DISABLE	= 0,
+	/** Regular VLAN Packet. Do not ignore VLAN filtering rules. */
+	GSW_PCE_ACTION_CROSS_VLAN_REGULAR	= 1,
+	/** Cross-VLAN packet. Ignore VLAN filtering  rules.*/
+	GSW_PCE_ACTION_CROSS_VLAN_CROSS	= 2
+} GSW_PCE_ActionCrossVLAN_t;
+
+/** \brief Port Filter Action-1/2/3/4/5/6 Selector - used for GSWIP-3.0 only.
+     This can be used only along with PortMember config.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Port Filter Action is Unused. */
+	GSW_PCE_PORT_FILTER_ACTION_UNUSED = 0,
+	/** Port Filter Action Type-1 is used. */
+	GSW_PCE_PORT_FILTER_ACTION_1	= 1,
+	/** Port Filter Action Type-2 is used. */
+	GSW_PCE_PORT_FILTER_ACTION_2	= 2,
+	/** Port Filter Action Type-3 is used. */
+	GSW_PCE_PORT_FILTER_ACTION_3	= 3,
+	/** Port Filter Action Type-4 is used. */
+	GSW_PCE_PORT_FILTER_ACTION_4	= 4,
+	/** Port Filter Action Type-5 (Unknown Unicast) is used. */
+	GSW_PCE_PORT_FILTER_ACTION_5	= 5,
+	/** Port Filter Action Type-6 (Unknown Multicast) is used. */
+	GSW_PCE_PORT_FILTER_ACTION_6	= 6
+} GSW_PCE_PortFilterAction_t;
+
+/** \brief MPE Processing Path Assignment Selector - used for GSWIP-3.0 only.
+    Used by \ref GSW_PCE_action_t. */
+typedef enum {
+	/** Processing Path is not enabled. */
+	GSW_PCE_PROCESSING_PATH_UNUSED = 0,
+	/** Processing Path-1 is used for MPE-1. */
+	GSW_PCE_PROCESSING_PATH_1 = 1,
+	/** Processing Path-2 is used for MPE-2. */
+	GSW_PCE_PROCESSING_PATH_2 = 2,
+	/** Processing Path-1 and -2 are used for MPE-1 & MPE-2. */
+	GSW_PCE_PROCESSING_PATH_BOTH = 3,
+} GSW_PCE_ProcessingPathAction_t;
+
+/** \brief Packet Classification Engine Action Configuration.
+    GSWIP-3.0 extension actions are explicitly indicated.
+    Used by \ref GSW_PCE_rule_t. */
+typedef struct {
+	/** Action "Traffic Class" Group.
+	    Traffic class action enable */
+	GSW_PCE_ActionTrafficClass_t	eTrafficClassAction;
+	/** Alternative Traffic class - used when eTrafficClassAction is set to 2. */
+	u8	nTrafficClassAlternate;
+
+	/** Action "IGMP Snooping" Group.
+	    IGMP Snooping control and enable. Please note that the 'nPortMapAction'
+	    configuration is ignored in case the IGMP snooping is enabled.
+	    Here, on read operations,
+	    'nPortMapAction = GSW_PCE_ACTION_PORTMAP_DISABLE' is returned. */
+	GSW_PCE_ActionIGMP_Snoop_t	eSnoopingTypeAction;
+
+	/** Action "Learning" Group.
+	    Learning action control and enable */
+	GSW_PCE_ActionLearning_t	eLearningAction;
+
+	/** Action "Interrupt" Group.
+	    Interrupt action generate and enable */
+	GSW_PCE_ActionIrq_t	eIrqAction;
+
+	/** Action "Cross State" Group.
+	    Cross state action control and enable */
+	GSW_PCE_ActionCrossState_t	eCrossStateAction;
+
+	/** Action "Critical Frames" Group.
+	    Critical Frame action control and enable */
+	GSW_PCE_ActionCriticalFrame_t	eCritFrameAction;
+
+	/** Action "Color Frames" Group.
+	    This is replacement of eCritFrameAction in GSWIP-3.1. */
+	GSW_PCE_ActionColorFrame_t eColorFrameAction;
+
+	/** Action "Timestamp" Group. Time stamp action control and enable */
+	GSW_PCE_ActionTimestamp_t	eTimestampAction;
+
+	/** Action "Forwarding" Group.
+	    Port map action enable. This port forwarding configuration is ignored
+	    in case the action "IGMP Snooping" is enabled via the
+	    parameter 'nSnoopingTypeAction'. */
+	GSW_PCE_ActionPortmap_t	ePortMapAction;
+	/** Target portmap for forwarded packets, only used if selected by
+	    'ePortMapAction'. Forwarding is done
+	    if 'ePortMapAction = GSW_PCE_ACTION_PORTMAP_ALTERNATIVE'.
+	    Every bit in the portmap represents one port (port 0 = LSB bit). */
+	u16 nForwardPortMap[16];
+
+	/** Target Sub-Interface Id (GSWIP-3.0 only) for forwarded packets,
+	    only used if selected by 'ePortMapAction'. Forwarding is done
+	    if 'ePortMapAction = GSW_PCE_ACTION_PORTMAP_ALTERNATIVE'. */
+	u16	nForwardSubIfId;
+
+	/** Action "Remarking" Group. Remarking action enable. Reserved in
+	    GSWIP-3.1. */
+	ltq_bool_t	bRemarkAction;
+	/** CTAG VLAN PCP remarking enable. Reserved in GSWIP-3.1.
+	    Remarking enabling means that remarking is possible in case
+	    the port configuration or metering enables remarking on that
+	    packet. Disabling remarking means that it is forced to
+	    not remarking this packet, independent of any port remarking of
+	    metering configuration. */
+	ltq_bool_t	bRemarkPCP;
+	/** STAG VLAN PCP remarking enable. Reserved in GSWIP-3.1.
+	    Remarking enabling means that remarking is possible in case
+	    the port configuration or metering enables remarking on that
+	    packet. Disabling remarking means that it is forced to
+	    not remarking this packet, independent of any port remarking of
+	    metering configuration. */
+	ltq_bool_t	bRemarkSTAG_PCP;
+	/** STAG VLAN DEI remarking enable. Reserved in GSWIP-3.1.
+	    Remarking enabling means that remarking is possible in case
+	    the port configuration or metering enables remarking on that
+	    packet. Disabling remarking means that it is forced to
+	    not remarking this packet, independent of any port remarking of
+	    metering configuration. */
+	ltq_bool_t	bRemarkSTAG_DEI;
+	/** DSCP remarking enable. Reserved in GSWIP-3.1.
+	    Remarking enabling means that remarking is possible in case
+	    the port configuration or metering enables remarking on that
+	    packet. Disabling remarking means that it is forced to
+	    not remarking this packet, independent of any port remarking of
+	    metering configuration. */
+	ltq_bool_t	bRemarkDSCP;
+	/** Class remarking enable. Reserved in GSWIP-3.1.
+	    Remarking enabling means that remarking is possible in case
+	    the port configuration or metering enables remarking on that
+	    packet. Disabling remarking means that it is forced to
+	    not remarking this packet, independent of any port remarking of
+	    metering configuration. */
+	ltq_bool_t	bRemarkClass;
+
+	/** Action "Meter" Group. Meter action control and enable.
+	    If metering action enabled, specified metering instance number
+	    overrules any other metering assignment.
+	    Up to two metering instances can be applied to a single packet. */
+	GSW_PCE_ActionMeter_t	eMeterAction;
+	/** Meter ID */
+	u8	nMeterId;
+
+	/** Action "RMON" Group. RMON action enable. Reserved in GSWIP-3.1. */
+	ltq_bool_t	bRMON_Action;
+	/** Counter ID (The index starts counting from zero). */
+	u8	nRMON_Id;
+
+	/** Action "CTAG VLAN" Group. VLAN action enable */
+	GSW_PCE_ActionVLAN_t	eVLAN_Action;
+	/** Alternative CTAG VLAN Id */
+	u16	nVLAN_Id;
+	/** Enable alternative FID */
+	ltq_bool_t bFidEnable;
+	/** Alternative FID. Valid when bFidEnable is TRUE. */
+	u8	nFId;
+	/** Enable extended VLAN operation for traffic match this flow entry. */
+	ltq_bool_t bExtendedVlanEnable;
+	/** Extended VLAN block allocated for traffic match this flow entry. Valid
+	    when bExtendedVlanEnable is TRUE. Only FIRST VLAN operation in this block
+	    is used for flow process. */
+	u32 nExtendedVlanBlockId;
+	/** Action "STAG VLAN" Group. VLAN action enable */
+	GSW_PCE_ActionVLAN_t	eSVLAN_Action;
+	/** Alternative STAG VLAN Id */
+	u16	nSVLAN_Id;
+	/** Action "Cross VLAN" Group. Cross VLAN action enable */
+	GSW_PCE_ActionCrossVLAN_t	eVLAN_CrossAction;
+	/**  CVLAN Ignore control */
+	ltq_bool_t	bCVLAN_Ignore_Control;
+	/** Port BitMap Mux control */
+	ltq_bool_t	bPortBitMapMuxControl;
+	/** Trunking action enable  */
+	ltq_bool_t	bPortTrunkAction;
+	/**  Port Link Selection control */
+	ltq_bool_t	bPortLinkSelection;
+	/** Action "Flow ID".
+	 The Switch supports enhancing the egress packets by a device specific
+	 special tag header. This header contains detailed switch classification
+	 results. One header file is a 'Flow ID', which can be explicitly set as
+	 flow table action when hitting a table rule.
+	 If selected, the Flow ID is given by the parameter 'nFlowID'. */
+	ltq_bool_t	bFlowID_Action;
+	/** Flow ID */
+	u16	nFlowID;
+
+	/** Routing Extension Id Action Selector - for GSWIP-3.0 only.
+	  When enabled, it expects a valid nRoutExtId value to be supplied. */
+	ltq_bool_t	bRoutExtId_Action;
+	/** Routing Extension Id Value - for GSWIP-3.0 only. (8-bits range) */
+	u8	nRoutExtId;
+	/** Routing Destination Port Mask Comparison - for GSWIP-3.0 only. If not enabled this field is not considered for routing session pattern lookup.*/
+	ltq_bool_t	bRtDstPortMaskCmp_Action;
+	/** Routing Source Port Mask Comparison - for GSWIP-3.0 only. If not enabled, this field is not considered for routing session pattern lookup.*/
+	ltq_bool_t	bRtSrcPortMaskCmp_Action;
+	/** Routing Destination IP Address Mask Comparison - for GSWIP-3.0 only. If not enabled, this field is not considered for routing session pattern lookup.*/
+	ltq_bool_t	bRtDstIpMaskCmp_Action;
+	/** Routing Source IP Address Mask Comparison - for GSWIP-3.0 only. If not enabled, this field is not considered for routing session pattern lookup.*/
+	ltq_bool_t	bRtSrcIpMaskCmp_Action;
+	/** Selector of IP in Tunneled IP header (Outer or Inner) - for GSWIP-3.0 only. */
+	ltq_bool_t	bRtInnerIPasKey_Action;
+	/** Routing Acceleration Enable Action - for GSWIP-3.0 only. This variable decides whether to accelerate the Routing session or not */
+	ltq_bool_t	bRtAccelEna_Action;
+	/** Routing Control Enable Action - for GSWIP-3.0 only. This variable is selector of Routing Accelerate action*/
+	ltq_bool_t	bRtCtrlEna_Action;
+	/** Assignment of flow to MPE Processing Path-1 or -2 or both - for GSWIP-3.0 only. */
+	GSW_PCE_ProcessingPathAction_t eProcessPath_Action;
+	/** Port Filter Action Config for this flow - for GSWIP-3.0 only. */
+	GSW_PCE_PortFilterAction_t	ePortFilterType_Action;
+
+	/** Enable Extraction. For GSWIP-3.1 only.
+	    Packet is identified to be extracted at extraction point defined by
+	    nRecordId. */
+	ltq_bool_t bExtractEnable;
+	/** Enable OAM. For GSWIP-3.1 only.
+	    Packet is identified for OAM process. */
+	ltq_bool_t bOamEnable;
+	/** Record ID is information used by extraction (bExtractEnable is set)
+	    and/or OAM process (bOamEnable is set). For GSWIP-3.1 only. Refer to
+	    GSWIP-3.1 Hardware Architecture Spec (HAS) for more detail. */
+	u32 nRecordId;
+} GSW_PCE_action_t;
+
+/** \brief Parameter to add/read a rule to/from the packet classification engine.
+    Used by \ref GSW_PCE_RULE_WRITE and \ref GSW_PCE_RULE_READ. */
+typedef struct {
+	/** PCE Rule Pattern Part. */
+	GSW_PCE_pattern_t	pattern;
+	/** PCE Rule Action Part. */
+	GSW_PCE_action_t	action;
+} GSW_PCE_rule_t;
+
+/** \brief Parameter to delete a rule from the packet classification engine.
+    Used by \ref GSW_PCE_RULE_DELETE. */
+typedef struct {
+	/** Rule Index in the PCE Table. */
+	u32	nIndex;
+} GSW_PCE_ruleDelete_t;
+
+/*@}*/ /* GSW_IOCTL_CLASS */
+
+/** \addtogroup GSW_IOCTL_SYS */
+/*@{*/
+
+/** \brief Reset selection.
+    Used by \ref GSW_reset_t. */
+typedef enum {
+	/** Switch Macro reset */
+	GSW_RESET_SWITCH	= 0,
+	/** MDIO master interface reset */
+	GSW_RESET_MDIO	= 1,
+} GSW_resetMode_t;
+
+/** \brief Reset selection.
+    Used by \ref GSW_RESET. */
+typedef struct {
+	/** Reset selection. */
+	GSW_resetMode_t	eReset;
+} GSW_reset_t;
+
+/** Number of extended RMON counter. */
+#define GSW_RMON_EXTEND_NUM	24
+
+
+/**
+   \brief Hardware platform extended RMON Counters. GSWIP-2.2/3.0 only.
+   This structure contains additional RMON counters of one Ethernet Switch Port.
+   These counters can be used by the packet classification engine and can be
+   freely assigned to dedicated packet rules and flows.
+    Used by \ref GSW_RMON_EXTEND_GET. */
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u8		nPortId;
+	/** Traffic flow counters */
+	u32	nTrafficFlowCnt[GSW_RMON_EXTEND_NUM];
+} GSW_RMON_extendGet_t;
+
+/**
+   \brief Hardware platform extended RMON Counters. GSWIP-3.1 only.
+   This structure contains additional RMON counters. These counters can be
+   used by the packet classification engine and can be freely assigned to
+   dedicated packet rules and flows.
+    Used by \ref GSW_RMON_FLOW_GET. */
+typedef struct {
+	/** If TRUE, use \ref GSW_RMON_flowGet_t::nIndex to access the Flow Counter,
+	    otherwise, use \ref GSW_TFLOW_COUNT_MODE_GET to determine mode and use
+	    \ref GSW_RMON_flowGet_t::nPortId and \ref GSW_RMON_flowGet_t::nFlowId
+	    to calculate index of the Flow Counter. */
+	ltq_bool_t bIndex;
+	/** Absolute index of Flow Counter. */
+	u16 nIndex;
+	/** Port ID. This could be Logical Port, CTP or Bridge Port. It depends
+	    on the mode set by \ref GSW_TFLOW_COUNT_MODE_SET. */
+	u16 nPortId;
+	/** \ref GSW_PCE_action_t::nFlowID. The range depends on the mode set
+	    by \ref GSW_TFLOW_COUNT_MODE_SET. */
+	u16 nFlowId;
+
+	/** Rx Packet Counter */
+	u32 nRxPkts;
+	/** Tx Packet Counter (non-PCE-Bypass) */
+	u32 nTxPkts;
+	/** Tx Packet Counter (PCE-Bypass) */
+	u32 nTxPceBypassPkts;
+} GSW_RMON_flowGet_t;
+
+/** \brief Used for getting metering RMON counters.
+    Used by \ref GSW_RMON_METER_GET */
+typedef enum {
+	/* Resereved */
+	GSW_RMON_METER_COLOR_RES = 0,
+	/* Green color */
+	GSW_RMON_METER_COLOR_GREEN = 1,
+	/* Yellow color */
+	GSW_RMON_METER_COLOR_YELLOW = 2,
+	/* Red color */
+	GSW_RMON_METER_COLOR_RED = 3,
+} GSW_RmonMeterColor_t;
+
+/**
+   \brief Hardware platform TFLOW counter mode.
+   Supported modes include, Global (default), Logical, CTP, Bridge port mode.
+   The number of counters that can be assigned varies based these mode type.
+    Used by \ref GSW_TFLOW_COUNT_MODE_SET and GSW_TFLOW_COUNT_MODE_GET. */
+typedef struct {
+	//Counter type. PCE Rx/Tx/Bp-Tx.
+	GSW_TflowCountConfType_t eCountType;
+	//Counter mode. Global/Logical/CTP/BrP.
+	GSW_TflowCmodeType_t eCountMode;
+	//The below params are valid only for CTP/BrP types.
+	//A group of ports matching MS (9-n) bits. n is nCtpLsb or nBrpLsb.
+	u16 nPortMsb;
+	//Number of valid bits in CTP port counter mode.
+	GSW_TflowCtpValBits_t nCtpLsb;
+	//Number of valid bits in bridge port counter mode.
+	GSW_TflowBrpValBits_t nBrpLsb;
+} GSW_TflowCmodeConf_t;
+
+/** \brief This structure describes the second, nano second and fractional
+    nano second counterpart of the switch reference timer. This
+    reference counter can be read by
+    using \ref GSW_TIMESTAMP_TIMER_GET , and it can be modified
+    by using \ref GSW_TIMESTAMP_TIMER_SET . */
+typedef struct {
+	/** Second. Absolute second timer count. */
+	u32	nSec;
+	/** Nano Second. Absolute nanosecond timer count. */
+	u32	nNanoSec;
+	/** Fractional NanoSecond. Absolute fractional nanosecond timer count.
+	    This counter specifis a 2^32 fractional 'nNanoSec'. */
+	u32	nFractionalNanoSec;
+} GSW_TIMESTAMP_Timer_t;
+
+/** \brief This structure describes the port related time stamp.
+    Used by \ref GSW_TIMESTAMP_PORT_READ.
+*/
+typedef struct {
+	/** Ethernet Port number (zero-based counting). The valid range is hardware
+	    dependent. An error code is delivered if the selected port is not
+	    available. */
+	u8		nPortId;
+	/** Second. Absolute second timer count. */
+	u32	nIngressSec;
+	/** Nano Second. Absolute nano second timer count. */
+	u32	nIngressNanoSec;
+	/** Second. Absolute second timer count. */
+	u32	nEgressSec;
+	/** Nano Second. Absolute nano second timer count. */
+	u32	nEgressNanoSec;
+} GSW_TIMESTAMP_PortRead_t;
+
+/*@}*/ /* GSW_IOCTL_SYS */
+
+/* -------------------------------------------------------------------------- */
+/*                        IOCTL Command Definitions                           */
+/* -------------------------------------------------------------------------- */
+
+/** \addtogroup GSW_IOCTL_DEBUG */
+/*@{*/
+
+/**
+   \brief Write to an internal register. The register offset defines which register to access in
+   which table. This routine only accesses the M4599_PDI and
+   the ETHSW_PDI of the switch. All PHY registers are accessed
+   via \ref GSW_MDIO_DATA_WRITE and \ref GSW_MDIO_DATA_READ.
+   Note that the switch API implementation checks whether the given address is
+   inside the valid address range. It returns with an error in case an invalid
+   address is given.
+
+   \param GSW_register_t Pointer to \ref GSW_register_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_REGISTER_SET	_IOW(GSW_COMMON_MAGIC, 0x02, GSW_register_t)
+
+/**
+   \brief Read an internal register. The register offset defines which register to access in
+   which table. This routine only accesses the ETHSW_PDI of the switch.
+   All PHY registers are accessed via \ref GSW_MDIO_DATA_WRITE and \ref GSW_MDIO_DATA_READ.
+   Note that the switch API implementation checks whether the given address is
+   inside the valid address range. It returns with an error in case an invalid
+   address is given.
+
+   \param GSW_register_t Pointer to \ref GSW_register_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_REGISTER_GET	_IOWR(GSW_COMMON_MAGIC, 0x01, GSW_register_t)
+
+/*@}*/ /* GSW_IOCTL_DEBUG */
+
+/** \addtogroup GSW_IOCTL_IRQ */
+/*@{*/
+/**
+   \brief Get the interrupt enable configuration. This assignment can be set using \ref GSW_IRQ_MASK_SET.
+
+   \param GSW_irq_t Pointer to an \ref GSW_irq_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+#define GSW_IRQ_MASK_GET	_IOWR(GSW_COMMON_MAGIC, 0x04, GSW_irq_t)
+
+/**
+   \brief Set the interrupt enable configuration. This assignment can be read using \ref GSW_IRQ_MASK_GET.
+   Setting interrupts that are not supported by hardware results in an error response.
+
+   \param GSW_irq_t Pointer to
+      an \ref GSW_irq_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+#define GSW_IRQ_MASK_SET	_IOW(GSW_COMMON_MAGIC, 0x05, GSW_irq_t)
+
+/**
+   \brief Read the interrupt status. Interrupt status indications can be cleared using \ref GSW_IRQ_STATUS_CLEAR.
+
+   \param GSW_irq_t Pointer to
+      an \ref GSW_irq_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+#define GSW_IRQ_GET	_IOWR(GSW_COMMON_MAGIC, 0x03, GSW_irq_t)
+
+/**
+   \brief Clear individual interrupt status bits. Interrupt status indications can be read using \ref GSW_IRQ_GET.
+
+   \param GSW_irq_t Pointer to
+      an \ref GSW_irq_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+*/
+#define GSW_IRQ_STATUS_CLEAR _IOW(GSW_COMMON_MAGIC, 0x06, GSW_irq_t)
+
+/*@}*/ /* GSW_IOCTL_IRQ */
+
+/** \addtogroup GSW_IOCTL_CLASS */
+/*@{*/
+
+/**
+   \brief This command writes a rule pattern and action to the table of the packet
+   classification engine. The pattern part describes the parameter to identify an
+   incoming packet to which the dedicated actions should be applied.
+   A rule can be read using the command \ref GSW_PCE_RULE_WRITE.
+
+   \param GSW_PCE_rule_t Pointer to \ref GSW_PCE_rule_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PCE_RULE_WRITE	_IOWR(GSW_TFLOW_MAGIC, 0x03, GSW_PCE_rule_t)
+
+/**
+   \brief This command allows the reading out of a rule pattern and action of the
+   packet classification engine.
+   A rule can be written using the command \ref GSW_PCE_RULE_WRITE.
+
+   \param GSW_PCE_rule_t Pointer to \ref GSW_PCE_rule_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PCE_RULE_READ	_IOWR(GSW_TFLOW_MAGIC, 0x02, GSW_PCE_rule_t)
+
+/**
+   \brief This command deletes a complete rule from the packet classification engine.
+   A delete operation is done on the rule of a dedicated index 'nIndex'.
+   A rule can be written over using the command \ref GSW_PCE_RULE_WRITE.
+
+   \param GSW_PCE_ruleDelete_t Pointer to \ref GSW_PCE_ruleDelete_t.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_PCE_RULE_DELETE  _IOWR(GSW_TFLOW_MAGIC, 0x01, GSW_PCE_ruleDelete_t)
+
+
+/*@}*/ /* GSW_IOCTL_CLASS */
+
+/** \addtogroup GSW_IOCTL_SYS */
+/*@{*/
+
+/**
+   \brief Forces a hardware reset of the switch device or switch macro. The device
+   automatically comes back out of reset and contains the initial values.
+   All previous configurations and statistics counters info are lost.
+
+   \param GSW_reset_t Pointer to an \ref GSW_reset_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+
+   \remarks Not supported for all devices
+*/
+#define GSW_RESET	_IOW(GSW_COMMON_MAGIC, 0x08, GSW_reset_t)
+
+/**
+   \brief Read out additional traffic flow (RMON) counters.
+   The zero-based 'nPortId' structure element describes the physical switch
+   port for the requested statistic information.
+   This API is replaced by
+	  \ref GSW_RMON_FLOW_GET for GSWIP-3.1.
+
+   \param GSW_RMON_extendGet_t  Pointer to a pre-allocated
+   \ref GSW_RMON_extendGet_t structure. The structure element 'nPortId' is
+   an input parameter that describes from which port to read the RMON counter.
+   All remaining structure elements are filled with the counter values.
+   The counter assignment needs to be done during the flow definition,
+   for example in \ref GSW_PCE_RULE_WRITE.
+
+   \remarks The function returns an error in case the given 'nPortId' is
+   out of range.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_RMON_EXTEND_GET	_IOWR(GSW_RMON_MAGIC, 0x08, GSW_RMON_extendGet_t)
+
+/** \brief This command sets the packet timestamp reference counter.
+    This reference timer is a switch global timer which is used by the
+    packet timestamp capture when sending and receiving Ethernet port level.
+
+    The command \ref GSW_TIMESTAMP_TIMER_GET allows to read out
+    the current reference timer.
+
+   \param GSW_TIMESTAMP_Timer_t Pointer to an \ref GSW_TIMESTAMP_Timer_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_TIMESTAMP_TIMER_SET _IOW(GSW_COMMON_MAGIC, 0x1D, GSW_TIMESTAMP_Timer_t)
+
+/** \brief This command reads out the switch global reference timer counter that is
+    used by the packet timestamp capture when sending and receiving Ethernet port level.
+
+    This reference timer is useful when processing the packet related
+    timestamp information for delay calculation.
+
+    The reference timer can be configured by \ref GSW_TIMESTAMP_TIMER_SET.
+
+   \param GSW_TIMESTAMP_Timer_t Pointer to an \ref GSW_TIMESTAMP_Timer_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_TIMESTAMP_TIMER_GET _IOWR(GSW_COMMON_MAGIC, 0x1E, GSW_TIMESTAMP_Timer_t)
+
+/** \brief This command reads out the port related timestamp values. This timestamp is captured
+    for ingress and egress packets triggered due to a traffic flow table timestamp action.
+    A switch global reference timer is used for the timestamp capture operation.
+    This global timer can be access by using \ref GSW_TIMESTAMP_TIMER_SET
+    and \ref GSW_TIMESTAMP_TIMER_GET.
+
+    A port related packet timestamp is triggered by the flow table
+    action 'eTimestampAction'.
+
+   \param GSW_TIMESTAMP_PortRead_t Pointer to
+      an \ref GSW_TIMESTAMP_PortRead_t structure.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_TIMESTAMP_PORT_READ _IOWR(GSW_COMMON_MAGIC, 0x1F, GSW_TIMESTAMP_PortRead_t)
+
+/**
+   \brief Read out additional traffic flow (RMON) counters. GSWIP-3.1 only.
+
+   \param GSW_RMON_flowGet_t  Pointer to a pre-allocated
+   \ref GSW_RMON_flowGet_t structure.
+
+   \remarks The function returns an error in case the given 'nIndex' is
+   out of range.
+
+   \remarks The function returns an error code in case an error occurs.
+            The error code is described in \ref GSW_return_t.
+
+   \return Return value as follows:
+   - GSW_statusOk: if successful
+   - An error code in case an error occurs
+*/
+#define GSW_RMON_FLOW_GET _IOWR(GSW_RMON_MAGIC, 0x09, GSW_RMON_flowGet_t)
+
+/*@}*/ /* GSW_IOCTL_SYS */
+
+#endif /* _LANTIQ_GSW_FLOW_H_ */
diff --git a/include/net/switch_api/mac_ops.h b/include/net/switch_api/mac_ops.h
index 57c8af04cf3a..51d014c78008 100644
--- a/include/net/switch_api/mac_ops.h
+++ b/include/net/switch_api/mac_ops.h
@@ -12,6 +12,9 @@
 
 #include "gsw_irq.h"
 #include "gsw_types.h"
+#ifdef __KERNEL__
+#include <linux/netdevice.h>
+#endif
 
 struct mac_ops {
 	/* This function Sets the Flow Ctrl operation in Both XGMAC and LMAC.
@@ -299,6 +302,31 @@ struct mac_ops {
 	 * return	OUT	-1: 	Configure Sub Second Inccrement Error
 	 */
 	int(*config_subsec_inc)(void *, u32);
+#ifdef __KERNEL__
+	/* This sequence is used set Hardware timestamp
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 */
+	int(*set_hwts)(void *, struct ifreq *);
+	/* This sequence is used get Hardware timestamp
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 */
+	int(*get_hwts)(void *, struct ifreq *);
+	/* This sequence is used for Rx Hardware timestamp operations
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT	-1: 	Initialize MAC Error
+	 */
+	int(*do_rx_hwts)(void *, struct sk_buff *);
+	/* This sequence is used for Tx Hardware timestamp operations
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT	-1: 	Initialize MAC Error
+	 */
+	int(*do_tx_hwts)(void *, struct sk_buff *);
+	/* This sequence is get Timestamp info
+	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
+	 * return	OUT	-1: 	Initialize MAC Error
+	 */
+	int(*mac_get_ts_info)(void *, struct ethtool_ts_info *);
+#endif
 	/* This sequence is used Initialize MAC
 	 * param[in/out]IN:	ops	MAC ops Struct registered for MAC 0/1/2.
 	 * return	OUT	-1: 	Initialize MAC Error
diff --git a/tools/testing/selftests/ptp/testptp.c b/tools/testing/selftests/ptp/testptp.c
index 5d2eae16f7ee..01ae4530b835 100644
--- a/tools/testing/selftests/ptp/testptp.c
+++ b/tools/testing/selftests/ptp/testptp.c
@@ -49,13 +49,14 @@
 #endif
 
 /* clock_adjtime is not available in GLIBC < 2.14 */
-#if !__GLIBC_PREREQ(2, 14)
+//#if !__GLIBC_PREREQ(2, 14)
 #include <sys/syscall.h>
-static int clock_adjtime(clockid_t id, struct timex *tx)
+int clock_adjtime(clockid_t id, struct timex *tx)
 {
+    printf("clock_adjtime\n");
 	return syscall(__NR_clock_adjtime, id, tx);
 }
-#endif
+//#endif
 
 static clockid_t get_clockid(int fd)
 {
