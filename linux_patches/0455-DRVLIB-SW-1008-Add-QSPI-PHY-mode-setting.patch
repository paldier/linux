From 50d733f45bd392de996dbc18585512e9c1fea3c1 Mon Sep 17 00:00:00 2001
From: Peter Harliman Liem <peter.harliman.liem@intel.com>
Date: Thu, 15 Nov 2018 11:23:32 +0800
Subject: [PATCH] DRVLIB_SW-1008 - Add QSPI PHY mode setting

This is to add QSPI PHY mode per recommendation
from concept team to improve signalling performance.
Setting values are retrieved from verification team
tuning.
---
 drivers/spi/spi-cadence-qspi-apb.c | 25 +++++++++++++++++++++++++
 drivers/spi/spi-cadence-qspi-apb.h | 11 +++++++++++
 2 files changed, 36 insertions(+)

diff --git a/drivers/spi/spi-cadence-qspi-apb.c b/drivers/spi/spi-cadence-qspi-apb.c
index 9bf0801cf02c..a8570e24442f 100644
--- a/drivers/spi/spi-cadence-qspi-apb.c
+++ b/drivers/spi/spi-cadence-qspi-apb.c
@@ -36,6 +36,7 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
+#include <linux/iopoll.h>
 #include <linux/spi/spi.h>
 #include <linux/dma-mapping.h>
 #include <linux/dmaengine.h>
@@ -882,10 +883,33 @@ unsigned int cadence_qspi_apb_is_controller_ready(void *reg_base)
 {
 	return cadence_qspi_wait_idle(reg_base);
 }
+
 void cadence_qspi_apb_controller_init(struct struct_cqspi *cadence_qspi)
 {
+	unsigned int reg;
+	int ret;
+
 	cadence_qspi_apb_controller_disable(cadence_qspi->iobase);
 
+	/* phy mode initialization */
+	CQSPI_WRITEL(0, cadence_qspi->iobase + CQSPI_PHY_CONFIG_REG);
+
+	reg = 0x14 << CQSPI_PHY_MASTER_INITIAL_DELAY_LSB;
+	CQSPI_WRITEL(reg, cadence_qspi->iobase + CQSPI_PHY_MASTER_CONTROL_REG);
+
+	reg = 0x4 << CQSPI_PHY_CONFIG_TX_DLL_DELAY_LSB;
+	reg |= 0x1 << CQSPI_PHY_CONFIG_RESYNC_LSB;
+	reg |= 0x1 << CQSPI_PHY_CONFIG_RESET_LSB;
+	CQSPI_WRITEL(reg, cadence_qspi->iobase + CQSPI_PHY_CONFIG_REG);
+
+	ret = readl_poll_timeout(cadence_qspi->iobase +
+				 CQSPI_DLL_OBSERVABLE_LOWER_REG, reg,
+				 reg & CQSPI_DLL_OBSERVABLE_LOWER_REG,
+				 1, 100);
+	if (ret)
+		dev_warn(&cadence_qspi->pdev->dev,
+			 "timeout waiting for qspi dll lock\n");
+
 	/* Configure the remap address register, no remap */
 	CQSPI_WRITEL(0, cadence_qspi->iobase + CQSPI_REG_REMAP);
 	/* Disable all interrupts. */
@@ -894,6 +918,7 @@ void cadence_qspi_apb_controller_init(struct struct_cqspi *cadence_qspi)
 	cadence_qspi_apb_controller_enable(cadence_qspi->iobase);
 	return;
 }
+
 unsigned int calculate_ticks_for_ns(unsigned int ref_clk_hz,
 	unsigned int ns_val)
 {
diff --git a/drivers/spi/spi-cadence-qspi-apb.h b/drivers/spi/spi-cadence-qspi-apb.h
index 0fef8db97a19..58da46492444 100644
--- a/drivers/spi/spi-cadence-qspi-apb.h
+++ b/drivers/spi/spi-cadence-qspi-apb.h
@@ -156,6 +156,17 @@
 #define	CQSPI_REG_CMDREADDATAUPPER		0xA4
 #define	CQSPI_REG_CMDWRITEDATALOWER		0xA8
 #define	CQSPI_REG_CMDWRITEDATAUPPER		0xAC
+
+/* PHY registers */
+#define CQSPI_PHY_CONFIG_REG                   0xB4
+#define CQSPI_PHY_CONFIG_TX_DLL_DELAY_LSB      16
+#define CQSPI_PHY_CONFIG_RESET_LSB             30
+#define CQSPI_PHY_CONFIG_RESYNC_LSB            31
+#define CQSPI_PHY_MASTER_INITIAL_DELAY_LSB     0
+#define CQSPI_PHY_MASTER_CONTROL_REG           0xB8
+#define CQSPI_DLL_OBSERVABLE_LOWER_REG         0xBC
+#define DLL_OBSERVABLE_LOWER_DLL_LOCK_INC_MASK 0x1
+
 /* Interrupt status bits */
 #define CQSPI_REG_IRQ_MODE_ERR			(1 << 0)
 #define CQSPI_REG_IRQ_UNDERFLOW			(1 << 1)
