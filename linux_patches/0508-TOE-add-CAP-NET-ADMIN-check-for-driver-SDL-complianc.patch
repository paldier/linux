From 66a322319c143173c0b717609944fe18d8bb207c Mon Sep 17 00:00:00 2001
From: Li Yin <yin1.li@intel.com>
Date: Tue, 4 Dec 2018 14:25:00 +0800
Subject: [PATCH] TOE: add CAP_NET_ADMIN check for driver SDL compliance

---
 drivers/net/ethernet/lantiq/ltq_toe_drv.c | 43 +++++++++++++++++--------------
 1 file changed, 24 insertions(+), 19 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/ltq_toe_drv.c b/drivers/net/ethernet/lantiq/ltq_toe_drv.c
index a2b0be273802..dc9b69f25c70 100644
--- a/drivers/net/ethernet/lantiq/ltq_toe_drv.c
+++ b/drivers/net/ethernet/lantiq/ltq_toe_drv.c
@@ -28,6 +28,7 @@
 #include <linux/netdevice.h>
 #include <linux/skbuff.h>
 #include <linux/tcp.h>
+#include <linux/capability.h>
 #include <linux/if_vlan.h>
 #include <linux/ip.h>
 
@@ -184,7 +185,7 @@ spinlock_t tso_register_lock;
 	WARN_ON(old_data != new_data); \
 	wmb(); \
 	ltq_toe_w32(physaddr, PORT_REQ_CMD_REG1(port)); \
-}while(0) 
+}while(0)
 
 #define toe_fill_cmd1(srcbuf, cachewb, port, lenn) do { \
 	  	unsigned int physaddr; \
@@ -207,7 +208,7 @@ spinlock_t tso_register_lock;
 	wmb(); \
    /* printk("REG1 = %X\n", physaddr); */\
 	ltq_toe_w32(physaddr, PORT_REQ_CMD_REG1(port)); \
-}while(0) 
+}while(0)
 
 #define toe_fill_cmd4(buf, port) do { \
 			/* CMD4 */ \
@@ -216,14 +217,14 @@ spinlock_t tso_register_lock;
 			pr_debug("address of the large buffer: = %08x \n", (unsigned int)(physaddr)); \
 /*      printk("REG4 = %X\n", physaddr); */\
 			ltq_toe_w32(physaddr, PORT_REQ_CMD_REG4(port)); \
-}while(0) 
+}while(0)
 
 #define toe_fill_cmd4_sbk(buff, port) do { \
 			/* CMD4 */ \
 			pr_debug("address of the large buffer: = %08x \n", (unsigned int)(buff)); \
   /*    printk("REG4_skb = %X\n", buff); */\
 			ltq_toe_w32(buff, PORT_REQ_CMD_REG4(port)); \
-}while(0) 
+}while(0)
 
 #define toe_fill_cmd2(dw0, port) do { \
 		/* CMD2 */ \
@@ -369,7 +370,7 @@ static void ltq_lro_ovflow_tasklet(unsigned long dev)
 			flag_wr |= 1 << (pos-1);
 		}
 	}
-	
+
 	spin_lock_irqsave(&tso_register_lock, tso_rl_flags);
 	if (flag_wr) {
 		pr_info("ecovfl writing: %x bcos except_flag = %x at pos =%d !\n", (unsigned int)flag_wr, (unsigned int)except_flag, pos);
@@ -465,7 +466,7 @@ static void lro_process_output_context(int port, int oc_flag_no)
 				out_of_sequence = 1;
 			if (except_reason < LRO_MAX_EXCEPTION_COUNT)
 				lro_num_except[except_reason]++;
-			else 
+			else
 				pr_err("spurious exception !!\n");
 			if ((except_reason == 0) && (no_segs == 0))
 				pr_info("flush exception with no_segs = %d for OC..%d\n", no_segs, oc_flag_no);
@@ -531,12 +532,12 @@ static void lro_process_output_context(int port, int oc_flag_no)
 					frag_skb = cbm_build_skb((void *) (frag_addr + offset), real_len, GFP_ATOMIC);
 					if (frag_skb) {
 						skb_put(frag_skb, frag_len);
-						if (last_frag_skb) 
+						if (last_frag_skb)
 							last_frag_skb->next = frag_skb;
 						else
 							skb_shinfo(skb)->frag_list = frag_skb;
 
-						last_frag_skb = frag_skb;	
+						last_frag_skb = frag_skb;
 						skb->len += frag_len;
 						skb->data_len += frag_len;
 						skb->truesize += frag_skb->truesize;
@@ -566,7 +567,7 @@ static void lro_process_output_context(int port, int oc_flag_no)
 
 				/* Send it to datapath library */
 				dp_rx(skb, 0);
-	} 
+	}
 
 	if (out_of_sequence) {
 
@@ -584,7 +585,7 @@ static void lro_process_output_context(int port, int oc_flag_no)
 			temp_len = data_len + 128 + NET_IP_ALIGN + NET_SKB_PAD;
 			real_len = SKB_DATA_ALIGN(temp_len) + SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
 			/*first_len = ltq_toe_r32(lro_sram_membase_res0 + 0xc) & 0x0000FFFF;*/
-			
+
 			if (port == 0xff)
 				pr_debug("buffer pointer of the exception packet: %x and length:%d \n", (unsigned int)data_ptr, data_len);
 			//skb = build_skb((void *) (data_ptr + ((desc3 & 0x3800000) >> 23) - 128 - NET_IP_ALIGN), real_len);
@@ -691,7 +692,7 @@ static void ltq_lro_exception_tasklet(unsigned long dev __maybe_unused)
 
 		temp_len = data_len + 128 + NET_IP_ALIGN + NET_SKB_PAD;
 		real_len = SKB_DATA_ALIGN(temp_len) + SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
-			
+
 		skb = cbm_build_skb((void *) (data_ptr + (offset - 128 - NET_IP_ALIGN - NET_SKB_PAD)), real_len, GFP_ATOMIC);
 
 		/* Get the Descriptor words */
@@ -949,7 +950,7 @@ int lro_stop_flow (int session_id, int timeout, int flags)
 {
 	struct ltq_lro_port *pport;
 
-	/* Lookup the LRO port */ 
+	/* Lookup the LRO port */
 	pport = ltq_lookup_lro_port(session_id & LRO_FID_0_LRO_FID_MASK);
 
 	if (!pport) {
@@ -1655,7 +1656,7 @@ static void ltq_tso_tasklet(unsigned long dev)
 
 		int_stat = ltq_toe_r32(TOE_INT_STAT) & (1 << (port));
 	} while (int_stat && --tso_tx_tasklet_budget);
-	
+
 	/* Unmask the interrupt */
 	spin_lock_irqsave(&tso_register_lock, tso_rl_flags);
 	ltq_toe_w32_mask(0, (1 << port), TOE_INT_EN);
@@ -1725,7 +1726,7 @@ int ltq_tso_xmit (struct sk_buff *skb, struct pmac_tx_hdr *pmac, int hdr_size, i
   	unsigned long toe_last = 0;
   	unsigned char *cmd4_buf;
 
-	pr_debug("%s: called.. with len:%d data:%x on port: %d nr_frags: %d\n", 
+	pr_debug("%s: called.. with len:%d data:%x on port: %d nr_frags: %d\n",
 					__FUNCTION__, skb->len, (unsigned int)skb->data, port, shinfo->nr_frags);
 
 	/* if there is no headroom for PMAC header, try to expand */
@@ -1755,7 +1756,7 @@ int ltq_tso_xmit (struct sk_buff *skb, struct pmac_tx_hdr *pmac, int hdr_size, i
    	 	 cmd4_buf = (unsigned char *)skb;
    	     /* toe_last |= (1 << PORT_REQ_CMD_REG0_0_LAST_POS); */
   	}
-	
+
  	/* Setup 1st command of gather in cmd registers */
  	/* Check that CMD port is available */
  	toe_get_cmd_own(port);
@@ -1767,7 +1768,7 @@ int ltq_tso_xmit (struct sk_buff *skb, struct pmac_tx_hdr *pmac, int hdr_size, i
 
 	if (!(shinfo->nr_frags))
 		toe_fill_cmd4_sbk((u32)skb, port);
-	else 
+	else
  		toe_fill_cmd4(cmd4_buf, port);
 
 	/*udelay(10);*/
@@ -1832,6 +1833,8 @@ EXPORT_SYMBOL(ltq_tso_xmit);
 
 static int toe_reg_read_proc(struct seq_file *s, void *v)
 {
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
 	seq_puts(s, "===============Global Regs ==================\n");
 	seq_printf(s, "ToE base address 0x%08x\n", (unsigned int) ltq_toe_membase);
 	seq_printf(s, "TSO_GCTRL: addr 0x%08x value 0x%08x\t\n", (unsigned int)(ltq_toe_membase + TSO_GCTRL), ltq_toe_r32(TSO_GCTRL));
@@ -1870,6 +1873,8 @@ static int lro_stats_read_proc(struct seq_file *s, void *v)
 {
 	int i,port;
 
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
 	seq_puts(s, "===============LRO Stats==================\n");
 	for (i=0; i<LRO_MAX_EXCEPTION_COUNT; i++)
 		seq_printf(s, "Exceptions %i: %d\t\n", i, (unsigned int) lro_num_except[i]);
@@ -1922,7 +1927,7 @@ static int tso_xmit_mode_read_proc(struct seq_file *s, void *v)
 	seq_printf(s, "TSO xmit IRQ mode: %d\n", g_tso_irq_mode);
 	seq_printf(s, "TSO xmit Polling mode: %d\n", g_tso_polling_mode);
 
-	return 0; 
+	return 0;
 }
 
 static int tso_xmit_mode_seq_open(struct inode *inode, struct file *file)
@@ -1936,7 +1941,7 @@ ssize_t tso_xmit_mode_proc_write(struct file *file, const char *user_buf, size_t
 	char buf[256];
 	int num;
 	char *param_list[2];
-	unsigned char *str; 
+	unsigned char *str;
 
 	if (copy_from_user(buf, user_buf, min(count, (sizeof(buf) - 1))))
 		return -EFAULT;
@@ -2168,7 +2173,7 @@ static int ltq_toe_init(struct platform_device *pdev)
 		cpumask.bits[0] = (1 << i);
 		if (irq_set_affinity(tso_irq, &cpumask))
 			pr_err("can not set affinity for IRQ - %d", tso_irq);
-	
+
 		tasklet_init(&tso_tasklet[i], ltq_tso_tasklet, (unsigned long)&ltq_tso_port[i]);
 		if (g_tso_polling_mode)
 			disable_irq(tso_irq);
