From b5f5aefc3941602b390d8336fe15e060981f7663 Mon Sep 17 00:00:00 2001
From: Gu Chao <gux.chao@intel.com>
Date: Thu, 12 Sep 2019 10:41:58 +0800
Subject: [PATCH] DRV_DPM_SW-39: Unify dpm debug print macros with standard
 linux kernel macros

---
 drivers/net/datapath/dpm/datapath.h                |  36 +-
 drivers/net/datapath/dpm/datapath_api.c            | 132 ++--
 drivers/net/datapath/dpm/datapath_instance.c       |  44 +-
 drivers/net/datapath/dpm/datapath_ioctl.c          |   8 +-
 drivers/net/datapath/dpm/datapath_logical_dev.c    |   8 +-
 drivers/net/datapath/dpm/datapath_misc.c           |  76 +--
 drivers/net/datapath/dpm/datapath_notifier.c       |   2 +-
 drivers/net/datapath/dpm/datapath_proc.c           |  77 ++-
 drivers/net/datapath/dpm/datapath_proc_qos.c       | 192 +++---
 drivers/net/datapath/dpm/datapath_qos.c            |   2 +-
 drivers/net/datapath/dpm/datapath_soc.c            |   2 +-
 drivers/net/datapath/dpm/datapath_swdev.c          |  34 +-
 drivers/net/datapath/dpm/datapath_tx.c             |  22 +-
 drivers/net/datapath/dpm/gswip30/datapath_coc.c    |  39 +-
 drivers/net/datapath/dpm/gswip30/datapath_gswip.c  |  14 +-
 .../datapath/dpm/gswip30/datapath_lookup_proc.c    |  62 +-
 drivers/net/datapath/dpm/gswip30/datapath_mib.c    |  96 ++-
 drivers/net/datapath/dpm/gswip30/datapath_misc.c   |  92 +--
 drivers/net/datapath/dpm/gswip30/datapath_proc.c   |  64 +-
 drivers/net/datapath/dpm/gswip30/datapath_rx.c     |  10 +-
 drivers/net/datapath/dpm/gswip30/datapath_tx.c     |  22 +-
 .../net/datapath/dpm/gswip31/datapath_ext_vlan.c   |  10 +-
 drivers/net/datapath/dpm/gswip31/datapath_gswip.c  | 150 ++---
 .../datapath/dpm/gswip31/datapath_lookup_proc.c    |  50 +-
 drivers/net/datapath/dpm/gswip31/datapath_misc.c   | 182 +++---
 drivers/net/datapath/dpm/gswip31/datapath_ppv4.c   |  32 +-
 .../net/datapath/dpm/gswip31/datapath_ppv4_api.c   | 694 ++++++++++-----------
 drivers/net/datapath/dpm/gswip31/datapath_proc.c   |  22 +-
 drivers/net/datapath/dpm/gswip31/datapath_rx.c     |  10 +-
 .../net/datapath/dpm/gswip31/datapath_switchdev.c  |  30 +-
 drivers/net/datapath/dpm/gswip31/datapath_tx.c     |  22 +-
 .../net/datapath/dpm/gswip32/datapath_ext_vlan.c   |  10 +-
 drivers/net/datapath/dpm/gswip32/datapath_gswip.c  | 178 +++---
 .../datapath/dpm/gswip32/datapath_lookup_proc.c    |  56 +-
 drivers/net/datapath/dpm/gswip32/datapath_misc.c   | 196 +++---
 drivers/net/datapath/dpm/gswip32/datapath_ppv4.c   |  32 +-
 .../net/datapath/dpm/gswip32/datapath_ppv4_api.c   | 690 ++++++++++----------
 .../datapath/dpm/gswip32/datapath_ppv4_session.c   |  74 +--
 drivers/net/datapath/dpm/gswip32/datapath_proc.c   |  22 +-
 drivers/net/datapath/dpm/gswip32/datapath_rx.c     |  12 +-
 .../net/datapath/dpm/gswip32/datapath_switchdev.c  |  30 +-
 drivers/net/datapath/dpm/gswip32/datapath_tx.c     |   2 +-
 42 files changed, 1746 insertions(+), 1792 deletions(-)

diff --git a/drivers/net/datapath/dpm/datapath.h b/drivers/net/datapath/dpm/datapath.h
index 64c1ce0626d5..64b46428901c 100644
--- a/drivers/net/datapath/dpm/datapath.h
+++ b/drivers/net/datapath/dpm/datapath.h
@@ -61,38 +61,6 @@
 #define DP_MAX_SCHED_NUM 2048  /*In fact it should use max number of node*/
 #define DP_MAX_CQM_DEQ 128 /*CQM dequeue port*/
 
-#ifdef LOGF_KLOG_ERROR
-#define PR_ERR  LOGF_KLOG_ERROR
-#define DP_ERR  LOGF_KLOG_ERROR
-
-#else
-#define PR_ERR printk
-#define DP_ERR printk
-#endif
-
-#ifdef LOGF_KLOG_INFO
-#undef PR_INFO
-#define PR_INFO LOGF_KLOG_ERROR
-#define DP_INFO LOGF_KLOG_ERROR
-
-#else
-#undef PR_INFO
-#define DP_INFO printk
-#define PR_INFO printk
-#endif
-
-#ifdef LOGF_KLOG_INFO_ONCE
-#define PR_INFO_ONCE    LOGF_KLOG_INFO_ONCE
-#else
-#define PR_INFO_ONCE printk_once
-#endif
-
-#ifdef LOGF_KLOG_RATELIMITED
-#define PR_RATELIMITED LOGF_KLOG_RATELIMITED
-#else
-#define PR_RATELIMITED printk_ratelimited
-#endif
-
 #define DP_PLATFORM_INIT    1
 #define DP_PLATFORM_DE_INIT 2
 
@@ -110,7 +78,7 @@
 #define dp_get_val(val, mask, offset) (((val) & (mask)) >> (offset))
 
 #define DP_DEBUG_ASSERT(expr, fmt, arg...)  do { if (expr) \
-	PR_ERR(fmt, ##arg); \
+	pr_err(fmt, ##arg); \
 } while (0)
 
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_DBG)
@@ -118,7 +86,7 @@
 	if (unlikely((dp_dbg_flag & (flags)) && \
 		     (((dp_print_num_en) && \
 		      (dp_max_print_num)) || (!dp_print_num_en)))) {\
-	PR_INFO(fmt, ##arg); \
+	pr_info(fmt, ##arg); \
 	if ((dp_print_num_en) && \
 	    (dp_max_print_num)) \
 		dp_max_print_num--; \
diff --git a/drivers/net/datapath/dpm/datapath_api.c b/drivers/net/datapath/dpm/datapath_api.c
index 8009ce73f7d2..f9a2b6822953 100644
--- a/drivers/net/datapath/dpm/datapath_api.c
+++ b/drivers/net/datapath/dpm/datapath_api.c
@@ -184,7 +184,7 @@ int get_dp_port_status_str_size(void)
 int parser_size_via_index(u8 index)
 {
 	if (index >= ARRAY_SIZE(pinfo)) {
-		PR_ERR("Wrong index=%d, it should less than %zu\n", index,
+		pr_err("Wrong index=%d, it should less than %zu\n", index,
 		       ARRAY_SIZE(pinfo));
 		return 0;
 	}
@@ -196,7 +196,7 @@ int parser_enabled(int ep, struct dma_rx_desc_1 *desc_1)
 {
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_EXTRA_DEBUG)
 	if (!desc_1) {
-		PR_ERR("NULL desc_1 is not allowed\n");
+		pr_err("NULL desc_1 is not allowed\n");
 		return 0;
 	}
 #endif
@@ -260,7 +260,7 @@ int8_t parser_size(int8_t v)
 	if (v == DP_PARSER_F_HDR_OFFSETS_ENABLE)
 		return PASAR_OFFSETS_NUM + PASAR_FLAGS_NUM;
 
-	PR_ERR("Wrong parser setting: %d\n", v);
+	pr_err("Wrong parser setting: %d\n", v);
 	/*error */
 	return -1;
 }
@@ -304,7 +304,7 @@ char *parser_str(int index)
 	if (index == 3)
 		return "mpe3";
 
-	PR_ERR("Wrong index:%d\n", index);
+	pr_err("Wrong index:%d\n", index);
 	return "Wrong index";
 }
 
@@ -323,7 +323,7 @@ void dp_parser_info_refresh(u32 cpu, u32 mpe1, u32 mpe2,
 
 	for (i = 0; i < ARRAY_SIZE(pinfo); i++) {
 		if (verify && (pinfo[i].size != parser_size(pinfo[i].v)))
-			PR_ERR("%s[%d](%d) != %s(%d)??\n",
+			pr_err("%s[%d](%d) != %s(%d)??\n",
 			       "Lcal parser pinfo", i, pinfo[i].size,
 			       "register cfg", parser_size(pinfo[i].v));
 
@@ -331,7 +331,7 @@ void dp_parser_info_refresh(u32 cpu, u32 mpe1, u32 mpe2,
 		pinfo[i].size = parser_size(pinfo[i].v);
 
 		if ((pinfo[i].size < 0) || (pinfo[i].size > PKT_PMAC_OFFSET)) {
-			PR_ERR("Wrong parser setting for %s: %d\n",
+			pr_err("Wrong parser setting for %s: %d\n",
 			       parser_str(i), pinfo[i].v);
 		}
 	}
@@ -363,7 +363,7 @@ static int32_t dp_alloc_port_private(int inst,
 	struct pmac_port_info *port;
 
 	if (!owner) {
-		PR_ERR("Allocate port failed for owner NULL\n");
+		pr_err("Allocate port failed for owner NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -391,7 +391,7 @@ static int32_t dp_alloc_port_private(int inst,
 
 	if (flags & DP_F_DEREGISTER) {	/*De-register */
 		if (port->status != PORT_ALLOCATED) {
-			PR_ERR("No Deallocate for module %s w/o deregistered\n",
+			pr_err("No Deallocate for module %s w/o deregistered\n",
 			       owner->name);
 			return DP_FAILURE;
 		}
@@ -407,7 +407,7 @@ static int32_t dp_alloc_port_private(int inst,
 	}
 	if (port_id) { /*with specified port_id */
 		if (port->status != PORT_FREE) {
-			PR_ERR("%s %s(%s %d) fail: port %d used by %s %d\n",
+			pr_err("%s %s(%s %d) fail: port %d used by %s %d\n",
 			       "module", owner->name,
 			       "dev_port", dev_port, port_id,
 			       port->owner->name,
@@ -417,12 +417,12 @@ static int32_t dp_alloc_port_private(int inst,
 	}
 	if (cbm_dp_port_alloc(owner, dev, dev_port, port_id,
 			      &cbm_data, flags)) {
-		PR_ERR("cbm_dp_port_alloc fail for %s/dev_port %d: %d\n",
+		pr_err("cbm_dp_port_alloc fail for %s/dev_port %d: %d\n",
 		       owner->name, dev_port, port_id);
 		return DP_FAILURE;
 	} else if (!(cbm_data.flags & CBM_PORT_DP_SET) &&
 		   !(cbm_data.flags & CBM_PORT_DQ_SET)) {
-		PR_ERR("%s NO DP_SET/DQ_SET(%x):%s/dev_port %d\n",
+		pr_err("%s NO DP_SET/DQ_SET(%x):%s/dev_port %d\n",
 		       "cbm_dp_port_alloc",
 		       cbm_data.flags,
 		       owner->name, dev_port);
@@ -462,7 +462,7 @@ static int32_t dp_alloc_port_private(int inst,
 
 		dma_ch_base = get_dma_chan_idx(inst, cbm_data.num_dma_chan);
 		if (dma_ch_base == DP_FAILURE) {
-			DP_ERR("Failed get_dma_chan_idx!!\n");
+			pr_err("Failed get_dma_chan_idx!!\n");
 			cbm_dp_port_dealloc(owner, dev_port, port_id, &cbm_data,
 					    flags | DP_F_DEREGISTER);
 			/* Only clear those fields we need to clear */
@@ -493,14 +493,14 @@ static int32_t dp_alloc_port_private(int inst,
 				cbm_data.tx_ring_offset;
 	if ((cbm_data.num_dma_chan > 1) && (cbm_data.deq_port_num !=
 	    cbm_data.num_dma_chan)) {
-		PR_ERR("ERROR:deq_port_num=%d not equal to num_dma_chan=%d\n",
+		pr_err("ERROR:deq_port_num=%d not equal to num_dma_chan=%d\n",
 		       cbm_data.deq_port_num, cbm_data.num_dma_chan);
 		return DP_FAILURE;
 	}
 
 	if (dp_port_prop[inst].info.port_platform_set(inst, port_id,
 						      data, flags)) {
-		PR_ERR("Failed port_platform_set for port_id=%d(%s)\n",
+		pr_err("Failed port_platform_set for port_id=%d(%s)\n",
 		       port_id, owner ? owner->name : "");
 		cbm_dp_port_dealloc(owner, dev_port, port_id, &cbm_data,
 				    flags | DP_F_DEREGISTER);
@@ -584,7 +584,7 @@ int32_t dp_register_subif_private(int inst, struct module *owner,
 		end = start + 1;
 	}
 
-	/*PR_INFO("search range: start=%d end=%d\n",start, end);*/
+	/*pr_info("search range: start=%d end=%d\n",start, end);*/
     /*allocate a free subif */
 	for (i = start; i < end; i++) {
 		sif = get_dp_port_subif(port_info, i);
@@ -603,14 +603,14 @@ int32_t dp_register_subif_private(int inst, struct module *owner,
 		if (port_info->status) {
 			if (dp_port_prop[inst].info.subif_platform_set(
 				inst, port_id, i, &platfrm_data, flags)) {
-				PR_ERR("subif_platform_set fail\n");
+				pr_err("subif_platform_set fail\n");
 				goto EXIT;
 			} else {
 				DP_DEBUG(DP_DBG_FLAG_REG,
 					 "subif_platform_set succeed\n");
 			}
 		} else {
-			PR_ERR("port info status fail for 0\n");
+			pr_err("port info status fail for 0\n");
 			return res;
 		}
 		sif->flags = 1;
@@ -653,12 +653,12 @@ int32_t dp_register_subif_private(int inst, struct module *owner,
 				(data ? data->deq_port_idx : 0);
 			if ((cbm_data.deq_port == 0) ||
 			    (cbm_data.deq_port >= DP_MAX_CQM_DEQ)) {
-				PR_ERR("Wrong deq_port: %d\n",
+				pr_err("Wrong deq_port: %d\n",
 				       cbm_data.deq_port);
 				return res;
 			}
 			if (!dp_dma_chan_tbl[inst]) {
-				PR_ERR("dp_dma_chan_tbl[%d] NULL\n", inst);
+				pr_err("dp_dma_chan_tbl[%d] NULL\n", inst);
 				return res;
 			}
 			for (j = 0; j < data->num_deq_port; j++) {
@@ -751,7 +751,7 @@ int32_t dp_deregister_subif_private(int inst, struct module *owner,
 		return res;
 	}
 	if (!dp_dma_chan_tbl[inst]) {
-		PR_ERR("dp_dma_chan_tbl[%d] NULL\n", inst);
+		pr_err("dp_dma_chan_tbl[%d] NULL\n", inst);
 		return res;
 	}
 
@@ -791,7 +791,7 @@ int32_t dp_deregister_subif_private(int inst, struct module *owner,
 	port_info->num_subif--;
 	if (dp_port_prop[inst].info.subif_platform_set(inst, port_id, i,
 						       &platfrm_data, flags)) {
-		PR_ERR("subif_platform_set fail\n");
+		pr_err("subif_platform_set fail\n");
 		/*return res;*/
 	}
 	if (!port_info->num_subif)
@@ -887,12 +887,12 @@ int32_t dp_alloc_port_ext(int inst, struct module *owner,
 		}
 		DP_LIB_UNLOCK(&dp_lock);
 		if (!dp_init_ok) {
-			PR_ERR("dp_alloc_port fail: datapath can't init\n");
+			pr_err("dp_alloc_port fail: datapath can't init\n");
 			return DP_FAILURE;
 		}
 	}
 	if (!dp_port_prop[0].valid) {
-		PR_ERR("No Valid datapath instance yet?\n");
+		pr_err("No Valid datapath instance yet?\n");
 		return DP_FAILURE;
 	}
 	if (!data)
@@ -918,12 +918,12 @@ int32_t dp_alloc_port_ext(int inst, struct module *owner,
 		aca_portid = dp_alloc_port(&aca_owner, &aca_dev,
 					   0, 0, NULL, DP_F_CHECKSUM);
 		if (aca_portid <= 0) {
-			PR_ERR("dp_alloc_port failed for %s\n", ACA_CSUM_NAME);
+			pr_err("dp_alloc_port failed for %s\n", ACA_CSUM_NAME);
 			return res;
 		}
 		if (dp_register_dev(&aca_owner, aca_portid,
 				    NULL, DP_F_CHECKSUM)) {
-			PR_ERR("dp_register_dev fail for %s\n", ACA_CSUM_NAME);
+			pr_err("dp_register_dev fail for %s\n", ACA_CSUM_NAME);
 			return res;
 		}
 		subif_id.port_id = aca_portid;
@@ -931,7 +931,7 @@ int32_t dp_alloc_port_ext(int inst, struct module *owner,
 		if (dp_register_subif(&aca_owner, &aca_dev,
 				      ACA_CSUM_NAME, &subif_id,
 				      DP_F_CHECKSUM)) {
-			PR_ERR("dp_register_subif fail for %s\n",
+			pr_err("dp_register_subif fail for %s\n",
 			       ACA_CSUM_NAME);
 			return res;
 		}
@@ -947,7 +947,7 @@ int32_t dp_register_dev(struct module *owner, uint32_t port_id,
 	int inst = dp_get_inst_via_module(owner, port_id, 0);
 
 	if (inst < 0) {
-		PR_ERR("dp_register_dev not valid module %s\n", owner->name);
+		pr_err("dp_register_dev not valid module %s\n", owner->name);
 		return -1;
 	}
 
@@ -975,7 +975,7 @@ int32_t dp_register_dev_ext(int inst, struct module *owner, uint32_t port_id,
 	struct cbm_dp_alloc_complete_data *cbm_data = NULL;
 
 	if (unlikely(!dp_init_ok)) {
-		PR_ERR("dp_register_dev failed for datapath not init yet\n");
+		pr_err("dp_register_dev failed for datapath not init yet\n");
 		return DP_FAILURE;
 	}
 	if (!data)
@@ -1183,7 +1183,7 @@ int32_t dp_register_subif_ext(int inst, struct module *owner,
 
 	subif_id_sync = kmalloc(sizeof(*subif_id_sync) * 2, GFP_ATOMIC);
 	if (!subif_id_sync) {
-		PR_ERR("Failed to alloc %zu bytes\n",
+		pr_err("Failed to alloc %zu bytes\n",
 		       sizeof(*subif_id_sync) * 2);
 		return DP_FAILURE;
 	}
@@ -1224,7 +1224,7 @@ int32_t dp_register_subif(struct module *owner, struct net_device *dev,
 	}
 	inst = dp_get_inst_via_module(owner, subif_id->port_id, 0);
 	if (inst < 0) {
-		PR_ERR("wrong inst for owner=%s with ep=%d\n", owner->name,
+		pr_err("wrong inst for owner=%s with ep=%d\n", owner->name,
 		       subif_id->port_id);
 		return DP_FAILURE;
 	}
@@ -1249,7 +1249,7 @@ int32_t dp_get_netif_subifid(struct net_device *netif, struct sk_buff *skb,
 	rcu_read_lock_bh();
 	dp_subif = dp_subif_lookup_safe(&dp_subif_list[idx], netif, subif_data);
 	if (!dp_subif) {
-		PR_ERR("Failed dp_subif_lookup: %s\n",
+		pr_err("Failed dp_subif_lookup: %s\n",
 		       netif ? netif->name : "NULL");
 		rcu_read_unlock_bh();
 		return res;
@@ -1270,7 +1270,7 @@ int32_t dp_get_netif_subifid(struct net_device *netif, struct sk_buff *skb,
 		res = subifid_fn_t(netif, skb, subif_data, dst_mac, subif,
 				   flags);
 		if (res != 0)
-			PR_ERR("get_netif_subifid callback function failed\n");
+			pr_err("get_netif_subifid callback function failed\n");
 	} else {
 		res = DP_SUCCESS;
 	}
@@ -1304,14 +1304,14 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 	subifs = kmalloc(sizeof(*subifs) * DP_MAX_CTP_PER_DEV,
 			 GFP_ATOMIC);
 	if (!subifs) {
-		PR_ERR("Failed to alloc %zu bytes\n",
+		pr_err("Failed to alloc %zu bytes\n",
 		       sizeof(*subifs) * DP_MAX_CTP_PER_DEV);
 		return res;
 	}
 	subif_flag = kmalloc(sizeof(*subif_flag) * DP_MAX_CTP_PER_DEV,
 			     GFP_ATOMIC);
 	if (!subif_flag) {
-		PR_ERR("Failed to alloc %zu bytes\n",
+		pr_err("Failed to alloc %zu bytes\n",
 		       sizeof(*subif_flag) * DP_MAX_CTP_PER_DEV);
 		kfree(subifs);
 		return res;
@@ -1363,7 +1363,7 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 				match = 1;
 				port_id = k;
 				if (num > 0) {
-					PR_ERR("Multiple same ctp_dev exist\n");
+					pr_err("Multiple same ctp_dev exist\n");
 					goto EXIT;
 				}
 				subifs[num] = sif->subif;
@@ -1390,7 +1390,7 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 					subif->flag_bp = 1;
 					port_id = k;
 					if (num >= DP_MAX_CTP_PER_DEV) {
-						PR_ERR("%s: Why CTP over %d\n",
+						pr_err("%s: Why CTP over %d\n",
 						       netif ? netif->name : "",
 						       DP_MAX_CTP_PER_DEV);
 						goto EXIT;
@@ -1409,7 +1409,7 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 						subif->flag_pmapper = 1;
 					bport = sif->bp;
 					if (num && (bport != sif->bp)) {
-						PR_ERR("%s:Why many bp:%d %d\n",
+						pr_err("%s:Why many bp:%d %d\n",
 						       netif ? netif->name : "",
 						       sif->bp, bport);
 						goto EXIT;
@@ -1478,7 +1478,7 @@ static int dp_build_cqm_data(int inst, uint32_t port_id,
 
 	if ((data->num_rx_ring > DP_RX_RING_NUM) ||
 	    (data->num_tx_ring > DP_TX_RING_NUM)) {
-		PR_ERR("Error RxRing = %d TxRing = %d\n",
+		pr_err("Error RxRing = %d TxRing = %d\n",
 		       data->num_rx_ring, data->num_tx_ring);
 		return DP_FAILURE;
 	}
@@ -1553,7 +1553,7 @@ static int dp_register_dc(int inst, uint32_t port_id,
 	res->cqm_dq_pid = port->deq_port_base;
 
 	if (!ops) {
-		DP_ERR("No UMT driver registered\n");
+		pr_err("No UMT driver registered\n");
 		return -ENODEV;
 	}
 
@@ -1661,7 +1661,7 @@ int32_t dp_check_if_netif_fastpath_fn(struct net_device *netif,
 
 	DP_LIB_LOCK(&dp_lock);
 	if (unlikely(!dp_init_ok)) {
-		PR_ERR("dp_check_if_netif_fastpath_fn fail: dp not ready\n");
+		pr_err("dp_check_if_netif_fastpath_fn fail: dp not ready\n");
 		return DP_FAILURE;
 	}
 	if (subif) {
@@ -1692,7 +1692,7 @@ struct module *dp_get_module_owner(int ep)
 	int inst = 0; /*here hardcode for PPA only */
 
 	if (unlikely(!dp_init_ok)) {
-		PR_ERR("dp_get_module_owner failed for dp not init yet\n");
+		pr_err("dp_get_module_owner failed for dp not init yet\n");
 		return NULL;
 	}
 
@@ -1880,7 +1880,7 @@ int dp_pmac_set(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 	int (*dp_pmac_set_fn)(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg);
 
 	if (inst >= DP_MAX_INST) {
-		PR_ERR("Wrong inst(%d) id: should less than %d\n",
+		pr_err("Wrong inst(%d) id: should less than %d\n",
 		       inst, DP_MAX_INST);
 		return DP_FAILURE;
 	}
@@ -1909,40 +1909,40 @@ int dp_set_pmapper(struct net_device *dev, struct dp_pmapper *mapper, u32 flag)
 	int res = DP_FAILURE;
 
 	if (!dev || !mapper) {
-		PR_ERR("dev or mapper is NULL\n");
+		pr_err("dev or mapper is NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (unlikely(!dp_init_ok)) {
-		PR_ERR("Failed for datapath not init yet\n");
+		pr_err("Failed for datapath not init yet\n");
 		return DP_FAILURE;
 	}
 	if (mapper->mode >= DP_PMAP_MAX) {
-		PR_ERR("mapper->mode(%d) out of range %d\n",
+		pr_err("mapper->mode(%d) out of range %d\n",
 		       mapper->mode, DP_PMAP_MAX);
 		return DP_FAILURE;
 	}
 	/* get the subif from the dev */
 	ret = dp_get_netif_subifid(dev, NULL, NULL, NULL, &subif, 0);
 	if (ret == DP_FAILURE) {
-		PR_ERR("Fail to get subif:dev=%s ret=%d flag_pmap=%d bp=%d\n",
+		pr_err("Fail to get subif:dev=%s ret=%d flag_pmap=%d bp=%d\n",
 		       dev->name, ret, subif.flag_pmapper, subif.bport);
 		return DP_FAILURE;
 	}
 	inst = subif.inst;
 	if (!dp_port_prop[inst].info.dp_set_gsw_pmapper) {
-		PR_ERR("Set pmapper is not supported\n");
+		pr_err("Set pmapper is not supported\n");
 		return DP_FAILURE;
 	}
 
 	bport = subif.bport;
 	if (bport >= DP_MAX_BP_NUM) {
-		PR_ERR("BP port(%d) out of range %d\n", bport, DP_MAX_BP_NUM);
+		pr_err("BP port(%d) out of range %d\n", bport, DP_MAX_BP_NUM);
 		return DP_FAILURE;
 	}
 	map = kmalloc(sizeof(*map), GFP_ATOMIC);
 	if (!map) {
-		PR_ERR("Failed for kmalloc: %zu bytes\n", sizeof(*map));
+		pr_err("Failed for kmalloc: %zu bytes\n", sizeof(*map));
 		return DP_FAILURE;
 	}
 	memcpy(map, mapper, sizeof(*map));
@@ -1952,7 +1952,7 @@ int dp_set_pmapper(struct net_device *dev, struct dp_pmapper *mapper, u32 flag)
 	} else if (mapper->mode == DP_PMAP_DSCP_ONLY) {
 		map->mode = GSW_PMAPPER_MAPPING_DSCP;
 	} else {
-		PR_ERR("Unknown mapper mode: %d\n", map->mode);
+		pr_err("Unknown mapper mode: %d\n", map->mode);
 		goto EXIT;
 	}
 
@@ -1965,7 +1965,7 @@ int dp_set_pmapper(struct net_device *dev, struct dp_pmapper *mapper, u32 flag)
 							 subif.port_id, map,
 							 flag);
 	if (ret == DP_FAILURE) {
-		PR_ERR("Failed to set mapper\n");
+		pr_err("Failed to set mapper\n");
 		goto EXIT;
 	}
 
@@ -1999,30 +1999,30 @@ int dp_get_pmapper(struct net_device *dev, struct dp_pmapper *mapper, u32 flag)
 	dp_subif_t subif = {0};
 
 	if (!dev || !mapper) {
-		PR_ERR("The parameter dev or mapper can not be NULL\n");
+		pr_err("The parameter dev or mapper can not be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (unlikely(!dp_init_ok)) {
-		PR_ERR("Failed for datapath not init yet\n");
+		pr_err("Failed for datapath not init yet\n");
 		return DP_FAILURE;
 	}
 
 	/*get the subif from the dev*/
 	ret = dp_get_netif_subifid(dev, NULL, NULL, NULL, &subif, 0);
 	if (ret == DP_FAILURE) {
-		PR_ERR("Can not get the subif from the dev\n");
+		pr_err("Can not get the subif from the dev\n");
 		return DP_FAILURE;
 	}
 	inst = subif.inst;
 	if (!dp_port_prop[inst].info.dp_get_gsw_pmapper) {
-		PR_ERR("Get pmapper is not supported\n");
+		pr_err("Get pmapper is not supported\n");
 		return DP_FAILURE;
 	}
 
 	bport = subif.bport;
 	if (bport > DP_MAX_BP_NUM) {
-		PR_ERR("BP port(%d) out of range %d\n", bport, DP_MAX_BP_NUM);
+		pr_err("BP port(%d) out of range %d\n", bport, DP_MAX_BP_NUM);
 		return DP_FAILURE;
 	}
 	/* init the subif into the dp_port_info*/
@@ -2031,7 +2031,7 @@ int dp_get_pmapper(struct net_device *dev, struct dp_pmapper *mapper, u32 flag)
 							 subif.port_id, mapper,
 							 flag);
 	if (ret == DP_FAILURE) {
-		PR_ERR("Failed to get mapper\n");
+		pr_err("Failed to get mapper\n");
 		return DP_FAILURE;
 	}
 	return ret;
@@ -2162,7 +2162,7 @@ int dp_set_min_frame_len(s32 dp_port,
 			 s32 min_frame_len,
 			 uint32_t flags)
 {
-	PR_INFO("Dummy dp_set_min_frame_len, need to implement later\n");
+	pr_info("Dummy dp_set_min_frame_len, need to implement later\n");
 	return DP_SUCCESS;
 }
 EXPORT_SYMBOL(dp_set_min_frame_len);
@@ -2205,7 +2205,7 @@ int dp_vlan_set(struct dp_tc_vlan *vlan, int flags)
 
 	if ((vlan->def_apply == DP_VLAN_APPLY_CTP) &&
 	    (subif.flag_pmapper == 1)) {
-		PR_ERR("cannot apply VLAN rule for pmapper device\n");
+		pr_err("cannot apply VLAN rule for pmapper device\n");
 		return DP_FAILURE;
 	} else if (vlan->def_apply == DP_VLAN_APPLY_CTP) {
 		info.dev_type = 0;
@@ -2370,7 +2370,7 @@ int dp_free_buffer_by_policy(struct dp_buffer_info *info, u32 flag)
 
 	ret = cqm_buffer_free_by_policy(&data);
 	if (ret != CBM_OK) {
-		DP_ERR("cqm_buffer_free_by_policy failed with %d\n", ret);
+		pr_err("cqm_buffer_free_by_policy failed with %d\n", ret);
 		return DP_FAILURE;
 	}
 	return DP_SUCCESS;
@@ -2407,17 +2407,17 @@ int dp_basic_proc(void)
 	register_notifier(0);
 	register_dp_cap(0);
 	if (request_dp(0)) /*register 1st dp instance */ {
-		PR_ERR("register_dp instance fail\n");
+		pr_err("register_dp instance fail\n");
 		return -1;
 	}
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_EXTRA_DEBUG)
-	PR_INFO("preempt_count=%x\n", preempt_count());
+	pr_info("preempt_count=%x\n", preempt_count());
 	if (preempt_count() & HARDIRQ_MASK)
-		PR_INFO("HARDIRQ_MASK\n");
+		pr_info("HARDIRQ_MASK\n");
 	if (preempt_count() & SOFTIRQ_MASK)
-		PR_INFO("SOFTIRQ_MASK\n");
+		pr_info("SOFTIRQ_MASK\n");
 	if (preempt_count() & NMI_MASK)
-		PR_INFO("NMI_MASK\n");
+		pr_info("NMI_MASK\n");
 #endif
 	dp_init_ok = 1;
 
@@ -2466,7 +2466,7 @@ MODULE_LICENSE("GPL");
 
 static int __init dp_dbg_lvl_set(char *str)
 {
-	PR_INFO("\n\ndp_dbg=%s\n\n", str);
+	pr_info("\n\ndp_dbg=%s\n\n", str);
 	dp_dbg_flag = dp_atoi(str);
 
 	return 0;
diff --git a/drivers/net/datapath/dpm/datapath_instance.c b/drivers/net/datapath/dpm/datapath_instance.c
index 037c9c010f8e..d553c7f8de43 100644
--- a/drivers/net/datapath/dpm/datapath_instance.c
+++ b/drivers/net/datapath/dpm/datapath_instance.c
@@ -53,7 +53,7 @@ int register_dp_hw_cap(struct dp_hw_cap *info, u32 flag)
 	int i;
 
 	if (!info) {
-		PR_ERR("register_dp_hw_cap: NULL info\n");
+		pr_err("register_dp_hw_cap: NULL info\n");
 		return -1;
 	}
 	for (i = 0; i < DP_MAX_HW_CAP; i++) {
@@ -63,7 +63,7 @@ int register_dp_hw_cap(struct dp_hw_cap *info, u32 flag)
 		hw_cap_list[i].info = info->info;
 		dp_cap_num++;
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_EXTRA_DEBUG)
-		PR_ERR("Succeed to %s HAL[%d]: type=%d ver=%d dp_cap_num=%d\n",
+		pr_err("Succeed to %s HAL[%d]: type=%d ver=%d dp_cap_num=%d\n",
 		       "Register",
 		       i,
 		       info->info.type,
@@ -72,7 +72,7 @@ int register_dp_hw_cap(struct dp_hw_cap *info, u32 flag)
 #endif
 		return 0;
 	}
-	PR_ERR("Failed to %s HAL: type=%d ver=%d\n",
+	pr_err("Failed to %s HAL: type=%d ver=%d\n",
 	       "Register",
 	       info->info.type,
 	       info->info.ver);
@@ -107,7 +107,7 @@ int dp_request_inst(struct dp_inst_info *info, u32 flag)
 		}
 	}
 	if (k == DP_MAX_HW_CAP) {
-		PR_ERR("dp_request_inst fail to math cap type=%d/ver=%d\n",
+		pr_err("dp_request_inst fail to math cap type=%d/ver=%d\n",
 		       info->type, info->ver);
 		return -1;
 	}
@@ -118,11 +118,11 @@ int dp_request_inst(struct dp_inst_info *info, u32 flag)
 			break;
 	}
 	if (i == DP_MAX_INST) {
-		PR_ERR("dp_request_inst fail for dp inst full arealdy\n");
+		pr_err("dp_request_inst fail for dp inst full arealdy\n");
 		return -1;
 	}
 	if (alloc_dma_chan_tbl(i)) {
-		PR_ERR("FAIL to alloc dma chan tbl\n");
+		pr_err("FAIL to alloc dma chan tbl\n");
 		return -1;
 	}
 	dp_port_prop[i].ops[0] = info->ops[0];
@@ -142,12 +142,12 @@ int dp_request_inst(struct dp_inst_info *info, u32 flag)
 	DP_DEBUG(DP_DBG_FLAG_COC, "DP registered CPUFREQ notifier\n");
 #endif
 	if (alloc_dp_port_subif_info(i)) {
-		PR_ERR("alloc_dp_port_subif_info fail..\n");
+		pr_err("alloc_dp_port_subif_info fail..\n");
 		return DP_FAILURE;
 	}
 	if (dp_port_prop[i].info.dp_platform_set(i, DP_PLATFORM_INIT) < 0) {
 		dp_port_prop[i].valid = 0;
-		PR_ERR("dp_platform_init failed for inst=%d\n", i);
+		pr_err("dp_platform_init failed for inst=%d\n", i);
 		return -1;
 	}
 	info->inst = i;
@@ -219,7 +219,7 @@ static int dp_ndo_setup_tc(struct net_device *dev, u32 handle,
 #endif
 	if (dev->netdev_ops->ndo_setup_tc)
 		return dev->netdev_ops->ndo_setup_tc(dev, handle, protocol, tc);
-	PR_ERR("Cannot support ndo_setup_tc\n");
+	pr_err("Cannot support ndo_setup_tc\n");
 	return -1;
 }
 #else
@@ -249,13 +249,13 @@ int dp_inst_add_dev(struct net_device *dev, char *subif_name, int inst,
 	int err = DP_SUCCESS;
 #endif
 	if (!dev && !subif_name) {
-		PR_ERR("Why dev/subif_name both NULL?\n");
+		pr_err("Why dev/subif_name both NULL?\n");
 		return -1;
 	}
 	idx = dp_dev_hash(dev, subif_name);
 	subif = kmalloc(sizeof(*subif), GFP_KERNEL);
 	if (!subif) {
-		PR_ERR("failed to alloc %zd bytes\n", sizeof(*subif));
+		pr_err("failed to alloc %zd bytes\n", sizeof(*subif));
 		return -1;
 	}
 
@@ -282,7 +282,7 @@ int dp_inst_add_dev(struct net_device *dev, char *subif_name, int inst,
 		}
 	}
 	if (!dp_dev) {
-		PR_ERR("Failed to kmalloc %zd bytes\n", sizeof(*dp_dev));
+		pr_err("Failed to kmalloc %zd bytes\n", sizeof(*dp_dev));
 		kfree(subif);
 		return -1;
 	}
@@ -336,22 +336,22 @@ int dp_inst_del_dev(struct net_device *dev, char *subif_name, int inst, int ep,
 	idx = dp_dev_hash(dev, subif_name);
 	dp_dev = dp_dev_lookup(&dp_dev_list[idx], dev, subif_name, flag);
 	if (!dp_dev) {
-		PR_ERR("Failed to dp_dev_lookup: %s_%s\n",
+		pr_err("Failed to dp_dev_lookup: %s_%s\n",
 		       dev ? dev->name : "NULL", subif_name);
 		return -1;
 	}
 	if (dp_dev->count <= 0) {
-		PR_ERR("Count(%d) should > 0(%s_%s)\n", dp_dev->count,
+		pr_err("Count(%d) should > 0(%s_%s)\n", dp_dev->count,
 		       dev ? dev->name : "NULL", subif_name);
 		return -1;
 	}
 	if (dp_dev->inst != inst) {
-		PR_ERR("Why inst not same:%d_%d(%s_%s)\n", dp_dev->inst, inst,
+		pr_err("Why inst not same:%d_%d(%s_%s)\n", dp_dev->inst, inst,
 		       dev ? dev->name : "NULL", subif_name);
 		return -1;
 	}
 	if (dp_dev->ep != ep) {
-		PR_ERR("Why ep not same:%d_%d(%s_%s)\n", dp_dev->ep, ep,
+		pr_err("Why ep not same:%d_%d(%s_%s)\n", dp_dev->ep, ep,
 		       dev ? dev->name : "NULL", subif_name);
 		return -1;
 	}
@@ -413,7 +413,7 @@ int dp_inst_insert_mod(struct module *owner, u16 ep, u32 inst, u32 flag)
 	u32 idx;
 
 	if (!owner) {
-		PR_ERR("owner NULL?\n");
+		pr_err("owner NULL?\n");
 		return -1;
 	}
 	idx = dp_mod_hash(owner, ep);
@@ -429,7 +429,7 @@ int dp_inst_insert_mod(struct module *owner, u16 ep, u32 inst, u32 flag)
 		}
 	}
 	if (!dp_mod) {
-		PR_ERR("Failed to kmalloc %zd bytes\n", sizeof(*dp_mod));
+		pr_err("Failed to kmalloc %zd bytes\n", sizeof(*dp_mod));
 		return -1;
 	}
 	if (new_f)
@@ -444,13 +444,13 @@ int dp_inst_del_mod(struct module *owner, u16 ep, u32 flag)
 	u32 idx;
 
 	if (!owner) {
-		PR_ERR("owner NULL?\n");
+		pr_err("owner NULL?\n");
 		return -1;
 	}
 	idx = dp_mod_hash(owner, ep);
 	dp_mod = dp_mod_lookup(&dp_mod_list[idx], owner, ep, flag);
 	if (!dp_mod) {
-		PR_ERR("Failed to dp_mod_lookup: %s\n",
+		pr_err("Failed to dp_mod_lookup: %s\n",
 		       owner->name);
 		return -1;
 	}
@@ -467,13 +467,13 @@ int dp_get_inst_via_module(struct module *owner,  u16 ep, u32 flag)
 	u32 idx;
 
 	if (!owner) {
-		PR_ERR("owner NULL?\n");
+		pr_err("owner NULL?\n");
 		return -1;
 	}
 	idx = dp_mod_hash(owner, ep);
 	dp_mod = dp_mod_lookup(&dp_mod_list[idx], owner, ep, flag);
 	if (!dp_mod) {
-		PR_ERR("Failed to dp_mod_lookup: %s\n",
+		pr_err("Failed to dp_mod_lookup: %s\n",
 		       owner->name);
 		return -1;
 	}
diff --git a/drivers/net/datapath/dpm/datapath_ioctl.c b/drivers/net/datapath/dpm/datapath_ioctl.c
index 55a5150ddb2f..3ea7224c20c3 100644
--- a/drivers/net/datapath/dpm/datapath_ioctl.c
+++ b/drivers/net/datapath/dpm/datapath_ioctl.c
@@ -15,7 +15,7 @@ static int get_tsinfo(struct net_device *dev,
 	struct pmac_port_info *port_info;
 
 	if (dp_get_netif_subifid(dev, NULL, NULL, NULL, &subif, 0)) {
-		PR_ERR("%s dp_get_netif_subifid failed for %s\n",
+		pr_err("%s dp_get_netif_subifid failed for %s\n",
 		       __func__, dev->name);
 		return -EFAULT;
 	}
@@ -56,11 +56,11 @@ int dp_ops_set(void **dev_ops, int ops_cb_offset,
 	int i;
 
 	if (!dev_ops) {
-		PR_ERR("dev_ops NULL\n");
+		pr_err("dev_ops NULL\n");
 		return DP_FAILURE;
 	}
 	if (!dp_new_ops) {
-		PR_ERR("dp_new_ops NULL\n");
+		pr_err("dp_new_ops NULL\n");
 		return DP_FAILURE;
 	}
 	if (*dev_ops != dp_new_ops) {
@@ -95,7 +95,7 @@ static int dp_ndo_ptp_ioctl(struct net_device *dev,
 	idx = dp_dev_hash(dev, NULL);
 	dp_dev = dp_dev_lookup(&dp_dev_list[idx], dev, NULL, 0);
 	if (!dp_dev) {
-		PR_ERR("\n dp_dev NULL\n");
+		pr_err("\n dp_dev NULL\n");
 		return -EFAULT;
 	}
 
diff --git a/drivers/net/datapath/dpm/datapath_logical_dev.c b/drivers/net/datapath/dpm/datapath_logical_dev.c
index 90dbaf1c6a6d..b3291d816362 100644
--- a/drivers/net/datapath/dpm/datapath_logical_dev.c
+++ b/drivers/net/datapath/dpm/datapath_logical_dev.c
@@ -46,17 +46,17 @@ int get_vlan_via_dev(struct net_device *dev, struct vlan_prop *vlan_prop)
 	base1 = get_base_dev(dev, 1);
 	vlan = dp_vlan_dev_priv(dev);
 	if (!base1) { /*single vlan */
-		PR_ERR("Not 1st VLAN interface no base\n");
+		pr_err("Not 1st VLAN interface no base\n");
 		return -1;
 	}
 	if (is_vlan_dev(base1)) { /*double or more vlan*/
 		base2 = get_base_dev(base1, 1);
 		if (!base2) {
-			PR_ERR("Not 2nd VLAN interface no base\n");
+			pr_err("Not 2nd VLAN interface no base\n");
 			return -1;
 		}
 		if (is_vlan_dev(base2)) {
-			PR_ERR("Too many VLAN tag, not supoprt\n");
+			pr_err("Too many VLAN tag, not supoprt\n");
 			return -1;
 		}
 		/*double vlan */
@@ -130,7 +130,7 @@ int add_logic_dev(int inst, int port_id, struct net_device *dev,
 	struct dp_subif_info *sif;
 
 	if (!dev) {
-		PR_ERR("dev NULL\n");
+		pr_err("dev NULL\n");
 		return -1;
 	}
 	base_dev = get_base_dev(dev, -1);
diff --git a/drivers/net/datapath/dpm/datapath_misc.c b/drivers/net/datapath/dpm/datapath_misc.c
index 6fecf3351c5e..f7d517d009d0 100644
--- a/drivers/net/datapath/dpm/datapath_misc.c
+++ b/drivers/net/datapath/dpm/datapath_misc.c
@@ -137,12 +137,12 @@ void dump_parser_flag(char *buf)
 	int len;
 
 	if (!buf) {
-		PR_ERR("dump_parser_flag buf NULL\n");
+		pr_err("dump_parser_flag buf NULL\n");
 		return;
 	}
 	p = kmalloc(2000, GFP_KERNEL);
 	if (!p) {
-		PR_ERR("kmalloc NULL\n");
+		pr_err("kmalloc NULL\n");
 		return;
 	}
 
@@ -154,17 +154,17 @@ void dump_parser_flag(char *buf)
 	 * flags: FLAG_L2TPFLAG_NO
 	 * 00 00 00 00 80 18 80 00
 	 */
-	PR_INFO("paser flag at 0x%px: ", buf);
+	pr_info("paser flag at 0x%px: ", buf);
 	len = 0;
 	for (i = 0; i < 8; i++)
 		len += sprintf(p + len, "%02x ", *(pflags - 7 + i));
-	PR_INFO("%s\n", p);
+	pr_info("%s\n", p);
 #if 1
-	PR_INFO("paser flag: ");
+	pr_info("paser flag: ");
 	len = 0;
 	for (i = 0; i < 8; i++)
 		len += sprintf(p + len, "%02x ", *(pflags - i));
-	PR_INFO("%s(reverse)\n", p);
+	pr_info("%s(reverse)\n", p);
 #endif
 
 	for (i = 0; i < PASAR_FLAGS_NUM; i++) {	/*8 flags per byte */
@@ -174,12 +174,12 @@ void dump_parser_flag(char *buf)
 
 			if ((*(pflags - i)) & (1 << j)) {	/*flag is set */
 				if ((i * 8 + j) < PASAR_OFFSETS_NUM)
-					PR_INFO("  Flag %02d offset=%02d: %s\n",
+					pr_info("  Flag %02d offset=%02d: %s\n",
 						i * 8 + j,
 						*(poffset + i * 8 + j),
 						parser_flags_str[i * 8 + j]);
 				else
-					PR_INFO("  Flag %02d %s (No offset)\n",
+					pr_info("  Flag %02d %s (No offset)\n",
 						i * 8 + j,
 						parser_flags_str[i * 8 + j]);
 			}
@@ -198,24 +198,24 @@ void dp_dump_raw_data(char *buf, int len, char *prefix_str)
 	char *s;
 
 	if (!p) {
-		PR_ERR("dp_dump_raw_data: p NULL ?\n");
+		pr_err("dp_dump_raw_data: p NULL ?\n");
 		return;
 	}
 	s = kmalloc(bytes, GFP_KERNEL);
 	if (!s) {
-		PR_ERR("kmalloc failed: %d\n", bytes);
+		pr_err("kmalloc failed: %d\n", bytes);
 		return;
 	}
 	sprintf(s, "%s in hex at 0x%px\n",
 		prefix_str ? (char *)prefix_str : "Data", p);
-	PR_INFO("%s", s);
+	pr_info("%s", s);
 
 	for (i = 0; i < len; i += line_num) {
 		l = sprintf(s, " %06d: ", i);
 		for (j = 0; (j < line_num) && (i + j < len); j++)
 			l += sprintf(s + l, "%02x ", p[i + j]);
 		sprintf(s + l, "\n");
-		PR_INFO("%s", s);
+		pr_info("%s", s);
 	}
 	kfree(s);
 }
@@ -325,21 +325,21 @@ int get_ip_hdr_info(u8 *pdata, int len, struct ip_hdr_info *info)
 		if (dp_dbg_flag & DP_DBG_FLAG_DUMP_TX) {
 			int i;
 
-			PR_INFO("IPV6 packet with next hdr:0x%x\n", next_hdr);
-			PR_INFO(" src IP: ");
+			pr_info("IPV6 packet with next hdr:0x%x\n", next_hdr);
+			pr_info(" src IP: ");
 			for (i = 0; i < 16; i++)
-				PR_INFO("%02x%s", pdata[8 + i],
+				pr_info("%02x%s", pdata[8 + i],
 					(i != 15) ? ":" : " ");
 
-			PR_INFO("\n");
+			pr_info("\n");
 
-			PR_INFO(" Dst IP: ");
+			pr_info(" Dst IP: ");
 
 			for (i = 0; i < 16; i++)
-				PR_INFO("%02x%s", pdata[24 + i],
+				pr_info("%02x%s", pdata[24 + i],
 					(i != 15) ? ":" : " ");
 
-			PR_INFO("\n");
+			pr_info("\n");
 		}
 #endif
 		while (1) {
@@ -737,14 +737,14 @@ struct sk_buff *dp_create_new_skb(struct sk_buff *skb)
 	int i;
 
 	if (unlikely(skb->data_len >= skb->len)) {
-		PR_ERR("why skb->data_len(%d) >= skb->len(%d)\n",
+		pr_err("why skb->data_len(%d) >= skb->len(%d)\n",
 		       skb->data_len, skb->len);
 		dev_kfree_skb_any(skb);
 		return NULL;
 	}
 
 	if (skb_shinfo(skb)->frag_list) {
-		PR_ERR("DP Not support skb_shinfo(skb)->frag_list yet !!\n");
+		pr_err("DP Not support skb_shinfo(skb)->frag_list yet !!\n");
 		dev_kfree_skb_any(skb);
 		return NULL;
 	}
@@ -1088,7 +1088,7 @@ int get_vlan_info(struct net_device *dev, struct vlan_info *vinfo)
 		vinfo->out_proto = vlan->vlan_proto;
 		vinfo->out_vid = vlan->vlan_id;
 	} else {
-		PR_ERR("Not a VLAN device\n");
+		pr_err("Not a VLAN device\n");
 		return -1;
 	}
 #endif
@@ -1142,11 +1142,11 @@ int dp_meter_add(struct net_device *dev, struct dp_meter_cfg *meter,
 	} else if (flag & DP_METER_ATTACH_BRIDGE) {
 		mtr_subif.fid = dp_get_fid_by_brname(dev, &mtr_subif.inst);
 		if (mtr_subif.fid < 0) {
-			PR_ERR("fid less then 0\n");
+			pr_err("fid less then 0\n");
 			return DP_FAILURE;
 		}
 	} else {
-		PR_ERR("Meter Flag not set\n");
+		pr_err("Meter Flag not set\n");
 		return DP_FAILURE;
 	}
 
@@ -1176,11 +1176,11 @@ int dp_meter_del(struct net_device *dev, struct dp_meter_cfg *meter,
 	} else if (flag & DP_METER_ATTACH_BRIDGE) {
 		mtr_subif.fid = dp_get_fid_by_brname(dev, &mtr_subif.inst);
 		if (mtr_subif.fid < 0) {
-			PR_ERR("fid less then 0\n");
+			pr_err("fid less then 0\n");
 			return DP_FAILURE;
 		}
 	} else {
-		PR_ERR("Meter Flag not set\n");
+		pr_err("Meter Flag not set\n");
 		return DP_FAILURE;
 	}
 
@@ -1194,7 +1194,7 @@ EXPORT_SYMBOL(dp_meter_del);
 #if (!IS_ENABLED(CONFIG_INTEL_DATAPATH_SWITCHDEV))
 int dp_get_fid_by_brname(struct net_device *dev, int *inst)
 {
-	PR_ERR("API not support when SWDEV disabled\n");
+	pr_err("API not support when SWDEV disabled\n");
 	return -1;
 }
 #endif
@@ -1253,7 +1253,7 @@ int32_t dp_del_subif(struct net_device *netif, void *data, dp_subif_t *subif,
 	idx = dp_subif_hash(netif);
 	dp_subif = dp_subif_lookup_safe(&dp_subif_list[idx], netif, data);
 	if (!dp_subif) {
-		PR_ERR("Failed dp_subif_lookup: %s\n",
+		pr_err("Failed dp_subif_lookup: %s\n",
 		       netif ? netif->name : "NULL");
 		return -1;
 	}
@@ -1330,7 +1330,7 @@ int32_t dp_sync_subifid(struct net_device *dev, char *subif_name,
 	} else {
 		if (dp_get_netif_subifid_priv(dev, NULL, subif_data,
 					      NULL, &subif_id[0], 0)) {
-			PR_ERR("DP subif synchronization fail\n");
+			pr_err("DP subif synchronization fail\n");
 			return DP_FAILURE;
 		}
 		if (data->ctp_dev) {
@@ -1436,13 +1436,13 @@ int dp_cpufreq_notify_init(int inst)
 	if (cpufreq_register_notifier
 	    (&dp_coc_cpufreq_transition_notifier_block,
 	    CPUFREQ_TRANSITION_NOTIFIER)) {
-		PR_ERR("cpufreq transiiton register_notifier failed?\n");
+		pr_err("cpufreq transiiton register_notifier failed?\n");
 		return -1;
 	}
 	if (cpufreq_register_notifier
 	    (&dp_coc_cpufreq_policy_notifier_block,
 	    CPUFREQ_POLICY_NOTIFIER)) {
-		PR_ERR("cpufreq policy register_notifier failed?\n");
+		pr_err("cpufreq policy register_notifier failed?\n");
 		return -1;
 	}
 	return 0;
@@ -1453,13 +1453,13 @@ int dp_cpufreq_notify_exit(void)
 	if (cpufreq_unregister_notifier
 	    (&dp_coc_cpufreq_transition_notifier_block,
 	    CPUFREQ_TRANSITION_NOTIFIER)) {
-		PR_ERR("cpufreq transition unregister_notifier failed?\n");
+		pr_err("cpufreq transition unregister_notifier failed?\n");
 		return -1;
 	}
 	if (cpufreq_unregister_notifier
 	    (&dp_coc_cpufreq_policy_notifier_block,
 	    CPUFREQ_POLICY_NOTIFIER)) {
-		PR_ERR("cpufreq policy unregister_notifier failed?\n");
+		pr_err("cpufreq policy unregister_notifier failed?\n");
 		return -1;
 	}
 	return 0;
@@ -1479,7 +1479,7 @@ u32 get_dma_chan_idx(int inst, int num_dma_chan)
 	if (!num_dma_chan)
 		return DP_FAILURE;
 	if (!dp_dma_chan_tbl[inst]) {
-		PR_ERR("dp_dma_chan_tbl[%d] NULL !!\n", inst);
+		pr_err("dp_dma_chan_tbl[%d] NULL !!\n", inst);
 		return DP_FAILURE;
 	}
 
@@ -1493,7 +1493,7 @@ u32 get_dma_chan_idx(int inst, int num_dma_chan)
 		if (match == num_dma_chan)
 			return base;
 	}
-	DP_ERR("No free chan available from chan table!!\n");
+	pr_err("No free chan available from chan table!!\n");
 	return DP_FAILURE;
 }
 
@@ -1508,7 +1508,7 @@ u32 alloc_dma_chan_tbl(int inst)
 					DP_MAX_DMA_CHAN), GFP_ATOMIC);
 
 	if (!dp_dma_chan_tbl[inst]) {
-		PR_ERR("Failed for kmalloc: %zu bytes\n",
+		pr_err("Failed for kmalloc: %zu bytes\n",
 		       (sizeof(struct dma_chan_info) * DP_MAX_DMA_CHAN));
 		return DP_FAILURE;
 	}
@@ -1538,7 +1538,7 @@ u32 alloc_dp_port_subif_info(int inst)
 	dp_port_info[inst] = kzalloc((sizeof(struct pmac_port_info) *
 				     max_dp_ports), GFP_KERNEL);
 	if (!dp_port_info[inst]) {
-		PR_ERR("Failed for kmalloc: %zu bytes\n",
+		pr_err("Failed for kmalloc: %zu bytes\n",
 		       (sizeof(struct pmac_port_info) * max_dp_ports));
 		return DP_FAILURE;
 	}
@@ -1547,7 +1547,7 @@ u32 alloc_dp_port_subif_info(int inst)
 			kzalloc(sizeof(struct dp_subif_info) * max_subif,
 				GFP_KERNEL);
 		if (!get_dp_port_info(inst, port_id)->subif_info) {
-			PR_ERR("Failed for kmalloc: %zu bytes\n",
+			pr_err("Failed for kmalloc: %zu bytes\n",
 			       max_subif * sizeof(struct dp_subif_info));
 			while (--port_id >= 0)
 				kfree(get_dp_port_info(inst,
diff --git a/drivers/net/datapath/dpm/datapath_notifier.c b/drivers/net/datapath/dpm/datapath_notifier.c
index 659c6b83c384..fe12453d2993 100644
--- a/drivers/net/datapath/dpm/datapath_notifier.c
+++ b/drivers/net/datapath/dpm/datapath_notifier.c
@@ -135,7 +135,7 @@ int dp_event(struct notifier_block *this, unsigned long event, void *ptr)
 				if (fid > 0) {
 					dp_dev->fid = fid;
 				} else {
-					PR_ERR("FID alloc failed in %s\r\n",
+					pr_err("FID alloc failed in %s\r\n",
 					       __func__);
 					return 0;
 				}
diff --git a/drivers/net/datapath/dpm/datapath_proc.c b/drivers/net/datapath/dpm/datapath_proc.c
index 59ca068120d1..346b931c83ff 100644
--- a/drivers/net/datapath/dpm/datapath_proc.c
+++ b/drivers/net/datapath/dpm/datapath_proc.c
@@ -134,7 +134,7 @@ int proc_port_dump(struct seq_file *s, int pos)
 	if (!capable(CAP_SYS_PACCT))
 		return -1;
 	if (!port) {
-		PR_ERR("Why port is NULL\n");
+		pr_err("Why port is NULL\n");
 		return -1;
 	}
 	info = &dp_port_prop[tmp_inst].info;
@@ -316,19 +316,19 @@ int display_port_info(int inst, u8 pos, int start_vap, int end_vap, u32 flag)
 	u16 start = 0;
 
 	if (!port) {
-		PR_ERR("Why port is NULL\n");
+		pr_err("Why port is NULL\n");
 		return -1;
 	}
 
 	if (port->status == PORT_FREE) {
 		if (pos == 0) {
-			PR_INFO("%s:rx_err_drop=0x%08x  tx_err_drop=0x%08x\n",
+			pr_info("%s:rx_err_drop=0x%08x  tx_err_drop=0x%08x\n",
 				"Reserved Port",
 				STATS_GET(port->rx_err_drop),
 				STATS_GET(port->tx_err_drop));
 
 		} else
-			PR_INFO("%02d:rx_err_drop=0x%08x  tx_err_drop=0x%08x\n",
+			pr_info("%02d:rx_err_drop=0x%08x  tx_err_drop=0x%08x\n",
 				pos,
 				STATS_GET(port->rx_err_drop),
 				STATS_GET(port->tx_err_drop));
@@ -338,7 +338,7 @@ int display_port_info(int inst, u8 pos, int start_vap, int end_vap, u32 flag)
 
 	DP_CB(tmp_inst, get_itf_start_end)(port->itf_info, &start, NULL);
 
-	PR_INFO("%02d: %s=0x0x%0lx(name:%8s) %s=%02d %s=%02d itf_base=%d(%s)\n",
+	pr_info("%02d: %s=0x0x%0lx(name:%8s) %s=%02d %s=%02d itf_base=%d(%s)\n",
 		pos,
 		"module",
 		(uintptr_t)port->owner, port->owner->name,
@@ -348,27 +348,27 @@ int display_port_info(int inst, u8 pos, int start_vap, int end_vap, u32 flag)
 		port->port_id,
 		start,
 		port->itf_info ? "Enabled" : "Not Enabled");
-	PR_INFO("    status:            %s\n",
+	pr_info("    status:            %s\n",
 		dp_port_status_str[port->status]);
-	PR_INFO("    allocate_flags:    ");
+	pr_info("    allocate_flags:    ");
 
 	for (i = 0; i < get_dp_port_type_str_size(); i++) {
 		if (port->alloc_flags & dp_port_flag[i])
-			PR_INFO("%s ", dp_port_type_str[i]);
+			pr_info("%s ", dp_port_type_str[i]);
 	}
 
-	PR_INFO("\n");
+	pr_info("\n");
 
 	if (!flag) {
-		PR_INFO("    cb->rx_fn:         0x%0lx\n",
+		pr_info("    cb->rx_fn:         0x%0lx\n",
 			(uintptr_t)port->cb.rx_fn);
-		PR_INFO("    cb->restart_fn:    0x%0lx\n",
+		pr_info("    cb->restart_fn:    0x%0lx\n",
 			(uintptr_t)port->cb.restart_fn);
-		PR_INFO("    cb->stop_fn:       0x%0lx\n",
+		pr_info("    cb->stop_fn:       0x%0lx\n",
 			(uintptr_t)port->cb.stop_fn);
-		PR_INFO("    cb->get_subifid_fn:0x%0lx\n",
+		pr_info("    cb->get_subifid_fn:0x%0lx\n",
 			(uintptr_t)port->cb.get_subifid_fn);
-		PR_INFO("    num_subif:         %02d\n", port->num_subif);
+		pr_info("    num_subif:         %02d\n", port->num_subif);
 	}
 
 	for (i = start_vap; i < end_vap; i++) {
@@ -376,37 +376,32 @@ int display_port_info(int inst, u8 pos, int start_vap, int end_vap, u32 flag)
 		struct dev_mib *mib = get_dp_port_subif_mib(sif);
 
 		if (sif->flags) {
-			PR_INFO
-			    ("      [%02d]:%s=0x%04x %s=0x%0lx(%s=%s),%s=%s\n",
-			     i,
-			     "subif",
-			     sif->subif,
-			     "netif",
-			     (uintptr_t)sif->netif,
-			     "device_name",
-			     sif->netif ? sif->netif->name : "NULL/DSL",
-			     "name",
-			     sif->device_name);
-			PR_INFO("          : rx_fn_rxif_pkt =0x%08x\n",
+			pr_info("      [%02d]:%s=0x%04x %s=0x%0lx(%s=%s),%s=%s\n",
+				i, "subif", sif->subif,
+				"netif", (uintptr_t)sif->netif,
+				"device_name",
+				sif->netif ? sif->netif->name : "NULL/DSL",
+				"name", sif->device_name);
+			pr_info("          : rx_fn_rxif_pkt =0x%08x\n",
 				STATS_GET(mib->rx_fn_rxif_pkt));
-			PR_INFO("          : rx_fn_txif_pkt =0x%08x\n",
+			pr_info("          : rx_fn_txif_pkt =0x%08x\n",
 				STATS_GET(mib->rx_fn_txif_pkt));
-			PR_INFO("          : rx_fn_dropped  =0x%08x\n",
+			pr_info("          : rx_fn_dropped  =0x%08x\n",
 				STATS_GET(mib->rx_fn_dropped));
-			PR_INFO("          : tx_cbm_pkt     =0x%08x\n",
+			pr_info("          : tx_cbm_pkt     =0x%08x\n",
 				STATS_GET(mib->tx_cbm_pkt));
-			PR_INFO("          : tx_tso_pkt     =0x%08x\n",
+			pr_info("          : tx_tso_pkt     =0x%08x\n",
 				STATS_GET(mib->tx_tso_pkt));
-			PR_INFO("          : tx_pkt_dropped =0x%08x\n",
+			pr_info("          : tx_pkt_dropped =0x%08x\n",
 				STATS_GET(mib->tx_pkt_dropped));
-			PR_INFO("          : tx_clone_pkt   =0x%08x\n",
+			pr_info("          : tx_clone_pkt   =0x%08x\n",
 				STATS_GET(mib->tx_clone_pkt));
-			PR_INFO("          : tx_hdr_room_pkt=0x%08x\n",
+			pr_info("          : tx_hdr_room_pkt=0x%08x\n",
 				STATS_GET(mib->tx_hdr_room_pkt));
 		}
 	}
 
-	ret = PR_INFO("    rx_err_drop=0x%08x  tx_err_drop=0x%08x\n",
+	ret = pr_info("    rx_err_drop=0x%08x  tx_err_drop=0x%08x\n",
 		      STATS_GET(port->rx_err_drop),
 		      STATS_GET(port->tx_err_drop));
 EXIT:
@@ -448,12 +443,12 @@ ssize_t proc_port_write(struct file *file, const char *buf, size_t count,
 	}
 
 	if (index_start >= MAX_DP_PORTS) {
-		PR_ERR("wrong index: 0 ~ 15\n");
+		pr_err("wrong index: 0 ~ 15\n");
 		return count;
 	}
 
 	if (vap_start >= info->cap.max_num_subif_per_port) {
-		PR_ERR("wrong VAP: 0 ~ 15\n");
+		pr_err("wrong VAP: 0 ~ 15\n");
 		return count;
 	}
 
@@ -473,9 +468,9 @@ ssize_t proc_port_write(struct file *file, const char *buf, size_t count,
 
 	return count;
  help:
-	PR_INFO("usage:\n");
-	PR_INFO("  echo mib  [ep][vap] > /prooc/dp/port\n");
-	PR_INFO("  echo port [ep][vap] > /prooc/dp/port\n");
+	pr_info("usage:\n");
+	pr_info("  echo mib  [ep][vap] > /prooc/dp/port\n");
+	pr_info("  echo port [ep][vap] > /prooc/dp/port\n");
 	return count;
 }
 
@@ -569,7 +564,7 @@ ssize_t proc_dbg_write(struct file *file, const char *buf, size_t count,
 			" > /proc/dp/dbg\n");
 	num += snprintf(tmp_buf + num, BUF_SIZE_TMP - num - 1,
 			" display command: cat /proc/dp/cmd\n");
-	PR_INFO("%s", tmp_buf);
+	pr_info("%s", tmp_buf);
 	kfree(tmp_buf);
 	return count;
 }
@@ -605,7 +600,7 @@ struct dentry *dp_proc_install(void)
 			dp_proc_entry_create(dp_proc_node,
 					     &dp_proc_entries[i]);
 	} else {
-		PR_ERR("datapath cannot create proc entry");
+		pr_err("datapath cannot create proc entry");
 		return NULL;
 	}
 
diff --git a/drivers/net/datapath/dpm/datapath_proc_qos.c b/drivers/net/datapath/dpm/datapath_proc_qos.c
index dd7542d43170..e2bb0a6c6f56 100644
--- a/drivers/net/datapath/dpm/datapath_proc_qos.c
+++ b/drivers/net/datapath/dpm/datapath_proc_qos.c
@@ -123,7 +123,7 @@ void set_child_per_box(struct q_print_info *q_info)
 			idx = p_box->n_q + p_box->n_sch;
 
 			if (idx >= PROC_DP_MAX_CHILD_PER_SCH_PORT) {
-				PR_ERR("too many child: should <%d\n",
+				pr_err("too many child: should <%d\n",
 				       PROC_DP_MAX_CHILD_PER_SCH_PORT);
 				return;
 			}
@@ -139,12 +139,12 @@ void set_child_per_box(struct q_print_info *q_info)
 		idx = p_box->n_q + p_box->n_sch;
 
 		if (idx >= PROC_DP_MAX_CHILD_PER_SCH_PORT) {
-			PR_ERR("too many child: should <%d\n",
+			pr_err("too many child: should <%d\n",
 			       PROC_DP_MAX_CHILD_PER_SCH_PORT);
 			return;
 		}
 		if (idx < 0) {
-			PR_ERR("wrong: idx(%d) should >= 0\n", idx);
+			pr_err("wrong: idx(%d) should >= 0\n", idx);
 			return;
 		}
 		p_box->child[idx].filled = 1;
@@ -162,14 +162,14 @@ void set_child_per_box(struct q_print_info *q_info)
 			c_box = q_info->sch_box[i][j];
 			idx = p_box->n_q + p_box->n_sch;
 			if (idx < 0) {
-				PR_ERR("wrong: idx(%d) should >= 0\n", idx);
+				pr_err("wrong: idx(%d) should >= 0\n", idx);
 				return;
 			}
 			c_box->p_box = p_box;
 			if (find_child_box(p_box->child, c_box))
 				continue;
 			if (idx >= PROC_DP_MAX_CHILD_PER_SCH_PORT - 1) {
-				PR_ERR("too many child: should <%d\n",
+				pr_err("too many child: should <%d\n",
 				       PROC_DP_MAX_CHILD_PER_SCH_PORT);
 				return;
 			}
@@ -232,7 +232,7 @@ int check_location(struct q_print_info *q_info)
 
 	for (i = 0; i < q_info->box_num; i++) {
 		if ((q_info->box[i].l.x2 - q_info->box[i].l.x1) != BOX_WIDTH) {
-			PR_ERR("sched[%d] x1/x2: %d - %d should equal%d\n",
+			pr_err("sched[%d] x1/x2: %d - %d should equal%d\n",
 			       q_info->box[i].node,
 			       q_info->box[i].l.x2,
 			       q_info->box[i].l.x1,
@@ -243,7 +243,7 @@ int check_location(struct q_print_info *q_info)
 			continue;
 		if ((q_info->box[i].p_box->l.x1 - q_info->box[i].l.x2) !=
 			PADDING_BETWEEN_BOX_X) {
-			PR_ERR("sched[%d]<->sched[%d]: %d - %d %s%d\n",
+			pr_err("sched[%d]<->sched[%d]: %d - %d %s%d\n",
 			       q_info->box[i].node,
 			       q_info->box[i].p_box->node,
 			       q_info->box[i].p_box->l.x2,
@@ -504,7 +504,7 @@ void print_all(struct seq_file *s, struct q_print_info *q_info)
 
 	buf = kmalloc(cols * rows + 1, GFP_KERNEL);
 	if (!buf) {
-		PR_ERR("fail to alloc %d bytes\n", cols * rows + 1);
+		pr_err("fail to alloc %d bytes\n", cols * rows + 1);
 		return;
 	}
 	memset(buf, ' ', cols * rows);
@@ -557,7 +557,7 @@ struct q_print_info *collect_info(struct seq_file *s,
 	size = sizeof(*q_info) + 1;
 	q_info = kmalloc(size, GFP_KERNEL);
 	if (!q_info) {
-		PR_ERR("fail to alloc %d bytes\n", size);
+		pr_err("fail to alloc %d bytes\n", size);
 		return NULL;
 	}
 	memset(q_info, 0, size);
@@ -574,7 +574,7 @@ struct q_print_info *collect_info(struct seq_file *s,
 		if (res->q_res[i].sch_lvl <= 0)
 			continue;
 		if (res->q_res[i].sch_lvl > PROC_MAX_BOX_LVL - 1) {
-			PR_ERR("Too many sched lvl(%d): expect<=%d\n",
+			pr_err("Too many sched lvl(%d): expect<=%d\n",
 			       res->q_res[i].sch_lvl,
 			       PROC_MAX_BOX_LVL - 1);
 				goto ERR_EXIT;
@@ -601,7 +601,7 @@ struct q_print_info *collect_info(struct seq_file *s,
 			q_info->sch_box[i][j] = &q_info->box[q_info->box_num];
 			q_info->box_num++;
 			if (q_info->box_num == ARRAY_SIZE(q_info->box)) {
-				PR_ERR("sched+port (%d) in one node: %s<%zd\n",
+				pr_err("sched+port (%d) in one node: %s<%zd\n",
 				       q_info->box_num,
 				       "expect",
 				       ARRAY_SIZE(q_info->box));
@@ -621,17 +621,17 @@ struct q_print_info *collect_info(struct seq_file *s,
 			continue;
 		for (j = 0; j < q_info->sch_lvl[i]; j++) {
 			if (!q_info->sch_box[i][j]->filled) {
-				PR_ERR("sch_box[%d][%d].fill should 1:%d\n",
+				pr_err("sch_box[%d][%d].fill should 1:%d\n",
 				       i, j, q_info->sch_box[i][j]->filled);
 				goto ERR_EXIT;
 			}
 			if (q_info->sch_box[i][j]->n_q < 0) {
-				PR_ERR("sch_box[%d][%d].n_q should >=0:%d\n",
+				pr_err("sch_box[%d][%d].n_q should >=0:%d\n",
 				       i, j, q_info->sch_box[i][j]->n_q);
 				goto ERR_EXIT;
 			}
 			if (q_info->sch_box[i][j]->n_sch < 0) {
-				PR_ERR("sch_box[%d][%d].n_sch should >=0:%d\n",
+				pr_err("sch_box[%d][%d].n_sch should >=0:%d\n",
 				       i, j, q_info->sch_box[i][j]->n_sch);
 				goto ERR_EXIT;
 			}
@@ -831,7 +831,7 @@ int get_res(int inst, int dp_port, int tconf_idx)
 		 "get_res: dp_port=%d tconf_idx=%d\n",
 		 tmp_res.dp_port, tmp_res.cqm_deq_idx);
 	if (dp_deq_port_res_get(&tmp_res, 0)) {
-		PR_ERR("dp_deq_port_res_get fail: inst=%d dp_port=%d, %s=%d\n",
+		pr_err("dp_deq_port_res_get fail: inst=%d dp_port=%d, %s=%d\n",
 		       qos_layout_inst, tmp_res.dp_port,
 		       "tconf_idx", curr_tconf_idx);
 		return -1;
@@ -926,33 +926,33 @@ int qos_dump_start(void)
 
 void qos_create_qos_help(void)
 {
-	PR_INFO("QOS Command Help:\n\n");
-	PR_INFO("     Add Queue: echo add_q <qid> <schid>:<leaf> %s%s\n\n",
+	pr_info("QOS Command Help:\n\n");
+	pr_info("     Add Queue: echo add_q <qid> <schid>:<leaf> %s%s\n\n",
 		"<schid>:<leaf> <schid>:<leaf> <schid>:<leaf> <portid> ",
 		"> /sys/kernel/debug/dp/qos");
-	PR_INFO("            id: qid/schid_node/cbm_port\n");
-	PR_INFO("  Delete Queue: echo del_q qid > /sys/kernel/debug/dp/qos\n");
-	PR_INFO("  Delete Sched: echo del_sch schid > %s\n",
+	pr_info("            id: qid/schid_node/cbm_port\n");
+	pr_info("  Delete Queue: echo del_q qid > /sys/kernel/debug/dp/qos\n");
+	pr_info("  Delete Sched: echo del_sch schid > %s\n",
 		"/sys/kernel/debug/dp/qos");
-	PR_INFO("  SET PRIO: echo prio <id> <type> <arbi> <prio_wfq> %s\n",
+	pr_info("  SET PRIO: echo prio <id> <type> <arbi> <prio_wfq> %s\n",
 		"> /sys/kernel/debug/dp/qos");
-	PR_INFO("            id: phy_queue/sched_node\n");
-	PR_INFO("          type: queue/sched\n");
-	PR_INFO("          arbi: null/sp/wsp/wrr/wrr_wsp/wfq\n");
-	PR_INFO("    CFG SHAPER: echo shaper <cmd> <id> <type> %s\n",
+	pr_info("            id: phy_queue/sched_node\n");
+	pr_info("          type: queue/sched\n");
+	pr_info("          arbi: null/sp/wsp/wrr/wrr_wsp/wfq\n");
+	pr_info("    CFG SHAPER: echo shaper <cmd> <id> <type> %s\n",
 		"<cir> <pir> <cbs> <pbs> > /sys/kernel/debug/dp/qos");
-	PR_INFO("           cmd: add/remove/disable\n");
-	PR_INFO("            id: qid/sched_node/cbm_port\n");
-	PR_INFO("          type: queue/sched/port\n");
-	PR_INFO("           cir: no_limit/max/value\n");
-	PR_INFO("      SET NODE: echo set_node <id> <type> <cmd>... %s\n",
+	pr_info("           cmd: add/remove/disable\n");
+	pr_info("            id: qid/sched_node/cbm_port\n");
+	pr_info("          type: queue/sched/port\n");
+	pr_info("           cir: no_limit/max/value\n");
+	pr_info("      SET NODE: echo set_node <id> <type> <cmd>... %s\n",
 		"> /sys/kernel/debug/dp/qos");
-	PR_INFO("            id: phy_queue/sched_node/cbm_port\n");
-	PR_INFO("          type: queue/sched/port\n");
-	PR_INFO("           cmd: enable(unblock)/disable(block)/%s\n",
+	pr_info("            id: phy_queue/sched_node/cbm_port\n");
+	pr_info("          type: queue/sched/port\n");
+	pr_info("           cmd: enable(unblock)/disable(block)/%s\n",
 		"resume/suspend");
-	PR_INFO("                enable/disable: only for queue/port\n");
-	PR_INFO("                resume/suspend: for all nodes\n");
+	pr_info("                enable/disable: only for queue/port\n");
+	pr_info("                resume/suspend: for all nodes\n");
 }
 
 ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
@@ -984,7 +984,7 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 		struct dp_qos_link cfg = {0};
 
 		if (num < 3) {
-			PR_INFO("Wrong Parameter(try help):echo help > %s\n",
+			pr_info("Wrong Parameter(try help):echo help > %s\n",
 				"/sys/kernel/debug/dp/qos");
 			return count;
 		}
@@ -999,7 +999,7 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 		cfg.n_sch_lvl = level;
 
 		if (!level)
-			PR_INFO("QID %d->", cfg.q_id);
+			pr_info("QID %d->", cfg.q_id);
 
 		for (i = 0; (i < (num - 3) && i < DP_MAX_SCH_LVL); i++) {
 			dp_replace_ch(param_list[i + idx],
@@ -1011,13 +1011,13 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 			cfg.sch[i].arbi = 1;
 			cfg.sch[i].prio_wfq = 0;
 
-			PR_INFO("SCH %d:LEAF %d->", cfg.sch[i].id,
+			pr_info("SCH %d:LEAF %d->", cfg.sch[i].id,
 				cfg.sch[i].leaf);
 		}
 
-		PR_INFO("PORT %d\n", cfg.cqm_deq_port);
+		pr_info("PORT %d\n", cfg.cqm_deq_port);
 		if (dp_link_add(&cfg, 0)) {
-			PR_ERR("dp_link_add failed\n");
+			pr_err("dp_link_add failed\n");
 			return count;
 		}
 	} else if (dp_strncmpi(param_list[0], "del_q", strlen("del_q")) == 0) {
@@ -1027,7 +1027,7 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 		node.type = DP_NODE_QUEUE;
 
 		if (dp_node_free(&node, DP_NODE_SMART_FREE)) {
-			PR_ERR("dp_node_free failed\n");
+			pr_err("dp_node_free failed\n");
 			return count;
 		}
 	} else if (dp_strncmpi(param_list[0], "del_p", strlen("del_p")) == 0) {
@@ -1041,7 +1041,7 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 			node.type = DP_NODE_PORT;
 			node.id.cqm_deq_port = dp_atoi(param_list[1]);
 		} else {
-			PR_ERR("unknown type %s\n", param_list[2]);
+			pr_err("unknown type %s\n", param_list[2]);
 		}
 	} else if (dp_strncmpi(param_list[0], "del_sch",
 			       strlen("del_sch")) == 0) {
@@ -1054,10 +1054,10 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 		node.type = DP_NODE_SCH;
 
 		if (dp_node_link_get(&node_link, 0))
-			PR_ERR("dp_node_link_get failed\n");
+			pr_err("dp_node_link_get failed\n");
 
 		if (dp_node_free(&node, 0)) {
-			PR_ERR("dp_node_free failed\n");
+			pr_err("dp_node_free failed\n");
 			return count;
 		}
 
@@ -1070,20 +1070,20 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 			res = dp_node_link_get(&node_link, 0);
 
 			if (dp_node_free(&node, 0))
-				PR_ERR("dp_node_free failed\n");
+				pr_err("dp_node_free failed\n");
 
 			if (res) {
-				PR_ERR("dp_node_link_get failed\n");
+				pr_err("dp_node_link_get failed\n");
 				break;
 			}
 		}
 
-		PR_INFO("\nSched %d deleted\n\n", node_link.node_id.sch_id);
+		pr_info("\nSched %d deleted\n\n", node_link.node_id.sch_id);
 	} else if (dp_strncmpi(param_list[0], "prio", strlen("prio")) == 0) {
 		struct dp_node_prio node_prio = {0};
 
 		if (num < 3) {
-			PR_ERR("id, type are required!%s%s\n",
+			pr_err("id, type are required!%s%s\n",
 			       "\n(try help):echo help > ",
 			       "/sys/kernel/debug/dp/qos");
 			return count;
@@ -1101,11 +1101,11 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 			node_prio.type = DP_NODE_PORT;
 			node_prio.id.cqm_deq_port = dp_atoi(param_list[1]);
 		} else {
-			PR_ERR("unknown type %s\n", param_list[2]);
+			pr_err("unknown type %s\n", param_list[2]);
 		}
 
 		if (dp_qos_link_prio_get(&node_prio, 0))
-			PR_ERR("dp_qos_link_prio_get failed\n");
+			pr_err("dp_qos_link_prio_get failed\n");
 
 		if (dp_strncmpi(param_list[3], "null", strlen("null")) == 0) {
 			node_prio.arbi = ARBITRATION_NULL;
@@ -1125,7 +1125,7 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 			   strlen("wfq")) == 0) {
 			node_prio.arbi = ARBITRATION_WFQ;
 		} else {
-			PR_ERR("unknown type %s\n", param_list[3]);
+			pr_err("unknown type %s\n", param_list[3]);
 			return count;
 		}
 
@@ -1133,7 +1133,7 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 			node_prio.prio_wfq = dp_atoi(param_list[4]);
 
 		if (dp_qos_link_prio_set(&node_prio, 0)) {
-			PR_ERR("dp_qos_link_prio_set failed\n");
+			pr_err("dp_qos_link_prio_set failed\n");
 			return count;
 		}
 	} else if (dp_strncmpi(param_list[0], "shaper",
@@ -1141,7 +1141,7 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 		struct dp_shaper_conf shaper_cfg = {0};
 
 		if (num < 4) {
-			PR_ERR("cmd, id, type are required!%s%s\n",
+			pr_err("cmd, id, type are required!%s%s\n",
 			       "\n(try help):echo help > ",
 			       "/sys/kernel/debug/dp/qos");
 			return count;
@@ -1156,7 +1156,7 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 				     strlen("disable")) == 0)
 			shaper_cfg.cmd = DP_SHAPER_CMD_DISABLE;
 		else
-			PR_ERR("unknown cmd try: echo help %s",
+			pr_err("unknown cmd try: echo help %s",
 			       "> /sys/kernel/debug/dp/qos");
 
 		if (dp_strncmpi(param_list[3], "queue", strlen("queue")) == 0) {
@@ -1171,12 +1171,12 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 			shaper_cfg.type = DP_NODE_PORT;
 			shaper_cfg.id.sch_id = dp_atoi(param_list[2]);
 		} else {
-			PR_ERR("unknown type %s\n", param_list[3]);
+			pr_err("unknown type %s\n", param_list[3]);
 			return count;
 		}
 
 		if (dp_shaper_conf_get(&shaper_cfg, 0))
-			PR_ERR("dp_shaper_conf_get failed\n");
+			pr_err("dp_shaper_conf_get failed\n");
 
 		if (dp_strncmpi(param_list[4], "no_limit",
 				strlen("no_limit")) == 0)
@@ -1194,7 +1194,7 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 			shaper_cfg.pbs = dp_atoi(param_list[7]);
 
 		if (dp_shaper_conf_set(&shaper_cfg, 0)) {
-			PR_ERR("dp_shaper_conf_set failed\n");
+			pr_err("dp_shaper_conf_set failed\n");
 			return count;
 		}
 	} else if (dp_strncmpi(param_list[0], "set_node",
@@ -1202,7 +1202,7 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 		struct dp_node_link_enable en_node = {0};
 
 		if (num < 4 || num > 5) {
-			PR_ERR("id, type, cmd are required!%s%s\n",
+			pr_err("id, type, cmd are required!%s%s\n",
 			       "\n(try help):echo help > ",
 			       "/sys/kernel/debug/dp/qos");
 			return count;
@@ -1220,7 +1220,7 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 			en_node.type = DP_NODE_PORT;
 			en_node.id.cqm_deq_port = dp_atoi(param_list[1]);
 		} else {
-			PR_ERR("Incorrect parameter!%s%s%s\n", param_list[2],
+			pr_err("Incorrect parameter!%s%s%s\n", param_list[2],
 			       "\n(try help):echo help > ",
 			       "/sys/kernel/debug/dp/qos");
 			return count;
@@ -1239,7 +1239,7 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 				       strlen("resume")) == 0) {
 			en_node.en |= DP_NODE_RESUME;
 		} else {
-			PR_ERR("Incorrect parameter!%s%s%s\n", param_list[3],
+			pr_err("Incorrect parameter!%s%s%s\n", param_list[3],
 			       "\n(try help):echo help > ",
 			       "/sys/kernel/debug/dp/qos");
 			return count;
@@ -1259,7 +1259,7 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 					       strlen("resume")) == 0) {
 				en_node.en |= DP_NODE_RESUME;
 			} else {
-				PR_ERR("Incorrect parameter!%s%s%s\n",
+				pr_err("Incorrect parameter!%s%s%s\n",
 				       param_list[4],
 				       "\n(try help):echo help > ",
 				       "/sys/kernel/debug/dp/qos");
@@ -1268,7 +1268,7 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 		}
 
 		if (dp_node_link_en_set(&en_node, 0)) {
-			PR_ERR("dp_node_link_en_set failed\n");
+			pr_err("dp_node_link_en_set failed\n");
 			return count;
 		}
 	} else if (dp_strncmpi(param_list[0], "qmap_set",
@@ -1278,7 +1278,7 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 		qmap_set.q_id = dp_atoi(param_list[1]);
 
 		if (num < 10) {
-			PR_INFO("Wrong Parameter(try help):%s\n",
+			pr_info("Wrong Parameter(try help):%s\n",
 				"echo help > /sys/kernel/debug/dp/qos");
 			return count;
 		}
@@ -1291,7 +1291,7 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 		qmap_set.map.class = dp_atoi(param_list[8]);
 		qmap_set.map.subif = dp_atoi(param_list[9]);
 		if (dp_queue_map_set(&qmap_set, 0)) {
-			PR_ERR("dp_queue_map_set failed\n");
+			pr_err("dp_queue_map_set failed\n");
 			return count;
 		}
 	} else if (dp_strncmpi(param_list[0], "get_child",
@@ -1307,26 +1307,26 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 			node.type = DP_NODE_PORT;
 			node.id.cqm_deq_port = dp_atoi(param_list[1]);
 		} else {
-			PR_ERR("unknown type %s\n", param_list[2]);
+			pr_err("unknown type %s\n", param_list[2]);
 		}
 
 		if (dp_children_get(&node, 0)) {
-			PR_ERR("dp_children_get failed\n");
+			pr_err("dp_children_get failed\n");
 			return count;
 		}
 		if (node.num)
-			PR_INFO("Node[%d] has {%d} Children!!\n",
+			pr_info("Node[%d] has {%d} Children!!\n",
 				node.id.q_id, node.num);
 		for (idx = 0; idx < PROC_DP_MAX_LEAF; idx++) {
 			if (node.child[idx].id.q_id) {
 				if (node.child[idx].type == DP_NODE_SCH)
-					PR_INFO("Child:[%d] is Sched:[%d]\n",
+					pr_info("Child:[%d] is Sched:[%d]\n",
 						idx, node.child[idx].id.q_id);
 				else if (node.child[idx].type == DP_NODE_QUEUE)
-					PR_INFO("Child:[%d] is Q:[%d]\n",
+					pr_info("Child:[%d] is Q:[%d]\n",
 						idx, node.child[idx].id.q_id);
 				else
-					PR_INFO("Child:[%d] is FREE\n", idx);
+					pr_info("Child:[%d] is FREE\n", idx);
 			}
 		}
 	} else if (dp_strncmpi(param_list[0], "q_link",
@@ -1337,24 +1337,24 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 		q_link.q_id = dp_atoi(param_list[1]);
 
 		if (dp_link_get(&q_link, 0)) {
-			PR_ERR("dp_link_get failed\n");
+			pr_err("dp_link_get failed\n");
 			return count;
 		}
 		if (!q_link.n_sch_lvl) {
-			PR_INFO("Q[%d](arbi:%d|prio:%d)->PORT[%d]\n",
+			pr_info("Q[%d](arbi:%d|prio:%d)->PORT[%d]\n",
 				q_link.q_id, q_link.q_arbi, q_link.q_prio_wfq,
 				q_link.cqm_deq_port);
 		} else {
-			PR_INFO("Q[%d](arbi:%d|prio:%d)\n",
+			pr_info("Q[%d](arbi:%d|prio:%d)\n",
 				q_link.q_id, q_link.q_arbi,
 				q_link.q_prio_wfq);
 			for (i = 0; i < q_link.n_sch_lvl; i++) {
-				PR_INFO("%s(%d):SCH[%d](arbi:%d|prio:%d)\n",
+				pr_info("%s(%d):SCH[%d](arbi:%d|prio:%d)\n",
 					"Parent level", i, q_link.sch[i].id,
 					q_link.sch[i].arbi,
 					q_link.sch[i].prio_wfq);
 			}
-			PR_INFO("Parent level(%d):PORT[%d] <Final Parent>\n",
+			pr_info("Parent level(%d):PORT[%d] <Final Parent>\n",
 				i, q_link.cqm_deq_port);
 		}
 	} else if (dp_strncmpi(param_list[0], "get_level",
@@ -1364,14 +1364,14 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 		dp.inst = 0;
 
 		if (dp_qos_level_get(&dp, 0)) {
-			PR_ERR("dp_qos_level_get failed\n");
+			pr_err("dp_qos_level_get failed\n");
 			return count;
 		}
 		if (dp.max_sch_lvl)
-			PR_INFO("Q->SCH(%d)->PORT, level:[%d]\n",
+			pr_info("Q->SCH(%d)->PORT, level:[%d]\n",
 				dp.max_sch_lvl, dp.max_sch_lvl);
 		else
-			PR_INFO("Q->PORT, level:[%d]\n", dp.max_sch_lvl);
+			pr_info("Q->PORT, level:[%d]\n", dp.max_sch_lvl);
 	} else if (dp_strncmpi(param_list[0], "q_conf",
 			       strlen("q_conf")) == 0) {
 		struct dp_queue_conf q_conf = {0};
@@ -1380,48 +1380,48 @@ ssize_t proc_qos_write(struct file *file, const char *buf, size_t count,
 		q_conf.q_id = dp_atoi(param_list[1]);
 
 		if (dp_queue_conf_get(&q_conf, 0)) {
-			PR_ERR("dp_queue_conf_get failed\n");
+			pr_err("dp_queue_conf_get failed\n");
 			return count;
 		}
 		if (q_conf.act & DP_NODE_EN)
-			PR_INFO("Q(%d) action is ENABLED:[%d]\n",
+			pr_info("Q(%d) action is ENABLED:[%d]\n",
 				q_conf.q_id, q_conf.act);
 		else
-			PR_INFO("Q(%d) action is BLOCKED:[%d]\n",
+			pr_info("Q(%d) action is BLOCKED:[%d]\n",
 				q_conf.q_id, q_conf.act);
 		if (q_conf.drop == DP_QUEUE_DROP_WRED) {
-			PR_INFO("Q(%d) is in WRED MODE:[%d]\n",
+			pr_info("Q(%d) is in WRED MODE:[%d]\n",
 				q_conf.q_id, q_conf.drop);
-			PR_INFO("Q(%d) is min_size_1:[%d]\n",
+			pr_info("Q(%d) is min_size_1:[%d]\n",
 				q_conf.q_id, q_conf.min_size[0]);
-			PR_INFO("Q(%d) is max_size_1:[%d]\n",
+			pr_info("Q(%d) is max_size_1:[%d]\n",
 				q_conf.q_id, q_conf.max_size[0]);
-			PR_INFO("Q(%d) is min_size_2:[%d]\n",
+			pr_info("Q(%d) is min_size_2:[%d]\n",
 				q_conf.q_id, q_conf.min_size[1]);
-			PR_INFO("Q(%d) is max_size_2:[%d]\n",
+			pr_info("Q(%d) is max_size_2:[%d]\n",
 				q_conf.q_id, q_conf.max_size[1]);
-			PR_INFO("Q(%d) is max_allowed:[%d]\n",
+			pr_info("Q(%d) is max_allowed:[%d]\n",
 				q_conf.q_id, q_conf.wred_max_allowed);
-			PR_INFO("Q(%d) is min_gauranteed:[%d]\n",
+			pr_info("Q(%d) is min_gauranteed:[%d]\n",
 				q_conf.q_id, q_conf.wred_min_guaranteed);
-			PR_INFO("Q(%d) is wred_slope_1:[%d]\n",
+			pr_info("Q(%d) is wred_slope_1:[%d]\n",
 				q_conf.q_id, q_conf.wred_slope[0]);
-			PR_INFO("Q(%d) is wred_slope_2:[%d]\n",
+			pr_info("Q(%d) is wred_slope_2:[%d]\n",
 				q_conf.q_id, q_conf.wred_slope[1]);
 		} else {
-			PR_INFO("Q(%d) is in DROP TAIL MODE:[%d]\n",
+			pr_info("Q(%d) is in DROP TAIL MODE:[%d]\n",
 				q_conf.q_id, q_conf.drop);
-			PR_INFO("Q(%d) is min_size_1:[%d]\n",
+			pr_info("Q(%d) is min_size_1:[%d]\n",
 				q_conf.q_id, q_conf.min_size[0]);
-			PR_INFO("Q(%d) is max_size_1:[%d]\n",
+			pr_info("Q(%d) is max_size_1:[%d]\n",
 				q_conf.q_id, q_conf.max_size[0]);
-			PR_INFO("Q(%d) is min_size_2:[%d]\n",
+			pr_info("Q(%d) is min_size_2:[%d]\n",
 				q_conf.q_id, q_conf.min_size[1]);
-			PR_INFO("Q(%d) is max_size_2:[%d]\n",
+			pr_info("Q(%d) is max_size_2:[%d]\n",
 				q_conf.q_id, q_conf.max_size[1]);
 		}
 	} else {
-		PR_INFO("Wrong Parameter:\n");
+		pr_info("Wrong Parameter:\n");
 		qos_create_qos_help();
 	}
 	return count;
diff --git a/drivers/net/datapath/dpm/datapath_qos.c b/drivers/net/datapath/dpm/datapath_qos.c
index 8b7da5d8c3dd..e1ff86f9119b 100644
--- a/drivers/net/datapath/dpm/datapath_qos.c
+++ b/drivers/net/datapath/dpm/datapath_qos.c
@@ -158,7 +158,7 @@ int dp_deq_port_res_get(struct dp_dequeue_res *res, int flag)
 			return DP_FAILURE;
 		dp_get_netif_subifid(res->dev, NULL, NULL, NULL, subif, 0);
 		if (!subif->subif_num) {
-			PR_ERR("Not found dev %s\n", res->dev->name);
+			pr_err("Not found dev %s\n", res->dev->name);
 			return DP_FAILURE;
 		}
 		res->dp_port = subif->port_id;
diff --git a/drivers/net/datapath/dpm/datapath_soc.c b/drivers/net/datapath/dpm/datapath_soc.c
index cc7b2bbf5a14..00e97830c59f 100644
--- a/drivers/net/datapath/dpm/datapath_soc.c
+++ b/drivers/net/datapath/dpm/datapath_soc.c
@@ -51,7 +51,7 @@ int request_dp(u32 flag)
 	info.cbm_inst = 0;
 	info.qos_inst = 0;
 	if (dp_request_inst(&info, flag)) {
-		PR_ERR("dp_request_inst failed\n");
+		pr_err("dp_request_inst failed\n");
 		return -1;
 	}
 	return 0;
diff --git a/drivers/net/datapath/dpm/datapath_swdev.c b/drivers/net/datapath/dpm/datapath_swdev.c
index 195b3f1b5339..0f74fe44d184 100644
--- a/drivers/net/datapath/dpm/datapath_swdev.c
+++ b/drivers/net/datapath/dpm/datapath_swdev.c
@@ -226,7 +226,7 @@ static int dp_swdev_add_bport_to_list(struct br_info *br_item,
 			kmalloc(sizeof(struct bridge_member_port),
 				GFP_KERNEL);
 		if (!bport_list) {
-			PR_ERR("\n Node creation failed\n");
+			pr_err("\n Node creation failed\n");
 			return -1;
 		}
 		bport_list->dev_reg_flag = br_item->flag;
@@ -284,7 +284,7 @@ static int dp_swdev_cfg_vlan(struct bridge_id_entry_item *br_item,
 		idx = dp_dev_hash(dev, NULL);
 		dp_dev = dp_dev_lookup(&dp_dev_list[idx], dev, NULL, 0);
 		if (!dp_dev) {
-			PR_ERR("\n dp_dev NULL\n");
+			pr_err("\n dp_dev NULL\n");
 			/* Cannot return -1 from here as this fn is
 			 * called by swdev commit phase
 			 */
@@ -314,7 +314,7 @@ static int dp_swdev_filter_vlan(struct net_device *dev,
 	if (switchdev_trans_ph_prepare(trans)) {
 		/*Get current BPORT ID,instance from DP*/
 		if (dp_get_netif_subifid(dev, NULL, NULL, NULL, &subif, 0)) {
-			PR_ERR("%s dp_get_netif_subifid failed for %s\n",
+			pr_err("%s dp_get_netif_subifid failed for %s\n",
 			       __func__, dev->name);
 			return -EOPNOTSUPP;
 		}
@@ -370,9 +370,8 @@ static int dp_swdev_cfg_gswip(struct bridge_id_entry_item *br_item,
 		if (ret == 0) {
 			br_info = kmalloc(sizeof(*br_info), GFP_KERNEL);
 			if (!br_info) {
-				PR_ERR
-				("Switch cfg Fail as kmalloc %zd bytes fail\n",
-				 sizeof(*br_info));
+				pr_err("Switch cfg Fail as kmalloc %zd bytes fail\n",
+				       sizeof(*br_info));
 				/*TODO need to check return value
 				 *for switchdev commit
 				 */
@@ -474,7 +473,7 @@ static int dp_swdev_add_if(struct net_device *dev,
 			res = dp_get_netif_subifid(base, NULL, NULL, NULL,
 						   &subif, 0);
 			if (res) {
-				PR_ERR("dp_get_netif_subifid fail:%s\n",
+				pr_err("dp_get_netif_subifid fail:%s\n",
 				       base->name);
 				return -EOPNOTSUPP;
 			}
@@ -485,7 +484,7 @@ static int dp_swdev_add_if(struct net_device *dev,
 				get_dp_port_info(inst, port)->owner,
 				dev, dev->name, &subif,
 				DP_F_SUBIF_LOGICAL)) {
-				PR_ERR("dp_register_subif fail: %s\n",
+				pr_err("dp_register_subif fail: %s\n",
 				       dev->name);
 				return -EOPNOTSUPP;
 			}
@@ -532,7 +531,7 @@ static int dp_swdev_add_if(struct net_device *dev,
 					       br_dev->name);
 					br_item->fid = br_id;
 				} else {
-					PR_ERR("Switch config failed\r\n");
+					pr_err("Switch config failed\r\n");
 					kfree(br_item);
 					swdev_unlock();
 					return -EOPNOTSUPP;
@@ -643,7 +642,7 @@ static int dp_swdev_del_if(struct net_device *dev,
 			swdev_unlock();
 			if (dp_get_netif_subifid(base, NULL, NULL,
 						 NULL, &subif, 0)) {
-				PR_ERR("dp_get_netif_subifid fail:%s\n",
+				pr_err("dp_get_netif_subifid fail:%s\n",
 				       base->name);
 				/*Cannot Return -EOPNOTSUPP
 				 * in swdev commit stage
@@ -656,7 +655,7 @@ static int dp_swdev_del_if(struct net_device *dev,
 					get_dp_port_info(inst, port)->owner,
 					dev, dev->name, &subif,
 					DP_F_DEREGISTER)) {
-				PR_ERR("dp_register_subif fail: %s\n",
+				pr_err("dp_register_subif fail: %s\n",
 				       dev->name);
 				/*Cannot Return -EOPNOTSUPP
 				 * in swdev commit stage
@@ -1023,9 +1022,8 @@ int dp_notif_br_alloc(struct net_device *br_dev)
 			== 0)) {
 			br_info = kmalloc(sizeof(*br_info), GFP_KERNEL);
 			if (!br_info) {
-				PR_ERR
-				("Switch cfg Fail as kmalloc %zd bytes fail\n",
-				 sizeof(*br_info));
+				pr_err("Switch cfg Fail as kmalloc %zd bytes fail\n",
+				       sizeof(*br_info));
 				return -1;
 			}
 			br_info->fid = br_id;
@@ -1036,11 +1034,11 @@ int dp_notif_br_alloc(struct net_device *br_dev)
 			INIT_LIST_HEAD(&br_info->bp_list);
 			dp_swdev_insert_bridge_id_entry(br_info);
 		} else {
-			PR_ERR("Switch configuration failed\r\n");
+			pr_err("Switch configuration failed\r\n");
 			return -1;
 		}
 	} else {
-		PR_ERR("Switch bridge alloc failed\r\n");
+		pr_err("Switch bridge alloc failed\r\n");
 		return -1;
 	}
 	return br_id;
@@ -1120,12 +1118,12 @@ int dp_port_register_switchdev(struct dp_dev  *dp_dev,
 	int err = DP_SUCCESS;
 
 	if (!dp_port) {
-		PR_ERR("cannot support switchdev if dev is NULL\n");
+		pr_err("cannot support switchdev if dev is NULL\n");
 		return -1;
 	}
 	if (dp_port_prop[dp_dev->inst].info.swdev_flag == 1) {
 		if (!dp_port->netdev_ops) {
-			PR_ERR("netdev_ops not defined\n");
+			pr_err("netdev_ops not defined\n");
 			return -1;
 		}
 	/* switchdev ops register */
diff --git a/drivers/net/datapath/dpm/datapath_tx.c b/drivers/net/datapath/dpm/datapath_tx.c
index c5a488216ae7..872d7d8a586a 100644
--- a/drivers/net/datapath/dpm/datapath_tx.c
+++ b/drivers/net/datapath/dpm/datapath_tx.c
@@ -138,48 +138,48 @@ int dp_tx_err(struct sk_buff *skb, struct dp_tx_common *cmn, int ret)
 {
 	switch (ret) {
 	case DP_XMIT_ERR_NOT_INIT:
-		PR_RATELIMITED("dp_xmit failed for dp no init yet\n");
+		printk_ratelimited("dp_xmit failed for dp no init yet\n");
 		break;
 
 	case DP_XMIT_ERR_IN_IRQ:
-		PR_RATELIMITED("dp_xmit not allowed in interrupt context\n");
+		printk_ratelimited("dp_xmit not allowed in interrupt context\n");
 		break;
 
 	case DP_XMIT_ERR_NULL_SUBIF:
-		PR_RATELIMITED("dp_xmit failed for rx_subif null\n");
+		printk_ratelimited("dp_xmit failed for rx_subif null\n");
 		UP_STATS(get_dp_port_info(0, 0)->tx_err_drop);
 		break;
 
 	case DP_XMIT_ERR_PORT_TOO_BIG:
 		UP_STATS(get_dp_port_info(0, 0)->tx_err_drop);
-		PR_RATELIMITED("rx_subif->port_id >= max_ports");
+		printk_ratelimited("rx_subif->port_id >= max_ports");
 		break;
 
 	case DP_XMIT_ERR_NULL_SKB:
-		PR_RATELIMITED("skb NULL");
+		printk_ratelimited("skb NULL");
 		UP_STATS(get_dp_port_info(0, cmn->dpid)->tx_err_drop);
 		break;
 
 	case DP_XMIT_ERR_NULL_IF:
 		UP_STATS(cmn->mib->tx_pkt_dropped);
-		PR_RATELIMITED("rx_if NULL");
+		printk_ratelimited("rx_if NULL");
 		break;
 
 	case DP_XMIT_ERR_REALLOC_SKB:
-		PR_INFO_ONCE("dp_create_new_skb failed\n");
+		pr_info_once("dp_create_new_skb failed\n");
 		break;
 
 	case DP_XMIT_ERR_EP_ZERO:
-		PR_ERR("Why ep zero in dp_xmit for %s\n",
+		pr_err("Why ep zero in dp_xmit for %s\n",
 		       skb->dev ? skb->dev->name : "NULL");
 		break;
 
 	case DP_XMIT_ERR_GSO_NOHEADROOM:
-		PR_ERR("No enough skb headerroom(GSO). Need tune SKB buffer\n");
+		pr_err("No enough skb headerroom(GSO). Need tune SKB buffer\n");
 		break;
 
 	case DP_XMIT_ERR_CSM_NO_SUPPORT:
-		PR_RATELIMITED("dp_xmit not support checksum\n");
+		printk_ratelimited("dp_xmit not support checksum\n");
 		break;
 
 	case DP_XMIT_PTP_ERR:
@@ -187,7 +187,7 @@ int dp_tx_err(struct sk_buff *skb, struct dp_tx_common *cmn, int ret)
 
 	default:
 		UP_STATS(cmn->mib->tx_pkt_dropped);
-		PR_INFO_ONCE("Why come to here:%x\n",
+		pr_info_once("Why come to here:%x\n",
 			     get_dp_port_info(0, cmn->dpid)->status);
 	}
 
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_coc.c b/drivers/net/datapath/dpm/gswip30/datapath_coc.c
index 35dfcdac9c18..6dd9bf5c0a34 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_coc.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_coc.c
@@ -86,7 +86,7 @@ EXPORT_SYMBOL(dp_set_rmon_threshold);
 static inline void coc_lock(void)
 {
 	if (unlikely(in_irq())) {
-		PR_ERR("Not allowed to call COC API in_irq mode\n");
+		pr_err("Not allowed to call COC API in_irq mode\n");
 		return;
 	}
 	spin_lock_bh(&dp_coc_lock);
@@ -243,7 +243,7 @@ ssize_t proc_coc_write_30(struct file *file, const char *buf, size_t count,
 		u32 rate = dp_atoi(param_list[1]);
 
 		if (!rate) {
-			PR_INFO("rate should not be zero\n");
+			pr_info("rate should not be zero\n");
 			return count;
 		}
 		if (dp_strncmpi(param_list[0], "rate1",
@@ -257,28 +257,23 @@ ssize_t proc_coc_write_30(struct file *file, const char *buf, size_t count,
 				strlen("rate3") + 1) == 0) {
 			dp_set_meter_rate(LTQ_CPUFREQ_PS_D3, rate);
 		} else {
-			PR_INFO
-			    ("Wrong COC state, it should be D1/D2/D3 only\n");
+			pr_info("Wrong COC state, it should be D1/D2/D3 only\n");
 		}
 	} else {
 		goto help;
 	}
 	return count;
  help:
-	PR_INFO("Datapath COC Proc Usage:\n");
-	PR_INFO
-	("echo timer polling_interval_in_seconds > /sys/kernel/debug/dp/coc\n");
-	PR_INFO
-	("echo <thresholdx> its_threshold_value > /sys/kernel/debug/dp/coc\n");
-	PR_INFO("       Note:Valid x of ranage: 1 2 3\n");
-	PR_INFO
-	    ("            For downscale to D<x> if rmon<threshold<x>'s cfg\n");
-	PR_INFO("            threshold1's >= threshold'2 > threshold'3\n");
-	PR_INFO("echo <ratex> <meter_rate_in_knps> /sys/kernel/debug/dp/coc\n");
-	PR_INFO("       Note:Valid x of range: 1 2 3\n");
-	PR_INFO
-	  ("            For upscale to D0 from D<x> if rmon>=rate<x>'s cfg\n");
-	PR_INFO("            Rate1's >= Rate2's > D3's threshold\n");
+	pr_info("Datapath COC Proc Usage:\n");
+	pr_info("echo timer polling_interval_in_seconds > /sys/kernel/debug/dp/coc\n");
+	pr_info("echo <thresholdx> its_threshold_value > /sys/kernel/debug/dp/coc\n");
+	pr_info("       Note:Valid x of ranage: 1 2 3\n");
+	pr_info("            For downscale to D<x> if rmon<threshold<x>'s cfg\n");
+	pr_info("            threshold1's >= threshold'2 > threshold'3\n");
+	pr_info("echo <ratex> <meter_rate_in_knps> /sys/kernel/debug/dp/coc\n");
+	pr_info("       Note:Valid x of range: 1 2 3\n");
+	pr_info("            For upscale to D0 from D<x> if rmon>=rate<x>'s cfg\n");
+	pr_info("            Rate1's >= Rate2's > D3's threshold\n");
 	return count;
 }
 
@@ -717,7 +712,7 @@ int dp_handle_cpufreq_event_30(int event_id, void *cfg)
 		res = dp_coc_policy_notify((struct cpufreq_policy *)cfg);
 		break;
 	default:
-		PR_ERR("no support for %d\n", event_id);
+		pr_err("no support for %d\n", event_id);
 		break;
 	}
 	return res;
@@ -752,7 +747,7 @@ int dp_coc_cpufreq_init(void)
 	dp_coc_init_stat = 0;
 	dp_coc_ena = 0;
 
-	PR_INFO("enter dp_coc_cpufreq_init\n");
+	pr_info("enter dp_coc_cpufreq_init\n");
 	spin_lock_init(&dp_coc_lock);
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_R];
 
@@ -774,7 +769,7 @@ int dp_coc_cpufreq_init(void)
 	dp_coc_init_stat = 1;
 	dp_coc_ena = 1;
 	schedule_work(&coc_work_q);
-	PR_INFO("Register DP to CPUFREQ successfully.\n");
+	pr_info("Register DP to CPUFREQ successfully.\n");
 	return 0;
 }
 
@@ -786,7 +781,7 @@ int dp_coc_cpufreq_exit(void)
 		coc_lock();
 		ret = del_timer(&dp_coc_timer);
 		if (ret)
-			PR_ERR("The timer is still in use...\n");
+			pr_err("The timer is still in use...\n");
 		dp_coc_init_stat = 0;
 		dp_coc_ena = 0;
 		dp_coc_ps_curr = -1; /* reset current state*/
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_gswip.c b/drivers/net/datapath/dpm/gswip30/datapath_gswip.c
index 9853c9df97a2..5e51eef2c09f 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_gswip.c
@@ -27,7 +27,7 @@ int dp_pmac_set_30(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 	GSW_PMAC_Glbl_Cfg_t pmac_glb;
 
 	if (!pmac_cfg || !port) {
-		PR_ERR("dp_pmac_set:wrong parameter(pmac_cfg/port NULL)\n");
+		pr_err("dp_pmac_set:wrong parameter(pmac_cfg/port NULL)\n");
 		return -1;
 	}
 
@@ -42,7 +42,7 @@ int dp_pmac_set_30(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 	else
 		gswr_r = dp_port_prop[inst].ops[1];
 	if (!gswr_r) {
-		PR_ERR("why gswr_r NULL\n");
+		pr_err("why gswr_r NULL\n");
 		return -1;
 	}
 
@@ -52,7 +52,7 @@ int dp_pmac_set_30(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 		ret = cbm_dequeue_port_resources_get(port, &dqport, flag);
 
 		if (ret == -1) {
-			PR_ERR("cbm_dequeue_port_resources_get failed\n");
+			pr_err("cbm_dequeue_port_resources_get failed\n");
 			return -1;
 		}
 
@@ -304,7 +304,7 @@ int dp_set_gsw_parser_30(u8 flag, u8 cpu, u8 mpe1,
 	struct core_ops *gsw_handle = dp_port_prop[0].ops[1]; /*pae*/
 
 	if (gsw_handle->gsw_common_ops.CPU_PortCfgGet(gsw_handle, &param)) {
-		PR_ERR("Failed GSW_CPU_PORT_CFG_GET\n");
+		pr_err("Failed GSW_CPU_PORT_CFG_GET\n");
 		return -1;
 	}
 	DP_DEBUG(DP_DBG_FLAG_DBG, "old flag=0x%x cpu=%d mpe1/2/3=%d/%d/%d\n",
@@ -326,7 +326,7 @@ int dp_set_gsw_parser_30(u8 flag, u8 cpu, u8 mpe1,
 		param.eMPE1MPE2ParserCfg = mpe3;
 
 	if (gsw_handle->gsw_common_ops.CPU_PortCfgSet(gsw_handle, &param)) {
-		PR_ERR("Failed GSW_CPU_PORT_CFG_SET\n");
+		pr_err("Failed GSW_CPU_PORT_CFG_SET\n");
 		return -1;
 	}
 	dp_parser_info_refresh(param.eNoMPEParserCfg,
@@ -343,7 +343,7 @@ int dp_get_gsw_parser_30(u8 *cpu, u8 *mpe1, u8 *mpe2,
 	struct core_ops *gsw_handle = dp_port_prop[0].ops[1]; /*pae*/
 
 	if (gsw_handle->gsw_common_ops.CPU_PortCfgGet(gsw_handle, &param)) {
-		PR_ERR("Failed GSW_CPU_PORT_CFG_GET\n");
+		pr_err("Failed GSW_CPU_PORT_CFG_GET\n");
 		return -1;
 	}
 	dp_parser_info_refresh(param.eNoMPEParserCfg,
@@ -388,7 +388,7 @@ int gsw_mib_reset_30(int dev, u32 flag)
 	ret = gsw_handle->gsw_rmon_ops.RMON_Clear(gsw_handle, &rmon_clear);
 
 	if (ret != GSW_statusOk) {
-		PR_ERR("R:GSW_RMON_CLEAR failed for GSW_RMON_ALL_TYPE\n");
+		pr_err("R:GSW_RMON_CLEAR failed for GSW_RMON_ALL_TYPE\n");
 		return -1;
 	}
 	return ret;
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_lookup_proc.c b/drivers/net/datapath/dpm/gswip30/datapath_lookup_proc.c
index 0ce1c5e5d4a1..1068bf3be188 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_lookup_proc.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_lookup_proc.c
@@ -34,7 +34,7 @@
 #define proc_printf(s, fmt, arg...) \
 	do { \
 		if (!s) \
-			PR_INFO(fmt, ##arg); \
+			pr_info(fmt, ##arg); \
 		else \
 			seq_printf(s, fmt, ##arg); \
 	} while (0)
@@ -238,7 +238,7 @@ static void lookup_pattern_match(int tmp_index)
 			for (i = 0; i < LOOKUP_FIELD_BITS; i++)
 				index |= (t[i] << i);
 			if (lookup_tbl_flags[index] == ENTRY_USED)
-				PR_ERR("why already used\n");
+				pr_err("why already used\n");
 			else
 				lookup_tbl_flags[index] = ENTRY_USED;
 		}
@@ -403,13 +403,13 @@ ssize_t proc_get_qid_via_index30(struct file *file, const char *buf,
 
 	if (len <= 0) {
 		err = -EFAULT;
-		PR_ERR("Wrong len value (%d)\n", len);
+		pr_err("Wrong len value (%d)\n", len);
 		return count;
 	}
 
 	if (copy_from_user(data, buf, len)) {
 		err = -EFAULT;
-		PR_ERR("copy_from_user fail");
+		pr_err("copy_from_user fail");
 		return count;
 	}
 
@@ -426,7 +426,7 @@ ssize_t proc_get_qid_via_index30(struct file *file, const char *buf,
 	if ((dp_strncmpi(param_list[0], "set", strlen("set")) == 0) ||
 	    (dp_strncmpi(param_list[0], "write", strlen("write")) == 0)) {
 		if (!param_list[2]) {
-			PR_ERR("wrong command\n");
+			pr_err("wrong command\n");
 			return count;
 		}
 		qid = dp_atoi(param_list[2]);
@@ -438,7 +438,7 @@ ssize_t proc_get_qid_via_index30(struct file *file, const char *buf,
 			return count;
 		}
 		set_lookup_qid_via_index(lookup_index, qid);
-		PR_INFO("Set lookup[%u 0x%x] ->     queue[%u]\n",
+		pr_info("Set lookup[%u 0x%x] ->     queue[%u]\n",
 			lookup_index, lookup_index, qid);
 	} else if ((dp_strncmpi(param_list[0], "get", strlen("get")) == 0) ||
 		   (dp_strncmpi(param_list[0], "read", strlen("read")) == 0)) {
@@ -448,7 +448,7 @@ ssize_t proc_get_qid_via_index30(struct file *file, const char *buf,
 			return count;
 		}
 		qid = get_lookup_qid_via_index(lookup_index);
-		PR_INFO("Get lookup[%05u 0x%04x] ->     queue[%u]\n",
+		pr_info("Get lookup[%05u 0x%04x] ->     queue[%u]\n",
 			lookup_index, lookup_index, qid);
 	} else if (dp_strncmpi(param_list[0], "find", strlen("find")) == 0) {
 		/*read out its all flags for specified qid */
@@ -472,21 +472,21 @@ ssize_t proc_get_qid_via_index30(struct file *file, const char *buf,
 	}
 	goto help;
 help:
-	PR_INFO("Usage: echo set lookup_flags queue_id > /proc/dp/lookup\n");
-	PR_INFO("     : echo get lookup_flags > /proc/dp/lookup\n");
-	PR_INFO("     : echo find  <x> > /proc/dp/lookup\n");
-	PR_INFO("     : echo find2 <x> > /proc/dp/lookup\n");
-	PR_INFO("     : echo remap <old_q> <new_q> > /proc/dp/lookup\n");
-	PR_INFO("  Hex example: echo set 0x10 10 > /proc/dp/lookup\n");
-	PR_INFO("  Dec:example: echo set 16 10 > /proc/dp/lookup\n");
-	PR_INFO("  Bin:example: echo set b10000 10 > /proc/dp/lookup\n");
-
-	PR_INFO("%s: echo set b1xxxx 10 > /proc/dp/lookup\n",
+	pr_info("Usage: echo set lookup_flags queue_id > /proc/dp/lookup\n");
+	pr_info("     : echo get lookup_flags > /proc/dp/lookup\n");
+	pr_info("     : echo find  <x> > /proc/dp/lookup\n");
+	pr_info("     : echo find2 <x> > /proc/dp/lookup\n");
+	pr_info("     : echo remap <old_q> <new_q> > /proc/dp/lookup\n");
+	pr_info("  Hex example: echo set 0x10 10 > /proc/dp/lookup\n");
+	pr_info("  Dec:example: echo set 16 10 > /proc/dp/lookup\n");
+	pr_info("  Bin:example: echo set b10000 10 > /proc/dp/lookup\n");
+
+	pr_info("%s: echo set b1xxxx 10 > /proc/dp/lookup\n",
 		"Special for BIN(Don't care bit)");
-	PR_INFO("Lookup format:\n");
-	PR_INFO("  Bits Index: | %s\n",
+	pr_info("Lookup format:\n");
+	pr_info("  Bits Index: | %s\n",
 		"13   12 |  11  |  10  |  9   |  8   |7   4 | 3   0 |");
-	PR_INFO("  Fields:     | %s\n",
+	pr_info("  Fields:     | %s\n",
 		"Flow ID | DEC  | ENC  | MPE2 | MPE1 |  EP  | CLASS |");
 
 	return count;
@@ -506,14 +506,14 @@ void lookup_table_via_qid(int qid)
 				if (tmp != qid)
 					continue;
 				f = 1;
-				PR_INFO("Get lookup[%05u 0x%04x]%s[%d]\n",
+				pr_info("Get lookup[%05u 0x%04x]%s[%d]\n",
 					index, index,
 					" ->     queue", qid);
 			}
 		}
 	}
 	if (!f)
-		PR_ERR("No mapping to queue id %d yet ?\n", qid);
+		pr_err("No mapping to queue id %d yet ?\n", qid);
 }
 
 void lookup_table_remap(int old_q, int new_q)
@@ -532,14 +532,14 @@ void lookup_table_remap(int old_q, int new_q)
 					continue;
 				set_lookup_qid_via_index(index, new_q);
 				f = 1;
-				PR_INFO("Remap lookup[%05u 0x%04x] %s[%d]\n",
+				pr_info("Remap lookup[%05u 0x%04x] %s[%d]\n",
 					index, index,
 					"->     queue", new_q);
 			}
 		}
 	}
 	if (!f)
-		PR_INFO("No mapping to queue id %d yet\n", new_q);
+		pr_info("No mapping to queue id %d yet\n", new_q);
 }
 
 #define LOOKUP_FIELD_BITS 14
@@ -569,7 +569,7 @@ int get_dont_care_lookup(char *s)
 
 	if (len >= LOOKUP_FIELD_BITS + 1)
 		len = LOOKUP_FIELD_BITS + 1;
-	PR_INFO("len=%d\n", len);
+	pr_info("len=%d\n", len);
 	for (i = len - 1, j = 0; i >= 1; i--, j++) {
 		if ((s[i] == 'x') || (s[i] == 'X')) {
 			lookup_mask2[j] = 1;
@@ -585,14 +585,14 @@ int get_dont_care_lookup(char *s)
 		}
 	}
 	if (flag) {
-		PR_INFO("\nGet lookup flag: ");
+		pr_info("\nGet lookup flag: ");
 		for (i = LOOKUP_FIELD_BITS - 1; i >= 0; i--) {
 			if (lookup_mask2[i])
-				PR_INFO("x");
+				pr_info("x");
 			else
-				PR_INFO("%d", lookup_flags2[i]);
+				pr_info("%d", lookup_flags2[i]);
 		}
-		PR_INFO("\n");
+		pr_info("\n");
 
 		return 0;
 	} else {
@@ -607,11 +607,11 @@ void lookup_table_recursive(int k, int tmp_index, int set_flag, int qid)
 	if (k < 0) {	/*finish recursive and start real read/set action */
 		if (set_flag) {
 			set_lookup_qid_via_index(tmp_index, qid);
-			PR_INFO("Set lookup[%05u 0x%04x] ->     queue[%d]\n",
+			pr_info("Set lookup[%05u 0x%04x] ->     queue[%d]\n",
 				tmp_index, tmp_index, qid);
 		} else {
 			qid = get_lookup_qid_via_index(tmp_index);
-			PR_INFO("Get lookup[%05u 0x%04x] ->     queue[%d]\n",
+			pr_info("Get lookup[%05u 0x%04x] ->     queue[%d]\n",
 				tmp_index, tmp_index, qid);
 		}
 		return;
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_mib.c b/drivers/net/datapath/dpm/gswip30/datapath_mib.c
index 8a6626f1edc9..e40caa1ebab9 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_mib.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_mib.c
@@ -219,9 +219,9 @@ static u64 wraparound(u64 curr, u64 last, u32 size)
 	if ((size > 4) || /*for 8 bytes(64bit mib),no need to do wraparound*/
 	    (curr >= last))
 		return curr - last;
-	PR_INFO("Wraparound happen:\n");
-	PR_INFO("  current mib: 0x%x\n", curr);
-	PR_INFO("  last    mib: 0x%x\n", last);
+	pr_info("Wraparound happen:\n");
+	pr_info("  current mib: 0x%x\n", curr);
+	pr_info("  last    mib: 0x%x\n", last);
 	return ((u64)WRAPAROUND_MAX_32) + (u64)curr - last;
 }
 
@@ -444,7 +444,7 @@ static int get_gsw_port_rmon(u32 ep, char *gsw_drv_name,
 	GSW_return_t ret;
 
 	if (!mib) {
-		PR_ERR("why mib pointer is %p\n", mib);
+		pr_err("why mib pointer is %p\n", mib);
 		return -1;
 	}
 	if (ep >= PMAC_MAX_NUM)
@@ -453,7 +453,7 @@ static int get_gsw_port_rmon(u32 ep, char *gsw_drv_name,
 	mib->nPortId = ep;
 	ret = dp_port_prop[0].ops[index]->gsw_rmon_ops.RMON_Port_Get(dp_port_prop[0].ops[index], mib);
 	if (ret) {
-		PR_ERR("GSW_RMON_PORT_GET failed(%d) from %s for port %d\n",
+		pr_err("GSW_RMON_PORT_GET failed(%d) from %s for port %d\n",
 		       ret, gsw_drv_name, ep);
 		return -1;
 	}
@@ -467,14 +467,14 @@ static int get_gsw_redirect_rmon(u32 ep, int index,
 	GSW_return_t ret;
 
 	if (!mib) {
-		PR_ERR("why mib pointer is %p\n", mib);
+		pr_err("why mib pointer is %p\n", mib);
 		return -1;
 	}
 
 	memset(mib, 0, sizeof(*mib));
 	ret = dp_port_prop[0].ops[index]->gsw_rmon_ops.RMON_Redirect_Get(dp_port_prop[0].ops[index], mib);
 	if (ret) {
-		PR_ERR("GSW_RMON_REDIRECT_GET failed from %s\n",
+		pr_err("GSW_RMON_REDIRECT_GET failed from %s\n",
 		       gsw_drv_name);
 		return -1;
 	}
@@ -488,16 +488,15 @@ static int get_gsw_itf_rmon(u32 index, int index,
 	GSW_return_t ret;
 
 	if (!mib) {
-		PR_ERR("why mib pointer is %p\n", mib);
+		pr_err("why mib pointer is %p\n", mib);
 		return -1;
 	}
 	memset(mib, 0, sizeof(*mib));
 	mib->nIfId = index;
 	ret = dp_port_prop[0].ops[index]->gsw_rmon_ops.RMON_If_Get(dp_port_prop[0].ops[index], mib);
 	if (ret) {
-		PR_ERR
-		    ("GSW_RMON_PORT_GET GSW_RMON_IF_GET from %s: index %d\n",
-		     gsw_drv_name, index);
+		pr_err("GSW_RMON_PORT_GET GSW_RMON_IF_GET from %s: index %d\n",
+		       gsw_drv_name, index);
 		return -1;
 	}
 	return 0;
@@ -508,7 +507,7 @@ int get_gsw_interface_base(int port_id)
 	struct pmac_port_info *port_info;
 
 	if ((port_id <= 0) || (port_id >= PMAC_MAX_NUM)) {
-		PR_ERR("Wrong subif\n");
+		pr_err("Wrong subif\n");
 		return -1;
 	}
 
@@ -540,7 +539,7 @@ int gsw_eth_wan_redirect_status(void)
 		q_cfg.nTrafficClassId = i;
 		ret = gsw_qos->QoS_QueuePortGet(gsw_handle, &q_cfg);
 		if (ret) {
-			PR_ERR("%s failed(%d) from %s for port %d\n",
+			pr_err("%s failed(%d) from %s for port %d\n",
 			       "GSW_QOS_QUEUE_PORT_GET",
 			       ret, GSWIP_R, WAN_EP);
 			return -1;
@@ -748,14 +747,14 @@ static int update_vap_mib_lower_lvl(dp_subif_t *subif, u32 flag)
 	itf_index = itf_base + vap;
 	if (itf_index >= MAX_RMON_ITF) {
 		ret = -1;
-		PR_ERR("wrong itf_index(%d) for port %d\n", itf_index,
+		pr_err("wrong itf_index(%d) for port %d\n", itf_index,
 		       port_id);
 		goto EXIT;
 	}
 	ret = get_gsw_itf_rmon(itf_index, GSWIP_R, &curr->gsw_if);
 	if (ret) {
 		curr->gsw_if = last_vap[port_id][vap].gsw_if;
-		PR_ERR("get_gsw_itf_rmon failed for port/vap(%d/%d)", port_id,
+		pr_err("get_gsw_itf_rmon failed for port/vap(%d/%d)", port_id,
 		       vap);
 	}
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_MIB_TMU_MPE_MIB)
@@ -768,7 +767,7 @@ static int update_vap_mib_lower_lvl(dp_subif_t *subif, u32 flag)
 					      &curr->tmu_qos, 0);
 		if (ret) {
 			curr->tmu_qos = last_vap[port_id][vap].tmu_qos;
-			PR_ERR("%s failed for port.vap(%d.%d):%d\n",
+			pr_err("%s failed for port.vap(%d.%d):%d\n",
 			       "tmu_hal_get_qos_mib_hook_fn",
 			       port_id, vap, ret);
 		}
@@ -784,7 +783,7 @@ static int update_vap_mib_lower_lvl(dp_subif_t *subif, u32 flag)
 						0);
 		if (ret) {
 			curr->mpe = last_vap[port_id][vap].mpe;
-			PR_ERR("%s failed for port.vap(%d.%d):%d\n",
+			pr_err("%s failed for port.vap(%d.%d):%d\n",
 			       "mpe_hal_get_netif_mib_hook_fn",
 			       port_id, vap, ret);
 		}
@@ -834,7 +833,7 @@ ssize_t proc_mib_timer_write(struct file *file, const char *buf, size_t count,
 #ifndef THREAD_MODE
 	mod_timer(&exp_timer, jiffies + poll_interval);
 #endif
-	PR_INFO("new poll_interval=%u sec\n",
+	pr_info("new poll_interval=%u sec\n",
 		(unsigned int)poll_interval / HZ);
 	return count;
 }
@@ -1020,13 +1019,13 @@ ssize_t proc_mib_inside_write(struct file *file, const char *buf,
 	set_start_end_id(num[0], num[1], PMAC_MAX_NUM - 1, PMAC_MAX_NUM - 1,
 			 0, PMAC_MAX_NUM - 1, &proc_mib_port_start_id,
 			 &proc_mib_port_end_id);
-	PR_INFO("proc_mib_port_start_id=%u, proc_mib_port_end_id=%u\n",
+	pr_info("proc_mib_port_start_id=%u, proc_mib_port_end_id=%u\n",
 		proc_mib_port_start_id, proc_mib_port_end_id);
 	return count;
 
  help:
-	PR_INFO("ussage echo start_id end_id > /proc/dp/mib_inside\n");
-	PR_INFO("       then display the selected port info via cat %s\n",
+	pr_info("ussage echo start_id end_id > /proc/dp/mib_inside\n");
+	pr_info("       then display the selected port info via cat %s\n",
 		"/proc/dp/mib_inside");
 	return count;
 }
@@ -1060,7 +1059,7 @@ int dp_get_port_vap_mib_30(dp_subif_t *subif, void *priv,
 			 "dp_get_port_vap_mib_30",
 			 subif->port_id, vap, flag);
 		if (update_vap_mib_lower_lvl(subif, flag))
-			PR_ERR("%s failed for port %d VAP=%d\n",
+			pr_err("%s failed for port %d VAP=%d\n",
 			       "update_vap_mib_lower_lvl",
 			       port_id, subif->subif);
 		net_mib->rx_dropped =
@@ -1088,9 +1087,8 @@ int dp_get_port_vap_mib_30(dp_subif_t *subif, void *priv,
 	tmp_subif.subif = 0;/*for dp_get_drv_mib to get all mib of all VAPs */
 
 	if (update_port_mib_lower_lvl(&tmp_subif, 0))
-		PR_ERR
-		    ("update_port_mib_lower_lvl failed for port %d VAP=%d\n",
-		     tmp_subif.port_id, tmp_subif.subif);
+		pr_err("update_port_mib_lower_lvl failed for port %d VAP=%d\n",
+		       tmp_subif.port_id, tmp_subif.subif);
 	if (port_id == 0) { /*not required by concept, for debugging only */
 		struct mibs_port *aggregate_cpu;
 
@@ -1581,7 +1579,7 @@ int clear_gsw_itf_mib(dp_subif_t *subif, u32 flag)
 	for (i = start; i < end; i++) {
 		rmon.nRmonId = i;
 		if (rmon.nRmonId >= MAX_RMON_ITF) {
-			PR_ERR("Why Port[%d]'s interface ID %d so big\n",
+			pr_err("Why Port[%d]'s interface ID %d so big\n",
 			       subif ? subif->port_id : -1,
 			       rmon.nRmonId);
 			return -1;
@@ -1838,7 +1836,7 @@ ssize_t proc_mib_port_write(struct file *file, const char *buf, size_t count,
 		tmu_hal_get_qos_m_local =
 			tmu_hal_get_qos_mib_hook_fn;
 		if (!tmu_hal_get_qos_m_local) {
-			PR_INFO("tmu_hal_get_qos_mib_hook_fn NULL\n");
+			pr_info("tmu_hal_get_qos_mib_hook_fn NULL\n");
 			return count;
 		}
 		for (k = 0; k < ARRAY_SIZE(port_list); k++) {
@@ -1857,31 +1855,31 @@ ssize_t proc_mib_port_write(struct file *file, const char *buf, size_t count,
 							      &qos_stats,
 							      0);
 				if (res) {
-					PR_INFO("%s failed for p[%d]\n",
+					pr_info("%s failed for p[%d]\n",
 						"tmu_hal_get_qos_mib_hook_fn",
 						tmp.port_id);
 					continue;
 				}
-				PR_INFO("%s[%d/%d]:drop_pkts=%llu bytes=%llu\n",
+				pr_info("%s[%d/%d]:drop_pkts=%llu bytes=%llu\n",
 					"qos_mib", tmp.port_id,
 					GET_VAP(tmp.subif, port->vap_offset,
 						port->vap_mask),
 					qos_stats.dropPkts,
 					qos_stats.dropBytes);
-				PR_INFO("%s[%d/%d]:enqPkts=%llu Bytes=%llu\n",
+				pr_info("%s[%d/%d]:enqPkts=%llu Bytes=%llu\n",
 					"qos_mib", tmp.port_id,
 					GET_VAP(tmp.subif, port->vap_offset,
 						port->vap_mask),
 				       qos_stats.enqPkts,
 				       qos_stats.enqBytes);
-				PR_INFO("%s[%d/%d]:deqPkts=%llu Bytes=%llu\n",
+				pr_info("%s[%d/%d]:deqPkts=%llu Bytes=%llu\n",
 					"qos_mib", tmp.port_id,
 					GET_VAP(tmp.subif, port->vap_offset,
 						port->vap_mask),
 					qos_stats.deqPkts,
 					qos_stats.deqBytes);
 			}
-			PR_INFO("\n");
+			pr_info("\n");
 		}
 	} else if (dp_strncmpi(param_list[0],
 			"csum_mib",
@@ -1889,14 +1887,14 @@ ssize_t proc_mib_port_write(struct file *file, const char *buf, size_t count,
 		tmu_hal_get_csum_ol_m_local =
 			tmu_hal_get_csum_ol_mib_hook_fn;
 		if (!tmu_hal_get_csum_ol_m_local) {
-			PR_INFO("tmu_hal_get_csum_ol_mib_hook_fn NULL\n");
+			pr_info("tmu_hal_get_csum_ol_mib_hook_fn NULL\n");
 			return count;
 		}
 		res = tmu_hal_get_csum_ol_m_local(&qos_stats, 0);
 		if (res)
-			PR_INFO("tmu_hal_get_csum_ol_mib_hook_fn failed\n");
+			pr_info("tmu_hal_get_csum_ol_mib_hook_fn failed\n");
 		else
-			PR_INFO("csum_mib: deqPkts=%llu  deqBytes=%llu\n",
+			pr_info("csum_mib: deqPkts=%llu  deqBytes=%llu\n",
 				qos_stats.deqPkts,
 				qos_stats.deqBytes);
 
@@ -1906,14 +1904,14 @@ ssize_t proc_mib_port_write(struct file *file, const char *buf, size_t count,
 		tmu_hal_clear_qos_m_local =
 			tmu_hal_clear_qos_mib_hook_fn;
 		if (!tmu_hal_clear_qos_m_local) {
-			PR_INFO("tmu_hal_clear_qos_m_local NULL ?\n");
+			pr_info("tmu_hal_clear_qos_m_local NULL ?\n");
 			return count;
 		}
 		res = tmu_hal_clear_qos_m_local(NULL, NULL, -1, 0);
 		if (res)
-			PR_INFO("tmu_hal_clear_qos_m_local failed\n");
+			pr_info("tmu_hal_clear_qos_m_local failed\n");
 		else
-			PR_INFO("%s done\n",
+			pr_info("%s done\n",
 				"tmu_hal_clear_qos_m_local(NULL, NULL, -1, 0)");
 
 	} else if (dp_strncmpi(param_list[0],
@@ -1922,14 +1920,14 @@ ssize_t proc_mib_port_write(struct file *file, const char *buf, size_t count,
 		tmu_hal_clear_csum_ol_m_local =
 			tmu_hal_clear_csum_ol_mib_hook_fn;
 		if (!tmu_hal_clear_csum_ol_m_local) {
-			PR_INFO("tmu_hal_clear_csum_ol_mib_hook_fn NULL\n");
+			pr_info("tmu_hal_clear_csum_ol_mib_hook_fn NULL\n");
 			return count;
 		}
 		res = tmu_hal_clear_csum_ol_m_local(0);
 		if (res)
-			PR_INFO("tmu_hal_clear_csum_ol_mib_hook_fn failed\n");
+			pr_info("tmu_hal_clear_csum_ol_mib_hook_fn failed\n");
 		else
-			PR_INFO("tmu_hal_clear_csum_ol_mib_hook_fn(0) done\n");
+			pr_info("tmu_hal_clear_csum_ol_mib_hook_fn(0) done\n");
 
 	} else {
 		goto help;
@@ -1940,14 +1938,14 @@ ssize_t proc_mib_port_write(struct file *file, const char *buf, size_t count,
 	return count;
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_MIB_TMU_MPE_MIB)
 help:
-	PR_INFO("usage:\n");
-	PR_INFO("  test qos_mib  api:      echo qos_mib        > %s\n",
+	pr_info("usage:\n");
+	pr_info("  test qos_mib  api:      echo qos_mib        > %s\n",
 		"/proc/dp/mib_port");
-	PR_INFO("  test csum_mib api       echo csum_mib       > %s\n",
+	pr_info("  test csum_mib api       echo csum_mib       > %s\n",
 		"/proc/dp/mib_port\n");
-	PR_INFO("  test cear_qos_mib  api  echo qos_mib_clear  > %s\n",
+	pr_info("  test cear_qos_mib  api  echo qos_mib_clear  > %s\n",
 		"/proc/dp/mib_port");
-	PR_INFO("  test csum_mib_clear api echo csum_mib_clear > %s\n",
+	pr_info("  test csum_mib_clear api echo csum_mib_clear > %s\n",
 		"/proc/dp/mib_port");
 
 	return count;
@@ -2044,12 +2042,12 @@ ssize_t proc_mib_vap_write(struct file *file, const char *buf, size_t count,
 	set_start_end_id(num[0], num[1], MAX_SUBIF_PER_PORT - 1,
 			 MAX_SUBIF_PER_PORT - 1, 0, -1,
 			 &proc_mib_vap_start_id, &proc_mib_vap_end_id);
-	PR_INFO("proc_mib_vap_start_id=%d, proc_mib_vap_end_id=%d\n",
+	pr_info("proc_mib_vap_start_id=%d, proc_mib_vap_end_id=%d\n",
 		proc_mib_vap_start_id, proc_mib_vap_end_id);
 	return count;
 
  help:
-	PR_INFO("usage: echo start_id end_id > /proc/dp/mib_vap\n");
+	pr_info("usage: echo start_id end_id > /proc/dp/mib_vap\n");
 	return count;
 }
 
@@ -2165,7 +2163,7 @@ int dp_mib_init(u32 flag)
 	exp_timer.data = 0;
 	exp_timer.function = mib_wraparound_timer_poll;
 	add_timer(&exp_timer);
-	PR_INFO("dp_mib_init done\n");
+	pr_info("dp_mib_init done\n");
 #endif
 	return 0;
 }
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_misc.c b/drivers/net/datapath/dpm/gswip30/datapath_misc.c
index 4a964382dc68..cb62a8a1d402 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_misc.c
@@ -250,29 +250,29 @@ static void dump_rx_dma_desc(struct dma_rx_desc_0 *desc_0,
 			     struct dma_rx_desc_3 *desc_3)
 {
 	if (!desc_0 || !desc_1 || !desc_2 || !desc_3) {
-		PR_ERR("rx desc_0/1/2/3 NULL\n");
+		pr_err("rx desc_0/1/2/3 NULL\n");
 		return;
 	}
-	PR_INFO(" DMA Descripotr:D0=0x%08x D1=0x%08x D2=0x%08x D3=0x%08x\n",
+	pr_info(" DMA Descripotr:D0=0x%08x D1=0x%08x D2=0x%08x D3=0x%08x\n",
 		*(u32 *)desc_0, *(u32 *)desc_1,
 		*(u32 *)desc_2, *(u32 *)desc_3);
-	PR_INFO("  DW0:%s=%d tunl_id=%d flow_id=%d eth_type=%d subif=0x%04x\n",
+	pr_info("  DW0:%s=%d tunl_id=%d flow_id=%d eth_type=%d subif=0x%04x\n",
 		"resv0", desc_0->field.resv0,
 		desc_0->field.tunnel_id,
 		desc_0->field.flow_id, desc_0->field.eth_type,
 		desc_0->field.dest_sub_if_id);
-	PR_INFO("  DW1:sess=%d tcp_err=%d nat=%d dec=%d enc=%d mpe2/1=%d/%d\n",
+	pr_info("  DW1:sess=%d tcp_err=%d nat=%d dec=%d enc=%d mpe2/1=%d/%d\n",
 		desc_1->field.session_id, desc_1->field.tcp_err,
 		desc_1->field.nat, desc_1->field.dec, desc_1->field.enc,
 		desc_1->field.mpe2, desc_1->field.mpe1);
-	PR_INFO("      color=%02d ep=%02d resv1=%d classid=%02d\n",
+	pr_info("      color=%02d ep=%02d resv1=%d classid=%02d\n",
 		desc_1->field.color, desc_1->field.ep, desc_1->field.resv1,
 		desc_1->field.classid);
-	PR_INFO("  DW2:data_ptr=0x%08x\n", desc_2->field.data_ptr);
-	PR_INFO("  DW3:own=%d c=%d sop=%d eop=%d dic=%d pdu_type=%d\n",
+	pr_info("  DW2:data_ptr=0x%08x\n", desc_2->field.data_ptr);
+	pr_info("  DW3:own=%d c=%d sop=%d eop=%d dic=%d pdu_type=%d\n",
 		desc_3->field.own, desc_3->field.c, desc_3->field.sop,
 		desc_3->field.eop, desc_3->field.dic, desc_3->field.pdu_type);
-	PR_INFO("      offset=%d atm_q=%d mpoa_pt=%d mpoa_mode=%d len=%d\n",
+	pr_info("      offset=%d atm_q=%d mpoa_pt=%d mpoa_mode=%d len=%d\n",
 		desc_3->field.byte_offset, desc_3->field.qid,
 		desc_3->field.mpoa_pt, desc_3->field.mpoa_mode,
 		desc_3->field.data_len);
@@ -286,29 +286,29 @@ static void dump_tx_dma_desc(struct dma_tx_desc_0 *desc_0,
 	int lookup;
 
 	if (!desc_0 || !desc_1 || !desc_2 || !desc_3) {
-		PR_ERR("tx desc_0/1/2/3 NULL\n");
+		pr_err("tx desc_0/1/2/3 NULL\n");
 		return;
 	}
-	PR_INFO(" DMA Descripotr:D0=0x%08x D1=0x%08x D2=0x%08x D3=0x%08x\n",
+	pr_info(" DMA Descripotr:D0=0x%08x D1=0x%08x D2=0x%08x D3=0x%08x\n",
 		*(u32 *)desc_0, *(u32 *)desc_1,
 		*(u32 *)desc_2, *(u32 *)desc_3);
-	PR_INFO("  DW0:%s=%d tunl_id=%d flow_id=%d eth_type=%d subif=0x%04x\n",
+	pr_info("  DW0:%s=%d tunl_id=%d flow_id=%d eth_type=%d subif=0x%04x\n",
 		"resv0", desc_0->field.resv0,
 		desc_0->field.tunnel_id,
 		desc_0->field.flow_id, desc_0->field.eth_type,
 		desc_0->field.dest_sub_if_id);
-	PR_INFO("  DW1:sess=%d tcp_err=%d nat=%d dec=%d enc=%d mpe2/1=%d/%d\n",
+	pr_info("  DW1:sess=%d tcp_err=%d nat=%d dec=%d enc=%d mpe2/1=%d/%d\n",
 		desc_1->field.session_id, desc_1->field.tcp_err,
 		desc_1->field.nat, desc_1->field.dec, desc_1->field.enc,
 		desc_1->field.mpe2, desc_1->field.mpe1);
-	PR_INFO("  color=%02d ep=%02d resv1=%d classid=%02d\n",
+	pr_info("  color=%02d ep=%02d resv1=%d classid=%02d\n",
 		desc_1->field.color, desc_1->field.ep, desc_1->field.resv1,
 		desc_1->field.classid);
-	PR_INFO("  DW2:data_ptr=0x%08x\n", desc_2->field.data_ptr);
-	PR_INFO("  DW3:own=%d c=%d sop=%d eop=%d dic=%d pdu_type=%d\n",
+	pr_info("  DW2:data_ptr=0x%08x\n", desc_2->field.data_ptr);
+	pr_info("  DW3:own=%d c=%d sop=%d eop=%d dic=%d pdu_type=%d\n",
 		desc_3->field.own, desc_3->field.c, desc_3->field.sop,
 		desc_3->field.eop, desc_3->field.dic, desc_3->field.pdu_type);
-	PR_INFO("  offset=%d atm_qid=%d mpoa_pt=%d mpoa_mode=%d len=%d\n",
+	pr_info("  offset=%d atm_qid=%d mpoa_pt=%d mpoa_mode=%d len=%d\n",
 		desc_3->field.byte_offset, desc_3->field.qid,
 		desc_3->field.mpoa_pt, desc_3->field.mpoa_mode,
 		desc_3->field.data_len);
@@ -319,7 +319,7 @@ static void dump_tx_dma_desc(struct dma_tx_desc_0 *desc_0,
 		((desc_1->field.mpe1) << 8) |
 		((desc_1->field.ep) << 4) |
 		((desc_1->field.classid) << 0);
-	PR_INFO("  lookup index=0x%x qid=%d\n", lookup,
+	pr_info("  lookup index=0x%x qid=%d\n", lookup,
 		get_lookup_qid_via_index(lookup));
 }
 
@@ -330,7 +330,7 @@ static void dump_rx_pmac(struct pmac_rx_hdr *pmac)
 	unsigned char buf[100];
 
 	if (!pmac) {
-		PR_ERR(" pmac NULL ??\n");
+		pr_err(" pmac NULL ??\n");
 		return;
 	}
 
@@ -338,27 +338,27 @@ static void dump_rx_pmac(struct pmac_rx_hdr *pmac)
 	for (i = 0; i < 8; i++)
 		l += sprintf(buf + l, "0x%02x ", p[i]);
 	l += sprintf(buf + l, "\n");
-	PR_INFO("%s", buf);
+	pr_info("%s", buf);
 
 	/*byte 0 */
-	PR_INFO("  byte 0:res=%d ver_done=%d ip_offset=%d\n", pmac->res1,
+	pr_info("  byte 0:res=%d ver_done=%d ip_offset=%d\n", pmac->res1,
 		pmac->ver_done, pmac->ip_offset);
 	/*byte 1 */
-	PR_INFO("  byte 1:tcp_h_offset=%d tcp_type=%d\n", pmac->tcp_h_offset,
+	pr_info("  byte 1:tcp_h_offset=%d tcp_type=%d\n", pmac->tcp_h_offset,
 		pmac->tcp_type);
 	/*byte 2 */
-	PR_INFO("  byte 2:ppid=%d class=%d\n", pmac->sppid, pmac->class);
+	pr_info("  byte 2:ppid=%d class=%d\n", pmac->sppid, pmac->class);
 	/*byte 3 */
-	PR_INFO("  byte 3:res=%d pkt_type=%d\n", pmac->res2, pmac->pkt_type);
+	pr_info("  byte 3:res=%d pkt_type=%d\n", pmac->res2, pmac->pkt_type);
 	/*byte 4 */
-	PR_INFO("  byte 4:res=%d redirect=%d res2=%d src_sub_inf_id=%d\n",
+	pr_info("  byte 4:res=%d redirect=%d res2=%d src_sub_inf_id=%d\n",
 		pmac->res3, pmac->redirect, pmac->res4, pmac->src_sub_inf_id);
 	/*byte 5 */
-	PR_INFO("  byte 5:src_sub_inf_id2=%d\n", pmac->src_sub_inf_id2);
+	pr_info("  byte 5:src_sub_inf_id2=%d\n", pmac->src_sub_inf_id2);
 	/*byte 6 */
-	PR_INFO("  byte 6:port_map=%d\n", pmac->port_map);
+	pr_info("  byte 6:port_map=%d\n", pmac->port_map);
 	/*byte 7 */
-	PR_INFO("  byte 7:port_map2=%d\n", pmac->port_map2);
+	pr_info("  byte 7:port_map2=%d\n", pmac->port_map2);
 }
 
 static void dump_tx_pmac(struct pmac_tx_hdr *pmac)
@@ -368,7 +368,7 @@ static void dump_tx_pmac(struct pmac_tx_hdr *pmac)
 	unsigned char buf[100];
 
 	if (!pmac) {
-		PR_ERR("dump_tx_pmac pmac NULL ??\n");
+		pr_err("dump_tx_pmac pmac NULL ??\n");
 		return;
 	}
 
@@ -376,31 +376,31 @@ static void dump_tx_pmac(struct pmac_tx_hdr *pmac)
 	for (i = 0; i < 8; i++)
 		l += sprintf(buf + l, "0x%02x ", p[i]);
 	sprintf(buf + l, "\n");
-	PR_INFO("%s", buf);
+	pr_info("%s", buf);
 	/*byte 0 */
-	PR_INFO("  byte 0:tcp_chksum=%d res=%d ip_offset=%d\n",
+	pr_info("  byte 0:tcp_chksum=%d res=%d ip_offset=%d\n",
 		pmac->tcp_chksum, pmac->res1, pmac->ip_offset);
 	/*byte 1 */
-	PR_INFO("  byte 1:tcp_h_offset=%d tcp_type=%d\n", pmac->tcp_h_offset,
+	pr_info("  byte 1:tcp_h_offset=%d tcp_type=%d\n", pmac->tcp_h_offset,
 		pmac->tcp_type);
 	/*byte 2 */
-	PR_INFO("  byte 2:ppid=%d res=%d\n", pmac->sppid, pmac->res);
+	pr_info("  byte 2:ppid=%d res=%d\n", pmac->sppid, pmac->res);
 	/*byte 3 */
-	PR_INFO("  byte 3:%s=%d %s=%d/%d time_dis=%d class_en=%d pkt_type=%d\n",
+	pr_info("  byte 3:%s=%d %s=%d/%d time_dis=%d class_en=%d pkt_type=%d\n",
 		"map_en", pmac->port_map_en,
 		"res", pmac->res2, pmac->res3,
 		pmac->time_dis, pmac->class_en,
 		pmac->pkt_type);
 	/*byte 4 */
-	PR_INFO("  byte 4:fcs_ins_dis=%d redirect=%d time_stmp=%d subif=%d\n",
+	pr_info("  byte 4:fcs_ins_dis=%d redirect=%d time_stmp=%d subif=%d\n",
 		pmac->fcs_ins_dis, pmac->redirect, pmac->time_stmp,
 		pmac->src_sub_inf_id);
 	/*byte 5 */
-	PR_INFO("  byte 5:src_sub_inf_id2=%d\n", pmac->src_sub_inf_id2);
+	pr_info("  byte 5:src_sub_inf_id2=%d\n", pmac->src_sub_inf_id2);
 	/*byte 6 */
-	PR_INFO("  byte 6:port_map=%d\n", pmac->port_map);
+	pr_info("  byte 6:port_map=%d\n", pmac->port_map);
 	/*byte 7 */
-	PR_INFO("  byte 7:port_map2=%d\n", pmac->port_map2);
+	pr_info("  byte 7:port_map2=%d\n", pmac->port_map2);
 }
 
 static void mib_init(u32 flag)
@@ -435,7 +435,7 @@ static int dp_platform_set(int inst, u32 flag)
 
 	if (!dp_port_prop[inst].ops[0] ||
 	    !dp_port_prop[inst].ops[1]) {
-		PR_ERR("Why gswip handle zero?\n");
+		pr_err("Why gswip handle zero?\n");
 		return -1;
 	}
 		if (!inst)
@@ -516,18 +516,18 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 	struct pmac_port_info *port_info;
 
 	if (!data || !data->subif_data) {
-		PR_ERR("data NULL or subif_data NULL\n");
+		pr_err("data NULL or subif_data NULL\n");
 		return -1;
 	}
 	if (!dp_dma_chan_tbl[inst]) {
-		PR_ERR("dp_dma_chan_tbl[%d] NULL\n", inst);
+		pr_err("dp_dma_chan_tbl[%d] NULL\n", inst);
 		return DP_FAILURE;
 	}
 	port_info = get_dp_port_info(inst, portid);
 	if (data->subif_data)
 		deq_port_idx = data->subif_data->deq_port_idx;
 	if (port_info->deq_port_num < deq_port_idx + 1) {
-		PR_ERR("Wrong deq_port_idx(%d), should < %d\n",
+		pr_err("Wrong deq_port_idx(%d), should < %d\n",
 		       deq_port_idx, port_info->deq_port_num);
 		return -1;
 	}
@@ -552,25 +552,25 @@ static int subif_hw_reset(int inst, int portid, int subif_ix,
 	struct pmac_port_info *port_info;
 
 	if (!data || !data->subif_data) {
-		PR_ERR("data NULL or subif_data NULL\n");
+		pr_err("data NULL or subif_data NULL\n");
 		return -1;
 	}
 	if (!dp_dma_chan_tbl[inst]) {
-		PR_ERR("dp_dma_chan_tbl[%d] NULL\n", inst);
+		pr_err("dp_dma_chan_tbl[%d] NULL\n", inst);
 		return DP_FAILURE;
 	}
 	port_info = get_dp_port_info(inst, portid);
 	if (data->subif_data)
 		deq_port_idx = data->subif_data->deq_port_idx;
 	if (port_info->deq_port_num < deq_port_idx + 1) {
-		PR_ERR("Wrong deq_port_idx(%d), should < %d\n",
+		pr_err("Wrong deq_port_idx(%d), should < %d\n",
 		       deq_port_idx, port_info->deq_port_num);
 		return -1;
 	}
 	cqe_deq = port_info->deq_port_base + deq_port_idx;
 	dma_ch_offset = dp_deq_port_tbl[inst][cqe_deq].dma_ch_offset;
 	if (!dp_deq_port_tbl[inst][cqe_deq].ref_cnt) {
-		PR_ERR("Wrong cbm[%d].ref_cnt=%d\n",
+		pr_err("Wrong cbm[%d].ref_cnt=%d\n",
 		       cqe_deq,
 		       dp_deq_port_tbl[inst][cqe_deq].ref_cnt);
 		return -1;
@@ -717,7 +717,7 @@ int register_dp_cap_gswip30(int flag)
 	cap.info.cap.max_num_bridge_port = 0;
 
 	if (register_dp_hw_cap(&cap, flag)) {
-		PR_ERR("Why register_dp_hw_cap fail\n");
+		pr_err("Why register_dp_hw_cap fail\n");
 		return -1;
 	}
 
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_proc.c b/drivers/net/datapath/dpm/gswip30/datapath_proc.c
index 5b7ee2899fa8..9b27d51a034c 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_proc.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_proc.c
@@ -269,9 +269,9 @@ static ssize_t proc_parser_write(struct file *file, const char *buf,
 	} else if (dp_strncmpi(param_list[0], "refresh",
 			       strlen("refresh")) == 0) {
 		dp_get_gsw_parser_30(NULL, NULL, NULL, NULL);
-		PR_INFO("value:cpu=%d mpe1=%d mpe2=%d mpe3=%d\n", pinfo[0].v,
+		pr_info("value:cpu=%d mpe1=%d mpe2=%d mpe3=%d\n", pinfo[0].v,
 			pinfo[1].v, pinfo[2].v, pinfo[3].v);
-		PR_INFO("size :cpu=%d mpe1=%d mpe2=%d mpe3=%d\n",
+		pr_info("size :cpu=%d mpe1=%d mpe2=%d mpe3=%d\n",
 			pinfo[0].size, pinfo[1].size, pinfo[2].size,
 			pinfo[3].size);
 		return count;
@@ -282,7 +282,7 @@ static ssize_t proc_parser_write(struct file *file, const char *buf,
 			flag = 0;
 		else if (flag > 3)
 			flag = 3;
-		PR_INFO("eProcessPath_Action set to %d\n", flag);
+		pr_info("eProcessPath_Action set to %d\n", flag);
 		/*: All packets set to same mpe flag as specified */
 		memset(&pce, 0, sizeof(pce));
 		pce.pattern.nIndex = pce_rule_id;
@@ -309,7 +309,7 @@ static ssize_t proc_parser_write(struct file *file, const char *buf,
 		pce.action.nRMON_Id = 0;	/*RMON_UDP_CNTR; */
 
 		if (gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, &pce)) {
-			PR_ERR("PCE rule add fail for GSW_PCE_RULE_WRITE\n");
+			pr_err("PCE rule add fail for GSW_PCE_RULE_WRITE\n");
 			return count;
 		}
 
@@ -322,17 +322,17 @@ static ssize_t proc_parser_write(struct file *file, const char *buf,
 		pce.pattern.nIndex = pce_rule_id;
 		pce.pattern.bEnable = 0;
 		if (gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, &pce)) {
-			PR_ERR("PCE rule add fail for GSW_PCE_RULE_WRITE\n");
+			pr_err("PCE rule add fail for GSW_PCE_RULE_WRITE\n");
 			return count;
 		}
 	} else {
-		PR_INFO("Usage: echo %s > parser\n",
+		pr_info("Usage: echo %s > parser\n",
 			"<enable/disable> [cpu] [mpe1] [mpe2] [mpe3]");
-		PR_INFO("Usage: echo <refresh> parser\n");
+		pr_info("Usage: echo <refresh> parser\n");
 
-		PR_INFO("Usage: echo %s > parser\n",
+		pr_info("Usage: echo %s > parser\n",
 			" mark eProcessPath_Action_value(0~3)");
-		PR_INFO("Usage: echo unmark > parser\n");
+		pr_info("Usage: echo unmark > parser\n");
 		return count;
 	}
 
@@ -694,7 +694,7 @@ static int proc_gsw_port_rmon_dump(struct seq_file *s, int pos)
 			ret = rmon->RMON_Port_Get(gsw_handle,
 						  &gsw_r_rmon_mib[i]);
 			if (ret != GSW_statusOk) {
-				PR_ERR("RMON_PORT_GET fail for Port %d\n", i);
+				pr_err("RMON_PORT_GET fail for Port %d\n", i);
 				return -1;
 			}
 		}
@@ -704,7 +704,7 @@ static int proc_gsw_port_rmon_dump(struct seq_file *s, int pos)
 		ret = rmon->RMON_Redirect_Get(gsw_handle, &gswr_rmon_redirect);
 
 		if (ret != GSW_statusOk) {
-			PR_ERR("GSW_RMON_REDIRECT_GET fail for Port %d\n", i);
+			pr_err("GSW_RMON_REDIRECT_GET fail for Port %d\n", i);
 			return -1;
 		}
 
@@ -716,7 +716,7 @@ static int proc_gsw_port_rmon_dump(struct seq_file *s, int pos)
 			ret = rmon->RMON_Port_Get(gsw_handle,
 						  &gsw_l_rmon_mib[i]);
 			if (ret != GSW_statusOk) {
-				PR_ERR("RMON_PORT_GET fail for Port %d\n", i);
+				pr_err("RMON_PORT_GET fail for Port %d\n", i);
 				return -1;
 			}
 		}
@@ -994,11 +994,11 @@ static ssize_t proc_gsw_rmon_write(struct file *file, const char *buf,
 	return count;
 
 help:
-	PR_INFO("usage: echo clear > /proc/dp/rmon\n");
-	PR_INFO("usage: echo TMU on > /proc/dp/rmon\n");
-	PR_INFO("usage: echo TMU off > /proc/dp/rmon\n");
-	PR_INFO("usage: echo RMON Full > /proc/dp/rmon\n");
-	PR_INFO("usage: echo RMON Basic > /proc/dp/rmon\n");
+	pr_info("usage: echo clear > /proc/dp/rmon\n");
+	pr_info("usage: echo TMU on > /proc/dp/rmon\n");
+	pr_info("usage: echo TMU off > /proc/dp/rmon\n");
+	pr_info("usage: echo RMON Full > /proc/dp/rmon\n");
+	pr_info("usage: echo RMON Basic > /proc/dp/rmon\n");
 	return count;
 }
 
@@ -1085,7 +1085,7 @@ static void pmac_eg_cfg(char *param_list[], int num, dp_pmac_cfg_t *pmac_cfg)
 					value = dp_atoi(param_list[i + 1]);
 					egress_entries[j].egress_callback(
 							pmac_cfg, value);
-					PR_INFO("egress pmac ep %s config ok\n",
+					pr_info("egress pmac ep %s config ok\n",
 						egress_entries[j].name);
 					break;
 				}
@@ -1095,7 +1095,7 @@ static void pmac_eg_cfg(char *param_list[], int num, dp_pmac_cfg_t *pmac_cfg)
 				value = dp_atoi(param_list[i + 1]);
 				egress_entries[j].egress_callback(pmac_cfg,
 								value);
-				PR_INFO("egress pmac ep %s configu ok\n",
+				pr_info("egress pmac ep %s configu ok\n",
 					egress_entries[j].name);
 				break;
 			}
@@ -1135,7 +1135,7 @@ ssize_t ep_port_write(struct file *file, const char *buf, size_t count,
 					value = dp_atoi(param_list[i + 1]);
 					ingress_entries[j].ingress_callback(
 							&pmac_cfg, value);
-					PR_INFO("ingress pmac ep %s configed\n",
+					pr_info("ingress pmac ep %s configed\n",
 						ingress_entries[j].name);
 					break;
 				}
@@ -1145,7 +1145,7 @@ ssize_t ep_port_write(struct file *file, const char *buf, size_t count,
 		ret = dp_pmac_set_30(inst, port, &pmac_cfg);
 
 		if (ret != 0) {
-			PR_ERR("pmac set configuration failed\n");
+			pr_err("pmac set configuration failed\n");
 			return -1;
 		}
 	} else if (dp_strncmpi(param_list[0], "egress", 6) == 0) {
@@ -1155,28 +1155,28 @@ ssize_t ep_port_write(struct file *file, const char *buf, size_t count,
 		ret = dp_pmac_set_30(inst, port, &pmac_cfg);
 
 		if (ret != 0) {
-			PR_ERR("pmac set configuration failed\n");
+			pr_err("pmac set configuration failed\n");
 			return -1;
 		}
 	} else {
-		PR_INFO("wrong command\n");
+		pr_info("wrong command\n");
 		goto help;
 	}
 
 	return count;
 help:
-	PR_INFO("echo ingress/egress [ep_port] %s > /proc/dp/ep\n",
+	pr_info("echo ingress/egress [ep_port] %s > /proc/dp/ep\n",
 		"['ingress/egress fields'] [value]");
-	PR_INFO("(eg) echo ingress 1 pmac 1 > /proc/dp/ep\n");
-	PR_INFO("(eg) echo egress 1 rm_l2hdr 2 > /proc/dp/ep\n");
-	PR_INFO("echo %s ['errdisc/pmac/pmac_pmap/pmac_en_pmap/pmac_tc",
+	pr_info("(eg) echo ingress 1 pmac 1 > /proc/dp/ep\n");
+	pr_info("(eg) echo egress 1 rm_l2hdr 2 > /proc/dp/ep\n");
+	pr_info("echo %s ['errdisc/pmac/pmac_pmap/pmac_en_pmap/pmac_tc",
 		"ingress [ep_port] ");
-	PR_INFO("                         %s > /proc/dp/ep\n",
+	pr_info("                         %s > /proc/dp/ep\n",
 		"/pmac_en_tc/pmac_subifid/pmac_srcport'] [value]");
-	PR_INFO("echo  %s %s> /proc/dp/ep\n",
+	pr_info("echo  %s %s> /proc/dp/ep\n",
 		"egress [ep_port]",
 		"['rx_dmachan/fcs/pmac/res_dw1/res1_dw0/res2_dw0] [value]");
-	PR_INFO("echo egress [ep_port] ['rm_l2hdr'] [value] > /proc/dp/ep\n");
+	pr_info("echo egress [ep_port] ['rm_l2hdr'] [value] > /proc/dp/ep\n");
 	return count;
 }
 
@@ -1201,13 +1201,13 @@ int dp_sub_proc_install_30(void)
 	int i;
 
 	if (!dp_proc_node) {
-		PR_INFO("dp_sub_proc_install failed\n");
+		pr_info("dp_sub_proc_install failed\n");
 		return 0;
 	}
 
 	for (i = 0; i < ARRAY_SIZE(dp_proc_entries); i++)
 		dp_proc_entry_create(dp_proc_node, &dp_proc_entries[i]);
-	PR_INFO("dp_sub_proc_install ok\n");
+	pr_info("dp_sub_proc_install ok\n");
 	return 0;
 }
 
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_rx.c b/drivers/net/datapath/dpm/gswip30/datapath_rx.c
index 3cb6a46f2de7..197dffebc291 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_rx.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_rx.c
@@ -62,7 +62,7 @@ static void rx_dbg_zero_port(struct sk_buff *skb, struct dma_rx_desc_0 *desc0,
 	last = jiffies;
 	DP_DEBUG(-1, "%s=%d vap=%d\n",
 		 (ep) ? "ep" : "port_id", port_id, vap);
-	PR_ERR("\nDrop for ep and source port id both zero ??\n");
+	pr_err("\nDrop for ep and source port id both zero ??\n");
 	dp_port_prop[inst].info.dump_rx_dma_desc(desc0, desc1, desc2, desc3);
 
 	if (paser_exist)
@@ -101,7 +101,7 @@ static int dp_handle_lct(struct pmac_port_info *dp_port,
 		}
 		lct_skb = skb_clone(skb, GFP_ATOMIC);
 		if (!lct_skb) {
-			PR_ERR("LCT mcast/bcast skb clone fail\n");
+			pr_err("LCT mcast/bcast skb clone fail\n");
 			return -1;
 		}
 		lct_skb->dev = sif->netif;
@@ -154,11 +154,11 @@ int32_t dp_rx_30(struct sk_buff *skb, u32 flags)
 
 	dp_port = get_dp_port_info(inst, 0);
 	if (!skb) {
-		PR_ERR("skb NULL\n");
+		pr_err("skb NULL\n");
 		return DP_FAILURE;
 	}
 	if (!skb->data) {
-		PR_ERR("skb->data NULL\n");
+		pr_err("skb->data NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -306,7 +306,7 @@ int32_t dp_rx_30(struct sk_buff *skb, u32 flags)
 
 	if (unlikely(port_id >=
 	    dp_port_prop[inst].info.cap.max_num_dp_ports - 1)) {
-		PR_ERR("Drop for wrong ep or src port id=%u ??\n",
+		pr_err("Drop for wrong ep or src port id=%u ??\n",
 		       port_id);
 		goto RX_DROP;
 	} else if (unlikely(dp_port->status == PORT_FREE)) {
diff --git a/drivers/net/datapath/dpm/gswip30/datapath_tx.c b/drivers/net/datapath/dpm/gswip30/datapath_tx.c
index 3b820a202edc..ab0062908154 100644
--- a/drivers/net/datapath/dpm/gswip30/datapath_tx.c
+++ b/drivers/net/datapath/dpm/gswip30/datapath_tx.c
@@ -384,46 +384,46 @@ int32_t dp_xmit_30(struct net_device *rx_if, dp_subif_t *rx_subif,
 lbl_err_ret:
 	switch (err_ret) {
 	case DP_XMIT_ERR_NOT_INIT:
-		PR_RATELIMITED("dp_xmit failed for dp no init yet\n");
+		printk_ratelimited("dp_xmit failed for dp no init yet\n");
 		break;
 	case DP_XMIT_ERR_IN_IRQ:
-		PR_RATELIMITED("dp_xmit not allowed in interrupt context\n");
+		printk_ratelimited("dp_xmit not allowed in interrupt context\n");
 		break;
 	case DP_XMIT_ERR_NULL_SUBIF:
-		PR_RATELIMITED("dp_xmit failed for rx_subif null\n");
+		printk_ratelimited("dp_xmit failed for rx_subif null\n");
 		UP_STATS(get_dp_port_info(inst, 0)->tx_err_drop);
 		break;
 	case DP_XMIT_ERR_PORT_TOO_BIG:
 		UP_STATS(get_dp_port_info(inst, 0)->tx_err_drop);
-		PR_RATELIMITED("rx_subif->port_id >= max_ports");
+		printk_ratelimited("rx_subif->port_id >= max_ports");
 		break;
 	case DP_XMIT_ERR_NULL_SKB:
-		PR_RATELIMITED("skb NULL");
+		printk_ratelimited("skb NULL");
 		UP_STATS(get_dp_port_info(inst,
 					  rx_subif->port_id)->tx_err_drop);
 		break;
 	case DP_XMIT_ERR_NULL_IF:
 		UP_STATS(mib->tx_pkt_dropped);
-		PR_RATELIMITED("rx_if NULL");
+		printk_ratelimited("rx_if NULL");
 		break;
 	case DP_XMIT_ERR_REALLOC_SKB:
-		PR_INFO_ONCE("dp_create_new_skb failed\n");
+		pr_info_once("dp_create_new_skb failed\n");
 		break;
 	case DP_XMIT_ERR_EP_ZERO:
-		PR_ERR("Why ep zero in dp_xmit for %s\n",
+		pr_err("Why ep zero in dp_xmit for %s\n",
 		       skb->dev ? skb->dev->name : "NULL");
 		break;
 	case DP_XMIT_ERR_GSO_NOHEADROOM:
-		PR_ERR("No enough skb headerroom(GSO). Need tune SKB buffer\n");
+		pr_err("No enough skb headerroom(GSO). Need tune SKB buffer\n");
 		break;
 	case DP_XMIT_ERR_CSM_NO_SUPPORT:
-		PR_RATELIMITED("dp_xmit not support checksum\n");
+		printk_ratelimited("dp_xmit not support checksum\n");
 		break;
 	case DP_XMIT_PTP_ERR:
 		break;
 	default:
 		UP_STATS(mib->tx_pkt_dropped);
-		PR_INFO_ONCE("Why come to here:%x\n", dp_info->status);
+		pr_info_once("Why come to here:%x\n", dp_info->status);
 	}
 	if (skb)
 		dev_kfree_skb_any(skb);
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_ext_vlan.c b/drivers/net/datapath/dpm/gswip31/datapath_ext_vlan.c
index fc19a60327d0..9e7590a357be 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_ext_vlan.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_ext_vlan.c
@@ -245,7 +245,7 @@ static int update_ctp(struct core_ops *ops, struct ext_vlan_info *vlan)
 		ctp.bIngressExtendedVlanEnable = LTQ_FALSE;
 		ret = ops->gsw_ctp_ops.CTP_PortConfigSet(ops, &ctp);
 		if (ret != GSW_statusOk) {
-			PR_ERR("Fail:Ingress VLAN operate disable in ctp\n");
+			pr_err("Fail:Ingress VLAN operate disable in ctp\n");
 			return -EIO;
 		}
 		DP_DEBUG(DP_DBG_FLAG_SWDEV,
@@ -377,7 +377,7 @@ static int bp_add_vlan1(struct core_ops *ops, struct vlan1 *vlan,
 		ret = ops->gsw_extvlan_ops.ExtendedVlan_Set(ops, vcfg);
 
 		if (ret != GSW_statusOk) {
-			PR_ERR("Fail updating Extended VLAN entry (%u, %u).\n",
+			pr_err("Fail updating Extended VLAN entry (%u, %u).\n",
 			       alloc.nExtendedVlanBlockId, i);
 			ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 			return -EIO;
@@ -390,7 +390,7 @@ static int bp_add_vlan1(struct core_ops *ops, struct vlan1 *vlan,
 	ret = ops->gsw_brdgport_ops.BridgePort_ConfigSet(ops, bpcfg);
 
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed in attaching Extended VLAN to Bridge Port.\n");
+		pr_err("Failed in attaching Extended VLAN to Bridge Port.\n");
 		ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 		return -EIO;
 	} else {
@@ -466,7 +466,7 @@ static int bp_add_vlan2(struct core_ops *ops, struct vlan2 *vlan,
 		ret = ops->gsw_extvlan_ops.ExtendedVlan_Set(ops, vcfg);
 
 		if (ret != GSW_statusOk) {
-			PR_ERR("Fail updating Extended VLAN entry (%u, %u).\n",
+			pr_err("Fail updating Extended VLAN entry (%u, %u).\n",
 			       alloc.nExtendedVlanBlockId, i);
 			ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 			return -EIO;
@@ -479,7 +479,7 @@ static int bp_add_vlan2(struct core_ops *ops, struct vlan2 *vlan,
 	ret = ops->gsw_brdgport_ops.BridgePort_ConfigSet(ops, bpcfg);
 
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed in attaching Extended VLAN to Bridge Port.\n");
+		pr_err("Failed in attaching Extended VLAN to Bridge Port.\n");
 		ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 		return -EIO;
 	} else {
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
index cefbdf318f36..4b35e0123703 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_gswip.c
@@ -94,7 +94,7 @@ int dp_pmac_set_31(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 	struct core_ops *gswr_r;
 
 	if (!pmac_cfg || !port) {
-		PR_ERR("dp_pmac_set:wrong parameter(pmac_cfg/port NULL)\n");
+		pr_err("dp_pmac_set:wrong parameter(pmac_cfg/port NULL)\n");
 		return -1;
 	}
 
@@ -115,7 +115,7 @@ int dp_pmac_set_31(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 		ret = cbm_dequeue_port_resources_get(port, &dqport, flag);
 
 		if (ret == -1) {
-			PR_ERR("cbm_dequeue_port_resources_get failed\n");
+			pr_err("cbm_dequeue_port_resources_get failed\n");
 			return -1;
 		}
 
@@ -402,7 +402,7 @@ int dp_set_gsw_parser_31(u8 flag, u8 cpu, u8 mpe1,
 	struct core_ops *gsw_handle = dp_port_prop[0].ops[0];/*gswip o */
 
 	if (gsw_handle->gsw_common_ops.CPU_PortCfgGet(gsw_handle, &param)) {
-		PR_ERR("Failed GSW_CPU_PORT_CFG_GET\n");
+		pr_err("Failed GSW_CPU_PORT_CFG_GET\n");
 		return -1;
 	}
 	DP_DEBUG(DP_DBG_FLAG_DBG, "old flag=0x%x cpu=%d mpe1/2/3=%d/%d/%d\n",
@@ -424,7 +424,7 @@ int dp_set_gsw_parser_31(u8 flag, u8 cpu, u8 mpe1,
 		param.eMPE1MPE2ParserCfg = mpe3;
 
 	if (gsw_handle->gsw_common_ops.CPU_PortCfgSet(gsw_handle, &param)) {
-		PR_ERR("Failed GSW_CPU_PORT_CFG_SET\n");
+		pr_err("Failed GSW_CPU_PORT_CFG_SET\n");
 		return -1;
 	}
 	memset(&reg, 0, sizeof(reg));
@@ -447,7 +447,7 @@ int dp_get_gsw_parser_31(u8 *cpu, u8 *mpe1, u8 *mpe2,
 	struct core_ops *gsw_handle = dp_port_prop[0].ops[0]; /*gswip 0*/
 
 	if (gsw_handle->gsw_common_ops.CPU_PortCfgGet(gsw_handle, &param)) {
-		PR_ERR("Failed GSW_CPU_PORT_CFG_GET\n");
+		pr_err("Failed GSW_CPU_PORT_CFG_GET\n");
 		return -1;
 	}
 	dp_parser_info_refresh(param.eNoMPEParserCfg,
@@ -488,7 +488,7 @@ int gsw_mib_reset_31(int dev, u32 flag)
 	ret = gsw_handle->gsw_rmon_ops.RMON_Clear(gsw_handle, &rmon_clear);
 
 	if (ret != GSW_statusOk) {
-		PR_ERR("R:GSW_RMON_CLEAR failed for GSW_RMON_ALL_TYPE\n");
+		pr_err("R:GSW_RMON_CLEAR failed for GSW_RMON_ALL_TYPE\n");
 		return -1;
 	}
 	return ret;
@@ -512,13 +512,13 @@ struct gsw_itf *ctp_port_assign(int inst, u8 ep, int bp_default,
 	alloc_flag = port_info->alloc_flags;
 
 	if (flags & DP_F_DEREGISTER) {
-		PR_ERR("Need to Free CTP Port here for ep=%d\n", ep);
+		pr_err("Need to Free CTP Port here for ep=%d\n", ep);
 		ctp_assign.nLogicalPortId = ep;
 		ctp_assign.eMode = itf_assign[ep].mode;
 		ctp_assign.nFirstCtpPortId = itf_assign[ep].start;
 		ctp_assign.nNumberOfCtpPort = itf_assign[ep].n;
 		if (gsw_ctp->CTP_PortAssignmentFree(gsw_handle, &ctp_assign)) {
-			PR_ERR("Failed to allc CTP for ep=%d blk=%d mode=%d\n",
+			pr_err("Failed to allc CTP for ep=%d blk=%d mode=%d\n",
 			       ep, assign->num, assign->emode);
 			return NULL;
 		}
@@ -542,7 +542,7 @@ struct gsw_itf *ctp_port_assign(int inst, u8 ep, int bp_default,
 	ctp_assign.nFirstCtpPortId = 0;
 	ctp_assign.nNumberOfCtpPort = num;
 	if (gsw_ctp->CTP_PortAssignmentAlloc(gsw_handle, &ctp_assign)) {
-		PR_ERR("Failed CTP Assignment for ep=%d blk size=%d mode=%s\n",
+		pr_err("Failed CTP Assignment for ep=%d blk size=%d mode=%s\n",
 		       ep, num, ctp_mode_string(assign->emode));
 		return NULL;
 	}
@@ -601,7 +601,7 @@ int alloc_bridge_port(int inst, int port_id, int subif_ix,
 	ret = gsw_bp->BridgePort_Alloc(gsw_handle, &bp);
 	if ((ret != GSW_statusOk) ||
 	    (bp.nBridgePortId < 0)) {
-		PR_ERR("Failed to get a bridge port\n");
+		pr_err("Failed to get a bridge port\n");
 		return -1;
 	}
 	/*set this new bridge port with specified bridge ID(fid)
@@ -627,7 +627,7 @@ int alloc_bridge_port(int inst, int port_id, int subif_ix,
 	SET_BP_MAP(bp_cfg.nBridgePortMap, bp_member); /*CPU*/
 	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed to set bridge id(%d) and port map for bp= %d\n",
+		pr_err("Failed to set bridge id(%d) and port map for bp= %d\n",
 		       fid, bp_cfg.nBridgePortId);
 		gsw_bp->BridgePort_Free(gsw_handle, &bp);
 		return -1;
@@ -640,7 +640,7 @@ int alloc_bridge_port(int inst, int port_id, int subif_ix,
 	bp_cfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed to get bridge port's member for bridgeport=%d\n",
+		pr_err("Failed to get bridge port's member for bridgeport=%d\n",
 		       bp_cfg.nBridgePortId);
 		gsw_bp->BridgePort_Free(gsw_handle, &bp);
 		return -1;
@@ -648,7 +648,7 @@ int alloc_bridge_port(int inst, int port_id, int subif_ix,
 	SET_BP_MAP(bp_cfg.nBridgePortMap, bp.nBridgePortId);
 	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed to set bridge port's member for bridgeport=%d\n",
+		pr_err("Failed to set bridge port's member for bridgeport=%d\n",
 		       bp_cfg.nBridgePortId);
 		gsw_bp->BridgePort_Free(gsw_handle, &bp);
 		return -1;
@@ -685,7 +685,7 @@ int free_bridge_port(int inst, int bp)
 	tmp->eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, tmp);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_GET: %d\n", bp);
+		pr_err("Failed GSW_BRIDGE_PORT_CONFIG_GET: %d\n", bp);
 		goto EXIT;
 	}
 	/*remove this delting bridgeport from other bridge port's member*/
@@ -700,13 +700,13 @@ int free_bridge_port(int inst, int bp)
 			tmp2->nBridgePortId = i * 16 + j;
 			ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, tmp2);
 			if (ret != GSW_statusOk) {
-				PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_GET\n");
+				pr_err("Failed GSW_BRIDGE_PORT_CONFIG_GET\n");
 				goto EXIT;
 			}
 			UNSET_BP_MAP(tmp2->nBridgePortMap, bp);
 			ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, tmp2);
 			if (ret != GSW_statusOk) {
-				PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_SET\n");
+				pr_err("Failed GSW_BRIDGE_PORT_CONFIG_SET\n");
 				goto EXIT;
 			}
 		}
@@ -719,7 +719,7 @@ int free_bridge_port(int inst, int bp)
 	ret = gsw_bp->BridgePort_Free(gsw_handle,
 				      (GSW_BRIDGE_portAlloc_t *)tmp);
 	if (ret != GSW_statusOk)
-		PR_ERR("Failed to GSW_BRIDGE_PORT_FREE:%d\n", bp);
+		pr_err("Failed to GSW_BRIDGE_PORT_FREE:%d\n", bp);
 FREE_EXIT:
 	kfree(tmp);
 	kfree(tmp2);
@@ -742,7 +742,7 @@ int dp_gswip_mac_entry_add(int bport, int fid, int inst, u8 *addr)
 	memcpy(tmp.nMAC, addr, GSW_MAC_ADDR_LEN);
 	ret = gsw_handle->gsw_swmac_ops.MAC_TableEntryAdd(gsw_handle, &tmp);
 	if (ret != GSW_statusOk) {
-		PR_ERR("fail in setting MAC table static add entry\r\n");
+		pr_err("fail in setting MAC table static add entry\r\n");
 		return -1;
 	}
 	return 0;
@@ -764,14 +764,14 @@ int dp_gswip_mac_entry_del(int bport, int fid, int inst, u8 *addr)
 	memcpy(mac_query.nMAC, addr, GSW_MAC_ADDR_LEN);
 	ret = gsw_swmac->MAC_TableEntryQuery(gsw_handle, &mac_query);
 	if (ret != GSW_statusOk) {
-		PR_ERR("fail in getting MAC query entry\r\n");
+		pr_err("fail in getting MAC query entry\r\n");
 		return -1;
 	}
 	tmp.nFId = fid;
 	memcpy(tmp.nMAC, addr, GSW_MAC_ADDR_LEN);
 	ret = gsw_swmac->MAC_TableEntryRemove(gsw_handle, &tmp);
 	if (ret != GSW_statusOk) {
-		PR_ERR("fail in setting MAC static entry remove\r\n");
+		pr_err("fail in setting MAC static entry remove\r\n");
 		return -1;
 	}
 	return 0;
@@ -788,14 +788,14 @@ int cpu_vlan_mod_dis(int inst)
 	cfg.nPortId = 0;
 	ret = ops->gsw_qos_ops.QoS_PortRemarkingCfgGet(ops, &cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("QoS_PortRemarkingCfgGet failed\n");
+		pr_err("QoS_PortRemarkingCfgGet failed\n");
 		return -1;
 	}
 
 	cfg.bPCP_EgressRemarkingEnable = LTQ_FALSE;
 	ret = ops->gsw_qos_ops.QoS_PortRemarkingCfgSet(ops, &cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("QoS_PortRemarkingCfgSet failed\n");
+		pr_err("QoS_PortRemarkingCfgSet failed\n");
 		return -1;
 	}
 
@@ -861,7 +861,7 @@ int dp_set_gsw_pmapper_31(int inst, int bport, int lport,
 		 bp_cfg.eMask);
 	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("fail in setting pmapper\r\n");
+		pr_err("fail in setting pmapper\r\n");
 		return -1;
 	}
 	return 0;
@@ -891,7 +891,7 @@ int dp_get_gsw_pmapper_31(int inst, int bport, int lport,
 
 	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("fail in getting pmapper\r\n");
+		pr_err("fail in getting pmapper\r\n");
 		return -1;
 	}
 
@@ -900,7 +900,7 @@ int dp_get_gsw_pmapper_31(int inst, int bport, int lport,
 		 bp_cfg.ePmapperMappingMode, bp_cfg.bPmapperEnable);
 
 	if (!bp_cfg.bPmapperEnable) {
-		PR_ERR("pmapper not enabled\r\n");
+		pr_err("pmapper not enabled\r\n");
 		return -1;
 	}
 	mapper->pmapper_id = bp_cfg.sPmapper.nPmapperId;
@@ -940,16 +940,16 @@ int dp_meter_alloc_31(int inst, int *meterid, int flag)
 	GSW_return_t ret;
 
 	if (inst < 0) {
-		PR_ERR("inst invalid\n");
+		pr_err("inst invalid\n");
 		return -1;
 	}
 	if (!meterid) {
-		PR_ERR("meterid NULL\n");
+		pr_err("meterid NULL\n");
 		return -1;
 	}
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
 	if (!gsw_handle) {
-		PR_ERR("gsw_handle NULL\n");
+		pr_err("gsw_handle NULL\n");
 		return -1;
 	}
 	gsw_qos = &gsw_handle->gsw_qos_ops;
@@ -957,7 +957,7 @@ int dp_meter_alloc_31(int inst, int *meterid, int flag)
 		meter_cfg.nMeterId = *meterid;
 		ret = gsw_qos->QOS_MeterAlloc(gsw_handle, &meter_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("Meter dealloc failed: %d\n", ret);
+			pr_err("Meter dealloc failed: %d\n", ret);
 			return -1;
 		}
 		return 0;
@@ -965,7 +965,7 @@ int dp_meter_alloc_31(int inst, int *meterid, int flag)
 	memset(&meter_cfg, 0, sizeof(meter_cfg));
 	ret = gsw_qos->QOS_MeterAlloc(gsw_handle, &meter_cfg);
 	if ((ret != GSW_statusOk) || (meter_cfg.nMeterId < 0)) {
-		PR_ERR("Failed to get a meter alloc\n");
+		pr_err("Failed to get a meter alloc\n");
 		*meterid = -1;
 		return -1;
 	}
@@ -985,7 +985,7 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 	struct pmac_port_info *port_info;
 
 	if (!mtr_subif) {
-		PR_ERR("mtr_subif NULL\n");
+		pr_err("mtr_subif NULL\n");
 		return -1;
 	}
 	memset(&bp_cfg, 0, sizeof(GSW_BRIDGE_portConfig_t));
@@ -997,7 +997,7 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	if (flag & DP_METER_ATTACH_CTP) {/* CTP port Flag */
 		if (mtr_subif->subif.flag_pmapper) {
-			PR_ERR("can't use CTP,pmapper is enable\n");
+			pr_err("can't use CTP,pmapper is enable\n");
 			return -1;
 		}
 		port_info = get_dp_port_info(mtr_subif->subif.inst,
@@ -1008,7 +1008,7 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 						 port_info->vap_mask);
 		ret = gsw_ctp->CTP_PortConfigGet(gsw_handle, &ctp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("PortConfigGet API failed :%d\n", ret);
+			pr_err("PortConfigGet API failed :%d\n", ret);
 			return -1;
 		}
 		if (meter->dir == DP_DIR_INGRESS) {
@@ -1030,35 +1030,35 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 		}
 		ret = gsw_ctp->CTP_PortConfigSet(gsw_handle, &ctp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("PortConfigSet API failed :%d\n", ret);
+			pr_err("PortConfigSet API failed :%d\n", ret);
 			return -1;
 		}
 	}
 	if (flag & DP_METER_ATTACH_BRPORT) {/*BRIDGE port Flag*/
 		if (!mtr_subif->subif.flag_bp) {
-			PR_ERR("flag_bp value 0\n");
+			pr_err("flag_bp value 0\n");
 			return -1;
 		}
 		bp_cfg.nBridgePortId = mtr_subif->subif.bport;
 		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &bp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("BridgePort_ConfigGet API failed :%d\n", ret);
+			pr_err("BridgePort_ConfigGet API failed :%d\n", ret);
 			return -1;
 		}
 		if (meter->dir == DP_DIR_EGRESS) {
-			PR_ERR("No Egress color marking for bridge port\n");
+			pr_err("No Egress color marking for bridge port\n");
 			return -1;
 		} else if (meter->dir == DP_DIR_INGRESS) {
 			bp_cfg.eMask =
 				GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_MARKING;
 			bp_cfg.eIngressMarkingMode = meter->mode;
 		} else {
-			PR_ERR(" invalid color mark dir\n");
+			pr_err(" invalid color mark dir\n");
 			return -1;
 		}
 		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &bp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("BridgePort_ConfigSet API failed :%d\n", ret);
+			pr_err("BridgePort_ConfigSet API failed :%d\n", ret);
 			return -1;
 		}
 	}
@@ -1083,7 +1083,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	int bret = 0;
 
 	if (!mtr_subif) {
-		PR_ERR("mtr_subif NULL\n");
+		pr_err("mtr_subif NULL\n");
 		return -1;
 	}
 	gsw_handle = dp_port_prop[mtr_subif->inst].ops[GSWIP_L];
@@ -1107,14 +1107,14 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	} else if (meter->type == trTCM) {
 		meter_cfg.eMtrType = GSW_QOS_Meter_trTCM;
 	} else {
-		PR_ERR(" invalid meter type\n");
+		pr_err(" invalid meter type\n");
 		return -1;
 	}
 	meter_cfg.nMeterId = meter->meter_id;
 	meter_cfg.nColourBlindMode = meter->col_mode;
 	ret = gsw_qos->QoS_MeterCfgSet(gsw_handle, &meter_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("MeterCfgSet API failed:%d\n", ret);
+		pr_err("MeterCfgSet API failed:%d\n", ret);
 		return -1;
 	}
 
@@ -1122,7 +1122,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		/* pattern setting */
 		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_ATOMIC);
 		if (!pce_rule) {
-			PR_ERR("ctp_cfg alloc failed\n");
+			pr_err("ctp_cfg alloc failed\n");
 			bret = -1;
 			goto err;
 		}
@@ -1133,7 +1133,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		pce_rule->action.nMeterId =  meter->meter_id;
 		ret = gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, pce_rule);
 		if (ret != GSW_statusOk) {
-			PR_ERR("PceRule Write API failed :%d\n", ret);
+			pr_err("PceRule Write API failed :%d\n", ret);
 			goto err;
 		}
 	}
@@ -1141,20 +1141,20 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		struct pmac_port_info *port_info;
 
 		if (mtr_subif->subif.flag_pmapper) {
-			PR_ERR("can't use CTP,pmapper is enable\n");
+			pr_err("can't use CTP,pmapper is enable\n");
 			bret = -1;
 			goto err;
 		}
 		ctp_cfg = kzalloc(sizeof(GSW_CTP_portConfig_t), GFP_ATOMIC);
 		if (!ctp_cfg) {
-			PR_ERR("ctp_cfg alloc failed\n");
+			pr_err("ctp_cfg alloc failed\n");
 			bret = -1;
 			goto err;
 		}
 		port_info = get_dp_port_info(mtr_subif->subif.inst,
 					     mtr_subif->subif.port_id);
 		if (!port_info) {
-			PR_ERR(" port_info is NULL\n");
+			pr_err(" port_info is NULL\n");
 			bret = -1;
 			goto err;
 		}
@@ -1164,7 +1164,7 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 						 port_info->vap_mask);
 		ret = gsw_ctp->CTP_PortConfigGet(gsw_handle, ctp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("PortConfigGet API failed :%d\n", ret);
+			pr_err("PortConfigGet API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
@@ -1177,32 +1177,32 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			ctp_cfg->bIngressMeteringEnable = 1;
 			ctp_cfg->nIngressTrafficMeterId =  meter->meter_id;
 		} else {
-			PR_ERR(" invalid meter dir\n");
+			pr_err(" invalid meter dir\n");
 			return -1;
 		}
 		ret = gsw_ctp->CTP_PortConfigSet(gsw_handle, ctp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("PortConfigSet API failed :%d\n", ret);
+			pr_err("PortConfigSet API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
 	}
 	if (flag & DP_METER_ATTACH_BRPORT) {/*BRIDGE port Flag*/
 		if (!mtr_subif->subif.flag_bp) {
-			PR_ERR("flag_bp value 0\n");
+			pr_err("flag_bp value 0\n");
 			bret = -1;
 			goto err;
 		}
 		bp_cfg = kzalloc(sizeof(GSW_BRIDGE_portConfig_t), GFP_ATOMIC);
 		if (!bp_cfg) {
-			PR_ERR("bp_cfg alloc failed\n");
+			pr_err("bp_cfg alloc failed\n");
 			bret = -1;
 			goto err;
 		}
 		bp_cfg->nBridgePortId = mtr_subif->subif.bport;
 		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, bp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("BridgePort_ConfigGet API failed :%d\n", ret);
+			pr_err("BridgePort_ConfigGet API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
@@ -1231,26 +1231,26 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			bp_cfg->bIngressMeteringEnable = 1;
 			bp_cfg->nIngressTrafficMeterId = meter->meter_id;
 		} else {
-			PR_ERR(" invalid meter dir\n");
+			pr_err(" invalid meter dir\n");
 			return -1;
 		}
 		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, bp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("BridgePort_ConfigSet API failed :%d\n", ret);
+			pr_err("BridgePort_ConfigSet API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
 	} else if (flag & DP_METER_ATTACH_BRIDGE) {
 		br_cfg = kzalloc(sizeof(GSW_BRIDGE_config_t), GFP_ATOMIC);
 		if (!br_cfg) {
-			PR_ERR("br_cfg alloc failed\n");
+			pr_err("br_cfg alloc failed\n");
 			bret = -1;
 			goto err;
 		}
 		br_cfg->nBridgeId = mtr_subif->fid;
 		ret = gsw_brdg->Bridge_ConfigGet(gsw_handle, br_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("Bridge_ConfigGet API failed :%d\n", ret);
+			pr_err("Bridge_ConfigGet API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
@@ -1268,13 +1268,13 @@ int dp_meter_add_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			       GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST,
 			       meter->meter_id, 1);
 		else {
-			PR_ERR("Meter flow invalid\n");
+			pr_err("Meter flow invalid\n");
 			bret = -1;
 			goto err;
 		}
 		ret = gsw_brdg->Bridge_ConfigSet(gsw_handle, br_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("Bridge_ConfigSet API failed :%d\n", ret);
+			pr_err("Bridge_ConfigSet API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
@@ -1303,7 +1303,7 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	int bret = 0;
 
 	if (!mtr_subif) {
-		PR_ERR(" mtr_subif NULL\n");
+		pr_err(" mtr_subif NULL\n");
 		return -1;
 	}
 	gsw_handle = dp_port_prop[mtr_subif->inst].ops[GSWIP_L];
@@ -1316,7 +1316,7 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	if (meter->dir & DP_METER_ATTACH_PCE) {
 		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_ATOMIC);
 		if (!pce_rule) {
-			PR_ERR("ctp_cfg alloc failed\n");
+			pr_err("ctp_cfg alloc failed\n");
 			bret = -1;
 			goto err;
 		}
@@ -1325,7 +1325,7 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		pce_rule->pattern.bEnable = 0;
 		ret = gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, pce_rule);
 		if (ret != GSW_statusOk) {
-			PR_ERR("PceRule Write API failed :%d\n", ret);
+			pr_err("PceRule Write API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
@@ -1334,20 +1334,20 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		struct pmac_port_info *port_info;
 
 		if (mtr_subif->subif.flag_pmapper) {
-			PR_ERR("flag_pmapper is set\n");
+			pr_err("flag_pmapper is set\n");
 			bret = -1;
 			goto err;
 		}
 		ctp_cfg = kzalloc(sizeof(GSW_CTP_portConfig_t), GFP_ATOMIC);
 		if (!ctp_cfg) {
-			PR_ERR("ctp_cfg alloc failed\n");
+			pr_err("ctp_cfg alloc failed\n");
 			bret = -1;
 			goto err;
 		}
 		port_info = get_dp_port_info(mtr_subif->subif.inst,
 					     mtr_subif->subif.port_id);
 		if (!port_info) {
-			PR_ERR(" port_info is NULL\n");
+			pr_err(" port_info is NULL\n");
 			bret = -1;
 			goto err;
 		}
@@ -1379,20 +1379,20 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	}
 	if (flag & DP_METER_ATTACH_BRPORT) {
 		if (!mtr_subif->subif.flag_bp) {
-			PR_ERR("flag_bp is 0\n");
+			pr_err("flag_bp is 0\n");
 			bret = -1;
 			goto err;
 		}
 		bp_cfg = kzalloc(sizeof(GSW_BRIDGE_portConfig_t), GFP_ATOMIC);
 		if (!bp_cfg) {
-			PR_ERR("bp_cfg alloc failed\n");
+			pr_err("bp_cfg alloc failed\n");
 			bret = -1;
 			goto err;
 		}
 		bp_cfg->nBridgePortId = mtr_subif->subif.bport;
 		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, bp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("BridgePort_ConfigGet API failed\n");
+			pr_err("BridgePort_ConfigGet API failed\n");
 			bret = -1;
 			goto err;
 		}
@@ -1422,7 +1422,7 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		}
 		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, bp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("BridgePort_ConfigSet API failed\n");
+			pr_err("BridgePort_ConfigSet API failed\n");
 			bret = -1;
 			goto err;
 		}
@@ -1430,14 +1430,14 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	if (flag & DP_METER_ATTACH_BRIDGE) {
 		br_cfg = kzalloc(sizeof(GSW_BRIDGE_config_t), GFP_ATOMIC);
 		if (!br_cfg) {
-			PR_ERR("br_cfg alloc failed\n");
+			pr_err("br_cfg alloc failed\n");
 			bret = -1;
 			goto err;
 		}
 		br_cfg->nBridgeId = mtr_subif->fid;
 		ret = gsw_brdg->Bridge_ConfigGet(gsw_handle, br_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("Bridge_ConfigGet API failed :%d\n", ret);
+			pr_err("Bridge_ConfigGet API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
@@ -1455,13 +1455,13 @@ int dp_meter_del_31(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			       GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST,
 			       meter->meter_id, 0);
 		else {
-			PR_ERR("Meter flow invalid\n");
+			pr_err("Meter flow invalid\n");
 			bret = -1;
 			goto err;
 		}
 		ret = gsw_brdg->Bridge_ConfigSet(gsw_handle, br_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("Bridge_ConfigSet API failed :%d\n", ret);
+			pr_err("Bridge_ConfigSet API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
@@ -1487,7 +1487,7 @@ int dp_set_bp_attr_31(struct dp_bp_attr *conf, int bport, uint32_t flag)
 
 	ret = ops->gsw_brdgport_ops.BridgePort_ConfigGet(ops, &brportcfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("fail in getting bridge port config\r\n");
+		pr_err("fail in getting bridge port config\r\n");
 		return DP_FAILURE;
 	}
 
@@ -1498,7 +1498,7 @@ int dp_set_bp_attr_31(struct dp_bp_attr *conf, int bport, uint32_t flag)
 
 	ret = ops->gsw_brdgport_ops.BridgePort_ConfigSet(ops, &brportcfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Fail in allocating/configuring bridge port\n");
+		pr_err("Fail in allocating/configuring bridge port\n");
 		return DP_FAILURE;
 	}
 
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_lookup_proc.c b/drivers/net/datapath/dpm/gswip31/datapath_lookup_proc.c
index 3bb69d412d0a..d463da16a22a 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_lookup_proc.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_lookup_proc.c
@@ -44,7 +44,7 @@
 #define proc_printf(s, fmt, arg...) \
 	do { \
 		if (!s) \
-			PR_INFO(fmt, ##arg); \
+			pr_info(fmt, ##arg); \
 		else \
 			seq_printf(s, fmt, ##arg); \
 	} while (0)
@@ -247,7 +247,7 @@ static void lookup_pattern_match(int tmp_index)
 			for (i = 0; i < LOOKUP_FIELD_BITS; i++)
 				index |= (t[i] << i);
 			if (lookup_tbl_flags[index] == ENTRY_USED)
-				PR_ERR("why already used\n");
+				pr_err("why already used\n");
 			else
 				lookup_tbl_flags[index] = ENTRY_USED;
 		}
@@ -420,13 +420,13 @@ ssize_t proc_get_qid_via_index31(struct file *file, const char *buf,
 
 	if (len <= 0) {
 		err = -EFAULT;
-		PR_ERR("Wrong len value (%d)\n", len);
+		pr_err("Wrong len value (%d)\n", len);
 		return count;
 	}
 
 	if (copy_from_user(data, buf, len)) {
 		err = -EFAULT;
-		PR_ERR("copy_from_user fail");
+		pr_err("copy_from_user fail");
 		return count;
 	}
 
@@ -443,7 +443,7 @@ ssize_t proc_get_qid_via_index31(struct file *file, const char *buf,
 	if ((dp_strncmpi(param_list[0], "set", strlen("set")) == 0) ||
 	    (dp_strncmpi(param_list[0], "write", strlen("write")) == 0)) {
 		if (!param_list[2]) {
-			PR_ERR("wrong command\n");
+			pr_err("wrong command\n");
 			return count;
 		}
 		qid = dp_atoi(param_list[2]);
@@ -453,7 +453,7 @@ ssize_t proc_get_qid_via_index31(struct file *file, const char *buf,
 					       qid);
 			return count;
 		}
-		PR_INFO("Set to queue[%u] done\n", qid);
+		pr_info("Set to queue[%u] done\n", qid);
 		set_lookup_qid_via_index(lookup_index, qid);
 		return count;
 	} else if ((dp_strncmpi(param_list[0], "get", strlen("get")) == 0) ||
@@ -464,7 +464,7 @@ ssize_t proc_get_qid_via_index31(struct file *file, const char *buf,
 			return count;
 		}
 		qid = get_lookup_qid_via_index(lookup_index);
-		PR_INFO("Get lookup[%05u 0x%04x] ->     queue[%u]\n",
+		pr_info("Get lookup[%05u 0x%04x] ->     queue[%u]\n",
 			lookup_index, lookup_index, qid);
 		return count;
 	} else if (dp_strncmpi(param_list[0], "find", strlen("find")) == 0) {
@@ -485,28 +485,28 @@ ssize_t proc_get_qid_via_index31(struct file *file, const char *buf,
 		int new_q = dp_atoi(param_list[2]);
 
 		lookup_table_remap(old_q, new_q);
-		PR_INFO("remap queue[%d] to queue[%d] done\n",
+		pr_info("remap queue[%d] to queue[%d] done\n",
 			old_q, new_q);
 		return count;
 	}
 
 	goto help;
 help:
-	PR_INFO("Usage: echo set lookup_flags queue_id > /proc/dp/lookup\n");
-	PR_INFO("     : echo get lookup_flags > /proc/dp/lookup\n");
-	PR_INFO("     : echo find  <x> > /proc/dp/lookup\n");
-	PR_INFO("     : echo find2 <x> > /proc/dp/lookup\n");
-	PR_INFO("     : echo remap <old_q> <new_q> > /proc/dp/lookup\n");
-	PR_INFO("  Hex example: echo set 0x10 10 > /proc/dp/lookup\n");
-	PR_INFO("  Dec:example: echo set 16 10 > /proc/dp/lookup\n");
-	PR_INFO("  Bin:example: echo set b10000 10 > /proc/dp/lookup\n");
-
-	PR_INFO("%s: echo set b1xxxx 10 > /proc/dp/lookup\n",
+	pr_info("Usage: echo set lookup_flags queue_id > /proc/dp/lookup\n");
+	pr_info("     : echo get lookup_flags > /proc/dp/lookup\n");
+	pr_info("     : echo find  <x> > /proc/dp/lookup\n");
+	pr_info("     : echo find2 <x> > /proc/dp/lookup\n");
+	pr_info("     : echo remap <old_q> <new_q> > /proc/dp/lookup\n");
+	pr_info("  Hex example: echo set 0x10 10 > /proc/dp/lookup\n");
+	pr_info("  Dec:example: echo set 16 10 > /proc/dp/lookup\n");
+	pr_info("  Bin:example: echo set b10000 10 > /proc/dp/lookup\n");
+
+	pr_info("%s: echo set b1xxxx 10 > /proc/dp/lookup\n",
 		"Special for BIN(Don't care bit)");
-	PR_INFO("Lookup format:\n");
-	PR_INFO("  Bits Index: | %s\n",
+	pr_info("Lookup format:\n");
+	pr_info("  Bits Index: | %s\n",
 		"13   12 |  11  |  10  |  9   |  8   |7   4 | 3   0 |");
-	PR_INFO("  Fields:     | %s\n",
+	pr_info("  Fields:     | %s\n",
 		"Flow ID | DEC  | ENC  | MPE2 | MPE1 |  EP  | CLASS |");
 	return count;
 }
@@ -525,14 +525,14 @@ void lookup_table_via_qid(int qid)
 				if (tmp != qid)
 					continue;
 				f = 1;
-				PR_INFO("Get lookup[%05u 0x%04x]%s[%d]\n",
+				pr_info("Get lookup[%05u 0x%04x]%s[%d]\n",
 					index, index,
 					" ->     queue", qid);
 			}
 		}
 	}
 	if (!f)
-		PR_ERR("No mapping to queue id %d yet ?\n", qid);
+		pr_err("No mapping to queue id %d yet ?\n", qid);
 }
 
 void lookup_table_remap(int old_q, int new_q)
@@ -559,7 +559,7 @@ void lookup_table_remap(int old_q, int new_q)
 		}
 	}
 	if (!f)
-		PR_INFO("No mapping to queue id %d yet\n", new_q);
+		pr_info("No mapping to queue id %d yet\n", new_q);
 }
 
 #define LOOKUP_FIELD_BITS 14
@@ -632,7 +632,7 @@ void lookup_table_recursive(int k, int tmp_index, int set_flag, int qid)
 				 tmp_index, tmp_index, qid);
 		} else {
 			qid = get_lookup_qid_via_index(tmp_index);
-			PR_INFO("Get lookup[%05u/0x%04x] ->     queue[%d]\n",
+			pr_info("Get lookup[%05u/0x%04x] ->     queue[%d]\n",
 				tmp_index, tmp_index, qid);
 		}
 		return;
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_misc.c b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
index 2f3727c0ffa1..5c31c7d7b9d6 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_misc.c
@@ -195,31 +195,31 @@ void dump_rx_dma_desc(struct dma_rx_desc_0 *desc_0,
 		      struct dma_rx_desc_3 *desc_3)
 {
 	if (!desc_0 || !desc_1 || !desc_2 || !desc_3) {
-		PR_ERR("rx desc_0/1/2/3 NULL\n");
+		pr_err("rx desc_0/1/2/3 NULL\n");
 		return;
 	}
 
-	PR_INFO(" DMA Descripotr:D0=0x%08x D1=0x%08x D2=0x%08x D3=0x%08x\n",
+	pr_info(" DMA Descripotr:D0=0x%08x D1=0x%08x D2=0x%08x D3=0x%08x\n",
 		*(u32 *)desc_0, *(u32 *)desc_1,
 		*(u32 *)desc_2, *(u32 *)desc_3);
-	PR_INFO("  DW0:redir=%d res=%d tunl=%d flow=%d ether=%d %s=0x%04x\n",
+	pr_info("  DW0:redir=%d res=%d tunl=%d flow=%d ether=%d %s=0x%04x\n",
 		desc_0->field.redir,
 		desc_0->field.resv, desc_0->field.tunnel_id,
 		desc_0->field.flow_id, desc_0->field.eth_type,
 		"subif", desc_0->field.dest_sub_if_id);
-	PR_INFO("  DW1:%s=%d tcp_err=%d nat=%d dec=%d enc=%d mpe2/1=%d/%d\n",
+	pr_info("  DW1:%s=%d tcp_err=%d nat=%d dec=%d enc=%d mpe2/1=%d/%d\n",
 		"sess/src_subif", desc_1->field.session_id,
 		desc_1->field.tcp_err,
 		desc_1->field.nat, desc_1->field.dec, desc_1->field.enc,
 		desc_1->field.mpe2, desc_1->field.mpe1);
-	PR_INFO("      color=%02d ep=%02d ip=%02d classid=%02d\n",
+	pr_info("      color=%02d ep=%02d ip=%02d classid=%02d\n",
 		desc_1->field.color, desc_1->field.ep, desc_1->field.ip,
 		desc_1->field.classid);
-	PR_INFO("  DW2:data_ptr=0x%08x\n", desc_2->field.data_ptr);
-	PR_INFO("  DW3:own=%d c=%d sop=%d eop=%d dic=%d pdu_type=%d\n",
+	pr_info("  DW2:data_ptr=0x%08x\n", desc_2->field.data_ptr);
+	pr_info("  DW3:own=%d c=%d sop=%d eop=%d dic=%d pdu_type=%d\n",
 		desc_3->field.own, desc_3->field.c, desc_3->field.sop,
 		desc_3->field.eop, desc_3->field.dic, desc_3->field.pdu_type);
-	PR_INFO("      offset=%d policy=%d res=%d pool=%d len=%d\n",
+	pr_info("      offset=%d policy=%d res=%d pool=%d len=%d\n",
 		desc_3->field.byte_offset, desc_3->field.policy,
 		desc_3->field.res, desc_3->field.pool,
 		desc_3->field.data_len);
@@ -236,29 +236,29 @@ void dump_tx_dma_desc(struct dma_tx_desc_0 *desc_0,
 	struct pmac_port_info *port_info;
 
 	if (!desc_0 || !desc_1 || !desc_2 || !desc_3) {
-		PR_ERR("tx desc_0/1/2/3 NULL\n");
+		pr_err("tx desc_0/1/2/3 NULL\n");
 		return;
 	}
-	PR_INFO(" DMA Descripotr:D0=0x%08x D1=0x%08x D2=0x%08x D3=0x%08x\n",
+	pr_info(" DMA Descripotr:D0=0x%08x D1=0x%08x D2=0x%08x D3=0x%08x\n",
 		*(u32 *)desc_0, *(u32 *)desc_1,
 		*(u32 *)desc_2, *(u32 *)desc_3);
-	PR_INFO("  DW0:redir=%d res=%d tunl=%d flow=%d ether=%d subif=0x%04x\n",
+	pr_info("  DW0:redir=%d res=%d tunl=%d flow=%d ether=%d subif=0x%04x\n",
 		desc_0->field.redir,
 		desc_0->field.resv, desc_0->field.tunnel_id,
 		desc_0->field.flow_id, desc_0->field.eth_type,
 		desc_0->field.dest_sub_if_id);
-	PR_INFO("  DW1:sess=%d tcp_err=%d nat=%d dec=%d enc=%d mpe2/1=%d/%d\n",
+	pr_info("  DW1:sess=%d tcp_err=%d nat=%d dec=%d enc=%d mpe2/1=%d/%d\n",
 		desc_1->field.session_id, desc_1->field.tcp_err,
 		desc_1->field.nat, desc_1->field.dec, desc_1->field.enc,
 		desc_1->field.mpe2, desc_1->field.mpe1);
-	PR_INFO("  color=%02d ep=%02d ip=%02d class=%d\n",
+	pr_info("  color=%02d ep=%02d ip=%02d class=%d\n",
 		desc_1->field.color, desc_1->field.ep,
 		desc_1->field.ip, desc_1->field.classid);
-	PR_INFO("  DW2:data_ptr=0x%08x\n", desc_2->field.data_ptr);
-	PR_INFO("  DW3:own=%d c=%d sop=%d eop=%d dic=%d pdu_type=%d\n",
+	pr_info("  DW2:data_ptr=0x%08x\n", desc_2->field.data_ptr);
+	pr_info("  DW3:own=%d c=%d sop=%d eop=%d dic=%d pdu_type=%d\n",
 		desc_3->field.own, desc_3->field.c, desc_3->field.sop,
 		desc_3->field.eop, desc_3->field.dic, desc_3->field.pdu_type);
-	PR_INFO("  offset=%d policy=%d res=%d pool=%d data_len=%d\n",
+	pr_info("  offset=%d policy=%d res=%d pool=%d data_len=%d\n",
 		desc_3->field.byte_offset,
 		desc_3->field.policy, desc_3->field.res,
 		desc_3->field.pool, desc_3->field.data_len);
@@ -295,7 +295,7 @@ void dump_tx_dma_desc(struct dma_tx_desc_0 *desc_0,
 			 ((desc_1->field.ep) << 4) |
 			 ((desc_0->field.dest_sub_if_id & 0x1) << 3) |
 			 (desc_1->field.classid & 7); /*lower 3 bits*/
-	PR_INFO("  lookup index=0x%x qid=%d\n", lookup,
+	pr_info("  lookup index=0x%x qid=%d\n", lookup,
 		get_lookup_qid_via_index(lookup));
 }
 
@@ -306,7 +306,7 @@ static void dump_rx_pmac(struct pmac_rx_hdr *pmac)
 	unsigned char buf[100];
 
 	if (!pmac) {
-		PR_ERR(" pmac NULL ??\n");
+		pr_err(" pmac NULL ??\n");
 		return;
 	}
 
@@ -314,30 +314,30 @@ static void dump_rx_pmac(struct pmac_rx_hdr *pmac)
 	for (i = 0; i < 8; i++)
 		l += sprintf(buf + l, "0x%02x ", p[i]);
 	l += sprintf(buf + l, "\n");
-	PR_INFO("%s", buf);
+	pr_info("%s", buf);
 
 	/*byte 0 */
-	PR_INFO("  byte 0:res=%d ver_done=%d ip_offset=%d\n", pmac->res0,
+	pr_info("  byte 0:res=%d ver_done=%d ip_offset=%d\n", pmac->res0,
 		pmac->ver_done, pmac->ip_offset);
 	/*byte 1 */
-	PR_INFO("  byte 1:tcp_h_offset=%d tcp_type=%d\n", pmac->tcp_h_offset,
+	pr_info("  byte 1:tcp_h_offset=%d tcp_type=%d\n", pmac->tcp_h_offset,
 		pmac->tcp_type);
 	/*byte 2 */
-	PR_INFO("  byte 2:class=%d res=%d\n", pmac->class, pmac->res2);
+	pr_info("  byte 2:class=%d res=%d\n", pmac->class, pmac->res2);
 	/*byte 3 */
-	PR_INFO("  byte 3:pkt_type=%d ext=%d ins=%d res31=%d oam=%d res32=%d\n",
+	pr_info("  byte 3:pkt_type=%d ext=%d ins=%d res31=%d oam=%d res32=%d\n",
 		pmac->pkt_type, pmac->ext, pmac->ins, pmac->res31,
 		pmac->oam, pmac->res32);
 	/*byte 4 */
-	PR_INFO("  byte 4:res=%d ptp=%d one_step=%d src_dst_subif_id_msb=%d\n",
+	pr_info("  byte 4:res=%d ptp=%d one_step=%d src_dst_subif_id_msb=%d\n",
 		pmac->res4, pmac->ptp, pmac->one_step,
 		pmac->src_dst_subif_id_msb);
 	/*byte 5 */
-	PR_INFO("  byte 5:src_sub_inf_id2=%d\n", pmac->src_dst_subif_id_lsb);
+	pr_info("  byte 5:src_sub_inf_id2=%d\n", pmac->src_dst_subif_id_lsb);
 	/*byte 6 */
-	PR_INFO("  byte 6:record_id_msb=%d\n", pmac->record_id_msb);
+	pr_info("  byte 6:record_id_msb=%d\n", pmac->record_id_msb);
 	/*byte 7 */
-	PR_INFO("  byte 7:record_id_lsb=%d igp_egp=%d\n",
+	pr_info("  byte 7:record_id_lsb=%d igp_egp=%d\n",
 		pmac->record_id_lsb, pmac->igp_egp);
 }
 
@@ -348,7 +348,7 @@ static void dump_tx_pmac(struct pmac_tx_hdr *pmac)
 	unsigned char buf[100];
 
 	if (!pmac) {
-		PR_ERR("dump_tx_pmac pmac NULL ??\n");
+		pr_err("dump_tx_pmac pmac NULL ??\n");
 		return;
 	}
 
@@ -356,18 +356,18 @@ static void dump_tx_pmac(struct pmac_tx_hdr *pmac)
 	for (i = 0; i < 8; i++)
 		l += sprintf(buf + l, "0x%02x ", p[i]);
 	sprintf(buf + l, "\n");
-	PR_INFO("%s", buf);
+	pr_info("%s", buf);
 
 	/*byte 0 */
-	PR_INFO("  byte 0:res=%d tcp_chksum=%d ip_offset=%d\n", pmac->res1,
+	pr_info("  byte 0:res=%d tcp_chksum=%d ip_offset=%d\n", pmac->res1,
 		pmac->tcp_chksum, pmac->ip_offset);
 	/*byte 1 */
-	PR_INFO("  byte 1:tcp_h_offset=%d tcp_type=%d\n", pmac->tcp_h_offset,
+	pr_info("  byte 1:tcp_h_offset=%d tcp_type=%d\n", pmac->tcp_h_offset,
 		pmac->tcp_type);
 	/*byte 2 */
-	PR_INFO("  byte 2:igp_msb=%d res=%d\n", pmac->igp_msb, pmac->res2);
+	pr_info("  byte 2:igp_msb=%d res=%d\n", pmac->igp_msb, pmac->res2);
 	/*byte 3 */
-	PR_INFO("  byte 3:%s=%d %s=%d %s=%d %s=%d %s=%d %s=%d %s=%d\n",
+	pr_info("  byte 3:%s=%d %s=%d %s=%d %s=%d %s=%d %s=%d %s=%d\n",
 		"pkt_type", pmac->pkt_type,
 		"ext", pmac->ext,
 		"ins", pmac->ins,
@@ -376,17 +376,17 @@ static void dump_tx_pmac(struct pmac_tx_hdr *pmac)
 		"lrnmd", pmac->lrnmd,
 		"class_en", pmac->class_en);
 	/*byte 4 */
-	PR_INFO("  byte 4:%s=%d ptp=%d one_step=%d src_dst_subif_id_msb=%d\n",
+	pr_info("  byte 4:%s=%d ptp=%d one_step=%d src_dst_subif_id_msb=%d\n",
 		"fcs_ins_dis", pmac->fcs_ins_dis,
 		pmac->ptp, pmac->one_step,
 		pmac->src_dst_subif_id_msb);
 	/*byte 5 */
-	PR_INFO("  byte 5:src_dst_subif_id_lsb=%d\n",
+	pr_info("  byte 5:src_dst_subif_id_lsb=%d\n",
 		pmac->src_dst_subif_id_lsb);
 	/*byte 6 */
-	PR_INFO("  byte 6:record_id_msb=%d\n", pmac->record_id_msb);
+	pr_info("  byte 6:record_id_msb=%d\n", pmac->record_id_msb);
 	/*byte 7 */
-	PR_INFO("  byte 7:record_id_lsb=%d igp_egp=%d\n", pmac->record_id_lsb,
+	pr_info("  byte 7:record_id_lsb=%d igp_egp=%d\n", pmac->record_id_lsb,
 		pmac->igp_egp);
 }
 
@@ -419,7 +419,7 @@ int alloc_q_to_port(struct ppv4_q_sch_port *info, u32 flag)
 	struct dp_subif_info *subif;
 
 	if (!priv) {
-		PR_ERR("why priv NULL ???\n");
+		pr_err("why priv NULL ???\n");
 		return -1;
 	}
 
@@ -431,7 +431,7 @@ int alloc_q_to_port(struct ppv4_q_sch_port *info, u32 flag)
 		port.inst = inst;
 		port.dp_port = info->dp_port;
 		if (dp_pp_alloc_port(&port)) {
-			PR_ERR("%s fail for deq_port=%d qos_deq_port=%d\n",
+			pr_err("%s fail for deq_port=%d qos_deq_port=%d\n",
 			       "dp_pp_alloc_port",
 			       port.cqm_deq_port, port.qos_deq_port);
 			return -1;
@@ -447,7 +447,7 @@ int alloc_q_to_port(struct ppv4_q_sch_port *info, u32 flag)
 	q.parent = port.node_id;
 	q.inst = inst;
 	if (dp_pp_alloc_queue(&q)) {
-		PR_ERR("%s fail\n",
+		pr_err("%s fail\n",
 		       "dp_pp_alloc_queue");
 		return -1;
 	}
@@ -479,7 +479,7 @@ int alloc_q_to_port(struct ppv4_q_sch_port *info, u32 flag)
 	link.prio_wfq = 0;
 
 	if (dp_node_link_add(&link, 0)) {
-		PR_ERR("dp_node_link_add_31 fail: cqm_deq_port=%d\n",
+		pr_err("dp_node_link_add_31 fail: cqm_deq_port=%d\n",
 		       info->cqe_deq);
 		return -1;
 	}
@@ -527,7 +527,7 @@ static int dp_gswip_remark_8P0D_set(int mode, int inst)
 	color_remark.nVal[14] = 13;
 	color_remark.nVal[15] = 15;
 	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
-		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -559,7 +559,7 @@ static int dp_gswip_remark_7P1D_set(int mode, int inst)
 	color_remark.nVal[14] = 13;
 	color_remark.nVal[15] = 15;
 	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
-		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -591,7 +591,7 @@ static int dp_gswip_remark_6P2D_set(int mode, int inst)
 	color_remark.nVal[14] = 13;
 	color_remark.nVal[15] = 15;
 	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
-		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -623,7 +623,7 @@ static int dp_gswip_remark_5P3D_set(int mode, int inst)
 	color_remark.nVal[14] = 13;
 	color_remark.nVal[15] = 15;
 	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
-		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -655,7 +655,7 @@ static int dp_gswip_remark_dscp_set(int mode, int inst)
 	color_remark.nVal[14] = 36;
 	color_remark.nVal[15] = 36;
 	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
-		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -799,7 +799,7 @@ static int dp_gswip_color_dscp_set(int mode, int inst)
 	color_mark.nColor[62] = GSW_DROP_PRECEDENCE_YELLOW;
 	color_mark.nColor[63] = GSW_DROP_PRECEDENCE_YELLOW;
 	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
-		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -847,7 +847,7 @@ static int dp_gswip_color_5P3D_set(int mode, int inst)
 	color_mark.nColor[14] = GSW_DROP_PRECEDENCE_GREEN;
 	color_mark.nColor[15] = GSW_DROP_PRECEDENCE_YELLOW;
 	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
-		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -895,7 +895,7 @@ static int dp_gswip_color_6P2D_set(int mode, int inst)
 	color_mark.nColor[14] = GSW_DROP_PRECEDENCE_GREEN;
 	color_mark.nColor[15] = GSW_DROP_PRECEDENCE_YELLOW;
 	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
-		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -943,7 +943,7 @@ static int dp_gswip_color_7P1D_set(int mode, int inst)
 	color_mark.nColor[14] = GSW_DROP_PRECEDENCE_GREEN;
 	color_mark.nColor[15] = GSW_DROP_PRECEDENCE_YELLOW;
 	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
-		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -991,7 +991,7 @@ static int dp_gswip_color_8P0D_set(int mode, int inst)
 	color_mark.nColor[14] = GSW_DROP_PRECEDENCE_GREEN;
 	color_mark.nColor[15] = GSW_DROP_PRECEDENCE_YELLOW;
 	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
-		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -1028,7 +1028,7 @@ int dp_platform_queue_set(int inst, u32 flag)
 
 	port_info = get_dp_port_info(inst, CPU_PORT);
 	if ((flag & DP_PLATFORM_DE_INIT) == DP_PLATFORM_DE_INIT) {
-		PR_ERR("Need to free resoruce in the future\n");
+		pr_err("Need to free resoruce in the future\n");
 		return 0;
 	}
 
@@ -1037,7 +1037,7 @@ int dp_platform_queue_set(int inst, u32 flag)
 		q.parent = 0;
 		q.inst = inst;
 		if (dp_pp_alloc_queue(&q)) {
-			PR_ERR("%s fail to alloc a drop queue ??\n",
+			pr_err("%s fail to alloc a drop queue ??\n",
 			       "dp_pp_alloc_queue");
 			return -1;
 		}
@@ -1070,7 +1070,7 @@ int dp_platform_queue_set(int inst, u32 flag)
 	cpu_data.cbm_inst = dp_port_prop[inst].cbm_inst;
 	ret = cbm_cpu_port_get(&cpu_data, 0);
 	if (ret == -1) {
-		PR_ERR("%s fail for CPU Port. Why ???\n",
+		pr_err("%s fail for CPU Port. Why ???\n",
 		       "cbm_cpu_port_get");
 		return -1;
 	}
@@ -1125,7 +1125,7 @@ int dp_platform_queue_set(int inst, u32 flag)
 		q_port.ctp = i; /*fake CTP for CPU port to store its qid*/
 		DP_DEBUG(DP_DBG_FLAG_QOS, "alloc_q_to_port...\n");
 		if (alloc_q_to_port(&q_port, 0)) {
-			PR_ERR("alloc_q_to_port fail for dp_port=%d\n",
+			pr_err("alloc_q_to_port fail for dp_port=%d\n",
 			       q_port.dp_port);
 			return -1;
 		}
@@ -1158,7 +1158,7 @@ int dp_platform_queue_set(int inst, u32 flag)
 		en_data.dp_inst = inst;
 		en_data.deq_port = cpu_data.dq_tx_push_info[i].deq_port;
 		if (cbm_dp_enable(NULL, PMAC_CPU_ID, &en_data, 0, 0)) {
-			PR_ERR("Fail to enable CPU[%d]\n", en_data.deq_port);
+			pr_err("Fail to enable CPU[%d]\n", en_data.deq_port);
 			return -1;
 		}
 	}
@@ -1179,7 +1179,7 @@ static int dp_platform_set(int inst, u32 flag)
 		dp_port_prop[inst].priv_hal =
 			kzalloc(sizeof(*priv), GFP_KERNEL);
 		if (!dp_port_prop[inst].priv_hal) {
-			PR_ERR("kmalloc failed: %d bytes\n",
+			pr_err("kmalloc failed: %d bytes\n",
 			       sizeof(struct hal_priv));
 			return -1;
 		}
@@ -1191,7 +1191,7 @@ static int dp_platform_set(int inst, u32 flag)
 			init_dma_desc_mask();
 		if (!dp_port_prop[inst].ops[0] ||
 		    !dp_port_prop[inst].ops[1]) {
-			PR_ERR("Why GSWIP handle Zero\n");
+			pr_err("Why GSWIP handle Zero\n");
 			return -1;
 		}
 		if (!inst)
@@ -1218,32 +1218,32 @@ static int dp_platform_set(int inst, u32 flag)
 		port_remark.nPortId = 0;
 		if (gsw_qos->QoS_PortRemarkingCfgGet(gsw_handle,
 						     &port_remark)) {
-			PR_ERR("GSW_QOS_PORT_REMARKING_CFG_GET failed\n");
+			pr_err("GSW_QOS_PORT_REMARKING_CFG_GET failed\n");
 			return -1;
 		}
 		port_remark.bPCP_EgressRemarkingEnable = 0;
 		if (gsw_qos->QoS_PortRemarkingCfgGet(gsw_handle,
 						     &port_remark)) {
-			PR_ERR("GSW_QOS_PORT_REMARKING_CFG_GET failed\n");
+			pr_err("GSW_QOS_PORT_REMARKING_CFG_GET failed\n");
 			return -1;
 		}
 
 		if (init_ppv4_qos(inst, flag)) {
-			PR_ERR("init_ppv4_qos fail\n");
+			pr_err("init_ppv4_qos fail\n");
 			return -1;
 		}
 		if (dp_platform_queue_set(inst, flag)) {
-			PR_ERR("dp_platform_queue_set fail\n");
+			pr_err("dp_platform_queue_set fail\n");
 
 			return -1;
 		}
 		if (dp_platform_color_table_set(inst)) {
-			PR_ERR("dp_platform_color_table_set fail\n");
+			pr_err("dp_platform_color_table_set fail\n");
 
 			return -1;
 		}
 		if (cpu_vlan_mod_dis(inst)) {
-			PR_ERR("cpu_vlan_mod_dis fail\n");
+			pr_err("cpu_vlan_mod_dis fail\n");
 			return -1;
 		}
 		return 0;
@@ -1275,7 +1275,7 @@ static int pon_config(int inst, int ep, struct dp_port_data *data, u32 flags)
 	memset((void *)&cpu_port_cfg, 0x00, sizeof(cpu_port_cfg));
 	ret = gsw_com->CPU_PortCfgGet(gsw_handle, &cpu_port_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("fail in getting CPU port config\r\n");
+		pr_err("fail in getting CPU port config\r\n");
 		return -1;
 	}
 	/* Enable the Egress and Ingress Special Tag */
@@ -1284,7 +1284,7 @@ static int pon_config(int inst, int ep, struct dp_port_data *data, u32 flags)
 	cpu_port_cfg.bSpecialTagEgress = 1;
 	ret = gsw_com->CPU_PortCfgSet(gsw_handle, &cpu_port_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Fail in configuring CPU port\n");
+		pr_err("Fail in configuring CPU port\n");
 		return -1;
 	}
 
@@ -1334,7 +1334,7 @@ static int dev_platform_set(int inst, u8 ep, struct dp_dev_data *data,
 	struct hal_priv *priv = (struct hal_priv *)dp_port_prop[inst].priv_hal;
 
 	if (!priv) {
-		PR_ERR("priv is NULL\n");
+		pr_err("priv is NULL\n");
 		return DP_FAILURE;
 	}
 	itf = ctp_port_assign(inst, ep, priv->bp_def, flags, data);
@@ -1355,7 +1355,7 @@ static int port_platform_set(int inst, u8 ep, struct dp_port_data *data,
 	u32 dma_chan, dma_ch_base;
 
 	if (!priv) {
-		PR_ERR("priv is NULL\n");
+		pr_err("priv is NULL\n");
 		return DP_FAILURE;
 	}
 	set_port_lookup_mode_31(inst, ep, flags);
@@ -1405,7 +1405,7 @@ static int port_platform_set(int inst, u8 ep, struct dp_port_data *data,
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_DBG)
 	if (DP_DBG_FLAG_QOS & dp_dbg_flag) {
 		for (i = 0; i < port_info->deq_port_num; i++) {
-			PR_INFO("cqm[%d]:addr/push=%px/%px credit=%dsize==%d\n",
+			pr_info("cqm[%d]:addr/push=%px/%px credit=%dsize==%d\n",
 				i + idx,
 				dp_deq_port_tbl[inst][i + idx].txpush_addr,
 				dp_deq_port_tbl[inst][i + idx].txpush_addr_qos,
@@ -1432,7 +1432,7 @@ static int set_ctp_bp(int inst, int ctp, int portid, int bp,
 	tmp.eMask = GSW_CTP_PORT_CONFIG_MASK_BRIDGE_PORT_ID;
 	tmp.nBridgePortId = bp;
 	if (gsw_handle->gsw_ctp_ops.CTP_PortConfigSet(gsw_handle, &tmp)) {
-		PR_ERR("Failed to CTP(%d)'s bridge port=%d for ep=%d\n",
+		pr_err("Failed to CTP(%d)'s bridge port=%d for ep=%d\n",
 		       ctp, bp, portid);
 		return -1;
 	}
@@ -1455,7 +1455,7 @@ static int reset_ctp_bp(int inst, int ctp, int portid, int bp)
 	tmp.nSubIfIdGroup = ctp;
 	tmp.nBridgePortId = bp;
 	if (gsw_handle->gsw_ctp_ops.CTP_PortConfigReset(gsw_handle, &tmp)) {
-		PR_ERR("Failed to reset CTP(%d)'s bridge port=%d for ep=%d\n",
+		pr_err("Failed to reset CTP(%d)'s bridge port=%d for ep=%d\n",
 		       ctp, bp, portid);
 		return -1;
 	}
@@ -1502,11 +1502,11 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 	int qid;
 
 	if (!data || !data->subif_data) {
-		PR_ERR("data NULL or subif_data NULL\n");
+		pr_err("data NULL or subif_data NULL\n");
 		return -1;
 	}
 	if (!dp_dma_chan_tbl[inst]) {
-		PR_ERR("dp_dma_chan_tbl[%d] NULL\n", inst);
+		pr_err("dp_dma_chan_tbl[%d] NULL\n", inst);
 		return DP_FAILURE;
 	}
 	port_info = get_dp_port_info(inst, portid);
@@ -1533,7 +1533,7 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 			bp = alloc_bridge_port(inst, portid,
 					       subif_ix, CPU_FID, CPU_BP);
 		if (bp < 0) {
-			PR_ERR("Fail to alloc bridge port\n");
+			pr_err("Fail to alloc bridge port\n");
 			return -1;
 		}
 	}
@@ -1546,7 +1546,7 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 	}
 	data->act = 0;
 	if (flags & DP_F_SUBIF_LOGICAL) {
-		PR_ERR("need more for logical dev??\n");
+		pr_err("need more for logical dev??\n");
 		return 0;
 	}
 	if (data->subif_data->ctp_dev) {
@@ -1567,7 +1567,7 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 	if (data->subif_data)
 		deq_port_idx = data->subif_data->deq_port_idx;
 	if (port_info->deq_port_num < deq_port_idx + 1) {
-		PR_ERR("Wrong deq_port_idx(%d), should < %d\n",
+		pr_err("Wrong deq_port_idx(%d), should < %d\n",
 		       deq_port_idx, port_info->deq_port_num);
 		return -1;
 	}
@@ -1575,12 +1575,12 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 	q_port.cqe_deq = port_info->deq_port_base + deq_port_idx;
 	if ((data->subif_data->flag_ops & DP_SUBIF_DEQPORT_NUM) &&
 	    (data->subif_data->num_deq_port > DP_MAX_DEQ_PER_SUBIF)) {
-		DP_ERR("deq_port(%d), cannot be more than max Q per subif %d\n",
+		pr_err("deq_port(%d), cannot be more than max Q per subif %d\n",
 		       data->subif_data->num_deq_port, DP_MAX_DEQ_PER_SUBIF);
 		return -1;
 	}
 	if (!priv) {
-		PR_ERR("priv NULL\n");
+		pr_err("priv NULL\n");
 		return -1;
 	}
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_DBG)
@@ -1631,19 +1631,19 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 			 q_flag_str(q_flag));
 		if (q_flag == DP_SUBIF_AUTO_NEW_Q) {
 			if (alloc_q_to_port(&q_port, 0)) {
-				PR_ERR("alloc_q_to_port fail for dp_port=%d\n",
+				pr_err("alloc_q_to_port fail for dp_port=%d\n",
 				       q_port.dp_port);
 				return -1;
 			}
 			if (dp_q_tbl[inst][q_port.qid].flag) {
-				PR_ERR("Why dp_q_tbl[%d][%d].flag =%d%s?\n",
+				pr_err("Why dp_q_tbl[%d][%d].flag =%d%s?\n",
 				       inst, q_port.qid,
 				       dp_q_tbl[inst][q_port.qid].flag,
 				       ":expect 0");
 				return -1;
 			}
 			if (dp_q_tbl[inst][q_port.qid].ref_cnt) {
-				PR_ERR("Why dp_q_tbl[%d][%d].ref_cnt =%d%s?\n",
+				pr_err("Why dp_q_tbl[%d][%d].ref_cnt =%d%s?\n",
 				       inst, q_port.qid,
 				       dp_q_tbl[inst][q_port.qid].ref_cnt,
 				       ":expect 0");
@@ -1830,23 +1830,23 @@ static int subif_hw_reset(int inst, int portid, int subif_ix,
 		bp = sif->bp;
 
 		if (!dp_dma_chan_tbl[inst]) {
-			PR_ERR("dp_dma_chan_tbl[%d] NULL\n", inst);
+			pr_err("dp_dma_chan_tbl[%d] NULL\n", inst);
 			return DP_FAILURE;
 		}
 		/* santity check table */
 		if (!dp_q_tbl[inst][qid].ref_cnt) {
-			PR_ERR("Why dp_q_tbl[%d][%d].ref_cnt Zero:expect > 0\n",
+			pr_err("Why dp_q_tbl[%d][%d].ref_cnt Zero:expect > 0\n",
 			       inst, qid);
 			return DP_FAILURE;
 		}
 		if (!dp_deq_port_tbl[inst][cqm_deq_port].ref_cnt) {
-			PR_ERR("Why dp_deq_port_tbl[%d][%d].ref_cnt Zero\n",
+			pr_err("Why dp_deq_port_tbl[%d][%d].ref_cnt Zero\n",
 			       inst, cqm_deq_port);
 			return DP_FAILURE;
 		}
 		if ((sif->ctp_dev) &&
 		    !dp_bp_dev_tbl[inst][bp].ref_cnt) {
-			PR_ERR("Why dp_bp_dev_tbl[%d][%d].ref_cnt =%d\n",
+			pr_err("Why dp_bp_dev_tbl[%d][%d].ref_cnt =%d\n",
 			       inst, bp, dp_bp_dev_tbl[inst][bp].ref_cnt);
 			return DP_FAILURE;
 		}
@@ -1942,7 +1942,7 @@ static int subif_hw_reset(int inst, int portid, int subif_ix,
 
 		if (!port_info->num_subif &&
 		    dp_deq_port_tbl[inst][cqm_deq_port].ref_cnt) {
-			PR_ERR("num_subif(%d) not match %s[%d][%d].ref_cnt\n",
+			pr_err("num_subif(%d) not match %s[%d][%d].ref_cnt\n",
 			       port_info->num_subif, "dp_deq_port", inst,
 			       cqm_deq_port);
 			return DP_FAILURE;
@@ -1992,11 +1992,11 @@ static int dp_ctp_tc_map_set_31(struct dp_tc_cfg *tc, int flag,
 	memset(&ctp_tc_cfg, 0, sizeof(ctp_tc_cfg));
 
 	if (!mtr_subif) {
-		PR_ERR("mtr_subif struct NULL\n");
+		pr_err("mtr_subif struct NULL\n");
 		return -1;
 	}
 	if (mtr_subif->subif.flag_pmapper) {
-		PR_ERR("Cannot support ctp tc set for pmmapper dev(%s)\n",
+		pr_err("Cannot support ctp tc set for pmmapper dev(%s)\n",
 		       tc->dev ? tc->dev->name : "NULL");
 		return -1;
 	}
@@ -2005,7 +2005,7 @@ static int dp_ctp_tc_map_set_31(struct dp_tc_cfg *tc, int flag,
 	ctp_tc_cfg.nLogicalPortId = mtr_subif->subif.port_id;
 	ctp_tc_cfg.nSubIfIdGroup = mtr_subif->subif.subif;
 	if (gsw_ctp->CTP_PortConfigGet(gsw_handle, &ctp_tc_cfg)) {
-		PR_ERR("Failed to get CTP info for ep=%d subif=%d\n",
+		pr_err("Failed to get CTP info for ep=%d subif=%d\n",
 		       mtr_subif->subif.port_id, mtr_subif->subif.subif);
 		return -1;
 	}
@@ -2017,7 +2017,7 @@ static int dp_ctp_tc_map_set_31(struct dp_tc_cfg *tc, int flag,
 		ctp_tc_cfg.bForcedTrafficClass = 0;
 
 	if (gsw_ctp->CTP_PortConfigSet(gsw_handle, &ctp_tc_cfg)) {
-		PR_ERR("CTP tc set fail for ep=%d subif=%d tc=%d force=%d\n",
+		pr_err("CTP tc set fail for ep=%d subif=%d tc=%d force=%d\n",
 		       mtr_subif->subif.port_id, mtr_subif->subif.subif,
 		       tc->tc, tc->force);
 		return -1;
@@ -2176,7 +2176,7 @@ int register_dp_cap_gswip31(int flag)
 	cap.info.cap.max_num_bridge_port = 128;
 
 	if (register_dp_hw_cap(&cap, flag)) {
-		PR_ERR("Why register_dp_hw_cap fail\n");
+		pr_err("Why register_dp_hw_cap fail\n");
 		return -1;
 	}
 
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_ppv4.c b/drivers/net/datapath/dpm/gswip31/datapath_ppv4.c
index 0bba3535aad5..f795f3a3e3e4 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_ppv4.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_ppv4.c
@@ -89,7 +89,7 @@ int dp_pp_alloc_port(struct ppv4_port *info)
 	if (qos_port_allocate(qos_dev,
 			      info->cqm_deq_port,
 			      &qos_p_id)) {
-		PR_ERR("Failed to alloc QoS for deq_port=%d\n",
+		pr_err("Failed to alloc QoS for deq_port=%d\n",
 		       info->cqm_deq_port);
 		return -1;
 	}
@@ -122,7 +122,7 @@ int dp_pp_alloc_port(struct ppv4_port *info)
 	}
 #endif
 	if (qos_port_set(qos_dev, qos_p_id, &conf)) {
-		PR_ERR("qos_port_set fail for port(cqm/qos) %d/%d\n",
+		pr_err("qos_port_set fail for port(cqm/qos) %d/%d\n",
 		       info->cqm_deq_port, qos_p_id);
 		qos_port_remove(qos_dev, qos_p_id);
 		return -1;
@@ -146,7 +146,7 @@ int dp_pp_alloc_queue(struct ppv4_queue *info)
 	struct pp_qos_dev *qos_dev = priv->qdev;
 
 	if (qos_queue_allocate(qos_dev, &q_node_id)) {
-		PR_ERR("qos_queue_allocate fail\n");
+		pr_err("qos_queue_allocate fail\n");
 		return -1;
 	}
 	DP_DEBUG(DP_DBG_FLAG_QOS, "qos_queue_allocate ok q_node=%d\n",
@@ -157,14 +157,14 @@ int dp_pp_alloc_queue(struct ppv4_queue *info)
 	conf.queue_wred_max_allowed = 0x400; /*max qocc in pkt */
 	conf.queue_child_prop.parent = info->parent;
 	if (qos_queue_set(qos_dev, q_node_id, &conf)) {
-		PR_ERR("qos_queue_set fail for node_id=%d to parent=%d\n",
+		pr_err("qos_queue_set fail for node_id=%d to parent=%d\n",
 		       q_node_id, info->parent);
 		return -1;
 	}
 	DP_DEBUG(DP_DBG_FLAG_QOS, "To attach q_node=%d to parent_node=%d\n",
 		 q_node_id, conf.queue_child_prop.parent);
 	if (qos_queue_info_get(qos_dev, q_node_id, &q_info)) {
-		PR_ERR("qos_queue_info_get fail for queue node_id=%d\n",
+		pr_err("qos_queue_info_get fail for queue node_id=%d\n",
 		       q_node_id);
 		return -1;
 	}
@@ -194,7 +194,7 @@ int init_ppv4_qos(int inst, int flag)
 #endif
 
 	if (!priv) {
-		PR_ERR("priv is NULL\n");
+		pr_err("priv is NULL\n");
 		return DP_FAILURE;
 	}
 	if (!(flag & DP_PLATFORM_INIT)) {
@@ -204,13 +204,13 @@ int init_ppv4_qos(int inst, int flag)
 	}
 	priv->qdev = qos_dev_open(dp_port_prop[inst].qos_inst);
 	if (!priv->qdev) {
-		PR_ERR("Could not open qos instance %d\n",
+		pr_err("Could not open qos instance %d\n",
 		       dp_port_prop[inst].qos_inst);
 		return DP_FAILURE;
 	}
 	t = kzalloc(sizeof(*t), GFP_ATOMIC);
 	if (!t) {
-		PR_ERR("kzalloc fail: %d bytes\n", sizeof(*t));
+		pr_err("kzalloc fail: %d bytes\n", sizeof(*t));
 		return DP_FAILURE;
 	}
 	t->param.wred_total_avail_resources = 0x38000;
@@ -221,19 +221,19 @@ int init_ppv4_qos(int inst, int flag)
 		t->param.reserved_ports[i] = 1;
 	res = qos_dev_init(priv->qdev, &t->param);
 	if (res) {
-		PR_ERR("qos_dev_init fail for qos inst %d\n",
+		pr_err("qos_dev_init fail for qos inst %d\n",
 		       dp_port_prop[inst].qos_inst);
 		goto EXIT;
 	}
 	if (cbm_cpu_port_get(&cpu_data, 0)) {
-		PR_ERR("cbm_cpu_port_get for CPU port?\n");
+		pr_err("cbm_cpu_port_get for CPU port?\n");
 		goto EXIT;
 	}
 	/* Sotre drop/flush port's info */
 	flush_port = &cpu_data.dq_tx_flush_info;
 	idx = flush_port->deq_port;
 	if ((idx == 0) || (idx >= ARRAY_SIZE(dp_deq_port_tbl[inst]))) {
-		PR_ERR("Wrog DP Flush port[%d]\n", idx);
+		pr_err("Wrog DP Flush port[%d]\n", idx);
 		goto EXIT;
 	}
 	priv->cqm_drop_p = idx;
@@ -257,7 +257,7 @@ int init_ppv4_qos(int inst, int flag)
 	if (qos_port_allocate(priv->qdev,
 			      priv->cqm_drop_p,
 			      &priv->ppv4_drop_p)) {
-		PR_ERR("Failed to alloc  qos drop port=%d\n",
+		pr_err("Failed to alloc  qos drop port=%d\n",
 		       priv->cqm_drop_p);
 		goto EXIT;
 	}
@@ -290,14 +290,14 @@ int init_ppv4_qos(int inst, int flag)
 	}
 #endif
 	if (qos_port_set(priv->qdev, priv->ppv4_drop_p, &t->p_conf)) {
-		PR_ERR("qos_port_set fail for port(cqm/qos) %d/%d\n",
+		pr_err("qos_port_set fail for port(cqm/qos) %d/%d\n",
 		       priv->cqm_drop_p, priv->ppv4_drop_p);
 		qos_port_remove(priv->qdev, priv->ppv4_drop_p);
 		goto EXIT;
 	}
 
 	if (qos_queue_allocate(priv->qdev, &q)) {
-		PR_ERR("qos_queue_allocate fail\n");
+		pr_err("qos_queue_allocate fail\n");
 		qos_port_remove(priv->qdev, q);
 		goto EXIT;
 	}
@@ -309,14 +309,14 @@ int init_ppv4_qos(int inst, int flag)
 	t->q_conf.queue_wred_max_allowed = 0; /*max qocc in pkt */
 	t->q_conf.queue_child_prop.parent = priv->ppv4_drop_p;
 	if (qos_queue_set(priv->qdev, q, &t->q_conf)) {
-		PR_ERR("qos_queue_set fail for node_id=%d to parent=%d\n",
+		pr_err("qos_queue_set fail for node_id=%d to parent=%d\n",
 		       q, t->q_conf.queue_child_prop.parent);
 		goto EXIT;
 	}
 	DP_DEBUG(DP_DBG_FLAG_QOS, "To attach q_node=%d to parent_node=%d\n",
 		 q, priv->ppv4_drop_p);
 	if (qos_queue_info_get(priv->qdev, q, &t->q_info)) {
-		PR_ERR("qos_queue_info_get fail for queue node_id=%d\n",
+		pr_err("qos_queue_info_get fail for queue node_id=%d\n",
 		       q);
 		goto EXIT;
 	}
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c b/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
index 7a2f8be5a1cc..e852c9cd584c 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_ppv4_api.c
@@ -39,7 +39,7 @@ int qos_platform_set(int cmd_id, void *node, int flag)
 	inst = node_link->inst;
 	priv = HAL(inst);
 	if (!priv->qdev) {
-		PR_ERR("qdev NULL with inst=%d\n", inst);
+		pr_err("qdev NULL with inst=%d\n", inst);
 		return DP_FAILURE;
 	}
 
@@ -135,7 +135,7 @@ int qos_platform_set(int cmd_id, void *node, int flag)
 					      flag);
 		break;
 	default:
-		PR_ERR("no support yet cmd_id %d\n", cmd_id);
+		pr_err("no support yet cmd_id %d\n", cmd_id);
 		break;
 	}
 	return res;
@@ -148,12 +148,12 @@ static int limit_pp2dp(u32 pp_limit, u32 *dp_limit)
 	int i;
 
 	if (!dp_limit) {
-		PR_ERR("dp_limit is NULL!\n");
+		pr_err("dp_limit is NULL!\n");
 		return DP_FAILURE;
 	}
 
 	if (pp_limit > QOS_MAX_BANDWIDTH_LIMIT) {
-		PR_ERR("Wrong pp shaper limit: %u\n", pp_limit);
+		pr_err("Wrong pp shaper limit: %u\n", pp_limit);
 		return DP_FAILURE;
 	}
 
@@ -166,7 +166,7 @@ static int limit_pp2dp(u32 pp_limit, u32 *dp_limit)
 	*dp_limit = pp_limit * MBPS_2_KBPS;/* mbps to kbps */
 
 	if ((*dp_limit <= 0) || (*dp_limit > DP_MAX_SHAPER_LIMIT)) {
-		PR_ERR("Wrong dp shaper limit: %u\n", *dp_limit);
+		pr_err("Wrong dp shaper limit: %u\n", *dp_limit);
 		return DP_FAILURE;
 	}
 	return DP_SUCCESS;
@@ -178,12 +178,12 @@ static int limit_dp2pp(u32 dp_limit, u32 *pp_limit)
 	int i;
 
 	if (!pp_limit) {
-		PR_ERR("pp_limit is NULL!\n");
+		pr_err("pp_limit is NULL!\n");
 		return DP_FAILURE;
 	}
 
 	if ((dp_limit > DP_MAX_SHAPER_LIMIT) || (dp_limit == 0)) {
-		PR_ERR("Wrong dp shaper limit: %u\n", dp_limit);
+		pr_err("Wrong dp shaper limit: %u\n", dp_limit);
 		return DP_FAILURE;
 	}
 
@@ -200,7 +200,7 @@ static int limit_dp2pp(u32 dp_limit, u32 *pp_limit)
 		*pp_limit = dp_limit / MBPS_2_KBPS;
 
 	if (*pp_limit > QOS_MAX_BANDWIDTH_LIMIT) {
-		PR_ERR("Wrong dp shaper limit: %u\n", *pp_limit);
+		pr_err("Wrong dp shaper limit: %u\n", *pp_limit);
 		return DP_FAILURE;
 	}
 	return DP_SUCCESS;
@@ -227,7 +227,7 @@ int arbi_dp2pp(int dp_arbi)
 		if (arbi_maps[i].dp_arbi == dp_arbi)
 			return arbi_maps[i].pp_arbi;
 	}
-	PR_ERR("Wrong dp_arbitrate: %d\n", dp_arbi);
+	pr_err("Wrong dp_arbitrate: %d\n", dp_arbi);
 	return DP_FAILURE;
 }
 
@@ -302,12 +302,12 @@ static int queue_flush_31(int inst, int node_id, int flag)
 	struct dp_lookup_entry *lookup = NULL;
 
 	if (qid < 0) {
-		PR_ERR("no physical qid for q_node=%d\n", node_id);
+		pr_err("no physical qid for q_node=%d\n", node_id);
 		res = DP_FAILURE;
 		goto EXIT;
 	}
 	if (qos_queue_conf_get(priv->qdev, node_id, &queue_cfg)) {
-		PR_ERR("qos_queue_conf_get fail: q[%d/%d]\n",
+		pr_err("qos_queue_conf_get fail: q[%d/%d]\n",
 		       qid, node_id);
 		res = DP_FAILURE;
 		goto EXIT;
@@ -315,19 +315,19 @@ static int queue_flush_31(int inst, int node_id, int flag)
 	lookup = kzalloc(sizeof(*lookup), GFP_ATOMIC);
 	if (!lookup) {
 		res = DP_FAILURE;
-		PR_ERR("kmalloc fail to alloc %d bytes\n", sizeof(*lookup));
+		pr_err("kmalloc fail to alloc %d bytes\n", sizeof(*lookup));
 		goto EXIT;
 	}
 	/* map to drop queue and save the changed lookup entries for recover */
 	if (dp_map_to_drop_q(inst, qid, lookup)) {
-		PR_ERR("failed to dp_map_to_drop_q for Q:%d\n", qid);
+		pr_err("failed to dp_map_to_drop_q for Q:%d\n", qid);
 		res = DP_FAILURE;
 		goto EXIT;
 	}
 	/* block/disable: ensure to drop all coming enqueue packet */
 	if (queue_cfg.blocked == 0) { /* to block */
 		if (pp_qos_queue_block(priv->qdev, node_id)) {
-			PR_ERR("pp_qos_queue_block fail: q[%d/%d]\n",
+			pr_err("pp_qos_queue_block fail: q[%d/%d]\n",
 			       qid, node_id);
 			res = DP_FAILURE;
 			goto EXIT;
@@ -366,7 +366,7 @@ static int queue_flush_31(int inst, int node_id, int flag)
 		tmp_q_cfg.queue_wred_max_allowed = DEF_QRED_MAX_ALLOW;
 		tmp_q_cfg.queue_child_prop.parent = priv->ppv4_drop_p;
 		if (qos_queue_set(priv->qdev, node_id, &tmp_q_cfg)) {
-			PR_ERR("qos_queue_set fail for queue=%d to parent=%d\n",
+			pr_err("qos_queue_set fail for queue=%d to parent=%d\n",
 			       qid, tmp_q_cfg.queue_child_prop.parent);
 			goto EXIT;
 		}
@@ -380,7 +380,7 @@ static int queue_flush_31(int inst, int node_id, int flag)
 #ifdef DP_FLUSH_SUSPEND_Q
 		/* set to suspend again before move back to original parent */
 		if (pp_qos_queue_suspend(priv->qdev, node_id)) {
-			PR_ERR("pp_qos_queue_suspend fail q[%d] to parent=%d\n",
+			pr_err("pp_qos_queue_suspend fail q[%d] to parent=%d\n",
 			       qid, tmp_q_cfg.queue_child_prop.parent);
 			goto EXIT;
 		}
@@ -391,7 +391,7 @@ static int queue_flush_31(int inst, int node_id, int flag)
 		 * with orignal variable queue_cfg
 		 */
 		if (qos_queue_set(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("qos_queue_conf_get fail: q[%d/%d]\n",
+			pr_err("qos_queue_conf_get fail: q[%d/%d]\n",
 			       qid, node_id);
 			res = DP_FAILURE;
 			goto EXIT;
@@ -404,7 +404,7 @@ static int queue_flush_31(int inst, int node_id, int flag)
 
 #ifdef DP_FLUSH_SUSPEND_Q
 	if (pp_qos_queue_suspend(priv->qdev, node_id)) {
-		PR_ERR("qos_queue_set fail\n");
+		pr_err("qos_queue_set fail\n");
 		goto EXIT;
 	}
 	DP_DEBUG(DP_DBG_FLAG_QOS,
@@ -501,26 +501,26 @@ static int node_queue_dec(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	phy_id = get_qid_by_node(inst, node_id, flag);
 	if (phy_id == DP_FAILURE) {
-		PR_ERR("get_qid_by_node failed\n");
+		pr_err("get_qid_by_node failed\n");
 		return DP_FAILURE;
 	}
 
 	pid = get_parent_node(inst, node_id, flag);
 	if (pid == DP_FAILURE) {
-		PR_ERR("get_parent_node failed for Q:%d\n", phy_id);
+		pr_err("get_parent_node failed for Q:%d\n", phy_id);
 		return DP_FAILURE;
 	}
 	DP_DEBUG(DP_DBG_FLAG_QOS, "parent:%d of Q:%d\n", pid, phy_id);
 
 	idx = get_child_idx_node_id(inst, node_id, 0);
 	if (idx == DP_FAILURE) {
-		PR_ERR("get_child_idx_node_id failed for Q:%d\n", phy_id);
+		pr_err("get_child_idx_node_id failed for Q:%d\n", phy_id);
 		return DP_FAILURE;
 	}
 	DP_DEBUG(DP_DBG_FLAG_QOS,
@@ -528,12 +528,12 @@ static int node_queue_dec(int inst, int node_id, int flag)
 		 pid, phy_id, node_id, idx);
 
 	if (!(priv->qos_queue_stat[phy_id].flag & PP_NODE_ACTIVE)) {
-		PR_ERR("Wrong Q[%d] Stat(%d):Expect ACTIVE\n", phy_id,
+		pr_err("Wrong Q[%d] Stat(%d):Expect ACTIVE\n", phy_id,
 		       priv->qos_queue_stat[phy_id].flag);
 		return DP_FAILURE;
 	}
 	if (!priv->qos_sch_stat[node_id].parent.flag) {
-		PR_ERR("Wrong Q[%d]'s Parent Stat(%d):Expect ACTIVE\n",
+		pr_err("Wrong Q[%d]'s Parent Stat(%d):Expect ACTIVE\n",
 		       node_id, priv->qos_sch_stat[node_id].parent.flag);
 		return DP_FAILURE;
 	}
@@ -562,26 +562,26 @@ static int node_queue_inc(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	phy_id = get_qid_by_node(inst, node_id, flag);
 	if (phy_id == DP_FAILURE) {
-		PR_ERR("get_qid_by_node failed\n");
+		pr_err("get_qid_by_node failed\n");
 		return DP_FAILURE;
 	}
 
 	pid = get_parent_node(inst, node_id, flag);
 	if (pid == DP_FAILURE) {
-		PR_ERR("get_parent_node failed for Q:%d\n", phy_id);
+		pr_err("get_parent_node failed for Q:%d\n", phy_id);
 		return DP_FAILURE;
 	}
 	DP_DEBUG(DP_DBG_FLAG_QOS, "parent:%d of Q:%d\n", pid, phy_id);
 
 	idx = get_free_child_idx(inst, pid, 0);
 	if (idx == DP_FAILURE) {
-		PR_ERR("get_free_child_idx failed for Q:%d\n", phy_id);
+		pr_err("get_free_child_idx failed for Q:%d\n", phy_id);
 		return DP_FAILURE;
 	}
 	DP_DEBUG(DP_DBG_FLAG_QOS,
@@ -589,7 +589,7 @@ static int node_queue_inc(int inst, int node_id, int flag)
 		 pid, phy_id, node_id, idx);
 
 	if (!(priv->qos_queue_stat[phy_id].flag & PP_NODE_ALLOC)) {
-		PR_ERR("Wrong Q[%d] Stat(%d):Expect ALLOC\n", phy_id,
+		pr_err("Wrong Q[%d] Stat(%d):Expect ALLOC\n", phy_id,
 		       priv->qos_queue_stat[phy_id].flag);
 		return DP_FAILURE;
 	}
@@ -621,12 +621,12 @@ static int node_queue_rst(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (phy_id == DP_FAILURE) {
-		PR_ERR("get_qid_by_node failed\n");
+		pr_err("get_qid_by_node failed\n");
 		return DP_FAILURE;
 	}
 	dp_port = priv->qos_queue_stat[phy_id].dp_port;
@@ -637,7 +637,7 @@ static int node_queue_rst(int inst, int node_id, int flag)
 		 phy_id, node_id, resv_idx);
 
 	if (!(priv->qos_queue_stat[phy_id].flag & PP_NODE_ALLOC)) {
-		PR_ERR("Wrong Q[%d] Stat(%d):Expect ALLOC\n", phy_id,
+		pr_err("Wrong Q[%d] Stat(%d):Expect ALLOC\n", phy_id,
 		       priv->qos_queue_stat[phy_id].flag);
 		return DP_FAILURE;
 	}
@@ -674,7 +674,7 @@ static int node_sched_dec(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -684,7 +684,7 @@ static int node_sched_dec(int inst, int node_id, int flag)
 
 		if (!priv->qos_sch_stat[node_id].child_num ||
 		    !(priv->qos_sch_stat[node_id].c_flag & PP_NODE_ACTIVE)) {
-			PR_ERR("Wrong Sch[%d] Stat(%d)/child_num(%d):%s\n",
+			pr_err("Wrong Sch[%d] Stat(%d)/child_num(%d):%s\n",
 			       node_id, priv->qos_sch_stat[node_id].c_flag,
 			       priv->qos_sch_stat[node_id].child_num,
 			       "Expect ACTIVE Or non-zero child_num");
@@ -697,14 +697,14 @@ static int node_sched_dec(int inst, int node_id, int flag)
 	} else if (flag & P_FLAG) {
 		pid = get_parent_node(inst, node_id, flag);
 		if (pid == DP_FAILURE) {
-			PR_ERR("get_parent_node failed for sched:%d\n",
+			pr_err("get_parent_node failed for sched:%d\n",
 			       node_id);
 			return DP_FAILURE;
 		}
 
 		idx = get_child_idx_node_id(inst, node_id, flag);
 		if (idx == DP_FAILURE) {
-			PR_ERR("get_child_idx_node_id failed for sched:%d\n",
+			pr_err("get_child_idx_node_id failed for sched:%d\n",
 			       node_id);
 			return DP_FAILURE;
 		}
@@ -714,12 +714,12 @@ static int node_sched_dec(int inst, int node_id, int flag)
 			 pid, node_id, idx);
 
 		if (!(priv->qos_sch_stat[node_id].p_flag & PP_NODE_ACTIVE)) {
-			PR_ERR("Wrong Sch[%d] Stat(%d):Expect ACTIVE\n",
+			pr_err("Wrong Sch[%d] Stat(%d):Expect ACTIVE\n",
 			       node_id, priv->qos_sch_stat[node_id].p_flag);
 			return DP_FAILURE;
 		}
 		if (!priv->qos_sch_stat[node_id].parent.flag) {
-			PR_ERR("Wrong SCH[%d] Parent Stat(%d):Expect ACTIV\n",
+			pr_err("Wrong SCH[%d] Parent Stat(%d):Expect ACTIV\n",
 			       node_id,
 			       priv->qos_sch_stat[node_id].parent.flag);
 			return DP_FAILURE;
@@ -750,7 +750,7 @@ static int node_sched_inc(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -760,7 +760,7 @@ static int node_sched_inc(int inst, int node_id, int flag)
 
 		if (priv->qos_sch_stat[node_id].child_num &&
 		    !(priv->qos_sch_stat[node_id].c_flag & PP_NODE_ACTIVE)) {
-			PR_ERR("Wrong Sch[%d] Stat(%d)/child_num(%d):%s\n",
+			pr_err("Wrong Sch[%d] Stat(%d)/child_num(%d):%s\n",
 			       node_id, priv->qos_sch_stat[node_id].c_flag,
 			       priv->qos_sch_stat[node_id].child_num,
 			       "Expect ACTIVE And Non-Zero child_num");
@@ -768,7 +768,7 @@ static int node_sched_inc(int inst, int node_id, int flag)
 		}
 		if (!priv->qos_sch_stat[node_id].child_num &&
 		    !(priv->qos_sch_stat[node_id].c_flag & PP_NODE_ALLOC)) {
-			PR_ERR("Wrong Sch[%d] Stat(%d)/child_num(%d):%s\n",
+			pr_err("Wrong Sch[%d] Stat(%d)/child_num(%d):%s\n",
 			       node_id, priv->qos_sch_stat[node_id].c_flag,
 			       priv->qos_sch_stat[node_id].child_num,
 			       "Expect ALLOC And zero child_num");
@@ -780,20 +780,20 @@ static int node_sched_inc(int inst, int node_id, int flag)
 	} else if (flag & P_FLAG) {
 		pid = get_parent_node(inst, node_id, flag);
 		if (pid == DP_FAILURE) {
-			PR_ERR("get_parent_node failed for sched:%d\n",
+			pr_err("get_parent_node failed for sched:%d\n",
 			       node_id);
 			return DP_FAILURE;
 		}
 
 		idx = get_free_child_idx(inst, pid, 0);
 		if (idx == DP_FAILURE) {
-			PR_ERR("get_free_child_idx failed for sched:%d\n",
+			pr_err("get_free_child_idx failed for sched:%d\n",
 			       node_id);
 			return DP_FAILURE;
 		}
 
 		if (!(priv->qos_sch_stat[node_id].p_flag & PP_NODE_ALLOC)) {
-			PR_ERR("Wrong Sch[%d] Stat(%d):Expect ALLOC\n",
+			pr_err("Wrong Sch[%d] Stat(%d):Expect ALLOC\n",
 			       node_id, priv->qos_sch_stat[node_id].p_flag);
 			return DP_FAILURE;
 		}
@@ -831,7 +831,7 @@ static int node_sched_rst(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	dp_port = priv->qos_sch_stat[node_id].dp_port;
@@ -846,7 +846,7 @@ static int node_sched_rst(int inst, int node_id, int flag)
 	if (priv->qos_sch_stat[node_id].child_num ||
 	    !(priv->qos_sch_stat[node_id].c_flag & PP_NODE_ALLOC) ||
 	    !(priv->qos_sch_stat[node_id].p_flag & PP_NODE_ALLOC)) {
-		PR_ERR("Wrong Sch[%d] c_flag(%d)/p_flag(%d)/child_num(%d):%s\n",
+		pr_err("Wrong Sch[%d] c_flag(%d)/p_flag(%d)/child_num(%d):%s\n",
 		       node_id, priv->qos_sch_stat[node_id].c_flag,
 		       priv->qos_sch_stat[node_id].p_flag,
 		       priv->qos_sch_stat[node_id].child_num,
@@ -883,19 +883,19 @@ static int node_port_dec(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	phy_id = get_cqm_deq_port_by_node(inst, node_id, flag);
 	if (phy_id == DP_FAILURE) {
-		PR_ERR("get_cqm_deq_port_by_node failed\n");
+		pr_err("get_cqm_deq_port_by_node failed\n");
 		return DP_FAILURE;
 	}
 
 	if (!priv->deq_port_stat[phy_id].child_num ||
 	    !(priv->deq_port_stat[phy_id].flag & PP_NODE_ACTIVE)) {
-		PR_ERR("Wrong P[%d] Stat(%d)/child_num(%d):%s\n",
+		pr_err("Wrong P[%d] Stat(%d)/child_num(%d):%s\n",
 		       phy_id, priv->deq_port_stat[phy_id].flag,
 		       priv->deq_port_stat[phy_id].child_num,
 		       "Expect ACTIVE Or non-zero child_num");
@@ -920,19 +920,19 @@ static int node_port_inc(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	phy_id = get_cqm_deq_port_by_node(inst, node_id, flag);
 	if (phy_id == DP_FAILURE) {
-		PR_ERR("get_cqm_deq_port_by_node failed\n");
+		pr_err("get_cqm_deq_port_by_node failed\n");
 		return DP_FAILURE;
 	}
 
 	if (priv->deq_port_stat[phy_id].child_num &&
 	    !(priv->deq_port_stat[phy_id].flag & PP_NODE_ACTIVE)) {
-		PR_ERR("Wrong P[%d] Stat(%d)/child_num(%d):%s\n", phy_id,
+		pr_err("Wrong P[%d] Stat(%d)/child_num(%d):%s\n", phy_id,
 		       priv->deq_port_stat[phy_id].flag,
 		       priv->deq_port_stat[phy_id].child_num,
 		       "Expect ACTIVE And Non-Zero child_num");
@@ -940,7 +940,7 @@ static int node_port_inc(int inst, int node_id, int flag)
 	}
 	if (!priv->deq_port_stat[phy_id].child_num &&
 	    !(priv->deq_port_stat[phy_id].flag & PP_NODE_ALLOC)) {
-		PR_ERR("Wrong P[%d] Stat(%d)/child_num(%d):%s\n", phy_id,
+		pr_err("Wrong P[%d] Stat(%d)/child_num(%d):%s\n", phy_id,
 		       priv->deq_port_stat[phy_id].flag,
 		       priv->deq_port_stat[phy_id].child_num,
 		       "Expect ALLOC And Zero child_num");
@@ -965,19 +965,19 @@ static int node_port_rst(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	phy_id = get_cqm_deq_port_by_node(inst, node_id, flag);
 	if (phy_id == DP_FAILURE) {
-		PR_ERR("get_cqm_deq_port_by_node failed\n");
+		pr_err("get_cqm_deq_port_by_node failed\n");
 		return DP_FAILURE;
 	}
 
 	if (priv->deq_port_stat[phy_id].child_num ||
 	    !(priv->deq_port_stat[phy_id].flag & PP_NODE_ALLOC)) {
-		PR_ERR("Wrong P[%d] Stat(%d)/child_num(%d):%s\n", phy_id,
+		pr_err("Wrong P[%d] Stat(%d)/child_num(%d):%s\n", phy_id,
 		       priv->deq_port_stat[phy_id].flag,
 		       priv->deq_port_stat[phy_id].child_num,
 		       "Expect ALLOC Or non-zero child_num");
@@ -1048,26 +1048,26 @@ static int dp_link_unset(struct dp_node_link *info, int flag)
 	struct hal_priv *priv;
 
 	if (!info) {
-		PR_ERR("info cannot be NULL\n");
+		pr_err("info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(info->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (info->node_type == DP_NODE_QUEUE) {
 		node_id = priv->qos_queue_stat[info->node_id.q_id].node_id;
 		if (qos_queue_conf_get(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("failed to qos_queue_conf_get\n");
+			pr_err("failed to qos_queue_conf_get\n");
 			return DP_FAILURE;
 		}
 		if (queue_cfg.queue_child_prop.parent ==
 						*(int *)&info->p_node_id) {
 			if (qos_queue_remove(priv->qdev, node_id)) {
-				PR_ERR("failed to qos_queue_remove\n");
+				pr_err("failed to qos_queue_remove\n");
 				return DP_FAILURE;
 			}
 		}
@@ -1075,14 +1075,14 @@ static int dp_link_unset(struct dp_node_link *info, int flag)
 	} else if (info->node_type == DP_NODE_SCH) {
 		if (qos_sched_conf_get(priv->qdev, info->node_id.sch_id,
 				       &sched_cfg)) {
-			PR_ERR("failed to qos_queue_conf_get\n");
+			pr_err("failed to qos_queue_conf_get\n");
 			return DP_FAILURE;
 		}
 		if (sched_cfg.sched_child_prop.parent ==
 						*(int *)&info->p_node_id) {
 			if (qos_sched_remove(priv->qdev,
 					     info->node_id.sch_id)) {
-				PR_ERR("failed to qos_sched_remove\n");
+				pr_err("failed to qos_sched_remove\n");
 				return DP_FAILURE;
 			}
 		}
@@ -1119,12 +1119,12 @@ static int dp_node_alloc_resv_pool(struct dp_node_alloc *node, int flag)
 	struct resv_q *resv_q;
 
 	if (!node) {
-		PR_ERR("node is  NULL\n");
+		pr_err("node is  NULL\n");
 		return DP_FAILURE;
 	}
 	priv = node ? HAL(node->inst) : NULL;
 	if (!priv) {
-		PR_ERR("priv is NULL\n");
+		pr_err("priv is NULL\n");
 		return DP_FAILURE;
 	}
 	resv_q = priv->resv[node->dp_port].resv_q;
@@ -1211,31 +1211,31 @@ static int dp_node_alloc_global_pool(struct dp_node_alloc *node, int flag)
 	int res = DP_FAILURE;
 
 	if (!node) {
-		PR_ERR("node is  NULL\n");
+		pr_err("node is  NULL\n");
 		goto EXIT;
 	}
 
 	priv = HAL(node->inst);
 	if (!priv) {
-		PR_ERR("priv is NULL\n");
+		pr_err("priv is NULL\n");
 		goto EXIT;
 	}
 
 	q_conf = kzalloc(sizeof(*q_conf), GFP_KERNEL);
 	if (!q_conf) {
-		PR_ERR("fail to alloc %d bytes\n", sizeof(*q_conf));
+		pr_err("fail to alloc %d bytes\n", sizeof(*q_conf));
 		goto EXIT;
 	}
 
 	qos_queue_info = kzalloc(sizeof(*qos_queue_info), GFP_KERNEL);
 	if (!qos_queue_info) {
-		PR_ERR("fail to alloc %d bytes\n", sizeof(*qos_queue_info));
+		pr_err("fail to alloc %d bytes\n", sizeof(*qos_queue_info));
 		goto EXIT;
 	}
 
 	if (node->type == DP_NODE_QUEUE) {
 		if (qos_queue_allocate(priv->qdev, &id)) {
-			PR_ERR("qos_queue_allocate failed\n");
+			pr_err("qos_queue_allocate failed\n");
 			goto EXIT;
 		}
 		DP_DEBUG(DP_DBG_FLAG_QOS, "qos_queue_allocate: %d\n", id);
@@ -1255,7 +1255,7 @@ static int dp_node_alloc_global_pool(struct dp_node_alloc *node, int flag)
 		q_conf->queue_child_prop.parent = priv->ppv4_tmp_p;
 #endif /* WORKAROUND_DROP_PORT */
 		if (qos_queue_set(priv->qdev, id, q_conf)) {
-			PR_ERR("qos_queue_set fail for queue=%d to parent=%d\n",
+			pr_err("qos_queue_set fail for queue=%d to parent=%d\n",
 			       id, q_conf->queue_child_prop.parent);
 			goto EXIT;
 		}
@@ -1266,7 +1266,7 @@ static int dp_node_alloc_global_pool(struct dp_node_alloc *node, int flag)
 #endif /* WORKAROUND_PORT_SET */
 		if (qos_queue_info_get(priv->qdev, id, qos_queue_info)) {
 			qos_queue_remove(priv->qdev, id);
-			PR_ERR("qos_queue_info_get: %d\n", id);
+			pr_err("qos_queue_info_get: %d\n", id);
 			goto EXIT;
 		}
 
@@ -1288,7 +1288,7 @@ static int dp_node_alloc_global_pool(struct dp_node_alloc *node, int flag)
 		goto EXIT;
 	} else if (node->type == DP_NODE_SCH) {
 		if (qos_sched_allocate(priv->qdev, &id)) {
-			PR_ERR("failed to qos_sched_allocate\n");
+			pr_err("failed to qos_sched_allocate\n");
 			qos_sched_remove(priv->qdev, id);
 			goto EXIT;
 		}
@@ -1302,7 +1302,7 @@ static int dp_node_alloc_global_pool(struct dp_node_alloc *node, int flag)
 		res = DP_SUCCESS;
 		goto EXIT;
 	} else {
-		PR_ERR("Unknown node type %d\n", node->type);
+		pr_err("Unknown node type %d\n", node->type);
 	}
 
 EXIT:
@@ -1324,13 +1324,13 @@ static int dp_alloc_qos_port(struct dp_node_alloc *node, int flag)
 	struct hal_priv *priv;
 
 	if (!node) {
-		PR_ERR("node NULL\n");
+		pr_err("node NULL\n");
 		goto EXIT;
 	}
 	inst = node->inst;
 	priv = HAL(node->inst);
 	if (!priv) {
-		PR_ERR("priv NULL\n");
+		pr_err("priv NULL\n");
 		goto EXIT;
 	}
 	cqm_deq_port = node->id.cqm_deq_port;
@@ -1338,7 +1338,7 @@ static int dp_alloc_qos_port(struct dp_node_alloc *node, int flag)
 		 "inst=%d dp_port=%d cqm_deq_port=%d\n",
 		 node->inst, node->dp_port, cqm_deq_port);
 	if (cqm_deq_port == DP_NODE_AUTO_ID) {
-		PR_ERR("cqm_deq_port wrong: %d\n", cqm_deq_port);
+		pr_err("cqm_deq_port wrong: %d\n", cqm_deq_port);
 		goto EXIT;
 	}
 	if (priv->deq_port_stat[cqm_deq_port].flag != PP_NODE_FREE) {
@@ -1347,7 +1347,7 @@ static int dp_alloc_qos_port(struct dp_node_alloc *node, int flag)
 		return priv->deq_port_stat[cqm_deq_port].node_id;
 	}
 	if (qos_port_allocate(priv->qdev, cqm_deq_port, &qos_port)) {
-		PR_ERR("failed to qos_port_allocate:%d\n", cqm_deq_port);
+		pr_err("failed to qos_port_allocate:%d\n", cqm_deq_port);
 		goto EXIT;
 	}
 	/* Configure QOS dequeue port */
@@ -1378,7 +1378,7 @@ static int dp_alloc_qos_port(struct dp_node_alloc *node, int flag)
 	}
 #endif
 	if (qos_port_set(priv->qdev, qos_port, &port_cfg)) {
-		PR_ERR("qos_port_set fail for port %d/%d\n",
+		pr_err("qos_port_set fail for port %d/%d\n",
 		       cqm_deq_port, qos_port);
 		qos_port_remove(priv->qdev, qos_port);
 		goto EXIT;
@@ -1405,13 +1405,13 @@ int dp_node_alloc_31(struct dp_node_alloc *node, int flag)
 	struct hal_priv *priv;
 
 	if (!node) {
-		PR_ERR("node NULL\n");
+		pr_err("node NULL\n");
 		return DP_FAILURE;
 	}
 
 	priv = HAL(node->inst);
 	if (!priv) {
-		PR_ERR("priv is NULL cannot proceed!!\n");
+		pr_err("priv is NULL cannot proceed!!\n");
 		return DP_FAILURE;
 	}
 
@@ -1487,13 +1487,13 @@ static int dp_smart_free_from_child_31(struct dp_node_alloc *node, int flag)
 	struct hal_priv *priv;
 
 	if (!node) {
-		PR_ERR("node is NULL cannot proceed!!\n");
+		pr_err("node is NULL cannot proceed!!\n");
 		return DP_FAILURE;
 	}
 
 	priv = HAL(node->inst);
 	if (!priv) {
-		PR_ERR("priv is NULL cannot proceed!!\n");
+		pr_err("priv is NULL cannot proceed!!\n");
 		return DP_FAILURE;
 	}
 
@@ -1503,7 +1503,7 @@ static int dp_smart_free_from_child_31(struct dp_node_alloc *node, int flag)
 		 node->id.q_id);
 	if (node->type == DP_NODE_QUEUE) {
 		if ((node->id.q_id < 0) || (node->id.q_id >= MAX_QUEUE)) {
-			PR_ERR("Wrong Parameter: QID[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: QID[%d]Out Of Range\n",
 			       node->id.q_id);
 			return DP_FAILURE;
 		}
@@ -1519,18 +1519,18 @@ static int dp_smart_free_from_child_31(struct dp_node_alloc *node, int flag)
 			DP_DEBUG(DP_DBG_FLAG_QOS,
 				 "current node doesnot have parent\n");
 		} else if (dp_node_unlink_31(&info, 0)) {
-			PR_ERR("dp_node_unlink_31 failed\n");
+			pr_err("dp_node_unlink_31 failed\n");
 			return DP_FAILURE;
 		}
 
 		if (dp_node_free_31(node, 0)) {
-			PR_ERR("failed to free Queue:[%d]\n", node->id.q_id);
+			pr_err("failed to free Queue:[%d]\n", node->id.q_id);
 			return DP_FAILURE;
 		}
 	} else if (node->type == DP_NODE_SCH) {
 		if ((node->id.sch_id < 0) ||
 		    (node->id.sch_id >= QOS_MAX_NODES)) {
-			PR_ERR("Wrong Parameter: Sched[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: Sched[%d]Out Of Range\n",
 			       node->id.sch_id);
 			return DP_FAILURE;
 		}
@@ -1548,19 +1548,19 @@ static int dp_smart_free_from_child_31(struct dp_node_alloc *node, int flag)
 		}
 
 		if (dp_node_free_31(node, 0)) {
-			PR_ERR("failed to free Sched:[%d]\n", node->id.sch_id);
+			pr_err("failed to free Sched:[%d]\n", node->id.sch_id);
 			return DP_FAILURE;
 		}
 	} else if (node->type == DP_NODE_PORT) {
 		if ((node->id.cqm_deq_port < 0) ||
 		    (node->id.cqm_deq_port >= MAX_CQM_DEQ)) {
-			PR_ERR("Wrong Parameter: Port[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: Port[%d]Out Of Range\n",
 			       node->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
 
 		if (dp_node_free_31(node, 0)) {
-			PR_ERR("failed to free Port:[%d]\n",
+			pr_err("failed to free Port:[%d]\n",
 			       node->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
@@ -1580,14 +1580,14 @@ static int dp_smart_free_from_child_31(struct dp_node_alloc *node, int flag)
 							 flag);
 			id = temp.id.cqm_deq_port;
 			if ((id < 0) || (id >= MAX_CQM_DEQ)) {
-				PR_ERR("Wrong Parameter: Port[%d]%s\n",
+				pr_err("Wrong Parameter: Port[%d]%s\n",
 				       id, "Out Of Range");
 				return DP_FAILURE;
 			}
 		} else {
 			id = temp.id.sch_id;
 			if ((id < 0) || (id >= QOS_MAX_NODES)) {
-				PR_ERR("Wrong Parameter: Sched[%d]%s\n",
+				pr_err("Wrong Parameter: Sched[%d]%s\n",
 				       id, "Out Of Range");
 				return DP_FAILURE;
 			}
@@ -1608,7 +1608,7 @@ static int dp_smart_free_from_child_31(struct dp_node_alloc *node, int flag)
 		f_free = (dp_node_link_get_31(&info, 0));
 		res = dp_node_free_31(&temp, 0);
 		if (res) {
-			PR_ERR("failed to free node:%d res %d\n",
+			pr_err("failed to free node:%d res %d\n",
 			       temp.id.q_id, res);
 			return DP_FAILURE;
 		}
@@ -1634,20 +1634,20 @@ int dp_free_children_via_parent_31(struct dp_node_alloc *node, int flag)
 	struct hal_priv *priv;
 
 	if (!node) {
-		PR_ERR("node is NULL cannot proceed!!\n");
+		pr_err("node is NULL cannot proceed!!\n");
 		return DP_FAILURE;
 	}
 
 	priv = HAL(node->inst);
 	if (!priv) {
-		PR_ERR("priv is NULL cannot proceed!!\n");
+		pr_err("priv is NULL cannot proceed!!\n");
 		return DP_FAILURE;
 	}
 
 	if (node->type == DP_NODE_PORT) {
 		if ((node->id.cqm_deq_port < 0) ||
 		    (node->id.cqm_deq_port >= MAX_CQM_DEQ)) {
-			PR_ERR("Wrong Parameter: Port[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: Port[%d]Out Of Range\n",
 			       node->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
@@ -1671,7 +1671,7 @@ int dp_free_children_via_parent_31(struct dp_node_alloc *node, int flag)
 				else
 					temp.id.q_id = child_id;
 				if (dp_free_children_via_parent_31(&temp, 0)) {
-					PR_ERR("fail %s=%d child:%d type=%d\n",
+					pr_err("fail %s=%d child:%d type=%d\n",
 					       "to free Port's",
 					       node->id.cqm_deq_port,
 					       CHILD(id, idx).node_id,
@@ -1688,7 +1688,7 @@ int dp_free_children_via_parent_31(struct dp_node_alloc *node, int flag)
 
 		if (!priv->qos_sch_stat[id].child_num) {
 			if (dp_node_free_31(node, 0)) {
-				PR_ERR("failed to free Port:[%d]\n",
+				pr_err("failed to free Port:[%d]\n",
 				       node->id.cqm_deq_port);
 				return DP_FAILURE;
 			}
@@ -1696,7 +1696,7 @@ int dp_free_children_via_parent_31(struct dp_node_alloc *node, int flag)
 	} else if (node->type == DP_NODE_SCH) {
 		if ((node->id.sch_id < 0) ||
 		    (node->id.sch_id >= QOS_MAX_NODES)) {
-			PR_ERR("Wrong Parameter: Sched[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: Sched[%d]Out Of Range\n",
 			       node->id.sch_id);
 			return DP_FAILURE;
 		}
@@ -1720,7 +1720,7 @@ int dp_free_children_via_parent_31(struct dp_node_alloc *node, int flag)
 				else
 					temp.id.q_id = child_id;
 				if (dp_free_children_via_parent_31(&temp, 0)) {
-					PR_ERR("fail %s=%d child:%d type=%d\n",
+					pr_err("fail %s=%d child:%d type=%d\n",
 					       "to free Sched's",
 					       node->id.sch_id,
 					       CHILD(id, idx).node_id,
@@ -1741,14 +1741,14 @@ int dp_free_children_via_parent_31(struct dp_node_alloc *node, int flag)
 
 		if (!priv->qos_sch_stat[id].child_num) {
 			if (dp_node_free_31(node, 0)) {
-				PR_ERR("failed to free Sched:[%d]\n",
+				pr_err("failed to free Sched:[%d]\n",
 				       node->id.sch_id);
 				return DP_FAILURE;
 			}
 		}
 	} else if (node->type == DP_NODE_QUEUE) {
 		if ((node->id.q_id < 0) || (node->id.q_id >= MAX_QUEUE)) {
-			PR_ERR("Wrong Parameter: QID[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: QID[%d]Out Of Range\n",
 			       node->id.q_id);
 			return DP_FAILURE;
 		}
@@ -1762,12 +1762,12 @@ int dp_free_children_via_parent_31(struct dp_node_alloc *node, int flag)
 
 		if (priv->qos_queue_stat[node->id.q_id].flag != PP_NODE_FREE) {
 			if (dp_node_unlink_31(&info, 0)) {
-				PR_ERR("dp_node_unlink_31 failed\n");
+				pr_err("dp_node_unlink_31 failed\n");
 				return DP_FAILURE;
 			}
 
 			if (dp_node_free_31(node, 0)) {
-				PR_ERR("failed to free Queue:[%d]\n",
+				pr_err("failed to free Queue:[%d]\n",
 				       node->id.q_id);
 				return DP_FAILURE;
 			}
@@ -1779,7 +1779,7 @@ int dp_free_children_via_parent_31(struct dp_node_alloc *node, int flag)
 				 info.p_node_type);
 		}
 	} else {
-		PR_ERR("Incorrect Parameter:%d\n", node->type);
+		pr_err("Incorrect Parameter:%d\n", node->type);
 		return DP_FAILURE;
 	}
 	return DP_SUCCESS;
@@ -1812,25 +1812,25 @@ int dp_node_free_31(struct dp_node_alloc *node, int flag)
 	int res = DP_FAILURE;
 
 	if (!node) {
-		PR_ERR("node is NULL cannot proceed!!\n");
+		pr_err("node is NULL cannot proceed!!\n");
 		return DP_FAILURE;
 	}
 
 	priv = HAL(node->inst);
 	if (!priv) {
-		PR_ERR("priv is NULL cannot proceed!!\n");
+		pr_err("priv is NULL cannot proceed!!\n");
 		return DP_FAILURE;
 	}
 	t = kzalloc(sizeof(*t), GFP_ATOMIC);
 	if (!t) {
-		PR_ERR("fail to alloc %d bytes\n", sizeof(*t));
+		pr_err("fail to alloc %d bytes\n", sizeof(*t));
 		return DP_FAILURE;
 	}
 
 	if (flag == DP_NODE_SMART_FREE) {/* dont pass flag */
 		res = dp_smart_free_from_child_31(node, 0);
 		if (res == DP_FAILURE) {
-			PR_ERR("dp_smart_free_from_child_31 failed\n");
+			pr_err("dp_smart_free_from_child_31 failed\n");
 			goto EXIT;
 		}
 	}
@@ -1841,7 +1841,7 @@ int dp_node_free_31(struct dp_node_alloc *node, int flag)
 		t->resv_flag = priv->qos_queue_stat[node->id.q_id].flag;
 
 		if (priv->qos_queue_stat[node->id.q_id].flag == PP_NODE_FREE) {
-			PR_ERR("Node Q[%d] is already Free Stat\n",
+			pr_err("Node Q[%d] is already Free Stat\n",
 			       node->id.q_id);
 			goto EXIT;
 		}
@@ -1850,11 +1850,11 @@ int dp_node_free_31(struct dp_node_alloc *node, int flag)
 			res = node_stat_update(node->inst, t->node_id,
 					       DP_NODE_RST);
 			if (res == DP_FAILURE) {
-				PR_ERR("node_stat_update failed\n");
+				pr_err("node_stat_update failed\n");
 				goto EXIT;
 			}
 			if (qos_queue_remove(priv->qdev, t->node_id)) {
-				PR_ERR("failed to qos_queue_remove\n");
+				pr_err("failed to qos_queue_remove\n");
 				goto EXIT;
 			}
 			res = DP_SUCCESS;
@@ -1865,7 +1865,7 @@ int dp_node_free_31(struct dp_node_alloc *node, int flag)
 		t->info.node_id = node->id;
 		t->info.node_type = node->type;
 		if (dp_node_unlink_31(&t->info, 0)) {
-			PR_ERR("failed to dp_node_unlink_31 for Q:%d\n",
+			pr_err("failed to dp_node_unlink_31 for Q:%d\n",
 			       node->id.q_id);
 			goto EXIT;
 		}
@@ -1876,18 +1876,18 @@ int dp_node_free_31(struct dp_node_alloc *node, int flag)
 		/* Remove Queue link only for global resource */
 		if (!(t->resv_flag & PP_NODE_RESERVE)) {
 			if (qos_queue_remove(priv->qdev, t->node_id)) {
-				PR_ERR("failed to qos_queue_remove\n");
+				pr_err("failed to qos_queue_remove\n");
 				goto EXIT;
 			}
 		}
 		if (node_stat_update(node->inst, t->node_id, DP_NODE_DEC)) {
-			PR_ERR("node_stat_update failed\n");
+			pr_err("node_stat_update failed\n");
 			goto EXIT;
 		}
 		/* call node_stat_update to update parent status */
 		if (node_stat_update(node->inst, t->parent_id,
 				     DP_NODE_DEC | C_FLAG)) {
-			PR_ERR("stat update fail Q:[%d/%d]'s parent:%d\n",
+			pr_err("stat update fail Q:[%d/%d]'s parent:%d\n",
 			       node->id.q_id, t->node_id, t->parent_id);
 			goto EXIT;
 		}
@@ -1897,7 +1897,7 @@ int dp_node_free_31(struct dp_node_alloc *node, int flag)
 		/* call node_Stat_update to free the node */
 		if (node_stat_update(node->inst, t->node_id,
 				     DP_NODE_RST)) {
-			PR_ERR("node_stat_update failed\n");
+			pr_err("node_stat_update failed\n");
 			goto EXIT;
 		}
 		DP_DEBUG(DP_DBG_FLAG_QOS,
@@ -1908,7 +1908,7 @@ int dp_node_free_31(struct dp_node_alloc *node, int flag)
 			qos_queue_conf_set_default(&t->tmp_q);
 			t->tmp_q.queue_child_prop.parent = priv->ppv4_drop_p;
 			if (qos_queue_set(priv->qdev, t->node_id, &t->tmp_q)) {
-				PR_ERR("qos_queue_set %s=%d to parent=%d\n",
+				pr_err("qos_queue_set %s=%d to parent=%d\n",
 				       "fail to reserve queue", t->node_id,
 				       t->tmp_q.queue_child_prop.parent);
 				goto EXIT;
@@ -1926,14 +1926,14 @@ int dp_node_free_31(struct dp_node_alloc *node, int flag)
 		t->resv_flag = priv->qos_sch_stat[t->sch_id].p_flag;
 
 		if (priv->qos_sch_stat[t->sch_id].child_num) {
-			PR_ERR("Node Sch[%d] still have child num %d\n",
+			pr_err("Node Sch[%d] still have child num %d\n",
 			       t->sch_id,
 			       priv->qos_sch_stat[t->sch_id].child_num);
 			goto EXIT;
 		}
 
 		if (priv->qos_sch_stat[t->sch_id].p_flag == PP_NODE_FREE) {
-			PR_ERR("Node Sch[%d] is already Free Stat\n",
+			pr_err("Node Sch[%d] is already Free Stat\n",
 			       t->sch_id);
 			goto EXIT;
 		}
@@ -1941,11 +1941,11 @@ int dp_node_free_31(struct dp_node_alloc *node, int flag)
 		if (qos_sched_conf_get(priv->qdev, t->sch_id, &t->sched_cfg)) {
 			if (node_stat_update(node->inst, t->sch_id,
 					     DP_NODE_RST | P_FLAG)) {
-				PR_ERR("node_stat_update failed\n");
+				pr_err("node_stat_update failed\n");
 				goto EXIT;
 			}
 			if (qos_sched_remove(priv->qdev, t->sch_id)) {
-				PR_ERR("failed to qos_sched_remove\n");
+				pr_err("failed to qos_sched_remove\n");
 				goto EXIT;
 			}
 			res = DP_SUCCESS;
@@ -1957,19 +1957,19 @@ int dp_node_free_31(struct dp_node_alloc *node, int flag)
 		/* Remove Sched link only if global resource */
 		if (!(t->resv_flag & PP_NODE_RESERVE)) {
 			if (qos_sched_remove(priv->qdev, t->sch_id)) {
-				PR_ERR("failed to qos_sched_remove\n");
+				pr_err("failed to qos_sched_remove\n");
 				goto EXIT;
 			}
 		}
 		if (node_stat_update(node->inst, t->sch_id,
 				     DP_NODE_DEC | P_FLAG)) {
-			PR_ERR("node_stat_update failed\n");
+			pr_err("node_stat_update failed\n");
 			goto EXIT;
 		}
 		/* call node_stat_update to update parent status */
 		if (node_stat_update(node->inst, t->parent_id,
 				     DP_NODE_DEC | C_FLAG)) {
-			PR_ERR("stat update fail Sch:[%d]'s parent:%d\n",
+			pr_err("stat update fail Sch:[%d]'s parent:%d\n",
 			       node->id.sch_id, t->parent_id);
 			goto EXIT;
 		}
@@ -1979,7 +1979,7 @@ int dp_node_free_31(struct dp_node_alloc *node, int flag)
 		/* call node_stat_update to free the node */
 		if (node_stat_update(node->inst, t->sch_id,
 				     DP_NODE_RST | P_FLAG)) {
-			PR_ERR("Node Reset failed Sched[/%d]\n",
+			pr_err("Node Reset failed Sched[/%d]\n",
 			       node->id.sch_id);
 			goto EXIT;
 		}
@@ -1991,7 +1991,7 @@ int dp_node_free_31(struct dp_node_alloc *node, int flag)
 			qos_sched_conf_set_default(&t->tmp_sch);
 			t->tmp_sch.sched_child_prop.parent = priv->ppv4_drop_p;
 			if (qos_sched_set(priv->qdev, t->sch_id, &t->tmp_sch)) {
-				PR_ERR("qos_sched_set %s=%d to parent=%d\n",
+				pr_err("qos_sched_set %s=%d to parent=%d\n",
 				       "fail to reserve SCH", t->sch_id,
 				       t->tmp_sch.sched_child_prop.parent);
 				goto EXIT;
@@ -2008,7 +2008,7 @@ int dp_node_free_31(struct dp_node_alloc *node, int flag)
 		t->node_id = priv->deq_port_stat[t->phy_id].node_id;
 
 		if (priv->deq_port_stat[t->phy_id].child_num) {
-			PR_ERR("Node port[%d] still have child num %d\n",
+			pr_err("Node port[%d] still have child num %d\n",
 			       t->phy_id,
 			       priv->deq_port_stat[t->phy_id].child_num);
 			goto EXIT;
@@ -2017,7 +2017,7 @@ int dp_node_free_31(struct dp_node_alloc *node, int flag)
 			res = node_stat_update(node->inst, t->node_id,
 					       DP_NODE_DEC);
 			if (res == DP_FAILURE) {
-				PR_ERR("Wrong Port %d flag:0x%x\n", t->phy_id,
+				pr_err("Wrong Port %d flag:0x%x\n", t->phy_id,
 				       priv->deq_port_stat[t->phy_id].flag);
 				goto EXIT;
 			}
@@ -2028,15 +2028,15 @@ int dp_node_free_31(struct dp_node_alloc *node, int flag)
 			res = DP_SUCCESS;
 			goto EXIT;
 		}
-		PR_ERR("Unexpect port %d flag %d\n",
+		pr_err("Unexpect port %d flag %d\n",
 		       t->phy_id, priv->deq_port_stat[t->phy_id].flag);
 		goto EXIT;
 	}
-	PR_ERR("Unexpect node->type %d\n", node->type);
+	pr_err("Unexpect node->type %d\n", node->type);
 
 EXIT:
 	if (res == DP_FAILURE)
-		PR_ERR("failed to free node:%d res %d\n",
+		pr_err("failed to free node:%d res %d\n",
 		       node->id.q_id, res);
 	kfree(t);
 	t = NULL;
@@ -2060,7 +2060,7 @@ static int dp_qos_parent_chk(struct dp_node_link *info, int flag)
 			node.dp_port = info->dp_port;
 
 			if ((dp_node_alloc_31(&node, flag)) == DP_FAILURE) {
-				PR_ERR("dp_node_alloc_31 queue alloc fail\n");
+				pr_err("dp_node_alloc_31 queue alloc fail\n");
 				return DP_FAILURE;
 			}
 			info->p_node_id = node.id;
@@ -2088,37 +2088,37 @@ static int get_parent_arbi(int inst, int node_id, int flag)
 	struct pp_qos_port_conf port_cfg = {0};
 
 	if (priv->qos_sch_stat[node_id].parent.flag == PP_NODE_FREE) {
-		PR_ERR("Parent is not set for node\n");
+		pr_err("Parent is not set for node\n");
 		return DP_FAILURE;
 	}
 	pid = priv->qos_sch_stat[node_id].parent.node_id;
 
 	if (priv->qos_sch_stat[node_id].parent.type == DP_NODE_SCH) {
 		if (qos_sched_conf_get(priv->qdev, pid, &sched_cfg)) {
-			PR_ERR("fail to get sched config\n");
+			pr_err("fail to get sched config\n");
 			return DP_FAILURE;
 		}
 		arbi = arbi_pp2dp(sched_cfg.sched_parent_prop.arbitration);
 		if (arbi == DP_FAILURE)
-			PR_ERR("Wrong pp_arbitrate: %d for %s:%d\n",
+			pr_err("Wrong pp_arbitrate: %d for %s:%d\n",
 			       port_cfg.port_parent_prop.arbitration,
 			       (priv->qos_sch_stat[node_id].type == DP_NODE_SCH)
 			       ? "sched" : "Q",
 			       node_id);
 	} else if (priv->qos_sch_stat[node_id].parent.type == DP_NODE_PORT) {
 		if (qos_port_conf_get(priv->qdev, pid, &port_cfg)) {
-			PR_ERR("fail to get port config\n");
+			pr_err("fail to get port config\n");
 			return DP_FAILURE;
 		}
 		arbi = arbi_pp2dp(port_cfg.port_parent_prop.arbitration);
 		if (arbi == DP_FAILURE)
-			PR_ERR("Wrong pp_arbitrate: %d for %s:%d\n",
+			pr_err("Wrong pp_arbitrate: %d for %s:%d\n",
 			       port_cfg.port_parent_prop.arbitration,
 			       (priv->qos_sch_stat[node_id].type == DP_NODE_SCH)
 			       ? "sched" : "Q",
 			       node_id);
 	} else {
-		PR_ERR("incorrect parent type:0x%x for node:%d.\n",
+		pr_err("incorrect parent type:0x%x for node:%d.\n",
 		       priv->qos_sch_stat[node_id].parent.type,
 		       node_id);
 		return DP_FAILURE;
@@ -2138,20 +2138,20 @@ int dp_node_link_get_31(struct dp_node_link *info, int flag)
 	int node_id, arbi;
 
 	if (!info) {
-		PR_ERR("info cannot be NULL\n");
+		pr_err("info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(info->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (info->node_type == DP_NODE_QUEUE) {
 		node_id = priv->qos_queue_stat[info->node_id.q_id].node_id;
 		if (qos_queue_conf_get(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("failed to qos_queue_conf_get\n");
+			pr_err("failed to qos_queue_conf_get\n");
 			return DP_FAILURE;
 		}
 		if (!queue_cfg.queue_child_prop.parent)
@@ -2184,16 +2184,16 @@ int dp_node_link_get_31(struct dp_node_link *info, int flag)
 	} else if (info->node_type == DP_NODE_SCH) {
 		if (qos_sched_conf_get(priv->qdev, info->node_id.sch_id,
 				       &sched_cfg)) {
-			PR_ERR("failed to qos_sched_conf_get\n");
+			pr_err("failed to qos_sched_conf_get\n");
 			return DP_FAILURE;
 		}
 		if (!sched_cfg.sched_child_prop.parent) {
-			PR_ERR("sched child do not have parent\n");
+			pr_err("sched child do not have parent\n");
 			return DP_FAILURE;
 		}
 		if (!(priv->qos_sch_stat[info->node_id.sch_id].p_flag &
 		      PP_NODE_ACTIVE)) {
-			PR_ERR("sched id %d flag not active, flag %d\n",
+			pr_err("sched id %d flag not active, flag %d\n",
 			       info->node_id.sch_id,
 			       priv->qos_sch_stat[info->node_id.sch_id].p_flag);
 			return DP_FAILURE;
@@ -2314,7 +2314,7 @@ static int dp_link_set(struct dp_node_link *info, int parent_node, int flag)
 			 queue_cfg->queue_child_prop.parent,
 			 info->cqm_deq_port.cqm_deq_port);
 		if (qos_queue_set(priv->qdev, node_id, queue_cfg)) {
-			PR_ERR("failed to qos_queue_set\n");
+			pr_err("failed to qos_queue_set\n");
 			qos_queue_remove(priv->qdev, node_id);
 			goto ERROR_EXIT;
 		}
@@ -2342,7 +2342,7 @@ static int dp_link_set(struct dp_node_link *info, int parent_node, int flag)
 			 info->cqm_deq_port.cqm_deq_port);
 
 		if (qos_sched_set(priv->qdev, node_id, sched_cfg)) {
-			PR_ERR("failed to %s %d parent_node %d\n",
+			pr_err("failed to %s %d parent_node %d\n",
 			       "qos_sched_set node_id",
 			       node_id, parent_node);
 			qos_sched_remove(priv->qdev, node_id);
@@ -2386,7 +2386,7 @@ static int set_parent_arbi(int inst, int node_id, int arbi, int flag)
 	struct pp_qos_port_conf port_cfg = {0};
 
 	if (priv->qos_sch_stat[node_id].parent.flag == PP_NODE_FREE) {
-		PR_ERR("Parent is not set for node\n");
+		pr_err("Parent is not set for node\n");
 		return DP_FAILURE;
 	}
 	pid = priv->qos_sch_stat[node_id].parent.node_id;
@@ -2394,34 +2394,34 @@ static int set_parent_arbi(int inst, int node_id, int arbi, int flag)
 	arbi = arbi_dp2pp(arbi);
 
 	if (arbi == DP_FAILURE) {
-		PR_ERR("Incorrect arbitration value provided:%d!\n", arbi);
+		pr_err("Incorrect arbitration value provided:%d!\n", arbi);
 		return DP_FAILURE;
 	}
 
 	if (priv->qos_sch_stat[node_id].parent.type == DP_NODE_SCH) {
 		if (qos_sched_conf_get(priv->qdev, pid, &sched_cfg)) {
-			PR_ERR("fail to get sched config\n");
+			pr_err("fail to get sched config\n");
 			return DP_FAILURE;
 		}
 		sched_cfg.sched_parent_prop.arbitration = arbi;
 		if (qos_sched_set(priv->qdev, pid, &sched_cfg)) {
-			PR_ERR("fail to set arbi sched:%d parent of node:%d\n",
+			pr_err("fail to set arbi sched:%d parent of node:%d\n",
 			       pid, node_id);
 			return DP_FAILURE;
 		}
 	} else if (priv->qos_sch_stat[node_id].parent.type == DP_NODE_PORT) {
 		if (qos_port_conf_get(priv->qdev, pid, &port_cfg)) {
-			PR_ERR("fail to get port config\n");
+			pr_err("fail to get port config\n");
 			return DP_FAILURE;
 		}
 		port_cfg.port_parent_prop.arbitration = arbi;
 		if (qos_port_set(priv->qdev, pid, &port_cfg)) {
-			PR_ERR("fail to set arbi port:%d parent of node:%d\n",
+			pr_err("fail to set arbi port:%d parent of node:%d\n",
 			       pid, node_id);
 			return DP_FAILURE;
 		}
 	} else {
-		PR_ERR("incorrect parent type:0x%x for node:%d.\n",
+		pr_err("incorrect parent type:0x%x for node:%d.\n",
 		       priv->qos_sch_stat[node_id].parent.type,
 		       node_id);
 		return DP_FAILURE;
@@ -2441,29 +2441,29 @@ int dp_qos_link_prio_set_31(struct dp_node_prio *info, int flag)
 	int node_id;
 
 	if (!info) {
-		PR_ERR("info cannot be NULL\n");
+		pr_err("info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(info->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (info->type == DP_NODE_QUEUE) {
 		if ((info->id.q_id < 0) || (info->id.q_id >= MAX_QUEUE)) {
-			PR_ERR("Invalid Queue ID:%d\n", info->id.q_id);
+			pr_err("Invalid Queue ID:%d\n", info->id.q_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_queue_stat[info->id.q_id].flag == PP_NODE_FREE) {
-			PR_ERR("Invalid Queue flag:0x%x\n",
+			pr_err("Invalid Queue flag:0x%x\n",
 			       priv->qos_queue_stat[info->id.q_id].flag);
 			return DP_FAILURE;
 		}
 		node_id = priv->qos_queue_stat[info->id.q_id].node_id;
 		if (qos_queue_conf_get(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("fail to get queue prio and parent\n");
+			pr_err("fail to get queue prio and parent\n");
 			return DP_FAILURE;
 		}
 		if (info->arbi == ARBITRATION_WRR) {
@@ -2477,12 +2477,12 @@ int dp_qos_link_prio_set_31(struct dp_node_prio *info, int flag)
 			 "Prio:%d paased to low level for queue[%d]\n",
 			 info->prio_wfq, info->id.q_id);
 		if (qos_queue_set(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("failed to qos_queue_set\n");
+			pr_err("failed to qos_queue_set\n");
 			return DP_FAILURE;
 		}
 		/* get parent conf and set arbi in parent */
 		if (set_parent_arbi(info->inst, node_id, info->arbi, flag)) {
-			PR_ERR("fail to set arbi:%d in Parent of Q:%d\n",
+			pr_err("fail to set arbi:%d in Parent of Q:%d\n",
 			       info->arbi, node_id);
 			return DP_FAILURE;
 		}
@@ -2493,18 +2493,18 @@ int dp_qos_link_prio_set_31(struct dp_node_prio *info, int flag)
 	} else if (info->type == DP_NODE_SCH) {
 		if ((info->id.sch_id < 0) ||
 		    (info->id.sch_id >= QOS_MAX_NODES)) {
-			PR_ERR("Invalid Sched ID:%d\n", info->id.sch_id);
+			pr_err("Invalid Sched ID:%d\n", info->id.sch_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_sch_stat[info->id.sch_id].p_flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Invalid Sched flag:0x%x\n",
+			pr_err("Invalid Sched flag:0x%x\n",
 			       priv->qos_sch_stat[info->id.sch_id].p_flag);
 			return DP_FAILURE;
 		}
 		if (qos_sched_conf_get(priv->qdev, info->id.sch_id,
 				       &sched_cfg)) {
-			PR_ERR("fail to get sched prio and parent\n");
+			pr_err("fail to get sched prio and parent\n");
 			return DP_FAILURE;
 		}
 		if (info->arbi == ARBITRATION_WRR) {
@@ -2517,13 +2517,13 @@ int dp_qos_link_prio_set_31(struct dp_node_prio *info, int flag)
 			 "Prio:%d paased to low level for Sched[%d]\n",
 			 info->prio_wfq, info->id.sch_id);
 		if (qos_sched_set(priv->qdev, info->id.sch_id, &sched_cfg)) {
-			PR_ERR("failed to qos_sched_set\n");
+			pr_err("failed to qos_sched_set\n");
 			return DP_FAILURE;
 		}
 		/* get parent conf and set arbi in parent */
 		if (set_parent_arbi(info->inst, info->id.sch_id,
 				    info->arbi, 0)) {
-			PR_ERR("fail to set arbi:%d Parent of Sched:%d\n",
+			pr_err("fail to set arbi:%d Parent of Sched:%d\n",
 			       info->arbi, info->id.sch_id);
 			return DP_FAILURE;
 		}
@@ -2532,7 +2532,7 @@ int dp_qos_link_prio_set_31(struct dp_node_prio *info, int flag)
 			 info->id.sch_id, info->arbi, info->prio_wfq);
 		return DP_SUCCESS;
 	}
-	PR_ERR("incorrect info type provided:0x%x\n", info->type);
+	pr_err("incorrect info type provided:0x%x\n", info->type);
 	return DP_FAILURE;
 }
 
@@ -2548,29 +2548,29 @@ int dp_qos_link_prio_get_31(struct dp_node_prio *info, int flag)
 	int node_id, arbi;
 
 	if (!info) {
-		PR_ERR("info cannot be NULL\n");
+		pr_err("info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(info->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (info->type == DP_NODE_QUEUE) {
 		if ((info->id.q_id < 0) || (info->id.q_id >= MAX_QUEUE)) {
-			PR_ERR("Invalid Queue ID:%d\n", info->id.q_id);
+			pr_err("Invalid Queue ID:%d\n", info->id.q_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_queue_stat[info->id.q_id].flag == PP_NODE_FREE) {
-			PR_ERR("Invalid Queue flag:%d\n",
+			pr_err("Invalid Queue flag:%d\n",
 			       priv->qos_queue_stat[info->id.q_id].flag);
 			return DP_FAILURE;
 		}
 		node_id = priv->qos_queue_stat[info->id.q_id].node_id;
 		if (qos_queue_conf_get(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("fail to get queue prio_wfq value!\n");
+			pr_err("fail to get queue prio_wfq value!\n");
 			return DP_FAILURE;
 		}
 
@@ -2591,18 +2591,18 @@ int dp_qos_link_prio_get_31(struct dp_node_prio *info, int flag)
 	} else if (info->type == DP_NODE_SCH) {
 		if ((info->id.sch_id < 0) ||
 		    (info->id.sch_id >= QOS_MAX_NODES)) {
-			PR_ERR("Invalid Sched ID:%d\n", info->id.sch_id);
+			pr_err("Invalid Sched ID:%d\n", info->id.sch_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_sch_stat[info->id.sch_id].p_flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Invalid Sched flag:%d\n",
+			pr_err("Invalid Sched flag:%d\n",
 			       priv->qos_sch_stat[info->id.sch_id].p_flag);
 			return DP_FAILURE;
 		}
 		if (qos_sched_conf_get(priv->qdev, info->id.sch_id,
 				       &sched_cfg)) {
-			PR_ERR("fail to get sched arbi and prio values!\n");
+			pr_err("fail to get sched arbi and prio values!\n");
 			return DP_FAILURE;
 		}
 
@@ -2623,7 +2623,7 @@ int dp_qos_link_prio_get_31(struct dp_node_prio *info, int flag)
 
 		return DP_SUCCESS;
 	}
-	PR_ERR("incorrect info type provided:0x%x\n", info->type);
+	pr_err("incorrect info type provided:0x%x\n", info->type);
 	return DP_FAILURE;
 }
 
@@ -2652,13 +2652,13 @@ int dp_deq_port_res_get_31(struct dp_dequeue_res *res, int flag)
 	struct pmac_port_info *port_info;
 
 	if (!res) {
-		PR_ERR("res cannot be NULL\n");
+		pr_err("res cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(res->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	port_info = get_dp_port_info(res->inst, res->dp_port);
@@ -2688,7 +2688,7 @@ int dp_deq_port_res_get_31(struct dp_dequeue_res *res, int flag)
 		if (qos_port_get_queues(priv->qdev,
 					priv->deq_port_stat[k].node_id,
 					q_ids, q_size, &q_num)) {
-			PR_ERR("qos_port_get_queues: port[%d/%d]\n",
+			pr_err("qos_port_get_queues: port[%d/%d]\n",
 			       k,
 			       priv->deq_port_stat[k].node_id);
 			return DP_FAILURE;
@@ -2705,7 +2705,7 @@ int dp_deq_port_res_get_31(struct dp_dequeue_res *res, int flag)
 			memset(&t.q_info, 0, sizeof(t.q_info));
 			if (qos_queue_info_get(priv->qdev,
 					       q_ids[i], &t.q_info)) {
-				PR_ERR("qos_port_info_get fail:q[/%d]\n",
+				pr_err("qos_port_info_get fail:q[/%d]\n",
 				       q_ids[i]);
 				continue;
 			}
@@ -2717,7 +2717,7 @@ int dp_deq_port_res_get_31(struct dp_dequeue_res *res, int flag)
 			memset(&t.q_conf, 0, sizeof(t.q_conf));
 			if (qos_queue_conf_get(priv->qdev,
 					       q_ids[i], &t.q_conf)) {
-				PR_ERR("qos_port_conf_get fail:q[/%d]\n",
+				pr_err("qos_port_conf_get fail:q[/%d]\n",
 				       q_ids[i]);
 				continue;
 			}
@@ -2733,7 +2733,7 @@ int dp_deq_port_res_get_31(struct dp_dequeue_res *res, int flag)
 					break;
 				} else if (priv->qos_sch_stat[p_id].type !=
 					   DP_NODE_SCH) {
-					PR_ERR("wrong p[/%d] type:%d\n",
+					pr_err("wrong p[/%d] type:%d\n",
 					       p_id,
 					       priv->qos_sch_stat[p_id].type);
 					break;
@@ -2745,7 +2745,7 @@ int dp_deq_port_res_get_31(struct dp_dequeue_res *res, int flag)
 				/* get next parent */
 				if (qos_sched_conf_get(priv->qdev,
 						       p_id, &t.sched_conf)) {
-					PR_ERR("qos_sched_conf_get %s[/%d]\n",
+					pr_err("qos_sched_conf_get %s[/%d]\n",
 					       "fail:sch", p_id);
 					break;
 				}
@@ -2773,13 +2773,13 @@ int dp_node_unlink_31(struct dp_node_link *info, int flag)
 	int i, node_id;
 
 	if (!info) {
-		PR_ERR("info cannot be NULL\n");
+		pr_err("info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(info->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -2788,7 +2788,7 @@ int dp_node_unlink_31(struct dp_node_link *info, int flag)
 		/* Need to check ACTIVE Flag */
 		if (!(priv->qos_queue_stat[info->node_id.q_id].flag &
 		    PP_NODE_ACTIVE)) {
-			PR_ERR("Wrong Queue[%d] Stat(%d):Expect ACTIVE\n",
+			pr_err("Wrong Queue[%d] Stat(%d):Expect ACTIVE\n",
 			       info->node_id.q_id,
 			       priv->qos_queue_stat[info->node_id.q_id].flag);
 		}
@@ -2801,7 +2801,7 @@ int dp_node_unlink_31(struct dp_node_link *info, int flag)
 	} else if (info->node_type == DP_NODE_SCH) {
 		if (!(priv->qos_sch_stat[info->node_id.sch_id].c_flag &
 								PP_NODE_ACTIVE))
-			PR_ERR("Wrong Sched FLAG Expect ACTIVE\n");
+			pr_err("Wrong Sched FLAG Expect ACTIVE\n");
 		if (qos_sched_conf_get(priv->qdev, info->node_id.sch_id,
 				       &sched_cfg))
 			return DP_FAILURE;
@@ -2851,24 +2851,24 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 	struct link_add_var *t = NULL;
 
 	if (!info) {
-		PR_ERR("info cannot be NULL\n");
+		pr_err("info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(info->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if ((!info->dp_port) && (info->dp_port != DP_PORT(info).dp_port)) {
-		PR_ERR("Fix wrong dp_port from %d to %d\n",
+		pr_err("Fix wrong dp_port from %d to %d\n",
 		       info->dp_port, DP_PORT(info).dp_port);
 		info->dp_port = DP_PORT(info).dp_port;
 	}
 	t = kzalloc(sizeof(*t), GFP_ATOMIC);
 	if (!t) {
-		PR_ERR("fail to alloc %d bytes\n", sizeof(*t));
+		pr_err("fail to alloc %d bytes\n", sizeof(*t));
 		return DP_FAILURE;
 	}
 	for (i = 0; i < ARRAY_SIZE(t->q_orig_block); i++) {
@@ -2886,7 +2886,7 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 		t->f_sch_auto_id = 1;
 	i = dp_qos_parent_chk(info, flag);
 	if (i == DP_FAILURE) {
-		PR_ERR("dp_qos_parent_chk fail\n");
+		pr_err("dp_qos_parent_chk fail\n");
 		goto EXIT_ERR;
 	}
 	t->parent.node_id = i;
@@ -2896,7 +2896,7 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 	/* Check parent's children limit not exceeded */
 	if (priv->qos_sch_stat[t->parent.node_id].child_num >=
 	    DP_MAX_CHILD_PER_NODE) {
-		PR_ERR("Child Num:%d is exceeding limit for Node:[%d]\n",
+		pr_err("Child Num:%d is exceeding limit for Node:[%d]\n",
 		       priv->qos_sch_stat[t->parent.node_id].child_num,
 		       t->parent.node_id);
 		goto EXIT_ERR;
@@ -2917,7 +2917,7 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 			t->node.dp_port = info->dp_port;
 			t->node.type = info->node_type;
 			if ((dp_node_alloc_31(&t->node, flag)) == DP_FAILURE) {
-				PR_ERR("dp_node_alloc_31 queue alloc fail\n");
+				pr_err("dp_node_alloc_31 queue alloc fail\n");
 				goto EXIT_ERR;
 			}
 			info->node_id = t->node.id;
@@ -2926,7 +2926,7 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 		/* add check for free flag and error */
 		if (priv->qos_queue_stat[info->node_id.q_id].flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Queue ID:%d is in Free state:0x%x\n",
+			pr_err("Queue ID:%d is in Free state:0x%x\n",
 			       info->node_id.q_id,
 			       priv->qos_queue_stat[info->node_id.q_id].flag);
 			goto EXIT_ERR;
@@ -2957,7 +2957,7 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 
 				if (node_stat_update(info->inst, t->node_id,
 						     DP_NODE_DEC)) {
-					PR_ERR("node_stat_update fail\n");
+					pr_err("node_stat_update fail\n");
 					goto EXIT_ERR;
 				}
 				/* reduce child_num in parent's global table */
@@ -2967,7 +2967,7 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 				if (node_stat_update(info->inst,
 						     PARENT(t->queue_cfg),
 						     DP_NODE_DEC | C_FLAG)) {
-					PR_ERR("node_stat_update fail\n");
+					pr_err("node_stat_update fail\n");
 					goto EXIT_ERR;
 				}
 			}
@@ -2981,7 +2981,7 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 		 *	goto EXIT_ERR;
 		 */
 		if (dp_link_set(info, t->parent.node_id, flag)) {
-			PR_ERR("dp_link_set fail to link to parent\n");
+			pr_err("dp_link_set fail to link to parent\n");
 			goto EXIT_ERR;
 		}
 	} else if (info->node_type == DP_NODE_SCH) {
@@ -2991,7 +2991,7 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 			t->node.type = info->node_type;
 
 			if ((dp_node_alloc_31(&t->node, flag)) == DP_FAILURE) {
-				PR_ERR("dp_node_alloc_31 sched alloc fail\n");
+				pr_err("dp_node_alloc_31 sched alloc fail\n");
 				goto EXIT_ERR;
 			}
 			info->node_id = t->node.id;
@@ -3004,7 +3004,7 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 		/* add check for free flag and error */
 		if (priv->qos_sch_stat[info->node_id.sch_id].p_flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Sched:%d is in Free state:0x%x\n",
+			pr_err("Sched:%d is in Free state:0x%x\n",
 			       info->node_id.sch_id,
 			       priv->qos_sch_stat[info->node_id.sch_id].p_flag);
 			goto EXIT_ERR;
@@ -3019,7 +3019,7 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 						 info->node_id.sch_id,
 						 t->queue_buf, t->queue_size,
 						 &t->queue_num)) {
-				PR_ERR("Can not get queues:%d\n",
+				pr_err("Can not get queues:%d\n",
 				       info->node_id.sch_id);
 				goto EXIT_ERR;
 			}
@@ -3038,13 +3038,13 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 			/* update flag for sch node */
 			if (node_stat_update(info->inst, info->node_id.sch_id,
 					     DP_NODE_DEC | P_FLAG)) {
-				PR_ERR("node_stat_update fail\n");
+				pr_err("node_stat_update fail\n");
 				goto EXIT_ERR;
 			}
 			/* reduce child_num in parent's global table */
 			if (node_stat_update(info->inst, PARENT_S(t->sched_cfg),
 					     DP_NODE_DEC | C_FLAG)) {
-				PR_ERR("node_stat_update fail\n");
+				pr_err("node_stat_update fail\n");
 				goto EXIT_ERR;
 			}
 		}
@@ -3056,7 +3056,7 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 		 *	goto EXIT_ERR;
 		 */
 		if (dp_link_set(info, t->parent.node_id, flag)) {
-			PR_ERR("dp_link_set failed to link to parent\n");
+			pr_err("dp_link_set failed to link to parent\n");
 			goto EXIT_ERR;
 		}
 	}
@@ -3083,7 +3083,7 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 		if (!t->f_restore)
 			continue;
 		if (qos_queue_set(priv->qdev, t->queue_buf[i], &t->queue_cfg)) {
-			PR_ERR("qos_queue_set fail for q[/%d]\n",
+			pr_err("qos_queue_set fail for q[/%d]\n",
 			       t->queue_buf[i]);
 			res = DP_FAILURE;
 		}
@@ -3104,7 +3104,7 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 				 "sched remove id %d\n", t->node.id.sch_id);
 			qos_sched_remove(priv->qdev, t->node.id.sch_id);
 		} else {
-			PR_ERR("Unexpect node type %d\n", t->node.type);
+			pr_err("Unexpect node type %d\n", t->node.type);
 		}
 	}
 	if (t->f_parent_free) {
@@ -3117,7 +3117,7 @@ int dp_node_link_add_31(struct dp_node_link *info, int flag)
 				 "sched remove id %d\n", t->parent.node_id);
 			qos_sched_remove(priv->qdev, t->parent.node_id);
 		} else {
-			PR_ERR("Unexpect node type %d\n", t->node.type);
+			pr_err("Unexpect node type %d\n", t->node.type);
 		}
 	}
 
@@ -3137,35 +3137,35 @@ int dp_queue_conf_set_31(struct dp_queue_conf *cfg, int flag)
 	int node_id, res = DP_FAILURE;
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(cfg->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	conf = kzalloc(sizeof(*conf), GFP_ATOMIC);
 	if (!conf) {
-		PR_ERR("fail to alloc %d bytes\n", sizeof(*conf));
+		pr_err("fail to alloc %d bytes\n", sizeof(*conf));
 		return DP_FAILURE;
 	}
 
 	if ((cfg->q_id < 0) || (cfg->q_id >= MAX_QUEUE)) {
-		PR_ERR("Invalid Queue ID:%d\n", cfg->q_id);
+		pr_err("Invalid Queue ID:%d\n", cfg->q_id);
 		goto EXIT;
 	}
 	if (priv->qos_queue_stat[cfg->q_id].flag == PP_NODE_FREE) {
-		PR_ERR("Invalid Queue flag:%d\n",
+		pr_err("Invalid Queue flag:%d\n",
 		       priv->qos_queue_stat[cfg->q_id].flag);
 		goto EXIT;
 	}
 	node_id = priv->qos_queue_stat[cfg->q_id].node_id;
 
 	if (qos_queue_conf_get(priv->qdev, node_id, conf)) {
-		PR_ERR("qos_queue_conf_get fail:%d\n", cfg->q_id);
+		pr_err("qos_queue_conf_get fail:%d\n", cfg->q_id);
 		goto EXIT;
 	}
 	if (flag & (cfg->act & DP_NODE_DIS))
@@ -3189,7 +3189,7 @@ int dp_queue_conf_set_31(struct dp_queue_conf *cfg, int flag)
 		conf->queue_wred_max_allowed = cfg->wred_max_allowed;
 	}
 	if (qos_queue_set(priv->qdev, node_id, conf)) {
-		PR_ERR("failed to qos_queue_set:%d\n", cfg->q_id);
+		pr_err("failed to qos_queue_set:%d\n", cfg->q_id);
 		goto EXIT;
 	}
 	res = DP_SUCCESS;
@@ -3211,35 +3211,35 @@ int dp_queue_conf_get_31(struct dp_queue_conf *cfg, int flag)
 	struct hal_priv *priv;
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(cfg->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	conf = kzalloc(sizeof(*conf), GFP_ATOMIC);
 	if (!conf) {
-		PR_ERR("fail to alloc %d bytes\n", sizeof(*conf));
+		pr_err("fail to alloc %d bytes\n", sizeof(*conf));
 		return DP_FAILURE;
 	}
 
 	if ((cfg->q_id < 0) || (cfg->q_id >= MAX_QUEUE)) {
-		PR_ERR("Invalid Queue ID:%d\n", cfg->q_id);
+		pr_err("Invalid Queue ID:%d\n", cfg->q_id);
 		goto EXIT;
 	}
 	if (priv->qos_queue_stat[cfg->q_id].flag == PP_NODE_FREE) {
-		PR_ERR("Invalid Queue flag:%d\n",
+		pr_err("Invalid Queue flag:%d\n",
 		       priv->qos_queue_stat[cfg->q_id].flag);
 		goto EXIT;
 	}
 	node_id = priv->qos_queue_stat[cfg->q_id].node_id;
 
 	if (qos_queue_conf_get(priv->qdev, node_id, conf)) {
-		PR_ERR("qos_queue_conf_get fail\n");
+		pr_err("qos_queue_conf_get fail\n");
 		goto EXIT;
 	}
 
@@ -3292,64 +3292,64 @@ int dp_node_link_en_set_31(struct dp_node_link_enable *en, int flag)
 	int node_id;
 
 	if (!en) {
-		PR_ERR("en info cannot be NULL\n");
+		pr_err("en info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(en->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if ((en->en & DP_NODE_EN) && (en->en & DP_NODE_DIS)) {
-		PR_ERR("enable & disable cannot be set together!\n");
+		pr_err("enable & disable cannot be set together!\n");
 		return DP_FAILURE;
 	}
 	if ((en->en & DP_NODE_SUSPEND) && (en->en & DP_NODE_RESUME)) {
-		PR_ERR("suspend & resume cannot be set together!\n");
+		pr_err("suspend & resume cannot be set together!\n");
 		return DP_FAILURE;
 	}
 
 	if (en->type == DP_NODE_QUEUE) {
 		if (!(en->en & (DP_NODE_EN | DP_NODE_DIS | DP_NODE_SUSPEND |
 				    DP_NODE_RESUME))) {
-			PR_ERR("Incorrect commands provided!\n");
+			pr_err("Incorrect commands provided!\n");
 			return DP_FAILURE;
 		}
 		if ((en->id.q_id < 0) || (en->id.q_id >= MAX_QUEUE)) {
-			PR_ERR("Wrong Parameter: QID[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: QID[%d]Out Of Range\n",
 			       en->id.q_id);
 			return DP_FAILURE;
 		}
 		node_id = priv->qos_queue_stat[en->id.q_id].node_id;
 
 		if (priv->qos_queue_stat[en->id.q_id].flag == PP_NODE_FREE) {
-			PR_ERR("Node Q[%d] is not allcoated\n", en->id.q_id);
+			pr_err("Node Q[%d] is not allcoated\n", en->id.q_id);
 			return DP_FAILURE;
 		}
 		if (en->en & DP_NODE_EN) {
 			if (pp_qos_queue_unblock(priv->qdev, node_id)) {
-				PR_ERR("pp_qos_queue_unblock fail Queue[%d]\n",
+				pr_err("pp_qos_queue_unblock fail Queue[%d]\n",
 				       en->id.q_id);
 				return DP_FAILURE;
 			}
 		}
 		if (en->en & DP_NODE_DIS) {
 			if (pp_qos_queue_block(priv->qdev, node_id)) {
-				PR_ERR("pp_qos_queue_block fail Queue[%d]\n",
+				pr_err("pp_qos_queue_block fail Queue[%d]\n",
 				       en->id.q_id);
 				return DP_FAILURE;
 			}
 		}
 
 		if (qos_queue_conf_get(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("qos_queue_conf_get fail: q[%d]\n", en->id.q_id);
+			pr_err("qos_queue_conf_get fail: q[%d]\n", en->id.q_id);
 			return DP_FAILURE;
 		}
 		if (en->en & DP_NODE_EN) {
 			if (queue_cfg.blocked) {
-				PR_ERR("Incorrect value set for Queue[%d]:%d\n",
+				pr_err("Incorrect value set for Queue[%d]:%d\n",
 				       en->id.q_id,
 				       queue_cfg.blocked);
 				return DP_FAILURE;
@@ -3357,7 +3357,7 @@ int dp_node_link_en_set_31(struct dp_node_link_enable *en, int flag)
 		}
 		if (en->en & DP_NODE_DIS) {
 			if (!queue_cfg.blocked) {
-				PR_ERR("Incorrect value set for Queue[%d]:%d\n",
+				pr_err("Incorrect value set for Queue[%d]:%d\n",
 				       en->id.q_id,
 				       queue_cfg.blocked);
 				return DP_FAILURE;
@@ -3366,22 +3366,22 @@ int dp_node_link_en_set_31(struct dp_node_link_enable *en, int flag)
 
 	} else if (en->type == DP_NODE_SCH) {
 		if (!(en->en & (DP_NODE_SUSPEND | DP_NODE_RESUME))) {
-			PR_ERR("Incorrect commands provided!\n");
+			pr_err("Incorrect commands provided!\n");
 			return DP_FAILURE;
 		}
 		if ((en->id.sch_id < 0) || (en->id.sch_id >= QOS_MAX_NODES)) {
-			PR_ERR("Wrong Parameter: Sched[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: Sched[%d]Out Of Range\n",
 			       en->id.sch_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_sch_stat[en->id.sch_id].p_flag == PP_NODE_FREE) {
-			PR_ERR("Node Sched[%d] is not allcoated\n",
+			pr_err("Node Sched[%d] is not allcoated\n",
 			       en->id.sch_id);
 			return DP_FAILURE;
 		}
 
 		if (qos_sched_conf_get(priv->qdev, en->id.sch_id, &sched_cfg)) {
-			PR_ERR("qos_sched_conf_get fail: sch[%d]\n",
+			pr_err("qos_sched_conf_get fail: sch[%d]\n",
 			       en->id.sch_id);
 			return DP_FAILURE;
 		}
@@ -3389,58 +3389,58 @@ int dp_node_link_en_set_31(struct dp_node_link_enable *en, int flag)
 	} else if (en->type == DP_NODE_PORT) {
 		if (!(en->en & (DP_NODE_EN | DP_NODE_DIS | DP_NODE_SUSPEND |
 				    DP_NODE_RESUME))) {
-			PR_ERR("Incorrect commands provided!\n");
+			pr_err("Incorrect commands provided!\n");
 			return DP_FAILURE;
 		}
 		if ((en->id.cqm_deq_port < 0) ||
 		    (en->id.cqm_deq_port >= MAX_CQM_DEQ)) {
-			PR_ERR("Wrong Parameter: Port[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: Port[%d]Out Of Range\n",
 			       en->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
 		if (priv->deq_port_stat[en->id.cqm_deq_port].flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Node Port[%d] is not allcoated\n",
+			pr_err("Node Port[%d] is not allcoated\n",
 			       en->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
 		node_id = priv->deq_port_stat[en->id.cqm_deq_port].node_id;
 		if (en->en & DP_NODE_EN) {
 			if (pp_qos_port_unblock(priv->qdev, node_id)) {
-				PR_ERR("pp_qos_port_unblock fail Port[%d]\n",
+				pr_err("pp_qos_port_unblock fail Port[%d]\n",
 				       en->id.cqm_deq_port);
 				return DP_FAILURE;
 			}
 		}
 		if (en->en & DP_NODE_DIS) {
 			if (pp_qos_port_block(priv->qdev, node_id)) {
-				PR_ERR("pp_qos_port_block fail Port[%d]\n",
+				pr_err("pp_qos_port_block fail Port[%d]\n",
 				       en->id.cqm_deq_port);
 				return DP_FAILURE;
 			}
 		}
 		if (en->en & DP_NODE_SUSPEND) {
 			if (pp_qos_port_disable(priv->qdev, node_id)) {
-				PR_ERR("pp_qos_port_disable fail Port[%d]\n",
+				pr_err("pp_qos_port_disable fail Port[%d]\n",
 				       en->id.cqm_deq_port);
 				return DP_FAILURE;
 			}
 		}
 		if (en->en & DP_NODE_RESUME) {
 			if (pp_qos_port_enable(priv->qdev, node_id)) {
-				PR_ERR("pp_qos_port_enable fail Port[%d]\n",
+				pr_err("pp_qos_port_enable fail Port[%d]\n",
 				       en->id.cqm_deq_port);
 				return DP_FAILURE;
 			}
 		}
 		if (qos_port_conf_get(priv->qdev, node_id, &port_cfg)) {
-			PR_ERR("qos_port_conf_get fail: port[%d]\n",
+			pr_err("qos_port_conf_get fail: port[%d]\n",
 			       en->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
 		if (en->en & DP_NODE_SUSPEND) {
 			if (!port_cfg.disable) {
-				PR_ERR("Incorrect value set for Port[%d]:%d\n",
+				pr_err("Incorrect value set for Port[%d]:%d\n",
 				       en->id.cqm_deq_port,
 				       port_cfg.disable);
 				return DP_FAILURE;
@@ -3448,7 +3448,7 @@ int dp_node_link_en_set_31(struct dp_node_link_enable *en, int flag)
 		}
 		if (en->en & DP_NODE_RESUME) {
 			if (port_cfg.disable) {
-				PR_ERR("Incorrect value set for Port[%d]:%d\n",
+				pr_err("Incorrect value set for Port[%d]:%d\n",
 				       en->id.cqm_deq_port,
 				       port_cfg.disable);
 				return DP_FAILURE;
@@ -3468,11 +3468,11 @@ int dp_node_link_en_get_31(struct dp_node_link_enable *en, int flag)
 	struct hal_priv *priv = HAL(en->inst);
 
 	if (!priv || !priv->qdev) {
-		PR_ERR("priv or priv->qdev NULL\n");
+		pr_err("priv or priv->qdev NULL\n");
 		return DP_FAILURE;
 	}
 	if (!en) {
-		PR_ERR("en info NULL\n");
+		pr_err("en info NULL\n");
 		return DP_FAILURE;
 	}
 	if (en->type == DP_NODE_QUEUE) {
@@ -3482,7 +3482,7 @@ int dp_node_link_en_get_31(struct dp_node_link_enable *en, int flag)
 			 "en->id.q_id=%d\n", en->id.q_id);
 		node_id = priv->qos_queue_stat[en->id.q_id].node_id;
 		if (qos_queue_conf_get(priv->qdev, node_id, &q_conf)) {
-			PR_ERR("qos_queue_conf_get fail: q[%d]\n",
+			pr_err("qos_queue_conf_get fail: q[%d]\n",
 			       en->id.q_id);
 			return DP_FAILURE;
 		}
@@ -3497,7 +3497,7 @@ int dp_node_link_en_get_31(struct dp_node_link_enable *en, int flag)
 			 "en->id.sch_id=%d\n", en->id.sch_id);
 		if (qos_sched_conf_get(priv->qdev, en->id.sch_id,
 				       &sched_conf)) {
-			PR_ERR("qos_sched_conf_get fail: sched[/%d]\n",
+			pr_err("qos_sched_conf_get fail: sched[/%d]\n",
 			       en->id.sch_id);
 			return DP_FAILURE;
 		}
@@ -3509,7 +3509,7 @@ int dp_node_link_en_get_31(struct dp_node_link_enable *en, int flag)
 			 "en->id.cqm_deq_port=%d\n", en->id.cqm_deq_port);
 		node_id = priv->deq_port_stat[en->id.cqm_deq_port].node_id;
 		if (qos_port_conf_get(priv->qdev, node_id, &p_conf)) {
-			PR_ERR("qos_queue_conf_get fail: port[%d]\n",
+			pr_err("qos_queue_conf_get fail: port[%d]\n",
 			       en->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
@@ -3533,24 +3533,24 @@ int dp_link_get_31(struct dp_qos_link *cfg, int flag)
 	int i, node_id;
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(cfg->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	node_id = priv->qos_queue_stat[cfg->q_id].node_id;
 
 	if (!(priv->qos_queue_stat[cfg->q_id].flag & PP_NODE_ACTIVE)) {
-		PR_ERR("Incorrect queue:%d state:expect ACTIV\n", cfg->q_id);
+		pr_err("Incorrect queue:%d state:expect ACTIV\n", cfg->q_id);
 		return DP_FAILURE;
 	}
 
 	if (qos_queue_conf_get(priv->qdev, node_id, &queue_cfg)) {
-		PR_ERR("failed to qos_queue_conf_get\n");
+		pr_err("failed to qos_queue_conf_get\n");
 		return DP_FAILURE;
 	}
 	cfg->q_arbi = get_parent_arbi(cfg->inst, node_id, 0);
@@ -3581,7 +3581,7 @@ int dp_link_get_31(struct dp_qos_link *cfg, int flag)
 				priv->qos_sch_stat[node_id].parent.node_id;
 			if (qos_sched_conf_get(priv->qdev, cfg->sch[i].id,
 					       &sched_cfg)) {
-				PR_ERR("dp_link_get:sched[/%d] conf get fail\n",
+				pr_err("dp_link_get:sched[/%d] conf get fail\n",
 				       cfg->sch[i].id);
 				return DP_FAILURE;
 			}
@@ -3623,12 +3623,12 @@ int dp_link_add_31(struct dp_qos_link *cfg, int flag)
 	struct f f_sch_free[DP_MAX_SCH_LVL] = {0};
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (cfg->n_sch_lvl > DP_MAX_SCH_LVL) {
-		PR_ERR("Incorrect sched_lvl:%s(%d) > %s(%d)\n",
+		pr_err("Incorrect sched_lvl:%s(%d) > %s(%d)\n",
 		       "cfg->n_sch_lvl", cfg->n_sch_lvl,
 		       "DP_MAX_SCH_LVL", DP_MAX_SCH_LVL);
 		return DP_FAILURE;
@@ -3657,7 +3657,7 @@ int dp_link_add_31(struct dp_qos_link *cfg, int flag)
 		f_sch_free[cfg->n_sch_lvl - 1].flag = 1;
 
 		if (dp_node_link_add_31(&info, flag)) {
-			PR_ERR("Failed to link Sch:%d to Port:%d\n",
+			pr_err("Failed to link Sch:%d to Port:%d\n",
 			       cfg->sch[cfg->n_sch_lvl - 1].id,
 			       cfg->cqm_deq_port);
 			goto EXIT;
@@ -3680,7 +3680,7 @@ int dp_link_add_31(struct dp_qos_link *cfg, int flag)
 			f_sch_free[i].flag = 1;
 
 			if (dp_node_link_add_31(&info, flag)) {
-				PR_ERR("Failed to link Sch:%d to Sch:%d\n",
+				pr_err("Failed to link Sch:%d to Sch:%d\n",
 				       cfg->sch[i].id, cfg->sch[i + 1].id);
 				goto EXIT;
 			}
@@ -3699,7 +3699,7 @@ int dp_link_add_31(struct dp_qos_link *cfg, int flag)
 		info.prio_wfq = cfg->sch[0].prio_wfq;
 
 		if (dp_node_link_add_31(&info, flag)) {
-			PR_ERR("Failed to link Q:%d to Sch:%d\n",
+			pr_err("Failed to link Q:%d to Sch:%d\n",
 			       cfg->q_id, cfg->sch[0].id);
 			f_q_free = 1;
 			goto EXIT;
@@ -3714,7 +3714,7 @@ int dp_link_add_31(struct dp_qos_link *cfg, int flag)
 		info.prio_wfq = cfg->q_prio_wfq;
 
 		if (dp_node_link_add_31(&info, flag)) {
-			PR_ERR("Failed to link Q:%d to Port:%d\n",
+			pr_err("Failed to link Q:%d to Port:%d\n",
 			       cfg->q_id, cfg->cqm_deq_port);
 			f_q_free = 1;
 			goto EXIT;
@@ -3739,7 +3739,7 @@ int dp_link_add_31(struct dp_qos_link *cfg, int flag)
 		/* sch provided by caller move it to ALLOC */
 		if (node_stat_update(info.inst, f_sch_free[i].sch_id,
 				     DP_NODE_DEC)) {
-			PR_ERR("Failed to %s sched:%d DP_NODE_DEC\n",
+			pr_err("Failed to %s sched:%d DP_NODE_DEC\n",
 			       "node_stat_update",
 			       f_sch_free[i].sch_id);
 			continue;
@@ -3758,7 +3758,7 @@ int dp_link_add_31(struct dp_qos_link *cfg, int flag)
 		}
 		/* queue provided by caller move it to ALLOC */
 		if (node_stat_update(info.inst, cfg->q_id, DP_NODE_DEC)) {
-			PR_ERR("Failed to update stat qid %d DP_NODE_DEC\n",
+			pr_err("Failed to update stat qid %d DP_NODE_DEC\n",
 			       cfg->q_id);
 			return DP_FAILURE;
 		}
@@ -3782,30 +3782,30 @@ int dp_shaper_conf_set_31(struct dp_shaper_conf *cfg, int flag)
 	u32 bw_limit;
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(cfg->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (cfg->type == DP_NODE_QUEUE) {
 		if ((cfg->id.q_id < 0) || (cfg->id.q_id >= MAX_QUEUE)) {
-			PR_ERR("Invalid Queue ID:%d\n", cfg->id.q_id);
+			pr_err("Invalid Queue ID:%d\n", cfg->id.q_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_queue_stat[cfg->id.q_id].flag == PP_NODE_FREE) {
-			PR_ERR("Invalid Queue flag:%d\n",
+			pr_err("Invalid Queue flag:%d\n",
 			       priv->qos_queue_stat[cfg->id.q_id].flag);
 			return DP_FAILURE;
 		}
 		node_id = priv->qos_queue_stat[cfg->id.q_id].node_id;
 
 		if (qos_queue_conf_get(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("qos_queue_conf_get fail:%d\n", cfg->id.q_id);
+			pr_err("qos_queue_conf_get fail:%d\n", cfg->id.q_id);
 			return DP_FAILURE;
 		}
 
@@ -3814,7 +3814,7 @@ int dp_shaper_conf_set_31(struct dp_shaper_conf *cfg, int flag)
 			res = limit_dp2pp(cfg->cir, &bw_limit);
 
 			if (res == DP_FAILURE) {
-				PR_ERR("Wrong dp shaper limit:%u\n", cfg->cir);
+				pr_err("Wrong dp shaper limit:%u\n", cfg->cir);
 				return DP_FAILURE;
 			}
 			queue_cfg.common_prop.bandwidth_limit = bw_limit;
@@ -3822,30 +3822,30 @@ int dp_shaper_conf_set_31(struct dp_shaper_conf *cfg, int flag)
 			   (cfg->cmd == DP_SHAPER_CMD_DISABLE)) {
 			queue_cfg.common_prop.bandwidth_limit = 0;
 		} else {
-			PR_ERR("Incorrect command provided:%d\n", cfg->cmd);
+			pr_err("Incorrect command provided:%d\n", cfg->cmd);
 			return DP_FAILURE;
 		}
 
 		if (qos_queue_set(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("qos_queue_set fail:%d\n", cfg->id.q_id);
+			pr_err("qos_queue_set fail:%d\n", cfg->id.q_id);
 			return DP_FAILURE;
 		}
 		return DP_SUCCESS;
 	} else if (cfg->type == DP_NODE_SCH) {
 		if ((cfg->id.sch_id < 0) || (cfg->id.sch_id >= QOS_MAX_NODES)) {
-			PR_ERR("Invalid Sched ID:%d\n", cfg->id.sch_id);
+			pr_err("Invalid Sched ID:%d\n", cfg->id.sch_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_sch_stat[cfg->id.sch_id].p_flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Invalid Sched flag:%d\n",
+			pr_err("Invalid Sched flag:%d\n",
 			       priv->qos_sch_stat[cfg->id.sch_id].p_flag);
 			return DP_FAILURE;
 		}
 
 		if (qos_sched_conf_get(priv->qdev, cfg->id.sch_id,
 				       &sched_cfg)) {
-			PR_ERR("qos_sched_conf_get fail:%d\n", cfg->id.sch_id);
+			pr_err("qos_sched_conf_get fail:%d\n", cfg->id.sch_id);
 			return DP_FAILURE;
 		}
 
@@ -3854,7 +3854,7 @@ int dp_shaper_conf_set_31(struct dp_shaper_conf *cfg, int flag)
 			res = limit_dp2pp(cfg->cir, &bw_limit);
 
 			if (res == DP_FAILURE) {
-				PR_ERR("Wrong dp shaper limit:%u\n", cfg->cir);
+				pr_err("Wrong dp shaper limit:%u\n", cfg->cir);
 				return DP_FAILURE;
 			}
 			sched_cfg.common_prop.bandwidth_limit = bw_limit;
@@ -3862,31 +3862,31 @@ int dp_shaper_conf_set_31(struct dp_shaper_conf *cfg, int flag)
 			   (cfg->cmd == DP_SHAPER_CMD_DISABLE)) {
 			sched_cfg.common_prop.bandwidth_limit = 0;
 		} else {
-			PR_ERR("Incorrect command provided:%d\n", cfg->cmd);
+			pr_err("Incorrect command provided:%d\n", cfg->cmd);
 			return DP_FAILURE;
 		}
 
 		if (qos_sched_set(priv->qdev, cfg->id.sch_id, &sched_cfg)) {
-			PR_ERR("qos_sched_set fail:%d\n", cfg->id.sch_id);
+			pr_err("qos_sched_set fail:%d\n", cfg->id.sch_id);
 			return DP_FAILURE;
 		}
 		return DP_SUCCESS;
 	} else if (cfg->type == DP_NODE_PORT) {
 		if ((cfg->id.cqm_deq_port < 0) ||
 		    (cfg->id.cqm_deq_port >= MAX_CQM_DEQ)) {
-			PR_ERR("Invalid Port ID:%d\n", cfg->id.cqm_deq_port);
+			pr_err("Invalid Port ID:%d\n", cfg->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
 		if (priv->deq_port_stat[cfg->id.cqm_deq_port].flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Invalid Port flag:%d\n",
+			pr_err("Invalid Port flag:%d\n",
 			       priv->deq_port_stat[cfg->id.cqm_deq_port].flag);
 			return DP_FAILURE;
 		}
 		node_id = priv->deq_port_stat[cfg->id.cqm_deq_port].node_id;
 
 		if (qos_port_conf_get(priv->qdev, node_id, &port_cfg)) {
-			PR_ERR("qos_port_conf_get fail:%d\n",
+			pr_err("qos_port_conf_get fail:%d\n",
 			       cfg->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
@@ -3896,7 +3896,7 @@ int dp_shaper_conf_set_31(struct dp_shaper_conf *cfg, int flag)
 			res = limit_dp2pp(cfg->cir, &bw_limit);
 
 			if (res == DP_FAILURE) {
-				PR_ERR("Wrong dp shaper limit:%u\n", cfg->cir);
+				pr_err("Wrong dp shaper limit:%u\n", cfg->cir);
 				return DP_FAILURE;
 			}
 			port_cfg.common_prop.bandwidth_limit = bw_limit;
@@ -3904,17 +3904,17 @@ int dp_shaper_conf_set_31(struct dp_shaper_conf *cfg, int flag)
 			   (cfg->cmd == DP_SHAPER_CMD_DISABLE)) {
 			port_cfg.common_prop.bandwidth_limit = 0;
 		} else {
-			PR_ERR("Incorrect command provided:%d\n", cfg->cmd);
+			pr_err("Incorrect command provided:%d\n", cfg->cmd);
 			return DP_FAILURE;
 		}
 
 		if (qos_port_set(priv->qdev, node_id, &port_cfg)) {
-			PR_ERR("qos_port_set fail:%d\n", cfg->id.cqm_deq_port);
+			pr_err("qos_port_set fail:%d\n", cfg->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
 		return DP_SUCCESS;
 	}
-	PR_ERR("Unkonwn type provided:0x%x\n", cfg->type);
+	pr_err("Unkonwn type provided:0x%x\n", cfg->type);
 	return DP_FAILURE;
 }
 
@@ -3934,55 +3934,55 @@ int dp_shaper_conf_get_31(struct dp_shaper_conf *cfg, int flag)
 	u32 bw_limit;
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(cfg->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (cfg->type == DP_NODE_QUEUE) {
 		if ((cfg->id.q_id < 0) || (cfg->id.q_id >= MAX_QUEUE)) {
-			PR_ERR("Invalid Queue ID:%d\n", cfg->id.q_id);
+			pr_err("Invalid Queue ID:%d\n", cfg->id.q_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_queue_stat[cfg->id.q_id].flag == PP_NODE_FREE) {
-			PR_ERR("Invalid Queue flag:%d\n",
+			pr_err("Invalid Queue flag:%d\n",
 			       priv->qos_queue_stat[cfg->id.q_id].flag);
 			return DP_FAILURE;
 		}
 		node_id = priv->qos_queue_stat[cfg->id.q_id].node_id;
 
 		if (qos_queue_conf_get(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("qos_queue_conf_get fail:%d\n", cfg->id.q_id);
+			pr_err("qos_queue_conf_get fail:%d\n", cfg->id.q_id);
 			return DP_FAILURE;
 		}
 		res = limit_pp2dp(queue_cfg.common_prop.bandwidth_limit,
 				  &bw_limit);
 
 		if (res == DP_FAILURE) {
-			PR_ERR("Wrong pp shaper limit:%u\n",
+			pr_err("Wrong pp shaper limit:%u\n",
 			       queue_cfg.common_prop.bandwidth_limit);
 			return DP_FAILURE;
 		}
 	} else if (cfg->type == DP_NODE_SCH) {
 		if ((cfg->id.sch_id < 0) || (cfg->id.sch_id >= QOS_MAX_NODES)) {
-			PR_ERR("Invalid Sched ID:%d\n", cfg->id.sch_id);
+			pr_err("Invalid Sched ID:%d\n", cfg->id.sch_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_sch_stat[cfg->id.sch_id].p_flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Invalid Sched flag:%d\n",
+			pr_err("Invalid Sched flag:%d\n",
 			       priv->qos_sch_stat[cfg->id.sch_id].p_flag);
 			return DP_FAILURE;
 		}
 
 		if (qos_sched_conf_get(priv->qdev, cfg->id.sch_id,
 				       &sched_cfg)) {
-			PR_ERR("qos_sched_conf_get fail:%d\n", cfg->id.sch_id);
+			pr_err("qos_sched_conf_get fail:%d\n", cfg->id.sch_id);
 			return DP_FAILURE;
 		}
 
@@ -3990,25 +3990,25 @@ int dp_shaper_conf_get_31(struct dp_shaper_conf *cfg, int flag)
 				  &bw_limit);
 
 		if (res == DP_FAILURE) {
-			PR_ERR("Wrong pp shaper limit:%u\n",
+			pr_err("Wrong pp shaper limit:%u\n",
 			       sched_cfg.common_prop.bandwidth_limit);
 			return DP_FAILURE;
 		}
 	} else if (cfg->type == DP_NODE_PORT) {
 		if ((cfg->id.cqm_deq_port < 0) ||
 		    (cfg->id.cqm_deq_port >= MAX_CQM_DEQ)) {
-			PR_ERR("Invalid Port ID:%d\n", cfg->id.cqm_deq_port);
+			pr_err("Invalid Port ID:%d\n", cfg->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
 		if (priv->deq_port_stat[cfg->id.cqm_deq_port].flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Invalid Port flag:%d\n",
+			pr_err("Invalid Port flag:%d\n",
 			       priv->deq_port_stat[cfg->id.cqm_deq_port].flag);
 			return DP_FAILURE;
 		}
 		node_id = priv->deq_port_stat[cfg->id.cqm_deq_port].node_id;
 		if (qos_port_conf_get(priv->qdev, node_id, &port_cfg)) {
-			PR_ERR("qos_port_conf_get fail:%d\n",
+			pr_err("qos_port_conf_get fail:%d\n",
 			       cfg->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
@@ -4016,12 +4016,12 @@ int dp_shaper_conf_get_31(struct dp_shaper_conf *cfg, int flag)
 				  &bw_limit);
 
 		if (res == DP_FAILURE) {
-			PR_ERR("Wrong pp shaper limit:%u\n",
+			pr_err("Wrong pp shaper limit:%u\n",
 			       port_cfg.common_prop.bandwidth_limit);
 			return DP_FAILURE;
 		}
 	} else {
-		PR_ERR("Unkonwn type provided:0x%x\n", cfg->type);
+		pr_err("Unkonwn type provided:0x%x\n", cfg->type);
 		return DP_FAILURE;
 	}
 
@@ -4041,29 +4041,29 @@ int dp_queue_map_get_31(struct dp_queue_map_get *cfg, int flag)
 	int res = DP_SUCCESS;
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(cfg->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	if ((cfg->q_id < 0) || (cfg->q_id >= MAX_QUEUE)) {
-		PR_ERR("Invalid Queue ID:%d\n", cfg->q_id);
+		pr_err("Invalid Queue ID:%d\n", cfg->q_id);
 		return DP_FAILURE;
 	}
 	if ((priv->qos_queue_stat[cfg->q_id].flag == PP_NODE_FREE) &&
 	    (cfg->q_id != priv->ppv4_drop_q)) {
-		PR_ERR("Invalid Queue flag:%d\n",
+		pr_err("Invalid Queue flag:%d\n",
 		       priv->qos_queue_stat[cfg->q_id].flag);
 		return DP_FAILURE;
 	}
 
 	if (cbm_queue_map_get(cfg->inst, cfg->q_id, &num_entry,
 			      &qmap_entry, 0)) {
-		PR_ERR("cbm_queue_map_get fail:%d\n", cfg->q_id);
+		pr_err("cbm_queue_map_get fail:%d\n", cfg->q_id);
 		return DP_FAILURE;
 	}
 
@@ -4073,7 +4073,7 @@ int dp_queue_map_get_31(struct dp_queue_map_get *cfg, int flag)
 		DP_DEBUG(DP_DBG_FLAG_QOS,
 			 "queue map entry returned null value\n");
 		if (num_entry) {
-			PR_ERR("num_entry is not null:%d\n", num_entry);
+			pr_err("num_entry is not null:%d\n", num_entry);
 			res = DP_FAILURE;
 		}
 		goto EXIT;
@@ -4114,22 +4114,22 @@ int dp_queue_map_set_31(struct dp_queue_map_set *cfg, int flag)
 	u32 cqm_flags = 0;
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(cfg->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	if ((cfg->q_id < 0) || (cfg->q_id >= MAX_QUEUE)) {
-		PR_ERR("Invalid Queue ID:%d\n", cfg->q_id);
+		pr_err("Invalid Queue ID:%d\n", cfg->q_id);
 		return DP_FAILURE;
 	}
 	if ((priv->qos_queue_stat[cfg->q_id].flag == PP_NODE_FREE) &&
 	    (cfg->q_id != priv->ppv4_drop_q)) {
-		PR_ERR("Invalid Queue flag:%d\n",
+		pr_err("Invalid Queue flag:%d\n",
 		       priv->qos_queue_stat[cfg->q_id].flag);
 		return DP_FAILURE;
 	}
@@ -4167,7 +4167,7 @@ int dp_queue_map_set_31(struct dp_queue_map_set *cfg, int flag)
 	}
 
 	if (cbm_queue_map_set(cfg->inst, cfg->q_id, &qmap_cfg, cqm_flags)) {
-		PR_ERR("cbm_queue_map_set fail for Q:%d\n", cfg->q_id);
+		pr_err("cbm_queue_map_set fail for Q:%d\n", cfg->q_id);
 		return DP_FAILURE;
 	}
 	return DP_SUCCESS;
@@ -4190,7 +4190,7 @@ int get_sch_level(int inst, int pid, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -4214,13 +4214,13 @@ int dp_qos_level_get_31(struct dp_qos_level *dp, int flag)
 	u16 i, id, pid, lvl_x = 0;
 
 	if (!dp) {
-		PR_ERR("dp cannot be NULL\n");
+		pr_err("dp cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	dp->max_sch_lvl = 0;
 	priv = HAL(dp->inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -4268,7 +4268,7 @@ int ppv4_queue_port_example(int inst, int dp_port, int t_cont, int q_node)
 	/* Allocate qos dequeue port's node id via cqm_deq_port */
 	rc = qos_port_allocate(priv->qdev, cqm_deq_port, &qos_port_node);
 	if (rc) {
-		PR_ERR("failed to qos_port_allocate\n");
+		pr_err("failed to qos_port_allocate\n");
 		return DP_FAILURE;
 	}
 
@@ -4293,7 +4293,7 @@ int ppv4_queue_port_example(int inst, int dp_port, int t_cont, int q_node)
 #endif
 	rc = qos_port_set(priv->qdev, qos_port_node, &port_cfg);
 	if (rc) {
-		PR_ERR("failed to qos_port_set\n");
+		pr_err("failed to qos_port_set\n");
 		qos_port_remove(priv->qdev, qos_port_node);
 		return DP_FAILURE;
 	}
@@ -4309,7 +4309,7 @@ int ppv4_queue_port_example(int inst, int dp_port, int t_cont, int q_node)
 #endif
 	rc = qos_queue_set(priv->qdev, q_node, &queue_cfg);
 	if (rc) {
-		PR_ERR("failed to qos_queue_set\n");
+		pr_err("failed to qos_queue_set\n");
 		qos_port_remove(priv->qdev, qos_port_node);
 		return DP_FAILURE;
 	}
@@ -4342,7 +4342,7 @@ int ppv4_queue_scheduler(int inst, int dp_port, int t_cont, int q_node,
 	/* Allocate qos dequeue port's node id via cqm_deq_port */
 	rc = qos_port_allocate(priv->qdev, cqm_deq_port, &qos_port_node);
 	if (rc) {
-		PR_ERR("failed to qos_port_allocate\n");
+		pr_err("failed to qos_port_allocate\n");
 		return DP_FAILURE;
 	}
 
@@ -4365,7 +4365,7 @@ int ppv4_queue_scheduler(int inst, int dp_port, int t_cont, int q_node,
 #endif
 	rc = qos_port_set(priv->qdev, qos_port_node, &port_cfg);
 	if (rc) {
-		PR_ERR("failed to qos_port_set\n");
+		pr_err("failed to qos_port_set\n");
 		qos_port_remove(priv->qdev, qos_port_node);
 		return DP_FAILURE;
 	}
@@ -4381,7 +4381,7 @@ int ppv4_queue_scheduler(int inst, int dp_port, int t_cont, int q_node,
 #endif
 	rc = qos_queue_set(priv->qdev, q_node, &queue_cfg);
 	if (rc) {
-		PR_ERR("failed to qos_queue_set\n");
+		pr_err("failed to qos_queue_set\n");
 		qos_port_remove(priv->qdev, qos_port_node);
 		return DP_FAILURE;
 	}
@@ -4391,7 +4391,7 @@ int ppv4_queue_scheduler(int inst, int dp_port, int t_cont, int q_node,
 	sched_cfg.sched_child_prop.parent = sch_node2;
 	rc = qos_sched_set(priv->qdev, sch_node1, &sched_cfg);
 	if (rc) {
-		PR_ERR("failed to qos_sched_set\n");
+		pr_err("failed to qos_sched_set\n");
 		qos_port_remove(priv->qdev, qos_port_node);
 		return DP_FAILURE;
 	}
@@ -4401,7 +4401,7 @@ int ppv4_queue_scheduler(int inst, int dp_port, int t_cont, int q_node,
 	sched_cfg.sched_child_prop.parent = qos_port_node;
 	rc = qos_sched_set(priv->qdev, sch_node2, &sched_cfg);
 	if (rc) {
-		PR_ERR("failed to qos_sched_set\n");
+		pr_err("failed to qos_sched_set\n");
 		qos_port_remove(priv->qdev, qos_port_node);
 		return DP_FAILURE;
 	}
@@ -4443,24 +4443,24 @@ int dp_children_get_31(struct dp_node_child *cfg, int flag)
 	struct hal_priv *priv;
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(cfg->inst);
 	cfg->num = 0;
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (cfg->type == DP_NODE_SCH) {
 		if ((cfg->id.sch_id < 0) || (cfg->id.sch_id >= QOS_MAX_NODES)) {
-			PR_ERR("Invalid Sched ID:%d\n", cfg->id.sch_id);
+			pr_err("Invalid Sched ID:%d\n", cfg->id.sch_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_sch_stat[cfg->id.sch_id].c_flag == PP_NODE_FREE) {
-			PR_ERR("Invalid Sched flag:0x%x\n",
+			pr_err("Invalid Sched flag:0x%x\n",
 			       priv->qos_sch_stat[cfg->id.sch_id].c_flag);
 			return DP_FAILURE;
 		}
@@ -4469,19 +4469,19 @@ int dp_children_get_31(struct dp_node_child *cfg, int flag)
 	} else if (cfg->type == DP_NODE_PORT) {
 		if ((cfg->id.cqm_deq_port < 0) ||
 		    (cfg->id.cqm_deq_port >= MAX_CQM_DEQ)) {
-			PR_ERR("Invalid Port ID:%d\n", cfg->id.cqm_deq_port);
+			pr_err("Invalid Port ID:%d\n", cfg->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
 		if (priv->deq_port_stat[cfg->id.cqm_deq_port].flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Invalid Port flag:0x%x\n",
+			pr_err("Invalid Port flag:0x%x\n",
 			       priv->deq_port_stat[cfg->id.cqm_deq_port].flag);
 			return DP_FAILURE;
 		}
 		node_id = priv->deq_port_stat[cfg->id.cqm_deq_port].node_id;
 
 	} else {
-		PR_ERR("Unkonwn type provided:0x%x\n", cfg->type);
+		pr_err("Unkonwn type provided:0x%x\n", cfg->type);
 		return DP_FAILURE;
 	}
 	if (!priv->qos_sch_stat[node_id].child_num)
@@ -4493,7 +4493,7 @@ int dp_children_get_31(struct dp_node_child *cfg, int flag)
 	if (cfg->num == res)
 		return DP_SUCCESS;
 
-	PR_ERR("child_num:[%d] not matched to res:[%d] for Node:%d\n",
+	pr_err("child_num:[%d] not matched to res:[%d] for Node:%d\n",
 	       cfg->num, res, cfg->id.sch_id);
 	return DP_FAILURE;
 }
@@ -4508,7 +4508,7 @@ static int dp_queue_alloc_conf(int inst, int *logical_id, int *qid)
 
 	if (qos_queue_allocate(priv->qdev, &id)) {
 		res = DP_FAILURE;
-		PR_ERR("qos_queue_allocate failed\n");
+		pr_err("qos_queue_allocate failed\n");
 		return res;
 	}
 	qos_queue_conf_set_default(&q_conf);
@@ -4517,7 +4517,7 @@ static int dp_queue_alloc_conf(int inst, int *logical_id, int *qid)
 	q_conf.queue_child_prop.parent = priv->ppv4_drop_p;
 	if (qos_queue_set(priv->qdev, id, &q_conf)) {
 		res = DP_FAILURE;
-		PR_ERR("qos_queue_set fail for queue=%d to parent=%d\n",
+		pr_err("qos_queue_set fail for queue=%d to parent=%d\n",
 		       id, q_conf.queue_child_prop.parent);
 		goto EXIT;
 	}
@@ -4525,7 +4525,7 @@ static int dp_queue_alloc_conf(int inst, int *logical_id, int *qid)
 		 id, q_conf.queue_child_prop.parent);
 	if (qos_queue_info_get(priv->qdev, id, &info)) {
 		res = DP_FAILURE;
-		PR_ERR("qos_queue_info_get: %d\n", id);
+		pr_err("qos_queue_info_get: %d\n", id);
 		goto EXIT;
 	}
 	*qid = info.physical_id;
@@ -4551,7 +4551,7 @@ int dp_q_reserve_continuous(int inst, int ep, struct dp_dev_data *data,
 		goto FREE_EXIT;
 	/* to reserve the queue */
 	if (data->num_resv_q <= 0) {
-		DP_ERR("Provide valid Q no for continuous Q reserve\n");
+		pr_err("Provide valid Q no for continuous Q reserve\n");
 		return DP_FAILURE;
 	}
 
@@ -4565,7 +4565,7 @@ int dp_q_reserve_continuous(int inst, int ep, struct dp_dev_data *data,
 		return DP_FAILURE;
 	}
 	if (dp_queue_alloc_conf(inst, &id, &qid)) {
-		PR_ERR("qos_queue_allocate failed\n");
+		pr_err("qos_queue_allocate failed\n");
 		kfree(priv->resv[ep].resv_q);
 		kfree(tmp_resv_q);
 		return DP_FAILURE;
@@ -4576,7 +4576,7 @@ int dp_q_reserve_continuous(int inst, int ep, struct dp_dev_data *data,
 	while (((curr_num) - curr_off) < data->num_resv_q) {
 		if (dp_queue_alloc_conf(inst, &id, &qid)) {
 			res = DP_FAILURE;
-			PR_ERR("qos_queue_allocate failed\n");
+			pr_err("qos_queue_allocate failed\n");
 			kfree(priv->resv[ep].resv_q);
 			goto clear_q;
 		}
@@ -4642,7 +4642,7 @@ int dp_node_reserve(int inst, int ep, struct dp_dev_data *data, int flags)
 	int res = DP_SUCCESS;
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -4669,7 +4669,7 @@ int dp_node_reserve(int inst, int ep, struct dp_dev_data *data, int flags)
 	for (i = 0; i < data->num_resv_q; i++) {
 		if (qos_queue_allocate(priv->qdev, &id)) {
 			res = DP_FAILURE;
-			PR_ERR("qos_queue_allocate failed\n");
+			pr_err("qos_queue_allocate failed\n");
 			goto FREE_EXIT;
 		}
 		DP_DEBUG(DP_DBG_FLAG_QOS,
@@ -4681,7 +4681,7 @@ int dp_node_reserve(int inst, int ep, struct dp_dev_data *data, int flags)
 		q_conf.queue_child_prop.parent = priv->ppv4_drop_p;
 		if (qos_queue_set(priv->qdev, id, &q_conf)) {
 			res = DP_FAILURE;
-			PR_ERR("qos_queue_set fail for queue=%d to parent=%d\n",
+			pr_err("qos_queue_set fail for queue=%d to parent=%d\n",
 			       id, q_conf.queue_child_prop.parent);
 			goto FREE_EXIT;
 		}
@@ -4692,7 +4692,7 @@ int dp_node_reserve(int inst, int ep, struct dp_dev_data *data, int flags)
 		if (qos_queue_info_get(priv->qdev, id, &info)) {
 			qos_queue_remove(priv->qdev, id);
 			res = DP_FAILURE;
-			PR_ERR("qos_queue_info_get: %d\n", id);
+			pr_err("qos_queue_info_get: %d\n", id);
 			goto FREE_EXIT;
 		}
 		resv_q[i].id = id;
@@ -4720,7 +4720,7 @@ int dp_node_reserve(int inst, int ep, struct dp_dev_data *data, int flags)
 		for (i = 0; i < data->num_resv_sched; i++) {
 			if (qos_sched_allocate(priv->qdev, &id)) {
 				res = DP_FAILURE;
-				PR_ERR("qos_queue_allocate failed\n");
+				pr_err("qos_queue_allocate failed\n");
 				goto FREE_EXIT;
 			}
 			DP_DEBUG(DP_DBG_FLAG_QOS,
@@ -4765,16 +4765,16 @@ int dp_qos_global_info_get_31(struct dp_qos_cfg_info *info, int flag)
 	unsigned int quanta = 0;
 
 	if (!info) {
-		PR_ERR("info cannot be NULL\n");
+		pr_err("info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(info->inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	if (pp_qos_get_quanta(priv->qdev, &quanta)) {
-		PR_ERR("failed pp_qos_get_quanta\n");
+		pr_err("failed pp_qos_get_quanta\n");
 		return DP_FAILURE;
 	}
 	info->quanta = quanta;
@@ -4794,25 +4794,25 @@ int dp_qos_port_conf_set_31(struct dp_port_cfg_info *info, int flag)
 	int node_id;
 
 	if (!info) {
-		PR_ERR("info cannot be NULL\n");
+		pr_err("info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(info->inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	node_id = priv->deq_port_stat[info->pid].node_id;
 	DP_DEBUG(DP_DBG_FLAG_QOS, "%s cqm_deq:%d, qos_port:%d\n",
 		 __func__, info->pid, node_id);
 	if (qos_port_conf_get(priv->qdev, node_id, &port_cfg)) {
-		PR_ERR("failed qos_port_conf_get\n");
+		pr_err("failed qos_port_conf_get\n");
 		return DP_FAILURE;
 	}
 	port_cfg.green_threshold = info->green_threshold;
 	port_cfg.yellow_threshold = info->yellow_threshold;
 	if (qos_port_set(priv->qdev, node_id, &port_cfg)) {
-		PR_ERR("fail to set yellow:%d green:%d for node:%d\n",
+		pr_err("fail to set yellow:%d green:%d for node:%d\n",
 		       info->yellow_threshold, info->green_threshold, node_id);
 		return DP_FAILURE;
 	}
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_proc.c b/drivers/net/datapath/dpm/gswip31/datapath_proc.c
index 2a967ecf7864..0f0399d37141 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_proc.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_proc.c
@@ -161,9 +161,9 @@ ssize_t proc_parser_write(struct file *file, const char *buf,
 				"refresh",
 				strlen("refresh")) == 0) {
 		dp_get_gsw_parser_31(NULL, NULL, NULL, NULL);
-		PR_INFO("value:cpu=%d mpe1=%d mpe2=%d mpe3=%d\n", pinfo[0].v,
+		pr_info("value:cpu=%d mpe1=%d mpe2=%d mpe3=%d\n", pinfo[0].v,
 			pinfo[1].v, pinfo[2].v, pinfo[3].v);
-		PR_INFO("size :cpu=%d mpe1=%d mpe2=%d mpe3=%d\n",
+		pr_info("size :cpu=%d mpe1=%d mpe2=%d mpe3=%d\n",
 			pinfo[0].size, pinfo[1].size, pinfo[2].size,
 			pinfo[3].size);
 		return count;
@@ -176,7 +176,7 @@ ssize_t proc_parser_write(struct file *file, const char *buf,
 			flag = 0;
 		else if (flag > 3)
 			flag = 3;
-		PR_INFO("eProcessPath_Action set to %d\n", flag);
+		pr_info("eProcessPath_Action set to %d\n", flag);
 		/*: All packets set to same mpe flag as specified */
 		memset(&pce, 0, sizeof(pce));
 		pce.pattern.nIndex = pce_rule_id;
@@ -207,7 +207,7 @@ ssize_t proc_parser_write(struct file *file, const char *buf,
 		pce.action.nRMON_Id = 0;	/*RMON_UDP_CNTR; */
 
 		if (gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, &pce)) {
-			PR_ERR("PCE rule add fail: GSW_PCE_RULE_WRITE\n");
+			pr_err("PCE rule add fail: GSW_PCE_RULE_WRITE\n");
 			return count;
 		}
 
@@ -218,17 +218,17 @@ ssize_t proc_parser_write(struct file *file, const char *buf,
 		pce.pattern.nIndex = pce_rule_id;
 		pce.pattern.bEnable = 0;
 		if (gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, &pce)) {
-			PR_ERR("PCE rule add fail:GSW_PCE_RULE_WRITE\n");
+			pr_err("PCE rule add fail:GSW_PCE_RULE_WRITE\n");
 			return count;
 		}
 	} else {
-		PR_INFO("Usage: echo %s [cpu] [mpe1] [mpe2] [mpe3] > parser\n",
+		pr_info("Usage: echo %s [cpu] [mpe1] [mpe2] [mpe3] > parser\n",
 			"<enable/disable>");
-		PR_INFO("Usage: echo <refresh> parser\n");
+		pr_info("Usage: echo <refresh> parser\n");
 
-		PR_INFO("Usage: echo %s > parser\n",
+		pr_info("Usage: echo %s > parser\n",
 			"mark eProcessPath_Action_value(0~3) pce_rule_id");
-		PR_INFO("Usage: echo unmark pce_rule_id > parser\n");
+		pr_info("Usage: echo unmark pce_rule_id > parser\n");
 		return count;
 	}
 
@@ -252,7 +252,7 @@ char *get_bp_member_string(int inst, u16 bp, char *buf)
 		GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID;
 	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed to get bridge port's member for bridgeport=%d\n",
+		pr_err("Failed to get bridge port's member for bridgeport=%d\n",
 		       bp_cfg.nBridgePortId);
 		return buf;
 	}
@@ -303,7 +303,7 @@ int dp_sub_proc_install_31(void)
 	int i;
 
 	if (!dp_proc_node) {
-		PR_ERR("dp_sub_proc_install failed\n");
+		pr_err("dp_sub_proc_install failed\n");
 		return 0;
 	}
 
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_rx.c b/drivers/net/datapath/dpm/gswip31/datapath_rx.c
index e726d9f36099..2a64c8c95fbd 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_rx.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_rx.c
@@ -61,7 +61,7 @@ static void rx_dbg_zero_port(struct sk_buff *skb, struct dma_rx_desc_0 *desc0,
 	last = jiffies;
 	DP_DEBUG(-1, "%s=%d vap=%d\n",
 		 (ep) ? "ep" : "port_id", port_id, vap);
-	PR_ERR("\nDrop for ep and source port id both zero ??\n");
+	pr_err("\nDrop for ep and source port id both zero ??\n");
 	dp_port_prop[inst].info.dump_rx_dma_desc(desc0, desc1, desc2, desc3);
 
 	if (paser_exist)
@@ -100,7 +100,7 @@ static int dp_handle_lct(struct pmac_port_info *dp_port,
 		}
 		lct_skb = skb_clone(skb, GFP_ATOMIC);
 		if (!lct_skb) {
-			PR_ERR("LCT mcast/bcast skb clone fail\n");
+			pr_err("LCT mcast/bcast skb clone fail\n");
 			return -1;
 		}
 		lct_skb->dev = sif->netif;
@@ -156,11 +156,11 @@ int32_t dp_rx_31(struct sk_buff *skb, u32 flags)
 
 	dp_port = get_dp_port_info(inst, 0);
 	if (!skb) {
-		PR_ERR("skb NULL\n");
+		pr_err("skb NULL\n");
 		return DP_FAILURE;
 	}
 	if (!skb->data) {
-		PR_ERR("skb->data NULL\n");
+		pr_err("skb->data NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -316,7 +316,7 @@ int32_t dp_rx_31(struct sk_buff *skb, u32 flags)
 
 	if (unlikely(port_id >=
 	    dp_port_prop[inst].info.cap.max_num_dp_ports - 1)) {
-		PR_ERR("Drop for wrong ep or src port id=%u ??\n",
+		pr_err("Drop for wrong ep or src port id=%u ??\n",
 		       port_id);
 		goto RX_DROP;
 	} else if (unlikely(dp_port->status == PORT_FREE)) {
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_switchdev.c b/drivers/net/datapath/dpm/gswip31/datapath_switchdev.c
index e52c375efe9a..3b4a47b8a051 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_switchdev.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_switchdev.c
@@ -25,7 +25,7 @@ int dp_swdev_alloc_bridge_id(int inst)
 	ret = gsw_handle->gsw_brdg_ops.Bridge_Alloc(gsw_handle, &br);
 	if ((ret != GSW_statusOk) ||
 	    (br.nBridgeId < 0)) {
-		PR_ERR("Failed to get a FID\n");
+		pr_err("Failed to get a FID\n");
 		return -1;
 	}
 	DP_DEBUG(DP_DBG_FLAG_SWDEV, "FID=%d\n", br.nBridgeId);
@@ -51,7 +51,7 @@ int dp_swdev_bridge_port_cfg_set(struct br_info *br_item,
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("fail in getting bridge port config\r\n");
+		pr_err("fail in getting bridge port config\r\n");
 		return -1;
 	}
 	list_for_each_entry(bport_list, &br_item->bp_list, list) {
@@ -83,7 +83,7 @@ int dp_swdev_bridge_port_cfg_set(struct br_info *br_item,
 			  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Fail in allocating/configuring bridge port\n");
+		pr_err("Fail in allocating/configuring bridge port\n");
 		return -1;
 	}
 	/* To set other member portmap with current bridge port map */
@@ -106,7 +106,7 @@ int dp_swdev_bridge_port_cfg_set(struct br_info *br_item,
 		brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &brportcfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("fail in getting br port config\r\n");
+			pr_err("fail in getting br port config\r\n");
 			return -1;
 		}
 		SET_BP_MAP(brportcfg.nBridgePortMap, bport);
@@ -116,7 +116,7 @@ int dp_swdev_bridge_port_cfg_set(struct br_info *br_item,
 				  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &brportcfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("Fail alloc/cfg bridge port\n");
+			pr_err("Fail alloc/cfg bridge port\n");
 			return -1;
 		}
 	}
@@ -179,7 +179,7 @@ int dp_swdev_bridge_port_cfg_reset(struct br_info *br_item,
 			  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Fail in configuring GSW_BRIDGE_portConfig_t in %s\r\n",
+		pr_err("Fail in configuring GSW_BRIDGE_portConfig_t in %s\r\n",
 		       __func__);
 		return -1;
 	}
@@ -196,7 +196,7 @@ int dp_swdev_bridge_port_cfg_reset(struct br_info *br_item,
 				  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID;
 		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &brportcfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("failed getting br port cfg\r\n");
+			pr_err("failed getting br port cfg\r\n");
 			return -1;
 		}
 		UNSET_BP_MAP(brportcfg.nBridgePortMap, bport);
@@ -205,7 +205,7 @@ int dp_swdev_bridge_port_cfg_reset(struct br_info *br_item,
 				  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &brportcfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("Fail alloc/cfg br port\n");
+			pr_err("Fail alloc/cfg br port\n");
 			return -1;
 		}
 	}
@@ -236,7 +236,7 @@ int dp_swdev_bridge_cfg_set(int inst, u16 fid)
 	brcfg.eForwardUnknownUnicast = GSW_BRIDGE_FORWARD_FLOOD;
 	ret = gsw_handle->gsw_brdg_ops.Bridge_ConfigSet(gsw_handle, &brcfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed to set bridge id(%d)\n", brcfg.nBridgeId);
+		pr_err("Failed to set bridge id(%d)\n", brcfg.nBridgeId);
 		br.nBridgeId = fid;
 		gsw_handle->gsw_brdg_ops.Bridge_Free(gsw_handle, &br);
 		return -1;
@@ -257,7 +257,7 @@ int dp_swdev_free_brcfg(int inst, u16 fid)
 	br.nBridgeId = fid;
 	ret = gsw_handle->gsw_brdg_ops.Bridge_Free(gsw_handle, &br);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed to free bridge id(%d)\n", br.nBridgeId);
+		pr_err("Failed to free bridge id(%d)\n", br.nBridgeId);
 		return -1;
 	}
 	DP_DEBUG(DP_DBG_FLAG_SWDEV, "FID(%d) freed for inst:%d\n", fid, inst);
@@ -279,18 +279,18 @@ int dp_gswip_ext_vlan(int inst, int vap, int ep)
 	port = get_dp_port_info(inst, ep);
 	vlan = kzalloc(sizeof(*vlan), GFP_KERNEL);
 	if (!vlan) {
-		PR_ERR("failed to alloc ext_vlan of %d bytes\n", sizeof(*vlan));
+		pr_err("failed to alloc ext_vlan of %d bytes\n", sizeof(*vlan));
 		return 0;
 	}
 	vlan->vlan2_list = kzalloc(sizeof(*vlan->vlan2_list), GFP_KERNEL);
 	if (!vlan->vlan2_list) {
-		PR_ERR("failed to alloc ext_vlan of %d bytes\n",
+		pr_err("failed to alloc ext_vlan of %d bytes\n",
 		       sizeof(*vlan->vlan2_list));
 		goto EXIT;
 	}
 	vlan->vlan1_list = kzalloc(sizeof(*vlan->vlan1_list), GFP_KERNEL);
 	if (!vlan->vlan1_list) {
-		PR_ERR("failed to alloc ext_vlan of %d bytes\n",
+		pr_err("failed to alloc ext_vlan of %d bytes\n",
 		       sizeof(*vlan->vlan1_list));
 		goto EXIT;
 	}
@@ -299,7 +299,7 @@ int dp_gswip_ext_vlan(int inst, int vap, int ep)
 		DP_DEBUG(DP_DBG_FLAG_SWDEV, "tmp dev name:%s\n",
 			 tmp->dev ? tmp->dev->name : "NULL");
 		if (!tmp->dev) {
-			PR_ERR("tmp->dev is NULL\n");
+			pr_err("tmp->dev is NULL\n");
 			goto EXIT;
 		}
 		ret = dp_swdev_chk_bport_in_br(tmp->dev, tmp->bp, inst);
@@ -355,7 +355,7 @@ int dp_gswip_ext_vlan(int inst, int vap, int ep)
 	if (ret == 0)
 		sif->swdev_priv = vlan->priv;
 	else
-		PR_ERR("set gswip ext vlan return error\n");
+		pr_err("set gswip ext vlan return error\n");
 
 EXIT:
 	kfree(vlan->vlan2_list);
diff --git a/drivers/net/datapath/dpm/gswip31/datapath_tx.c b/drivers/net/datapath/dpm/gswip31/datapath_tx.c
index 21653cd372fb..d2e85ad5edfc 100644
--- a/drivers/net/datapath/dpm/gswip31/datapath_tx.c
+++ b/drivers/net/datapath/dpm/gswip31/datapath_tx.c
@@ -383,46 +383,46 @@ int32_t dp_xmit_31(struct net_device *rx_if, dp_subif_t *rx_subif,
 lbl_err_ret:
 	switch (err_ret) {
 	case DP_XMIT_ERR_NOT_INIT:
-		PR_RATELIMITED("dp_xmit failed for dp no init yet\n");
+		printk_ratelimited("dp_xmit failed for dp no init yet\n");
 		break;
 	case DP_XMIT_ERR_IN_IRQ:
-		PR_RATELIMITED("dp_xmit not allowed in interrupt context\n");
+		printk_ratelimited("dp_xmit not allowed in interrupt context\n");
 		break;
 	case DP_XMIT_ERR_NULL_SUBIF:
-		PR_RATELIMITED("dp_xmit failed for rx_subif null\n");
+		printk_ratelimited("dp_xmit failed for rx_subif null\n");
 		UP_STATS(get_dp_port_info(inst, 0)->tx_err_drop);
 		break;
 	case DP_XMIT_ERR_PORT_TOO_BIG:
 		UP_STATS(get_dp_port_info(inst, 0)->tx_err_drop);
-		PR_RATELIMITED("rx_subif->port_id >= max_ports");
+		printk_ratelimited("rx_subif->port_id >= max_ports");
 		break;
 	case DP_XMIT_ERR_NULL_SKB:
-		PR_RATELIMITED("skb NULL");
+		printk_ratelimited("skb NULL");
 		UP_STATS(get_dp_port_info(inst,
 					  rx_subif->port_id)->tx_err_drop);
 		break;
 	case DP_XMIT_ERR_NULL_IF:
 		UP_STATS(mib->tx_pkt_dropped);
-		PR_RATELIMITED("rx_if NULL");
+		printk_ratelimited("rx_if NULL");
 		break;
 	case DP_XMIT_ERR_REALLOC_SKB:
-		PR_INFO_ONCE("dp_create_new_skb failed\n");
+		pr_info_once("dp_create_new_skb failed\n");
 		break;
 	case DP_XMIT_ERR_EP_ZERO:
-		PR_ERR("Why ep zero in dp_xmit for %s\n",
+		pr_err("Why ep zero in dp_xmit for %s\n",
 		       skb->dev ? skb->dev->name : "NULL");
 		break;
 	case DP_XMIT_ERR_GSO_NOHEADROOM:
-		PR_ERR("No enough skb headerroom(GSO). Need tune SKB buffer\n");
+		pr_err("No enough skb headerroom(GSO). Need tune SKB buffer\n");
 		break;
 	case DP_XMIT_ERR_CSM_NO_SUPPORT:
-		PR_RATELIMITED("dp_xmit not support checksum\n");
+		printk_ratelimited("dp_xmit not support checksum\n");
 		break;
 	case DP_XMIT_PTP_ERR:
 		break;
 	default:
 		UP_STATS(mib->tx_pkt_dropped);
-		PR_INFO_ONCE("Why come to here:%x\n", dp_info->status);
+		pr_info_once("Why come to here:%x\n", dp_info->status);
 	}
 	if (skb)
 		dev_kfree_skb_any(skb);
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_ext_vlan.c b/drivers/net/datapath/dpm/gswip32/datapath_ext_vlan.c
index eef0c7b7af29..454640607840 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_ext_vlan.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_ext_vlan.c
@@ -245,7 +245,7 @@ static int update_ctp(struct core_ops *ops, struct ext_vlan_info *vlan)
 		ctp.bIngressExtendedVlanEnable = LTQ_FALSE;
 		ret = ops->gsw_ctp_ops.CTP_PortConfigSet(ops, &ctp);
 		if (ret != GSW_statusOk) {
-			PR_ERR("Fail:Ingress VLAN operate disable in ctp\n");
+			pr_err("Fail:Ingress VLAN operate disable in ctp\n");
 			return -EIO;
 		}
 		DP_DEBUG(DP_DBG_FLAG_SWDEV,
@@ -377,7 +377,7 @@ static int bp_add_vlan1(struct core_ops *ops, struct vlan1 *vlan,
 		ret = ops->gsw_extvlan_ops.ExtendedVlan_Set(ops, vcfg);
 
 		if (ret != GSW_statusOk) {
-			PR_ERR("Fail updating Extended VLAN entry (%u, %u).\n",
+			pr_err("Fail updating Extended VLAN entry (%u, %u).\n",
 			       alloc.nExtendedVlanBlockId, i);
 			ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 			return -EIO;
@@ -390,7 +390,7 @@ static int bp_add_vlan1(struct core_ops *ops, struct vlan1 *vlan,
 	ret = ops->gsw_brdgport_ops.BridgePort_ConfigSet(ops, bpcfg);
 
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed in attaching Extended VLAN to Bridge Port.\n");
+		pr_err("Failed in attaching Extended VLAN to Bridge Port.\n");
 		ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 		return -EIO;
 	} else {
@@ -466,7 +466,7 @@ static int bp_add_vlan2(struct core_ops *ops, struct vlan2 *vlan,
 		ret = ops->gsw_extvlan_ops.ExtendedVlan_Set(ops, vcfg);
 
 		if (ret != GSW_statusOk) {
-			PR_ERR("Fail updating Extended VLAN entry (%u, %u).\n",
+			pr_err("Fail updating Extended VLAN entry (%u, %u).\n",
 			       alloc.nExtendedVlanBlockId, i);
 			ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 			return -EIO;
@@ -479,7 +479,7 @@ static int bp_add_vlan2(struct core_ops *ops, struct vlan2 *vlan,
 	ret = ops->gsw_brdgport_ops.BridgePort_ConfigSet(ops, bpcfg);
 
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed in attaching Extended VLAN to Bridge Port.\n");
+		pr_err("Failed in attaching Extended VLAN to Bridge Port.\n");
 		ops->gsw_extvlan_ops.ExtendedVlan_Free(ops, &alloc);
 		return -EIO;
 	} else {
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_gswip.c b/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
index bd9b0c9ce0c7..b6822780113d 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_gswip.c
@@ -94,7 +94,7 @@ int dp_pmac_set_32(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 	GSW_PMAC_Glbl_Cfg_t pmac_glb;
 
 	if (!pmac_cfg || !port) {
-		PR_ERR("dp_pmac_set:wrong parameter(pmac_cfg/port NULL)\n");
+		pr_err("dp_pmac_set:wrong parameter(pmac_cfg/port NULL)\n");
 		return -1;
 	}
 
@@ -115,7 +115,7 @@ int dp_pmac_set_32(int inst, u32 port, dp_pmac_cfg_t *pmac_cfg)
 		ret = cbm_dequeue_port_resources_get(port, &dqport, flag);
 
 		if (ret == -1) {
-			PR_ERR("cbm_dequeue_port_resources_get failed\n");
+			pr_err("cbm_dequeue_port_resources_get failed\n");
 			return -1;
 		}
 
@@ -404,7 +404,7 @@ int dp_set_gsw_parser_32(u8 flag, u8 cpu, u8 mpe1,
 	struct core_ops *gsw_handle = dp_port_prop[0].ops[0];/*gswip o */
 
 	if (gsw_handle->gsw_common_ops.CPU_PortCfgGet(gsw_handle, &param)) {
-		PR_ERR("Failed GSW_CPU_PORT_CFG_GET\n");
+		pr_err("Failed GSW_CPU_PORT_CFG_GET\n");
 		return -1;
 	}
 	DP_DEBUG(DP_DBG_FLAG_DBG, "old flag=0x%x cpu=%d mpe1/2/3=%d/%d/%d\n",
@@ -426,7 +426,7 @@ int dp_set_gsw_parser_32(u8 flag, u8 cpu, u8 mpe1,
 		param.eMPE1MPE2ParserCfg = mpe3;
 
 	if (gsw_handle->gsw_common_ops.CPU_PortCfgSet(gsw_handle, &param)) {
-		PR_ERR("Failed GSW_CPU_PORT_CFG_SET\n");
+		pr_err("Failed GSW_CPU_PORT_CFG_SET\n");
 		return -1;
 	}
 	dp_parser_info_refresh(param.eNoMPEParserCfg,
@@ -443,7 +443,7 @@ int dp_get_gsw_parser_32(u8 *cpu, u8 *mpe1, u8 *mpe2,
 	struct core_ops *gsw_handle = dp_port_prop[0].ops[0]; /*gswip 0*/
 
 	if (gsw_handle->gsw_common_ops.CPU_PortCfgGet(gsw_handle, &param)) {
-		PR_ERR("Failed GSW_CPU_PORT_CFG_GET\n");
+		pr_err("Failed GSW_CPU_PORT_CFG_GET\n");
 		return -1;
 	}
 	dp_parser_info_refresh(param.eNoMPEParserCfg,
@@ -484,7 +484,7 @@ int gsw_mib_reset_32(int dev, u32 flag)
 	ret = gsw_handle->gsw_rmon_ops.RMON_Clear(gsw_handle, &rmon_clear);
 
 	if (ret != GSW_statusOk) {
-		PR_ERR("R:GSW_RMON_CLEAR failed for GSW_RMON_ALL_TYPE\n");
+		pr_err("R:GSW_RMON_CLEAR failed for GSW_RMON_ALL_TYPE\n");
 		return -1;
 	}
 	return ret;
@@ -508,13 +508,13 @@ struct gsw_itf *ctp_port_assign_32(int inst, u8 ep, int bp_default,
 	alloc_flag = port_info->alloc_flags;
 
 	if (flags & DP_F_DEREGISTER) {
-		PR_ERR("Need to Free CTP Port here for ep=%d\n", ep);
+		pr_err("Need to Free CTP Port here for ep=%d\n", ep);
 		ctp_assign.nLogicalPortId = ep;
 		ctp_assign.eMode = itf_assign[ep].mode;
 		ctp_assign.nFirstCtpPortId = itf_assign[ep].start;
 		ctp_assign.nNumberOfCtpPort = itf_assign[ep].n;
 		if (gsw_ctp->CTP_PortAssignmentFree(gsw_handle, &ctp_assign)) {
-			PR_ERR("Failed to allc CTP for ep=%d blk=%d mode=%d\n",
+			pr_err("Failed to allc CTP for ep=%d blk=%d mode=%d\n",
 			       ep, assign->num, assign->emode);
 			return NULL;
 		}
@@ -538,7 +538,7 @@ struct gsw_itf *ctp_port_assign_32(int inst, u8 ep, int bp_default,
 	ctp_assign.nFirstCtpPortId = 0;
 	ctp_assign.nNumberOfCtpPort = num;
 	if (gsw_ctp->CTP_PortAssignmentAlloc(gsw_handle, &ctp_assign)) {
-		PR_ERR("Failed CTP Assignment for ep=%d blk size=%d mode=%s\n",
+		pr_err("Failed CTP Assignment for ep=%d blk size=%d mode=%s\n",
 		       ep, num, ctp_mode_string(assign->emode));
 		return NULL;
 	}
@@ -597,7 +597,7 @@ int alloc_bridge_port_32(int inst, int port_id, int subif_ix,
 	memset(&bp, 0, sizeof(bp));
 	ret = gsw_bp->BridgePort_Alloc(gsw_handle, &bp);
 	if ((ret != GSW_statusOk) || (bp.nBridgePortId < 0)) {
-		PR_ERR("Failed to get a bridge port\n");
+		pr_err("Failed to get a bridge port\n");
 		return -1;
 	}
 	/*set this new bridge port with specified bridge ID(fid)
@@ -623,7 +623,7 @@ int alloc_bridge_port_32(int inst, int port_id, int subif_ix,
 	SET_BP_MAP(bp_cfg.nBridgePortMap, bp_member); /*CPU*/
 	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed to set bridge id(%d) and port map for bp= %d\n",
+		pr_err("Failed to set bridge id(%d) and port map for bp= %d\n",
 		       fid, bp_cfg.nBridgePortId);
 		gsw_bp->BridgePort_Free(gsw_handle, &bp);
 		return -1;
@@ -636,7 +636,7 @@ int alloc_bridge_port_32(int inst, int port_id, int subif_ix,
 	bp_cfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed to get bridge port's member for bridgeport=%d\n",
+		pr_err("Failed to get bridge port's member for bridgeport=%d\n",
 		       bp_cfg.nBridgePortId);
 		gsw_bp->BridgePort_Free(gsw_handle, &bp);
 		return -1;
@@ -644,7 +644,7 @@ int alloc_bridge_port_32(int inst, int port_id, int subif_ix,
 	SET_BP_MAP(bp_cfg.nBridgePortMap, bp.nBridgePortId);
 	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed to set bridge port's member for bridgeport=%d\n",
+		pr_err("Failed to set bridge port's member for bridgeport=%d\n",
 		       bp_cfg.nBridgePortId);
 		gsw_bp->BridgePort_Free(gsw_handle, &bp);
 		return -1;
@@ -681,7 +681,7 @@ int free_bridge_port_32(int inst, int bp)
 	tmp->eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, tmp);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_GET: %d\n", bp);
+		pr_err("Failed GSW_BRIDGE_PORT_CONFIG_GET: %d\n", bp);
 		goto EXIT;
 	}
 	/*remove this delting bridgeport from other bridge port's member*/
@@ -696,13 +696,13 @@ int free_bridge_port_32(int inst, int bp)
 			tmp2->nBridgePortId = i * 16 + j;
 			ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, tmp2);
 			if (ret != GSW_statusOk) {
-				PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_GET\n");
+				pr_err("Failed GSW_BRIDGE_PORT_CONFIG_GET\n");
 				goto EXIT;
 			}
 			UNSET_BP_MAP(tmp2->nBridgePortMap, bp);
 			ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, tmp2);
 			if (ret != GSW_statusOk) {
-				PR_ERR("Failed GSW_BRIDGE_PORT_CONFIG_SET\n");
+				pr_err("Failed GSW_BRIDGE_PORT_CONFIG_SET\n");
 				goto EXIT;
 			}
 		}
@@ -715,7 +715,7 @@ int free_bridge_port_32(int inst, int bp)
 	ret = gsw_bp->BridgePort_Free(gsw_handle,
 				      (GSW_BRIDGE_portAlloc_t *)tmp);
 	if (ret != GSW_statusOk)
-		PR_ERR("Failed to GSW_BRIDGE_PORT_FREE:%d\n", bp);
+		pr_err("Failed to GSW_BRIDGE_PORT_FREE:%d\n", bp);
 FREE_EXIT:
 	kfree(tmp);
 	kfree(tmp2);
@@ -738,7 +738,7 @@ int dp_gswip_mac_entry_add_32(int bport, int fid, int inst, u8 *addr)
 	memcpy(tmp.nMAC, addr, GSW_MAC_ADDR_LEN);
 	ret = gsw_handle->gsw_swmac_ops.MAC_TableEntryAdd(gsw_handle, &tmp);
 	if (ret != GSW_statusOk) {
-		PR_ERR("fail in setting MAC table static add entry\r\n");
+		pr_err("fail in setting MAC table static add entry\r\n");
 		return -1;
 	}
 	return 0;
@@ -760,14 +760,14 @@ int dp_gswip_mac_entry_del_32(int bport, int fid, int inst, u8 *addr)
 	memcpy(mac_query.nMAC, addr, GSW_MAC_ADDR_LEN);
 	ret = gsw_swmac->MAC_TableEntryQuery(gsw_handle, &mac_query);
 	if (ret != GSW_statusOk) {
-		PR_ERR("fail in getting MAC query entry\r\n");
+		pr_err("fail in getting MAC query entry\r\n");
 		return -1;
 	}
 	tmp.nFId = fid;
 	memcpy(tmp.nMAC, addr, GSW_MAC_ADDR_LEN);
 	ret = gsw_swmac->MAC_TableEntryRemove(gsw_handle, &tmp);
 	if (ret != GSW_statusOk) {
-		PR_ERR("fail in setting MAC static entry remove\r\n");
+		pr_err("fail in setting MAC static entry remove\r\n");
 		return -1;
 	}
 	return 0;
@@ -784,14 +784,14 @@ int cpu_vlan_mod_dis_32(int inst)
 	cfg.nPortId = 0;
 	ret = ops->gsw_qos_ops.QoS_PortRemarkingCfgGet(ops, &cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("QoS_PortRemarkingCfgGet failed\n");
+		pr_err("QoS_PortRemarkingCfgGet failed\n");
 		return -1;
 	}
 
 	cfg.bPCP_EgressRemarkingEnable = LTQ_FALSE;
 	ret = ops->gsw_qos_ops.QoS_PortRemarkingCfgSet(ops, &cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("QoS_PortRemarkingCfgSet failed\n");
+		pr_err("QoS_PortRemarkingCfgSet failed\n");
 		return -1;
 	}
 
@@ -857,7 +857,7 @@ int dp_set_gsw_pmapper_32(int inst, int bport, int lport,
 		 bp_cfg.eMask);
 	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("fail in setting pmapper\r\n");
+		pr_err("fail in setting pmapper\r\n");
 		return -1;
 	}
 	return 0;
@@ -887,7 +887,7 @@ int dp_get_gsw_pmapper_32(int inst, int bport, int lport,
 
 	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("fail in getting pmapper\r\n");
+		pr_err("fail in getting pmapper\r\n");
 		return -1;
 	}
 
@@ -896,7 +896,7 @@ int dp_get_gsw_pmapper_32(int inst, int bport, int lport,
 		 bp_cfg.ePmapperMappingMode, bp_cfg.bPmapperEnable);
 
 	if (!bp_cfg.bPmapperEnable) {
-		PR_ERR("pmapper not enabled\r\n");
+		pr_err("pmapper not enabled\r\n");
 		return -1;
 	}
 	mapper->pmapper_id = bp_cfg.sPmapper.nPmapperId;
@@ -936,16 +936,16 @@ int dp_meter_alloc_32(int inst, int *meterid, int flag)
 	GSW_return_t ret;
 
 	if (inst < 0) {
-		PR_ERR("inst invalid\n");
+		pr_err("inst invalid\n");
 		return -1;
 	}
 	if (!meterid) {
-		PR_ERR("meterid NULL\n");
+		pr_err("meterid NULL\n");
 		return -1;
 	}
 	gsw_handle = dp_port_prop[inst].ops[GSWIP_L];
 	if (!gsw_handle) {
-		PR_ERR("gsw_handle NULL\n");
+		pr_err("gsw_handle NULL\n");
 		return -1;
 	}
 	gsw_qos = &gsw_handle->gsw_qos_ops;
@@ -953,7 +953,7 @@ int dp_meter_alloc_32(int inst, int *meterid, int flag)
 		meter_cfg.nMeterId = *meterid;
 		ret = gsw_qos->QOS_MeterAlloc(gsw_handle, &meter_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("Meter dealloc failed: %d\n", ret);
+			pr_err("Meter dealloc failed: %d\n", ret);
 			return -1;
 		}
 		return 0;
@@ -961,7 +961,7 @@ int dp_meter_alloc_32(int inst, int *meterid, int flag)
 	memset(&meter_cfg, 0, sizeof(meter_cfg));
 	ret = gsw_qos->QOS_MeterAlloc(gsw_handle, &meter_cfg);
 	if ((ret != GSW_statusOk) || (meter_cfg.nMeterId < 0)) {
-		PR_ERR("Failed to get a meter alloc\n");
+		pr_err("Failed to get a meter alloc\n");
 		*meterid = -1;
 		return -1;
 	}
@@ -981,7 +981,7 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 	struct pmac_port_info *port_info;
 
 	if (!mtr_subif) {
-		PR_ERR("mtr_subif NULL\n");
+		pr_err("mtr_subif NULL\n");
 		return -1;
 	}
 	memset(&bp_cfg, 0, sizeof(GSW_BRIDGE_portConfig_t));
@@ -993,7 +993,7 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 	gsw_bp = &gsw_handle->gsw_brdgport_ops;
 	if (flag & DP_METER_ATTACH_CTP) {/* CTP port Flag */
 		if (mtr_subif->subif.flag_pmapper) {
-			PR_ERR("can't use CTP,pmapper is enable\n");
+			pr_err("can't use CTP,pmapper is enable\n");
 			return -1;
 		}
 		port_info = get_dp_port_info(mtr_subif->subif.inst,
@@ -1004,7 +1004,7 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 						 port_info->vap_mask);
 		ret = gsw_ctp->CTP_PortConfigGet(gsw_handle, &ctp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("PortConfigGet API failed :%d\n", ret);
+			pr_err("PortConfigGet API failed :%d\n", ret);
 			return -1;
 		}
 		if (meter->dir == DP_DIR_INGRESS) {
@@ -1026,35 +1026,35 @@ static int dp_set_col_mark(struct net_device *dev, struct dp_meter_cfg  *meter,
 		}
 		ret = gsw_ctp->CTP_PortConfigSet(gsw_handle, &ctp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("PortConfigSet API failed :%d\n", ret);
+			pr_err("PortConfigSet API failed :%d\n", ret);
 			return -1;
 		}
 	}
 	if (flag & DP_METER_ATTACH_BRPORT) {/*BRIDGE port Flag*/
 		if (!mtr_subif->subif.flag_bp) {
-			PR_ERR("flag_bp value 0\n");
+			pr_err("flag_bp value 0\n");
 			return -1;
 		}
 		bp_cfg.nBridgePortId = mtr_subif->subif.bport;
 		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &bp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("BridgePort_ConfigGet API failed :%d\n", ret);
+			pr_err("BridgePort_ConfigGet API failed :%d\n", ret);
 			return -1;
 		}
 		if (meter->dir == DP_DIR_EGRESS) {
-			PR_ERR("No Egress color marking for bridge port\n");
+			pr_err("No Egress color marking for bridge port\n");
 			return -1;
 		} else if (meter->dir == DP_DIR_INGRESS) {
 			bp_cfg.eMask =
 				GSW_BRIDGE_PORT_CONFIG_MASK_INGRESS_MARKING;
 			bp_cfg.eIngressMarkingMode = meter->mode;
 		} else {
-			PR_ERR(" invalid color mark dir\n");
+			pr_err(" invalid color mark dir\n");
 			return -1;
 		}
 		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &bp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("BridgePort_ConfigSet API failed :%d\n", ret);
+			pr_err("BridgePort_ConfigSet API failed :%d\n", ret);
 			return -1;
 		}
 	}
@@ -1079,7 +1079,7 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	int bret = 0;
 
 	if (!mtr_subif) {
-		PR_ERR("mtr_subif NULL\n");
+		pr_err("mtr_subif NULL\n");
 		return -1;
 	}
 	gsw_handle = dp_port_prop[mtr_subif->inst].ops[GSWIP_L];
@@ -1103,14 +1103,14 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	} else if (meter->type == trTCM) {
 		meter_cfg.eMtrType = GSW_QOS_Meter_trTCM;
 	} else {
-		PR_ERR(" invalid meter type\n");
+		pr_err(" invalid meter type\n");
 		return -1;
 	}
 	meter_cfg.nMeterId = meter->meter_id;
 	meter_cfg.nColourBlindMode = meter->col_mode;
 	ret = gsw_qos->QoS_MeterCfgSet(gsw_handle, &meter_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("MeterCfgSet API failed:%d\n", ret);
+		pr_err("MeterCfgSet API failed:%d\n", ret);
 		return -1;
 	}
 
@@ -1118,7 +1118,7 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		/* pattern setting */
 		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_ATOMIC);
 		if (!pce_rule) {
-			PR_ERR("ctp_cfg alloc failed\n");
+			pr_err("ctp_cfg alloc failed\n");
 			bret = -1;
 			goto err;
 		}
@@ -1129,7 +1129,7 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		pce_rule->action.nMeterId =  meter->meter_id;
 		ret = gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, pce_rule);
 		if (ret != GSW_statusOk) {
-			PR_ERR("PceRule Write API failed :%d\n", ret);
+			pr_err("PceRule Write API failed :%d\n", ret);
 			goto err;
 		}
 	}
@@ -1137,20 +1137,20 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		struct pmac_port_info *port_info;
 
 		if (mtr_subif->subif.flag_pmapper) {
-			PR_ERR("can't use CTP,pmapper is enable\n");
+			pr_err("can't use CTP,pmapper is enable\n");
 			bret = -1;
 			goto err;
 		}
 		ctp_cfg = kzalloc(sizeof(GSW_CTP_portConfig_t), GFP_ATOMIC);
 		if (!ctp_cfg) {
-			PR_ERR("ctp_cfg alloc failed\n");
+			pr_err("ctp_cfg alloc failed\n");
 			bret = -1;
 			goto err;
 		}
 		port_info = get_dp_port_info(mtr_subif->subif.inst,
 					     mtr_subif->subif.port_id);
 		if (!port_info) {
-			PR_ERR(" port_info is NULL\n");
+			pr_err(" port_info is NULL\n");
 			bret = -1;
 			goto err;
 		}
@@ -1160,7 +1160,7 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 						 port_info->vap_mask);
 		ret = gsw_ctp->CTP_PortConfigGet(gsw_handle, ctp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("PortConfigGet API failed :%d\n", ret);
+			pr_err("PortConfigGet API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
@@ -1173,32 +1173,32 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			ctp_cfg->bIngressMeteringEnable = 1;
 			ctp_cfg->nIngressTrafficMeterId =  meter->meter_id;
 		} else {
-			PR_ERR(" invalid meter dir\n");
+			pr_err(" invalid meter dir\n");
 			return -1;
 		}
 		ret = gsw_ctp->CTP_PortConfigSet(gsw_handle, ctp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("PortConfigSet API failed :%d\n", ret);
+			pr_err("PortConfigSet API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
 	}
 	if (flag & DP_METER_ATTACH_BRPORT) {/*BRIDGE port Flag*/
 		if (!mtr_subif->subif.flag_bp) {
-			PR_ERR("flag_bp value 0\n");
+			pr_err("flag_bp value 0\n");
 			bret = -1;
 			goto err;
 		}
 		bp_cfg = kzalloc(sizeof(GSW_BRIDGE_portConfig_t), GFP_ATOMIC);
 		if (!bp_cfg) {
-			PR_ERR("bp_cfg alloc failed\n");
+			pr_err("bp_cfg alloc failed\n");
 			bret = -1;
 			goto err;
 		}
 		bp_cfg->nBridgePortId = mtr_subif->subif.bport;
 		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, bp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("BridgePort_ConfigGet API failed :%d\n", ret);
+			pr_err("BridgePort_ConfigGet API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
@@ -1227,26 +1227,26 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			bp_cfg->bIngressMeteringEnable = 1;
 			bp_cfg->nIngressTrafficMeterId = meter->meter_id;
 		} else {
-			PR_ERR(" invalid meter dir\n");
+			pr_err(" invalid meter dir\n");
 			return -1;
 		}
 		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, bp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("BridgePort_ConfigSet API failed :%d\n", ret);
+			pr_err("BridgePort_ConfigSet API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
 	} else if (flag & DP_METER_ATTACH_BRIDGE) {
 		br_cfg = kzalloc(sizeof(GSW_BRIDGE_config_t), GFP_ATOMIC);
 		if (!br_cfg) {
-			PR_ERR("br_cfg alloc failed\n");
+			pr_err("br_cfg alloc failed\n");
 			bret = -1;
 			goto err;
 		}
 		br_cfg->nBridgeId = mtr_subif->fid;
 		ret = gsw_brdg->Bridge_ConfigGet(gsw_handle, br_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("Bridge_ConfigGet API failed :%d\n", ret);
+			pr_err("Bridge_ConfigGet API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
@@ -1264,13 +1264,13 @@ int dp_meter_add_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			       GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST,
 			       meter->meter_id, 1);
 		else {
-			PR_ERR("Meter flow invalid\n");
+			pr_err("Meter flow invalid\n");
 			bret = -1;
 			goto err;
 		}
 		ret = gsw_brdg->Bridge_ConfigSet(gsw_handle, br_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("Bridge_ConfigSet API failed :%d\n", ret);
+			pr_err("Bridge_ConfigSet API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
@@ -1299,7 +1299,7 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	int bret = 0;
 
 	if (!mtr_subif) {
-		PR_ERR(" mtr_subif NULL\n");
+		pr_err(" mtr_subif NULL\n");
 		return -1;
 	}
 	gsw_handle = dp_port_prop[mtr_subif->inst].ops[GSWIP_L];
@@ -1312,7 +1312,7 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	if (meter->dir & DP_METER_ATTACH_PCE) {
 		pce_rule = kzalloc(sizeof(GSW_PCE_rule_t), GFP_ATOMIC);
 		if (!pce_rule) {
-			PR_ERR("ctp_cfg alloc failed\n");
+			pr_err("ctp_cfg alloc failed\n");
 			bret = -1;
 			goto err;
 		}
@@ -1321,7 +1321,7 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		pce_rule->pattern.bEnable = 0;
 		ret = gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, pce_rule);
 		if (ret != GSW_statusOk) {
-			PR_ERR("PceRule Write API failed :%d\n", ret);
+			pr_err("PceRule Write API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
@@ -1330,20 +1330,20 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		struct pmac_port_info *port_info;
 
 		if (mtr_subif->subif.flag_pmapper) {
-			PR_ERR("flag_pmapper is set\n");
+			pr_err("flag_pmapper is set\n");
 			bret = -1;
 			goto err;
 		}
 		ctp_cfg = kzalloc(sizeof(GSW_CTP_portConfig_t), GFP_ATOMIC);
 		if (!ctp_cfg) {
-			PR_ERR("ctp_cfg alloc failed\n");
+			pr_err("ctp_cfg alloc failed\n");
 			bret = -1;
 			goto err;
 		}
 		port_info = get_dp_port_info(mtr_subif->subif.inst,
 					     mtr_subif->subif.port_id);
 		if (!port_info) {
-			PR_ERR(" port_info is NULL\n");
+			pr_err(" port_info is NULL\n");
 			bret = -1;
 			goto err;
 		}
@@ -1375,20 +1375,20 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	}
 	if (flag & DP_METER_ATTACH_BRPORT) {
 		if (!mtr_subif->subif.flag_bp) {
-			PR_ERR("flag_bp is 0\n");
+			pr_err("flag_bp is 0\n");
 			bret = -1;
 			goto err;
 		}
 		bp_cfg = kzalloc(sizeof(GSW_BRIDGE_portConfig_t), GFP_ATOMIC);
 		if (!bp_cfg) {
-			PR_ERR("bp_cfg alloc failed\n");
+			pr_err("bp_cfg alloc failed\n");
 			bret = -1;
 			goto err;
 		}
 		bp_cfg->nBridgePortId = mtr_subif->subif.bport;
 		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, bp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("BridgePort_ConfigGet API failed\n");
+			pr_err("BridgePort_ConfigGet API failed\n");
 			bret = -1;
 			goto err;
 		}
@@ -1418,7 +1418,7 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 		}
 		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, bp_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("BridgePort_ConfigSet API failed\n");
+			pr_err("BridgePort_ConfigSet API failed\n");
 			bret = -1;
 			goto err;
 		}
@@ -1426,14 +1426,14 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 	if (flag & DP_METER_ATTACH_BRIDGE) {
 		br_cfg = kzalloc(sizeof(GSW_BRIDGE_config_t), GFP_ATOMIC);
 		if (!br_cfg) {
-			PR_ERR("br_cfg alloc failed\n");
+			pr_err("br_cfg alloc failed\n");
 			bret = -1;
 			goto err;
 		}
 		br_cfg->nBridgeId = mtr_subif->fid;
 		ret = gsw_brdg->Bridge_ConfigGet(gsw_handle, br_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("Bridge_ConfigGet API failed :%d\n", ret);
+			pr_err("Bridge_ConfigGet API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
@@ -1451,13 +1451,13 @@ int dp_meter_del_32(struct net_device *dev,  struct dp_meter_cfg  *meter,
 			       GSW_BRIDGE_PORT_EGRESS_METER_BROADCAST,
 			       meter->meter_id, 0);
 		else {
-			PR_ERR("Meter flow invalid\n");
+			pr_err("Meter flow invalid\n");
 			bret = -1;
 			goto err;
 		}
 		ret = gsw_brdg->Bridge_ConfigSet(gsw_handle, br_cfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("Bridge_ConfigSet API failed :%d\n", ret);
+			pr_err("Bridge_ConfigSet API failed :%d\n", ret);
 			bret = -1;
 			goto err;
 		}
@@ -1483,11 +1483,11 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 
 	priv = (struct hal_priv *)dp_port_prop[inst].priv_hal;
 	if (!priv) {
-		PR_ERR("priv NULL ?\n");
+		pr_err("priv NULL ?\n");
 		return DP_FAILURE;
 	}
 	if (!gsw_handle) {
-		PR_ERR("gsw_handle NULL ?\n");
+		pr_err("gsw_handle NULL ?\n");
 		return DP_FAILURE;
 	}
 	memset(&lp_gp_assign, 0, sizeof(GSW_LPID_to_GPID_Assignment_t));
@@ -1501,7 +1501,7 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 
 		if (gsw_gpid->LpidToGpid_AssignmentSet(gsw_handle,
 						       &lp_gp_assign)) {
-			PR_ERR("Fail to assign Lpid->Gpid table %d in GSWIP\n",
+			pr_err("Fail to assign Lpid->Gpid table %d in GSWIP\n",
 			       ep);
 			return DP_FAILURE;
 		}
@@ -1511,7 +1511,7 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 
 		if (gsw_gpid->GpidToLpid_AssignmentSet(gsw_handle,
 						       &gp_lp_assign)) {
-			PR_ERR("Fail to assign GPID->LPID table %d in GSWIP\n",
+			pr_err("Fail to assign GPID->LPID table %d in GSWIP\n",
 			       ep);
 			return DP_FAILURE;
 		}
@@ -1520,23 +1520,23 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 	}
 	assign = get_ctp_assign(get_dp_port_info(inst, ep)->alloc_flags);
 	if (!assign) {
-		PR_ERR("assign NULL:ep=%d, alloc_f=0x%x\n",
+		pr_err("assign NULL:ep=%d, alloc_f=0x%x\n",
 		       ep, get_dp_port_info(inst, ep)->alloc_flags);
 		return DP_FAILURE;
 	}
 	gpid_num = assign->max_gpid;
 	gpid_base = alloc_gpid(inst, DP_DYN_GPID, gpid_num, ep);
 	if (gpid_base == DP_FAILURE) {
-		PR_ERR("Allocate %d GPID failed for Ep %d\n", gpid_num, ep);
+		pr_err("Allocate %d GPID failed for Ep %d\n", gpid_num, ep);
 		return DP_FAILURE;
 	}
 	gpid_spl = alloc_gpid(inst, DP_SPL_GPID, 1, ep);
 	if (gpid_spl == DP_FAILURE) {
-		DP_ERR("Fail to alloc special GPID for dpid=%d\n", ep);
+		pr_err("Fail to alloc special GPID for dpid=%d\n", ep);
 		return DP_FAILURE;
 	}
 	DP_DEBUG(DP_DBG_FLAG_DBG, "Lpid->Gpid table ep=%d\n", ep);
-	PR_INFO("Alloc GPID=%d num=%d spl_GPID=%d\n", gpid_base, gpid_num,
+	pr_info("Alloc GPID=%d num=%d spl_GPID=%d\n", gpid_base, gpid_num,
 		gpid_spl);
 	lp_gp_assign.nLogicalPortId = ep;
 	lp_gp_assign.nFirstGlobalPortId = gpid_base;
@@ -1544,7 +1544,7 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 
 	if (gsw_gpid->LpidToGpid_AssignmentSet(gsw_handle, &lp_gp_assign)) {
 #if 0
-		PR_ERR("Fail to assign Lpid->Gpid table %d in GSWIP\n",
+		pr_err("Fail to assign Lpid->Gpid table %d in GSWIP\n",
 		       ep);
 #endif
 		return DP_FAILURE;
@@ -1556,7 +1556,7 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 	gp_lp_assign.nGlobalPortId = gpid_base;
 
 	if (gsw_gpid->GpidToLpid_AssignmentSet(gsw_handle, &gp_lp_assign)) {
-		PR_ERR("Fail to assign Gpid->Lpid table %d in GSWIP\n",
+		pr_err("Fail to assign Gpid->Lpid table %d in GSWIP\n",
 		       ep);
 #if 0
 		return DP_FAILURE;
@@ -1572,13 +1572,13 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 	for (i = 0; i < gpid_num; i++) {
 		cbm_gpid.gpid = gpid_base + i;
 		if (cbm_gpid_lpid_map(&cbm_gpid)) {
-			DP_ERR("Fail to set CBM GPID(%d)<->LPID(%d)\n",
+			pr_err("Fail to set CBM GPID(%d)<->LPID(%d)\n",
 			       cbm_gpid.gpid, cbm_gpid.lpid);
 #if 0
 			return DP_FAILURE;
 #endif
 		}
-		DP_INFO("cbm_gpid:lpid=%d gpid=%d\n", cbm_gpid.lpid,
+		pr_info("cbm_gpid:lpid=%d gpid=%d\n", cbm_gpid.lpid,
 			cbm_gpid.gpid);
 	}
 	get_dp_port_info(inst, ep)->gpid_base = gpid_base;
@@ -1592,11 +1592,11 @@ int gpid_port_assign(int inst, u8 ep, u32 flags)
 	priv->gp_dp_map[gpid_spl].dpid = ep;
 
 	/* alloc/configure speical GPID for this dp port */
-	PR_INFO("Try to add gpid_spl=%d\n",
+	pr_info("Try to add gpid_spl=%d\n",
 		get_dp_port_info(inst, ep)->gpid_spl);
 	if (dp_add_pp_gpid(inst, ep, 0,
 			   get_dp_port_info(inst, ep)->gpid_spl, 1)) {
-		DP_ERR("dp_add_pp_gpid for dport/gpid=%d/%d\n", ep,
+		pr_err("dp_add_pp_gpid for dport/gpid=%d/%d\n", ep,
 		       get_dp_port_info(inst, ep)->gpid_spl);
 		return DP_FAILURE;
 	}
@@ -1616,7 +1616,7 @@ int dp_set_bp_attr_32(struct dp_bp_attr *conf, int bport, uint32_t flag)
 
 	ret = ops->gsw_brdgport_ops.BridgePort_ConfigGet(ops, &brportcfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("fail in getting bridge port config\r\n");
+		pr_err("fail in getting bridge port config\r\n");
 		return DP_FAILURE;
 	}
 
@@ -1627,7 +1627,7 @@ int dp_set_bp_attr_32(struct dp_bp_attr *conf, int bport, uint32_t flag)
 
 	ret = ops->gsw_brdgport_ops.BridgePort_ConfigSet(ops, &brportcfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Fail in allocating/configuring bridge port\n");
+		pr_err("Fail in allocating/configuring bridge port\n");
 		return DP_FAILURE;
 	}
 
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_lookup_proc.c b/drivers/net/datapath/dpm/gswip32/datapath_lookup_proc.c
index 8caf76003eb8..3a1da8710db5 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_lookup_proc.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_lookup_proc.c
@@ -41,7 +41,7 @@
 #define proc_printf(s, fmt, arg...) \
 	do { \
 		if (!s) \
-			PR_INFO(fmt, ##arg); \
+			pr_info(fmt, ##arg); \
 		else \
 			seq_printf(s, fmt, ##arg); \
 	} while (0)
@@ -263,7 +263,7 @@ static void lookup_pattern_match(int tmp_index)
 			for (i = 0; i < LOOKUP_FIELD_BITS; i++)
 				index |= (t[i] << i);
 			if (lookup_tbl_flags[index] == ENTRY_USED)
-				PR_ERR("why already used\n");
+				pr_err("why already used\n");
 			else
 				lookup_tbl_flags[index] = ENTRY_USED;
 		}
@@ -467,13 +467,13 @@ ssize_t proc_get_qid_via_index32(struct file *file, const char *buf,
 
 	if (len <= 0) {
 		err = -EFAULT;
-		PR_ERR("Wrong len value (%d)\n", len);
+		pr_err("Wrong len value (%d)\n", len);
 		return count;
 	}
 
 	if (copy_from_user(data, buf, len)) {
 		err = -EFAULT;
-		PR_ERR("copy_from_user fail");
+		pr_err("copy_from_user fail");
 		return count;
 	}
 
@@ -490,7 +490,7 @@ ssize_t proc_get_qid_via_index32(struct file *file, const char *buf,
 	if ((dp_strncmpi(param_list[0], "set", strlen("set")) == 0) ||
 	    (dp_strncmpi(param_list[0], "write", strlen("write")) == 0)) {
 		if (!param_list[2]) {
-			PR_ERR("wrong command\n");
+			pr_err("wrong command\n");
 			return count;
 		}
 		qid = dp_atoi(param_list[2]);
@@ -500,7 +500,7 @@ ssize_t proc_get_qid_via_index32(struct file *file, const char *buf,
 					       qid);
 			return count;
 		}
-		PR_INFO("Set to queue[%u] done\n", qid);
+		pr_info("Set to queue[%u] done\n", qid);
 		lookup.index = lookup_index;
 		lookup.qid = qid;
 		dp_set_lookup_qid_via_index(&lookup);
@@ -514,7 +514,7 @@ ssize_t proc_get_qid_via_index32(struct file *file, const char *buf,
 		}
 		lookup.index = lookup_index;
 		qid = dp_get_lookup_qid_via_index(&lookup);
-		PR_INFO("Get lookup[%05u 0x%04x] ->     queue[%u]\n",
+		pr_info("Get lookup[%05u 0x%04x] ->     queue[%u]\n",
 			lookup_index, lookup_index, qid);
 		return count;
 	} else if (dp_strncmpi(param_list[0], "find",
@@ -537,7 +537,7 @@ ssize_t proc_get_qid_via_index32(struct file *file, const char *buf,
 		int new_q = dp_atoi(param_list[2]);
 
 		lookup_table_remap(old_q, new_q);
-		PR_INFO("remap queue[%d] to queue[%d] done\n",
+		pr_info("remap queue[%d] to queue[%d] done\n",
 			old_q, new_q);
 		return count;
 	}  else if (dp_strncmpi(param_list[0], "test",
@@ -559,33 +559,33 @@ ssize_t proc_get_qid_via_index32(struct file *file, const char *buf,
 		lookup.ep = 3;
 		cbm_queue_map_set(dp_port_prop[inst].cbm_inst, qid,
 				  &lookup, flag);
-		DP_INFO("cbm_queue_map_set ep=%d egflag=%d qid=%d flag=0x%x\n",
+		pr_info("cbm_queue_map_set ep=%d egflag=%d qid=%d flag=0x%x\n",
 			lookup.ep, lookup.egflag, qid, flag);
 		lookup.egflag = 1;
 		cbm_queue_map_set(dp_port_prop[inst].cbm_inst, qid,
 				  &lookup, flag);
-		DP_INFO("cbm_queue_map_set ep=%d egflag=%d qid=%d flag=0x%x\n",
+		pr_info("cbm_queue_map_set ep=%d egflag=%d qid=%d flag=0x%x\n",
 			lookup.ep, lookup.egflag, qid, flag);
 		return count;
 	}
 	goto help;
 help:
-	PR_INFO("Usage: echo set lookup_flags queue_id > /proc/dp/lookup\n");
-	PR_INFO("     : echo get lookup_flags > /proc/dp/lookup\n");
-	PR_INFO("     : echo find  <x> > /proc/dp/lookup\n");
-	PR_INFO("     : echo find2 <x> > /proc/dp/lookup\n");
-	PR_INFO("     : echo remap <old_q> <new_q> > /proc/dp/lookup\n");
-	PR_INFO("     : echo test <qid> > /proc/dp/lookup\n");
-	PR_INFO("  Hex example: echo set 0x10 10 > /proc/dp/lookup\n");
-	PR_INFO("  Dec:example: echo set 16 10 > /proc/dp/lookup\n");
-	PR_INFO("  Bin:example: echo set b10000 10 > /proc/dp/lookup\n");
-
-	PR_INFO("%s: echo set b1xxxx 10 > /proc/dp/lookup\n",
+	pr_info("Usage: echo set lookup_flags queue_id > /proc/dp/lookup\n");
+	pr_info("     : echo get lookup_flags > /proc/dp/lookup\n");
+	pr_info("     : echo find  <x> > /proc/dp/lookup\n");
+	pr_info("     : echo find2 <x> > /proc/dp/lookup\n");
+	pr_info("     : echo remap <old_q> <new_q> > /proc/dp/lookup\n");
+	pr_info("     : echo test <qid> > /proc/dp/lookup\n");
+	pr_info("  Hex example: echo set 0x10 10 > /proc/dp/lookup\n");
+	pr_info("  Dec:example: echo set 16 10 > /proc/dp/lookup\n");
+	pr_info("  Bin:example: echo set b10000 10 > /proc/dp/lookup\n");
+
+	pr_info("%s: echo set b1xxxx 10 > /proc/dp/lookup\n",
 		"Special for BIN(Don't care bit)");
-	PR_INFO("Lookup format:\n");
-	PR_INFO("  Bits Index: | %s\n",
+	pr_info("Lookup format:\n");
+	pr_info("  Bits Index: | %s\n",
 		"13   12 |  11  |  10  |  9   |  8   |7   4 | 3   0 |");
-	PR_INFO("  Fields:     | %s\n",
+	pr_info("  Fields:     | %s\n",
 		"Flow ID | DEC  | ENC  | MPE2 | MPE1 |  EP  | CLASS |");
 	return count;
 }
@@ -606,14 +606,14 @@ void lookup_table_via_qid(int qid)
 				if (tmp != qid)
 					continue;
 				f = 1;
-				PR_INFO("Get lookup[%05u 0x%04x]%s[%d]\n",
+				pr_info("Get lookup[%05u 0x%04x]%s[%d]\n",
 					index, index,
 					" ->     queue", qid);
 			}
 		}
 	}
 	if (!f)
-		PR_ERR("No mapping to queue id %d yet ?\n", qid);
+		pr_err("No mapping to queue id %d yet ?\n", qid);
 }
 
 void lookup_table_remap(int old_q, int new_q)
@@ -644,7 +644,7 @@ void lookup_table_remap(int old_q, int new_q)
 		}
 	}
 	if (!f)
-		PR_INFO("No mapping to queue id %d yet\n", new_q);
+		pr_info("No mapping to queue id %d yet\n", new_q);
 }
 
 static u8 lookup_flags2[LOOKUP_FIELD_BITS];
@@ -720,7 +720,7 @@ void lookup_table_recursive(int k, int tmp_index, int set_flag, int qid)
 		} else {
 			lookup.index = tmp_index;
 			qid = dp_get_lookup_qid_via_index(&lookup);
-			PR_INFO("Get lookup[%05u/0x%04x] ->     queue[%d]\n",
+			pr_info("Get lookup[%05u/0x%04x] ->     queue[%d]\n",
 				tmp_index, tmp_index, qid);
 		}
 		return;
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_misc.c b/drivers/net/datapath/dpm/gswip32/datapath_misc.c
index 6269c988c2b3..5fd7cfc0c328 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_misc.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_misc.c
@@ -182,18 +182,18 @@ void dump_rx_dma_desc_32(struct dma_rx_desc_0 *desc_0,
 			 struct dma_rx_desc_3 *desc_3)
 {
 	if (!desc_0 || !desc_1 || !desc_2 || !desc_3) {
-		PR_ERR("rx desc_0/1/2/3 NULL\n");
+		pr_err("rx desc_0/1/2/3 NULL\n");
 		return;
 	}
 
-	PR_INFO(" DMA Descriptor:D0=0x%08x D1=0x%08x D2=0x%08x D3=0x%08x\n",
+	pr_info(" DMA Descriptor:D0=0x%08x D1=0x%08x D2=0x%08x D3=0x%08x\n",
 		*(u32 *)desc_0, *(u32 *)desc_1,
 		*(u32 *)desc_2, *(u32 *)desc_3);
-	PR_INFO("  DW0: dw0bit31=%d flow_id=%d dw0bit16=%d %s=0x%04x\n",
+	pr_info("  DW0: dw0bit31=%d flow_id=%d dw0bit16=%d %s=0x%04x\n",
 		desc_0->field.dw0bit31,
 		desc_0->field.flow_id, desc_0->field.dw0bit16,
 		"subif", desc_0->field.dest_sub_if_id);
-	PR_INFO(
+	pr_info(
 		"  DW1: redir=%d header_mode=%d pmac=%d ts=%d pre_l2=%d classen=%d fcs=%d pkt_type=%d src_pool=%d dec=%d enc=%d lro_type=%d color=%d port=%d classid=%d\n",
 		desc_1->field.redir, desc_1->field.header_mode,
 		desc_1->field.pmac, desc_1->field.ts, desc_1->field.pre_l2,
@@ -201,9 +201,9 @@ void dump_rx_dma_desc_32(struct dma_rx_desc_0 *desc_0,
 		desc_1->field.pkt_type, desc_1->field.src_pool,
 		desc_1->field.dec, desc_1->field.enc, desc_1->field.lro_type,
 		desc_1->field.color, desc_1->field.ep, desc_1->field.classid);
-	PR_INFO("  DW2: data_ptr=0x%08x ByteOffset=%d\n",
+	pr_info("  DW2: data_ptr=0x%08x ByteOffset=%d\n",
 		desc_2->field.data_ptr, desc_2->field.byte_offset);
-	PR_INFO(
+	pr_info(
 		"  DW3: own=%d c=%d sop=%d eop=%d dic=%d haddr=0x%08x sp=%d pool_policy=%d data_len=%d\n",
 		desc_3->field.own, desc_3->field.c, desc_3->field.sop,
 		desc_3->field.eop, desc_3->field.dic, desc_3->field.haddr,
@@ -224,17 +224,17 @@ void dump_tx_dma_desc_32(struct dma_tx_desc_0 *desc_0,
 	struct pmac_port_info *port_info;
 
 	if (!desc_0 || !desc_1 || !desc_2 || !desc_3) {
-		PR_ERR("tx desc_0/1/2/3 NULL\n");
+		pr_err("tx desc_0/1/2/3 NULL\n");
 		return;
 	}
-	PR_INFO(" DMA Descripotr:D0=0x%08x D1=0x%08x D2=0x%08x D3=0x%08x\n",
+	pr_info(" DMA Descripotr:D0=0x%08x D1=0x%08x D2=0x%08x D3=0x%08x\n",
 		*(u32 *)desc_0, *(u32 *)desc_1,
 		*(u32 *)desc_2, *(u32 *)desc_3);
-	PR_INFO("  DW0:dw0bit31=%d flow_id=%d dw0bit16=%d %s=0x%04x\n",
+	pr_info("  DW0:dw0bit31=%d flow_id=%d dw0bit16=%d %s=0x%04x\n",
 		desc_0->field.dw0bit31,
 		desc_0->field.flow_id, desc_0->field.dw0bit16,
 		"subif", desc_0->field.dest_sub_if_id);
-	PR_INFO(
+	pr_info(
 		"  DW1:redir=%d header_mode=%d pmac=%d ts=%d pre_l2=%d classen=%d fcs=%d pkt_type=%d src_pool=%d dec=%d enc=%d lro_type=%d color=%d port=%d classid=%d\n",
 		desc_1->field.redir, desc_1->field.header_mode,
 		desc_1->field.pmac, desc_1->field.ts, desc_1->field.pre_l2,
@@ -242,9 +242,9 @@ void dump_tx_dma_desc_32(struct dma_tx_desc_0 *desc_0,
 		desc_1->field.pkt_type, desc_1->field.src_pool,
 		desc_1->field.dec, desc_1->field.enc, desc_1->field.lro_type,
 		desc_1->field.color, desc_1->field.ep, desc_1->field.classid);
-	PR_INFO("  DW2:data_ptr=0x%08x ByteOffset=%d\n", desc_2->field.data_ptr,
+	pr_info("  DW2:data_ptr=0x%08x ByteOffset=%d\n", desc_2->field.data_ptr,
 		desc_2->field.byte_offset);
-	PR_INFO(
+	pr_info(
 		"  DW3:own=%d c=%d sop=%d eop=%d dic=%d haddr=0x%08x sp=%d pool_policy=%d data_len=%d\n",
 		desc_3->field.own, desc_3->field.c, desc_3->field.sop,
 		desc_3->field.eop, desc_3->field.dic, desc_3->field.haddr,
@@ -299,13 +299,13 @@ void dump_tx_dma_desc_32(struct dma_tx_desc_0 *desc_0,
 			 ((dp_port & 0x0F) << 8) |
 			 ((desc_1->field.redir) << 12);
 	else {
-		PR_INFO("Invalid Lookup Mode: %d\n",
+		pr_info("Invalid Lookup Mode: %d\n",
 			port_info->cqe_lu_mode);
 		return;
 	}
 	cbm_lookup.index = lookup;
 	cbm_lookup.egflag = desc_1->field.redir;
-	PR_INFO("  lookup index=0x%x qid=%d for gpid=%u\n", lookup,
+	pr_info("  lookup index=0x%x qid=%d for gpid=%u\n", lookup,
 		dp_get_lookup_qid_via_index(&cbm_lookup), desc_1->field.ep);
 }
 
@@ -316,7 +316,7 @@ static void dump_rx_pmac(struct pmac_rx_hdr *pmac)
 	unsigned char buf[100];
 
 	if (!pmac) {
-		PR_ERR(" pmac NULL ??\n");
+		pr_err(" pmac NULL ??\n");
 		return;
 	}
 
@@ -324,32 +324,32 @@ static void dump_rx_pmac(struct pmac_rx_hdr *pmac)
 	for (i = 0; i < 8; i++)
 		l += sprintf(buf + l, "0x%02x ", p[i]);
 	l += sprintf(buf + l, "\n");
-	PR_INFO("%s", buf);
+	pr_info("%s", buf);
 
 	/*byte 0 */
-	PR_INFO("  byte 0:ver_done=%d ip_offset=%d\n",
+	pr_info("  byte 0:ver_done=%d ip_offset=%d\n",
 		pmac->ver_done, pmac->ip_offset);
 	/*byte 1 */
-	PR_INFO("  byte 1:tcp_h_offset=%d tcp_type=%d\n", pmac->tcp_h_offset,
+	pr_info("  byte 1:tcp_h_offset=%d tcp_type=%d\n", pmac->tcp_h_offset,
 		pmac->tcp_type);
 	/*byte 2 */
-	PR_INFO("  byte 2:class=%d res=%d src_dst_subif_id_14_12=%d\n",
+	pr_info("  byte 2:class=%d res=%d src_dst_subif_id_14_12=%d\n",
 		pmac->class, pmac->res2, pmac->src_dst_subif_id_14_12);
 	/*byte 3 */
-	PR_INFO("  byte 3:%s=%d %s=%d %s=%d %s=%d %s=%d %s=%d\n",
+	pr_info("  byte 3:%s=%d %s=%d %s=%d %s=%d %s=%d %s=%d\n",
 		"pkt_type", pmac->pkt_type, "ext", pmac->ext,
 		"ins", pmac->ins, "pre_12", pmac->pre_l2,
 		"oam", pmac->oam, "res32", pmac->res32);
 	/*byte 4 */
-	PR_INFO("  byte 4:fcs=%d ptp=%d one_step=%d src_dst_subif_id_msb=%d\n",
+	pr_info("  byte 4:fcs=%d ptp=%d one_step=%d src_dst_subif_id_msb=%d\n",
 		pmac->fcs, pmac->ptp, pmac->one_step,
 		pmac->src_dst_subif_id_msb);
 	/*byte 5 */
-	PR_INFO("  byte 5:src_sub_inf_id2=%d\n", pmac->src_dst_subif_id_lsb);
+	pr_info("  byte 5:src_sub_inf_id2=%d\n", pmac->src_dst_subif_id_lsb);
 	/*byte 6 */
-	PR_INFO("  byte 6:record_id_msb=%d\n", pmac->record_id_msb);
+	pr_info("  byte 6:record_id_msb=%d\n", pmac->record_id_msb);
 	/*byte 7 */
-	PR_INFO("  byte 7:record_id_lsb=%d igp_egp=%d\n",
+	pr_info("  byte 7:record_id_lsb=%d igp_egp=%d\n",
 		pmac->record_id_lsb, pmac->igp_egp);
 }
 
@@ -360,7 +360,7 @@ static void dump_tx_pmac(struct pmac_tx_hdr *pmac)
 	unsigned char buf[100];
 
 	if (!pmac) {
-		PR_ERR("dump_tx_pmac pmac NULL ??\n");
+		pr_err("dump_tx_pmac pmac NULL ??\n");
 		return;
 	}
 
@@ -368,35 +368,35 @@ static void dump_tx_pmac(struct pmac_tx_hdr *pmac)
 	for (i = 0; i < 8; i++)
 		l += sprintf(buf + l, "0x%02x ", p[i]);
 	sprintf(buf + l, "\n");
-	PR_INFO("%s", buf);
+	pr_info("%s", buf);
 
 	/*byte 0 */
-	PR_INFO("  byte 0:tcp_chksum=%d ip_offset=%d\n",
+	pr_info("  byte 0:tcp_chksum=%d ip_offset=%d\n",
 		pmac->tcp_chksum, pmac->ip_offset);
 	/*byte 1 */
-	PR_INFO("  byte 1:tcp_h_offset=%d tcp_type=%d\n", pmac->tcp_h_offset,
+	pr_info("  byte 1:tcp_h_offset=%d tcp_type=%d\n", pmac->tcp_h_offset,
 		pmac->tcp_type);
 	/*byte 2 */
-	PR_INFO("  byte 2:igp_msb=%d res=%d\n", pmac->src_dst_subif_id_14_12,
+	pr_info("  byte 2:igp_msb=%d res=%d\n", pmac->src_dst_subif_id_14_12,
 		pmac->res2);
 	/*byte 3 */
-	PR_INFO("  byte 3:%s=%d %s=%d %s=%d %s=%d %s=%d %s=%d %s=%d\n",
+	pr_info("  byte 3:%s=%d %s=%d %s=%d %s=%d %s=%d %s=%d %s=%d\n",
 		"pkt_type", pmac->pkt_type, "ext", pmac->ext,
 		"ins", pmac->ins, "res3", pmac->res3,
 		"oam", pmac->oam, "lrnmd", pmac->lrnmd,
 		"class_en", pmac->class_en);
 	/*byte 4 */
-	PR_INFO("  byte 4:%s=%d ptp=%d one_step=%d src_dst_subif_id_msb=%d\n",
+	pr_info("  byte 4:%s=%d ptp=%d one_step=%d src_dst_subif_id_msb=%d\n",
 		"fcs_ins_dis", pmac->fcs_ins_dis,
 		pmac->ptp, pmac->one_step,
 		pmac->src_dst_subif_id_msb);
 	/*byte 5 */
-	PR_INFO("  byte 5:src_dst_subif_id_lsb=%d\n",
+	pr_info("  byte 5:src_dst_subif_id_lsb=%d\n",
 		pmac->src_dst_subif_id_lsb);
 	/*byte 6 */
-	PR_INFO("  byte 6:record_id_msb=%d\n", pmac->record_id_msb);
+	pr_info("  byte 6:record_id_msb=%d\n", pmac->record_id_msb);
 	/*byte 7 */
-	PR_INFO("  byte 7:record_id_lsb=%d igp_egp=%d\n", pmac->record_id_lsb,
+	pr_info("  byte 7:record_id_lsb=%d igp_egp=%d\n", pmac->record_id_lsb,
 		pmac->igp_egp);
 }
 
@@ -429,7 +429,7 @@ int alloc_q_to_port_32(struct ppv4_q_sch_port *info, u32 flag)
 	struct dp_subif_info *subif;
 
 	if (!priv) {
-		PR_ERR("why priv NULL ???\n");
+		pr_err("why priv NULL ???\n");
 		return -1;
 	}
 
@@ -441,7 +441,7 @@ int alloc_q_to_port_32(struct ppv4_q_sch_port *info, u32 flag)
 		port.inst = inst;
 		port.dp_port = info->dp_port;
 		if (dp_pp_alloc_port_32(&port)) {
-			PR_ERR("%s fail for deq_port=%d qos_deq_port=%d\n",
+			pr_err("%s fail for deq_port=%d qos_deq_port=%d\n",
 			       "dp_pp_alloc_port_32",
 			       port.cqm_deq_port, port.qos_deq_port);
 			return -1;
@@ -455,7 +455,7 @@ int alloc_q_to_port_32(struct ppv4_q_sch_port *info, u32 flag)
 	q.parent = port.node_id;
 	q.inst = inst;
 	if (dp_pp_alloc_queue_32(&q)) {
-		PR_ERR("%s fail\n",
+		pr_err("%s fail\n",
 		       "dp_pp_alloc_queue_32");
 		return -1;
 	}
@@ -487,7 +487,7 @@ int alloc_q_to_port_32(struct ppv4_q_sch_port *info, u32 flag)
 	link.prio_wfq = 0;
 
 	if (dp_node_link_add(&link, 0)) {
-		PR_ERR("dp_node_link_add_32 fail: cqm_deq_port=%d\n",
+		pr_err("dp_node_link_add_32 fail: cqm_deq_port=%d\n",
 		       info->cqe_deq);
 		return -1;
 	}
@@ -535,7 +535,7 @@ static int dp_gswip_remark_8P0D_set(int mode, int inst)
 	color_remark.nVal[14] = 13;
 	color_remark.nVal[15] = 15;
 	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
-		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -567,7 +567,7 @@ static int dp_gswip_remark_7P1D_set(int mode, int inst)
 	color_remark.nVal[14] = 13;
 	color_remark.nVal[15] = 15;
 	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
-		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -599,7 +599,7 @@ static int dp_gswip_remark_6P2D_set(int mode, int inst)
 	color_remark.nVal[14] = 13;
 	color_remark.nVal[15] = 15;
 	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
-		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -631,7 +631,7 @@ static int dp_gswip_remark_5P3D_set(int mode, int inst)
 	color_remark.nVal[14] = 13;
 	color_remark.nVal[15] = 15;
 	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
-		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -663,7 +663,7 @@ static int dp_gswip_remark_dscp_set(int mode, int inst)
 	color_remark.nVal[14] = 36;
 	color_remark.nVal[15] = 36;
 	if (gsw_qos->QOS_ColorReMarkingTableSet(gsw_handle, &color_remark)) {
-		PR_ERR("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_REMARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -807,7 +807,7 @@ static int dp_gswip_color_dscp_set(int mode, int inst)
 	color_mark.nColor[62] = GSW_DROP_PRECEDENCE_YELLOW;
 	color_mark.nColor[63] = GSW_DROP_PRECEDENCE_YELLOW;
 	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
-		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -855,7 +855,7 @@ static int dp_gswip_color_5P3D_set(int mode, int inst)
 	color_mark.nColor[14] = GSW_DROP_PRECEDENCE_GREEN;
 	color_mark.nColor[15] = GSW_DROP_PRECEDENCE_YELLOW;
 	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
-		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -903,7 +903,7 @@ static int dp_gswip_color_6P2D_set(int mode, int inst)
 	color_mark.nColor[14] = GSW_DROP_PRECEDENCE_GREEN;
 	color_mark.nColor[15] = GSW_DROP_PRECEDENCE_YELLOW;
 	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
-		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -951,7 +951,7 @@ static int dp_gswip_color_7P1D_set(int mode, int inst)
 	color_mark.nColor[14] = GSW_DROP_PRECEDENCE_GREEN;
 	color_mark.nColor[15] = GSW_DROP_PRECEDENCE_YELLOW;
 	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
-		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -999,7 +999,7 @@ static int dp_gswip_color_8P0D_set(int mode, int inst)
 	color_mark.nColor[14] = GSW_DROP_PRECEDENCE_GREEN;
 	color_mark.nColor[15] = GSW_DROP_PRECEDENCE_YELLOW;
 	if (gsw_qos->QOS_ColorMarkingTableSet(gsw_handle, &color_mark)) {
-		PR_ERR("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
+		pr_err("GSW_QOS_COLOR_MARKING_CFG_SET failed\n");
 		return -1;
 	}
 	return 0;
@@ -1043,12 +1043,12 @@ int dp_platform_queue_set_32(int inst, u32 flag)
 	struct cbm_tx_push *tx_push;
 
 	if (!cpu_assign) {
-		DP_ERR("cpu_assign NULL\n");
+		pr_err("cpu_assign NULL\n");
 		return 0;
 	}
 	port_info = get_dp_port_info(inst, CPU_PORT);
 	if ((flag & DP_PLATFORM_DE_INIT) == DP_PLATFORM_DE_INIT) {
-		PR_ERR("Need to free resoruce in the future\n");
+		pr_err("Need to free resoruce in the future\n");
 		return 0;
 	}
 
@@ -1057,13 +1057,13 @@ int dp_platform_queue_set_32(int inst, u32 flag)
 		q.parent = 0;
 		q.inst = inst;
 		if (dp_pp_alloc_queue_32(&q)) {
-			PR_ERR("%s fail to alloc a drop queue ??\n",
+			pr_err("%s fail to alloc a drop queue ??\n",
 			       "dp_pp_alloc_queue_32");
 			return -1;
 		}
 		priv->ppv4_drop_q = q.qid;
 	} else {
-		PR_INFO("drop queue/port: %d/%d\n", priv->ppv4_drop_q,
+		pr_info("drop queue/port: %d/%d\n", priv->ppv4_drop_q,
 			priv->cqm_drop_p);
 	}
 	/*Map all lookup entry to drop queue at the beginning*/
@@ -1116,14 +1116,14 @@ int dp_platform_queue_set_32(int inst, u32 flag)
 	cpu.cbm_inst = dp_port_prop[inst].cbm_inst;
 	ret = cbm_cpu_port_get(&cpu, 0);
 	if (ret == -1) {
-		PR_ERR("%s fail for CPU Port. Why ???\n",
+		pr_err("%s fail for CPU Port. Why ???\n",
 		       "cbm_cpu_port_get");
 		return -1;
 	}
 	gpid_base = alloc_gpid(inst, DP_DYN_GPID,
 			       CPU_GPID_NUM, CPU_PORT);
 	if (gpid_base == DP_FAILURE) {
-		DP_ERR("alloc_gpid fail for CPU: %d\n", CPU_PORT);
+		pr_err("alloc_gpid fail for CPU: %d\n", CPU_PORT);
 		return -1;
 	}
 	port_info->gpid_base = gpid_base;
@@ -1177,7 +1177,7 @@ int dp_platform_queue_set_32(int inst, u32 flag)
 			q_port.ctp = i;
 			DP_DEBUG(DP_DBG_FLAG_QOS, "alloc_q_to_port_32...\n");
 			if (alloc_q_to_port_32(&q_port, 0)) { /* q_port.qid */
-				PR_ERR("%s fail for dp_port=%d\n",
+				pr_err("%s fail for dp_port=%d\n",
 				       "alloc_q_to_port_32", q_port.dp_port);
 				return -1;
 			}
@@ -1193,7 +1193,7 @@ int dp_platform_queue_set_32(int inst, u32 flag)
 			subif_info->policy_num = cpu.policy_num[i][j];
 			if (dp_add_pp_gpid(inst, CPU_PORT, vap,
 					   gpid_base + vap, 0)) {
-				DP_ERR("dp_alloc_pp_gpid fail for CPU VAP=%d\n",
+				pr_err("dp_alloc_pp_gpid fail for CPU VAP=%d\n",
 				       vap);
 				return -1;
 			}
@@ -1236,7 +1236,7 @@ int dp_platform_queue_set_32(int inst, u32 flag)
 				hostif.qid = q_port.qid;
 				hostif.color = PP_COLOR_GREEN;
 				if (dp_add_dflt_hostif(&hostif, 0)) {
-					DP_ERR("%s fail for CPU VAP=%d\n",
+					pr_err("%s fail for CPU VAP=%d\n",
 					       "dp_add_dflt_hostif", vap);
 					return -1;
 				}
@@ -1249,13 +1249,13 @@ int dp_platform_queue_set_32(int inst, u32 flag)
 			en_data.dp_inst = inst;
 			en_data.deq_port = tx_push->deq_port;
 			if (cbm_dp_enable(NULL, PMAC_CPU_ID, &en_data, 0, 0)) {
-				PR_ERR("Fail to enable CPU[%d]\n",
+				pr_err("Fail to enable CPU[%d]\n",
 				       en_data.deq_port);
 				return -1;
 			}
 		}
 	}
-	DP_INFO("CPU VAP %d are enabled now\n", vap_num);
+	pr_info("CPU VAP %d are enabled now\n", vap_num);
 
 	return 0;
 }
@@ -1275,7 +1275,7 @@ static int dp_platform_set(int inst, u32 flag)
 		dp_port_prop[inst].priv_hal =
 			kzalloc(sizeof(*priv), GFP_KERNEL);
 		if (!dp_port_prop[inst].priv_hal) {
-			PR_ERR("kmalloc failed: %zu bytes\n",
+			pr_err("kmalloc failed: %zu bytes\n",
 			       sizeof(struct hal_priv));
 			return -1;
 		}
@@ -1287,7 +1287,7 @@ static int dp_platform_set(int inst, u32 flag)
 			init_dma_desc_mask();
 		if (!dp_port_prop[inst].ops[0] ||
 		    !dp_port_prop[inst].ops[1]) {
-			PR_ERR("Why GSWIP handle Zero\n");
+			pr_err("Why GSWIP handle Zero\n");
 			return -1;
 		}
 		if (!inst)
@@ -1315,35 +1315,35 @@ static int dp_platform_set(int inst, u32 flag)
 		/*disable egress VLAN modification for CPU port*/
 		port_remark.nPortId = 0;
 		if (qos->QoS_PortRemarkingCfgGet(gsw_handle, &port_remark)) {
-			PR_ERR("GSW_QOS_PORT_REMARKING_CFG_GET failed\n");
+			pr_err("GSW_QOS_PORT_REMARKING_CFG_GET failed\n");
 			return -1;
 		}
 		port_remark.bPCP_EgressRemarkingEnable = 0;
 		if (qos->QoS_PortRemarkingCfgGet(gsw_handle, &port_remark)) {
-			PR_ERR("GSW_QOS_PORT_REMARKING_CFG_GET failed\n");
+			pr_err("GSW_QOS_PORT_REMARKING_CFG_GET failed\n");
 			return -1;
 		}
 
 		if (init_ppv4_qos_32(inst, flag)) {
-			PR_ERR("init_ppv4_qos_32 fail\n");
+			pr_err("init_ppv4_qos_32 fail\n");
 			return -1;
 		}
 		if (dp_platform_queue_set_32(inst, flag)) {
-			PR_ERR("dp_platform_queue_set_32 fail\n");
+			pr_err("dp_platform_queue_set_32 fail\n");
 
 			return -1;
 		}
 		if (dp_platform_color_table_set(inst)) {
-			PR_ERR("dp_platform_color_table_set fail\n");
+			pr_err("dp_platform_color_table_set fail\n");
 
 			return -1;
 		}
 		if (cpu_vlan_mod_dis_32(inst)) {
-			PR_ERR("cpu_vlan_mod_dis_32 fail\n");
+			pr_err("cpu_vlan_mod_dis_32 fail\n");
 			return -1;
 		}
 		if (dp_tx_init_32(inst)) {
-			PR_ERR("dp_tx_init_32 fail\n");
+			pr_err("dp_tx_init_32 fail\n");
 			return -1;
 		}
 		return 0;
@@ -1378,7 +1378,7 @@ static int pon_config(int inst, int ep, struct dp_port_data *data, u32 flags)
 	memset((void *)&cpu_port_cfg, 0x00, sizeof(cpu_port_cfg));
 	ret = gsw_com->CPU_PortCfgGet(gsw_handle, &cpu_port_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("fail in getting CPU port config\r\n");
+		pr_err("fail in getting CPU port config\r\n");
 		return -1;
 	}
 	/* Enable the Egress and Ingress Special Tag */
@@ -1387,7 +1387,7 @@ static int pon_config(int inst, int ep, struct dp_port_data *data, u32 flags)
 	cpu_port_cfg.bSpecialTagEgress = 1;
 	ret = gsw_com->CPU_PortCfgSet(gsw_handle, &cpu_port_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Fail in configuring CPU port\n");
+		pr_err("Fail in configuring CPU port\n");
 		return -1;
 	}
 
@@ -1427,11 +1427,11 @@ static int dev_platform_set(int inst, u8 ep, struct dp_dev_data *data,
 	struct hal_priv *priv = (struct hal_priv *)dp_port_prop[inst].priv_hal;
 
 	if (!priv) {
-		PR_ERR("priv is NULL\n");
+		pr_err("priv is NULL\n");
 		return DP_FAILURE;
 	}
 	if (flags & DP_F_DEREGISTER) {
-		DP_INFO("Need implement in the future\n");
+		pr_info("Need implement in the future\n");
 		return DP_SUCCESS;
 	}
 
@@ -1439,7 +1439,7 @@ static int dev_platform_set(int inst, u8 ep, struct dp_dev_data *data,
 	itf = ctp_port_assign_32(inst, ep, priv->bp_def, flags, data);
 	get_dp_port_info(inst, ep)->itf_info = itf;
 	if (gpid_port_assign(inst, ep, flags)) {
-		DP_ERR("gpid_port_assign failed\n");
+		pr_err("gpid_port_assign failed\n");
 		return DP_FAILURE;
 	}
 
@@ -1457,7 +1457,7 @@ static int port_platform_set(int inst, u8 ep, struct dp_port_data *data,
 	u32 dma_chan, dma_ch_base;
 
 	if (!priv) {
-		PR_ERR("priv is NULL\n");
+		pr_err("priv is NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -1511,7 +1511,7 @@ static int port_platform_set(int inst, u8 ep, struct dp_port_data *data,
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_DBG)
 	if (DP_DBG_FLAG_QOS & dp_dbg_flag) {
 		for (i = 0; i < port_info->deq_port_num; i++) {
-			PR_INFO("cqm[%d]: %s/%s=%px/%px credit=%d size=%d\n",
+			pr_info("cqm[%d]: %s/%s=%px/%px credit=%d size=%d\n",
 				i + idx, "addr", "push",
 				dp_deq_port_tbl[inst][i + idx].txpush_addr,
 				dp_deq_port_tbl[inst][i + idx].txpush_addr_qos,
@@ -1535,7 +1535,7 @@ static int set_ctp_bp(int inst, int ctp, int portid, int bp)
 	tmp.eMask = GSW_CTP_PORT_CONFIG_MASK_BRIDGE_PORT_ID;
 	tmp.nBridgePortId = bp;
 	if (gsw_handle->gsw_ctp_ops.CTP_PortConfigSet(gsw_handle, &tmp)) {
-		PR_ERR("Failed to CTP(%d)'s bridge port=%d for ep=%d\n",
+		pr_err("Failed to CTP(%d)'s bridge port=%d for ep=%d\n",
 		       ctp, bp, portid);
 		return -1;
 	}
@@ -1554,7 +1554,7 @@ static int reset_ctp_bp(int inst, int ctp, int portid, int bp)
 	tmp.nSubIfIdGroup = ctp;
 	tmp.nBridgePortId = bp;
 	if (gsw_handle->gsw_ctp_ops.CTP_PortConfigReset(gsw_handle, &tmp)) {
-		PR_ERR("Failed to reset CTP(%d)'s bridge port=%d for ep=%d\n",
+		pr_err("Failed to reset CTP(%d)'s bridge port=%d for ep=%d\n",
 		       ctp, bp, portid);
 		return -1;
 	}
@@ -1592,11 +1592,11 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 	struct dp_subif_info *sif;
 
 	if (!data || !data->subif_data) {
-		PR_ERR("data NULL or subif_data NULL\n");
+		pr_err("data NULL or subif_data NULL\n");
 		return -1;
 	}
 	if (!dp_dma_chan_tbl[inst]) {
-		PR_ERR("dp_dma_chan_tbl[%d] NULL\n", inst);
+		pr_err("dp_dma_chan_tbl[%d] NULL\n", inst);
 		return DP_FAILURE;
 	}
 	port_info = get_dp_port_info(inst, portid);
@@ -1620,7 +1620,7 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 		bp = alloc_bridge_port_32(inst, portid,
 					  subif_ix, CPU_FID, CPU_BP);
 		if (bp < 0) {
-			PR_ERR("Fail to alloc bridge port\n");
+			pr_err("Fail to alloc bridge port\n");
 			return -1;
 		}
 	}
@@ -1629,7 +1629,7 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 		   sif->bp);
 	data->act = 0;
 	if (flags & DP_F_SUBIF_LOGICAL) {
-		PR_ERR("need more for logical dev??\n");
+		pr_err("need more for logical dev??\n");
 		return 0;
 	}
 	if (data->subif_data->ctp_dev) {
@@ -1651,14 +1651,14 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 	if (data->subif_data)
 		deq_port_idx = data->subif_data->deq_port_idx;
 	if (port_info->deq_port_num < deq_port_idx + 1) {
-		PR_ERR("Wrong deq_port_idx(%d), should < %d\n",
+		pr_err("Wrong deq_port_idx(%d), should < %d\n",
 		       deq_port_idx, port_info->deq_port_num);
 		return -1;
 	}
 	/*QUEUE_CFG if needed */
 	q_port.cqe_deq = port_info->deq_port_base + deq_port_idx;
 	if (!priv) {
-		PR_ERR("priv NULL\n");
+		pr_err("priv NULL\n");
 		return -1;
 	}
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_DBG)
@@ -1699,18 +1699,18 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 		int cqe_deq;
 
 		if (alloc_q_to_port_32(&q_port, 0)) {
-			PR_ERR("alloc_q_to_port_32 fail for dp_port=%d\n",
+			pr_err("alloc_q_to_port_32 fail for dp_port=%d\n",
 			       q_port.dp_port);
 			return -1;
 		}
 		if (dp_q_tbl[inst][q_port.qid].flag) {
-			PR_ERR("Why dp_q_tbl[%d][%d].flag =%d:expect 0?\n",
+			pr_err("Why dp_q_tbl[%d][%d].flag =%d:expect 0?\n",
 			       inst, q_port.qid,
 			       dp_q_tbl[inst][q_port.qid].flag);
 			return -1;
 		}
 		if (dp_q_tbl[inst][q_port.qid].ref_cnt) {
-			PR_ERR("Why dp_q_tbl[%d][%d].ref_cnt =%d:expect 0?\n",
+			pr_err("Why dp_q_tbl[%d][%d].ref_cnt =%d:expect 0?\n",
 			       inst, q_port.qid,
 			       dp_q_tbl[inst][q_port.qid].ref_cnt);
 			return -1;
@@ -1826,7 +1826,7 @@ static int subif_hw_set(int inst, int portid, int subif_ix,
 	sif->policy_num = port_info->policy_num;
 	sif->policy_base = port_info->policy_base;
 	if (dp_subif_pp_set(inst, portid, subif_ix, data, flags)) {
-		DP_ERR("dp_subif_pp_set fail for dpid/vap=%d/%d\n",
+		pr_err("dp_subif_pp_set fail for dpid/vap=%d/%d\n",
 		       portid, subif_ix);
 	}
 	if (subif_ix < port_info->gpid_num)
@@ -1893,24 +1893,24 @@ static int subif_hw_reset(int inst, int portid, int subif_ix,
 	bp = sif->bp;
 
 	if (!dp_dma_chan_tbl[inst]) {
-		PR_ERR("dp_dma_chan_tbl[%d] NULL\n", inst);
+		pr_err("dp_dma_chan_tbl[%d] NULL\n", inst);
 		return DP_FAILURE;
 	}
 
 	/* santity check table */
 	if (!dp_q_tbl[inst][qid].ref_cnt) {
-		PR_ERR("Why dp_q_tbl[%d][%d].ref_cnt Zero: expect > 0\n",
+		pr_err("Why dp_q_tbl[%d][%d].ref_cnt Zero: expect > 0\n",
 		       inst, qid);
 		return DP_FAILURE;
 	}
 	if (!dp_deq_port_tbl[inst][cqm_deq_port].ref_cnt) {
-		PR_ERR("Why dp_deq_port_tbl[%d][%d].ref_cnt Zero\n",
+		pr_err("Why dp_deq_port_tbl[%d][%d].ref_cnt Zero\n",
 		       inst, cqm_deq_port);
 		return DP_FAILURE;
 	}
 	if ((sif->ctp_dev) &&
 	    !dp_bp_dev_tbl[inst][bp].ref_cnt) {
-		PR_ERR("Why dp_bp_dev_tbl[%d][%d].ref_cnt =%d\n",
+		pr_err("Why dp_bp_dev_tbl[%d][%d].ref_cnt =%d\n",
 		       inst, bp, dp_bp_dev_tbl[inst][bp].ref_cnt);
 		return DP_FAILURE;
 	}
@@ -1980,7 +1980,7 @@ static int subif_hw_reset(int inst, int portid, int subif_ix,
 
 	if (!port_info->num_subif &&
 	    dp_deq_port_tbl[inst][cqm_deq_port].ref_cnt) {
-		PR_ERR("num_subif(%d) not match dp_deq_port[%d][%d].ref_cnt\n",
+		pr_err("num_subif(%d) not match dp_deq_port[%d][%d].ref_cnt\n",
 		       port_info->num_subif,
 		       inst, cqm_deq_port);
 		return DP_FAILURE;
@@ -2029,11 +2029,11 @@ static int dp_ctp_tc_map_set_32(struct dp_tc_cfg *tc, int flag,
 	memset(&ctp_tc_cfg, 0, sizeof(ctp_tc_cfg));
 
 	if (!mtr_subif) {
-		PR_ERR("mtr_subif struct NULL\n");
+		pr_err("mtr_subif struct NULL\n");
 		return -1;
 	}
 	if (mtr_subif->subif.flag_pmapper) {
-		PR_ERR("Cannot support ctp tc set for pmmapper dev(%s)\n",
+		pr_err("Cannot support ctp tc set for pmmapper dev(%s)\n",
 		       tc->dev ? tc->dev->name : "NULL");
 		return -1;
 	}
@@ -2042,7 +2042,7 @@ static int dp_ctp_tc_map_set_32(struct dp_tc_cfg *tc, int flag,
 	ctp_tc_cfg.nLogicalPortId = mtr_subif->subif.port_id;
 	ctp_tc_cfg.nSubIfIdGroup = mtr_subif->subif.subif;
 	if (gsw_ctp->CTP_PortConfigGet(gsw_handle, &ctp_tc_cfg)) {
-		PR_ERR("Failed to get CTP info for ep=%d subif=%d\n",
+		pr_err("Failed to get CTP info for ep=%d subif=%d\n",
 		       mtr_subif->subif.port_id, mtr_subif->subif.subif);
 		return -1;
 	}
@@ -2054,7 +2054,7 @@ static int dp_ctp_tc_map_set_32(struct dp_tc_cfg *tc, int flag,
 		ctp_tc_cfg.bForcedTrafficClass = 0;
 
 	if (gsw_ctp->CTP_PortConfigSet(gsw_handle, &ctp_tc_cfg)) {
-		PR_ERR("CTP tc set fail for ep=%d subif=%d tc=%d force=%d\n",
+		pr_err("CTP tc set fail for ep=%d subif=%d tc=%d force=%d\n",
 		       mtr_subif->subif.port_id, mtr_subif->subif.subif,
 		       tc->tc, tc->force);
 		return -1;
@@ -2100,7 +2100,7 @@ static void update_port_vap(int inst, u32 *ep, int *vap,
 			get_pmac_subif(pmac, &subif);
 			*ep = GET_VAP(subif, pi->vap_offset, pi->vap_mask);
 		} else {
-			PR_ERR("Pmac Header is not present\n");
+			pr_err("Pmac Header is not present\n");
 		}
 		*vap = 0;
 		*decryp = 1;
@@ -2224,7 +2224,7 @@ int register_dp_cap_gswip32(int flag)
 	cap.info.cap.max_num_bridge_port = 128;
 
 	if (register_dp_hw_cap(&cap, flag)) {
-		PR_ERR("Why register_dp_hw_cap fail\n");
+		pr_err("Why register_dp_hw_cap fail\n");
 		return -1;
 	}
 
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_ppv4.c b/drivers/net/datapath/dpm/gswip32/datapath_ppv4.c
index c0293bff4960..286fcb18e9f0 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_ppv4.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_ppv4.c
@@ -85,7 +85,7 @@ int dp_pp_alloc_port_32(struct ppv4_port *info)
 	if (qos_port_allocate_32(qos_dev,
 				 info->cqm_deq_port,
 				 &qos_p_id)) {
-		PR_ERR("Failed to alloc QoS for deq_port=%d\n",
+		pr_err("Failed to alloc QoS for deq_port=%d\n",
 		       info->cqm_deq_port);
 		return -1;
 	}
@@ -118,7 +118,7 @@ int dp_pp_alloc_port_32(struct ppv4_port *info)
 	}
 #endif
 	if (qos_port_set_32(qos_dev, qos_p_id, &conf)) {
-		PR_ERR("qos_port_set_32 fail for port(cqm/qos) %d/%d\n",
+		pr_err("qos_port_set_32 fail for port(cqm/qos) %d/%d\n",
 		       info->cqm_deq_port, qos_p_id);
 		qos_port_remove_32(qos_dev, qos_p_id);
 		return -1;
@@ -142,7 +142,7 @@ int dp_pp_alloc_queue_32(struct ppv4_queue *info)
 	struct pp_qos_dev *qos_dev = priv->qdev;
 
 	if (qos_queue_allocate_32(qos_dev, &q_node_id)) {
-		PR_ERR("qos_queue_allocate_32 fail\n");
+		pr_err("qos_queue_allocate_32 fail\n");
 		return -1;
 	}
 	DP_DEBUG(DP_DBG_FLAG_QOS, "qos_queue_allocate_32 ok q_node=%d\n",
@@ -153,14 +153,14 @@ int dp_pp_alloc_queue_32(struct ppv4_queue *info)
 	conf.wred_max_allowed = 0x400; /*max qocc in pkt */
 	conf.queue_child_prop.parent = info->parent;
 	if (qos_queue_set_32(qos_dev, q_node_id, &conf)) {
-		PR_ERR("qos_queue_set_32 fail for node_id=%d to parent=%d\n",
+		pr_err("qos_queue_set_32 fail for node_id=%d to parent=%d\n",
 		       q_node_id, info->parent);
 		return -1;
 	}
 	DP_DEBUG(DP_DBG_FLAG_QOS, "To attach q_node=%d to parent_node=%d\n",
 		 q_node_id, conf.queue_child_prop.parent);
 	if (qos_queue_info_get_32(qos_dev, q_node_id, &q_info)) {
-		PR_ERR("qos_queue_info_get_32 fail for queue node_id=%d\n",
+		pr_err("qos_queue_info_get_32 fail for queue node_id=%d\n",
 		       q_node_id);
 		return -1;
 	}
@@ -188,7 +188,7 @@ int init_ppv4_qos_32(int inst, int flag)
 	struct cbm_cpu_port_data cpu_data = {0};
 #endif
 	if (!priv) {
-		PR_ERR("priv is NULL\n");
+		pr_err("priv is NULL\n");
 		return DP_FAILURE;
 	}
 	if (!(flag & DP_PLATFORM_INIT)) {
@@ -198,25 +198,25 @@ int init_ppv4_qos_32(int inst, int flag)
 	}
 	priv->qdev = qos_dev_open_32(dp_port_prop[inst].qos_inst);
 	if (!priv->qdev) {
-		PR_ERR("Could not open qos instance %d\n",
+		pr_err("Could not open qos instance %d\n",
 		       dp_port_prop[inst].qos_inst);
 		return DP_FAILURE;
 	}
-	PR_INFO("qos_dev_open_32 qdev=%px\n", priv->qdev);
+	pr_info("qos_dev_open_32 qdev=%px\n", priv->qdev);
 	t = kzalloc(sizeof(*t), GFP_ATOMIC);
 	if (!t) {
-		PR_ERR("kzalloc fail: %zd bytes\n", sizeof(*t));
+		pr_err("kzalloc fail: %zd bytes\n", sizeof(*t));
 		return DP_FAILURE;
 	}
 	if (cbm_cpu_port_get(&cpu_data, 0)) {
-		PR_ERR("cbm_cpu_port_get for CPU port?\n");
+		pr_err("cbm_cpu_port_get for CPU port?\n");
 		goto EXIT;
 	}
 	/* Sotre drop/flush port's info */
 	flush_port = &cpu_data.dq_tx_flush_info;
 	idx = flush_port->deq_port;
 	if ((idx == 0) || (idx >= ARRAY_SIZE(dp_deq_port_tbl[inst]))) {
-		PR_ERR("Wrog DP Flush port[%d]\n", idx);
+		pr_err("Wrog DP Flush port[%d]\n", idx);
 		goto EXIT;
 	}
 	priv->cqm_drop_p = idx;
@@ -240,7 +240,7 @@ int init_ppv4_qos_32(int inst, int flag)
 	if (qos_port_allocate_32(priv->qdev,
 				 priv->cqm_drop_p,
 				 &priv->ppv4_drop_p)) {
-		PR_ERR("Failed to alloc  qos drop port=%d\n",
+		pr_err("Failed to alloc  qos drop port=%d\n",
 		       priv->cqm_drop_p);
 		goto EXIT;
 	}
@@ -273,14 +273,14 @@ int init_ppv4_qos_32(int inst, int flag)
 	}
 #endif
 	if (qos_port_set_32(priv->qdev, priv->ppv4_drop_p, &t->p_conf)) {
-		PR_ERR("qos_port_set_32 fail for port(cqm/qos) %d/%d\n",
+		pr_err("qos_port_set_32 fail for port(cqm/qos) %d/%d\n",
 		       priv->cqm_drop_p, priv->ppv4_drop_p);
 		qos_port_remove_32(priv->qdev, priv->ppv4_drop_p);
 		goto EXIT;
 	}
 
 	if (qos_queue_allocate_32(priv->qdev, &q)) {
-		PR_ERR("qos_queue_allocate_32 fail\n");
+		pr_err("qos_queue_allocate_32 fail\n");
 		qos_port_remove_32(priv->qdev, q);
 		goto EXIT;
 	}
@@ -292,14 +292,14 @@ int init_ppv4_qos_32(int inst, int flag)
 	t->q_conf.wred_max_allowed = 0; /*max qocc in pkt */
 	t->q_conf.queue_child_prop.parent = priv->ppv4_drop_p;
 	if (qos_queue_set_32(priv->qdev, q, &t->q_conf)) {
-		PR_ERR("qos_queue_set_32 fail for node_id=%d to parent=%d\n",
+		pr_err("qos_queue_set_32 fail for node_id=%d to parent=%d\n",
 		       q, t->q_conf.queue_child_prop.parent);
 		goto EXIT;
 	}
 	DP_DEBUG(DP_DBG_FLAG_QOS, "To attach q_node=%d to parent_node=%d\n",
 		 q, priv->ppv4_drop_p);
 	if (qos_queue_info_get_32(priv->qdev, q, &t->q_info)) {
-		PR_ERR("qos_queue_info_get_32 fail for queue node_id=%d\n",
+		pr_err("qos_queue_info_get_32 fail for queue node_id=%d\n",
 		       q);
 		goto EXIT;
 	}
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c b/drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c
index 6092e4f20236..926c9c0bd102 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_ppv4_api.c
@@ -69,7 +69,7 @@ int qos_platform_set_32(int cmd_id, void *node, int flag)
 	inst = node_link->inst;
 	priv = HAL(inst);
 	if (!priv->qdev) {
-		PR_ERR("qdev NULL with inst=%d\n", inst);
+		pr_err("qdev NULL with inst=%d\n", inst);
 		return DP_FAILURE;
 	}
 
@@ -168,7 +168,7 @@ int qos_platform_set_32(int cmd_id, void *node, int flag)
 					      flag);
 		break;
 	default:
-		PR_ERR("no support yet cmd_id %d\n", cmd_id);
+		pr_err("no support yet cmd_id %d\n", cmd_id);
 		break;
 	}
 	return res;
@@ -181,12 +181,12 @@ static int limit_pp2dp(u32 pp_limit, u32 *dp_limit)
 	int i;
 
 	if (!dp_limit) {
-		PR_ERR("dp_limit is NULL!\n");
+		pr_err("dp_limit is NULL!\n");
 		return DP_FAILURE;
 	}
 
 	if (pp_limit > QOS_MAX_BANDWIDTH_LIMIT) {
-		PR_ERR("Wrong pp shaper limit: %u\n", pp_limit);
+		pr_err("Wrong pp shaper limit: %u\n", pp_limit);
 		return DP_FAILURE;
 	}
 
@@ -199,7 +199,7 @@ static int limit_pp2dp(u32 pp_limit, u32 *dp_limit)
 	*dp_limit = pp_limit * MBPS_2_KBPS;/* mbps to kbps */
 
 	if ((*dp_limit <= 0) || (*dp_limit > DP_MAX_SHAPER_LIMIT)) {
-		PR_ERR("Wrong dp shaper limit: %u\n", *dp_limit);
+		pr_err("Wrong dp shaper limit: %u\n", *dp_limit);
 		return DP_FAILURE;
 	}
 	return DP_SUCCESS;
@@ -211,12 +211,12 @@ static int limit_dp2pp(u32 dp_limit, u32 *pp_limit)
 	int i;
 
 	if (!pp_limit) {
-		PR_ERR("pp_limit is NULL!\n");
+		pr_err("pp_limit is NULL!\n");
 		return DP_FAILURE;
 	}
 
 	if ((dp_limit > DP_MAX_SHAPER_LIMIT) || (dp_limit == 0)) {
-		PR_ERR("Wrong dp shaper limit: %u\n", dp_limit);
+		pr_err("Wrong dp shaper limit: %u\n", dp_limit);
 		return DP_FAILURE;
 	}
 
@@ -233,7 +233,7 @@ static int limit_dp2pp(u32 dp_limit, u32 *pp_limit)
 		*pp_limit = dp_limit / MBPS_2_KBPS;
 
 	if (*pp_limit > QOS_MAX_BANDWIDTH_LIMIT) {
-		PR_ERR("Wrong dp shaper limit: %u\n", *pp_limit);
+		pr_err("Wrong dp shaper limit: %u\n", *pp_limit);
 		return DP_FAILURE;
 	}
 	return DP_SUCCESS;
@@ -260,7 +260,7 @@ int arbi_dp2pp_32(int dp_arbi)
 		if (arbi_maps[i].dp_arbi == dp_arbi)
 			return arbi_maps[i].pp_arbi;
 	}
-	PR_ERR("Wrong dp_arbitrate: %d\n", dp_arbi);
+	pr_err("Wrong dp_arbitrate: %d\n", dp_arbi);
 	return DP_FAILURE;
 }
 
@@ -336,12 +336,12 @@ static int queue_flush_32(int inst, int node_id, int flag)
 	struct cbm_lookup info = {0};
 
 	if (qid < 0) {
-		PR_ERR("no physical qid for q_node=%d\n", node_id);
+		pr_err("no physical qid for q_node=%d\n", node_id);
 		res = DP_FAILURE;
 		goto EXIT;
 	}
 	if (qos_queue_conf_get_32(priv->qdev, node_id, &queue_cfg)) {
-		PR_ERR("qos_queue_conf_get_32 fail: q[%d/%d]\n",
+		pr_err("qos_queue_conf_get_32 fail: q[%d/%d]\n",
 		       qid, node_id);
 		res = DP_FAILURE;
 		goto EXIT;
@@ -349,19 +349,19 @@ static int queue_flush_32(int inst, int node_id, int flag)
 	lookup = kzalloc(sizeof(*lookup), GFP_ATOMIC);
 	if (!lookup) {
 		res = DP_FAILURE;
-		PR_ERR("kmalloc fail to alloc %zd bytes\n", sizeof(*lookup));
+		pr_err("kmalloc fail to alloc %zd bytes\n", sizeof(*lookup));
 		goto EXIT;
 	}
 	/* map to drop queue and save the changed lookup entries for recover */
 	if (dp_map_to_drop_q_32(inst, qid, lookup)) {
-		PR_ERR("failed to dp_map_to_drop_q_32 for Q:%d\n", qid);
+		pr_err("failed to dp_map_to_drop_q_32 for Q:%d\n", qid);
 		res = DP_FAILURE;
 		goto EXIT;
 	}
 	/* block/disable: ensure to drop all coming enqueue packet */
 	if (queue_cfg.blocked == 0) { /* to block */
 		if (pp_qos_queue_block(priv->qdev, node_id)) {
-			PR_ERR("pp_qos_queue_block fail: q[%d/%d]\n",
+			pr_err("pp_qos_queue_block fail: q[%d/%d]\n",
 			       qid, node_id);
 			res = DP_FAILURE;
 			goto EXIT;
@@ -399,7 +399,7 @@ static int queue_flush_32(int inst, int node_id, int flag)
 		dp_wred_def(&tmp_q_cfg);
 		tmp_q_cfg.queue_child_prop.parent = priv->ppv4_drop_p;
 		if (qos_queue_set_32(priv->qdev, node_id, &tmp_q_cfg)) {
-			PR_ERR(
+			pr_err(
 			    "qos_queue_set_32 fail for queue=%d to parent=%d\n",
 			    qid, tmp_q_cfg.queue_child_prop.parent);
 			goto EXIT;
@@ -414,7 +414,7 @@ static int queue_flush_32(int inst, int node_id, int flag)
 #ifdef DP_FLUSH_SUSPEND_Q
 		/* set to suspend again before move back to original parent */
 		if (pp_qos_queue_suspend(priv->qdev, node_id)) {
-			PR_ERR("pp_qos_queue_suspend fail q[%d] to parent=%d\n",
+			pr_err("pp_qos_queue_suspend fail q[%d] to parent=%d\n",
 			       qid, tmp_q_cfg.queue_child_prop.parent);
 			goto EXIT;
 		}
@@ -425,7 +425,7 @@ static int queue_flush_32(int inst, int node_id, int flag)
 		 * with orignal variable queue_cfg
 		 */
 		if (qos_queue_set_32(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("qos_queue_conf_get_32 fail: q[%d/%d]\n",
+			pr_err("qos_queue_conf_get_32 fail: q[%d/%d]\n",
 			       qid, node_id);
 			res = DP_FAILURE;
 			goto EXIT;
@@ -438,7 +438,7 @@ static int queue_flush_32(int inst, int node_id, int flag)
 
 #ifdef DP_FLUSH_SUSPEND_Q
 	if (pp_qos_queue_suspend(priv->qdev, node_id)) {
-		PR_ERR("qos_queue_set_32 fail\n");
+		pr_err("qos_queue_set_32 fail\n");
 		goto EXIT;
 	}
 	DP_DEBUG(DP_DBG_FLAG_QOS,
@@ -538,26 +538,26 @@ static int node_queue_dec(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	phy_id = get_qid_by_node(inst, node_id, flag);
 	if (phy_id == DP_FAILURE) {
-		PR_ERR("get_qid_by_node failed\n");
+		pr_err("get_qid_by_node failed\n");
 		return DP_FAILURE;
 	}
 
 	pid = get_parent_node(inst, node_id, flag);
 	if (pid == DP_FAILURE) {
-		PR_ERR("get_parent_node failed for Q:%d\n", phy_id);
+		pr_err("get_parent_node failed for Q:%d\n", phy_id);
 		return DP_FAILURE;
 	}
 	DP_DEBUG(DP_DBG_FLAG_QOS, "parent:%d of Q:%d\n", pid, phy_id);
 
 	idx = get_child_idx_node_id(inst, node_id, 0);
 	if (idx == DP_FAILURE) {
-		PR_ERR("get_child_idx_node_id failed for Q:%d\n", phy_id);
+		pr_err("get_child_idx_node_id failed for Q:%d\n", phy_id);
 		return DP_FAILURE;
 	}
 	DP_DEBUG(DP_DBG_FLAG_QOS,
@@ -565,12 +565,12 @@ static int node_queue_dec(int inst, int node_id, int flag)
 		 pid, phy_id, node_id, idx);
 
 	if (!(priv->qos_queue_stat[phy_id].flag & PP_NODE_ACTIVE)) {
-		PR_ERR("Wrong Q[%d] Stat(%d):Expect ACTIVE\n", phy_id,
+		pr_err("Wrong Q[%d] Stat(%d):Expect ACTIVE\n", phy_id,
 		       priv->qos_queue_stat[phy_id].flag);
 		return DP_FAILURE;
 	}
 	if (!priv->qos_sch_stat[node_id].parent.flag) {
-		PR_ERR("Wrong Q[%d]'s Parent Stat(%d):Expect ACTIVE\n",
+		pr_err("Wrong Q[%d]'s Parent Stat(%d):Expect ACTIVE\n",
 		       node_id, priv->qos_sch_stat[node_id].parent.flag);
 		return DP_FAILURE;
 	}
@@ -599,26 +599,26 @@ static int node_queue_inc(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	phy_id = get_qid_by_node(inst, node_id, flag);
 	if (phy_id == DP_FAILURE) {
-		PR_ERR("get_qid_by_node failed\n");
+		pr_err("get_qid_by_node failed\n");
 		return DP_FAILURE;
 	}
 
 	pid = get_parent_node(inst, node_id, flag);
 	if (pid == DP_FAILURE) {
-		PR_ERR("get_parent_node failed for Q:%d\n", phy_id);
+		pr_err("get_parent_node failed for Q:%d\n", phy_id);
 		return DP_FAILURE;
 	}
 	DP_DEBUG(DP_DBG_FLAG_QOS, "parent:%d of Q:%d\n", pid, phy_id);
 
 	idx = get_free_child_idx(inst, pid, 0);
 	if (idx == DP_FAILURE) {
-		PR_ERR("get_free_child_idx failed for Q:%d\n", phy_id);
+		pr_err("get_free_child_idx failed for Q:%d\n", phy_id);
 		return DP_FAILURE;
 	}
 	DP_DEBUG(DP_DBG_FLAG_QOS,
@@ -626,7 +626,7 @@ static int node_queue_inc(int inst, int node_id, int flag)
 		 pid, phy_id, node_id, idx);
 
 	if (!(priv->qos_queue_stat[phy_id].flag & PP_NODE_ALLOC)) {
-		PR_ERR("Wrong Q[%d] Stat(%d):Expect ALLOC\n", phy_id,
+		pr_err("Wrong Q[%d] Stat(%d):Expect ALLOC\n", phy_id,
 		       priv->qos_queue_stat[phy_id].flag);
 		return DP_FAILURE;
 	}
@@ -658,12 +658,12 @@ static int node_queue_rst(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (phy_id == DP_FAILURE) {
-		PR_ERR("get_qid_by_node failed\n");
+		pr_err("get_qid_by_node failed\n");
 		return DP_FAILURE;
 	}
 	dp_port = priv->qos_queue_stat[phy_id].dp_port;
@@ -674,7 +674,7 @@ static int node_queue_rst(int inst, int node_id, int flag)
 		 phy_id, node_id, resv_idx);
 
 	if (!(priv->qos_queue_stat[phy_id].flag & PP_NODE_ALLOC)) {
-		PR_ERR("Wrong Q[%d] Stat(%d):Expect ALLOC\n", phy_id,
+		pr_err("Wrong Q[%d] Stat(%d):Expect ALLOC\n", phy_id,
 		       priv->qos_queue_stat[phy_id].flag);
 		return DP_FAILURE;
 	}
@@ -711,7 +711,7 @@ static int node_sched_dec(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -721,7 +721,7 @@ static int node_sched_dec(int inst, int node_id, int flag)
 
 		if (!priv->qos_sch_stat[node_id].child_num ||
 		    !(priv->qos_sch_stat[node_id].c_flag & PP_NODE_ACTIVE)) {
-			PR_ERR("Wrong Sch[%d] Stat(%d)/child_num(%d):%s\n",
+			pr_err("Wrong Sch[%d] Stat(%d)/child_num(%d):%s\n",
 			       node_id, priv->qos_sch_stat[node_id].c_flag,
 			       priv->qos_sch_stat[node_id].child_num,
 			       "Expect ACTIVE Or non-zero child_num");
@@ -734,14 +734,14 @@ static int node_sched_dec(int inst, int node_id, int flag)
 	} else if (flag & P_FLAG) {
 		pid = get_parent_node(inst, node_id, flag);
 		if (pid == DP_FAILURE) {
-			PR_ERR("get_parent_node failed for sched:%d\n",
+			pr_err("get_parent_node failed for sched:%d\n",
 			       node_id);
 			return DP_FAILURE;
 		}
 
 		idx = get_child_idx_node_id(inst, node_id, flag);
 		if (idx == DP_FAILURE) {
-			PR_ERR("get_child_idx_node_id failed for sched:%d\n",
+			pr_err("get_child_idx_node_id failed for sched:%d\n",
 			       node_id);
 			return DP_FAILURE;
 		}
@@ -751,12 +751,12 @@ static int node_sched_dec(int inst, int node_id, int flag)
 			 pid, node_id, idx);
 
 		if (!(priv->qos_sch_stat[node_id].p_flag & PP_NODE_ACTIVE)) {
-			PR_ERR("Wrong Sch[%d] Stat(%d):Expect ACTIVE\n",
+			pr_err("Wrong Sch[%d] Stat(%d):Expect ACTIVE\n",
 			       node_id, priv->qos_sch_stat[node_id].p_flag);
 			return DP_FAILURE;
 		}
 		if (!priv->qos_sch_stat[node_id].parent.flag) {
-			PR_ERR("Wrong SCH[%d] Parent Stat(%d):Expect ACTIV\n",
+			pr_err("Wrong SCH[%d] Parent Stat(%d):Expect ACTIV\n",
 			       node_id,
 			       priv->qos_sch_stat[node_id].parent.flag);
 			return DP_FAILURE;
@@ -787,7 +787,7 @@ static int node_sched_inc(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -797,7 +797,7 @@ static int node_sched_inc(int inst, int node_id, int flag)
 
 		if (priv->qos_sch_stat[node_id].child_num &&
 		    !(priv->qos_sch_stat[node_id].c_flag & PP_NODE_ACTIVE)) {
-			PR_ERR("Wrong Sch[%d] Stat(%d)/child_num(%d):%s\n",
+			pr_err("Wrong Sch[%d] Stat(%d)/child_num(%d):%s\n",
 			       node_id, priv->qos_sch_stat[node_id].c_flag,
 			       priv->qos_sch_stat[node_id].child_num,
 			       "Expect ACTIVE And Non-Zero child_num");
@@ -805,7 +805,7 @@ static int node_sched_inc(int inst, int node_id, int flag)
 		}
 		if (!priv->qos_sch_stat[node_id].child_num &&
 		    !(priv->qos_sch_stat[node_id].c_flag & PP_NODE_ALLOC)) {
-			PR_ERR("Wrong Sch[%d] Stat(%d)/child_num(%d):%s\n",
+			pr_err("Wrong Sch[%d] Stat(%d)/child_num(%d):%s\n",
 			       node_id, priv->qos_sch_stat[node_id].c_flag,
 			       priv->qos_sch_stat[node_id].child_num,
 			       "Expect ALLOC And zero child_num");
@@ -817,20 +817,20 @@ static int node_sched_inc(int inst, int node_id, int flag)
 	} else if (flag & P_FLAG) {
 		pid = get_parent_node(inst, node_id, flag);
 		if (pid == DP_FAILURE) {
-			PR_ERR("get_parent_node failed for sched:%d\n",
+			pr_err("get_parent_node failed for sched:%d\n",
 			       node_id);
 			return DP_FAILURE;
 		}
 
 		idx = get_free_child_idx(inst, pid, 0);
 		if (idx == DP_FAILURE) {
-			PR_ERR("get_free_child_idx failed for sched:%d\n",
+			pr_err("get_free_child_idx failed for sched:%d\n",
 			       node_id);
 			return DP_FAILURE;
 		}
 
 		if (!(priv->qos_sch_stat[node_id].p_flag & PP_NODE_ALLOC)) {
-			PR_ERR("Wrong Sch[%d] Stat(%d):Expect ALLOC\n",
+			pr_err("Wrong Sch[%d] Stat(%d):Expect ALLOC\n",
 			       node_id, priv->qos_sch_stat[node_id].p_flag);
 			return DP_FAILURE;
 		}
@@ -868,7 +868,7 @@ static int node_sched_rst(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	dp_port = priv->qos_sch_stat[node_id].dp_port;
@@ -883,7 +883,7 @@ static int node_sched_rst(int inst, int node_id, int flag)
 	if (priv->qos_sch_stat[node_id].child_num ||
 	    !(priv->qos_sch_stat[node_id].c_flag & PP_NODE_ALLOC) ||
 	    !(priv->qos_sch_stat[node_id].p_flag & PP_NODE_ALLOC)) {
-		PR_ERR("Wrong Sch[%d] c_flag(%d)/p_flag(%d)/child_num(%d):%s\n",
+		pr_err("Wrong Sch[%d] c_flag(%d)/p_flag(%d)/child_num(%d):%s\n",
 		       node_id, priv->qos_sch_stat[node_id].c_flag,
 		       priv->qos_sch_stat[node_id].p_flag,
 		       priv->qos_sch_stat[node_id].child_num,
@@ -920,19 +920,19 @@ static int node_port_dec(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	phy_id = get_cqm_deq_port_by_node(inst, node_id, flag);
 	if (phy_id == DP_FAILURE) {
-		PR_ERR("get_cqm_deq_port_by_node failed\n");
+		pr_err("get_cqm_deq_port_by_node failed\n");
 		return DP_FAILURE;
 	}
 
 	if (!priv->deq_port_stat[phy_id].child_num ||
 	    !(priv->deq_port_stat[phy_id].flag & PP_NODE_ACTIVE)) {
-		PR_ERR("Wrong P[%d] Stat(%d)/child_num(%d):%s\n",
+		pr_err("Wrong P[%d] Stat(%d)/child_num(%d):%s\n",
 		       phy_id, priv->deq_port_stat[phy_id].flag,
 		       priv->deq_port_stat[phy_id].child_num,
 		       "Expect ACTIVE Or non-zero child_num");
@@ -957,19 +957,19 @@ static int node_port_inc(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	phy_id = get_cqm_deq_port_by_node(inst, node_id, flag);
 	if (phy_id == DP_FAILURE) {
-		PR_ERR("get_cqm_deq_port_by_node failed\n");
+		pr_err("get_cqm_deq_port_by_node failed\n");
 		return DP_FAILURE;
 	}
 
 	if (priv->deq_port_stat[phy_id].child_num &&
 	    !(priv->deq_port_stat[phy_id].flag & PP_NODE_ACTIVE)) {
-		PR_ERR("Wrong P[%d] Stat(%d)/child_num(%d):%s\n", phy_id,
+		pr_err("Wrong P[%d] Stat(%d)/child_num(%d):%s\n", phy_id,
 		       priv->deq_port_stat[phy_id].flag,
 		       priv->deq_port_stat[phy_id].child_num,
 		       "Expect ACTIVE And Non-Zero child_num");
@@ -977,7 +977,7 @@ static int node_port_inc(int inst, int node_id, int flag)
 	}
 	if (!priv->deq_port_stat[phy_id].child_num &&
 	    !(priv->deq_port_stat[phy_id].flag & PP_NODE_ALLOC)) {
-		PR_ERR("Wrong P[%d] Stat(%d)/child_num(%d):%s\n", phy_id,
+		pr_err("Wrong P[%d] Stat(%d)/child_num(%d):%s\n", phy_id,
 		       priv->deq_port_stat[phy_id].flag,
 		       priv->deq_port_stat[phy_id].child_num,
 		       "Expect ALLOC And Zero child_num");
@@ -1002,19 +1002,19 @@ static int node_port_rst(int inst, int node_id, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	phy_id = get_cqm_deq_port_by_node(inst, node_id, flag);
 	if (phy_id == DP_FAILURE) {
-		PR_ERR("get_cqm_deq_port_by_node failed\n");
+		pr_err("get_cqm_deq_port_by_node failed\n");
 		return DP_FAILURE;
 	}
 
 	if (priv->deq_port_stat[phy_id].child_num ||
 	    !(priv->deq_port_stat[phy_id].flag & PP_NODE_ALLOC)) {
-		PR_ERR("Wrong P[%d] Stat(%d)/child_num(%d):%s\n", phy_id,
+		pr_err("Wrong P[%d] Stat(%d)/child_num(%d):%s\n", phy_id,
 		       priv->deq_port_stat[phy_id].flag,
 		       priv->deq_port_stat[phy_id].child_num,
 		       "Expect ALLOC Or non-zero child_num");
@@ -1085,26 +1085,26 @@ static int dp_link_unset(struct dp_node_link *info, int flag)
 	struct hal_priv *priv;
 
 	if (!info) {
-		PR_ERR("info cannot be NULL\n");
+		pr_err("info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(info->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (info->node_type == DP_NODE_QUEUE) {
 		node_id = priv->qos_queue_stat[info->node_id.q_id].node_id;
 		if (qos_queue_conf_get_32(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("failed to qos_queue_conf_get_32\n");
+			pr_err("failed to qos_queue_conf_get_32\n");
 			return DP_FAILURE;
 		}
 		if (queue_cfg.queue_child_prop.parent ==
 						*(int *)&info->p_node_id) {
 			if (qos_queue_remove_32(priv->qdev, node_id)) {
-				PR_ERR("failed to qos_queue_remove_32\n");
+				pr_err("failed to qos_queue_remove_32\n");
 				return DP_FAILURE;
 			}
 		}
@@ -1112,14 +1112,14 @@ static int dp_link_unset(struct dp_node_link *info, int flag)
 	} else if (info->node_type == DP_NODE_SCH) {
 		if (qos_sched_conf_get_32(priv->qdev, info->node_id.sch_id,
 					  &sched_cfg)) {
-			PR_ERR("failed to qos_queue_conf_get_32\n");
+			pr_err("failed to qos_queue_conf_get_32\n");
 			return DP_FAILURE;
 		}
 		if (sched_cfg.sched_child_prop.parent ==
 						*(int *)&info->p_node_id) {
 			if (qos_sched_remove_32(priv->qdev,
 						info->node_id.sch_id)) {
-				PR_ERR("failed to qos_sched_remove_32\n");
+				pr_err("failed to qos_sched_remove_32\n");
 				return DP_FAILURE;
 			}
 		}
@@ -1156,12 +1156,12 @@ static int dp_node_alloc_resv_pool(struct dp_node_alloc *node, int flag)
 	struct resv_q *resv_q;
 
 	if (!node) {
-		PR_ERR("node is  NULL\n");
+		pr_err("node is  NULL\n");
 		return DP_FAILURE;
 	}
 	priv = node ? HAL(node->inst) : NULL;
 	if (!priv) {
-		PR_ERR("priv is NULL\n");
+		pr_err("priv is NULL\n");
 		return DP_FAILURE;
 	}
 	resv_q = priv->resv[node->dp_port].resv_q;
@@ -1248,31 +1248,31 @@ static int dp_node_alloc_global_pool(struct dp_node_alloc *node, int flag)
 	int res = DP_FAILURE;
 
 	if (!node) {
-		PR_ERR("node is  NULL\n");
+		pr_err("node is  NULL\n");
 		goto EXIT;
 	}
 
 	priv = HAL(node->inst);
 	if (!priv) {
-		PR_ERR("priv is NULL\n");
+		pr_err("priv is NULL\n");
 		goto EXIT;
 	}
 
 	q_conf = kzalloc(sizeof(*q_conf), GFP_KERNEL);
 	if (!q_conf) {
-		PR_ERR("fail to alloc %zd bytes\n", sizeof(*q_conf));
+		pr_err("fail to alloc %zd bytes\n", sizeof(*q_conf));
 		goto EXIT;
 	}
 
 	qos_queue_info = kzalloc(sizeof(*qos_queue_info), GFP_KERNEL);
 	if (!qos_queue_info) {
-		PR_ERR("fail to alloc %zd bytes\n", sizeof(*qos_queue_info));
+		pr_err("fail to alloc %zd bytes\n", sizeof(*qos_queue_info));
 		goto EXIT;
 	}
 
 	if (node->type == DP_NODE_QUEUE) {
 		if (qos_queue_allocate_32(priv->qdev, &id)) {
-			PR_ERR("qos_queue_allocate_32 failed\n");
+			pr_err("qos_queue_allocate_32 failed\n");
 			goto EXIT;
 		}
 		DP_DEBUG(DP_DBG_FLAG_QOS, "qos_queue_allocate_32: %d\n", id);
@@ -1291,7 +1291,7 @@ static int dp_node_alloc_global_pool(struct dp_node_alloc *node, int flag)
 		q_conf->queue_child_prop.parent = priv->ppv4_tmp_p;
 #endif /* WORKAROUND_DROP_PORT */
 		if (qos_queue_set_32(priv->qdev, id, q_conf)) {
-			PR_ERR(
+			pr_err(
 			    "qos_queue_set_32 fail for queue=%d to parent=%d\n",
 			    id, q_conf->queue_child_prop.parent);
 			goto EXIT;
@@ -1303,7 +1303,7 @@ static int dp_node_alloc_global_pool(struct dp_node_alloc *node, int flag)
 #endif /* WORKAROUND_PORT_SET */
 		if (qos_queue_info_get_32(priv->qdev, id, qos_queue_info)) {
 			qos_queue_remove_32(priv->qdev, id);
-			PR_ERR("qos_queue_info_get_32: %d\n", id);
+			pr_err("qos_queue_info_get_32: %d\n", id);
 			goto EXIT;
 		}
 
@@ -1325,7 +1325,7 @@ static int dp_node_alloc_global_pool(struct dp_node_alloc *node, int flag)
 		goto EXIT;
 	} else if (node->type == DP_NODE_SCH) {
 		if (qos_sched_allocate_32(priv->qdev, &id)) {
-			PR_ERR("failed to qos_sched_allocate_32\n");
+			pr_err("failed to qos_sched_allocate_32\n");
 			qos_sched_remove_32(priv->qdev, id);
 			goto EXIT;
 		}
@@ -1339,7 +1339,7 @@ static int dp_node_alloc_global_pool(struct dp_node_alloc *node, int flag)
 		res = DP_SUCCESS;
 		goto EXIT;
 	} else {
-		PR_ERR("Unknown node type %d\n", node->type);
+		pr_err("Unknown node type %d\n", node->type);
 	}
 
 EXIT:
@@ -1361,13 +1361,13 @@ static int dp_alloc_qos_port(struct dp_node_alloc *node, int flag)
 	struct hal_priv *priv;
 
 	if (!node) {
-		PR_ERR("node NULL\n");
+		pr_err("node NULL\n");
 		goto EXIT;
 	}
 	inst = node->inst;
 	priv = HAL(node->inst);
 	if (!priv) {
-		PR_ERR("priv NULL\n");
+		pr_err("priv NULL\n");
 		goto EXIT;
 	}
 	cqm_deq_port = node->id.cqm_deq_port;
@@ -1375,7 +1375,7 @@ static int dp_alloc_qos_port(struct dp_node_alloc *node, int flag)
 		 "inst=%d dp_port=%d cqm_deq_port=%d\n",
 		 node->inst, node->dp_port, cqm_deq_port);
 	if (cqm_deq_port == DP_NODE_AUTO_ID) {
-		PR_ERR("cqm_deq_port wrong: %d\n", cqm_deq_port);
+		pr_err("cqm_deq_port wrong: %d\n", cqm_deq_port);
 		goto EXIT;
 	}
 	if (priv->deq_port_stat[cqm_deq_port].flag != PP_NODE_FREE) {
@@ -1384,10 +1384,10 @@ static int dp_alloc_qos_port(struct dp_node_alloc *node, int flag)
 		return priv->deq_port_stat[cqm_deq_port].node_id;
 	}
 	if (qos_port_allocate_32(priv->qdev, cqm_deq_port, &qos_port)) {
-		PR_ERR("failed to qos_port_allocate_32:%d\n", cqm_deq_port);
+		pr_err("failed to qos_port_allocate_32:%d\n", cqm_deq_port);
 		goto EXIT;
 	}
-	/* PR_INFO("qos_port_alloc succeed: %d/%d\n",
+	/* pr_info("qos_port_alloc succeed: %d/%d\n",
 	 *	   cqm_deq_port, qos_port);
 	 */
 	/* Configure QOS dequeue port */
@@ -1418,7 +1418,7 @@ static int dp_alloc_qos_port(struct dp_node_alloc *node, int flag)
 	}
 #endif
 	if (qos_port_set_32(priv->qdev, qos_port, &port_cfg)) {
-		PR_ERR("qos_port_set_32 fail for port %d/%d\n",
+		pr_err("qos_port_set_32 fail for port %d/%d\n",
 		       cqm_deq_port, qos_port);
 		qos_port_remove_32(priv->qdev, qos_port);
 		goto EXIT;
@@ -1445,13 +1445,13 @@ int dp_node_alloc_32(struct dp_node_alloc *node, int flag)
 	struct hal_priv *priv;
 
 	if (!node) {
-		PR_ERR("node NULL\n");
+		pr_err("node NULL\n");
 		return DP_FAILURE;
 	}
 
 	priv = HAL(node->inst);
 	if (!priv) {
-		PR_ERR("priv is NULL cannot proceed!!\n");
+		pr_err("priv is NULL cannot proceed!!\n");
 		return DP_FAILURE;
 	}
 
@@ -1532,13 +1532,13 @@ static int dp_smart_free_from_child_32(struct dp_node_alloc *node, int flag)
 	struct hal_priv *priv;
 
 	if (!node) {
-		PR_ERR("node is NULL cannot proceed!!\n");
+		pr_err("node is NULL cannot proceed!!\n");
 		return DP_FAILURE;
 	}
 
 	priv = HAL(node->inst);
 	if (!priv) {
-		PR_ERR("priv is NULL cannot proceed!!\n");
+		pr_err("priv is NULL cannot proceed!!\n");
 		return DP_FAILURE;
 	}
 
@@ -1548,7 +1548,7 @@ static int dp_smart_free_from_child_32(struct dp_node_alloc *node, int flag)
 		 node->id.q_id);
 	if (node->type == DP_NODE_QUEUE) {
 		if ((node->id.q_id < 0) || (node->id.q_id >= MAX_QUEUE)) {
-			PR_ERR("Wrong Parameter: QID[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: QID[%d]Out Of Range\n",
 			       node->id.q_id);
 			return DP_FAILURE;
 		}
@@ -1564,18 +1564,18 @@ static int dp_smart_free_from_child_32(struct dp_node_alloc *node, int flag)
 			DP_DEBUG(DP_DBG_FLAG_QOS,
 				 "current node doesnot have parent\n");
 		} else if (dp_node_unlink_32(&info, 0)) {
-			PR_ERR("dp_node_unlink_32 failed\n");
+			pr_err("dp_node_unlink_32 failed\n");
 			return DP_FAILURE;
 		}
 
 		if (dp_node_free_32(node, 0)) {
-			PR_ERR("failed to free Queue:[%d]\n", node->id.q_id);
+			pr_err("failed to free Queue:[%d]\n", node->id.q_id);
 			return DP_FAILURE;
 		}
 	} else if (node->type == DP_NODE_SCH) {
 		if ((node->id.sch_id < 0) ||
 		    (node->id.sch_id >= QOS_MAX_NODES)) {
-			PR_ERR("Wrong Parameter: Sched[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: Sched[%d]Out Of Range\n",
 			       node->id.sch_id);
 			return DP_FAILURE;
 		}
@@ -1593,19 +1593,19 @@ static int dp_smart_free_from_child_32(struct dp_node_alloc *node, int flag)
 		}
 
 		if (dp_node_free_32(node, 0)) {
-			PR_ERR("failed to free Sched:[%d]\n", node->id.sch_id);
+			pr_err("failed to free Sched:[%d]\n", node->id.sch_id);
 			return DP_FAILURE;
 		}
 	} else if (node->type == DP_NODE_PORT) {
 		if ((node->id.cqm_deq_port < 0) ||
 		    (node->id.cqm_deq_port >= MAX_CQM_DEQ)) {
-			PR_ERR("Wrong Parameter: Port[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: Port[%d]Out Of Range\n",
 			       node->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
 
 		if (dp_node_free_32(node, 0)) {
-			PR_ERR("failed to free Port:[%d]\n",
+			pr_err("failed to free Port:[%d]\n",
 			       node->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
@@ -1625,14 +1625,14 @@ static int dp_smart_free_from_child_32(struct dp_node_alloc *node, int flag)
 							 flag);
 			id = temp.id.cqm_deq_port;
 			if ((id < 0) || (id >= MAX_CQM_DEQ)) {
-				PR_ERR("Wrong Parameter: Port[%d]%s\n",
+				pr_err("Wrong Parameter: Port[%d]%s\n",
 				       id, "Out Of Range");
 				return DP_FAILURE;
 			}
 		} else {
 			id = temp.id.sch_id;
 			if ((id < 0) || (id >= QOS_MAX_NODES)) {
-				PR_ERR("Wrong Parameter: Sched[%d]%s\n",
+				pr_err("Wrong Parameter: Sched[%d]%s\n",
 				       id, "Out Of Range");
 				return DP_FAILURE;
 			}
@@ -1653,7 +1653,7 @@ static int dp_smart_free_from_child_32(struct dp_node_alloc *node, int flag)
 		f_free = (dp_node_link_get_32(&info, 0));
 		res = dp_node_free_32(&temp, 0);
 		if (res) {
-			PR_ERR("failed to free node:%d res %d\n",
+			pr_err("failed to free node:%d res %d\n",
 			       temp.id.q_id, res);
 			return DP_FAILURE;
 		}
@@ -1679,20 +1679,20 @@ int dp_free_children_via_parent_32(struct dp_node_alloc *node, int flag)
 	struct hal_priv *priv;
 
 	if (!node) {
-		PR_ERR("node is NULL cannot proceed!!\n");
+		pr_err("node is NULL cannot proceed!!\n");
 		return DP_FAILURE;
 	}
 
 	priv = HAL(node->inst);
 	if (!priv) {
-		PR_ERR("priv is NULL cannot proceed!!\n");
+		pr_err("priv is NULL cannot proceed!!\n");
 		return DP_FAILURE;
 	}
 
 	if (node->type == DP_NODE_PORT) {
 		if ((node->id.cqm_deq_port < 0) ||
 		    (node->id.cqm_deq_port >= MAX_CQM_DEQ)) {
-			PR_ERR("Wrong Parameter: Port[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: Port[%d]Out Of Range\n",
 			       node->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
@@ -1716,7 +1716,7 @@ int dp_free_children_via_parent_32(struct dp_node_alloc *node, int flag)
 				else
 					temp.id.q_id = child_id;
 				if (dp_free_children_via_parent_32(&temp, 0)) {
-					PR_ERR("fail %s=%d child:%d type=%d\n",
+					pr_err("fail %s=%d child:%d type=%d\n",
 					       "to free Port's",
 					       node->id.cqm_deq_port,
 					       CHILD(id, idx).node_id,
@@ -1733,7 +1733,7 @@ int dp_free_children_via_parent_32(struct dp_node_alloc *node, int flag)
 
 		if (!priv->qos_sch_stat[id].child_num) {
 			if (dp_node_free_32(node, 0)) {
-				PR_ERR("failed to free Port:[%d]\n",
+				pr_err("failed to free Port:[%d]\n",
 				       node->id.cqm_deq_port);
 				return DP_FAILURE;
 			}
@@ -1741,7 +1741,7 @@ int dp_free_children_via_parent_32(struct dp_node_alloc *node, int flag)
 	} else if (node->type == DP_NODE_SCH) {
 		if ((node->id.sch_id < 0) ||
 		    (node->id.sch_id >= QOS_MAX_NODES)) {
-			PR_ERR("Wrong Parameter: Sched[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: Sched[%d]Out Of Range\n",
 			       node->id.sch_id);
 			return DP_FAILURE;
 		}
@@ -1765,7 +1765,7 @@ int dp_free_children_via_parent_32(struct dp_node_alloc *node, int flag)
 				else
 					temp.id.q_id = child_id;
 				if (dp_free_children_via_parent_32(&temp, 0)) {
-					PR_ERR("fail %s=%d child:%d type=%d\n",
+					pr_err("fail %s=%d child:%d type=%d\n",
 					       "to free Sched's",
 					       node->id.sch_id,
 					       CHILD(id, idx).node_id,
@@ -1786,14 +1786,14 @@ int dp_free_children_via_parent_32(struct dp_node_alloc *node, int flag)
 
 		if (!priv->qos_sch_stat[id].child_num) {
 			if (dp_node_free_32(node, 0)) {
-				PR_ERR("failed to free Sched:[%d]\n",
+				pr_err("failed to free Sched:[%d]\n",
 				       node->id.sch_id);
 				return DP_FAILURE;
 			}
 		}
 	} else if (node->type == DP_NODE_QUEUE) {
 		if ((node->id.q_id < 0) || (node->id.q_id >= MAX_QUEUE)) {
-			PR_ERR("Wrong Parameter: QID[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: QID[%d]Out Of Range\n",
 			       node->id.q_id);
 			return DP_FAILURE;
 		}
@@ -1807,12 +1807,12 @@ int dp_free_children_via_parent_32(struct dp_node_alloc *node, int flag)
 
 		if (priv->qos_queue_stat[node->id.q_id].flag != PP_NODE_FREE) {
 			if (dp_node_unlink_32(&info, 0)) {
-				PR_ERR("dp_node_unlink_32 failed\n");
+				pr_err("dp_node_unlink_32 failed\n");
 				return DP_FAILURE;
 			}
 
 			if (dp_node_free_32(node, 0)) {
-				PR_ERR("failed to free Queue:[%d]\n",
+				pr_err("failed to free Queue:[%d]\n",
 				       node->id.q_id);
 				return DP_FAILURE;
 			}
@@ -1824,7 +1824,7 @@ int dp_free_children_via_parent_32(struct dp_node_alloc *node, int flag)
 				 info.p_node_type);
 		}
 	} else {
-		PR_ERR("Incorrect Parameter:%d\n", node->type);
+		pr_err("Incorrect Parameter:%d\n", node->type);
 		return DP_FAILURE;
 	}
 	return DP_SUCCESS;
@@ -1857,25 +1857,25 @@ int dp_node_free_32(struct dp_node_alloc *node, int flag)
 	int res = DP_FAILURE;
 
 	if (!node) {
-		PR_ERR("node is NULL cannot proceed!!\n");
+		pr_err("node is NULL cannot proceed!!\n");
 		return DP_FAILURE;
 	}
 
 	priv = HAL(node->inst);
 	if (!priv) {
-		PR_ERR("priv is NULL cannot proceed!!\n");
+		pr_err("priv is NULL cannot proceed!!\n");
 		return DP_FAILURE;
 	}
 	t = kzalloc(sizeof(*t), GFP_ATOMIC);
 	if (!t) {
-		PR_ERR("fail to alloc %zd bytes\n", sizeof(*t));
+		pr_err("fail to alloc %zd bytes\n", sizeof(*t));
 		return DP_FAILURE;
 	}
 
 	if (flag == DP_NODE_SMART_FREE) {/* dont pass flag */
 		res = dp_smart_free_from_child_32(node, 0);
 		if (res == DP_FAILURE) {
-			PR_ERR("dp_smart_free_from_child_32 failed\n");
+			pr_err("dp_smart_free_from_child_32 failed\n");
 			goto EXIT;
 		}
 	}
@@ -1886,7 +1886,7 @@ int dp_node_free_32(struct dp_node_alloc *node, int flag)
 		t->resv_flag = priv->qos_queue_stat[node->id.q_id].flag;
 
 		if (priv->qos_queue_stat[node->id.q_id].flag == PP_NODE_FREE) {
-			PR_ERR("Node Q[%d] is already Free Stat\n",
+			pr_err("Node Q[%d] is already Free Stat\n",
 			       node->id.q_id);
 			goto EXIT;
 		}
@@ -1896,11 +1896,11 @@ int dp_node_free_32(struct dp_node_alloc *node, int flag)
 			res = node_stat_update(node->inst, t->node_id,
 					       DP_NODE_RST);
 			if (res == DP_FAILURE) {
-				PR_ERR("node_stat_update failed\n");
+				pr_err("node_stat_update failed\n");
 				goto EXIT;
 			}
 			if (qos_queue_remove_32(priv->qdev, t->node_id)) {
-				PR_ERR("failed to qos_queue_remove_32\n");
+				pr_err("failed to qos_queue_remove_32\n");
 				goto EXIT;
 			}
 			res = DP_SUCCESS;
@@ -1911,7 +1911,7 @@ int dp_node_free_32(struct dp_node_alloc *node, int flag)
 		t->info.node_id = node->id;
 		t->info.node_type = node->type;
 		if (dp_node_unlink_32(&t->info, 0)) {
-			PR_ERR("failed to dp_node_unlink_32 for Q:%d\n",
+			pr_err("failed to dp_node_unlink_32 for Q:%d\n",
 			       node->id.q_id);
 			goto EXIT;
 		}
@@ -1922,18 +1922,18 @@ int dp_node_free_32(struct dp_node_alloc *node, int flag)
 		/* Remove Queue link only for global resource */
 		if (!(t->resv_flag & PP_NODE_RESERVE)) {
 			if (qos_queue_remove_32(priv->qdev, t->node_id)) {
-				PR_ERR("failed to qos_queue_remove_32\n");
+				pr_err("failed to qos_queue_remove_32\n");
 				goto EXIT;
 			}
 		}
 		if (node_stat_update(node->inst, t->node_id, DP_NODE_DEC)) {
-			PR_ERR("node_stat_update failed\n");
+			pr_err("node_stat_update failed\n");
 			goto EXIT;
 		}
 		/* call node_stat_update to update parent status */
 		if (node_stat_update(node->inst, t->parent_id,
 				     DP_NODE_DEC | C_FLAG)) {
-			PR_ERR("stat update fail Q:[%d/%d]'s parent:%d\n",
+			pr_err("stat update fail Q:[%d/%d]'s parent:%d\n",
 			       node->id.q_id, t->node_id, t->parent_id);
 			goto EXIT;
 		}
@@ -1943,7 +1943,7 @@ int dp_node_free_32(struct dp_node_alloc *node, int flag)
 		/* call node_Stat_update to free the node */
 		if (node_stat_update(node->inst, t->node_id,
 				     DP_NODE_RST)) {
-			PR_ERR("node_stat_update failed\n");
+			pr_err("node_stat_update failed\n");
 			goto EXIT;
 		}
 		DP_DEBUG(DP_DBG_FLAG_QOS,
@@ -1955,7 +1955,7 @@ int dp_node_free_32(struct dp_node_alloc *node, int flag)
 			t->tmp_q.queue_child_prop.parent = priv->ppv4_drop_p;
 			if (qos_queue_set_32(priv->qdev, t->node_id,
 					     &t->tmp_q)) {
-				PR_ERR("qos_queue_set_32 %s=%d to parent=%d\n",
+				pr_err("qos_queue_set_32 %s=%d to parent=%d\n",
 				       "fail to reserve queue", t->node_id,
 				       t->tmp_q.queue_child_prop.parent);
 				goto EXIT;
@@ -1973,14 +1973,14 @@ int dp_node_free_32(struct dp_node_alloc *node, int flag)
 		t->resv_flag = priv->qos_sch_stat[t->sch_id].p_flag;
 
 		if (priv->qos_sch_stat[t->sch_id].child_num) {
-			PR_ERR("Node Sch[%d] still have child num %d\n",
+			pr_err("Node Sch[%d] still have child num %d\n",
 			       t->sch_id,
 			       priv->qos_sch_stat[t->sch_id].child_num);
 			goto EXIT;
 		}
 
 		if (priv->qos_sch_stat[t->sch_id].p_flag == PP_NODE_FREE) {
-			PR_ERR("Node Sch[%d] is already Free Stat\n",
+			pr_err("Node Sch[%d] is already Free Stat\n",
 			       t->sch_id);
 			goto EXIT;
 		}
@@ -1989,11 +1989,11 @@ int dp_node_free_32(struct dp_node_alloc *node, int flag)
 					  &t->sched_cfg)) {
 			if (node_stat_update(node->inst, t->sch_id,
 					     DP_NODE_RST | P_FLAG)) {
-				PR_ERR("node_stat_update failed\n");
+				pr_err("node_stat_update failed\n");
 				goto EXIT;
 			}
 			if (qos_sched_remove_32(priv->qdev, t->sch_id)) {
-				PR_ERR("failed to qos_sched_remove_32\n");
+				pr_err("failed to qos_sched_remove_32\n");
 				goto EXIT;
 			}
 			res = DP_SUCCESS;
@@ -2005,19 +2005,19 @@ int dp_node_free_32(struct dp_node_alloc *node, int flag)
 		/* Remove Sched link only if global resource */
 		if (!(t->resv_flag & PP_NODE_RESERVE)) {
 			if (qos_sched_remove_32(priv->qdev, t->sch_id)) {
-				PR_ERR("failed to qos_sched_remove_32\n");
+				pr_err("failed to qos_sched_remove_32\n");
 				goto EXIT;
 			}
 		}
 		if (node_stat_update(node->inst, t->sch_id,
 				     DP_NODE_DEC | P_FLAG)) {
-			PR_ERR("node_stat_update failed\n");
+			pr_err("node_stat_update failed\n");
 			goto EXIT;
 		}
 		/* call node_stat_update to update parent status */
 		if (node_stat_update(node->inst, t->parent_id,
 				     DP_NODE_DEC | C_FLAG)) {
-			PR_ERR("stat update fail Sch:[%d]'s parent:%d\n",
+			pr_err("stat update fail Sch:[%d]'s parent:%d\n",
 			       node->id.sch_id, t->parent_id);
 			goto EXIT;
 		}
@@ -2027,7 +2027,7 @@ int dp_node_free_32(struct dp_node_alloc *node, int flag)
 		/* call node_stat_update to free the node */
 		if (node_stat_update(node->inst, t->sch_id,
 				     DP_NODE_RST | P_FLAG)) {
-			PR_ERR("Node Reset failed Sched[/%d]\n",
+			pr_err("Node Reset failed Sched[/%d]\n",
 			       node->id.sch_id);
 			goto EXIT;
 		}
@@ -2040,7 +2040,7 @@ int dp_node_free_32(struct dp_node_alloc *node, int flag)
 			t->tmp_sch.sched_child_prop.parent = priv->ppv4_drop_p;
 			if (qos_sched_set_32(priv->qdev, t->sch_id,
 					     &t->tmp_sch)) {
-				PR_ERR("qos_sched_set_32 %s=%d to parent=%d\n",
+				pr_err("qos_sched_set_32 %s=%d to parent=%d\n",
 				       "fail to reserve SCH", t->sch_id,
 				       t->tmp_sch.sched_child_prop.parent);
 				goto EXIT;
@@ -2057,7 +2057,7 @@ int dp_node_free_32(struct dp_node_alloc *node, int flag)
 		t->node_id = priv->deq_port_stat[t->phy_id].node_id;
 
 		if (priv->deq_port_stat[t->phy_id].child_num) {
-			PR_ERR("Node port[%d] still have child num %d\n",
+			pr_err("Node port[%d] still have child num %d\n",
 			       t->phy_id,
 			       priv->deq_port_stat[t->phy_id].child_num);
 			goto EXIT;
@@ -2066,7 +2066,7 @@ int dp_node_free_32(struct dp_node_alloc *node, int flag)
 			res = node_stat_update(node->inst, t->node_id,
 					       DP_NODE_DEC);
 			if (res == DP_FAILURE) {
-				PR_ERR("Wrong Port %d flag:0x%x\n", t->phy_id,
+				pr_err("Wrong Port %d flag:0x%x\n", t->phy_id,
 				       priv->deq_port_stat[t->phy_id].flag);
 				goto EXIT;
 			}
@@ -2077,15 +2077,15 @@ int dp_node_free_32(struct dp_node_alloc *node, int flag)
 			res = DP_SUCCESS;
 			goto EXIT;
 		}
-		PR_ERR("Unexpect port %d flag %d\n",
+		pr_err("Unexpect port %d flag %d\n",
 		       t->phy_id, priv->deq_port_stat[t->phy_id].flag);
 		goto EXIT;
 	}
-	PR_ERR("Unexpect node->type %d\n", node->type);
+	pr_err("Unexpect node->type %d\n", node->type);
 
 EXIT:
 	if (res == DP_FAILURE)
-		PR_ERR("failed to free node:%d res %d\n",
+		pr_err("failed to free node:%d res %d\n",
 		       node->id.q_id, res);
 	kfree(t);
 	t = NULL;
@@ -2109,7 +2109,7 @@ static int dp_qos_parent_chk(struct dp_node_link *info, int flag)
 			node.dp_port = info->dp_port;
 
 			if ((dp_node_alloc_32(&node, flag)) == DP_FAILURE) {
-				PR_ERR("dp_node_alloc_32 queue alloc fail\n");
+				pr_err("dp_node_alloc_32 queue alloc fail\n");
 				return DP_FAILURE;
 			}
 			info->p_node_id = node.id;
@@ -2137,20 +2137,20 @@ int dp_node_link_get_32(struct dp_node_link *info, int flag)
 	int node_id;
 
 	if (!info) {
-		PR_ERR("info cannot be NULL\n");
+		pr_err("info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(info->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (info->node_type == DP_NODE_QUEUE) {
 		node_id = priv->qos_queue_stat[info->node_id.q_id].node_id;
 		if (qos_queue_conf_get_32(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("failed to qos_queue_conf_get_32\n");
+			pr_err("failed to qos_queue_conf_get_32\n");
 			return DP_FAILURE;
 		}
 		if (!queue_cfg.queue_child_prop.parent)
@@ -2170,16 +2170,16 @@ int dp_node_link_get_32(struct dp_node_link *info, int flag)
 	} else if (info->node_type == DP_NODE_SCH) {
 		if (qos_sched_conf_get_32(priv->qdev, info->node_id.sch_id,
 					  &sched_cfg)) {
-			PR_ERR("failed to qos_sched_conf_get_32\n");
+			pr_err("failed to qos_sched_conf_get_32\n");
 			return DP_FAILURE;
 		}
 		if (!sched_cfg.sched_child_prop.parent) {
-			PR_ERR("sched child do not have parent\n");
+			pr_err("sched child do not have parent\n");
 			return DP_FAILURE;
 		}
 		if (!(priv->qos_sch_stat[info->node_id.sch_id].p_flag &
 		      PP_NODE_ACTIVE)) {
-			PR_ERR("sched id %d flag not active, flag %d\n",
+			pr_err("sched id %d flag not active, flag %d\n",
 			       info->node_id.sch_id,
 			       priv->qos_sch_stat[info->node_id.sch_id].p_flag);
 			return DP_FAILURE;
@@ -2231,7 +2231,7 @@ static int dp_link_set(struct dp_node_link *info, int parent_node, int flag)
 			 queue_cfg->queue_child_prop.parent,
 			 info->cqm_deq_port.cqm_deq_port);
 		if (qos_queue_set_32(priv->qdev, node_id, queue_cfg)) {
-			PR_ERR("failed to qos_queue_set_32\n");
+			pr_err("failed to qos_queue_set_32\n");
 			qos_queue_remove_32(priv->qdev, node_id);
 			goto ERROR_EXIT;
 		}
@@ -2252,7 +2252,7 @@ static int dp_link_set(struct dp_node_link *info, int parent_node, int flag)
 			 info->cqm_deq_port.cqm_deq_port);
 
 		if (qos_sched_set_32(priv->qdev, node_id, sched_cfg)) {
-			PR_ERR("failed to %s %d parent_node %d\n",
+			pr_err("failed to %s %d parent_node %d\n",
 			       "qos_sched_set_32 node_id",
 			       node_id, parent_node);
 			qos_sched_remove_32(priv->qdev, node_id);
@@ -2295,37 +2295,37 @@ static int get_parent_arbi(int inst, int node_id, int flag)
 	struct pp_qos_port_conf port_cfg = {0};
 
 	if (priv->qos_sch_stat[node_id].parent.flag == PP_NODE_FREE) {
-		PR_ERR("Parent is not set for node\n");
+		pr_err("Parent is not set for node\n");
 		return DP_FAILURE;
 	}
 	pid = priv->qos_sch_stat[node_id].parent.node_id;
 
 	if (priv->qos_sch_stat[node_id].parent.type == DP_NODE_SCH) {
 		if (qos_sched_conf_get_32(priv->qdev, pid, &sched_cfg)) {
-			PR_ERR("fail to get sched config\n");
+			pr_err("fail to get sched config\n");
 			return DP_FAILURE;
 		}
 		arbi = arbi_pp2dp_32(sched_cfg.sched_parent_prop.arbitration);
 		if (arbi == DP_FAILURE)
-			PR_ERR("Wrong pp_arbitrate: %d for %s:%d\n",
+			pr_err("Wrong pp_arbitrate: %d for %s:%d\n",
 			       port_cfg.port_parent_prop.arbitration,
 			       (priv->qos_sch_stat[node_id].type == DP_NODE_SCH)
 			       ? "sched" : "Q",
 			       node_id);
 	} else if (priv->qos_sch_stat[node_id].parent.type == DP_NODE_PORT) {
 		if (qos_port_conf_get_32(priv->qdev, pid, &port_cfg)) {
-			PR_ERR("fail to get port config\n");
+			pr_err("fail to get port config\n");
 			return DP_FAILURE;
 		}
 		arbi = arbi_pp2dp_32(port_cfg.port_parent_prop.arbitration);
 		if (arbi == DP_FAILURE)
-			PR_ERR("Wrong pp_arbitrate: %d for %s:%d\n",
+			pr_err("Wrong pp_arbitrate: %d for %s:%d\n",
 			       port_cfg.port_parent_prop.arbitration,
 			       (priv->qos_sch_stat[node_id].type == DP_NODE_SCH)
 			       ? "sched" : "Q",
 			       node_id);
 	} else {
-		PR_ERR("incorrect parent type:0x%x for node:%d.\n",
+		pr_err("incorrect parent type:0x%x for node:%d.\n",
 		       priv->qos_sch_stat[node_id].parent.type,
 		       node_id);
 		return DP_FAILURE;
@@ -2345,7 +2345,7 @@ static int set_parent_arbi(int inst, int node_id, int arbi, int flag)
 	struct pp_qos_port_conf port_cfg = {0};
 
 	if (priv->qos_sch_stat[node_id].parent.flag == PP_NODE_FREE) {
-		PR_ERR("Parent is not set for node\n");
+		pr_err("Parent is not set for node\n");
 		return DP_FAILURE;
 	}
 	pid = priv->qos_sch_stat[node_id].parent.node_id;
@@ -2353,34 +2353,34 @@ static int set_parent_arbi(int inst, int node_id, int arbi, int flag)
 	arbi = arbi_dp2pp_32(arbi);
 
 	if (arbi == DP_FAILURE) {
-		PR_ERR("Incorrect arbitration value provided:%d!\n", arbi);
+		pr_err("Incorrect arbitration value provided:%d!\n", arbi);
 		return DP_FAILURE;
 	}
 
 	if (priv->qos_sch_stat[node_id].parent.type == DP_NODE_SCH) {
 		if (qos_sched_conf_get_32(priv->qdev, pid, &sched_cfg)) {
-			PR_ERR("fail to get sched config\n");
+			pr_err("fail to get sched config\n");
 			return DP_FAILURE;
 		}
 		sched_cfg.sched_parent_prop.arbitration = arbi;
 		if (qos_sched_set_32(priv->qdev, pid, &sched_cfg)) {
-			PR_ERR("fail to set arbi sched:%d parent of node:%d\n",
+			pr_err("fail to set arbi sched:%d parent of node:%d\n",
 			       pid, node_id);
 			return DP_FAILURE;
 		}
 	} else if (priv->qos_sch_stat[node_id].parent.type == DP_NODE_PORT) {
 		if (qos_port_conf_get_32(priv->qdev, pid, &port_cfg)) {
-			PR_ERR("fail to get port config\n");
+			pr_err("fail to get port config\n");
 			return DP_FAILURE;
 		}
 		port_cfg.port_parent_prop.arbitration = arbi;
 		if (qos_port_set_32(priv->qdev, pid, &port_cfg)) {
-			PR_ERR("fail to set arbi port:%d parent of node:%d\n",
+			pr_err("fail to set arbi port:%d parent of node:%d\n",
 			       pid, node_id);
 			return DP_FAILURE;
 		}
 	} else {
-		PR_ERR("incorrect parent type:0x%x for node:%d.\n",
+		pr_err("incorrect parent type:0x%x for node:%d.\n",
 		       priv->qos_sch_stat[node_id].parent.type,
 		       node_id);
 		return DP_FAILURE;
@@ -2400,29 +2400,29 @@ int dp_qos_link_prio_set_32(struct dp_node_prio *info, int flag)
 	int node_id;
 
 	if (!info) {
-		PR_ERR("info cannot be NULL\n");
+		pr_err("info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(info->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (info->type == DP_NODE_QUEUE) {
 		if ((info->id.q_id < 0) || (info->id.q_id >= MAX_QUEUE)) {
-			PR_ERR("Invalid Queue ID:%d\n", info->id.q_id);
+			pr_err("Invalid Queue ID:%d\n", info->id.q_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_queue_stat[info->id.q_id].flag == PP_NODE_FREE) {
-			PR_ERR("Invalid Queue flag:0x%x\n",
+			pr_err("Invalid Queue flag:0x%x\n",
 			       priv->qos_queue_stat[info->id.q_id].flag);
 			return DP_FAILURE;
 		}
 		node_id = priv->qos_queue_stat[info->id.q_id].node_id;
 		if (qos_queue_conf_get_32(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("fail to get queue prio and parent\n");
+			pr_err("fail to get queue prio and parent\n");
 			return DP_FAILURE;
 		}
 		queue_cfg.queue_child_prop.priority = info->prio_wfq;
@@ -2430,12 +2430,12 @@ int dp_qos_link_prio_set_32(struct dp_node_prio *info, int flag)
 			 "Prio:%d paased to low level for queue[%d]\n",
 			 info->prio_wfq, info->id.q_id);
 		if (qos_queue_set_32(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("failed to qos_queue_set_32\n");
+			pr_err("failed to qos_queue_set_32\n");
 			return DP_FAILURE;
 		}
 		/* get parent conf and set arbi in parent */
 		if (set_parent_arbi(info->inst, node_id, info->arbi, flag)) {
-			PR_ERR("fail to set arbi:%d in Parent of Q:%d\n",
+			pr_err("fail to set arbi:%d in Parent of Q:%d\n",
 			       info->arbi, node_id);
 			return DP_FAILURE;
 		}
@@ -2446,18 +2446,18 @@ int dp_qos_link_prio_set_32(struct dp_node_prio *info, int flag)
 	} else if (info->type == DP_NODE_SCH) {
 		if ((info->id.sch_id < 0) ||
 		    (info->id.sch_id >= QOS_MAX_NODES)) {
-			PR_ERR("Invalid Sched ID:%d\n", info->id.sch_id);
+			pr_err("Invalid Sched ID:%d\n", info->id.sch_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_sch_stat[info->id.sch_id].p_flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Invalid Sched flag:0x%x\n",
+			pr_err("Invalid Sched flag:0x%x\n",
 			       priv->qos_sch_stat[info->id.sch_id].p_flag);
 			return DP_FAILURE;
 		}
 		if (qos_sched_conf_get_32(priv->qdev, info->id.sch_id,
 					  &sched_cfg)) {
-			PR_ERR("fail to get sched prio and parent\n");
+			pr_err("fail to get sched prio and parent\n");
 			return DP_FAILURE;
 		}
 		sched_cfg.sched_child_prop.priority = info->prio_wfq;
@@ -2465,13 +2465,13 @@ int dp_qos_link_prio_set_32(struct dp_node_prio *info, int flag)
 			 "Prio:%d paased to low level for Sched[%d]\n",
 			 info->prio_wfq, info->id.sch_id);
 		if (qos_sched_set_32(priv->qdev, info->id.sch_id, &sched_cfg)) {
-			PR_ERR("failed to qos_sched_set_32\n");
+			pr_err("failed to qos_sched_set_32\n");
 			return DP_FAILURE;
 		}
 		/* get parent conf and set arbi in parent */
 		if (set_parent_arbi(info->inst, info->id.sch_id,
 				    info->arbi, 0)) {
-			PR_ERR("fail to set arbi:%d Parent of Sched:%d\n",
+			pr_err("fail to set arbi:%d Parent of Sched:%d\n",
 			       info->arbi, info->id.sch_id);
 			return DP_FAILURE;
 		}
@@ -2480,7 +2480,7 @@ int dp_qos_link_prio_set_32(struct dp_node_prio *info, int flag)
 			 info->id.sch_id, info->arbi, info->prio_wfq);
 		return DP_SUCCESS;
 	}
-	PR_ERR("incorrect info type provided:0x%x\n", info->type);
+	pr_err("incorrect info type provided:0x%x\n", info->type);
 	return DP_FAILURE;
 }
 
@@ -2496,29 +2496,29 @@ int dp_qos_link_prio_get_32(struct dp_node_prio *info, int flag)
 	int node_id, arbi;
 
 	if (!info) {
-		PR_ERR("info cannot be NULL\n");
+		pr_err("info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(info->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (info->type == DP_NODE_QUEUE) {
 		if ((info->id.q_id < 0) || (info->id.q_id >= MAX_QUEUE)) {
-			PR_ERR("Invalid Queue ID:%d\n", info->id.q_id);
+			pr_err("Invalid Queue ID:%d\n", info->id.q_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_queue_stat[info->id.q_id].flag == PP_NODE_FREE) {
-			PR_ERR("Invalid Queue flag:%d\n",
+			pr_err("Invalid Queue flag:%d\n",
 			       priv->qos_queue_stat[info->id.q_id].flag);
 			return DP_FAILURE;
 		}
 		node_id = priv->qos_queue_stat[info->id.q_id].node_id;
 		if (qos_queue_conf_get_32(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("fail to get queue prio_wfq value!\n");
+			pr_err("fail to get queue prio_wfq value!\n");
 			return DP_FAILURE;
 		}
 
@@ -2533,18 +2533,18 @@ int dp_qos_link_prio_get_32(struct dp_node_prio *info, int flag)
 	} else if (info->type == DP_NODE_SCH) {
 		if ((info->id.sch_id < 0) ||
 		    (info->id.sch_id >= QOS_MAX_NODES)) {
-			PR_ERR("Invalid Sched ID:%d\n", info->id.sch_id);
+			pr_err("Invalid Sched ID:%d\n", info->id.sch_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_sch_stat[info->id.sch_id].p_flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Invalid Sched flag:%d\n",
+			pr_err("Invalid Sched flag:%d\n",
 			       priv->qos_sch_stat[info->id.sch_id].p_flag);
 			return DP_FAILURE;
 		}
 		if (qos_sched_conf_get_32(priv->qdev, info->id.sch_id,
 					  &sched_cfg)) {
-			PR_ERR("fail to get sched arbi and prio values!\n");
+			pr_err("fail to get sched arbi and prio values!\n");
 			return DP_FAILURE;
 		}
 
@@ -2557,7 +2557,7 @@ int dp_qos_link_prio_get_32(struct dp_node_prio *info, int flag)
 		info->prio_wfq = sched_cfg.sched_child_prop.priority;
 		return DP_SUCCESS;
 	}
-	PR_ERR("incorrect info type provided:0x%x\n", info->type);
+	pr_err("incorrect info type provided:0x%x\n", info->type);
 	return DP_FAILURE;
 }
 
@@ -2586,13 +2586,13 @@ int dp_deq_port_res_get_32(struct dp_dequeue_res *res, int flag)
 	struct pmac_port_info *port_info;
 
 	if (!res) {
-		PR_ERR("res cannot be NULL\n");
+		pr_err("res cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(res->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	port_info = get_dp_port_info(res->inst, res->dp_port);
@@ -2622,7 +2622,7 @@ int dp_deq_port_res_get_32(struct dp_dequeue_res *res, int flag)
 		if (qos_port_get_queues_32(priv->qdev,
 					   priv->deq_port_stat[k].node_id,
 					   q_ids, q_size, &q_num)) {
-			PR_ERR("qos_port_get_queues_32: port[%d/%d]\n",
+			pr_err("qos_port_get_queues_32: port[%d/%d]\n",
 			       k,
 			       priv->deq_port_stat[k].node_id);
 			return DP_FAILURE;
@@ -2639,7 +2639,7 @@ int dp_deq_port_res_get_32(struct dp_dequeue_res *res, int flag)
 			memset(&t.q_info, 0, sizeof(t.q_info));
 			if (qos_queue_info_get_32(priv->qdev,
 						  q_ids[i], &t.q_info)) {
-				PR_ERR("qos_port_info_get_32 fail:q[/%d]\n",
+				pr_err("qos_port_info_get_32 fail:q[/%d]\n",
 				       q_ids[i]);
 				continue;
 			}
@@ -2651,7 +2651,7 @@ int dp_deq_port_res_get_32(struct dp_dequeue_res *res, int flag)
 			memset(&t.q_conf, 0, sizeof(t.q_conf));
 			if (qos_queue_conf_get_32(priv->qdev,
 						  q_ids[i], &t.q_conf)) {
-				PR_ERR("qos_port_conf_get_32 fail:q[/%d]\n",
+				pr_err("qos_port_conf_get_32 fail:q[/%d]\n",
 				       q_ids[i]);
 				continue;
 			}
@@ -2665,7 +2665,7 @@ int dp_deq_port_res_get_32(struct dp_dequeue_res *res, int flag)
 					break;
 				} else if (priv->qos_sch_stat[p_id].type !=
 					   DP_NODE_SCH) {
-					PR_ERR("wrong p[/%d] type:%d\n",
+					pr_err("wrong p[/%d] type:%d\n",
 					       p_id,
 					       priv->qos_sch_stat[p_id].type);
 					break;
@@ -2677,7 +2677,7 @@ int dp_deq_port_res_get_32(struct dp_dequeue_res *res, int flag)
 				/* get next parent */
 				if (qos_sched_conf_get_32(priv->qdev, p_id,
 							  &t.sched_conf)) {
-					PR_ERR(
+					pr_err(
 					    "qos_sched_conf_get_32 %s[/%d]\n",
 					    "fail:sch", p_id);
 					break;
@@ -2706,13 +2706,13 @@ int dp_node_unlink_32(struct dp_node_link *info, int flag)
 	int i, node_id;
 
 	if (!info) {
-		PR_ERR("info cannot be NULL\n");
+		pr_err("info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(info->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -2721,7 +2721,7 @@ int dp_node_unlink_32(struct dp_node_link *info, int flag)
 		/* Need to check ACTIVE Flag */
 		if (!(priv->qos_queue_stat[info->node_id.q_id].flag &
 		    PP_NODE_ACTIVE)) {
-			PR_ERR("Wrong Queue[%d] Stat(%d):Expect ACTIVE\n",
+			pr_err("Wrong Queue[%d] Stat(%d):Expect ACTIVE\n",
 			       info->node_id.q_id,
 			       priv->qos_queue_stat[info->node_id.q_id].flag);
 		}
@@ -2730,7 +2730,7 @@ int dp_node_unlink_32(struct dp_node_link *info, int flag)
 	} else if (info->node_type == DP_NODE_SCH) {
 		if (!(priv->qos_sch_stat[info->node_id.sch_id].c_flag &
 								PP_NODE_ACTIVE))
-			PR_ERR("Wrong Sched FLAG Expect ACTIVE\n");
+			pr_err("Wrong Sched FLAG Expect ACTIVE\n");
 		if (qos_sched_conf_get_32(priv->qdev, info->node_id.sch_id,
 					  &sched_cfg))
 			return DP_FAILURE;
@@ -2780,24 +2780,24 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 	struct link_add_var *t = NULL;
 
 	if (!info) {
-		PR_ERR("info cannot be NULL\n");
+		pr_err("info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(info->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if ((!info->dp_port) && (info->dp_port != DP_PORT(info).dp_port)) {
-		PR_ERR("Fix wrong dp_port from %d to %d\n",
+		pr_err("Fix wrong dp_port from %d to %d\n",
 		       info->dp_port, DP_PORT(info).dp_port);
 		info->dp_port = DP_PORT(info).dp_port;
 	}
 	t = kzalloc(sizeof(*t), GFP_ATOMIC);
 	if (!t) {
-		PR_ERR("fail to alloc %zd bytes\n", sizeof(*t));
+		pr_err("fail to alloc %zd bytes\n", sizeof(*t));
 		return DP_FAILURE;
 	}
 	for (i = 0; i < ARRAY_SIZE(t->q_orig_block); i++) {
@@ -2815,7 +2815,7 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 		t->f_sch_auto_id = 1;
 	i = dp_qos_parent_chk(info, flag);
 	if (i == DP_FAILURE) {
-		PR_ERR("dp_qos_parent_chk fail\n");
+		pr_err("dp_qos_parent_chk fail\n");
 		goto EXIT_ERR;
 	}
 	t->parent.node_id = i;
@@ -2825,7 +2825,7 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 	/* Check parent's children limit not exceeded */
 	if (priv->qos_sch_stat[t->parent.node_id].child_num >=
 	    DP_MAX_CHILD_PER_NODE) {
-		PR_ERR("Child Num:%d is exceeding limit for Node:[%d]\n",
+		pr_err("Child Num:%d is exceeding limit for Node:[%d]\n",
 		       priv->qos_sch_stat[t->parent.node_id].child_num,
 		       t->parent.node_id);
 		goto EXIT_ERR;
@@ -2846,7 +2846,7 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 			t->node.dp_port = info->dp_port;
 			t->node.type = info->node_type;
 			if ((dp_node_alloc_32(&t->node, flag)) == DP_FAILURE) {
-				PR_ERR("dp_node_alloc_32 queue alloc fail\n");
+				pr_err("dp_node_alloc_32 queue alloc fail\n");
 				goto EXIT_ERR;
 			}
 			info->node_id = t->node.id;
@@ -2855,7 +2855,7 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 		/* add check for free flag and error */
 		if (priv->qos_queue_stat[info->node_id.q_id].flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Queue ID:%d is in Free state:0x%x\n",
+			pr_err("Queue ID:%d is in Free state:0x%x\n",
 			       info->node_id.q_id,
 			       priv->qos_queue_stat[info->node_id.q_id].flag);
 			goto EXIT_ERR;
@@ -2886,7 +2886,7 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 
 				if (node_stat_update(info->inst, t->node_id,
 						     DP_NODE_DEC)) {
-					PR_ERR("node_stat_update fail\n");
+					pr_err("node_stat_update fail\n");
 					goto EXIT_ERR;
 				}
 				/* reduce child_num in parent's global table */
@@ -2896,7 +2896,7 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 				if (node_stat_update(info->inst,
 						     PARENT(t->queue_cfg),
 						     DP_NODE_DEC | C_FLAG)) {
-					PR_ERR("node_stat_update fail\n");
+					pr_err("node_stat_update fail\n");
 					goto EXIT_ERR;
 				}
 			}
@@ -2910,7 +2910,7 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 		 *	goto EXIT_ERR;
 		 */
 		if (dp_link_set(info, t->parent.node_id, flag)) {
-			PR_ERR("dp_link_set fail to link to parent\n");
+			pr_err("dp_link_set fail to link to parent\n");
 			goto EXIT_ERR;
 		}
 	} else if (info->node_type == DP_NODE_SCH) {
@@ -2920,7 +2920,7 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 			t->node.type = info->node_type;
 
 			if ((dp_node_alloc_32(&t->node, flag)) == DP_FAILURE) {
-				PR_ERR("dp_node_alloc_32 sched alloc fail\n");
+				pr_err("dp_node_alloc_32 sched alloc fail\n");
 				goto EXIT_ERR;
 			}
 			info->node_id = t->node.id;
@@ -2933,7 +2933,7 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 		/* add check for free flag and error */
 		if (priv->qos_sch_stat[info->node_id.sch_id].p_flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Sched:%d is in Free state:0x%x\n",
+			pr_err("Sched:%d is in Free state:0x%x\n",
 			       info->node_id.sch_id,
 			       priv->qos_sch_stat[info->node_id.sch_id].p_flag);
 			goto EXIT_ERR;
@@ -2948,7 +2948,7 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 						    info->node_id.sch_id,
 						    t->queue_buf, t->queue_size,
 						    &t->queue_num)) {
-				PR_ERR("Can not get queues:%d\n",
+				pr_err("Can not get queues:%d\n",
 				       info->node_id.sch_id);
 				goto EXIT_ERR;
 			}
@@ -2967,13 +2967,13 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 			/* update flag for sch node */
 			if (node_stat_update(info->inst, info->node_id.sch_id,
 					     DP_NODE_DEC | P_FLAG)) {
-				PR_ERR("node_stat_update fail\n");
+				pr_err("node_stat_update fail\n");
 				goto EXIT_ERR;
 			}
 			/* reduce child_num in parent's global table */
 			if (node_stat_update(info->inst, PARENT_S(t->sched_cfg),
 					     DP_NODE_DEC | C_FLAG)) {
-				PR_ERR("node_stat_update fail\n");
+				pr_err("node_stat_update fail\n");
 				goto EXIT_ERR;
 			}
 		}
@@ -2985,7 +2985,7 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 		 *	goto EXIT_ERR;
 		 */
 		if (dp_link_set(info, t->parent.node_id, flag)) {
-			PR_ERR("dp_link_set failed to link to parent\n");
+			pr_err("dp_link_set failed to link to parent\n");
 			goto EXIT_ERR;
 		}
 	}
@@ -3013,7 +3013,7 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 			continue;
 		if (qos_queue_set_32(priv->qdev, t->queue_buf[i],
 				     &t->queue_cfg)) {
-			PR_ERR("qos_queue_set_32 fail for q[/%d]\n",
+			pr_err("qos_queue_set_32 fail for q[/%d]\n",
 			       t->queue_buf[i]);
 			res = DP_FAILURE;
 		}
@@ -3034,7 +3034,7 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 				 "sched remove id %d\n", t->node.id.sch_id);
 			qos_sched_remove_32(priv->qdev, t->node.id.sch_id);
 		} else {
-			PR_ERR("Unexpect node type %d\n", t->node.type);
+			pr_err("Unexpect node type %d\n", t->node.type);
 		}
 	}
 	if (t->f_parent_free) {
@@ -3047,7 +3047,7 @@ int dp_node_link_add_32(struct dp_node_link *info, int flag)
 				 "sched remove id %d\n", t->parent.node_id);
 			qos_sched_remove_32(priv->qdev, t->parent.node_id);
 		} else {
-			PR_ERR("Unexpect node type %d\n", t->node.type);
+			pr_err("Unexpect node type %d\n", t->node.type);
 		}
 	}
 
@@ -3067,35 +3067,35 @@ int dp_queue_conf_set_32(struct dp_queue_conf *cfg, int flag)
 	int node_id, res = DP_FAILURE;
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(cfg->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	conf = kzalloc(sizeof(*conf), GFP_ATOMIC);
 	if (!conf) {
-		PR_ERR("fail to alloc %zd bytes\n", sizeof(*conf));
+		pr_err("fail to alloc %zd bytes\n", sizeof(*conf));
 		return DP_FAILURE;
 	}
 
 	if ((cfg->q_id < 0) || (cfg->q_id >= MAX_QUEUE)) {
-		PR_ERR("Invalid Queue ID:%d\n", cfg->q_id);
+		pr_err("Invalid Queue ID:%d\n", cfg->q_id);
 		goto EXIT;
 	}
 	if (priv->qos_queue_stat[cfg->q_id].flag == PP_NODE_FREE) {
-		PR_ERR("Invalid Queue flag:%d\n",
+		pr_err("Invalid Queue flag:%d\n",
 		       priv->qos_queue_stat[cfg->q_id].flag);
 		goto EXIT;
 	}
 	node_id = priv->qos_queue_stat[cfg->q_id].node_id;
 
 	if (qos_queue_conf_get_32(priv->qdev, node_id, conf)) {
-		PR_ERR("qos_queue_conf_get_32 fail:%d\n", cfg->q_id);
+		pr_err("qos_queue_conf_get_32 fail:%d\n", cfg->q_id);
 		goto EXIT;
 	}
 	if (flag & (cfg->act & DP_NODE_DIS))
@@ -3114,7 +3114,7 @@ int dp_queue_conf_set_32(struct dp_queue_conf *cfg, int flag)
 		conf->wred_min_guaranteed = cfg->wred_min_guaranteed;
 		conf->wred_max_allowed = cfg->wred_max_allowed;
 	} else if (flag & (cfg->drop == DP_QUEUE_DROP_TAIL)) {
-		PR_ERR("Further check PPv4 Tail Drop Capability.\n");
+		pr_err("Further check PPv4 Tail Drop Capability.\n");
 		conf->wred_enable = 0;
 		conf->wred_min_avg_green = cfg->min_size[0];
 		conf->wred_min_avg_yellow = cfg->min_size[1];
@@ -3122,7 +3122,7 @@ int dp_queue_conf_set_32(struct dp_queue_conf *cfg, int flag)
 		conf->wred_max_allowed = cfg->wred_max_allowed;
 	}
 	if (qos_queue_set_32(priv->qdev, node_id, conf)) {
-		PR_ERR("failed to qos_queue_set_32:%d\n", cfg->q_id);
+		pr_err("failed to qos_queue_set_32:%d\n", cfg->q_id);
 		goto EXIT;
 	}
 	res = DP_SUCCESS;
@@ -3144,35 +3144,35 @@ int dp_queue_conf_get_32(struct dp_queue_conf *cfg, int flag)
 	struct hal_priv *priv;
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(cfg->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	conf = kzalloc(sizeof(*conf), GFP_ATOMIC);
 	if (!conf) {
-		PR_ERR("fail to alloc %zd bytes\n", sizeof(*conf));
+		pr_err("fail to alloc %zd bytes\n", sizeof(*conf));
 		return DP_FAILURE;
 	}
 
 	if ((cfg->q_id < 0) || (cfg->q_id >= MAX_QUEUE)) {
-		PR_ERR("Invalid Queue ID:%d\n", cfg->q_id);
+		pr_err("Invalid Queue ID:%d\n", cfg->q_id);
 		goto EXIT;
 	}
 	if (priv->qos_queue_stat[cfg->q_id].flag == PP_NODE_FREE) {
-		PR_ERR("Invalid Queue flag:%d\n",
+		pr_err("Invalid Queue flag:%d\n",
 		       priv->qos_queue_stat[cfg->q_id].flag);
 		goto EXIT;
 	}
 	node_id = priv->qos_queue_stat[cfg->q_id].node_id;
 
 	if (qos_queue_conf_get_32(priv->qdev, node_id, conf)) {
-		PR_ERR("qos_queue_conf_get_32 fail\n");
+		pr_err("qos_queue_conf_get_32 fail\n");
 		goto EXIT;
 	}
 
@@ -3225,65 +3225,65 @@ int dp_node_link_en_set_32(struct dp_node_link_enable *en, int flag)
 	int node_id;
 
 	if (!en) {
-		PR_ERR("en info cannot be NULL\n");
+		pr_err("en info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(en->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if ((en->en & DP_NODE_EN) && (en->en & DP_NODE_DIS)) {
-		PR_ERR("enable & disable cannot be set together!\n");
+		pr_err("enable & disable cannot be set together!\n");
 		return DP_FAILURE;
 	}
 	if ((en->en & DP_NODE_SUSPEND) && (en->en & DP_NODE_RESUME)) {
-		PR_ERR("suspend & resume cannot be set together!\n");
+		pr_err("suspend & resume cannot be set together!\n");
 		return DP_FAILURE;
 	}
 
 	if (en->type == DP_NODE_QUEUE) {
 		if (!(en->en & (DP_NODE_EN | DP_NODE_DIS | DP_NODE_SUSPEND |
 				    DP_NODE_RESUME))) {
-			PR_ERR("Incorrect commands provided!\n");
+			pr_err("Incorrect commands provided!\n");
 			return DP_FAILURE;
 		}
 		if ((en->id.q_id < 0) || (en->id.q_id >= MAX_QUEUE)) {
-			PR_ERR("Wrong Parameter: QID[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: QID[%d]Out Of Range\n",
 			       en->id.q_id);
 			return DP_FAILURE;
 		}
 		node_id = priv->qos_queue_stat[en->id.q_id].node_id;
 
 		if (priv->qos_queue_stat[en->id.q_id].flag == PP_NODE_FREE) {
-			PR_ERR("Node Q[%d] is not allcoated\n", en->id.q_id);
+			pr_err("Node Q[%d] is not allcoated\n", en->id.q_id);
 			return DP_FAILURE;
 		}
 		if (en->en & DP_NODE_EN) {
 			if (pp_qos_queue_unblock(priv->qdev, node_id)) {
-				PR_ERR("pp_qos_queue_unblock fail Queue[%d]\n",
+				pr_err("pp_qos_queue_unblock fail Queue[%d]\n",
 				       en->id.q_id);
 				return DP_FAILURE;
 			}
 		}
 		if (en->en & DP_NODE_DIS) {
 			if (pp_qos_queue_block(priv->qdev, node_id)) {
-				PR_ERR("pp_qos_queue_block fail Queue[%d]\n",
+				pr_err("pp_qos_queue_block fail Queue[%d]\n",
 				       en->id.q_id);
 				return DP_FAILURE;
 			}
 		}
 
 		if (qos_queue_conf_get_32(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("qos_queue_conf_get_32 fail: q[%d]\n",
+			pr_err("qos_queue_conf_get_32 fail: q[%d]\n",
 			       en->id.q_id);
 			return DP_FAILURE;
 		}
 		if (en->en & DP_NODE_EN) {
 			if (queue_cfg.blocked) {
-				PR_ERR("Incorrect value set for Queue[%d]:%d\n",
+				pr_err("Incorrect value set for Queue[%d]:%d\n",
 				       en->id.q_id,
 				       queue_cfg.blocked);
 				return DP_FAILURE;
@@ -3291,7 +3291,7 @@ int dp_node_link_en_set_32(struct dp_node_link_enable *en, int flag)
 		}
 		if (en->en & DP_NODE_DIS) {
 			if (!queue_cfg.blocked) {
-				PR_ERR("Incorrect value set for Queue[%d]:%d\n",
+				pr_err("Incorrect value set for Queue[%d]:%d\n",
 				       en->id.q_id,
 				       queue_cfg.blocked);
 				return DP_FAILURE;
@@ -3300,23 +3300,23 @@ int dp_node_link_en_set_32(struct dp_node_link_enable *en, int flag)
 
 	} else if (en->type == DP_NODE_SCH) {
 		if (!(en->en & (DP_NODE_SUSPEND | DP_NODE_RESUME))) {
-			PR_ERR("Incorrect commands provided!\n");
+			pr_err("Incorrect commands provided!\n");
 			return DP_FAILURE;
 		}
 		if ((en->id.sch_id < 0) || (en->id.sch_id >= QOS_MAX_NODES)) {
-			PR_ERR("Wrong Parameter: Sched[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: Sched[%d]Out Of Range\n",
 			       en->id.sch_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_sch_stat[en->id.sch_id].p_flag == PP_NODE_FREE) {
-			PR_ERR("Node Sched[%d] is not allcoated\n",
+			pr_err("Node Sched[%d] is not allcoated\n",
 			       en->id.sch_id);
 			return DP_FAILURE;
 		}
 
 		if (qos_sched_conf_get_32(priv->qdev, en->id.sch_id,
 					  &sched_cfg)) {
-			PR_ERR("qos_sched_conf_get_32 fail: sch[%d]\n",
+			pr_err("qos_sched_conf_get_32 fail: sch[%d]\n",
 			       en->id.sch_id);
 			return DP_FAILURE;
 		}
@@ -3324,58 +3324,58 @@ int dp_node_link_en_set_32(struct dp_node_link_enable *en, int flag)
 	} else if (en->type == DP_NODE_PORT) {
 		if (!(en->en & (DP_NODE_EN | DP_NODE_DIS | DP_NODE_SUSPEND |
 				    DP_NODE_RESUME))) {
-			PR_ERR("Incorrect commands provided!\n");
+			pr_err("Incorrect commands provided!\n");
 			return DP_FAILURE;
 		}
 		if ((en->id.cqm_deq_port < 0) ||
 		    (en->id.cqm_deq_port >= MAX_CQM_DEQ)) {
-			PR_ERR("Wrong Parameter: Port[%d]Out Of Range\n",
+			pr_err("Wrong Parameter: Port[%d]Out Of Range\n",
 			       en->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
 		if (priv->deq_port_stat[en->id.cqm_deq_port].flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Node Port[%d] is not allcoated\n",
+			pr_err("Node Port[%d] is not allcoated\n",
 			       en->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
 		node_id = priv->deq_port_stat[en->id.cqm_deq_port].node_id;
 		if (en->en & DP_NODE_EN) {
 			if (pp_qos_port_unblock(priv->qdev, node_id)) {
-				PR_ERR("pp_qos_port_unblock fail Port[%d]\n",
+				pr_err("pp_qos_port_unblock fail Port[%d]\n",
 				       en->id.cqm_deq_port);
 				return DP_FAILURE;
 			}
 		}
 		if (en->en & DP_NODE_DIS) {
 			if (pp_qos_port_block(priv->qdev, node_id)) {
-				PR_ERR("pp_qos_port_block fail Port[%d]\n",
+				pr_err("pp_qos_port_block fail Port[%d]\n",
 				       en->id.cqm_deq_port);
 				return DP_FAILURE;
 			}
 		}
 		if (en->en & DP_NODE_SUSPEND) {
 			if (pp_qos_port_disable(priv->qdev, node_id)) {
-				PR_ERR("pp_qos_port_disable fail Port[%d]\n",
+				pr_err("pp_qos_port_disable fail Port[%d]\n",
 				       en->id.cqm_deq_port);
 				return DP_FAILURE;
 			}
 		}
 		if (en->en & DP_NODE_RESUME) {
 			if (pp_qos_port_enable(priv->qdev, node_id)) {
-				PR_ERR("pp_qos_port_enable fail Port[%d]\n",
+				pr_err("pp_qos_port_enable fail Port[%d]\n",
 				       en->id.cqm_deq_port);
 				return DP_FAILURE;
 			}
 		}
 		if (qos_port_conf_get_32(priv->qdev, node_id, &port_cfg)) {
-			PR_ERR("qos_port_conf_get_32 fail: port[%d]\n",
+			pr_err("qos_port_conf_get_32 fail: port[%d]\n",
 			       en->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
 		if (en->en & DP_NODE_SUSPEND) {
 			if (!port_cfg.disable) {
-				PR_ERR("Incorrect value set for Port[%d]:%d\n",
+				pr_err("Incorrect value set for Port[%d]:%d\n",
 				       en->id.cqm_deq_port,
 				       port_cfg.disable);
 				return DP_FAILURE;
@@ -3383,7 +3383,7 @@ int dp_node_link_en_set_32(struct dp_node_link_enable *en, int flag)
 		}
 		if (en->en & DP_NODE_RESUME) {
 			if (port_cfg.disable) {
-				PR_ERR("Incorrect value set for Port[%d]:%d\n",
+				pr_err("Incorrect value set for Port[%d]:%d\n",
 				       en->id.cqm_deq_port,
 				       port_cfg.disable);
 				return DP_FAILURE;
@@ -3403,11 +3403,11 @@ int dp_node_link_en_get_32(struct dp_node_link_enable *en, int flag)
 	struct hal_priv *priv = HAL(en->inst);
 
 	if (!priv || !priv->qdev) {
-		PR_ERR("priv or priv->qdev NULL\n");
+		pr_err("priv or priv->qdev NULL\n");
 		return DP_FAILURE;
 	}
 	if (!en) {
-		PR_ERR("en info NULL\n");
+		pr_err("en info NULL\n");
 		return DP_FAILURE;
 	}
 	if (en->type == DP_NODE_QUEUE) {
@@ -3417,7 +3417,7 @@ int dp_node_link_en_get_32(struct dp_node_link_enable *en, int flag)
 			 "en->id.q_id=%d\n", en->id.q_id);
 		node_id = priv->qos_queue_stat[en->id.q_id].node_id;
 		if (qos_queue_conf_get_32(priv->qdev, node_id, &q_conf)) {
-			PR_ERR("qos_queue_conf_get_32 fail: q[%d]\n",
+			pr_err("qos_queue_conf_get_32 fail: q[%d]\n",
 			       en->id.q_id);
 			return DP_FAILURE;
 		}
@@ -3432,7 +3432,7 @@ int dp_node_link_en_get_32(struct dp_node_link_enable *en, int flag)
 			 "en->id.sch_id=%d\n", en->id.sch_id);
 		if (qos_sched_conf_get_32(priv->qdev, en->id.sch_id,
 					  &sched_conf)) {
-			PR_ERR("qos_sched_conf_get_32 fail: sched[/%d]\n",
+			pr_err("qos_sched_conf_get_32 fail: sched[/%d]\n",
 			       en->id.sch_id);
 			return DP_FAILURE;
 		}
@@ -3444,7 +3444,7 @@ int dp_node_link_en_get_32(struct dp_node_link_enable *en, int flag)
 			 "en->id.cqm_deq_port=%d\n", en->id.cqm_deq_port);
 		node_id = priv->deq_port_stat[en->id.cqm_deq_port].node_id;
 		if (qos_port_conf_get_32(priv->qdev, node_id, &p_conf)) {
-			PR_ERR("qos_queue_conf_get_32 fail: port[%d]\n",
+			pr_err("qos_queue_conf_get_32 fail: port[%d]\n",
 			       en->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
@@ -3468,24 +3468,24 @@ int dp_link_get_32(struct dp_qos_link *cfg, int flag)
 	int i, node_id;
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(cfg->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	node_id = priv->qos_queue_stat[cfg->q_id].node_id;
 
 	if (!(priv->qos_queue_stat[cfg->q_id].flag & PP_NODE_ACTIVE)) {
-		PR_ERR("Incorrect queue:%d state:expect ACTIV\n", cfg->q_id);
+		pr_err("Incorrect queue:%d state:expect ACTIV\n", cfg->q_id);
 		return DP_FAILURE;
 	}
 
 	if (qos_queue_conf_get_32(priv->qdev, node_id, &queue_cfg)) {
-		PR_ERR("failed to qos_queue_conf_get_32\n");
+		pr_err("failed to qos_queue_conf_get_32\n");
 		return DP_FAILURE;
 	}
 	cfg->q_arbi = get_parent_arbi(cfg->inst, node_id, 0);
@@ -3509,7 +3509,7 @@ int dp_link_get_32(struct dp_qos_link *cfg, int flag)
 				priv->qos_sch_stat[node_id].parent.node_id;
 			if (qos_sched_conf_get_32(priv->qdev, cfg->sch[i].id,
 						  &sched_cfg)) {
-				PR_ERR("dp_link_get:sched[/%d] conf get fail\n",
+				pr_err("dp_link_get:sched[/%d] conf get fail\n",
 				       cfg->sch[i].id);
 				return DP_FAILURE;
 			}
@@ -3544,12 +3544,12 @@ int dp_link_add_32(struct dp_qos_link *cfg, int flag)
 	struct f f_sch_free[DP_MAX_SCH_LVL] = {0};
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (cfg->n_sch_lvl > DP_MAX_SCH_LVL) {
-		PR_ERR("Incorrect sched_lvl:%s(%d) > %s(%d)\n",
+		pr_err("Incorrect sched_lvl:%s(%d) > %s(%d)\n",
 		       "cfg->n_sch_lvl", cfg->n_sch_lvl,
 		       "DP_MAX_SCH_LVL", DP_MAX_SCH_LVL);
 		return DP_FAILURE;
@@ -3578,7 +3578,7 @@ int dp_link_add_32(struct dp_qos_link *cfg, int flag)
 		f_sch_free[cfg->n_sch_lvl - 1].flag = 1;
 
 		if (dp_node_link_add_32(&info, flag)) {
-			PR_ERR("Failed to link Sch:%d to Port:%d\n",
+			pr_err("Failed to link Sch:%d to Port:%d\n",
 			       cfg->sch[cfg->n_sch_lvl - 1].id,
 			       cfg->cqm_deq_port);
 			goto EXIT;
@@ -3601,7 +3601,7 @@ int dp_link_add_32(struct dp_qos_link *cfg, int flag)
 			f_sch_free[i].flag = 1;
 
 			if (dp_node_link_add_32(&info, flag)) {
-				PR_ERR("Failed to link Sch:%d to Sch:%d\n",
+				pr_err("Failed to link Sch:%d to Sch:%d\n",
 				       cfg->sch[i].id, cfg->sch[i + 1].id);
 				goto EXIT;
 			}
@@ -3620,7 +3620,7 @@ int dp_link_add_32(struct dp_qos_link *cfg, int flag)
 		info.prio_wfq = cfg->sch[0].prio_wfq;
 
 		if (dp_node_link_add_32(&info, flag)) {
-			PR_ERR("Failed to link Q:%d to Sch:%d\n",
+			pr_err("Failed to link Q:%d to Sch:%d\n",
 			       cfg->q_id, cfg->sch[0].id);
 			f_q_free = 1;
 			goto EXIT;
@@ -3635,7 +3635,7 @@ int dp_link_add_32(struct dp_qos_link *cfg, int flag)
 		info.prio_wfq = cfg->q_prio_wfq;
 
 		if (dp_node_link_add_32(&info, flag)) {
-			PR_ERR("Failed to link Q:%d to Port:%d\n",
+			pr_err("Failed to link Q:%d to Port:%d\n",
 			       cfg->q_id, cfg->cqm_deq_port);
 			f_q_free = 1;
 			goto EXIT;
@@ -3660,7 +3660,7 @@ int dp_link_add_32(struct dp_qos_link *cfg, int flag)
 		/* sch provided by caller move it to ALLOC */
 		if (node_stat_update(info.inst, f_sch_free[i].sch_id,
 				     DP_NODE_DEC)) {
-			PR_ERR("Failed to %s sched:%d DP_NODE_DEC\n",
+			pr_err("Failed to %s sched:%d DP_NODE_DEC\n",
 			       "node_stat_update",
 			       f_sch_free[i].sch_id);
 			continue;
@@ -3679,7 +3679,7 @@ int dp_link_add_32(struct dp_qos_link *cfg, int flag)
 		}
 		/* queue provided by caller move it to ALLOC */
 		if (node_stat_update(info.inst, cfg->q_id, DP_NODE_DEC)) {
-			PR_ERR("Failed to update stat qid %d DP_NODE_DEC\n",
+			pr_err("Failed to update stat qid %d DP_NODE_DEC\n",
 			       cfg->q_id);
 			return DP_FAILURE;
 		}
@@ -3703,30 +3703,30 @@ int dp_shaper_conf_set_32(struct dp_shaper_conf *cfg, int flag)
 	u32 bw_limit;
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(cfg->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (cfg->type == DP_NODE_QUEUE) {
 		if ((cfg->id.q_id < 0) || (cfg->id.q_id >= MAX_QUEUE)) {
-			PR_ERR("Invalid Queue ID:%d\n", cfg->id.q_id);
+			pr_err("Invalid Queue ID:%d\n", cfg->id.q_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_queue_stat[cfg->id.q_id].flag == PP_NODE_FREE) {
-			PR_ERR("Invalid Queue flag:%d\n",
+			pr_err("Invalid Queue flag:%d\n",
 			       priv->qos_queue_stat[cfg->id.q_id].flag);
 			return DP_FAILURE;
 		}
 		node_id = priv->qos_queue_stat[cfg->id.q_id].node_id;
 
 		if (qos_queue_conf_get_32(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("qos_queue_conf_get_32 fail:%d\n", cfg->id.q_id);
+			pr_err("qos_queue_conf_get_32 fail:%d\n", cfg->id.q_id);
 			return DP_FAILURE;
 		}
 
@@ -3735,7 +3735,7 @@ int dp_shaper_conf_set_32(struct dp_shaper_conf *cfg, int flag)
 			res = limit_dp2pp(cfg->cir, &bw_limit);
 
 			if (res == DP_FAILURE) {
-				PR_ERR("Wrong dp shaper limit:%u\n", cfg->cir);
+				pr_err("Wrong dp shaper limit:%u\n", cfg->cir);
 				return DP_FAILURE;
 			}
 			queue_cfg.common_prop.bandwidth_limit = bw_limit;
@@ -3743,30 +3743,30 @@ int dp_shaper_conf_set_32(struct dp_shaper_conf *cfg, int flag)
 			   (cfg->cmd == DP_SHAPER_CMD_DISABLE)) {
 			queue_cfg.common_prop.bandwidth_limit = 0;
 		} else {
-			PR_ERR("Incorrect command provided:%d\n", cfg->cmd);
+			pr_err("Incorrect command provided:%d\n", cfg->cmd);
 			return DP_FAILURE;
 		}
 
 		if (qos_queue_set_32(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("qos_queue_set_32 fail:%d\n", cfg->id.q_id);
+			pr_err("qos_queue_set_32 fail:%d\n", cfg->id.q_id);
 			return DP_FAILURE;
 		}
 		return DP_SUCCESS;
 	} else if (cfg->type == DP_NODE_SCH) {
 		if ((cfg->id.sch_id < 0) || (cfg->id.sch_id >= QOS_MAX_NODES)) {
-			PR_ERR("Invalid Sched ID:%d\n", cfg->id.sch_id);
+			pr_err("Invalid Sched ID:%d\n", cfg->id.sch_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_sch_stat[cfg->id.sch_id].p_flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Invalid Sched flag:%d\n",
+			pr_err("Invalid Sched flag:%d\n",
 			       priv->qos_sch_stat[cfg->id.sch_id].p_flag);
 			return DP_FAILURE;
 		}
 
 		if (qos_sched_conf_get_32(priv->qdev, cfg->id.sch_id,
 					  &sched_cfg)) {
-			PR_ERR("qos_sched_conf_get_32 fail:%d\n",
+			pr_err("qos_sched_conf_get_32 fail:%d\n",
 			       cfg->id.sch_id);
 			return DP_FAILURE;
 		}
@@ -3776,7 +3776,7 @@ int dp_shaper_conf_set_32(struct dp_shaper_conf *cfg, int flag)
 			res = limit_dp2pp(cfg->cir, &bw_limit);
 
 			if (res == DP_FAILURE) {
-				PR_ERR("Wrong dp shaper limit:%u\n", cfg->cir);
+				pr_err("Wrong dp shaper limit:%u\n", cfg->cir);
 				return DP_FAILURE;
 			}
 			sched_cfg.common_prop.bandwidth_limit = bw_limit;
@@ -3784,31 +3784,31 @@ int dp_shaper_conf_set_32(struct dp_shaper_conf *cfg, int flag)
 			   (cfg->cmd == DP_SHAPER_CMD_DISABLE)) {
 			sched_cfg.common_prop.bandwidth_limit = 0;
 		} else {
-			PR_ERR("Incorrect command provided:%d\n", cfg->cmd);
+			pr_err("Incorrect command provided:%d\n", cfg->cmd);
 			return DP_FAILURE;
 		}
 
 		if (qos_sched_set_32(priv->qdev, cfg->id.sch_id, &sched_cfg)) {
-			PR_ERR("qos_sched_set_32 fail:%d\n", cfg->id.sch_id);
+			pr_err("qos_sched_set_32 fail:%d\n", cfg->id.sch_id);
 			return DP_FAILURE;
 		}
 		return DP_SUCCESS;
 	} else if (cfg->type == DP_NODE_PORT) {
 		if ((cfg->id.cqm_deq_port < 0) ||
 		    (cfg->id.cqm_deq_port >= MAX_CQM_DEQ)) {
-			PR_ERR("Invalid Port ID:%d\n", cfg->id.cqm_deq_port);
+			pr_err("Invalid Port ID:%d\n", cfg->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
 		if (priv->deq_port_stat[cfg->id.cqm_deq_port].flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Invalid Port flag:%d\n",
+			pr_err("Invalid Port flag:%d\n",
 			       priv->deq_port_stat[cfg->id.cqm_deq_port].flag);
 			return DP_FAILURE;
 		}
 		node_id = priv->deq_port_stat[cfg->id.cqm_deq_port].node_id;
 
 		if (qos_port_conf_get_32(priv->qdev, node_id, &port_cfg)) {
-			PR_ERR("qos_port_conf_get_32 fail:%d\n",
+			pr_err("qos_port_conf_get_32 fail:%d\n",
 			       cfg->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
@@ -3818,7 +3818,7 @@ int dp_shaper_conf_set_32(struct dp_shaper_conf *cfg, int flag)
 			res = limit_dp2pp(cfg->cir, &bw_limit);
 
 			if (res == DP_FAILURE) {
-				PR_ERR("Wrong dp shaper limit:%u\n", cfg->cir);
+				pr_err("Wrong dp shaper limit:%u\n", cfg->cir);
 				return DP_FAILURE;
 			}
 			port_cfg.common_prop.bandwidth_limit = bw_limit;
@@ -3826,18 +3826,18 @@ int dp_shaper_conf_set_32(struct dp_shaper_conf *cfg, int flag)
 			   (cfg->cmd == DP_SHAPER_CMD_DISABLE)) {
 			port_cfg.common_prop.bandwidth_limit = 0;
 		} else {
-			PR_ERR("Incorrect command provided:%d\n", cfg->cmd);
+			pr_err("Incorrect command provided:%d\n", cfg->cmd);
 			return DP_FAILURE;
 		}
 
 		if (qos_port_set_32(priv->qdev, node_id, &port_cfg)) {
-			PR_ERR("qos_port_set_32 fail:%d\n",
+			pr_err("qos_port_set_32 fail:%d\n",
 			       cfg->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
 		return DP_SUCCESS;
 	}
-	PR_ERR("Unkonwn type provided:0x%x\n", cfg->type);
+	pr_err("Unkonwn type provided:0x%x\n", cfg->type);
 	return DP_FAILURE;
 }
 
@@ -3857,55 +3857,55 @@ int dp_shaper_conf_get_32(struct dp_shaper_conf *cfg, int flag)
 	u32 bw_limit;
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(cfg->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (cfg->type == DP_NODE_QUEUE) {
 		if ((cfg->id.q_id < 0) || (cfg->id.q_id >= MAX_QUEUE)) {
-			PR_ERR("Invalid Queue ID:%d\n", cfg->id.q_id);
+			pr_err("Invalid Queue ID:%d\n", cfg->id.q_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_queue_stat[cfg->id.q_id].flag == PP_NODE_FREE) {
-			PR_ERR("Invalid Queue flag:%d\n",
+			pr_err("Invalid Queue flag:%d\n",
 			       priv->qos_queue_stat[cfg->id.q_id].flag);
 			return DP_FAILURE;
 		}
 		node_id = priv->qos_queue_stat[cfg->id.q_id].node_id;
 
 		if (qos_queue_conf_get_32(priv->qdev, node_id, &queue_cfg)) {
-			PR_ERR("qos_queue_conf_get_32 fail:%d\n", cfg->id.q_id);
+			pr_err("qos_queue_conf_get_32 fail:%d\n", cfg->id.q_id);
 			return DP_FAILURE;
 		}
 		res = limit_pp2dp(queue_cfg.common_prop.bandwidth_limit,
 				  &bw_limit);
 
 		if (res == DP_FAILURE) {
-			PR_ERR("Wrong pp shaper limit:%u\n",
+			pr_err("Wrong pp shaper limit:%u\n",
 			       queue_cfg.common_prop.bandwidth_limit);
 			return DP_FAILURE;
 		}
 	} else if (cfg->type == DP_NODE_SCH) {
 		if ((cfg->id.sch_id < 0) || (cfg->id.sch_id >= QOS_MAX_NODES)) {
-			PR_ERR("Invalid Sched ID:%d\n", cfg->id.sch_id);
+			pr_err("Invalid Sched ID:%d\n", cfg->id.sch_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_sch_stat[cfg->id.sch_id].p_flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Invalid Sched flag:%d\n",
+			pr_err("Invalid Sched flag:%d\n",
 			       priv->qos_sch_stat[cfg->id.sch_id].p_flag);
 			return DP_FAILURE;
 		}
 
 		if (qos_sched_conf_get_32(priv->qdev, cfg->id.sch_id,
 					  &sched_cfg)) {
-			PR_ERR("qos_sched_conf_get_32 fail:%d\n",
+			pr_err("qos_sched_conf_get_32 fail:%d\n",
 			       cfg->id.sch_id);
 			return DP_FAILURE;
 		}
@@ -3914,25 +3914,25 @@ int dp_shaper_conf_get_32(struct dp_shaper_conf *cfg, int flag)
 				  &bw_limit);
 
 		if (res == DP_FAILURE) {
-			PR_ERR("Wrong pp shaper limit:%u\n",
+			pr_err("Wrong pp shaper limit:%u\n",
 			       sched_cfg.common_prop.bandwidth_limit);
 			return DP_FAILURE;
 		}
 	} else if (cfg->type == DP_NODE_PORT) {
 		if ((cfg->id.cqm_deq_port < 0) ||
 		    (cfg->id.cqm_deq_port >= MAX_CQM_DEQ)) {
-			PR_ERR("Invalid Port ID:%d\n", cfg->id.cqm_deq_port);
+			pr_err("Invalid Port ID:%d\n", cfg->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
 		if (priv->deq_port_stat[cfg->id.cqm_deq_port].flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Invalid Port flag:%d\n",
+			pr_err("Invalid Port flag:%d\n",
 			       priv->deq_port_stat[cfg->id.cqm_deq_port].flag);
 			return DP_FAILURE;
 		}
 		node_id = priv->deq_port_stat[cfg->id.cqm_deq_port].node_id;
 		if (qos_port_conf_get_32(priv->qdev, node_id, &port_cfg)) {
-			PR_ERR("qos_port_conf_get_32 fail:%d\n",
+			pr_err("qos_port_conf_get_32 fail:%d\n",
 			       cfg->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
@@ -3940,12 +3940,12 @@ int dp_shaper_conf_get_32(struct dp_shaper_conf *cfg, int flag)
 				  &bw_limit);
 
 		if (res == DP_FAILURE) {
-			PR_ERR("Wrong pp shaper limit:%u\n",
+			pr_err("Wrong pp shaper limit:%u\n",
 			       port_cfg.common_prop.bandwidth_limit);
 			return DP_FAILURE;
 		}
 	} else {
-		PR_ERR("Unkonwn type provided:0x%x\n", cfg->type);
+		pr_err("Unkonwn type provided:0x%x\n", cfg->type);
 		return DP_FAILURE;
 	}
 
@@ -3965,28 +3965,28 @@ int dp_queue_map_get_32(struct dp_queue_map_get *cfg, int flag)
 	int res = DP_SUCCESS;
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(cfg->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	if ((cfg->q_id < 0) || (cfg->q_id >= MAX_QUEUE)) {
-		PR_ERR("Invalid Queue ID:%d\n", cfg->q_id);
+		pr_err("Invalid Queue ID:%d\n", cfg->q_id);
 		return DP_FAILURE;
 	}
 	if (priv->qos_queue_stat[cfg->q_id].flag == PP_NODE_FREE) {
-		PR_ERR("Invalid Queue flag:%d\n",
+		pr_err("Invalid Queue flag:%d\n",
 		       priv->qos_queue_stat[cfg->q_id].flag);
 		return DP_FAILURE;
 	}
 
 	if (cbm_queue_map_get(cfg->inst, cfg->q_id, cfg->egflag, &num_entry,
 			      &qmap_entry, 0)) {
-		PR_ERR("cbm_queue_map_get fail: qid=%d egflag=%d\n",
+		pr_err("cbm_queue_map_get fail: qid=%d egflag=%d\n",
 		       cfg->q_id, cfg->egflag);
 		return DP_FAILURE;
 	}
@@ -3997,7 +3997,7 @@ int dp_queue_map_get_32(struct dp_queue_map_get *cfg, int flag)
 		DP_DEBUG(DP_DBG_FLAG_QOS,
 			 "queue map entry returned null value\n");
 		if (num_entry) {
-			PR_ERR("num_entry is not null:%d\n", num_entry);
+			pr_err("num_entry is not null:%d\n", num_entry);
 			res = DP_FAILURE;
 		}
 		goto EXIT;
@@ -4038,21 +4038,21 @@ int dp_queue_map_set_32(struct dp_queue_map_set *cfg, int flag)
 	u32 cqm_flags = 0;
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(cfg->inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	if ((cfg->q_id < 0) || (cfg->q_id >= MAX_QUEUE)) {
-		PR_ERR("Invalid Queue ID:%d\n", cfg->q_id);
+		pr_err("Invalid Queue ID:%d\n", cfg->q_id);
 		return DP_FAILURE;
 	}
 	if (priv->qos_queue_stat[cfg->q_id].flag == PP_NODE_FREE) {
-		PR_ERR("Invalid Queue flag:%d\n",
+		pr_err("Invalid Queue flag:%d\n",
 		       priv->qos_queue_stat[cfg->q_id].flag);
 		return DP_FAILURE;
 	}
@@ -4091,7 +4091,7 @@ int dp_queue_map_set_32(struct dp_queue_map_set *cfg, int flag)
 	}
 
 	if (cbm_queue_map_set(cfg->inst, cfg->q_id, &qmap_cfg, cqm_flags)) {
-		PR_ERR("cbm_queue_map_set fail for Q:%d\n", cfg->q_id);
+		pr_err("cbm_queue_map_set fail for Q:%d\n", cfg->q_id);
 		return DP_FAILURE;
 	}
 	return DP_SUCCESS;
@@ -4114,7 +4114,7 @@ int get_sch_level_32(int inst, int pid, int flag)
 
 	priv = HAL(inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -4138,13 +4138,13 @@ int dp_qos_level_get_32(struct dp_qos_level *dp, int flag)
 	u16 i, id, pid, lvl_x = 0;
 
 	if (!dp) {
-		PR_ERR("dp cannot be NULL\n");
+		pr_err("dp cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	dp->max_sch_lvl = 0;
 	priv = HAL(dp->inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -4192,7 +4192,7 @@ int ppv4_queue_port_example(int inst, int dp_port, int t_cont, int q_node)
 	/* Allocate qos dequeue port's node id via cqm_deq_port */
 	rc = qos_port_allocate_32(priv->qdev, cqm_deq_port, &qos_port_node);
 	if (rc) {
-		PR_ERR("failed to qos_port_allocate_32\n");
+		pr_err("failed to qos_port_allocate_32\n");
 		return DP_FAILURE;
 	}
 
@@ -4217,7 +4217,7 @@ int ppv4_queue_port_example(int inst, int dp_port, int t_cont, int q_node)
 #endif
 	rc = qos_port_set_32(priv->qdev, qos_port_node, &port_cfg);
 	if (rc) {
-		PR_ERR("failed to qos_port_set_32\n");
+		pr_err("failed to qos_port_set_32\n");
 		qos_port_remove_32(priv->qdev, qos_port_node);
 		return DP_FAILURE;
 	}
@@ -4233,7 +4233,7 @@ int ppv4_queue_port_example(int inst, int dp_port, int t_cont, int q_node)
 #endif
 	rc = qos_queue_set_32(priv->qdev, q_node, &queue_cfg);
 	if (rc) {
-		PR_ERR("failed to qos_queue_set_32\n");
+		pr_err("failed to qos_queue_set_32\n");
 		qos_port_remove_32(priv->qdev, qos_port_node);
 		return DP_FAILURE;
 	}
@@ -4266,7 +4266,7 @@ int ppv4_queue_scheduler(int inst, int dp_port, int t_cont, int q_node,
 	/* Allocate qos dequeue port's node id via cqm_deq_port */
 	rc = qos_port_allocate_32(priv->qdev, cqm_deq_port, &qos_port_node);
 	if (rc) {
-		PR_ERR("failed to qos_port_allocate_32\n");
+		pr_err("failed to qos_port_allocate_32\n");
 		return DP_FAILURE;
 	}
 
@@ -4289,7 +4289,7 @@ int ppv4_queue_scheduler(int inst, int dp_port, int t_cont, int q_node,
 #endif
 	rc = qos_port_set_32(priv->qdev, qos_port_node, &port_cfg);
 	if (rc) {
-		PR_ERR("failed to qos_port_set_32\n");
+		pr_err("failed to qos_port_set_32\n");
 		qos_port_remove_32(priv->qdev, qos_port_node);
 		return DP_FAILURE;
 	}
@@ -4305,7 +4305,7 @@ int ppv4_queue_scheduler(int inst, int dp_port, int t_cont, int q_node,
 #endif
 	rc = qos_queue_set_32(priv->qdev, q_node, &queue_cfg);
 	if (rc) {
-		PR_ERR("failed to qos_queue_set_32\n");
+		pr_err("failed to qos_queue_set_32\n");
 		qos_port_remove_32(priv->qdev, qos_port_node);
 		return DP_FAILURE;
 	}
@@ -4315,7 +4315,7 @@ int ppv4_queue_scheduler(int inst, int dp_port, int t_cont, int q_node,
 	sched_cfg.sched_child_prop.parent = sch_node2;
 	rc = qos_sched_set_32(priv->qdev, sch_node1, &sched_cfg);
 	if (rc) {
-		PR_ERR("failed to qos_sched_set_32\n");
+		pr_err("failed to qos_sched_set_32\n");
 		qos_port_remove_32(priv->qdev, qos_port_node);
 		return DP_FAILURE;
 	}
@@ -4325,7 +4325,7 @@ int ppv4_queue_scheduler(int inst, int dp_port, int t_cont, int q_node,
 	sched_cfg.sched_child_prop.parent = qos_port_node;
 	rc = qos_sched_set_32(priv->qdev, sch_node2, &sched_cfg);
 	if (rc) {
-		PR_ERR("failed to qos_sched_set_32\n");
+		pr_err("failed to qos_sched_set_32\n");
 		qos_port_remove_32(priv->qdev, qos_port_node);
 		return DP_FAILURE;
 	}
@@ -4367,24 +4367,24 @@ int dp_children_get_32(struct dp_node_child *cfg, int flag)
 	struct hal_priv *priv;
 
 	if (!cfg) {
-		PR_ERR("cfg cannot be NULL\n");
+		pr_err("cfg cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(cfg->inst);
 	cfg->num = 0;
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
 	if (cfg->type == DP_NODE_SCH) {
 		if ((cfg->id.sch_id < 0) || (cfg->id.sch_id >= QOS_MAX_NODES)) {
-			PR_ERR("Invalid Sched ID:%d\n", cfg->id.sch_id);
+			pr_err("Invalid Sched ID:%d\n", cfg->id.sch_id);
 			return DP_FAILURE;
 		}
 		if (priv->qos_sch_stat[cfg->id.sch_id].c_flag == PP_NODE_FREE) {
-			PR_ERR("Invalid Sched flag:0x%x\n",
+			pr_err("Invalid Sched flag:0x%x\n",
 			       priv->qos_sch_stat[cfg->id.sch_id].c_flag);
 			return DP_FAILURE;
 		}
@@ -4393,19 +4393,19 @@ int dp_children_get_32(struct dp_node_child *cfg, int flag)
 	} else if (cfg->type == DP_NODE_PORT) {
 		if ((cfg->id.cqm_deq_port < 0) ||
 		    (cfg->id.cqm_deq_port >= MAX_CQM_DEQ)) {
-			PR_ERR("Invalid Port ID:%d\n", cfg->id.cqm_deq_port);
+			pr_err("Invalid Port ID:%d\n", cfg->id.cqm_deq_port);
 			return DP_FAILURE;
 		}
 		if (priv->deq_port_stat[cfg->id.cqm_deq_port].flag ==
 		    PP_NODE_FREE) {
-			PR_ERR("Invalid Port flag:0x%x\n",
+			pr_err("Invalid Port flag:0x%x\n",
 			       priv->deq_port_stat[cfg->id.cqm_deq_port].flag);
 			return DP_FAILURE;
 		}
 		node_id = priv->deq_port_stat[cfg->id.cqm_deq_port].node_id;
 
 	} else {
-		PR_ERR("Unkonwn type provided:0x%x\n", cfg->type);
+		pr_err("Unkonwn type provided:0x%x\n", cfg->type);
 		return DP_FAILURE;
 	}
 	if (!priv->qos_sch_stat[node_id].child_num)
@@ -4417,7 +4417,7 @@ int dp_children_get_32(struct dp_node_child *cfg, int flag)
 	if (cfg->num == res)
 		return DP_SUCCESS;
 
-	PR_ERR("child_num:[%d] not matched to res:[%d] for Node:%d\n",
+	pr_err("child_num:[%d] not matched to res:[%d] for Node:%d\n",
 	       cfg->num, res, cfg->id.sch_id);
 	return DP_FAILURE;
 }
@@ -4441,7 +4441,7 @@ int dp_node_reserve_32(int inst, int ep, struct dp_port_data *data, int flags)
 #endif
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -4469,7 +4469,7 @@ int dp_node_reserve_32(int inst, int ep, struct dp_port_data *data, int flags)
 	for (i = 0; i < data->num_resv_q; i++) {
 		if (qos_queue_allocate_32(priv->qdev, &id)) {
 			res = DP_FAILURE;
-			PR_ERR("qos_queue_allocate_32 failed\n");
+			pr_err("qos_queue_allocate_32 failed\n");
 			goto FREE_EXIT;
 		}
 		DP_DEBUG(DP_DBG_FLAG_QOS,
@@ -4481,7 +4481,7 @@ int dp_node_reserve_32(int inst, int ep, struct dp_port_data *data, int flags)
 		q_conf.queue_child_prop.parent = priv->ppv4_drop_p;
 		if (qos_queue_set_32(priv->qdev, id, &q_conf)) {
 			res = DP_FAILURE;
-			PR_ERR(
+			pr_err(
 			    "qos_queue_set_32 fail for queue=%d to parent=%d\n",
 			    id, q_conf.queue_child_prop.parent);
 			goto FREE_EXIT;
@@ -4493,7 +4493,7 @@ int dp_node_reserve_32(int inst, int ep, struct dp_port_data *data, int flags)
 		if (qos_queue_info_get_32(priv->qdev, id, &info)) {
 			qos_queue_remove_32(priv->qdev, id);
 			res = DP_FAILURE;
-			PR_ERR("qos_queue_info_get_32: %d\n", id);
+			pr_err("qos_queue_info_get_32: %d\n", id);
 			goto FREE_EXIT;
 		}
 		resv_q[i].id = id;
@@ -4521,7 +4521,7 @@ int dp_node_reserve_32(int inst, int ep, struct dp_port_data *data, int flags)
 		for (i = 0; i < data->num_resv_sched; i++) {
 			if (qos_sched_allocate_32(priv->qdev, &id)) {
 				res = DP_FAILURE;
-				PR_ERR("qos_queue_allocate_32 failed\n");
+				pr_err("qos_queue_allocate_32 failed\n");
 				goto FREE_EXIT;
 			}
 			DP_DEBUG(DP_DBG_FLAG_QOS,
@@ -4561,7 +4561,7 @@ int dp_get_q_logic_32(int inst, int qid)
 	struct hal_priv *priv = HAL(inst);
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return PP_QOS_INVALID_ID;
 	}
 	return pp_qos_queue_id_get(priv->qdev, qid);
@@ -4573,7 +4573,7 @@ int dp_get_queue_logic_32(struct dp_qos_q_logic *cfg, int flag)
 	int res = DP_SUCCESS;
 
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	cfg->q_logic_id = dp_get_q_logic_32(cfg->inst, cfg->q_id);
@@ -4592,18 +4592,18 @@ int dp_qos_global_info_get_32(struct dp_qos_cfg_info *info, int flag)
 	unsigned int quanta = 0;
 
 	if (!info) {
-		PR_ERR("info cannot be NULL\n");
+		pr_err("info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(info->inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	/* TODO Need to add later once PP QOS has this prototype */
 	#if 0
 	if (pp_qos_get_quanta(priv->qdev, &quanta)) {
-		PR_ERR("failed pp_qos_get_quanta\n");
+		pr_err("failed pp_qos_get_quanta\n");
 		return DP_FAILURE;
 	}
 	#endif
@@ -4624,25 +4624,25 @@ int dp_qos_port_conf_set_32(struct dp_port_cfg_info *info, int flag)
 	int node_id;
 
 	if (!info) {
-		PR_ERR("info cannot be NULL\n");
+		pr_err("info cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	priv = HAL(info->inst);
 	if (!priv) {
-		PR_ERR("priv cannot be NULL\n");
+		pr_err("priv cannot be NULL\n");
 		return DP_FAILURE;
 	}
 	node_id = priv->deq_port_stat[info->pid].node_id;
 	DP_DEBUG(DP_DBG_FLAG_QOS, "%s cqm_deq:%d, qos_port:%d\n",
 		 __func__, info->pid, node_id);
 	if (qos_port_conf_get(priv->qdev, node_id, &port_cfg)) {
-		PR_ERR("failed qos_port_conf_get\n");
+		pr_err("failed qos_port_conf_get\n");
 		return DP_FAILURE;
 	}
 	port_cfg.green_threshold = info->green_threshold;
 	port_cfg.yellow_threshold = info->yellow_threshold;
 	if (qos_port_set(priv->qdev, node_id, &port_cfg)) {
-		PR_ERR("fail to set yellow:%d green:%d for node:%d\n",
+		pr_err("fail to set yellow:%d green:%d for node:%d\n",
 		       info->yellow_threshold, info->green_threshold, node_id);
 		return DP_FAILURE;
 	}
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_ppv4_session.c b/drivers/net/datapath/dpm/gswip32/datapath_ppv4_session.c
index 12f2dac05877..cba8562f4b16 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_ppv4_session.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_ppv4_session.c
@@ -197,7 +197,7 @@ int dp_add_pp_gpid(int inst, int dpid, int vap, int gpid, int spl_gpid)
 	port_info = get_dp_port_info(inst, dpid);
 	ctp_info = get_ctp_assign(port_info->alloc_flags);
 	if (!ctp_info) {
-		PR_ERR("get_ctp_assign fail:0x%x for dpid=%d\n",
+		pr_err("get_ctp_assign fail:0x%x for dpid=%d\n",
 		       port_info->alloc_flags, dpid);
 		return DP_SUCCESS;
 	}
@@ -291,27 +291,27 @@ int dp_add_pp_gpid(int inst, int dpid, int vap, int gpid, int spl_gpid)
 		cfg.tx.prel2_en = true;
 	}
 #endif  /* end of LGM_DP_HARDCODE_TEST */
-	PR_INFO("add gpid=%d\n", gpid);
-	PR_INFO("cfg.rx.cls.n_flds=%d\n", cfg.rx.cls.n_flds);
-	PR_INFO("cfg.rx.mem_port_en=%d\n", cfg.rx.mem_port_en);
-	PR_INFO("cfg.rx.flow_ctrl_en=%d\n", cfg.rx.flow_ctrl_en);
-	PR_INFO("cfg.rx.policies_map=0x%X\n", cfg.rx.policies_map);
-	PR_INFO("cfg.rx.parse_type=%d\n", cfg.rx.parse_type);
-
-	PR_INFO("cfg.tx.max_pkt_size=%d\n", cfg.tx.max_pkt_size);
-	PR_INFO("cfg.tx.headroom_size=%d\n", cfg.tx.headroom_size);
-	PR_INFO("cfg.tx.tailroom_size=%d\n", cfg.tx.tailroom_size);
-	PR_INFO("cfg.tx.min_pkt_len=%d\n", cfg.tx.min_pkt_len);
-	PR_INFO("cfg.tx.base_policy=%d\n", cfg.tx.base_policy);
-	PR_INFO("cfg.tx.policy_map=0x%X\n", cfg.tx.policies_map);
-	PR_INFO("cfg.tx.pkt_only_en=%d\n", cfg.tx.pkt_only_en);
-	PR_INFO("cfg.tx.seg_en=%d\n", cfg.tx.seg_en);
+	pr_info("add gpid=%d\n", gpid);
+	pr_info("cfg.rx.cls.n_flds=%d\n", cfg.rx.cls.n_flds);
+	pr_info("cfg.rx.mem_port_en=%d\n", cfg.rx.mem_port_en);
+	pr_info("cfg.rx.flow_ctrl_en=%d\n", cfg.rx.flow_ctrl_en);
+	pr_info("cfg.rx.policies_map=0x%X\n", cfg.rx.policies_map);
+	pr_info("cfg.rx.parse_type=%d\n", cfg.rx.parse_type);
+
+	pr_info("cfg.tx.max_pkt_size=%d\n", cfg.tx.max_pkt_size);
+	pr_info("cfg.tx.headroom_size=%d\n", cfg.tx.headroom_size);
+	pr_info("cfg.tx.tailroom_size=%d\n", cfg.tx.tailroom_size);
+	pr_info("cfg.tx.min_pkt_len=%d\n", cfg.tx.min_pkt_len);
+	pr_info("cfg.tx.base_policy=%d\n", cfg.tx.base_policy);
+	pr_info("cfg.tx.policy_map=0x%X\n", cfg.tx.policies_map);
+	pr_info("cfg.tx.pkt_only_en=%d\n", cfg.tx.pkt_only_en);
+	pr_info("cfg.tx.seg_en=%d\n", cfg.tx.seg_en);
 
 	if (pp_port_add(gpid, &cfg)) {
-		PR_ERR("failed to create gpid: %d\n", gpid);
+		pr_err("failed to create gpid: %d\n", gpid);
 		return DP_FAILURE;
 	}
-	PR_INFO("GPID[%d] added ok\n", gpid);
+	pr_info("GPID[%d] added ok\n", gpid);
 	return DP_SUCCESS;
 }
 
@@ -361,13 +361,13 @@ int dp_add_default_egress_sess(struct dp_session *sess, int flag)
 	ret = pp_session_create(&args, &sess_id, NULL);
 	if (ret) {
 		/* IF failure, call PPA API to add this session... */
-		DP_ERR("session create failed. Call PPA to continue");
+		pr_err("session create failed. Call PPA to continue");
 		return DP_FAILURE;
 	}
 	port_info = get_dp_port_info(sess->inst, sess->in_port);
 	get_dp_port_subif(port_info, sess->vap)->dfl_sess[sess->class] =
 		sess_id;
-	DP_INFO("session id = %u\n", sess_id);
+	pr_info("session id = %u\n", sess_id);
 	return DP_SUCCESS;
 }
 
@@ -414,17 +414,17 @@ int dp_add_hostif(int inst, int dpid, int vap)
 			hif.dp.eg[i].pid = PP_PORT_INVALID;
 		}
 	}
-	DP_INFO("dpid=%d vap=%u\n", dpid, vap);
-	DP_INFO("hif.cls.port=%u\n", hif.cls.port);
-	DP_INFO("hif.cls.tc_bitmap=0x%x\n", hif.cls.tc_bitmap);
-	DP_INFO("hif.dp.color=%d\n", hif.dp.color);
+	pr_info("dpid=%d vap=%u\n", dpid, vap);
+	pr_info("hif.cls.port=%u\n", hif.cls.port);
+	pr_info("hif.cls.tc_bitmap=0x%x\n", hif.cls.tc_bitmap);
+	pr_info("hif.dp.color=%d\n", hif.dp.color);
 	for (i = 0; i < ARRAY_SIZE(hif.dp.eg); i++) {
-		DP_INFO("hif.dp.eg[%d].pid=%u\n", i, hif.dp.eg[i].pid);
-		DP_INFO("hif.dp.eg[%d].qos_q=%u\n", i, hif.dp.eg[i].qos_q);
+		pr_info("hif.dp.eg[%d].pid=%u\n", i, hif.dp.eg[i].pid);
+		pr_info("hif.dp.eg[%d].qos_q=%u\n", i, hif.dp.eg[i].qos_q);
 	}
 	ret = pp_hostif_add(&hif);
 	if (ret)
-		DP_ERR("hostif_add fail:dpid/gpid=%u/%u vap/tc=%d/%u\n",
+		pr_err("hostif_add fail:dpid/gpid=%u/%u vap/tc=%d/%u\n",
 		       dpid, hif.cls.port, vap, hif.cls.tc_bitmap);
 
 	/* high priority */
@@ -443,17 +443,17 @@ int dp_add_hostif(int inst, int dpid, int vap)
 			hif.dp.eg[i].pid  = PP_PORT_INVALID;
 		}
 	}
-	DP_INFO("dpid=%d vap=%u\n", dpid, vap);
-	DP_INFO("hif.cls.port=%u\n", hif.cls.port);
-	DP_INFO("hif.cls.tc_bitmap=0x%x\n", hif.cls.tc_bitmap);
-	DP_INFO("hif.dp.color=%u\n", hif.dp.color);
+	pr_info("dpid=%d vap=%u\n", dpid, vap);
+	pr_info("hif.cls.port=%u\n", hif.cls.port);
+	pr_info("hif.cls.tc_bitmap=0x%x\n", hif.cls.tc_bitmap);
+	pr_info("hif.dp.color=%u\n", hif.dp.color);
 	for (i = 0; i < ARRAY_SIZE(hif.dp.eg); i++) {
-		DP_INFO("hif.dp.eg[%d].pid=%u\n", i, hif.dp.eg[i].pid);
-		DP_INFO("hif.dp.eg[%d].qos_q=%u\n", i, hif.dp.eg[i].qos_q);
+		pr_info("hif.dp.eg[%d].pid=%u\n", i, hif.dp.eg[i].pid);
+		pr_info("hif.dp.eg[%d].qos_q=%u\n", i, hif.dp.eg[i].qos_q);
 	}
 	ret = pp_hostif_add(&hif);
 	if (ret)
-		DP_ERR("hostif_add fail:dpid/gpid=%d/%d vap/tc=%d/%d\n",
+		pr_err("hostif_add fail:dpid/gpid=%d/%d vap/tc=%d/%d\n",
 		       dpid, hif.cls.port, vap, hif.cls.tc_bitmap);
 
 	return DP_SUCCESS;
@@ -468,7 +468,7 @@ int dp_add_dflt_hostif(struct dp_dflt_hostif *hostif, int flag)
 	int i;
 
 	if (!hostif) {
-		DP_ERR("hostif NULL\n");
+		pr_err("hostif NULL\n");
 		return DP_FAILURE;
 	}
 	/* only allowed one queue for pp_hostif_dflt_set */
@@ -503,9 +503,9 @@ int dp_subif_pp_set(int inst, int portid, int vap,
 			num = port_info->gpid_num;
 		gpid = port_info->gpid_base + num;
 	}
-	PR_INFO("dp_subif_pp_set=%d\n", gpid);
+	pr_info("dp_subif_pp_set=%d\n", gpid);
 	if (dp_add_pp_gpid(inst, portid, vap, gpid, 0) == DP_FAILURE) {
-		DP_ERR("dp_add_pp_gpid for dport/vap=%d/%d\n", portid, vap);
+		pr_err("dp_add_pp_gpid for dport/vap=%d/%d\n", portid, vap);
 		return -1;
 	}
 	get_dp_port_subif(port_info, vap)->gpid = gpid;
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_proc.c b/drivers/net/datapath/dpm/gswip32/datapath_proc.c
index 8240cd145596..00a8ab3b1fe9 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_proc.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_proc.c
@@ -161,9 +161,9 @@ ssize_t proc_parser_write(struct file *file, const char *buf,
 				"refresh",
 				strlen("refresh")) == 0) {
 		dp_get_gsw_parser_32(NULL, NULL, NULL, NULL);
-		PR_INFO("value:cpu=%d mpe1=%d mpe2=%d mpe3=%d\n", pinfo[0].v,
+		pr_info("value:cpu=%d mpe1=%d mpe2=%d mpe3=%d\n", pinfo[0].v,
 			pinfo[1].v, pinfo[2].v, pinfo[3].v);
-		PR_INFO("size :cpu=%d mpe1=%d mpe2=%d mpe3=%d\n",
+		pr_info("size :cpu=%d mpe1=%d mpe2=%d mpe3=%d\n",
 			pinfo[0].size, pinfo[1].size, pinfo[2].size,
 			pinfo[3].size);
 		return count;
@@ -176,7 +176,7 @@ ssize_t proc_parser_write(struct file *file, const char *buf,
 			flag = 0;
 		else if (flag > 3)
 			flag = 3;
-		PR_INFO("eProcessPath_Action set to %d\n", flag);
+		pr_info("eProcessPath_Action set to %d\n", flag);
 		/*: All packets set to same mpe flag as specified */
 		memset(&pce, 0, sizeof(pce));
 		pce.pattern.nIndex = pce_rule_id;
@@ -207,7 +207,7 @@ ssize_t proc_parser_write(struct file *file, const char *buf,
 		pce.action.nRMON_Id = 0;	/*RMON_UDP_CNTR; */
 
 		if (gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, &pce)) {
-			PR_ERR("PCE rule add fail: GSW_PCE_RULE_WRITE\n");
+			pr_err("PCE rule add fail: GSW_PCE_RULE_WRITE\n");
 			return count;
 		}
 
@@ -218,17 +218,17 @@ ssize_t proc_parser_write(struct file *file, const char *buf,
 		pce.pattern.nIndex = pce_rule_id;
 		pce.pattern.bEnable = 0;
 		if (gsw_tflow->TFLOW_PceRuleWrite(gsw_handle, &pce)) {
-			PR_ERR("PCE rule add fail:GSW_PCE_RULE_WRITE\n");
+			pr_err("PCE rule add fail:GSW_PCE_RULE_WRITE\n");
 			return count;
 		}
 	} else {
-		PR_INFO("Usage: echo %s [cpu] [mpe1] [mpe2] [mpe3] > parser\n",
+		pr_info("Usage: echo %s [cpu] [mpe1] [mpe2] [mpe3] > parser\n",
 			"<enable/disable>");
-		PR_INFO("Usage: echo <refresh> parser\n");
+		pr_info("Usage: echo <refresh> parser\n");
 
-		PR_INFO("Usage: echo %s > parser\n",
+		pr_info("Usage: echo %s > parser\n",
 			"mark eProcessPath_Action_value(0~3) pce_rule_id");
-		PR_INFO("Usage: echo unmark pce_rule_id > parser\n");
+		pr_info("Usage: echo unmark pce_rule_id > parser\n");
 		return count;
 	}
 
@@ -252,7 +252,7 @@ char *get_bp_member_string_32(int inst, u16 bp, char *buf)
 		GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID;
 	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &bp_cfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed to get bridge port's member for bridgeport=%d\n",
+		pr_err("Failed to get bridge port's member for bridgeport=%d\n",
 		       bp_cfg.nBridgePortId);
 		return buf;
 	}
@@ -307,7 +307,7 @@ int dp_sub_proc_install_32(void)
 	int i;
 
 	if (!dp_proc_node) {
-		PR_ERR("dp_sub_proc_install failed\n");
+		pr_err("dp_sub_proc_install failed\n");
 		return 0;
 	}
 
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_rx.c b/drivers/net/datapath/dpm/gswip32/datapath_rx.c
index f0cc2257d8b8..f0df20cef761 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_rx.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_rx.c
@@ -85,7 +85,7 @@ int32_t dp_rx_32(struct sk_buff *skb, u32 flags)
 	dp_port = get_dp_port_info(inst, 0);
 
 	if (!skb || !skb->data) {
-		PR_ERR("skb NULL or skb->data is NULL\n");
+		pr_err("skb NULL or skb->data is NULL\n");
 		return DP_FAILURE;
 	}
 
@@ -107,7 +107,7 @@ int32_t dp_rx_32(struct sk_buff *skb, u32 flags)
 	pp_rx_pkt_hook(skb);
 	pp_desc = pp_pkt_desc_get(skb);
 	if (!pp_desc) {
-		DP_ERR("pp_pkt_desc_get fail\n");
+		pr_err("pp_pkt_desc_get fail\n");
 		goto RX_DROP2;
 	}
 
@@ -123,11 +123,11 @@ int32_t dp_rx_32(struct sk_buff *skb, u32 flags)
 			  gpid, dpid);
 
 	if (unlikely(!dpid)) { /*Normally shouldnot go to here */
-		DP_ERR("%s %s D0: %08x D1: %08x D2: %08x D3: %08x\n",
+		pr_err("%s %s D0: %08x D1: %08x D2: %08x D3: %08x\n",
 		       "Impossible: DPID Invalid (0),", "Desc rx'd:",
 		       *(u32 *)desc_0, *(u32 *)desc_1,
 		       *(u32 *)desc_2, *(u32 *)desc_3);
-		DP_ERR("%s %px %s D0: %08x D1: %08x D2: %08x D3: %08x\n",
+		pr_err("%s %px %s D0: %08x D1: %08x D2: %08x D3: %08x\n",
 		       "QoS Descriptor at buf_base", skb->buf_base,
 		       "Desc rx'd:", *skb->buf_base,
 		       *(skb->buf_base + sizeof(u32)),
@@ -169,7 +169,7 @@ int32_t dp_rx_32(struct sk_buff *skb, u32 flags)
 			sess.sig = pp_desc->ud.hash_sig;
 			if (dp_add_default_egress_sess(&sess, 0)) {
 				atomic_dec(&p_subif->f_dfl_sess[classid]);
-				PR_ERR("Fail to create default egress\n");
+				pr_err("Fail to create default egress\n");
 				goto RX_DROP;
 			}
 		} else {
@@ -273,7 +273,7 @@ int32_t dp_rx_32(struct sk_buff *skb, u32 flags)
 
 	if (unlikely(dpid >=
 		     dp_port_prop[inst].info.cap.max_num_dp_ports - 1)) {
-		PR_ERR("Drop for wrong ep or src port id=%u ??\n",
+		pr_err("Drop for wrong ep or src port id=%u ??\n",
 		       dpid);
 		goto RX_DROP;
 	} else if (unlikely(dp_port->status == PORT_FREE)) {
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_switchdev.c b/drivers/net/datapath/dpm/gswip32/datapath_switchdev.c
index 9a474ad38e1d..9f22270f276c 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_switchdev.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_switchdev.c
@@ -25,7 +25,7 @@ int dp_swdev_alloc_bridge_id_32(int inst)
 	ret = gsw_handle->gsw_brdg_ops.Bridge_Alloc(gsw_handle, &br);
 	if ((ret != GSW_statusOk) ||
 	    (br.nBridgeId < 0)) {
-		PR_ERR("Failed to get a FID\n");
+		pr_err("Failed to get a FID\n");
 		return -1;
 	}
 	DP_DEBUG(DP_DBG_FLAG_SWDEV, "FID=%d\n", br.nBridgeId);
@@ -51,7 +51,7 @@ int dp_swdev_bridge_port_cfg_set_32(struct br_info *br_item,
 	brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("fail in getting bridge port config\r\n");
+		pr_err("fail in getting bridge port config\r\n");
 		return -1;
 	}
 	list_for_each_entry(bport_list, &br_item->bp_list, list) {
@@ -82,7 +82,7 @@ int dp_swdev_bridge_port_cfg_set_32(struct br_info *br_item,
 			  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Fail in allocating/configuring bridge port\n");
+		pr_err("Fail in allocating/configuring bridge port\n");
 		return -1;
 	}
 	/* To set other member portmap with current bridge port map */
@@ -105,7 +105,7 @@ int dp_swdev_bridge_port_cfg_set_32(struct br_info *br_item,
 		brportcfg.eMask = GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &brportcfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("fail in getting br port config\r\n");
+			pr_err("fail in getting br port config\r\n");
 			return -1;
 		}
 		SET_BP_MAP(brportcfg.nBridgePortMap, bport);
@@ -115,7 +115,7 @@ int dp_swdev_bridge_port_cfg_set_32(struct br_info *br_item,
 				  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &brportcfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("Fail alloc/cfg bridge port\n");
+			pr_err("Fail alloc/cfg bridge port\n");
 			return -1;
 		}
 	}
@@ -178,7 +178,7 @@ int dp_swdev_bridge_port_cfg_reset_32(struct br_info *br_item,
 			  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 	ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &brportcfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Fail in configuring GSW_BRIDGE_portConfig_t in %s\r\n",
+		pr_err("Fail in configuring GSW_BRIDGE_portConfig_t in %s\r\n",
 		       __func__);
 		return -1;
 	}
@@ -195,7 +195,7 @@ int dp_swdev_bridge_port_cfg_reset_32(struct br_info *br_item,
 				  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_ID;
 		ret = gsw_bp->BridgePort_ConfigGet(gsw_handle, &brportcfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("failed getting br port cfg\r\n");
+			pr_err("failed getting br port cfg\r\n");
 			return -1;
 		}
 		UNSET_BP_MAP(brportcfg.nBridgePortMap, bport);
@@ -204,7 +204,7 @@ int dp_swdev_bridge_port_cfg_reset_32(struct br_info *br_item,
 				  GSW_BRIDGE_PORT_CONFIG_MASK_BRIDGE_PORT_MAP;
 		ret = gsw_bp->BridgePort_ConfigSet(gsw_handle, &brportcfg);
 		if (ret != GSW_statusOk) {
-			PR_ERR("Fail alloc/cfg br port\n");
+			pr_err("Fail alloc/cfg br port\n");
 			return -1;
 		}
 	}
@@ -235,7 +235,7 @@ int dp_swdev_bridge_cfg_set_32(int inst, u16 fid)
 	brcfg.eForwardUnknownUnicast = GSW_BRIDGE_FORWARD_FLOOD;
 	ret = gsw_handle->gsw_brdg_ops.Bridge_ConfigSet(gsw_handle, &brcfg);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed to set bridge id(%d)\n", brcfg.nBridgeId);
+		pr_err("Failed to set bridge id(%d)\n", brcfg.nBridgeId);
 		br.nBridgeId = fid;
 		gsw_handle->gsw_brdg_ops.Bridge_Free(gsw_handle, &br);
 		return -1;
@@ -256,7 +256,7 @@ int dp_swdev_free_brcfg_32(int inst, u16 fid)
 	br.nBridgeId = fid;
 	ret = gsw_handle->gsw_brdg_ops.Bridge_Free(gsw_handle, &br);
 	if (ret != GSW_statusOk) {
-		PR_ERR("Failed to free bridge id(%d)\n", br.nBridgeId);
+		pr_err("Failed to free bridge id(%d)\n", br.nBridgeId);
 		return -1;
 	}
 	DP_DEBUG(DP_DBG_FLAG_SWDEV, "FID(%d) freed for inst:%d\n", fid, inst);
@@ -278,19 +278,19 @@ int dp_gswip_ext_vlan_32(int inst, int vap, int ep)
 	port = get_dp_port_info(inst, ep);
 	vlan = kzalloc(sizeof(*vlan), GFP_KERNEL);
 	if (!vlan) {
-		PR_ERR("failed to alloc ext_vlan of %zd bytes\n",
+		pr_err("failed to alloc ext_vlan of %zd bytes\n",
 		       sizeof(*vlan));
 		return 0;
 	}
 	vlan->vlan2_list = kzalloc(sizeof(*vlan->vlan2_list), GFP_KERNEL);
 	if (!vlan->vlan2_list) {
-		PR_ERR("failed to alloc ext_vlan of %zd bytes\n",
+		pr_err("failed to alloc ext_vlan of %zd bytes\n",
 		       sizeof(*vlan->vlan2_list));
 		goto EXIT;
 	}
 	vlan->vlan1_list = kzalloc(sizeof(*vlan->vlan1_list), GFP_KERNEL);
 	if (!vlan->vlan1_list) {
-		PR_ERR("failed to alloc ext_vlan of %zd bytes\n",
+		pr_err("failed to alloc ext_vlan of %zd bytes\n",
 		       sizeof(*vlan->vlan1_list));
 		goto EXIT;
 	}
@@ -299,7 +299,7 @@ int dp_gswip_ext_vlan_32(int inst, int vap, int ep)
 		DP_DEBUG(DP_DBG_FLAG_SWDEV, "tmp dev name:%s\n",
 			 tmp->dev ? tmp->dev->name : "NULL");
 		if (!tmp->dev) {
-			PR_ERR("tmp->dev is NULL\n");
+			pr_err("tmp->dev is NULL\n");
 			goto EXIT;
 		}
 		ret = dp_swdev_chk_bport_in_br(tmp->dev, tmp->bp, inst);
@@ -355,7 +355,7 @@ int dp_gswip_ext_vlan_32(int inst, int vap, int ep)
 	if (ret == 0)
 		sif->swdev_priv = vlan->priv;
 	else
-		PR_ERR("set gswip ext vlan return error\n");
+		pr_err("set gswip ext vlan return error\n");
 
 EXIT:
 	kfree(vlan->vlan2_list);
diff --git a/drivers/net/datapath/dpm/gswip32/datapath_tx.c b/drivers/net/datapath/dpm/gswip32/datapath_tx.c
index 9976b159cfbf..dbaba49817c9 100644
--- a/drivers/net/datapath/dpm/gswip32/datapath_tx.c
+++ b/drivers/net/datapath/dpm/gswip32/datapath_tx.c
@@ -30,7 +30,7 @@ static int cqm_preprocess(struct sk_buff *skb, struct dp_tx_common *cmn,
 
 #if IS_ENABLED(CONFIG_INTEL_DATAPATH_EXTRA_DEBUG)
 	if (unlikely(!cmn->gpid)) {
-		PR_INFO("Why after get_dma_pmac_templ ep is zero\n");
+		pr_info("Why after get_dma_pmac_templ ep is zero\n");
 		return DP_XMIT_ERR_EP_ZERO;
 	}
 #endif
