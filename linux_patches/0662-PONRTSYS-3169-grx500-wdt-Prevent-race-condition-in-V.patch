From c8ab42946046790cea93ea00c4b9128559634821 Mon Sep 17 00:00:00 2001
From: Hauke Mehrtens <hauke.mehrtens@intel.com>
Date: Tue, 2 Jul 2019 13:41:16 +0200
Subject: [PATCH] PONRTSYS-3169: grx500_wdt:  Prevent race condition in
 VPE_OTHER accesses

The other VPE register is also used in the GIC driver, in the next access we
do some settings for the VPE configured before. If this is intercepted by an
IRQ the watchdog will be configured for the  wrong CPU.
Deactivate IRQs while we modify this to make this atomic, this should fix
some race conditions.

This hopefully fixes the sporadic watchdog triggers we see sometimes.
---
 drivers/watchdog/grx500_wdt.c | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/drivers/watchdog/grx500_wdt.c b/drivers/watchdog/grx500_wdt.c
index b40ae0ce5586..a8a04a0f82ca 100644
--- a/drivers/watchdog/grx500_wdt.c
+++ b/drivers/watchdog/grx500_wdt.c
@@ -134,6 +134,7 @@ static inline void Enable_WDT_intr(void *wdtirq)
 static int grx500wdt_start(struct watchdog_device *wdt_dev)
 {
 	uint32_t config0;
+	unsigned long flags;
 
 	pr_debug("[%s]:[%d] wdt_dev=0x%p id=%d cpu = %d\n", __func__, __LINE__,
 		wdt_dev, wdt_dev->id, smp_processor_id());
@@ -144,6 +145,7 @@ static int grx500wdt_start(struct watchdog_device *wdt_dev)
 			(config0 | WD_START));
 		wmb();
 	} else {
+		local_irq_save(flags);
 		gic_write_reg(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), wdt_dev->id);
 		wmb();
 		config0 = gic_read_reg(GIC_REG(VPE_OTHER, GIC_VPE_WD_CONFIG0));
@@ -151,6 +153,7 @@ static int grx500wdt_start(struct watchdog_device *wdt_dev)
 		gic_write_reg(GIC_REG(VPE_OTHER, GIC_VPE_WD_CONFIG0),
 			(config0 | WD_START));
 		wmb();
+		local_irq_restore(flags);
 	}
 
 	return 0;
@@ -159,6 +162,7 @@ static int grx500wdt_start(struct watchdog_device *wdt_dev)
 static int grx500wdt_stop(struct watchdog_device *wdt_dev)
 {
 	uint32_t config0;
+	unsigned long flags;
 
 	pr_debug("[%s]:[%d] wdt_dev=0x%p id=%d cpu = %d\n", __func__, __LINE__,
 		wdt_dev, wdt_dev->id, smp_processor_id());
@@ -169,6 +173,7 @@ static int grx500wdt_stop(struct watchdog_device *wdt_dev)
 			(config0 & ~WD_START));
 		wmb();
 	} else {
+		local_irq_save(flags);
 		gic_write_reg(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), wdt_dev->id);
 		wmb();
 		config0 = gic_read_reg(GIC_REG(VPE_OTHER, GIC_VPE_WD_CONFIG0));
@@ -176,6 +181,7 @@ static int grx500wdt_stop(struct watchdog_device *wdt_dev)
 		gic_write_reg(GIC_REG(VPE_OTHER, GIC_VPE_WD_CONFIG0),
 			(config0 & ~WD_START));
 		wmb();
+		local_irq_restore(flags);
 	}
 
 	return 0;
@@ -185,6 +191,7 @@ static int grx500wdt_set_timeout(struct watchdog_device *wdt_dev,
 				unsigned int new_timeout)
 {
 	struct watchdog_device *grx500_wdt;
+	unsigned long flags;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
@@ -208,6 +215,7 @@ static int grx500wdt_set_timeout(struct watchdog_device *wdt_dev,
 		}
 		wmb();
 	} else {
+		local_irq_save(flags);
 		gic_write_reg(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), wdt_dev->id);
 		wmb();
 		if (((u64)cpu_clk * (u64)(grx500_wdt->timeout)) <= (u64)U32_MAX) {
@@ -218,6 +226,7 @@ static int grx500wdt_set_timeout(struct watchdog_device *wdt_dev,
 				(U32_MAX));
 		}
 		wmb();
+		local_irq_restore(flags);
 	}
 
 	grx500wdt_start(grx500_wdt);
@@ -228,6 +237,7 @@ static int grx500wdt_set_timeout(struct watchdog_device *wdt_dev,
 static uint32_t grx500wdt_get_timeleft(struct watchdog_device *wdt_dev)
 {
 	u32 count0, initial0, config0, rst_en, map0;
+	unsigned long flags;
 
 	if (wdt_dev->id == smp_processor_id()) {
 		initial0 = gic_read_reg(GIC_REG(VPE_LOCAL, GIC_VPE_WD_INITIAL0));
@@ -239,6 +249,7 @@ static uint32_t grx500wdt_get_timeleft(struct watchdog_device *wdt_dev)
 		map0 = gic_read_reg(GIC_REG(VPE_LOCAL, GIC_VPE_WD_MAP));
 		rmb();
 	} else {
+		local_irq_save(flags);
 		gic_write_reg(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), wdt_dev->id);
 		wmb();
 		initial0 = gic_read_reg(GIC_REG(VPE_OTHER, GIC_VPE_WD_INITIAL0));
@@ -249,6 +260,7 @@ static uint32_t grx500wdt_get_timeleft(struct watchdog_device *wdt_dev)
 		rmb();
 		map0 = gic_read_reg(GIC_REG(VPE_OTHER, GIC_VPE_WD_MAP));
 		rmb();
+		local_irq_restore(flags);
 	}
 
 	regmap_read(ltq_rcu_base, RCU_IAP_WDT_RST_EN, &rst_en);
@@ -336,6 +348,7 @@ static int grx500wdt_probe(struct platform_device *pdev)
 	struct grx500_wdt_struct *priv;
 	int ret, cpu, irq, resetcause;
 	int i;
+	unsigned long flags;
 
 	/*
 	 * I/O memory need not be taken from Device Tree as WDT is part of
@@ -440,6 +453,7 @@ static int grx500wdt_probe(struct platform_device *pdev)
 				(U32_MAX));
 			wmb();
 		} else {
+			local_irq_save(flags);
 			gic_write_reg(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), cpu);
 			wmb();
 			gic_write_reg(GIC_REG(VPE_OTHER, GIC_VPE_WD_CONFIG0), 0x0);
@@ -452,6 +466,7 @@ static int grx500wdt_probe(struct platform_device *pdev)
 			gic_write_reg(GIC_REG(VPE_OTHER, GIC_VPE_WD_INITIAL0),
 				(U32_MAX));
 			wmb();
+			local_irq_restore(flags);
 		}
 
 		/* Map to PIN is configured by GIC */
