From 0bf8d196ac20f77c770abb2c1ed965a689993e92 Mon Sep 17 00:00:00 2001
From: thampan <joby.thampan@intel.com>
Date: Tue, 20 Nov 2018 11:04:49 +0800
Subject: [PATCH] Fix for Multicast Entry not match in Big Endian CPU

---
 .../net/ethernet/lantiq/switch-api/gsw_swmcast.c   | 78 ++++++++++++++++++----
 1 file changed, 66 insertions(+), 12 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_swmcast.c b/drivers/net/ethernet/lantiq/switch-api/gsw_swmcast.c
index 75d103878fa3..9b4e9a106663 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_swmcast.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_swmcast.c
@@ -234,11 +234,6 @@ int gsw_get_swmcast_entry(void *cdev, GSW_multicastTableRead_t *parm, u32 loc)
 		for (i = 0; i < 8; i++)
 			parm->uIP_Gsa.nIPv6[i] = pcetable.key[11 + i];
 
-		if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
-			parm->uIP_Gda.nIPv4 = le32_to_cpu(parm->uIP_Gda.nIPv4);
-			parm->uIP_Gsa.nIPv4 = le32_to_cpu(parm->uIP_Gsa.nIPv4);
-		}
-
 		/* Action */
 		parm->nSubIfId = ((pcetable.val[1] >> 3) & 0x1FFF);
 
@@ -300,6 +295,25 @@ static int set_pce_hash_table(void *cdev, MCAST_HASHTBL *phtable, u32 loc)
 	/* Pattern */
 	pcetable.key[2] |= phtable->key.fid & 0x3F;
 
+#if CONFIG_CPU_BIG_ENDIAN
+
+	if (phtable->ip_type == GSW_IP_SELECT_IPV4) {
+		pcetable.key[3] = phtable->key.dstip.nIPv6[1];
+		pcetable.key[4] = phtable->key.dstip.nIPv6[0];
+		pcetable.key[11] = phtable->key.srcip.nIPv6[1];
+		pcetable.key[12] = phtable->key.srcip.nIPv6[0];
+	} else if (phtable->ip_type == GSW_IP_SELECT_IPV6) {
+		for (i = 0; i < 8; i++) {
+			pcetable.key[3 + i] = phtable->key.dstip.nIPv6[7 - i];
+		}
+
+		for (i = 0; i < 8; i++) {
+			pcetable.key[11 + i] = phtable->key.srcip.nIPv6[7 - i];
+		}
+	}
+
+#else
+
 	for (i = 0; i < 8; i++) {
 		pcetable.key[3 + i] = phtable->key.dstip.nIPv6[i];
 	}
@@ -308,6 +322,8 @@ static int set_pce_hash_table(void *cdev, MCAST_HASHTBL *phtable, u32 loc)
 		pcetable.key[11 + i] = phtable->key.srcip.nIPv6[i];
 	}
 
+#endif
+
 	/* Action */
 	pcetable.val[1] = ((phtable->action.subifid & 0x1FFF) << 3);
 
@@ -343,19 +359,32 @@ int gsw_insert_hashtable_entry(void *cdev, GSW_multicastTable_t *parm)
 	portId = parm->nPortId;
 
 	if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
-		pattern.srcip.nIPv4 = cpu_to_le32(parm->uIP_Gsa.nIPv4);
-		pattern.dstip.nIPv4 = cpu_to_le32(parm->uIP_Gda.nIPv4);
-		pr_debug("portId = %d\n parm->eIPVersion = %d\n nSubIfId = %d\n uIP_Gsa.nIPv4 = %08x\n uIP_Gda.nIPv4 = %08x\n fid = %d\n bExclSrcIP = %d\n eModeMember = %d\n", parm->nPortId, parm->eIPVersion, parm->nSubIfId, parm->uIP_Gsa.nIPv4, parm->uIP_Gda.nIPv4,
-		       parm->nFID,  parm->bExclSrcIP, parm->eModeMember);
+
+		pattern.srcip.nIPv4 = parm->uIP_Gsa.nIPv4;
+		pattern.dstip.nIPv4 = parm->uIP_Gda.nIPv4;
+
+		pr_debug("portId = %d\n parm->eIPVersion = %d\n nSubIfId = %d\n uIP_Gsa.nIPv4 = %08x\n uIP_Gda.nIPv4 = %08x\n fid = %d\n bExclSrcIP = %d\n eModeMember = %d\n", parm->nPortId, parm->eIPVersion, parm->nSubIfId, pattern.srcip.nIPv4, pattern.dstip.nIPv4,
+			 parm->nFID,  parm->bExclSrcIP, parm->eModeMember);
 	} else if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
 
 		pr_debug("portId = %d\n parm->eIPVersion = %d\n nSubIfId = %d\n fid = %d\n bExclSrcIP = %d\n eModeMember = %d\n",
-		       parm->nPortId, parm->eIPVersion, parm->nSubIfId, parm->nFID,  parm->bExclSrcIP, parm->eModeMember);
+			 parm->nPortId, parm->eIPVersion, parm->nSubIfId, parm->nFID,  parm->bExclSrcIP, parm->eModeMember);
+
+#if CONFIG_CPU_BIG_ENDIAN
+
+		for (i = 0; i < 8; i++) {
+			pattern.srcip.nIPv6[i] = parm->uIP_Gsa.nIPv6[i];
+			pattern.dstip.nIPv6[i] = parm->uIP_Gda.nIPv6[i];
+		}
+
+#else
 
 		for (i = 0; i < 8; i++) {
 			pattern.srcip.nIPv6[i] = parm->uIP_Gsa.nIPv6[7 - i];
 			pattern.dstip.nIPv6[i] = parm->uIP_Gda.nIPv6[7 - i];
 		}
+
+#endif
 	}
 
 	pattern.fid = parm->nFID;
@@ -477,13 +506,26 @@ int gsw_search_hashtable_entry(void *cdev, GSW_multicastTable_t *parm, GSW_multi
 	portId = parm->nPortId;
 
 	if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
+
 		pattern.srcip.nIPv4 = parm->uIP_Gsa.nIPv4;
 		pattern.dstip.nIPv4 = parm->uIP_Gda.nIPv4;
+
 	} else if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+#if CONFIG_CPU_BIG_ENDIAN
+
+		for (i = 0; i < 8; i++) {
+			pattern.srcip.nIPv6[i] = parm->uIP_Gsa.nIPv6[i];
+			pattern.dstip.nIPv6[i] = parm->uIP_Gda.nIPv6[i];
+		}
+
+#else
+
 		for (i = 0; i < 8; i++) {
 			pattern.srcip.nIPv6[i] = parm->uIP_Gsa.nIPv6[7 - i];
 			pattern.dstip.nIPv6[i] = parm->uIP_Gda.nIPv6[7 - i];
 		}
+
+#endif
 	}
 
 	pattern.fid = parm->nFID;
@@ -644,13 +686,25 @@ int gsw_remove_hashtable_entry(void *cdev, GSW_multicastTable_t *parm)
 	}
 
 	if (parm->eIPVersion == GSW_IP_SELECT_IPV4) {
-		pattern.srcip.nIPv4 = cpu_to_le32(parm->uIP_Gsa.nIPv4);
-		pattern.dstip.nIPv4 = cpu_to_le32(parm->uIP_Gda.nIPv4);
+		pattern.srcip.nIPv4 = parm->uIP_Gsa.nIPv4;
+		pattern.dstip.nIPv4 = parm->uIP_Gda.nIPv4;
+
 	} else if (parm->eIPVersion == GSW_IP_SELECT_IPV6) {
+#if CONFIG_CPU_BIG_ENDIAN
+
+		for (i = 0; i < 8; i++) {
+			pattern.srcip.nIPv6[i] = parm->uIP_Gsa.nIPv6[i];
+			pattern.dstip.nIPv6[i] = parm->uIP_Gda.nIPv6[i];
+		}
+
+#else
+
 		for (i = 0; i < 8; i++) {
 			pattern.srcip.nIPv6[i] = parm->uIP_Gsa.nIPv6[7 - i];
 			pattern.dstip.nIPv6[i] = parm->uIP_Gda.nIPv6[7 - i];
 		}
+
+#endif
 	}
 
 	pattern.fid = parm->nFID;
