From c0d7b313991310a524ef07c91b1741326eb02992 Mon Sep 17 00:00:00 2001
From: Dinesh Sudham <dineshx.sudham@intel.com>
Date: Fri, 2 Aug 2019 16:36:10 +0800
Subject: [PATCH] PONRTSYS-4302: GSWAPI: Traffic flow rule management

---
 drivers/net/ethernet/lantiq/switch-api/gsw_debug.c |  43 +++
 .../net/ethernet/lantiq/switch-api/gsw_flow_core.c | 323 ++++++++++++++++++++-
 .../net/ethernet/lantiq/switch-api/gsw_flow_core.h |  22 ++
 .../net/ethernet/lantiq/switch-api/gsw_ll_func.h   |   5 +-
 .../ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c |   5 +
 include/net/switch_api/gsw_flow_ops.h              |   6 +
 include/net/switch_api/lantiq_gsw.h                |  27 +-
 include/net/switch_api/lantiq_gsw_flow.h           |  49 ++++
 8 files changed, 474 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_debug.c b/drivers/net/ethernet/lantiq/switch-api/gsw_debug.c
index a37af647e71b..8491a90a5423 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_debug.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_debug.c
@@ -1189,3 +1189,46 @@ GSW_return_t GSW_MacsecCfg(void *cdev, GSW_MAC_cfg_t *macsec_cfg)
 	return GSW_statusOk;
 }
 
+GSW_return_t gsw_debug_tflow_tablestatus(void *cdev, GSW_debug_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 i, blockid = 0;
+
+	if (!gswdev) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	pr_info("\n");
+
+	if (parm->nCheckIndexInUse) {
+		for (i = 0; i < gswdev->tftblsize; i++) {
+			if (gswdev->tflow_idx.flow_idx[i].indexinuse) {
+				blockid = gswdev->tflow_idx.flow_idx[i].tflowblockid;
+				pr_info("TFLOW Table Index  %d = InUse, Associated to TFLOW Block Id %d.\n",
+					i, blockid);
+			}
+		}
+
+		return GSW_statusOk;
+	}
+
+	if (parm->nForceSet) {
+		gswdev->tflow_idx.flow_idx[parm->nTableIndex].indexinuse = 1;
+		gswdev->tflow_idx.flow_idx[parm->nTableIndex].tflowblockid = parm->nblockid;
+		gswdev->tflow_idx.usedentry++;
+		pr_info("TFLOW Table Index  %d is Forced to InUSe\n",
+			parm->nTableIndex);
+	} else {
+		pr_info("TFLOW  Table Index %d:\n\n",
+			parm->nTableIndex);
+		pr_info("BlockId						= %d\n",
+			gswdev->tflow_idx.flow_idx[parm->nTableIndex].tflowblockid);
+		pr_info("IndexInUse					= %d\n",
+			gswdev->tflow_idx.flow_idx[parm->nTableIndex].indexinuse);
+		pr_info("IndexInUsageCnt				= %d\n",
+			gswdev->tflow_idx.flow_idx[parm->nTableIndex].indexinusagecnt);
+	}
+
+	return GSW_statusOk;
+}
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
index 48175dd3dc6d..3c1203db8490 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.c
@@ -1,5 +1,5 @@
 /******************************************************************************
-				Copyright (c) 2016, 2017 Intel Corporation
+				Copyright (c) 2016, 2019 Intel Corporation
 
 ******************************************************************************/
 /*****************************************************************************
@@ -8,7 +8,6 @@
 	For licensing information, see the file 'LICENSE' in the root folder of
 	this software module.
 ******************************************************************************/
-
 #ifdef __KERNEL__
 #include <linux/jiffies.h>
 #include <linux/timer.h>
@@ -3176,7 +3175,7 @@ void *ethsw_api_core_init(ethsw_core_init_t *ethcinit)
 	ethsw_api_dev_t *PrvData;
 	struct core_ops *ops;
 	void *cdev;
-	u32 ret = 0;
+	u32 ret = 0, i = 0, reg_val;
 
 #ifdef __KERNEL__
 
@@ -3267,6 +3266,33 @@ void *ethsw_api_core_init(ethsw_core_init_t *ethcinit)
 	/** TFlow Table Init */
 	pce_table_init(&PrvData->phandler);
 
+	if (!PrvData->num_of_global_rules) {
+		if (IS_VRSN_30_31_32(PrvData->gipver)) {
+			gsw_r32(cdev, PCE_TFCR_NUM_NUM_OFFSET,
+				PCE_TFCR_NUM_NUM_SHIFT,
+				PCE_TFCR_NUM_NUM_SIZE, &PrvData->num_of_global_rules);
+			PrvData->num_of_global_rules = PrvData->num_of_global_rules << 2;
+		} else if (IS_VRSN_BELOW_30(PrvData->gipver))
+			PrvData->num_of_global_rules = PrvData->tftblsize;
+	}
+
+	/* Mark the tflow global rule indexes are in  inuse */
+	for (i = 0; i < PrvData->num_of_global_rules; i++) {
+		PrvData->tflow_idx.flow_idx[i].indexinuse = 1;
+		PrvData->tflow_idx.usedentry++;
+		PrvData->tflow_idx.flow_idx[i].indexinusagecnt++;
+	}
+
+	if (IS_VRSN_30_31_32(PrvData->gipver)) {
+		/* First Entry of Common Region in TFLOW Table */
+		gsw_w32(cdev, PCE_TFCR_ID_INDEX_OFFSET, PCE_TFCR_ID_INDEX_SHIFT,
+			PCE_TFCR_ID_INDEX_SIZE, 0x0);
+		reg_val = PrvData->num_of_global_rules;
+		/* Number of Entries of Common Region in TFLOW Table */
+		gsw_w32(cdev, PCE_TFCR_NUM_NUM_OFFSET, PCE_TFCR_NUM_NUM_SHIFT,
+			PCE_TFCR_NUM_NUM_SIZE, (reg_val >> 2));
+	}
+
 	/** Parser Micro Code Init */
 #if defined(CONFIG_USE_EMULATOR)
 	gsw_w32(cdev, PCE_GCTRL_0_MC_VALID_OFFSET,
@@ -11813,6 +11839,10 @@ GSW_return_t GSW_CapGet(void *cdev, GSW_cap_t *parm)
 		parm->nCap = gswdev->num_of_bridge_port;
 		break;
 
+	case GSW_CAP_TYPE_COMMON_TFLOW_RULES:
+		parm->nCap = gswdev->num_of_global_rules;
+		break;
+
 	case GSW_CAP_TYPE_LAST:
 		parm->nCap = GSW_CAP_TYPE_LAST;
 		break;
@@ -18041,6 +18071,65 @@ GSW_return_t GSW_IrqStatusClear(void *cdev, GSW_irq_t *parm)
 	return GSW_statusOk;
 }
 
+/**
+ * GSW_PceRuleManage - To Manage the TFLOW Table Rule
+ * @cdev: device pointer
+ * @parm: parm Pointer to \ref GSW_PCE_rule_t
+ * Description: this is to Manage TFLOW Table Rule
+ */
+static GSW_return_t gsw_pcerulemanage(void *cdev, GSW_PCE_rule_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 idx, firstidx, lastidx;
+	int ret = GSW_statusOk;
+	GSW_CTP_portConfig_t ctpget;
+	/*TFlow table index */
+	idx = parm->pattern.nIndex;
+
+	if (!gswdev) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+	switch (parm->region) {
+	case GSW_TFLOW_COMMMON_REGION:
+		if (idx >= gswdev->num_of_global_rules) {
+			pr_err("\n\tERROR: Index %d is greater than common region Entries = %d\n",
+			       idx, gswdev->num_of_global_rules);
+			return GSW_statusErr;
+		}
+
+		break;
+
+	case GSW_TFLOW_CTP_REGION:
+		ctpget.nLogicalPortId = parm->logicalportid;
+		ctpget.nSubIfIdGroup = parm->subifidgroup;
+		ctpget.eMask =  GSW_CTP_PORT_CONFIG_FLOW_ENTRY;
+		GSW_CtpPortConfigGet(cdev, &ctpget);
+		firstidx = ctpget.nFirstFlowEntryIndex;
+		lastidx = ctpget.nFirstFlowEntryIndex + ctpget.nNumberOfFlowEntries;
+
+		if (idx < firstidx || idx >= lastidx) {
+			pr_err("\n\tERROR: Index %d is Didn't match CTP region Entries, StartEntryIndex = %d NumberofEntries = %d\n",
+			       idx, ctpget.nFirstFlowEntryIndex,
+				   ctpget.nNumberOfFlowEntries);
+			return GSW_statusErr;
+		}
+
+		break;
+
+	case GSW_TFLOW_DEBUG:
+		PCE_ASSERT(idx >= (gswdev->tftblsize));
+		break;
+
+	default:
+		pr_err("\n\tERROR: TFLOW Table doesn't support This Region\n");
+		return GSW_statusErr;
+	}
+
+	return ret;
+}
+
 GSW_return_t GSW_PceRuleRead(void *cdev, GSW_PCE_rule_t *parm)
 {
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
@@ -18051,6 +18140,8 @@ GSW_return_t GSW_PceRuleRead(void *cdev, GSW_PCE_rule_t *parm)
 		return  GSW_statusErr;
 	}
 
+	if (GSW_statusOk != gsw_pcerulemanage(cdev, parm))
+		return GSW_statusErr;
 #ifdef __KERNEL__
 	spin_lock_bh(&gswdev->lock_pce);
 #endif
@@ -18080,6 +18171,8 @@ GSW_return_t GSW_PceRuleWrite(void *cdev, GSW_PCE_rule_t *parm)
 		return GSW_statusErr;
 	}
 
+	if (GSW_statusOk != gsw_pcerulemanage(cdev, parm))
+		return GSW_statusErr;
 #ifdef __KERNEL__
 	spin_lock_bh(&gswdev->lock_pce);
 #endif
@@ -23888,7 +23981,7 @@ GSW_return_t GSW_CtpPortConfigSet(void *cdev, GSW_CTP_portConfig_t *param)
 	pctbl_prog_t tbl_prog_ctpport_ingress;
 	pctbl_prog_t tbl_prog_ctpport_egress;
 	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
-	u32 idx = 0, FirstIdx, LastIdx, pmapper_idx, ctp_port;
+	u32 idx = 0, FirstIdx, LastIdx, pmapper_idx, ctp_port, ctplastidx;
 	u32 BlkSize = 0;
 	u32 ret;
 	GSW_CTP_portAssignment_t ctp_get;
@@ -24785,6 +24878,42 @@ GSW_return_t GSW_CtpPortConfigSet(void *cdev, GSW_CTP_portConfig_t *param)
 	}
 
 	if (param->eMask & GSW_CTP_PORT_CONFIG_FLOW_ENTRY) {
+		if (param->nFirstFlowEntryIndex > gswdev->tftblsize) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/*Check whether this index is InUse
+		 *Since it will be marked as InUse during allocation.
+		 */
+		if (!gswdev->tflow_idx.flow_idx[param->nFirstFlowEntryIndex].indexinuse) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/*Check whether this index belongs to this BlockID
+		 *Since it will be marked during allocation.
+		 */
+		if (gswdev->tflow_idx.flow_idx[param->nFirstFlowEntryIndex].tflowblockid
+		    != param->nFirstFlowEntryIndex) {
+			ret = GSW_statusErr;
+			goto UNLOCK_AND_RETURN;
+		}
+
+		/*Search for the Last Index of this block.
+		 *Note: The Blocks are always allocated contiguously.
+		 */
+		ctplastidx = param->nFirstFlowEntryIndex;
+
+		while (gswdev->tflow_idx.flow_idx[ctplastidx].tflowblockid ==
+			   param->nFirstFlowEntryIndex &&
+			   gswdev->tflow_idx.flow_idx[ctplastidx].indexinuse) {
+			   ctplastidx++;
+		}
+
+		param->nNumberOfFlowEntries = ctplastidx - param->nFirstFlowEntryIndex;
+		gswdev->tflow_idx.flow_idx[param->nFirstFlowEntryIndex].indexinuse = 1;
+		gswdev->tflow_idx.flow_idx[param->nFirstFlowEntryIndex].indexinusagecnt++;
 		tbl_prog_ctpport_ingress.val[7] &= ~(0x7F << 2);
 		tbl_prog_ctpport_ingress.val[7] |= (param->nFirstFlowEntryIndex & 0x1FC);
 		tbl_prog_ctpport_ingress.val[8] &= ~(0xFF << 2);
@@ -25479,6 +25608,13 @@ GSW_return_t GSW_CtpPortConfigReset(void *cdev, GSW_CTP_portConfig_t *param)
 		gswdev->ctpportconfig_idx[ctp_port].IngressBridgeBypassPmappperIdx = 0;
 	}
 
+	param->nFirstFlowEntryIndex = (tbl_prog_ctpport_ingress.val[7] & 0x1FC);
+	param->nNumberOfFlowEntries = (tbl_prog_ctpport_ingress.val[8] & 0x3FC);
+
+	if (param->nNumberOfFlowEntries)
+		/*Release this TFLOW blk from this CTP Port*/
+		gswdev->tflow_idx.flow_idx[param->nFirstFlowEntryIndex].indexinusagecnt--;
+
 	/*Zero the ingress/egress ctp port table index*/
 	/*Same ctp port idx for ingress and egress ctp port configuration*/
 	memset(&tbl_prog_ctpport_ingress, 0, sizeof(pctbl_prog_t));
@@ -26492,6 +26628,179 @@ GSW_return_t GSW_UnFreeze(void)
 
 	return 0;
 }
+
+static u8 gsw_search_tflowcontiguousblock
+		(ethsw_api_dev_t *gswdev,
+		u32 blockid, u32 numberofentries)
+{
+	u32 i;
+
+	for (i = blockid; i <= (blockid + numberofentries); i++) {
+		if (gswdev->tflow_idx.flow_idx[i].indexinuse)
+			return 0;
+	}
+
+	return 1;
+}
+
+GSW_return_t gsw_tflow_alloc(void *cdev, gsw_tflow_alloc_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u16 tflowindex = 0;
+	u8 contiguousblockfound = 0;
+	u32 i, ret = GSW_statusOk;
+
+	if (!gswdev) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_alloc);
+#endif
+
+	parm->num_of_pcerules = (parm->num_of_pcerules + 3) & ~0x03;
+	if (parm->num_of_pcerules >
+		(gswdev->tftblsize -
+		gswdev->tflow_idx.usedentry)) {
+		pr_err(" nNumberOfRules requested is more than TFLOW index limit  %s:%s:%d",
+		       __FILE__, __func__, __LINE__);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*Allocate New Block as per the number of table Entries requested
+	 *The Block must be allocated with contiguous table index
+	 */
+	for (tflowindex = gswdev->num_of_global_rules;
+		tflowindex < gswdev->tftblsize  &&
+		!contiguousblockfound; tflowindex++) {
+		/*Table Index not in use*/
+		if (!gswdev->tflow_idx.flow_idx[tflowindex].indexinuse) {
+			contiguousblockfound =
+				gsw_search_tflowcontiguousblock
+				(gswdev, tflowindex, parm->num_of_pcerules);
+		}
+
+		/*Contiguous block found in the table*/
+		if (contiguousblockfound) {
+			parm->tflowblockid = tflowindex;
+
+			/*Mark the contiguous table indexes as InUse
+			 *and tag it with block id
+			 */
+			for (i = parm->tflowblockid; i <
+			     (parm->tflowblockid + parm->num_of_pcerules);
+				 i++) {
+				gswdev->tflow_idx.flow_idx[i].indexinuse = 1;
+				gswdev->tflow_idx.flow_idx[i].tflowblockid =
+				   parm->tflowblockid;
+				gswdev->tflow_idx.usedentry++;
+			}
+		}
+	}
+
+	/*Contiguous block not found in the table*/
+	if (!contiguousblockfound) {
+		pr_err(" ContiguousBlock NotFound %s:%s:%d",
+		       __FILE__, __func__, __LINE__);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_alloc);
+#endif
+	return ret;
+}
+
+GSW_return_t gsw_tflow_free(void *cdev, gsw_tflow_alloc_t *parm)
+{
+	ethsw_api_dev_t *gswdev = GSW_PDATA_GET(cdev);
+	u32 ret = GSW_statusOk, idx = 0;
+
+	if (!gswdev) {
+		pr_err("%s:%s:%d", __FILE__, __func__, __LINE__);
+		return GSW_statusErr;
+	}
+
+#ifdef __KERNEL__
+	spin_lock_bh(&gswdev->lock_pce);
+#endif
+
+	if (parm->tflowblockid >= gswdev->tftblsize) {
+		pr_err("tflowblockid %d out of range Supported num_of_tflowrules = %d]\n",
+		       parm->tflowblockid, gswdev->tftblsize);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*tflow blockid should be in use,if not in use return error*/
+	if (!gswdev->tflow_idx.flow_idx[parm->tflowblockid].indexinuse) {
+		pr_err("Blockid %u is Not inUse -> need to allocate before freeing\n",
+		       parm->tflowblockid);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*if this ntflowblockid usage count is not zero,
+	 *that means it is used by some one.
+	 * This Block can be deleted,
+	 *only if that some one release this block
+	 */
+	if (gswdev->tflow_idx.flow_idx[parm->tflowblockid].indexinusagecnt) {
+		pr_err("ERROR :TFLOW block %u is used by some resource,can not delete\n",
+		       parm->tflowblockid);
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	idx = parm->tflowblockid;
+	parm->num_of_pcerules = 0;
+
+	if (gswdev->tflow_idx.flow_idx[idx].tflowblockid !=
+	    parm->tflowblockid) {
+		ret = GSW_statusErr;
+		goto UNLOCK_AND_RETURN;
+	}
+
+	/*Condition to delete idx
+	 *	1. idx should belong to this block
+	 *	2. idx should be in Use
+	 *	3. idx should be with in valid TFLOW
+	 *	table range (Entry 0-511 is valid)
+	 */
+	while (gswdev->tflow_idx.flow_idx[idx].indexinuse &&
+	       idx < gswdev->tftblsize &&
+		   (gswdev->tflow_idx.flow_idx[idx].tflowblockid ==
+		   parm->tflowblockid)) {
+		/*free this idx and decrement the the number
+		 *of used table entries/idx
+		 */
+		gswdev->tflow_idx.flow_idx[idx].indexinuse = 0;
+		gswdev->tflow_idx.flow_idx[idx].tflowblockid =
+				TFLOW_ENTRY_INVALID;
+		gswdev->tflow_idx.usedentry--;
+		/*A reference for the user, how many entries has
+		 *been deleted in this block
+		 *debugging purpose
+		 */
+		parm->num_of_pcerules++;
+		/*increment the idx,since the block's allocation
+		 *in ADD is Contiguous
+		 */
+		idx++;
+	}
+
+UNLOCK_AND_RETURN:
+
+#ifdef __KERNEL__
+	spin_unlock_bh(&gswdev->lock_pce);
+#endif
+	return ret;
+}
 static GSW_return_t gsw_init_fn_ptrs(struct core_ops *ops)
 {
 
@@ -26556,6 +26865,10 @@ static GSW_return_t gsw_init_fn_ptrs(struct core_ops *ops)
 	ops->gsw_tflow_ops.TFLOW_PceRuleDelete			= GSW_PceRuleDelete;
 	ops->gsw_tflow_ops.TFLOW_PceRuleRead			= GSW_PceRuleRead;
 	ops->gsw_tflow_ops.TFLOW_PceRuleWrite			= GSW_PceRuleWrite;
+	ops->gsw_tflow_ops.tflow_pcealloc				=
+				gsw_tflow_alloc;
+	ops->gsw_tflow_ops.tflow_pcefree				=
+				gsw_tflow_free;
 
 	/*QOS operations*/
 	ops->gsw_qos_ops.QoS_MeterCfgGet				= GSW_QoS_MeterCfgGet;
@@ -26754,6 +27067,8 @@ static GSW_return_t gsw_init_fn_ptrs(struct core_ops *ops)
 	ops->gsw_debug_ops.DEBUG_Def_PceBypQmap			= GSW_Debug_PceBypassTable;
 	ops->gsw_debug_ops.DEBUG_GetLpStatistics		= GSW_Debug_GetLpStatistics;
 	ops->gsw_debug_ops.DEBUG_GetCtpStatistics 		= GSW_Debug_GetCtpStatistics;
+	ops->gsw_debug_ops.debug_tflowtablestatus       =
+				gsw_debug_tflow_tablestatus;
 	ops->gsw_debug_ops.Xgmac						= GSW_XgmacCfg;
 	ops->gsw_debug_ops.Gswss						= GSW_GswssCfg;
 	ops->gsw_debug_ops.Lmac							= GSW_LmacCfg;
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
index 6b1759a92608..2667be02daf0 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_flow_core.h
@@ -126,6 +126,7 @@ Where as CLEAR_FILL_CTRL_REG takes care of clear then fill.
 #define METER_TABLE_SIZE            128
 #define SHAPER_TABLE_SIZE           32
 #define PMAPPER_TABLE_SIZE          32
+#define GSW_TFLOW_TABLE_SIZE		512
 #define CLEAR_U16(var) var &= ((u16)~(0xFFFF))
 /*-------------------------------------*/
 
@@ -176,6 +177,8 @@ Where as CLEAR_FILL_CTRL_REG takes care of clear then fill.
 #define IS_VRSN_30_31(ver) \
 	((ver == LTQ_GSWIP_3_0) || (ver == LTQ_GSWIP_3_1))
 
+#define IS_VRSN_30_31_32(ver) \
+	((ver == LTQ_GSWIP_3_0) || (ver == LTQ_GSWIP_3_1) || (ver == LTQ_GSWIP_3_2))
 #define IS_VRSN_31_OR_32(ver) \
 	((ver == LTQ_GSWIP_3_1) || (ver == LTQ_GSWIP_3_2))
 
@@ -191,6 +194,11 @@ Where as CLEAR_FILL_CTRL_REG takes care of clear then fill.
     || (ver == LTQ_GSWIP_2_2) || (ver == LTQ_GSWIP_2_1) \
     || (ver == LTQ_GSWIP_2_0))
 
+/* Features compared with less than 3.0 GSWIP versions */
+#define IS_VRSN_BELOW_30(ver) \
+	((ver == LTQ_GSWIP_2_2_ETC)  || (ver == LTQ_GSWIP_2_2)\
+	 ||  (ver == LTQ_GSWIP_2_1) || (ver == LTQ_GSWIP_2_0))
+
 #define GSW_BRIDGE_PORT_SRC_IP_LOOKUP_DISABLE 1
 
 /*PHY Reg 0x4 */
@@ -505,6 +513,7 @@ typedef enum {
 #define BRDG_CONF_ENTRY_INVALID 0xFFFF
 #define BRDG_PORTCONF_ENTRY_INVALID 0xFFFF
 #define METER_ENTRY_INVALID 0xFFFF
+#define TFLOW_ENTRY_INVALID 0xFFFF
 
 typedef enum {
 	PCE_VLANFILTER_INDEX = 0x2,
@@ -897,6 +906,17 @@ struct pce_irq_linklist {
 };
 
 typedef struct {
+	u16 tflowblockid;
+	u8 indexinuse;
+	u16 indexinusagecnt;
+} gsw_tflow_entry_t;
+
+typedef struct {
+	gsw_tflow_entry_t flow_idx[GSW_TFLOW_TABLE_SIZE];
+	u16 usedentry;
+} gsw_tflow_t;
+
+typedef struct {
 	gsw_devtype_t	sdev;
 	port_config_t pconfig[MAX_PORT_NUMBER];
 	avlan_tbl_t avtable[VLAN_ACTIVE_TABLE_SIZE];
@@ -912,6 +932,7 @@ typedef struct {
 	gsw_meter_t meter_idx[METER_TABLE_SIZE];
 	gsw_shaper_t shaper_idx[SHAPER_TABLE_SIZE];
 	gsw_pmapper_t pmapper_idx[PMAPPER_TABLE_SIZE];
+	gsw_tflow_t tflow_idx;
 	void *raldev;
 	/*platform device struct*/
 	void *pdev;
@@ -981,6 +1002,7 @@ typedef struct {
 	void *gsw_base;  			/*Base address GSWITCH */
 	u32 gsw_mode;				/* GSWIP Mode 0 "short_cut", 1 "full_qos" */
 	u32 dpu;			        /* DPU = 1, pmac G.INT config, DPU = 0, Non-G.INT config */
+	u32 num_of_global_rules;    /* Number of Global(Common) TFLOW Rules */
 
 #ifdef __KERNEL__
 	spinlock_t lock_pce;
diff --git a/drivers/net/ethernet/lantiq/switch-api/gsw_ll_func.h b/drivers/net/ethernet/lantiq/switch-api/gsw_ll_func.h
index fe1e97cbedc0..a27fcfa196cf 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gsw_ll_func.h
+++ b/drivers/net/ethernet/lantiq/switch-api/gsw_ll_func.h
@@ -3252,6 +3252,9 @@ GSW_return_t GSW_CtpPortConfigReset(void *cdev, GSW_CTP_portConfig_t *parm);
 GSW_return_t GSW_DefaultMacFilterSet(void *cdev, GSW_MACFILTER_default_t *parm);
 GSW_return_t GSW_DefaultMacFilterGet(void *cdev, GSW_MACFILTER_default_t *parm);
 
+GSW_return_t gsw_tflow_alloc(void *cdev, gsw_tflow_alloc_t *parm);
+GSW_return_t gsw_tflow_free(void *cdev, gsw_tflow_alloc_t *parm);
+
 GSW_return_t GSW_Debug_CtpTableStatus(void *cdev, GSW_debug_t *parm);
 GSW_return_t GSW_Debug_BrgPortTableStatus(void *cdev, GSW_debug_t *parm);
 GSW_return_t GSW_Debug_BrgTableStatus(void *cdev, GSW_debug_t *parm);
@@ -3269,7 +3272,7 @@ GSW_return_t GSW_Debug_GetLpStatistics(void *cdev, GSW_debug_t *parm);
 GSW_return_t GSW_Debug_GetCtpStatistics(void *cdev, GSW_debug_t *parm);
 GSW_return_t  GSW_Debug_PrintPceIrqList(void *cdev);
 GSW_return_t GSW_Debug_RMON_Port_Get(void *cdev, GSW_Debug_RMON_Port_cnt_t *parm);
-
+GSW_return_t gsw_debug_tflow_tablestatus(void *cdev, GSW_debug_t *parm);
 
 
 GSW_return_t GSW_Irq_register(void *cdev, GSW_Irq_Op_t *irq);
diff --git a/drivers/net/ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c b/drivers/net/ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c
index fe3f192efba9..07b6e3addfa5 100644
--- a/drivers/net/ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c
+++ b/drivers/net/ethernet/lantiq/switch-api/gswip_dev/gsw_dev.c
@@ -26,6 +26,8 @@
 #define EXTERNAL_SWITCH_BASEADDR		"intel,gsw_ext-baseaddr"
 #define EXTERNAL_SWITCH_SGMIIBASEADDR   "intel,gsw_ext-sgmiibaseaddr"
 #define GSW_DPU                         "intel,gsw-dpu"
+#define GSW_GLOBAL_PCE_RULE_NUM         "intel,gsw-globalpce-rules"
+
 /* Structure for GSWIP Subsystem operations
  * used to start Sub-Functional Drivers
  */
@@ -316,6 +318,9 @@ static int gsw_add_switchdev(struct gsw_cell *gsw_dev_cell, u32 devid)
 
 	of_property_read_u32(gsw_dpu, GSW_DPU,
 			     &switch_pdata->dpu);
+	/* Get the Number of Common/Global TFLOW Rules */
+	of_property_read_u32(gsw_dev_cell->of_node, GSW_GLOBAL_PCE_RULE_NUM,
+			     &switch_pdata->num_of_global_rules);
 #ifndef CONFIG_OF
 
 	if (gsw_dev[devid].prod_id == GRX500) {
diff --git a/include/net/switch_api/gsw_flow_ops.h b/include/net/switch_api/gsw_flow_ops.h
index 7f0d83ee29fc..4b7bf8939b12 100644
--- a/include/net/switch_api/gsw_flow_ops.h
+++ b/include/net/switch_api/gsw_flow_ops.h
@@ -150,6 +150,10 @@ struct tflow_ops {
 	GSW_return_t (*TFLOW_PceRuleRead)(void *, GSW_PCE_rule_t *);
 	/* Command: GSW_PCE_RULE_WRITE ; Index: 0x03 */
 	GSW_return_t (*TFLOW_PceRuleWrite)(void *, GSW_PCE_rule_t *);
+	/* Command: GSW_TFLOW_ALLOC ; Index: 0x04 */
+	GSW_return_t (*tflow_pcealloc)(void *, gsw_tflow_alloc_t *);
+	/* Command: GSW_TFLOW_FREE ; Index: 0x05 */
+	GSW_return_t (*tflow_pcefree)(void *, gsw_tflow_alloc_t *);
 };
 
 /*QOS operations*/
@@ -581,6 +585,8 @@ struct debug_ops {
 	GSW_return_t (*DEBUG_RMON_Port_Get)(void *, GSW_Debug_RMON_Port_cnt_t *);
 	/* Command: GSW_DEBUG_TUNNELTEMP_STATUS ; Index: 0x18 */
 	GSW_return_t (*DEBUG_TunnelTempTableStatus)(void *, GSW_debug_t *);
+	/* Command: GSW_DEBUG_TFLOWTABLE_STATUS ; Index: 0x19 */
+	GSW_return_t (*debug_tflowtablestatus)(void *, GSW_debug_t *);
 };
 
 struct irq_ops {
diff --git a/include/net/switch_api/lantiq_gsw.h b/include/net/switch_api/lantiq_gsw.h
index f6461f7eea18..d8cc23f23572 100644
--- a/include/net/switch_api/lantiq_gsw.h
+++ b/include/net/switch_api/lantiq_gsw.h
@@ -1882,8 +1882,10 @@ typedef enum {
 	GSW_CAP_TYPE_CTP = 24,
 	/** Number of bridge ports - for GSWIP-3.1 only. */
 	GSW_CAP_TYPE_BRIDGE_PORT = 25,
+	/** Number of COMMON PCE Rules. */
+	GSW_CAP_TYPE_COMMON_TFLOW_RULES = 26,
 	/** Last Capability Index */
-	GSW_CAP_TYPE_LAST	= 26
+	GSW_CAP_TYPE_LAST	= 27
 } GSW_capType_t;
 
 /** \brief Capability structure.
@@ -4548,6 +4550,28 @@ typedef struct {
 	GSW_B_TAG_Config_t sBtag;
 } GSW_PBB_Tunnel_Template_Config_t;
 
+/** \brief TRAFFIC FLOW TABLE  Allocation.
+ *	Used by \ref GSW_TFLOW_ALLOC and \ref GSW_TFLOW_FREE.
+ */
+typedef struct {
+	/** Number of traffic flow table entries are
+	 * associated to CTP port.Ingress traffic from this CTP
+	 *	port will go through PCE rules search ending at
+	 *	(nFirstFlowEntryIndex+nNumberOfFlowEntries)-1. Should
+	 *	be times of 4. Proper value should be given
+	 *	for \ref GSW_TFLOW_ALLOC.
+	 *	This field is ignored for \ref GSW_TFLOW_FREE.
+	 */
+	u32 num_of_pcerules;
+	/** If \ref GSW_TFLOW_ALLOC is successful, a valid ID will be returned
+	 *  in this field. Otherwise, \ref INVALID_HANDLE is
+	 *	returned in this field.
+	 *  For \ref GSW_TFLOW_FREE, this field should be valid ID returned by
+	 *  \ref GSW_TFLOW_ALLOC.
+	 */
+	u32 tflowblockid;
+} gsw_tflow_alloc_t;
+
 /*@}*/ /* GSW_IOCTL_GSWIP31 */
 
 /* -------------------------------------------------------------------------- */
@@ -7687,6 +7711,7 @@ typedef struct {
 #define GSW_DEBUG_PRINT_PCEIRQ_LIST 		_IO(GSW_DEBUG_MAGIC, 0x16)
 #define GSW_DEBUG_RMON_PORT_GET				_IOWR(GSW_DEBUG_MAGIC, 0x17, GSW_Debug_RMON_Port_cnt_t)
 #define GSW_DEBUG_TUNNELTEMP_STATUS 		_IOWR(GSW_DEBUG_MAGIC, 0x18, GSW_debug_t)
+#define GSW_DEBUG_TFLOWTABLE_STATUS _IOWR(GSW_DEBUG_MAGIC, 0x19, GSW_debug_t)
 
 /**
    \brief Following are for GSWIP IRQ operation
diff --git a/include/net/switch_api/lantiq_gsw_flow.h b/include/net/switch_api/lantiq_gsw_flow.h
index f7fedd5b117a..8a551bc6eca9 100644
--- a/include/net/switch_api/lantiq_gsw_flow.h
+++ b/include/net/switch_api/lantiq_gsw_flow.h
@@ -885,6 +885,23 @@ typedef struct {
 	GSW_PCE_MacTableMacinMacSelect eMacTableMacinMacSelect;
 } GSW_PCE_ActionPBB_t;
 
+/** \brief Trafiic Flow Table Mangaement.
+ *   Used by \ref GSW_PCE_rule_t.
+ */
+typedef enum {
+	/** TFLOW TABLE COMMON Region Selection.
+	 *	The parameter 'nRegion' specifies the relative TFLOW Region.
+	 */
+	GSW_TFLOW_COMMMON_REGION = 0,
+	/** TFLOW TABLE CTP Region Selection.
+	 *  The parameter 'nRegion' specifies the relative TFLOW Region.
+	 */
+	GSW_TFLOW_CTP_REGION = 1,
+	/** TFLOW TABLE Debug selection */
+	GSW_TFLOW_DEBUG	= 2
+} gsw_tflowregion_t;
+
+
 /** \brief Packet Classification Engine Action Configuration.
     GSWIP-3.0 extension actions are explicitly indicated.
     Used by \ref GSW_PCE_rule_t. */
@@ -1079,6 +1096,14 @@ typedef struct {
 /** \brief Parameter to add/read a rule to/from the packet classification engine.
     Used by \ref GSW_PCE_RULE_WRITE and \ref GSW_PCE_RULE_READ. */
 typedef struct {
+	/** Logical Port Id. The valid range is hardware dependent. */
+	u32 logicalportid;
+	/** Sub interface ID group,
+	 *The valid range is hardware/protocol dependent.
+	 */
+	u32 subifidgroup;
+	/** PCE TABLE Region */
+	gsw_tflowregion_t region;
 	/** PCE Rule Pattern Part. */
 	GSW_PCE_pattern_t	pattern;
 	/** PCE Rule Action Part. */
@@ -1396,6 +1421,30 @@ typedef struct {
 */
 #define GSW_PCE_RULE_DELETE  _IOWR(GSW_TFLOW_MAGIC, 0x01, GSW_PCE_ruleDelete_t)
 
+/**
+ *\brief Allocate TFLOW  block.
+ *It allocates consecutive TFLOW configuration entries and return the block ID
+ *for further operations: \ref GSW_TFLOW_FREE.
+
+ *\param gsw_tflow_alloc_t Pointer to \ref gsw_tflow_alloc_t.
+
+ *\return Return value as follows:
+ *- GSW_statusOk: if successful
+ *- An error code in case an error occurs
+ */
+#define GSW_TFLOW_ALLOC	_IOWR(GSW_TFLOW_MAGIC, 0x04, gsw_tflow_alloc_t)
+/**
+ *\brief Release TFLOW Configuration block.
+ *It is used to release TFLOW Configuration block allocated by
+ *\ref GSW_TFLOW_ALLOC.
+
+ *\param gsw_tflow_alloc_t Pointer to \ref gsw_tflow_alloc_t.
+
+ *\return Return value as follows:
+ *- GSW_statusOk: if successful
+ *- An error code in case an error occurs
+ */
+#define GSW_TFLOW_FREE	_IOWR(GSW_TFLOW_MAGIC, 0x05, gsw_tflow_alloc_t)
 
 /*@}*/ /* GSW_IOCTL_CLASS */
 
