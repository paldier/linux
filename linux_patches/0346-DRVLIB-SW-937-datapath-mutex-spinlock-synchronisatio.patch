From 4a1f101f5a925e547bea27b63e9da6731a98132e Mon Sep 17 00:00:00 2001
From: Rekha Eswaran <rekha.eswaran@intel.com>
Date: Mon, 8 Oct 2018 17:48:19 +0800
Subject: [PATCH] DRVLIB_SW-937: datapath mutex/spinlock synchronisation review
 comments

---
 drivers/net/ethernet/lantiq/datapath/datapath.h    | 10 ++---
 .../net/ethernet/lantiq/datapath/datapath_api.c    | 15 ++-----
 .../net/ethernet/lantiq/datapath/datapath_misc.c   | 47 +++++++++++-----------
 .../net/ethernet/lantiq/datapath/datapath_swdev.c  |  4 --
 4 files changed, 33 insertions(+), 43 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/datapath/datapath.h b/drivers/net/ethernet/lantiq/datapath/datapath.h
index ae493af6611f..61c02a620db6 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath.h
+++ b/drivers/net/ethernet/lantiq/datapath/datapath.h
@@ -765,13 +765,13 @@ extern struct hlist_head dp_subif_list[DP_SUBIF_LIST_HASH_SIZE];
 int32_t dp_sync_subifid(struct net_device *dev, char *subif_name,
 			dp_subif_t *subif_id, struct dp_subif_data *data,
 			u32 flags);
-int32_t	dp_update_subif(struct net_device *netif, struct dp_subif_data *data,
-			dp_subif_t *subif, char *subif_name);
-int32_t	dp_del_subif(struct net_device *netif, struct dp_subif_data *data,
-		     dp_subif_t *subif, char *subif_name);
+int32_t	dp_update_subif(struct net_device *netif, void *data, dp_subif_t *subif,
+			char *subif_name, u32 flags);
+int32_t	dp_del_subif(struct net_device *netif, void *data, dp_subif_t *subif,
+		     char *subif_name, u32 flags);
 struct dp_subif_cache *dp_subif_lookup(struct hlist_head *head,
 				       struct net_device *dev,
-				       struct dp_subif_data *data);
+				       void *data);
 int dp_subif_list_init(void);
 u32 dp_subif_hash(struct net_device *dev);
 int32_t dp_get_netif_subifid_priv(struct net_device *netif,
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_api.c b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
index 3edbcdb33144..aba5fa92bca3 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_api.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_api.c
@@ -1048,7 +1048,7 @@ int32_t dp_get_netif_subifid(struct net_device *netif, struct sk_buff *skb,
 	struct dp_subif_cache *dp_subif;
 	u32 idx;
 	dp_get_netif_subifid_fn_t subifid_fn_t;
-	int res = -1;
+	int res = DP_FAILURE;
 
 	idx = dp_subif_hash(netif);
 	//TODO handle DSL case in future
@@ -1061,6 +1061,7 @@ int32_t dp_get_netif_subifid(struct net_device *netif, struct sk_buff *skb,
 		return res;
 	}
 	memcpy(subif, &dp_subif->subif, sizeof(dp_subif->subif));
+	rcu_read_unlock_bh();
 	subifid_fn_t = dp_subif->subif_fn;
 	if (subifid_fn_t) {
 		/*subif->subif will be set by callback api itself */
@@ -1068,11 +1069,9 @@ int32_t dp_get_netif_subifid(struct net_device *netif, struct sk_buff *skb,
 		    subifid_fn_t(netif, skb, subif_data, dst_mac, subif,
 				 flags);
 		if (res != 0)
-			DP_DEBUG(DP_DBG_FLAG_DBG,
-				 "get_netif_subifid callback failed\n");
+			PR_ERR("get_netif_subifid callback function failed\n");
 	}
-	rcu_read_unlock_bh();
-	return DP_SUCCESS;
+	return res;
 }
 EXPORT_SYMBOL(dp_get_netif_subifid);
 
@@ -1091,7 +1090,6 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 	int i, k;
 	int port_id = -1;
 	u16 bport = 0;
-	//dp_get_netif_subifid_fn_t subifid_fn_t;
 	int inst, start, end;
 	u8 match = 0;
 	u8 num = 0;
@@ -1138,7 +1136,6 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 	}
 #endif
 	subif->flag_pmapper = 0;
-	//DP_LIB_LOCK(&dp_lock);
 	for (k = start; k < end; k++) {
 		if (dp_port_info[inst][k].status != PORT_SUBIF_REGISTERED)
 			continue;
@@ -1160,7 +1157,6 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 				match = 1;
 				port_id = k;
 				if (num > 0) {
-					//DP_LIB_UNLOCK(&dp_lock);
 					PR_ERR("Multiple same ctp_dev exist\n");
 					goto EXIT;
 				}
@@ -1185,7 +1181,6 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 					subif->flag_bp = 1;
 					port_id = k;
 					if (num >= DP_MAX_CTP_PER_DEV) {
-						//DP_LIB_UNLOCK(&dp_lock);
 						PR_ERR("%s: Why CTP over %d\n",
 						       netif ? netif->name : "",
 						       DP_MAX_CTP_PER_DEV);
@@ -1227,7 +1222,6 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 					subif->inst = inst;
 					subif->port_id = k;
 					subif->bport = tmp->bp;
-					//DP_LIB_UNLOCK(&dp_lock);
 					res = 0;
 					/*note: logical device no callback */
 					goto EXIT;
@@ -1237,7 +1231,6 @@ int32_t dp_get_netif_subifid_priv(struct net_device *netif, struct sk_buff *skb,
 		if (match)
 			break;
 	}
-	//DP_LIB_UNLOCK(&dp_lock);
 
 	if (port_id < 0) {
 		if (subif_data)
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_misc.c b/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
index 829b7a49d752..3e1925fb3bb5 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_misc.c
@@ -1248,7 +1248,7 @@ int dp_subif_list_init(void)
 
 struct dp_subif_cache *dp_subif_lookup(struct hlist_head *head,
 				       struct net_device *dev,
-				       struct dp_subif_data *data)
+				       void *data)
 {
 	struct dp_subif_cache *item;
 
@@ -1265,8 +1265,8 @@ struct dp_subif_cache *dp_subif_lookup(struct hlist_head *head,
 	return NULL;
 }
 
-int32_t	dp_del_subif(struct net_device *netif, struct dp_subif_data *data,
-		     dp_subif_t *subif, char *subif_name)
+int32_t	dp_del_subif(struct net_device *netif, void *data, dp_subif_t *subif,
+		     char *subif_name, u32 flags)
 {
 	struct dp_subif_cache *dp_subif;
 	u32 idx;
@@ -1284,8 +1284,8 @@ int32_t	dp_del_subif(struct net_device *netif, struct dp_subif_data *data,
 	return 1;
 }
 
-int32_t	dp_update_subif(struct net_device *netif, struct dp_subif_data *data,
-			dp_subif_t *subif, char *subif_name)
+int32_t	dp_update_subif(struct net_device *netif, void *data,
+			dp_subif_t *subif, char *subif_name, u32 flags)
 {
 	struct dp_subif_cache *dp_subif_new, *dp_subif;
 	u32 idx;
@@ -1297,7 +1297,9 @@ int32_t	dp_update_subif(struct net_device *netif, struct dp_subif_data *data,
 	inst = subif->inst;
 	portid = subif->port_id;
 	port_info = &dp_port_info[inst][portid];
-	subifid_fn_t = port_info->cb.get_subifid_fn;
+	if (subifid_fn_t && !(flags & DP_F_SUBIF_LOGICAL)) {
+		subifid_fn_t = port_info->cb.get_subifid_fn;
+	}
 	vap = GET_VAP(subif->subif, port_info->vap_offset,
 		      port_info->vap_mask);
 
@@ -1311,8 +1313,7 @@ int32_t	dp_update_subif(struct net_device *netif, struct dp_subif_data *data,
 			dp_subif->dev = netif;
 			strncpy(dp_subif->name, subif_name,
 				sizeof(dp_subif->name) - 1);
-			if (subifid_fn_t)
-				dp_subif->subif_fn = subifid_fn_t;
+			dp_subif->subif_fn = subifid_fn_t;
 			hlist_add_head_rcu(&dp_subif->hlist,
 					   &dp_subif_list[idx]);
 			return 0;
@@ -1335,35 +1336,35 @@ int32_t dp_sync_subifid(struct net_device *dev, char *subif_name,
 			u32 flags)
 {
 /*Note: passing subif_name as subif_data to dp_get_netif_subifid_priv api */
-	char *subif_data;
+	void *subif_data;
 
-	subif_data = subif_name;
+	subif_data = (void *)subif_name;
 	/*check flag for register / deregister to update/del */
 	if (flags & DP_F_DEREGISTER) {
 		if (data->ctp_dev)
-			dp_del_subif(data->ctp_dev, data, subif_id, subif_name);
+			dp_del_subif(data->ctp_dev, subif_data, subif_id,
+				     subif_name, flags);
 
 		if (dp_get_netif_subifid_priv(dev, NULL, subif_data, NULL,
-					      subif_id, 0)) {
-			dp_del_subif(dev, data, subif_id, subif_name);
-		} else {
-			subif_id->subif_num--;
-			dp_update_subif(dev, data, subif_id, subif_name);
-		}
+					      subif_id, 0))
+			dp_del_subif(dev, subif_data, subif_id, subif_name, flags);
+		else
+			dp_update_subif(dev, subif_data, subif_id, subif_name,
+					flags);
 	} else {
 		if (dp_get_netif_subifid_priv(dev, NULL, subif_data,
-					      NULL, subif_id, 0))
+					      NULL, subif_id, 0)) {
+			PR_ERR("DP subif synchronization fail\n");
 			return DP_FAILURE;
-		if (!subif_id->subif_num)
-			subif_id->subif_num = 1;
-		dp_update_subif(dev, data, subif_id, subif_name);
+		}
+		dp_update_subif(dev, subif_data, subif_id, subif_name, flags);
 		if (data->ctp_dev) {
 			if (dp_get_netif_subifid_priv(data->ctp_dev, NULL,
 						      subif_data, NULL,
 						      subif_id,	0))
 				return DP_FAILURE;
-			dp_update_subif(data->ctp_dev, data, subif_id,
-					subif_name);
+			dp_update_subif(data->ctp_dev, subif_data, subif_id,
+					subif_name, flags);
 		}
 	}
 	return 0;
diff --git a/drivers/net/ethernet/lantiq/datapath/datapath_swdev.c b/drivers/net/ethernet/lantiq/datapath/datapath_swdev.c
index b29768f37816..87c7503ebeed 100644
--- a/drivers/net/ethernet/lantiq/datapath/datapath_swdev.c
+++ b/drivers/net/ethernet/lantiq/datapath/datapath_swdev.c
@@ -41,7 +41,6 @@ static int dp_swdev_del_bport_from_list(struct br_info *br_item,
 
 struct hlist_head
 	g_bridge_id_entry_hash_table[DP_MAX_INST][BR_ID_ENTRY_HASH_TABLE_SIZE];
-//static spinlock_t dp_swdev_lock;
 
 #ifdef DP_SPIN_LOCK
 static DEFINE_SPINLOCK(dp_swdev_lock); /*datapath spinlock*/
@@ -51,13 +50,11 @@ static DEFINE_MUTEX(dp_swdev_lock);
 
 static inline void swdev_lock(void)
 {
-	//spin_lock_bh(&dp_swdev_lock);
 	DP_LIB_LOCK(&dp_swdev_lock);
 }
 
 static inline void swdev_unlock(void)
 {
-	//spin_unlock_bh(&dp_swdev_lock);
 	DP_LIB_UNLOCK(&dp_swdev_lock);
 }
 
@@ -183,7 +180,6 @@ int dp_swdev_bridge_id_entry_init(void)
 {
 	int i, j;
 
-	//spin_lock_init(&dp_swdev_lock);
 	for (i = 0; i < DP_MAX_INST; i++)
 		for (j = 0; j < BR_ID_ENTRY_HASH_TABLE_SIZE; j++)
 			INIT_HLIST_HEAD(&g_bridge_id_entry_hash_table[i][j]);
