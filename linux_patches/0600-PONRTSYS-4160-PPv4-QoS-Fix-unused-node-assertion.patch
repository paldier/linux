From d00e843f9407c0d36fc28e20ecd0320b96ac5e6f Mon Sep 17 00:00:00 2001
From: ofirbitt <ofir1.bitton@intel.com>
Date: Tue, 14 May 2019 08:48:43 +0300
Subject: [PATCH] PONRTSYS-4160: PPv4 QoS - Fix unused node assertion

---
 .../net/ethernet/lantiq/ppv4/qos/pp_qos_debugfs.c  |  66 +---------
 .../net/ethernet/lantiq/ppv4/qos/pp_qos_linux.c    |   3 +-
 drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c |   4 +-
 .../net/ethernet/lantiq/ppv4/qos/pp_qos_utils.c    | 139 +++++++++++++++++++--
 .../net/ethernet/lantiq/ppv4/qos/pp_qos_utils.h    |   4 +
 5 files changed, 136 insertions(+), 80 deletions(-)

diff --git a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_debugfs.c b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_debugfs.c
index 987d0ed24250..63cfcc998284 100644
--- a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_debugfs.c
+++ b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_debugfs.c
@@ -44,7 +44,6 @@ static struct {
 
 #define PP_QOS_DEBUGFS_DIR "ppv4_qos"
 #define PP_QOS_DBG_MAX_BUF	(1024)
-#define PP_QOS_DBG_MAX_INPUT	(64)
 
 static ssize_t add_shared_bwl_group(struct file *file, const char __user *buf,
 				    size_t count, loff_t *pos)
@@ -1180,56 +1179,6 @@ static const struct file_operations debug_pstat_fops = {
 	.release = single_release,
 };
 
-#define ARB_STR(a)                             \
-	((a) == PP_QOS_ARBITRATION_WSP ? "WSP" : \
-	 (a) == PP_QOS_ARBITRATION_WRR ? "WRR" :  \
-	 (a) == PP_QOS_ARBITRATION_WFQ ? "WFQ" :  \
-	 "Unknown")
-
-static void __dbg_dump_subtree(struct pp_qos_dev *qdev,
-			       struct qos_node *node,
-			       u32 depth,
-			       struct seq_file *s)
-{
-	u32 idx, tab_idx, n = 0;
-	u32 child_phy, node_id;
-	char tabs_str[PP_QOS_DBG_MAX_INPUT];
-	bool last_child;
-	struct qos_node *child;
-
-	if (depth > 6) {
-		pr_err("Maximum depth of 6 exceeded\n");
-		return;
-	}
-
-	tabs_str[0] = '\0';
-	for (tab_idx = 0 ; tab_idx < depth ; tab_idx++)
-		n += snprintf(tabs_str + n, PP_QOS_DBG_MAX_INPUT - n, "|\t");
-
-	for (idx = 0; idx < node->parent_prop.num_of_children ; ++idx) {
-		last_child = (idx == (node->parent_prop.num_of_children - 1));
-		child_phy = node->parent_prop.first_child_phy + idx;
-		node_id = get_id_from_phy(qdev->mapping, child_phy);
-		child = get_node_from_phy(qdev->nodes, child_phy);
-
-		if (last_child)
-			seq_printf(s, "%s'-- ", tabs_str);
-		else
-			seq_printf(s, "%s|-- ", tabs_str);
-
-		if (node_sched(child)) {
-			seq_printf(s, "Sched-%u(%u)-%s\n",
-				   node_id, child_phy,
-				   ARB_STR(child->parent_prop.arbitration));
-			__dbg_dump_subtree(qdev, child, depth + 1, s);
-		} else if (node_queue(child)) {
-			seq_printf(s, "Queue-%u(%u)-rlm-%u\n",
-				   node_id, child_phy,
-				   child->data.queue.rlm);
-		}
-	}
-}
-
 /**
  * @brief dump complete qos tree
  */
@@ -1238,8 +1187,6 @@ static int pp_qos_dbg_tree_show(struct seq_file *s, void *unused)
 	struct platform_device *pdev;
 	struct pp_qos_drv_data *pdata;
 	struct pp_qos_dev *qdev;
-	struct qos_node *node;
-	u32 node_id, node_phy;
 
 	pdev = s->private;
 
@@ -1257,18 +1204,7 @@ static int pp_qos_dbg_tree_show(struct seq_file *s, void *unused)
 		return 0;
 	}
 
-	/* Iterate through all port nodes */
-	for (node_phy = 0; node_phy < NUM_OF_NODES; ++node_phy) {
-		node = get_node_from_phy(qdev->nodes, node_phy);
-		node_id = get_id_from_phy(qdev->mapping, node_phy);
-		if (node_port(node)) {
-			seq_printf(s, "|-- Port-%u(%u)-%s\n",
-				   node_id,
-				   get_phy_from_id(qdev->mapping, node_id),
-				   ARB_STR(node->parent_prop.arbitration));
-			__dbg_dump_subtree(qdev, node, 1, s);
-		}
-	}
+	qos_dbg_tree_show(qdev, s);
 
 	return 0;
 }
diff --git a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_linux.c b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_linux.c
index 71e0bcf08922..6eae19c12e5f 100644
--- a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_linux.c
+++ b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_linux.c
@@ -55,8 +55,9 @@ void stop_run(void)
 	struct pp_qos_drv_data *pdata;
 
 	if (cur_dev) {
-		dev_err(cur_dev, "!!!!! Qos driver in unstable mode !!!!!\n");
+		dev_err(cur_dev, "QoS Assertion\n");
 		pdata = dev_get_drvdata(cur_dev);
+		qos_dbg_tree_show(pdata->qdev, NULL);
 		QOS_BITS_SET(pdata->qdev->flags, PP_QOS_FLAGS_ASSERT);
 	}
 }
diff --git a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c
index f1378b93190f..a5426e1c826a 100644
--- a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c
+++ b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_main.c
@@ -1609,6 +1609,8 @@ static void node_sched_init(struct pp_qos_dev *qdev, struct qos_node *node)
 {
 	node_init(qdev, node, 1, 1, 1);
 	node->type = TYPE_SCHED;
+	node->data.sched.new_child_phy = QOS_UNKNOWN_PHY;
+	node->data.sched.new_child_skipped = 0;
 }
 
 STATIC_UNLESS_TEST int sched_cfg_valid(
@@ -2297,7 +2299,7 @@ int pp_qos_dev_init(struct pp_qos_dev *qdev, struct pp_qos_init_param *conf)
 	}
 
 	QOS_LOG_DEBUG("wred total resources\t%u\n",
-			qdev->hwconf.wred_total_avail_resources);
+		      qdev->hwconf.wred_total_avail_resources);
 	QOS_LOG_DEBUG("qm_ddr_start\t\t0x%08X\n", qdev->hwconf.qm_ddr_start);
 	QOS_LOG_DEBUG("qm_num_of_pages\t\t%u\n", qdev->hwconf.qm_num_pages);
 	QOS_LOG_DEBUG("clock\t\t\t%u\n", qdev->hwconf.qos_clock);
diff --git a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_utils.c b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_utils.c
index b3d5174fa622..5c5b25cf70fd 100644
--- a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_utils.c
+++ b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_utils.c
@@ -396,11 +396,9 @@ int cmd_queue_put(struct cmd_queue *q, void *_cmd, size_t size)
 
 	cmd = _cmd;
 
-	if (CMD_QUEUE_SIZE - q->count < size) {
-		QOS_LOG_ERR("%lu bytes free, can't accommodate %zu bytes\n",
-				CMD_QUEUE_SIZE - q->count, size);
-		return -1;
-	}
+	QOS_ASSERT(CMD_QUEUE_SIZE - q->count >= size,
+		   "%lu bytes free, can't accommodate %zu bytes\n",
+		   CMD_QUEUE_SIZE - q->count, size);
 
 	toend = CMD_QUEUE_SIZE - q->write;
 	if (toend >= size) {
@@ -429,7 +427,7 @@ static int cmd_queue_read(struct cmd_queue *q,
 
 	if (q->count < size) {
 		QOS_LOG_DEBUG("has only %zu bytes, can't retrieve %zu bytes\n",
-				q->count, size);
+			      q->count, size);
 		return -1;
 	}
 
@@ -1033,6 +1031,9 @@ STATIC_UNLESS_TEST void nodes_move(struct pp_qos_dev *qdev,
 	const struct qos_node *node;
 #endif
 
+	QOS_LOG_DEBUG("src_phy %u. dst_phy %u. count %u\n",
+		      src_phy, dst_phy, count);
+
 	QOS_ASSERT(src_phy != dst_phy,
 			"src and dst are the same %u\n",
 			src_phy);
@@ -1089,8 +1090,10 @@ STATIC_UNLESS_TEST void nodes_move(struct pp_qos_dev *qdev,
 		/* Issue update preds each node whose ancestor moved */
 		ances_size = parents_span(qdev->nodes, 0, dst_phy, count,
 				ancestors, MAX_MOVING_NODES);
+
 		for (i = 0; i < ances_size; ++i)
 			tree_update_predecessors(qdev, ancestors[i]);
+
 	#if 0
 		for (i = 0; i < suspend_size; ++i)
 			create_resume_cmd(qdev, suspend[i]);
@@ -1357,8 +1360,8 @@ static void send_bw_weight_command(struct pp_qos_dev *qdev,
 	uint32_t modified = 0;
 
 	QOS_LOG_DEBUG("child %u: Sending new BW weight %d\n",
-			get_phy_from_node(qdev->nodes, child),
-			bw_weight);
+		      get_phy_from_node(qdev->nodes, child),
+		      bw_weight);
 
 	QOS_BITS_SET(modified, QOS_MODIFIED_BW_WEIGHT);
 
@@ -1633,11 +1636,21 @@ static int post_order_travers_tree(struct pp_qos_dev *qdev,
 
 	total = 0;
 	node = get_node_from_phy(qdev->nodes, root);
-	QOS_ASSERT(node_used(node), "Unused node\n");
+	QOS_ASSERT(node_used(node), "Unused node with phy %u\n", root);
 
 	if (node_parent(node)) {
 		for (i = 0; i < node->parent_prop.num_of_children; ++i) {
 			phy = node->parent_prop.first_child_phy + i;
+
+			/* Do not try to update the about to be added child */
+			if (node_sched(node) &&
+			    (node->data.sched.new_child_phy == phy)) {
+				node->data.sched.new_child_skipped = 1;
+				QOS_LOG_DEBUG("Skipping child %u (Sched %u)\n",
+					      phy, root);
+				continue;
+			}
+
 			total += post_order_travers_tree(qdev, phy, conform,
 					cdata, operation, odata);
 		}
@@ -2378,6 +2391,12 @@ static unsigned int children_on_non_full_octet(
 	unsigned int phy;
 
 	phy = calculate_new_child_location(qdev, parent, child_priority);
+
+	if (node_sched(parent)) {
+		parent->data.sched.new_child_phy = phy;
+		parent->data.sched.new_child_skipped = 0;
+	}
+
 	octet_nodes_shift(qdev, phy, usage - octet_phy_offset(phy), 1);
 	return phy;
 }
@@ -2452,7 +2471,6 @@ static unsigned int has_less_than_8_children_on_full_octet(
 	src_phy =  min_parent->parent_prop.first_child_phy;
 	nodes_move(qdev, dst_phy, src_phy, num_of_nodes_to_move);
 
-
 	/*
 	 * shift original octet if necessary i.e. if last moved
 	 * node was not last node on octet
@@ -2495,7 +2513,8 @@ static unsigned int phy_alloc_parent_has_less_than_8_children(
 		   get_phy_from_node(qdev->nodes, parent));
 
 	parent_id = get_id_from_phy(qdev->mapping,
-			get_phy_from_node(qdev->nodes, parent));
+				    get_phy_from_node(qdev->nodes, parent));
+
 	if (parent->parent_prop.num_of_children == 0) {
 		octet = octet_get_with_at_least_free_entries(qdev->octets, 1);
 		if (!QOS_OCTET_VALID(octet)) {
@@ -2519,8 +2538,29 @@ static unsigned int phy_alloc_parent_has_less_than_8_children(
 					octet,
 					child_priority);
 	}
-	if (QOS_PHY_VALID(phy))
+
+	parent = get_node_from_phy(qdev->nodes,
+				   get_phy_from_id(qdev->mapping, parent_id));
+
+	if (QOS_PHY_VALID(phy)) {
 		link_with_parent(qdev, phy, parent_id);
+		if (node_sched(parent) &&
+		    QOS_PHY_VALID(parent->data.sched.new_child_phy)) {
+			QOS_LOG_DEBUG("Sched %u(%u). phy %u. skipped %u\n",
+				      parent_id,
+				      get_phy_from_node(qdev->nodes, parent),
+				      phy,
+				      parent->data.sched.new_child_skipped);
+
+			/* We must update preds of the skipped child */
+			if (parent->data.sched.new_child_skipped)
+				tree_update_predecessors(qdev, phy);
+
+			/* Remove new child listing from sched db */
+			parent->data.sched.new_child_phy = QOS_UNKNOWN_PHY;
+			parent->data.sched.new_child_skipped = 0;
+		}
+	}
 	return phy;
 }
 
@@ -2764,7 +2804,7 @@ int check_sync_with_fw(struct pp_qos_dev *qdev)
 int qos_device_ready(const struct pp_qos_dev *qdev)
 {
 	if (PP_QOS_DEVICE_IS_ASSERT(qdev)) {
-		QOS_LOG_CRIT("!!!!! Qos driver in unstable mode !!!!!\n");
+		QOS_LOG_CRIT("Qos fatal event occurred\n");
 		return 0;
 	}
 
@@ -2878,3 +2918,76 @@ void update_children_position(
 	if (node_parent(child))
 		tree_update_predecessors(qdev, new_phy);
 }
+
+#define ARB_STR(a)                             \
+	((a) == PP_QOS_ARBITRATION_WSP ? "WSP" : \
+	 (a) == PP_QOS_ARBITRATION_WRR ? "WRR" :  \
+	 (a) == PP_QOS_ARBITRATION_WFQ ? "WFQ" :  \
+	 "Unknown")
+
+#define QOS_DBG_PRINT(s, msg, ...) (s ? seq_printf(s, msg, ##__VA_ARGS__) : \
+				    pr_info(msg, ##__VA_ARGS__))
+
+void __dbg_dump_subtree(struct pp_qos_dev *qdev,
+			struct qos_node *node,
+			u32 depth,
+			struct seq_file *s)
+{
+	u32 idx, tab_idx, n = 0;
+	u32 child_phy, node_id;
+	char tabs_str[PP_QOS_DBG_MAX_INPUT];
+	char indent_str[PP_QOS_DBG_MAX_INPUT];
+	bool last_child;
+	struct qos_node *child;
+
+	if (depth > 6) {
+		pr_err("Maximum depth of 6 exceeded\n");
+		return;
+	}
+
+	tabs_str[0] = '\0';
+	for (tab_idx = 0 ; tab_idx < depth ; tab_idx++)
+		n += snprintf(tabs_str + n, PP_QOS_DBG_MAX_INPUT - n, "|\t");
+
+	for (idx = 0; idx < node->parent_prop.num_of_children ; ++idx) {
+		last_child = (idx == (node->parent_prop.num_of_children - 1));
+		child_phy = node->parent_prop.first_child_phy + idx;
+		node_id = get_id_from_phy(qdev->mapping, child_phy);
+		child = get_node_from_phy(qdev->nodes, child_phy);
+
+		if (last_child)
+			snprintf(indent_str, "%s'-- ", tabs_str);
+		else
+			snprintf(indent_str, "%s|-- ", tabs_str);
+
+		if (node_sched(child)) {
+			QOS_DBG_PRINT(s, "%sSched-%u(%u)-%s\n",
+				   indent_str, node_id, child_phy,
+				   ARB_STR(child->parent_prop.arbitration));
+			__dbg_dump_subtree(qdev, child, depth + 1, s);
+		} else if (node_queue(child)) {
+			QOS_DBG_PRINT(s, "%sQueue-%u(%u)-rlm-%u\n",
+				   indent_str, node_id, child_phy,
+				   child->data.queue.rlm);
+		}
+	}
+}
+
+void qos_dbg_tree_show(struct pp_qos_dev *qdev, struct seq_file *s)
+{
+	struct qos_node *node;
+	u32 node_id, node_phy;
+
+	/* Iterate through all port nodes */
+	for (node_phy = 0; node_phy < NUM_OF_NODES; ++node_phy) {
+		node = get_node_from_phy(qdev->nodes, node_phy);
+		node_id = get_id_from_phy(qdev->mapping, node_phy);
+		if (node_port(node)) {
+			QOS_DBG_PRINT(s, "|-- Port-%u(%u)-%s\n",
+				      node_id,
+				      get_phy_from_id(qdev->mapping, node_id),
+				      ARB_STR(node->parent_prop.arbitration));
+			__dbg_dump_subtree(qdev, node, 1, s);
+		}
+	}
+}
diff --git a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_utils.h b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_utils.h
index d1106fa2d917..6a2390e3c38c 100644
--- a/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_utils.h
+++ b/drivers/net/ethernet/lantiq/ppv4/qos/pp_qos_utils.h
@@ -42,6 +42,7 @@
 #define QOS_MAX_SHARED_BW_GRP QOS_MAX_SHARED_BANDWIDTH_GROUP
 
 #define MAX_QOS_INSTANCES 1U
+#define PP_QOS_DBG_MAX_INPUT (64)
 
 /* for calculating number of ddr pages for qm from resource size */
 #define PPV4_QOS_DESC_SIZE (16U)
@@ -141,6 +142,8 @@ struct qos_node {
 			int		disable;
 		} port;
 		struct {
+			uint16_t	new_child_phy;
+			uint8_t		new_child_skipped;
 		} sched;
 		struct _queue {
 			uint32_t	green_min;
@@ -279,6 +282,7 @@ struct qos_dev_init_info {
 /******************************************************************************/
 #define QOS_LOG(format, arg...) QOS_LOG_DEBUG(format, ##arg)
 void stop_run(void);
+void qos_dbg_tree_show(struct pp_qos_dev *qdev, struct seq_file *s);
 
 #ifdef __KERNEL__
 #define QOS_ASSERT(condition, format... )				\
